answer_id,answer_body,answer_vote,question_id
2184204,"
Some of the reasons why you may want to provide a custom sorting function are:

You are using a little-endian system (such as x86) and you are using integers as your database's keys. Berkeley DB stores keys as byte strings and little-endian integers do not sort well when viewed as byte strings. There are several solutions to this problem, one being to provide a custom comparison function. See http://www.oracle.com/technology/documentation/berkeley-db/db/ref/am_misc/faq.html for more information.

You set a BTree's key  comparison function  using DB->set_bt_compare().  
For example, an example routine that is used to sort integer keys in the database is:
",4,1572427
1572568,"
I think you have to create a secondary index for your data.  
I had tried Sleeping Cat Berkeley Database (due to code maintenance) but I did not try secondary indices.
If perfomance isn't so critical and you can switch database engine, I recommend SQLite :-)
",0,1572427
1557636,"
Similar to ltcmelo's example, but if the objects themselves don't contain the counter:
If your counter is an external variable like that though it won't affect the ordering (at least if it's positive - thanks onebyone!) - so this may in fact not be necessary at all (or maybe I misunderstand what you're after?). It's a useful technique in other cases though.
",4,1557570
1557641,"
Create a functor, and store the extra value in the functor object:
",1,1557570
1557603,"
Just create an function-object, a class/struct with an overload of operator() that does the right thing for you. In this case, taking into consideration the extra variables. Then, you pass an instance of it to the sort method.
EDIT: I just noticed that you have a list of pointers so I changed a bit the struct.
",0,1557570
1541909,"
This may be unrelated to your segmentation fault, but...
In C++, your ""compare"" predicate must be a strict weak ordering.  In particular, ""compare(X,X)""
must return ""false"" for any X.  In your compare function, if both pairs are identical, you hit the test (p1.first <= p2.first) , and return ""true"".  Therefore, this ""compare"" predicate does not impose a strict weak ordering, and the result of passing it to ""sort"" is undefined.
",42,1541817
1541832,"
Try using all the values from n = 32766 up to 32770. I suspect you'll find that you are experiencing some sort of overflow. This is because 2^15 (32768) is the biggest number that can be represented using 16 bits (assuming you also allow negative numbers). You will have to use a different data type.
Suggestion:
Get it to output the vector's maxsize:
Let us know what that does. All things being normal, I'd expect it to be in the hundreds of millions (536870911 on my computer). But if it's more like 32768, then that could be the problem.
",3,1541817
52735565,"
C++ acts weird sometimes. I got Segmentation fault in basic_string.h file! I was upgrading my code base to GCC 5.4.0 from GCC 4.2.1 and suddenly this SEG FAULT occurred and I was wondering why the same code was working earlier and now it is breaking inside C++ own STL. Then I looked up the back trace and found that it was coming from std::sort for vector of pointers, which was using custom comparator to compare the pointers on the basis of fetching the object's name by member function ptr->GetName(). This GetName() was returning a string.
I spent a whole day on figuring out what maybe the change in basic_string file to cause this fault. Then I got to know about this ""Strict Weak Ordering"" thing and I changed my comparator function accordingly. Still no luck.
Then I tweaked around and changed the original comparator function to a Functor. And now, it worked. I don't know exactly the reason behind it but it worked.
Here is my original comparator function : 
And here is the new Function Object.
Same logic, but it works with Function Object.
",-2,1541817
1453758,"
That's called alphanumeric sorting.
Check out this link: The Alphanum Algorithm
",5,1453725
1786422,"
i think u can use a pair object and then make vector > and then sort this vector.
Pairs are compared based on their first elements. So, this way you can get the sort you desire.
",0,1453725
1437853,"
You can use std::sort with a function (or functor object) that provides a strict weak ordering for vectors.  I.e. you define a vector-less-than function that orders two vectors correctly, something like this (off the top of my head).
Edit: after comments, added checking for one or two empty vectors, which does make things trickier.
",7,1437816
1437845,"
Use a simple std::sort and pass a functor that compares only the vector's last elements.

Partial_sort rearranges the elements in the range [first, last) so that they are partially in ascending order. Specifically, it places the smallest middle - first elements, sorted in ascending order, into the range [first, middle). The remaining last - middle elements are placed, in an unspecified order, into the range [middle, last).

",6,1437816
1437847,"
You can pass along a comparator as the fourth argument to std::partial_sort or std::sort, so just write a function object with a call operator taking two vector arguments that compare your vectors the way you want to.
",2,1437816
1434438,"
You need iterators into your array and some sorting criterion. Let's start with the iterators: 
You will need a begin iterator and an end iterator. The begin iterator needs to point to the first element, the end iterator needs to point behind the last element. Pointers are perfect iterators. An array is implicitly convertible into a pointer to its first element, so you have a begin iterator. Add the number of elements in the array to it and you have an end iterator. The number of elements in the array can be obtained by dividing the size (number of bytes) of the array by the size of a single element. Putting it all together: 
Now you need something for the algorithm to decide which of two given objects of your class is the smaller one. An easy way to do this would be by overloading operator< for your class: 
Now you can sort your array: 
If the sorting criterion isn't as fix (say, sometimes you want to sort based on foo's bar data, sometimes based on its wrgly data), you can pass different sorting criteria to the sort algorithm as an optional third parameter. Sorting criteria should be function-like entities. That can be functions or function objects. The latter provide inlining, which is why they are usually better. Here's both: 
This is how you use them: 
You can also create the comparator on the fly: 
Edit: Here's a few more hints based on your expanded question: 
sortContainer * sortList = new sortContiner [length]; will create a dynamic array on the heap. In C++, there is no garbage collection and you are responsible for cleaning up on the heap after yourself (in this case by invoking delete[] sortList;). This is notoriously hard to do for novices and error-prone even for seasoned programmers. There's a very good chance that what you want is an automatic array: sortContainer sortList[length]; on the stack. 
The identifier sortContainer tells me that the thing is a container. However, it's the type of the items to be put into the container. Be more careful by picking identifiers. Proper naming goes a long way towards readable and maintainable code. 
",5,1434343
1434370,"
You can put the objects in container ( say, std::vector) and write a functor and use the same in stable_sort.
Edit: 
Using arrays ( as @sbi and @wrang-wrang suggested):
OR write operator < for your class and straight way call stable_sort
",4,1434343
1434446,"
Here's the declaration of stable_sort():
You have to use the second overload and provide you own comparison functor. Something along the lines:
It could also be a free function - anything that you can apply () to, like:
Then you sorting statement would be:
Note that objects of your type have to freely copyable.
Look here for details.
",2,1434343
1434388,"
You must write your own predicate and pass it to the standard algorithm.
",1,1434343
1434522,"
As a complement to the other answers: The predicate can be created on the fly with boost (or tr1) bind. For example, to sort by the ""key"" member:
",1,1434343
1434633,"
I see there are already a couple of solutions, but since I typed mine already, I want to post it anyway. This is a little working solution to give you an idea:
The output should be something like this
",1,1434343
1434431,"
You can something like this: The code is self explanatory:
",0,1434343
1412792,"
You could either initialize largest and second to an appropriate lower bound, or to the first two items in the list (check which one is bigger, and don't forget to check if the list has at least two items)
",20,1412751
1412779,"
using partial_sort ?
An Example:
",21,1412751
1412841,"
nth_element(begin, begin+n,end,Compare) places the element that would be nth (where ""first"" is ""0th"") if the range [begin, end) were sorted at position begin+n and makes sure that everything from [begin,begin+n) would appear before the nth element in the sorted list.  So the code you want is:
This will work well in your case, since you're only looking for the two largest.  Assuming your appropriateCompare sorts things from largest to smallest, the second largest element with be at position 1 and the largest will be at position 0. 
",7,1412751
1412782,"
Lets assume you mean to find the two largest unique values in the list.
If the list is already sorted, then just look at the second last element (or rather, iterate from the end looking for the second last value).
If the list is unsorted, then don't bother to sort it.  Sorting is at best O(n lg n).  Simple linear iteration is O(n), so just loop over the elements keeping track:
There are of course other criteria, and these could all be put into the test inside the loop.  However, should you mean that two elements that both have the same largest value should be found, you have to consider what happens should three or more elements all have this largest value, or if two or more elements have the second largest.
",2,1412751
1412839,"
The answer depends if you just want the values, or also iterators pointing at the values.
Minor modification of @will answer.
",1,1412751
1412889,"
The optimal algorithm shouldn't need more than 1.5 * N - 2 comparisons. (Once we've decided that it's O(n), what's the coefficient in front of N? 2 * N comparisons is less than optimal).
So, first determine the ""winner"" and the ""loser"" in each pair - that's 0.5 * N comparisons.
Then determine the largest element by comparing winners - that's another 0.5 * N - 1 comparisons.
Then determine the second-largest element by comparing the loser of the pair where the largest element came from against the winners of all other pairs - another 0.5 * N - 1 comparisons.
Total comparisons = 1.5 N - 2.
",1,1412751
1412773,"
Create a sublist from n..m, sort it descending. Then grab the first two elements. Delete these elements from the orginal list.
",0,1412751
1412811,"
You can scan the list in one pass and save the 1st and 2nd values, that has a O(n) efficiency while sorting is O(n log n).
EDIT:
I think that partial sort is O(n log k)
",0,1412751
1412892,"
Untested but fun:
",0,1412751
1412988,"
If the largest is the first element, search for the second largest in [largest+1,end). Otherwise search in [begin,largest) and [largest+1,end) and take the maximum of the two. Of course, this has O(2n), so it's not optimal. 
If you have random-access iterators, you could do as quick sort does and use the ever-elegant recursion: 
This has O(n) and shouldn't make more comparisons than NomeN's implementation.
",0,1412751
1479517,"
top k is usually a bit better than n(log k)
Of course the special_allocator can in essence be just an array of k multiset value_types and a list of those nodes (which typically has nothing on it as the other k are in use in the multiset until its time to put a new one in and we erase and then immediate ly reuse it. Good to have this or else the memory alloc/free in std::multiset and the cache line crap kills ya. Its a (very) tiny bit of work to give it static state without violating STL allocator rules.
Not as good as a specialized algo for exactly 2 but for fixed k<<n, I would GUESS (2n+delta*n) where delta is small - my DEK ACP vol3 S&S is packed away and an estimate on delta is a bit more work that I want to do.
average worst is I would guess n(log(k-1) + 2) when in opposite order and all distinct. 
best is 2n + k(log k) for the k best being the first
",0,1412751
1382361,"
From what I understand, you want list::sort to find the least node in the list which is greater than the input.
To do this, you need to iterate through all the elements and keep the current least-but-greater node found.
Something like this:
Now change your display function to use it like this:
This part keeps calling sort until sort returns NULL.  The first call to sort is with NULL so the lowest item is found (that is, the first in the sorted list).  sort returns NULL if there are no more nodes larger than current_node, thus terminating the loop.
",2,1382273
1382326,"
Before I even get to the question asked, I observe some problems you probably want to address:

Your nodes have two different kinds of next's, but only one kind of prev. Is that really what you want, and if so, which next is paired with the prev?
The method you have named sort doesn't sort, but acts as a comparison.
You don't appear to have implemented an actual sort (or at least you haven't exhibited it here).
There is no need for the repetitive setting of FirstName and SecondName back to NULL in sort. They are local variables and simple disappear when the method returns.
There is no need to do two strcmp's in sort. Either cache the result of the first one ( int cmp=strcmp(...);) or use aswitchon the value returned bystrcmp`.

To sort a double linked array I would I would suggest one of:

Using a standard container that supports std::sort if this is allowed (but I'm guessing that this is homework, so probably not). I believe that std::list qualifies.
Sorting at insertion time if the sort order will never change
Implementing a partition sort (i.e. quicksort), which will work very nicely on this kind of structure (but the usual example code is given on arrays, so you will have to understand what is being done and why before the right way to implement it on linked lists becomes apparent).

",4,1382273
1382413,"
Why isn't using std::list (the STL's doubly-linked list) and its associated sort function appropriate here? If you defined an operator< for your list items, it will Just Work and you won't have to write a whole bunch of code just to have a list and sort it.
",3,1382273
1382299,"
I wouldn't bother to write my own sort function. I'd just use qsort. Since it's interface is c and not c++, to use it you just build an array of object pointers, then call qsort on it with your own comparator function. Then rebuild the linked list from the newly sorted array of object pointers.
",2,1382273
1382397,"
If you are looking for an efficient in-place sort algorithm for linked lists, check out this one ... I've found it to be quite fast.
",0,1382273
1380496,"
A simple example using std::sort

Edit: As Kirill V. Lyadvinsky pointed out, instead of supplying a sort predicate, you can implement the operator< for MyStruct:
Using this method means you can simply sort the vector as follows:
Edit2: As Kappa suggests you can also sort the vector in the descending order by overloading a > operator and changing call of sort a bit: 
And you should call sort as:
",319,1380463
26295515,"
In the interest of coverage.  I put forward an implementation using lambda expressions.
C++11
C++14
",128,1380463
1380481,"
You could use functor as third argument of std::sort, or you could define operator< in your class.
",52,1380463
1380488,"
You are on the right track.  std::sort will use operator< as comparison function by default.  So in order to sort your objects, you will either have to overload bool operator<( const T&, const T& ) or provide a functor that does the comparison, much like this:
The advantage of the usage of a functor is that you can use a function with access to the class' private members.
",13,1380463
37334886,"
Sorting such a vector or any other applicable (mutable input iterator) range of custom objects of type X can be achieved using various methods, especially including the use of standard library algorithms like 

sort, 
stable_sort, 
partial_sort or
partial_sort_copy.

Since most of the techniques, to obtain relative ordering of X elements, have already been posted, I'll start by some notes on ""why"" and ""when"" to use the various approaches.
The ""best"" approach will depend on different factors:

Is sorting ranges of X objects a common or a rare task (will such ranges be sorted a mutiple different places in the program or by library users)?
Is the required sorting ""natural"" (expected) or are there multiple ways the type could be compared to itself?
Is performance an issue or should sorting ranges of X objects be foolproof?

If sorting ranges of X is a common task and the achieved sorting is to be expected (i.e. X just wraps a single fundamental value) then on would probably go for overloading operator< since it enables sorting without any fuzz (like correctly passing proper comparators) and repeatedly yields expected results.
If sorting is a common task or likely to be required in different contexts, but there are multiple criteria which can be used to sort X objects, I'd go for Functors (overloaded operator() functions of custom classes) or function pointers (i.e. one functor/function for lexical ordering and another one for natural ordering).
If sorting ranges of type X is uncommon or unlikely in other contexts I tend to use lambdas instead of cluttering any namespace with more functions or types.
This is especially true if the sorting is not ""clear"" or ""natural"" in some way. You can easily get the logic behind the ordering when looking at a lambda that is applied in-place whereas operator< is opague at first sight and you'd have to look the definition up to know what ordering logic will be applied.
Note however, that a single operator< definition is a single point of failure whereas multiple lambas are multiple points of failure and require a more caution.
If the definition of operator< isn't available where the sorting is done / the sort template is compiled, the compiler might be forced to make a function call when comparing objects, instead of inlining the ordering logic which might be a severe drawback (at least when link time optimization/code generation is not applied).
Ways to achieve comparability of class X in order to use standard library sorting algorithms
Let std::vector<X> vec_X; and std::vector<Y> vec_Y;
1. Overload T::operator<(T) or operator<(T, T) and use standard library templates that do not expect a comparison function.
Either overload member operator<:
or free operator<:
2. Use a function pointer with a custom comparison function as sorting function parameter.
3. Create a bool operator()(T, T) overload for a custom type which can be passed as comparison functor.
Those function object definitions can be written a little more generic using C++11 and templates:
which can be used to sort any type with member i supporting <.
4. Pass an anonymus closure (lambda) as comparison parameter to the sorting functions.
Where C++14 enables a even more generic lambda expression:
which could be wrapped in a macro
making ordinary comparator creation quite smooth:
",11,1380463
1380493,"
Yes, std::sort() with third parameter (function or object) would be easier. An example: 
http://www.cplusplus.com/reference/algorithm/sort/
",4,1380463
1380487,"
In your class, you may overload the ""<"" operator.
",3,1380463
36736713,"
Below is the code using lambdas
#include ""stdafx.h""
#include <vector>
#include <algorithm>

using namespace std;

struct MyStruct
{
    int key;
    std::string stringValue;

    MyStruct(int k, const std::string& s) : key(k), stringValue(s) {}
};

int main()
{
    std::vector < MyStruct > vec;

    vec.push_back(MyStruct(4, ""test""));
    vec.push_back(MyStruct(3, ""a""));
    vec.push_back(MyStruct(2, ""is""));
    vec.push_back(MyStruct(1, ""this""));

    std::sort(vec.begin(), vec.end(), 
        [] (const MyStruct& struct1, const MyStruct& struct2)
        {
            return (struct1.key < struct2.key);
        }
    );
    return 0;
}

",2,1380463
50040873,"
I was curious if there is any measurable impact on performance between the various ways one can call std::sort, so I've created this simple test:
What it does is it creates a random vector, and then measures how much time is required to copy it and sort the copy of it (and compute some checksum to avoid too vigorous dead code elimination).
I was compiling with g++ (GCC) 7.2.1 20170829 (Red Hat 7.2.1-1)
Here are results:
Looks like all the options except for passing function pointer are very similar, and passing a function pointer causes +30% penalty. 
It also looks like the operator< version is ~1% slower (I repeated the test multiple times and the effect persists), which is a bit strange as it suggests that the generated code is different (I lack skill to analyze --save-temps output).
",2,1380463
20763862,"
",1,1380463
45567530,"
You can use user defined comparator class.
",1,1380463
38730028,"
To sort a vector you can use the sort() algorithm in .
The third parameter used can be greater or less or any function or object can also be used. However the default operator is < if you leave third parameter empty.
",0,1380463
45992778,"
if compare is false, it will do ""swap"".
",0,1380463
1367494,"
Maps are stored as a tree sorted in key order. You want the 10 smallest (or largest) integer values, and their keys, right?
In that case, iterate the map and put all the key-value pairs in a vector of pairs (std::vector<std::pair<std::string, int> >). I think you can just use the two-iterator-arg constructor of std::vector for this. Then use std::partial_sort on the vector. Specify a comparator to partial_sort, which compares pairs by just comparing the value int, ignoring the key string. Then you have the 10 pairs you want at the start of the vector, and the rest of the vector contains the remaining pairs in an unspecified order.
Code (untested):
Note that if there are several strings with the same value, either side of the limit of 10, then it's not specified which ones you get. You can control this by having your comparator look at the string too, in cases where the integers are equal.
",25,1367429
1367490,"
For iterating by value you could use boost::multi_index. It will looks as follows:
You could use any index for iteration ( val_str or val_int ).
",7,1367429
1367609,"
May not be the most elegant way, but you can sort them via value in a set as:

#include <map>
#include <set>
#include <iostream>
#include <string>

using namespace std;

struct sortPairSecond
{
   bool operator()(const pair<string, int> &lhs;, const pair<string, int> &rhs;)
   {
       return lhs.second < rhs.second;
   }
};


int main (int argc, char *argv[])
{
    cout << ""Started...\n"";
    map<string, int> myMap;
    myMap[""One""]   = 1;
    myMap[""Ten""]   = 10;
    myMap[""Five""]  = 5;
    myMap[""Zero""]  = 0;
    myMap[""Eight""] = 8;


    cout << ""Map Order:\n---------------\n"";
    set<pair<string,int>, sortPairSecond > mySet;
    for(map<string, int>::const_iterator it = myMap.begin(); it != myMap.end(); ++it)
    {
        cout << it->first << "" = "" << it->second << ""\n"";
        mySet.insert(*it);
    }

    cout << ""\nSet Order:\n--------------\n"";
    for(set<pair<string, int> >::const_iterator it = mySet.begin(); it != mySet.end(); ++it)
    {
        cout << it->first << "" = "" << it->second << ""\n"";
    }

    return 1;
}



",1,1367429
1367480,"
If you iterate using the map iterator, you will get the items sorted on key as it internally uses balanced binary tree to store the values. So you could just extract the 10 values from it using the iterators. Is that what you want or you want to do something else? Please clarify.
EDIT:
Instead of using the vector and sorting, you can directly use set and pass the comparison function. Then you can extract the top 10 elements. This is my test code:
",1,1367429
1367748,"
Another possibility is to build a reverse map. For you that would be std::map<int, std::string>. Entries in the reverse map are sorted by their value. 
The following is what I have in my tool box for such occasions: 
This code assumes that values are unique, too (and throws an assertion, if this is not the case). If this doesn't apply to your problem, you could easily change the code to use a multi map.
",1,1367429
1300346,"
Integer obj2() isn't the definition of an object, it is the declaration of a function named obj2 returning an Integer (put it outside any function to understand why it is so).  This occurs also sometimes with more complex constructions where it can be even more confusing. Some name this the most vexing parse.
Here is the promised example of a more complex case:
Here quxx is a function returning a Bar and taking (a pointer) to a function returning a Foo and without parameters.  You could write the same declaration more clearly like this:
To get the definition of a variable initialized with the constructor taking a Foo, you can add a level of parenthesis:
",15,1300327
1300364,"
Because obj2 is a function. See this
",3,1300327
1300398,"
obj2 is not a BinaryPredicate and is invalid as the third parameter to std::sort
obj2 needs to be something like 
or the functor type used by obj1.
",1,1300327
1300443,"
There is no definition of no argument constructor.
Use, Integer obj2(0);
",1,1300327
1300436,"
class Integer
{
public:
    int m;
    Integer(int a):m(a){};
};
class CompareParts 
{
public:
    bool operator()(const Integer & p1,const Integer & p2)
    {
        return p1.m
    }
};
int main()
{
    std::vector vecInteger;   
    vecInteger.push_back(Integer(12)); 
    vecInteger.push_back(Integer(13)); 
    vecInteger.push_back(Integer(5));  
    vecInteger.push_back(Integer(7));  
    vecInteger.push_back(Integer(9));  
}
Output:
5 7 9 12 13
",0,1300327
1292745,"
Since you say you're not familiar with vectors (you really should learn STL containers ASAP, though), I assume you're playing with arrays. Something along these lines:
The third optional argument f of stable_sort is a function object - that is, anything which can be called like a function by following it with parentheses - f(a, b). A function (or rather a pointer to one) is a function object; other kinds include classes with overloaded operator(), but for your purposes a plain function would probably do.
Now you have your data type with int field on which you want to sort, and some additional data:
To sort this (or anything, really), stable_sort needs to have some way of comparing any two elements to see which one is greater. By default it simply uses operator < to compare; if the element type supports it directly, that is. Obviously, int does; it is also possible to overload operator< for your struct, and it will be picked up as well, but you asked about a different approach.
This is what the third argument is for - when it is provided, stable_sort calls it every time it needs to make a comparison, passing two elements as the arguments to the call. The called function (or function object, in general) must return true if first argument is less than second for the purpose of sorting, or false if it is greater or equal - in other words, it must work like operator < itself does (except that you define the way you want things to be compared). For foo, you just want to compare n, and leave the rest alone. So:
And now you use it by passing the pointer to this function (represented simply by its name) to stable_sort:
",4,1292511
1292544,"
You need to pass the comparison function. Something like this:
Inside the sort algorithm, to compare the values the comparison function passed by you is used. If you have a more complex data structure and want to sort on a particular attribute of the data structure then you can use this user-defined function to compare the values.
",3,1292511
1292556,"
I believe you are talking about this function:
And the function call:
The function compare_as_ints is a normal function but this is being passed to the stable_sort as a function pointer. i.e., the address of the function is being passed which would be used by stable_sort internally to compare the values.
Look at this function pointer tutorial if you are unclear about this.
",2,1292511
1271587,"
I think you're severely overcomplicating your solution. You can implement radix using the single array received in the input, with the buckets in each step represented by an array of indices that mark the starting index of each bucket in the input array.
In fact, you could even do it recursively:
Of course buckets[i+1] - buckets[i] will cause a buffer overflow when i is 9, but I omitted the extra check or readability's sake; I trust you know how to handle that.
With that, you just have to call radixSort(testcases, sizeof(testcases) / sizeof(testcases[0]), 0) and your array should be sorted.
",11,1271367
40457313,"
To speed up the process with better memory management, create a matrix for the counts that get converted into indices by making a single pass over the array. Allocate a second temp array the same size as the original array, and radix sort between the two arrays until the array is sorted. If an odd number of radix sort passes is performed, then the temp array will need to be copied back to the original array at the end.
To further speed up the process, use base 256 instead of base 10 for the radix sort. This only takes 1 scan pass to create the matrix and 4 radix sort passes to do the sort. Example code:
",2,1271367
1271954,"
Since your values are ints in the range of 0 ... 1,000,000
You can create a int array of of size 1,000,001, and do the whole thing in two passes
Init the second array to all zeros.
Make a pass through your input array, and use the value as a subscript
to increment the value in the second array.
Once you do that then the second pass is easy.
walk through the second array, and each element tells you how many times that
number appeared in the original array.   Use that information to repopulate
your input array.
",0,1271367
1248835,"
If you're after an algorithm for that type of sorting (where the data can't all fit into core at once), my solution comes from the very earliest days of the ""revolution"" when top-end machines had less memory than most modern-day calculators.
I haven't worked out the big-O properties but I think it would be O(n) reads, O(n log n) sort phase (depends on the sort method chosen) and O(n) writes.
Let's say your data set has one million elements and you can only fit 100,000 in memory at a time. Here's what I'd do:

read in the first 100,000, sort them and write that sorted list back out.
do this for each group of 100,000.
run a merge operation on the 10 groups.

In other words, once your 10 groups are sorted within the group, grab the first entry from each group.
Then write that the lowest of those 10 (which is the lowest of the whole million) to the output file and read the next one from that group in its place.
Then just continue selecting the lowest of the 10, writing it out and replacing it from the same group. In that way, the final output is the entire sorted list of a million entries.
",4,1248774
1248819,"
Check out external merge sort algorithm.
",3,1248774
1248786,"
Try this page: Sorting Algorithms. Besides showing nice animations of several algorithms it explains how they work and their complexity.
",2,1248774
1242724,"
If you want to avoid swapping overhead, you could try Selection Sort. This sorting algorithm will find a value and immediatly put it into the right place performing only one swap, thus, I believe, doing the minimal number of swaps as possible.
",1,1238191
1238219,"
In the above you should really be using std::vectors, not arrays. I can't imagine why you can't return a (const) vector of pointers, but if that is the case, work with a vector of pointers, sorting only the pointers and then when sorted, copy the resulting sorted structures into another vector and return that, which will mean only one copy per vector entry.
",0,1238191
1685224,"
You could put it into a std::list and then define the comparison function for the sort. It should only swap the pointers to each node and not the structures.  Swaping of pointers is a quick 2 or 3 op function.
",0,1238191
1230477,"
You're working with a const vector, which cannot be sorted. (Or changed).
This is because your function is const:
Remove the const so members of your class can be modified (and therefore sorted).
",4,1230428
1230437,"
The following code compiles under g++ 4.4.0:
Please test it with your compiler. In general, it would be helpful if you and others posted small complete programs like this which can be easily tested, and which illustrate the problem (or lack of them, in this case).
",3,1230428
1230472,"
The code above compiles fine, it looks like you have an assignment problem when trying to assign something to a const Edge.
You don't need to define an assignment operator but you can't assign something to a const Edge.
",0,1230428
1230567,"
The printGraph function is declared as a const member function of Graph but you're trying to modify a member variable (the edges vector). Remove the const from the printGraph declaration and the code will compile. 
Alternatively make a local copy of the edges vector and sort that before printing it out, since the comments state this function is only for debugging performance shouldn't be a major concern. It's a little misleading for a function called printGraph to be modifying the edges vector anyway.
",0,1230428
1230480,"
It looks to me like you're calling std::sort with a std::vector<Edge>::const_iterator instead of a std::vector<Edge>::iterator, probably in graph.cpp line 107.
After seeing the code: The iterators are indeed constant. edges is a member variable of Graph and printGraph is a const method. Therefore edges can't be modified inside of printGraph because the Graph object can't be modified by a const method. Sorting edges would modify it, so it leads to a compiler error.
",0,1230428
1208858,"
Sorting to get a median is very inefficient. You could use STL nth_element instead:
Note: the nth_element will modify the vector/array v. Make a copy first if you need to preserve the original.
",19,1208766
1208820,"
Please please please never recommend bubble sort except to masochists!
For small values, insertion sort is best, and its good for other applications (nearly sorted data of any length).
Edit: cleaned up formatting, emphasizing suggested answer.
",9,1208766
1208808,"
Only 9 values? Quicksort is overkill.
Perhaps use insertion sort, bubble sort or other simpler sorting algorithms when working with smaller datasets.
Performance
Bubble sort has worst-case and average complexity both О(n²), where n is the number of items being sorted. There exist many sorting algorithms with the substantially better worst-case or average complexity of O(n log n). Even other О(n²) sorting algorithms, such as insertion sort, tend to have better performance than bubble sort. Therefore bubble sort is not a practical sorting algorithm when n is large.
However, granted, you did not even have to sort to get the median as others have suggested.
",5,1208766
1208804,"

As onebyone mentioned there is no need to sort completely to get a median.
STL has sort algorithm which usually can perform comparison inlining. It also has smarter algorithm than guaranteed by qsort, with worstcase of O(NlgN).

",4,1208766
1208809,"
Using quicksort for only 9 values is going to be rather inefficient. For such a small sample size, you're much better off utilizing a selection sort or replacement sort... there is very little overhead in these sorting methods.
Quicksort and Mergesort really shine once your sample size reaches a threshold, perhaps 50+. 
In these situations, I'd write my own code rather than use a built-in function.
",4,1208766
1208905,"
The std::sort() algorithm is almost always preferable to qsort().  It's typically easier to use and runs faster.
If you want to get into detail, there's actually a family of sorting algorithms.  Stroustrup writes in The C++ Programming Language that std::sort is often not the exact right thing to use.  In this case, std::nth_element() is probably what you want.
",4,1208766
1208825,"
You don't have enough values to work with Quicksort and you should use less advanced algorithms (ex: Bubble sort, Insertion sort, ... explanation here.
There is a cost associated to Quicksort's setup and when you don't have enough values, it's useless to use this beast.
",2,1208766
1208803,"
Insertion Sort.. 
On small datasets you can use different algorithms to get optimal performance. QuickSort shines once the dataset grows. 
There are different approaches. You can use data structures where you sort on insert, and there are onces where you sort the complete dataset. You just need to find your optimal algorithm. 
",1,1208766
1196054,"
Boost Multi-Index supports sorting anything you want and supports changing the fields the list gets oderdered by, although you can't just type a1.x=1 anymore, instead, you have to use MultiIndex::replace().
I can't think of a faster/more natural way of doing this, as deleting and reinserting the element would've to be done anyway.
",6,1196000
1196053,"
I would consider using a sorted std::vector instead.  At one of those points where you predictably modify x for one of the set's members, then just re-sort the vector.  It's a little cleaner than having to remove and reinsert items.  This might be too much overhead though if you're frequently modifying a single set member's property and re-sorting.  It would be much more useful if you're likely to be changing many of these properties at once.
",1,1196000
1200388,"
As others pointed out, using a std::set or std::multiset just does not cut it.
You probably did not notice since you use pointers, but the assumption is that objects are immutable (though in this case it means that the pointers are const, but not the pointed value).
Therefore, you cannot use (directly) a standard container which will do your book-keeping automatically.
At this point you have several solutions:

you may use a library, in this case the Boost.MultiIndex comes to mind, even though you will have to learn to use it
or you may wrap a standard container in a dedicated class (for example, your set)

I think both are equally valid. Since the operation is very simple you may not want to use the Boost library for this yet (learning curve, integration, ...).
Also, you may consider using 'invasive' containers. What I mean is that you could use the 'Observer' pattern here >> your object can notify its container each time its value change, so that the container reposition it at its 'new' correct position (using a std::multiset internally).
If efficiency is a concern, I would not consider sorting a vector. Sorting a full container each time a single object change is a waste, your erase/insert method is much more efficient.
",1,1196000
1171390,"
Ordered insertion doesn't need boost:
upper_bound provides a valid insertion point provided that the vector is sorted to start with, so as long as you only ever insert elements in their correct place, you're done. I originally said lower_bound, but if the vector contains multiple equal elements, then upper_bound selects the insertion point which requires less work.
This does have to copy O(n) elements, but you say insertion sort is ""blindingly fast"", and this is faster. If it's not fast enough, you have to find a way to add items in batches and validate at the end, or else give up on contiguous storage and switch to a container which maintains order, such as set or multiset.
A heap does not maintain order in the underlying container, but is good for a priority queue or similar, because it makes removal of the maximum element fast. You say you want to maintain the vector in order, but if you never actually iterate over the whole collection in order then you might not need it to be fully ordered, and that's when a heap is useful.
",10,1171365
1171495,"
According to item 23 of Meyers' Effective STL, you should use a sorted vector if you application use its data structures in 3 phases. From the book, they are : 


Setup. Create a new data structure by inserting lots of elements into it. During this phase, almost all operation are insertions and erasure. Lookups are rare on nonexistent
Lookup. Consult the data structure to find specific pieces of information. During this phase, almost all operations are lookups. Insertion and erasures are rare or nonexistent. There are so many lookups, the performance of this phase makes the performance of the other phases incidental.
Reorganize. Modify the content of the data structure. perhaps by erasing all the current data and inserting new data in its place. Behaviorally, this phase is equivalent to phase 1. Once this phase is completed, the application return to phase 2


If your use of your data structure resembles this, you should use a sorted vector, and then use a binary_search as mentionned. If not, a typical associative container should do it, that means a set, multi-set, map or multimap as those structure  are ordered by default
",6,1171365
1171375,"
Why not just use a binary search to find where to insert the new element? Then you will insert exactly into the required position.
",3,1171365
1171430,"
If you need to insert a lot of elements into a sorted sequence, use std::merge, potentially sorting the new elements first:
",1,1171365
1171427,"
Using a binary search to find the insertion location isn't going to speed up the algorithm much because it will still be O(N) to do the insertion (consider inserting at the beginning of a vector - you have to move every element down one to create the space).
A tree (aka heap) will be O(log(N)) to insert, much better performance.
See http://www.sgi.com/tech/stl/priority_queue.html
Note that a tree will still have worst case O(N) performance for insert unless it is balanced, e.g. an AVL tree.
",0,1171365
1171396,"
Why not to use boost::multi_index ? 
NOTE: boost::multi_index does not provide memory contiguity, a property of std::vectors by which elements are stored adjacent to one another in a single block of memory.
",0,1171365
1171400,"
There are a few things you need to do.

You may want to consider making use of reserve() to avoid excessive re-allocing of the entire vector.  If you have knowledge of the size it will grow to, you may gain some performance by doing resrve()s yourself (rather than having the implemetation do them automaticaly using the built in heuristic).
Do a binary search to find the insertion location.  Then resize and shift everything following the insertion point up by one to make room.
Consider: do you really want to use a vector?  Perhaps a set or map are better.

The advantage of binary search over lower_bound is that if the insertion point is close to the end of the vector you don't have to pay the theta(n) complexity.
",0,1171365
1171532,"

If you want insert an element into the ""right"" position, why do you plan on using sort. Find the position using lower_bound and insert, using, well, `insert' method of the vector. That will still be O(N) to insert new item.
heap is not going to help you, because heap is not sorted. It allows you get get at the smallest element quickly, and then quickly remove it and get next smallest element. However, the data in heap is not stored in sort order, so if you have algorithms that must iterate over data in order, it will not help.

I am afraid you description skimmed to much detail, but it seems like list is just not the right element for the task. std::deque is much better suited for insertion in the middle, and you might also consider std::set. I suggest you explain why you need to keep the data sorted to get more helpful advice.
",0,1171365
1171545,"
You might want to consider using a BTree or a Judy Trie. 

You don't want to use contiguous memory for large collections, insertions should not take O(n) time; 
You want to use at least binary insertion for single elements, multiple elements should be presorted so you can make the search boundaries smaller;
You do not want your data structure wasting memory, so nothing with left and right pointers for each data element.

",0,1171365
13324107,"
As others have said I'd probably have created a BTree out of a linked list instead of using a vector. Even if you got past the sorting issue, vectors have the problem of fully reallocating when they need to grow, assuming you don't know your maximum size before hand.
If you are worried about a list allocating on different memory pages and causing cache related performance issues, preallocate your nodes in an array, (pool the objects) and insert these into the list. 
You can add a value in your data type that denotes if it is allocated off the heap or from a pool. This way if you detect that your pool runs out of room, you can start allocating off the heap and throw an assert or something to yourself so you know to bump up the pool size (or make this a command line option to set.
Hope this helps, as I see you already have lots of great answers.
",0,1171365
1132396,"
Isn't it just this?
",2,1132175
1132355,"
You can also reduce some of the code verbosity using the trinary operator like this:
See?
This is much shorter and in my opinion easily read.
I know it's not what you asked for but it's also important.
",1,1132175
1132524,"
Is it intended that if the case nPriority1 < 0 and nPriority2 < 0 but nPriority1 != nPriority2 the other data aren't compared?
If it isn't, I'd use something like
which will consider values less or equal to 0 the same as the maximum possible value.
(Note that optimizing for performance is probably not worthwhile if you consider that there are insensitive comparisons in the most common path.)
",1,1132175
1132320,"
If you can, it seems like modifying the priority scheme would be the most elegant, so that you could just sort normally.  For example, instead of storing a default priority as 0, store it as 999, and cap user defined priorities at 998.  Then you won't have to deal with the special case anymore, and your compare function can have a more straightforward structure, with no nesting of if's:
(pseudocode)
",0,1132175
1132473,"
I think the inelegance you feel about your solution comes from duplicate code for the zero priority exception. The Pragmatic Programmer explains that each piece of information in your source should be defined in ""one true"" place. To the naive programmer reading your function, you want the exception to stand-out, separate from the other logic, in one place, so that it is readily understandable. How about this?
",0,1132175
1132575,"
I Java-ized it, but the approach will work fine in C++:
Basically, just extract the special-handling-for-zero behavior into its own function, and iterate along the fields in sort-priority order, returning as soon as you have a nonzero.
",0,1132175
1132612,"
As long as the highest priority is not larger than INT_MAX/2, you could do
This will turn priority 0 into bound and shift all other priorities down by 1.  The advantage is that you avoid comparisons and make the remainder of the code look more natural.
In response to your comment, here is a complete solution that avoids the translation in the 95% case where priorities are equal.  Note, however, that your concern over this is misplaced since this tiny overhead is negligible with respect to the overall complexity of this case, since the equal-priorities case involves at the very least a function call to the time comparison method and at worst an additional call to the name comparator, which is surely at least an order of magnitude slower than whatever you do to compare the priorities.  If you are really concerned about efficiency, go ahead and experiment.  I predict that the difference between the worst-performing and best-performing suggestions made in this thread won't be more than 2%.
Depending on your compiler/hardware, you might be able to squeeze out a few more cycles by replacing the last line with
or
or (assuming 2's complement)
Final comment: Do you really want CompareCompetitions to return 1,-1,0 ?  If all you need it for is bubble sort, you would be better off with a function returning a bool (true if comp1 is "">="" comp2 and false otherwise).  This would simplify (albeit slightly) the code of CompareCompetitions as well as the code of the bubble sorter.  On the other hand, it would make CompareCompetitions less general-purpose.
",0,1132175
1129192,"
If you intend to use std::sort, you will need to use a datastructure like a pair.
You can, of course, manually sort the vectors, and essentially reimplement std::sort.
This question really depends on a great number of other questions, such as:

How many items will be in the vectors?
How critical is performance?
Do you REALLY want to implement your own sort algorithm?

Implementing a quicksort should be fairly painless, and will allow you to avoid moving the data around.
",2,1129176
1129193,"
If you manually sort them yourself, you can just swap the corresponding items in the double array along with the items in the string array that you would normally do. Or, you could have a third array:
That just indexes into the string/double array, and sort that array instead (swapping based on the values in the string array).
",5,1129176
1129902,"
You could create an auxiliary vector:
Initialize it to to 0,1,2,...n-1, where n is the size of your vectors, and have the sort algorithm sort it using a functor that looks at the vector<string>, i.e., when asked to compare index1 and index2, the functor will look up the corresponding strings and compare them instead.  Once you have indices sorted, you can easily sort your two arrays to conform to it in linear time.
Edit: I didn't see Jim Buck's second suggestion.  My answer is just an expanded version of that.
",3,1129176
1129931,"
Although the indices idea is effectively the same, you can in fact define a random access iterator type that knows the two vectors, and moves them (through assignment) in sync.  The value_type of that iterator would be pair.  In functional programming, you'd call this a ""zip"" (but not a zipper).
It's definitely not worth the hassle unless you're VERY tight on space.  If you have the space, actually zipping the two vectors into a single vector of pairs, or using the indices approach, are both easier.
If you're able to get it right the first time, copy/pasting a 10 line quicksort with the obvious modifications will be the fastest way to what you want.

Ed's note: there is an already-written Zip Iterator available in Boost, as pointed out in this newer answer to the same question:",3,1129176
1104635,"
I believe you need to change
into
and
into
IOW, your code needs to be const-correct and not claim it may modify things it in fact doesn't (nor needs to).
",3,1104605
1104631,"
Make your val() and operator<() const functions.
The same for Sort::operator() — take const Thing& instead of Thing&.
",4,1104605
1104663,"
Try making operator< take its argument by const reference.  You'll need to change its implementation to directly access _val or (preferably) make val() const as well when you do this (because a const member function can't call a non-const one).
",0,1104605
1100738,"
list member sort is a non-static function so must be called on a list instance.
Edit: You can't use the free function std::sort as it requires random access iterators which list iterators are not.
",4,1100671
1100684,"
You're passing a class as an argument to a function. You cannot do that - you have to create an instance of the class, and pass that:
Note the extra parentheses after OccurenceComparator above that create a temporary object of the class using default constructor.
Another mistake is that you're calling list::sort as a static function on class std::list. It's not static, so you need to call it as a member function on substring_list.
",4,1100671
1100698,"
The original problem was already solved by Pavel Minaev above.
But some extra notes.
The operator() should probably be const (as well as the parameters).
For simple classes like this it is easier to just make them structures.
Note the comparison must provide a strict weak ordering:

template<class BinaryPredicate>
  void sort(BinaryPredicate comp); 
Comp must be a comparison function that induces a strict weak ordering (as defined in the LessThan Comparable requirements on objects of type T. This function sorts the list *this according to Comp. The sort is stable, that is, the relative order of equivalent elements is preserved. All iterators remain valid and continue to point to the same elements. [6] The number of comparisons is approximately N log N, where N is the list's size. 

",3,1100671
1041939,"
I agree with R. Pate and Todd Gardner; a std::set might be a good idea here.  Even if you're stuck using vectors, if you have enough duplicates, you might be better off creating a set to do the dirty work.
Let's compare three approaches:
Just using vector, sort + unique
Convert to set (manually)
Convert to set (using a constructor)
Here's how these perform as the number of duplicates changes:

Summary: when the number of duplicates is large enough, it's actually faster to convert to a set and then dump the data back into a vector.  
And for some reason, doing the set conversion manually seems to be faster than using the set constructor -- at least on the toy random data that I used.
",512,1041620
24477023,"
I redid Nate Kohl's profiling and got different results. For my test case, directly sorting the vector is always more efficient than using a set. I added a new more efficient method, using an unordered_set.
Keep in mind that the unordered_set method only works if you have a good hash function for the type you need uniqued and sorted. For ints, this is easy! (The standard library provides a default hash which is simply the identity function.) Also, don't forget to sort at the end since unordered_set is, well, unordered :)
I did some digging inside the set and unordered_set implementation and discovered that the constructor actually construct a new node for every element, before checking its value to determine if it should actually be inserted (in Visual Studio implementation, at least).
Here are the 5 methods:
f1: Just using vector, sort + unique
f2: Convert to set (using a constructor)
f3: Convert to set (manually)
f4: Convert to unordered_set (using a constructor)
f5: Convert to unordered_set (manually)
I did the test with a vector of 100,000,000 ints chosen randomly in ranges [1,10], [1,1000], and [1,100000]
The results (in seconds, smaller is better):
",51,1041620
1041630,"
std::unique only removes duplicate elements if they're neighbours: you have to sort the vector first before it will work as you intend.
std::unique is defined to be stable, so the vector will still be sorted after running unique on it.
",46,1041620
1041700,"
I'm not sure what you are using this for, so I can't say this with 100% certainty, but normally when I think ""sorted, unique"" container, I think of a std::set. It might be a better fit for your usecase:
Otherwise, sorting prior to calling unique (as the other answers pointed out) is the way to go.
",40,1041620
1041626,"
std::unique only works on consecutive runs of duplicate elements, so you'd better sort first.  However, it is stable, so your vector will remain sorted.
",19,1041620
1041970,"
Here's a template to do it for you:
call it like:
",12,1041620
1041627,"
You need to sort it before you call unique because unique only removes duplicates that are next to each other. 
edit: 38 seconds...
",7,1041620
1041874,"
Efficiency is a complicated concept.  There's time vs. space considerations, as well as general measurements (where you only get vague answers such as O(n)) vs. specific ones (e.g. bubble sort can be much faster than quicksort, depending on input characteristics).
If you have relatively few duplicates, then sort followed by unique and erase seems the way to go.  If you had relatively many duplicates, creating a set from the vector and letting it do the heavy lifting could easily beat it.
Don't just concentrate on time efficiency either.  Sort+unique+erase operates in O(1) space, while the set construction operates in O(n) space.  And neither directly lends itself to a map-reduce parallelization (for really huge datasets).
",7,1041620
31748822,"
If you do not want to change the order of elements, then you can try this solution:
",6,1041620
1041628,"
unique only removes consecutive duplicate elements (which is necessary for it to run in linear time), so you should perform the sort first. It will remain sorted after the call to unique.
",5,1041620
1041688,"
As already stated, unique requires a sorted container.  Additionally, unique doesn't actually remove elements from the container.  Instead, they are copied to the end, unique returns an iterator pointing to the first such duplicate element, and you are expected to call erase to actually remove the elements.
",2,1041620
14844222,"
The standard approach suggested by Nate Kohl, just using vector, sort + unique:
doesn't work for a vector of pointers.
Look carefully at this example on cplusplus.com.
In their example, the ""so called duplicates"" moved to the end are actually shown as ? (undefined values), because those ""so called duplicates"" are SOMETIMES ""extra elements"" and SOMETIMES there are ""missing elements"" that were in the original vector.
A problem occurs when using std::unique() on a vector of pointers to objects (memory leaks, bad read of data from HEAP,  duplicate frees, which cause segmentation faults, etc).
Here's my solution to the problem: replace std::unique() with ptgi::unique().
See the file ptgi_unique.hpp below:
And here is the UNIT Test program that I used to test it:
",2,1041620
30875206,"
About alexK7 benchmarks. I tried them and got similar results, but when the range of values is 1 million the cases using std::sort (f1) and using std::unordered_set (f5) produce similar time. When the range of values is 10 million f1 is faster than f5. 
If the range of values is limited and the values are unsigned int, it is possible to use std::vector, the size of which corresponds to the given range. Here is the code:
",1,1041620
14900835,"
Here's the example of the duplicate delete problem that occurs with std::unique().  On a LINUX machine, the program crashes.  Read the comments for details.
",0,1041620
19900771,"
",0,1041620
47117300,"
sort(v.begin(), v.end()), v.erase(unique(v.begin(), v,end()), v.end());
",0,1041620
47840175,"
If you are looking for performance and using std::vector, I recommend the one that this documentation link provides.
",0,1041620
49595720,"
If you don't want to modify the vector (erase, sort) then you can use the Newton library, In the algorithm sublibrary there is a function call, copy_single
so You can:
where copy is the vector in where you want to push_back the copy of the unique elements. but remember you push_back the elements, and you don't create a new vector
anyway, this is faster because you don't erase() the elements (which takes a lot of time, except when you pop_back(), because of reassignment)
I make some experiments and it's faster.
Also, you can use:
sometimes is still faster.
",0,1041620
52249687,"
More understandable code from: https://en.cppreference.com/w/cpp/algorithm/unique
ouput:
",0,1041620
49743527,"
This is a function that I created that you can use to delete repeats. The header files needed are just <iostream> and <vector>.
",-2,1041620
933902,"
Yes, so long as the value type in the range to be sorted has an operator < that defines a ""strict weak ordering"", that is to say, it can be used to compare two MyTest instances correctly. You might do something like:
",10,933886
933898,"
Write an operator< for your struct. This is the default function used by sort and the easiest way to allow it to function on your custom data structures.
",3,933886
933901,"
Define the operator<
",2,933886
934053,"
It is possible to do it with a member function but the stand alone function is the way to go.
Why ..

Scott Meyers: How Non-Member Functions Improve Encapsulation
If you're writing a function that can
  be implemented as either a member or
  as a non-friend non-member, you should
  prefer to implement it as a non-member
  function. That decision increases
  class encapsulation. When you think
  encapsulation, you should think
  non-member functions.
Surprised? Read on

",2,933886
933910,"
You should define an operator< in MyTest and it should look like this:
",1,933886
7220425,"
http://ideone.com/3QLtP
This defines no operator <, but does define functor. 
However, it's fun to travel through time or compilation process.
",-2,933886
891852,"
The following is a description of the quickselect algorithm. I will assume that you want to find the kth smallest value.

Take the first element of your array. This will be your pivot. Keep track of its position.
Partition the array based on this pivot. Elements smaller than your pivot go before your pivot in the array; larger, after your pivot. (This step will move your pivot. Keep track of its position in your array.)
You now know that your pivot is larger than pivot_position number of elements. Therefore, your pivot is the (pivot_position + 1)th smallest element.

If k is equal to pivot_position + 1, then you've found your kth smallest value. Congratulations, return pivot_position as the position of that value in the array.
If k is less than pivot_position + 1, you want some value that's smaller than your pivot. Look in the part of the array before your pivot for the kth smallest value.
If k is greater than pivot_position + 1, you want some value that's larger than your pivot. Look in the part of the array after your pivot for the *k - (pivot_position + 1)*th smallest value (since that part of the array excludes the (pivot_position + 1) smallest values).


Since you're using C++, you should probably implement your functions as follows:
select takes your array, left and right bounds, and your k. To clarify, array[left] will be the first element; array[right] will be the last; right - left + 1 will be the length of the array. select returns the position of the kth smallest element.
partition takes your array, left and right bounds, and the starting position of your pivot. It's safe to just pass 0 for pivot_position every time, meaning that you want to use the first element in the array as the pivot. (In a variation called randomized quickselect, you pick a random pivot_position.) partition returns the position of the pivot after you're done moving things around.
",4,891750
891782,"
The STL has a partial_sort function that will sort the first k items of a sequence, and allowing you to grab that item with a simple lookup.
In other words, look for std::partial_sort and the rest will be obvious.
There is also a nth_element function in the STL.  I'm sure you can figure out how to use it.
",1,891750
886203,"
A simple extension of merge sort's merge phase can do this in O(n lg m) time (where n = total number of items and m = number of lists), using a priority queue (eg, a heap). Pseudocode:
And a simple (untested!) concrete implementation in C++:
",15,886178
886189,"
You could try applying the merge sort one at a time to each of the lists:
http://en.wikipedia.org/wiki/Merge_sort
This has the algorithm for the merge sort. Essentially you'd go with list 1 and 2 and merge sort those. Then you'd take that new combined list and sort with list 3, and this continues until you have one fully sorted list.
EDIT:
Actually, because your lists are already sorted, only the last part of the merge sort would be needed. I would iteratively combine the lists into bigger and bigger parts all the while sorting each of those bigger lists until you have your full list, which is essentially what the merge sort does after it's done with its divide and conquer approach.
",2,886178
886212,"
If performance is not a concern, I would sort the lists last.  The code is more readable, shorter, and less likely to get screwed up by someone revisiting the code in the future.
",2,886178
886234,"
This is a standard (although 8-way) merge sort.
Basically you ""open"" the eight sorted lists then begin processing them, extracting the lowest value each time, something like:
 
 
",1,886178
886265,"
Basically you are doing part of multiway mergesort, except your stuff is already sorted...
http://lcm.csa.iisc.ernet.in/dsa/node211.html
Just find the lowest in each array (almost use as stacks) and put that in your output till all stacks are empty...
",0,886178
1654943,"
You want a merge sort. Your lists are already split but not all the way to the smallest level. You may want to do this:
That shouldn't be a time/memory consuming operation because the concatenation should add a link from the last node in in a list to the first element of the next list.
",0,886178
878507,"
What you're doing right now with your function is mixing the attributes of your data instead of sorting it. You should either use a flag to differ between the column to sort or 3 functions sortByName, sortByID and sortByAmout. And your ifs are wrong. Instead of 
it should say something like
",3,878387
878454,"
Your previous questions accepted answer was to use the std::sort function.
To do what you want here you should have 3 different sort functions

sortByName
sortById
sortByAmount

Then you just call std::sort with the relevant function
",0,878387
878471,"
You should use std::sort for this instead of writing your own sorting code unless you have an exceptionally good reason to write your own.
Writing your own is less clear, less efficient and contains duplicated code in this case.
Edit:  Ok, not being allowed to use sort is a good reason.  
In that case, my advice is the try to refactor your code into functions and try to make it so that each function does only one thing.  That way, the duplication should become apparent and can be eliminated.
The code you posted is trying to do at least four things in one big chunk.  Try to separate out your sorting code from what you are sorting.  Then you should be able to separate out each of the three ways of sorting.
",0,878387
873725,"
You should use C++'s standard sort function, std::sort, declared in the <algorithm> header.
When you sort using a custom sorting function, you have to provide a predicate function that says whether the left-hand value is less than the right-hand value. So if you want to sort by name first, then by ID, then by amount due, all in ascending order, you could do:
Now, pass that function to your sort call:
This assumes you have an STL container (and not an array, like you have in your sample code) called customers containing customers.
",33,873715
874352,"
Its often overlooked that you can actually use STL range functions with C based arrays, like in your example. So you don't actually have to move over to using an STL based container (I won't debate the merits of doing that here :-)).
So, building on the answer from Chris, you could invoke sort as follows:
",13,873715
873741,"
You only need to write a comparison function that compares two CustomerProfile types. Once you have this function, you can use either the STL sort (see http://www.sgi.com/tech/stl/sort.html or http://msdn.microsoft.com/en-us/library/ecdecxh1(VS.80).aspx) or the old C qsort: http://en.wikipedia.org/wiki/Qsort_(C_Standard_Library). I would advise against writing your own sort algorithm, unless this is a homework assignment.
Your comparison depends on the technology you like to use, it could look do something like this:
this assumes that the 'string' type in your example is a char*. If you use Unicode or multibyte types then the appropriate Unicode or multibyte comparison has to be used, obviously.
Then you would just call the algorithm, with your comparison function. Eg. using qsort:
Now if this is a homework assignment, you shouldn't be asking here how to do it...
",2,873715
873724,"
You can find a lot of sort implementations in C++ with creative googling..
The only difference is that instead of sorting numbers, you are sorting structs.
So wherever there is something like if(a[i]<a[j]) in the algorithm you will use, make a call like `if(isFirstCustomerLowerThanOther(a[i]

Now, create a function with the following structure:
Even better, if you use C++ you can use the STL's sort algortihm (again, google for info and for how to pass an ordering to it.
",1,873715
874442,"
I assume that you are new to programming or in C++, so here is what you probably are looking for:
",0,873715
864607,"
Why aren't you using std::sort? That's what it's for:
Of course, you really should use the C++ std::string class as well. That's what it's for. And then you don't have to screw around with error-prone C string manipulation functions like stricmp.
",9,864554
864572,"
First, compare the last names.  If they are equal, then compare the first names:
",5,864554
864577,"
Firstly, use qsort or the proper C++ equivalent which takes a function which compares two objects.
The comparison should then be trivial:
NB: a real C++ implementation would probably use templates for the comparator function.
",4,864554
864583,"
You have to change your comparison. The basic algorithm is if friends[i] > friends[j] then swap them. So change your definition of "">"" to include first name comparisons.
Something like the following ought to do:
You might want to do the last name comparison only once though (store it in a temp variable instead of comparing twice), but the idea is the same.
Note that the ""best"" way to do this might be to provide comparison functions in the FRIEND class. Then you can use if(friends[i].CompareTo(friends[j]) > 0) instead.
",3,864554
864613,"
In addition to the choice of building a comparison function that uses both names, you can sort on the fist names then sort on the last names, but you must take care to use a stable sort for the second pass. Might as well use it for the first too.
Good news: std::stable_sort is available and guaranteed to be, well, stable (thanks to Adam and libt for the correction). The plain std::sort and the c standard library qsort are not guaranteed to be stable, though some implementation might be. As Mark points out in the comments, the bubble sort you exhibit is already stable.

This is less efficient that the single-sort-with-a-custom-compare-function choice, but it makes it easy to let you user select multiple sorts at run-time (because you don't have to define every possible comparison function, or a mini-language).
",2,864554
864604,"
Please don't implement sorts by yourself - std::sort (in <algorithm>) does this job much better and much more efficient. (Except you just want to see how your algorithm works for experimental purpose)
You will have to specify a comparison function or better a functor anyway.
You can just invoke it like this:
",1,864554
864657,"
If you don't mind using boost.tuple (and replacing or at least modifying your existing implementation of Friend), there is an included comparison function.
All the above should work.
",1,864554
864580,"
Add the following:    
",0,864554
864622,"
Define a comparison function (or class as jalf suggested) and use the STL's std::sort():
",0,864554
864837,"
you can use a concatenation of left aligned last name and first name as a sorting key
this is another point of view you're looking for, i think :)
",0,864554
34829173,"
You can sort by last name and if last names are the same, sort them by the first names.
Something like this (Bubble sort used):
",0,864554
842453,"
Sorting a linked list in constant space is easy, you just have to adjust the pointers. The easiest way to do this is to use a sort algorithm that only swaps adjacent elements. I'm going to provide a bubble-sort, just because you've made no requirement for efficiency:
",12,842407
842422,"
A few methods:

use bubble sort on the list in place, this should be fast enough if the list is small
copy the list to an array and use heapsort or quicksort then copy it back
use bogosort on the list in place. The best case complexity is O(n) so it should be really fast*

*note that the expected runtime complexity is O(n*n!)
",2,842407
842451,"
As this is obviously homework I would recommend:
You should know how to swap two elements of you list. Then pick a Sorting Algorithm and implement it. 
",1,842407
4909803,"
For in-place sorting of a linked list, I would suggest merge sort.  It's stable, and runs in NlgN time.
",1,842407
34668459,"
There are good answers that compared the algorithms theoretically. I benchmarked std::sort and std::stable_sort with google/benchmark for curiosity's sake.
It is useful to point out ahead of time that;

Benchmark machine has 1 X 2500 MHz CPU and 1 GB RAM
Benchmark OS Arch Linux 2015.08 x86-64
Benchmark compiled with g++ 5.3.0 and clang++ 3.7.0 (-std=c++11, -O3 and -pthread)
BM_Base* benchmark tries to measure the time populating std::vector<>. That time should be subtracted from the sorting results for better comparison.  

First benchmark sorts std::vector<int> with 512k size.
[ g++ ]# benchmark_sorts --benchmark_repetitions=10
Run on (1 X 2500 MHz CPU )
2016-01-08 01:37:43
Benchmark                         Time(ns)    CPU(ns) Iterations
----------------------------------------------------------------
...
BM_BaseInt/512k_mean              24730499   24726189         28
BM_BaseInt/512k_stddev              293107     310668          0
...
BM_SortInt/512k_mean              70967679   70799990         10
BM_SortInt/512k_stddev             1300811    1301295          0
...
BM_StableSortInt/512k_mean        73487904   73481467          9
BM_StableSortInt/512k_stddev        979966     925172          0

[ clang++ ]# benchmark_sorts --benchmark_repetitions=10
Run on (1 X 2500 MHz CPU )
2016-01-08 01:39:07
Benchmark                         Time(ns)    CPU(ns) Iterations
----------------------------------------------------------------
...
BM_BaseInt/512k_mean              26198558   26197526         27
BM_BaseInt/512k_stddev              320971     348314          0
...
BM_SortInt/512k_mean              70648019   70666660         10
BM_SortInt/512k_stddev             2030727    2033062          0
...
BM_StableSortInt/512k_mean        82004375   81999989          9
BM_StableSortInt/512k_stddev        197309     181453          0

Second benchmark sorts std::vector<S> with 512k size (sizeof(Struct S) = 20).
[ g++ ]# benchmark_sorts --benchmark_repetitions=10
Run on (1 X 2500 MHz CPU )
2016-01-08 01:49:32
Benchmark                         Time(ns)    CPU(ns) Iterations
----------------------------------------------------------------
...
BM_BaseStruct/512k_mean           26485063   26410254         26
BM_BaseStruct/512k_stddev           270355     128200          0
...
BM_SortStruct/512k_mean           81844178   81833325          8
BM_SortStruct/512k_stddev           240868     204088          0
...
BM_StableSortStruct/512k_mean    106945879  106857114          7
BM_StableSortStruct/512k_stddev   10446119   10341548          0

[ clang++ ]# benchmark_sorts --benchmark_repetitions=10
Run on (1 X 2500 MHz CPU )
2016-01-08 01:53:01
Benchmark                         Time(ns)    CPU(ns) Iterations
----------------------------------------------------------------
...
BM_BaseStruct/512k_mean           27327329   27280000         25
BM_BaseStruct/512k_stddev           488318     333059          0 
...
BM_SortStruct/512k_mean           78611207   78407400          9
BM_SortStruct/512k_stddev           690207     372230          0 
...
BM_StableSortStruct/512k_mean    109477231  109333325          8
BM_StableSortStruct/512k_stddev   11697084   11506626          0

Anyone who likes to run the benchmark, here is the code,
",16,810951
810995,"
std::stable_sort performs NlogN comparisons when sufficient memory is available. When insufficient memory is available, it degrades to N((logN)^2) comparisons. Therefore it is roughly of the same efficiency as std::sort (which performs O(NlogN) comparisons in both average and worst case) when memory is available.
For those interested, sort() uses an introsort (quicksort which switches to heapsort when the recursion reaches a certain depth) and stable_sort() uses a merge sort.
",16,810951
810991,"
Big enough to warrant a separate function that does stable sort and not have std::sort() do it transparently. 
",10,810951
811125,"
Sometimes std::stable_sort() is needed because it maintains order of elements that are equal.
And the conventional advice is that, if maintaining order is not important, you should use std::sort() instead.
However, its context dependant.  There is plenty of data that is best sorted with stable sort even if you don't need to maintain order:
Quicksort quickly becomes worst-case performance if the data has consistently poor pivot points.
The Burrows-Wheeler Transform is an algorithm used as part of data compression, e.g. bzip2.  It requires sorting all the rotations of the text.  For the majority of text data, merge sort (as often used by std::stable_sort()) is substantially faster than quicksort (as usually used by std::sort()).
bbb is a BWT implementation that notes the advantages of std::stable_sort() over sort() for this application.
",9,810951
811055,"

How big is the performance gap in
  practice? Do you have some experience
  about that?

Yes, but it didn't go the way you would expect.
I took a C implementation of the Burrows-Wheeler Transform and C++-ified it. Turned out a lot slower than the C code (though the code was cleaner). So I put timing instrumentation in there and it appeared that the qsort was performing faster than the std::sort. This was running in VC6. It was then recompiled with stable_sort and the tests ran faster than the C version. Other optimisations managed to push the C++ version ~25% quicker than the C version. I think it was possible to eke more speed but the clarity of the code was disappearing.
",2,810951
17403655,"
If you are sorting a large number of structs, the IO speed of your memory/disk starts to become more important than the asymptotic running time. Furthermore, memory usage should also be taken into consideration.
I tried std::stable_sort on 2Gb of data (64B structs), not knowing that std::stable_sort creates an internal copy of the data. The swap trashing that followed almost locked up my pc.
Using the unstable std::sort reduces memory usage by a factor of 2, which is useful when sorting large arrays. I terminated the std::stable_sort, so I cannot determine how much slower it was. However, if stable sort is not required, then I think it is better to use the unstable std::sort.
",1,810951
39345161,"
Was looking for something similar - but was surprised no one talked about Auxiliary space.
As I believe - the implementation of both stable_sort and sort is supposed to guarantee O(NlogN) for all (Best, Average & Worst) cases.
However, the difference exists in the Auxiliary space used.
stable_sort needs an Auxiliary space of O(N).
May be the difference in performance lies in acquiring that space. :)
Otherwise, theoretically - they are supposed to be same w.r.t performance.
sort should do what you need unless you need this -> 
    stable_sort preserves the relative order of the elements with equivalent values.
",1,810951
788161,"
If your tree widget is called treeWidget, you should be able to call the header() method, which is from QTreeWidget's parent QTreeView, then sortIndicatorOrder() from the QHeaderView class:
With this, you know the user's current sort order, and you can apply your sort on insert according to this.
",2,788080
788146,"
I don't have a setup for testing but according to the documentation, this should cause sorting to occur as items are inserted.
Qt recommends against doing this as there will be a performance cost and say that you should set sorting enabled after all the adds are completed. Hope this helps.
",2,788080
703518,"
I don't think std::sort works on lists as it requires a random access iterator which is not provided by a list<>. Note that list<> provides a sort method but it's completely separate from std::sort.
The choice of container does matter. STL's std::sort relies on iterators to abstract away the way a container stores data. It just uses the iterators you provide to move elements around. The faster those iterators work in terms of accessing and assigning an element, the faster the std::sort would work.
",12,703503
703537,"
The choice does make a difference, but predicting which container will be the most efficient is very difficult. The best approach is to use the container that is easiest for your application to work with (probably std::vector), see if sorting is adequately fast with that container, and if so stick wth it. If not, do performance profiling on your sorting problem  and choose  different container based on the profile data.
As an ex-lecturer and ex-trainer, I sometimes feel personally responsible for the common idea that a linked list has mystical performance enhancing properties. Take it from one who knows: the only reason a linked list appear in so many text books and tutorials is because it is covenient for the people who wrote those books and tutorials to have  a data structure that can illustrate pointers, dynamic memory mangement, recursion, searching and sorting all in one - it has nothing to do with efficiency.
",14,703503
703524,"
std::list is definitely not a good (valid) choice for std::sort(), because std::sort() requires random-access iterators.  std::map and friends are also no good because an element's position cannot be enforced; that is, the position of an element in a map cannot be enforced by the user with insertion into a particular position or a swap.  Among the standard containers we're down to std::vector and std::deque.
std::sort() is like other standard algorithms in that it only acts by swapping elements' values around (*t = *s).  So even if list would magically support O(1) access the links wouldn't be reorganized but rather their values would be swapped.
Because std::sort() doesn't change the container's size it should make no difference in runtime performance whether you use std::vector or std::deque.  Primitive arrays should be also fast to sort, probably even faster than the standard containers -- but I don't expect the difference in speed to be significant enough to justify using them.
",8,703503
703512,"
It depends on the element type.
If you're just storing pointers (or POD) then vector will be fastest. If you're storing objects then list's sort will be faster as it will swap nodes and not physical elements.
",5,703503
703519,"
The sort algorithm knows nothing about your container. All it knows about are random-access iterators. Thus you can sort things that aren't even in a STL container. So how fast it is going to be depends on the iterators you give it, and how fast it is to dereference and copy what they point to.
std::sort won't work on std::list, since sort requires random access iterators. You should use one of std::list's member function sorts for that case. Those member functions will efficiently swap around linked list pointers instead of copying elements.
",1,703503
709593,"
Vector.
Always use vector as your default.  It has the lowest space overheads and fastest access of any other container (among other advantages like C-compatible layout and random-access iterators).
Now, ask yourself - what else you doing with your container?  Do you need strong exception guarantees?  List, set and map are likely to be better options (though they all have their own sort routines).  Do you need to regularly add elements to the front of your container?  Consider deque.  Does your container need to always be sorted?  Set and map are likely to be a better fit.  
Finally, figure out specifically what ""best"" is for you and then choose the most appropriate container and measure how it performs for your needs.
",1,703503
703533,"
It surely does matter, just because different containers have different memory access patterns etc. which could play a role.
However, std::sort doesn't work on std::list<>::iterators as these are not RandomAccessIterators. Moreover, although it would be possible to implement a specialization for std::list<> that would shuffle the nodes' pointers, it would probably have strange and surprising semantic consequences - eg. if you have an iterator inside sorted range in a vector, its value will change after the sorting, which would not be true with this specialization.
",0,703503
703574,"
std::sort requires random access iterators, so your only options to use that are vector or deque. It will swap the values, and at a guess vector will probably perform slightly faster than deque because it typically has a simpler underlying data structure. The difference is likely very marginal though.
If you use a std::list, there is a specialisation (std::list::sort) which should swap the pointers rather than the values. However because it's not random access it'll use mergesort instead of quicksort, which will probably mean that the algorithm itself is a little slower.
Anyway, I think the answer is normally vector. If you have large classes for each element so copying overhead dominates the sorting process, list might beat it. Or alternatively you could store pointers to them in a vector and supply a custom predicate to sort them appropriately.
",0,703503
40867671,"
I totally agree with the statements that guys have posted above. But what is the best way to learn new things? Hey!!!! surely not reading the text and learning by heart but.... EXAMPLES :D As recently I immersed in containers specified in STL, here is the quick test code that is self-explanatory, I hope:
And the code for timer:
Here is the result when no optimization is used (g++ --std=c++11 file.cpp -o a.out):
array allocates 0.958443 MB
action sort array took: 183ms
action sort vector took: 316ms
action sort list took: 725ms
action sort deque took: 436ms 
and with optimization (g++ -O3 --std=c++11 file.cpp -o a.out):
array allocates 0.958443 MB
action sort array took: 55ms
action sort vector took: 57ms
action sort list took: 264ms
action sort deque took: 67ms 
Notice that although vector and array has similar times sorting for this case, array size is limited as it is supposed to be initialized on stack (by default, not using own allocators etc.)
So it depends also if you use optimization for compiler, if not, we may see noticeable difference.
",0,703503
688068,"
You can just do 
And it will sort your strings. Then go through them checking whether they are in order
In particular, std::string::compare couldn't be used as a comparator, because it doesn't do what sort wants it to do: Return true if the first argument is less than the second, and return false otherwise. If you use sort like above, it will just use operator<, which will do exactly that (i.e std::string makes it return first.compare(second) < 0).
",63,688039
688064,"
What is the question exactly? It seems everything is already there.
However, you should probably use std::cout << *i << std::endl;

i is an iterator == pointer to the data in the container, so * is needed
c_str() is a function of std::string and not a variable

The problems in your code do not relate to your question?
Some hints for you:

std::vector also overrides [] operator, so you can instead save the iterator hassle and use it like an array (iterate from 0 to vector.size()).
You could use std::set instead, which has automatically sorting on insertion (binary tree), so you save the extra sorting.
Using a functor makes your output even more fun: copy(V.begin(), V.end(), ostream_iterator<std::string>(cout, ""\n""));

",3,688039
688094,"
litb is correct, as always.
I just wanted to point out the more general point - anything that can be compared with < can be sorted with std::sort.  I'll sometimes sneak an operator< member function into a struct, just so I can do this.
",2,688039
688076,"
For sort use:
std::sort  or std::vector< std::string>::sort(..) method.
To check if it is sorted:
use std::is_sorted for check is sorted -  http://www.sgi.com/tech/stl/is_sorted.html
or
std::adjacent_find( v.begin(), v.end(), std::greater< std::string >() ) == v.end() 
for your case you could use default comparator
EDITED:
std::is_sorted is not standard stl function, it defined in sgi stl implementation.
Thanks @Brian Neal for this note.
",2,688039
33839283,"
Sorting the string:
Checking whether vector is sorted:
C++11 Method to check sorted vector:
std::is_sorted(vec.begin(),vec.end())
Now printing the sorted vector:
",0,688039
688305,"
You could use a std::set, which is naturally a sorted container.
",0,688039
49332788,"
Try using comaprator:
",0,688039
642258,"
I asked this exact question (although in Java) and got pointed to http://www.davekoelle.com/alphanum.html which has an algorithm and implementations of it in many languages.
",15,642213
642220,"
This is known as natural sorting. There's an algorithm here that looks promising.
Be careful of problems with non-ASCII characters (see Jeff's blog entry on the subject).
",6,642213
26765718,"
Several natural sort implementations for C++ are available. A brief review:

natural_sort<> - based on Boost.Regex.

In my tests, it's roughly 20 times slower than other options.

Dirk Jagdmann's alnum.hpp, based on Dave Koelle's alphanum algorithm

Potential integer overlow issues for values over MAXINT

Martin Pool's natsort - written in C, but trivially usable from C++.

The only C/C++ implementation I've seen to offer a case insensitive version, which would seem to be a high priority for a ""natural"" sort.
Like the other implementations, it doesn't actually parse decimal points, but it does special case leading zeroes (anything with a leading 0 is assumed to be a fraction), which is a little weird but potentially useful.
PHP uses this algorithm.


",4,642213
33724751,"
Partially reposting my another answer:
toUpper() function:
Usage:
",1,642213
34514673,"
To solve what is essentially a parsing problem a state machine (aka finite state automaton) is the way to go. Dissatisfied with the above solutions i wrote a simple one-pass early bail-out algorithm that beats C/C++ variants suggested above in terms of performance, does not suffer from numerical datatype overflow errors, and is easy to modify to add case insensitivity if required.
sources can be found here
",0,642213
4639860,"
I am not very sure if it is you want, anyway, you can have a try:-)
",-1,642213
610146,"
C++ Standard ISO/IEC 14882:2003 says:

23.2.2.4/31 
Notes: Stable: the relative order of the equivalent elements is preserved. If an exception is thrown the
  order of the elements in the list is indeterminate.

",23,609956
609996,"
Yes, std::list<>::sort is guaranteed to be stable.
See http://www.sgi.com/tech/stl/List.html
",13,609956
610002,"
According to ""The C++ Programming Language"" (Stroustrup p470), yes, stl::list<>::sort is stable.
",10,609956
583094,"
Is there a reason you can't null-terminate your buffers?
If not, since you're using C++ you can write your own function object:
",3,583063
583098,"
With std::sort, you can use a Functor like this:
Then you can do this:
EDIT: from the comment suggestions (i guess both strings are in a common buffer?):
",7,583063
583125,"
With the C function qsort(), no, there is no way to pass the length to your comparison function without using a global variable, which means it can't be done in a thread-safe manner.  Some systems have a qsort_r() function (r stands for reentrant) which allows you to pass an extra context parameter, which then gets passed on to your comparison function:
",4,583063
583081,"
Can you pack your buffer pointer + length into a structure and pass a pointer of that structure as void *?
",2,583063
6270050,"
You could use a hack like:
which you would first call as buffcmp(&bsize, NULL) and then pass it as the comparison function to qsort.
You could of course make the comparison behave more naturally in the case of buffcmp(NULL, NULL) etc by adding more if statements. 
",1,583063
583101,"
You could functors (give the length to the functor's constructor) or Boost.Lambda (use the length in-place).
",0,583063
583114,"
I'm not clear on what you're asking. But I'll try, assuming that

You have a single buffer
You have an array of pointers of some kind which has been processed in some way so that some or all of its contents point into the buffer 

That is code equivalent to:
Now if you control the allocation of the buffer, you could substitute
and go ahead using strcmp. This may be possible even if you don't control the filling of the buffer.
If you have to live with a buffer handed you by someone else you can

Use some global storage (which you asked to avoid and good thinking).
Hand the sort function something more complicated than a raw pointer (the address of a struct or class that supports the extra data). For this you need to control the deffinition of ary in the above code.
Use a sort function which supports an extra input. Either sort_r as suggested by Adam, or a home-rolled solution (which I do recommend as an exercise for the student, and don't recommend in real life). In either case the extra data is probably a pointer to the end of the buffer.

",0,583063
583124,"
memcmp should stop on the first byte that is unequal, so the length should be large, i.e. to-the-end-of-the-buffer. Then the only way it can return zero is if it does go to the end of the buffer.
(BTW, I lean toward merge sort myself. It's stable and well-behaved.)
",-2,583063
438057,"
__merge_without_buffer() is performing an in-place merge, as the merge step of an in-place merge sort.  It takes as input two ranges of data [first, middle) and [middle, last) which are assumed to already be sorted.  The len1 and len2 parameters are equal to the lengths of the two input ranges, namely (middle - first) and (last - middle) respectively.
First, it picks a pivot element.  Then, it rearranges the data into the order A1 B1 A2 B2, where A1 is the set of elements in [first, middle) that are less than the pivot, A2 is the set of elements in [first, middle) greater than or equal to the pivot, B1 is the set of elements in [middle, last) less than the pivot, and B2 is the set of elements in [middle, last) greater than or equal to the pivot.  Note that the data is originally in the order A1 A2 B1 B2, so all we need to do is to turn A2 B1 into B1 A2.  This is with a call to std::rotate(), which does just that.
Now we've separated out the elements which are less than the pivot (A1 and B1) from those that are greater than or equal to the pivot (A2 and B2), so now we can recursively merge the two subranges A1 A2 and B1 B2.
How do we choose a pivot?  In the implementation I'm looking at, it chooses the median element from the larger subrange (i.e. if [first, middle) has more elements than [middle, last), it chooses the median of [first, middle); otherwise, it chooses the median of [middle, last)).  Since the subranges are already sorted, choosing the median is trivial.  This pivot choice ensures that when recursively merging the two subranges, each subproblem is no more than 3/4 the size of the current problem, because in the worst case, at least 1/4 of the elements are larger than or smaller than the pivot.
What is the running time of this?  The std::rotate() call takes O(N) time, and we make two recursive calls to ourselves.  This equates to a running time of O(N log N).  However, note that this is only one step in mergesort: remember that in mergesort you first recursively sort both halves and then merge.  Thus, the recurrence relation for the running time of mergesort is now:
T(N) = 2T(N/2) + O(N log N)
Plug this into the Master theorem, and you get that mergesort now runs in O(N log2 N) time!
As an interesting final point, consider the following three qualities of a comparison-based sorting algorithm:

In-place
Stable
Runs in O(N log N) time

You can usually only get 2 of these at once - quicksort gets you (1) and (3), mergesort gets you (2) and (3), and an in-place mergesort gets you (1) and (2).  Non-comparison-based sorts such as count sort can achieve all 3, but those sorts can only sort certain data types.  It's possible there exists a comparison-based sort which achieves all 3, but if there is, I'm not aware of its existence, and it's almost certainly much more complicated.
",11,438012
377737,"
To do this, use QTreeView::setSortingEnabled() and QTreeView::sortByColumn.  Just remember to turn this on /after/ you initially populate the widget, and turn it off again /before/ doing any bulk updates for efficiency.
",12,372391
330196,"
To answer your first question, yes. It is perfectly safe to modify the members of your pair, since the actual data in the pair does not affect the vector itself.
edit: I have a feeling that you were getting an error when using a map because you tried to modify the first value of the map's internal pair. That would not be allowed because that value is part of the map's inner workings.
As stated by dribeas:
In maps you cannot change first as it would break the invariant of the map being a sorted balanced tree

edit: To answer your second question, I see nothing at all wrong with the way you are structuring the data, but I would have the database hold pointers to DnaPairT objects, instead of the objects themselves. This would dramatically reduce the amount of memory that gets copied around during the sort procedure.
The only reason you might need to look into more efficient methods is if your database is so enormous that the sorting loop takes too long to complete. If that is the case, though,  I would imagine that your query function would be the one taking up most of the processing time.
",5,330186
330252,"
You can't modify since the variable first of std::pair is defined const
",1,330186
328959,"
std::sort takes a different compare function from that used in qsort. Instead of returning –1, 0 or 1, this function is expected to return a bool value indicating whether the first element is less than the second.
You have two possibilites: implement operator < for your objects; in that case, the default sort invocation without a third argument will work; or you can rewrite your above function to accomplish the same thing.
Notice that you have to use strong typing in the arguments.
Additionally, it's good not to use a function here at all. Instead, use a function object. These benefit from inlining.
",25,328955
328981,"
In C++, you can use functors like boost::bind which do this job nicely:
If you need to do this many times, you can also solve the problem by making a function object which accepts member pointers and does the sort. You can reuse it for any kind of object and members. First how you use it:
Here is the code for make_cmp. Feel free to rip it (using boost::preprocessor):
",7,328955
5693570,"
With C++0x and lambdas Konrad's solution looks like this:
",5,328955
314527,"
",15,314492
314571,"
Use the GNU sort program (externally) if you can't fit the data into RAM: it will sort arbitrary sized files and the larger the file, the smaller the additional cost of creating the process.
",6,314492
314556,"
You can use the algorithms in the STL on arrays native datatypes, not just on STL containers.  The other suggestion to use std::sort won't work as posted however, because strcmp returns a value that evaluates to true for all comparisons when the strings aren't the same, not just if the left hand side is less than the right hand side -- which is what std::sort wants; a binary predicate returning true of the left hand side is less than the right hand side.
This works:
",5,314492
314606,"
boost::bind can do it:
Edit: The strings are not null-terminated:
",3,314492
314533,"
Probably the easiest way is to used the old stdlib.h function qsort.
This should work:
Please note that this is standard C and only works reliable with English text.
If you have a list of String objects, then other things are possible in C++.
If you are on Linux and writing a gtk or Qt application then I would propose that you have a look at these libraries beforehand.
",2,314492
314544,"
If the files are large and do not fit in RAM, you can use bin/bucket sort to split the data into smaller files and finally aggregate the pieces in a result file. Other responses show you how to sort each individual bucket file.
",2,314492
314827,"
The canonical way to sort an array of character strings in C, and therefore an available but not necessarily recommended way to do so in C++, uses a level of indirection to strcmp():
",0,314492
317382,"
A few things come to mind:

If your data is too big to fit into memory, you may want to just build up an index in-memory of file offsets, then memory-mapping the file to access the strings (depends on your OS).
In-place is going to require a lot of memory copies.  If you can, use a shell sort.  Then once you know the final order, it's much easier to reorder the strings in-place in linear time.
If the strings are all the same length, you really want a radix sort.  If you're not familiar with a radix sort, here's the basic idea:  Comparison-based sorting (which is what std::sort, qsort, and any other general-purpose sorting) always requires O(N log N) time.  Radix sorting compares a single digit at a time (starting at str[0] and ending at str[K-1] for a K-lenth string), and overall can require only O(N) time to execute.

Consult the Internetfor a much better detailed description of radix sorting algorithms than I can provide.  Aside from what I've said, I would avoid all of the other solutions that use standard libarary sorting facilities.  They just aren't designed your particular problem, unfortunately.
",0,314492
321584,"
You probably want to look into memory mapped files (see http://en.wikipedia.org/wiki/Memory-mapped_file), mmap() function (http://en.wikipedia.org/wiki/Mmap) on POSIX-complaint OSes. You'll essentially get a pointer to contiguous memory representing the file's contents.
The good side is that the OS will take care of loading parts of the file into memory and unloading them again, as needed.
One downside is that you'll need to resolve to some form of file locking to avoid corruption if more than one process is likely to access the file.
Another downside is that this doesn't guarantee good performance - to do that, you'll need a sorting algorithm that tries to avoid constantly loading and unloading pages (unless of course you have enough memory to load the entire file into memory).
Hope this has given you some ideas!
",0,314492
275033,"
You could build a little chaining system like so:
Then to use it:
The last line is a little verbose, but I think it's clear what's intended.
",8,274951
274963,"
One conventional way to handle this is to sort in multiple passes and use a stable sort. Notice that std::sort is generally not stable. However, there’s std::stable_sort.
That said, I would write a wrapper around functors that return a tristate (representing less, equals, greater).
",2,274951
11167563,"
You can try this:
Usage:
Implementation:
",2,274951
275014,"
std::sort is not guaranteed to be stable because stable sorts are usually slower than non-stable ones ... so using a stable sort multiple times looks like a recipe for performance trouble...
And yes it's really a shame that sort ask for a predicate:
I see no other way than create a functor accepting a vector of tristate functions ...
",2,274951
276172,"
The chaining solution is verbose. You could also use boost::bind in conjunction with std::logical_and to build your sorting predicate. See the linked article for more information: How the boost bind library can improve your C++ programs
",1,274951
15014633,"
Variadic templates in C++ 11 give a shorter option:
",1,274951
244507,"
std::sort() should work:
This uses the pointer to the first element in the array as the start iterator, and the pointer to one past the last element as the last iterator (should never be dereferenced anyway, so all's well). You could also pass in a custom predicate if the array contained more interesting data:
Oh - and don't use CArray.
",9,244487
236199,"
friol's approach is good when coupled with yours. First, build a vector consisting of the numbers 1…n, along with the elements from the vector dictating the sorting order:
Now you can sort this array using a custom sorter:
Now you've captured the order of rearrangement inside order (more precisely, in the first component of the items). You can now use this ordering to sort your other vectors. There's probably a very clever in-place variant running in the same time, but until someone else comes up with it, here's one variant that isn't in-place. It uses order as a look-up table for the new index of each element.
",29,236172
238095,"
Put your values in a Boost Multi-Index container then iterate over to read the values in the order you want. You can even copy them to another vector if you want to.
",8,236172
342940,"
Now you can use the ""indices"" vector to index into ""Values"" vector.
",8,236172
236193,"
Only one rough solution comes to my mind: create a vector that is the sum of all other vectors (a vector of structures, like {3,Third,...},{1,First,...}) then sort this vector by the first field, and then split the structures again.
Probably there is a better solution inside Boost or using the standard library.
",4,236172
4265862,"
You can probably define a custom ""facade"" iterator that does what you need here. It would store iterators to all your vectors or alternatively derive the iterators for all but the first vector from the offset of the first. The tricky part is what that iterator dereferences to: think of something like boost::tuple and make clever use of boost::tie. (If you wanna extend on this idea, you can build these iterator types recursively using templates but you probably never want to write down the type of that - so you either need c++0x auto or a wrapper function for sort that takes ranges)
",3,236172
238075,"
I think what you really need (but correct me if I'm wrong) is a way to access elements of a container in some order.
Rather than rearranging my original collection, I would borrow a concept from Database design:  keep an index, ordered by a certain criterion.  This index is an extra indirection that offers great flexibility.
This way it is possible to generate multiple indices according to different members of a class.
",2,236172
8584552,"
ltjax's answer is a great approach - which is actually implemented in boost's zip_iterator http://www.boost.org/doc/libs/1_43_0/libs/iterator/doc/zip_iterator.html
It packages together into a tuple whatever iterators you provide it. 
You can then create your own comparison function for a sort based on any combination of iterator values in your tuple. For this question, it would just be the first iterator in your tuple.
A nice feature of this approach is that it allows you to keep the memory of each individual vector contiguous (if you're using vectors and that's what you want). You also don't need to store a separate index vector of ints.
",1,236172
26533002,"
A slightly more compact variant of xtofl's answer for if you are just looking to iterate through all your vectors based on the  of a single keys vector. Create a permutation vector and use this to index into your other vectors.
",1,236172
27423416,"
This would have been an addendum to Konrad's answer as it an approach for a in-place variant of applying the sort order to a vector. Anyhow since the edit won't go through I will put it here
Here is a in-place variant with a slightly higher time complexity that is due to a primitive operation of checking a boolean. The additional space complexity is of a vector which can be a space efficient compiler dependent implementation. The complexity of a vector can be eliminated if the given order itself can be modified.
Here is a in-place variant with a slightly higher time complexity that is due to a primitive operation of checking a boolean. The additional space complexity is of a vector which can be a space efficient compiler dependent implementation. The complexity of a vector can be eliminated if the given order itself can be modified. This is a example of what the algorithm is doing. 
If the order is   3 0 4 1 2, the movement of the elements as indicated by the position indices would be 3--->0; 0--->1; 1--->3; 2--->4; 4--->2.
",1,236172
35901428,"
Here is a relatively simple implementation using index mapping between the ordered and unordered names that will be used to match the ages to the ordered names:
For the sake of completeness, here are the functions populate() and print():
and:
And finally, main() becomes:
",0,236172
44987027,"
",0,236172
46370413,"
So many asked this question and nobody came up with a satisfactory answer. Here is a std::sort helper that enables to sort two vectors simultaneously, taking into account the values of only one vector. This solution is based on a custom RadomIt (random iterator), and operates directly on the original vector data, without temporary copies, structure rearrangement or additional indices:
C++, Sort One Vector Based On Another One
",-2,236172
218720,"
I would use set::lower_bound to find the matching or greater value, then decrement the iterator to check the next lower value.  You should use std::set rather than std::map since your key is embedded in the object - you'll need to provide a functor that compares the timestamp members.
",7,218488
218574,"
I would use equal_range too for such a thing.
If you are using sort() every time on your vector it might be better to use a map (or set), as that's always sorted automatically, and use the member equal_range
But that depends on the the amount of inserts / queries / amount of data. (although for something that always needs to be sorted when I query, a map would be my first choice, and I'd only use a vector if there was a very good reason)
",7,218488
218569,"
Depending on what your usage is, you could do a simple linear search instead of a sort.  Come up with a ""distance"" function, loop through keeping track of the best match so far, and its distance.  When you find a better match, forget the previous one, and keep the new one and its distance.  When you've looped through everything, you have your match.
This works out to be O(N*S) where N is the number of items in the vector and S is the number of searches.
Your current way is O((N+S)*LogN) which is greater if the number of searches is small and bounded.   Otherwise the sort / binary search is better.
",0,218488
6508063,"
",0,218488
13481,"
Since you're using C++, I would do it something like this. The SortIntPointers function can be any sort algorithm, the important part is that it sorts the array of pointers based on the int that they are pointing to. Once that is done, you can go through the array of pointers and assign their sorted index which will end up in the original position in the original array.
Hopefully that's clear enough.
",7,13473
119587,"
Ok, here is my atempt in C++  
",3,13473
13482,"
create a new array with increasing values from 0 to n-1 (where n is the length of the array you want to sort). Then sort the new array based on the values in the old array indexed by the values in the new array. 
For example, if you use bubble sort (easy to explain), then instead of comparing the values in the new array, you compare the values in the old array at the position indexed by a value in the new array:
",2,13473
13477,"
Well, there's a trival n^2 solution.
In python:
Depending on how large your list is, this may work. If your list is very long, you'll need to do some strange parallel array sorting, which doesn't look like much fun and is a quick way to introduce extra bugs in your code.
Also note that the above code assumes unique values in oldArray. If that's not the case, you'll need to do some post processing to solve tied values.
",0,13473
122083,"
Parallel sorting of vector using boost::lambda...
Note: I used vectorS instead of arrays because it is clearer/easier, also, I used C-style indexing which starts counting from 0, not 1.
",0,13473
33194962,"
create a new Array and use bubble sort to rank the elements
The rank of each element will be rank[i]+1 to be in the order of 1,2,....n
",0,13473
44255995,"
This is a solution in c language
",0,13473
13105343,"
Boost.Container flat_set

Boost.Container flat_[multi]map/set containers are ordered-vector based associative containers based on Austern's and Alexandrescu's guidelines. These ordered vector containers have also benefited recently with the addition of move semantics to C++, speeding up insertion and erasure times considerably. Flat associative containers have the following attributes:

Faster lookup than standard associative containers
Much faster iteration than standard associative containers.
Less memory consumption for small objects (and for big objects if shrink_to_fit is used)
Improved cache performance (data is stored in contiguous memory)
Non-stable iterators (iterators are invalidated when inserting and erasing elements)
Non-copyable and non-movable values types can't be stored
Weaker exception safety than standard associative containers (copy/move constructors can throw when shifting values in erasures and insertions)
Slower insertion and erasure than standard associative containers (specially for non-movable types)


Live demo:


jalf: If you want a sorted vector, it is likely better to insert all the elements, and then call std::sort() once, after the insertions.

boost::flat_set can do that automatically:

Effects: Constructs an empty set using the specified comparison object and allocator, and inserts elements from the range [first, last).
Complexity: Linear in N if the range [first, last) is already sorted using comp and otherwise N*log(N), where N is last - first. 

",28,2710221
2710332,"
The reason such a container is not part of the standard library is that it would be inefficient. Using a vector for storage means objects have to be moved if something is inserted in the middle of the vector. Doing this on every insertion gets needlessly expensive. (On average, half the objects will have to be moved for each insertion. That's pretty costly)
If you want a sorted vector, it is likely better to insert all the elements, and then call std::sort() once, after the insertions.
",8,2710221
2710278,"
I think there's not 'sorted container' adapter in the STL because there are already the appropriate associative containers for keeping things sorted that would be appropriate to use in nearly all cases. To be honest, about the only reason I can think of off the top of my head for having a sorted vector<> container might be to interoperate with C functions that expect a sorted array. Of course, I may be missing something.
If you feel that a sorted vector<> would be more appropriate for your needs (being aware of the shortcomings of inserting elements into a vector), here's an implementation on Code Project:

An STL compliant sorted vector By Martin Holzherr

I've never used it, so I can't vouch for it (or its license - if any is specified).  But a quick read of the article and it looks like the author at least made a good effort for the container adapter to have an appropriate STL interface.
It seems to be worth a closer look.
",5,2710221
2710744,"
If you decide to roll your own, you might also want to check out boost:ublas.  Specifically:
and look at coordinate_vector, which implements a vector of values and indexes.  This data structure supports O(1) insertion (violating the sort), but then sorts on-demand Omega(n log n).  Of course, once it's sorted, lookups are O(logn). If part of the array is sorted, the algorithm recognizes this and sorts only the newly added elements, then does an inplace merge.  If you care about efficiency, this is probably the best you can do.
",4,2710221
2710343,"
Alexandresu's Loki has a sorted vector implementation, if you dont want to go through the relativley insignicant effort of rolling you own. 
http://loki-lib.sourceforge.net/html/a00025.html
",3,2710221
30906195,"
Here is my sorted_vector class that I've been using in production code for years.  It has overloads to let you use a custom predicate.  I've used it for containers of pointers, which can be a really nice solution in a lot of use cases.
",0,2710221
2700300,"
It is a quirk of C++ that arbitrary pointers of the same type are not (necessarily) comparable with <, but are comparable with std::less.
Unfortunately, the operator< for std::pair is defined in terms of operator< on the components, not std::less.
So, assuming that you want two pairs to fall in the same sort position if and only if they point to the same two objects, you need:
On pretty much any system you can name, this should compile to the same code as return lhs < rhs;, but that is not formally correct. If the referands of the pointers are all subobjects of the same object (for instance if you have a huge array and all the pairs point to elements of that one array), then operator< is OK for the pointers and hence OK for std::pair<pointer,pointer>.
If you want to pairs to fall in the same sort position if and only if the objects they point to sort the same, then you'd add the extra dereference:
and perhaps you'd also add checks for null pointers, if those are permitted. Of course if you know that SomeClass really is a class type, not a pointer type, then you don't need to use std::less in the version above, just define operator< for SomeClass and:
You may or may not be able to optimise that a bit, since there are some repeated null checks performed in both the first and second calls to lessptr. If you care that much, see what the compiler does with it.
",9,2699642
2699665,"
Assuming your class has comparison operators:
If you just want to compare the pointer addresses, use std::greater<T>:
EDIT: OK, I really have no idea what you are trying to do now, with your most recent edit. Why not just use the default sort, if all you want to do is find duplicates?
",4,2699642
2699845,"
If I understand correctly Your predicate should have the following signature
I know nothing about Your class and if there is any natural order for it, so it's hard to guess how You want to sort it. In The comment You write that the biggest items should be first. I assume there is < operator for the class. How about this?
EDIT: Ok thx for clarifying. How about this?
",0,2699642
2699867,"
You should define an operator<on your pair class. I assume that your pair holds item1 and item2. So:
This solution assumes that the items have defined the < and the == operators.
I suppose I didn't meet what you were exactly looking for, but I recommend to overload the <, >, and == operators in your pair class.
",0,2699642
2699467,"
Yes.  See the answers to this question from this morning: C++ struct sorting
",0,2699443
2699476,"
Yes, it is. Take a look here for an example.
",0,2699443
2699091,"
You can build a second map, with the first map's values as keys and the first map's keys as values.
This works only if all values are distinct. If you cannot assume this, then you need to build a multimap instead of a map.
",27,2699060
2699101,"
Dump out all the key-value pairs into a set<pair<K, V> > first, where the set is constructed with a less-than functor that compares the pair's second value only. That way, your code still works even if your values aren't all distinct.
Or dump the key-value pairs into a vector<pair<K, V> >, then sort that vector with the same less-than functor afterwards.
",61,2699060
2699073,"

I wonder how can I implement the STL map sorting by value.

You can’t, by definition. A map is a data structure that sorts its element by key.
",16,2699060
2699079,"
You should use Boost.Bimap for this sort of thing.
",4,2699060
18265044,"
I've just done a similar question in my c++ book. The answer I came up with might not be very efficient though:
",1,2699060
48672896,"
Based on @swegi's idea, I implemented a solution in c++11 using a multimap:
Code on Ideone
I also implemented a C++11 solution based on @Chris' idea using a vector of pairs. For correct sorting, I provide a lambda expression as comparison functor:
Code on Ideone
The first solution is more compact, but both solutions should have roughly the same performance. Inserting into a multimap is of O(log n), but this has to be done for n entries, resulting in O(n log n). Sorting the vector in the second solution also results in O(n log n).
I also gave a try to @Chris' idea on using a set of pairs. However, it won't work if the values aren't all distinct. Using a functor that compares only the pair's second element doesn't help. If you first insert make_pair(1, 1) into the set and then try to insert make_pair(2, 1), then the second pair won't be inserted, because both pairs are seen as identical by that set. You can see that effect here on Ideone.
",1,2699060
14742867,"
Create another map, provide a less() function based on the value not key, AND the function should return true if the value1 <= value2 (not strictly < ). In this case, elements with non-distinct values can be sorted as well. 
",0,2699060
2698876,"
You can define what comparison function to use in each run of the sort algorithm by using the third argument:
A simple example:
",12,2698854
2698881,"
There are 2 versions of std::sort, the 2nd version accepts a comparison functor:
For example:
See also http://www.cplusplus.com/reference/algorithm/sort/.
This variant still uses the same quicksort algorithm, so it's O(n log n) on average.
",2,2698854
2698904,"
There are two versions of std::sort, the first one simply takes the iterators and uses the object's operator< overload, while the second allows you to specify a comparator object to perform the comparison. You simply need to provide a class that conforms to the StrictWeakOrdering concept as a compartor. The comparator object (or function) should be callable with two parameters, where each parameters is of the specified type, and it should return true if the first parameter is less than the second parameter. For example:

bool mycomparator(const T& a, const T&b;); // return true if a < b

OR

class MyComparator
{
    public:
         bool operator()(const T& a, const T& b)const; // return true if a < b
};

",1,2698854
2699399,"
Just for completeness, here is a an example using c++0x lambda functions:
",1,2698854
2699481,"
Boost.Bind allows in simple cases to define a compare function inplace:
Output:
",0,2698854
2686618,"
Typically just create a structure something like this:
Alternatively, just put the eigenvalue/eigenvector into an std::pair -- though I'd prefer eigen.value and eigen.vector over something.first and something.second.
",7,2686548
2686990,"
I've done this a number of times in different situations.  Rather than sorting the array, just create a new array that has the sorted indices in it.  
For example, you have a length n array (vector) evals, and a 2d nxn array evects.  Create a new array index that has contains the values [0, n-1]. 
Then rather than accessing evals as evals[i], you access it as evals[index[i]] and instead of evects[i][j], you access it evects[index[i]][j]. 
Now you write your sort routine to sort the index array rather than the evals array, so instead of index looking like {0, 1, 2, ... , n-1}, the value in the index array will be in increasing order of the values in the evals array.
So after sorting, if you do this:
you'll get a sorted list of evals.
this way you can sort anything that's associated with that evals array without actually moving memory around.  This is important when n gets large, you don't want to be moving around the columns of the evects matrix.
basically the i'th smallest eval will be located at index[i] and that corresponds to the index[i]th evect.
Edited to add.  Here's a sort function that I've written to work with std::sort to do what I just said:
",2,2686548
2686818,"
The solution purely relies on the way you store your eigenvector matrix.
The best performance while sorting will be achieved if you can implement swap(evector1, evector2) so that it only rebinds the pointers and the real data is left unchanged.
This could be done using something like double* or probably something more complicated, depends on your matrix implementation.
If done this way, swap(...) wouldn't affect your sorting operation performance.
",0,2686548
2686874,"
The idea of conglomerating your vector and matrix is probably the best way to do it in C++.  I am thinking about how I would do it in R and seeing if that can be translated to C++.  In R it's very easy, simply evec<-evec[,order(eval)].  Unfortunately, I don't know of any built in way to perform the order() operation in C++. Perhaps someone else does, in which case this could be done in a similar way.
",0,2686548
2639322,"
std::multimap will probably be faster, as it is O(log n) per insertion, whereas an insert and sort of the list is O(n log n).
Depending on your usage pattern, you might be better off with sorted vectors. If you insert a whole bunch of items at once and then do a bunch of reads -- i.e. reads and writes aren't interleaved -- then you'll have better performance with vector, std::sort, and std::binary_search.
",5,2639300
2639318,"
You might consider using the lower_bound algorithm to find where to insert into your list.  http://stdcxx.apache.org/doc/stdlibref/lower-bound.html
Edit: In light of Neil's comment, note that this will work with any sequence container (vector, deque, etc.)
",1,2639300
2639428,"
If you do not need Key/Value pairs std::set or std::multiset is probably better than using std::multimap.
Reference for std::set:
http://www.cplusplus.com/reference/stl/set/
Reference for std::multiset:
http://www.cplusplus.com/reference/stl/multiset/
Edit: (seems like it was unclear before)
It is in general better to use a container like std::(multi)set or std:(multi)map than using std::list and sorting it afterwards everytime an element is inserted because std::list does not perform very good in inserting elements in the middle of the container.
",1,2639300
2639386,"
Generally speaking, iterating over a container is likely to take about as much time as iterating over another, so if you keep adding to a container and then iterating over it, it's mainly a question of picking a container that avoids constantly having to reallocate memory and inserts the way you want quickly.
Both list and multimap will avoid having to reallocate themselves simply from adding an element (like you could get with a vector), so it's primarily a question of how long it takes to insert. Adding to the end of a list will be O(1) while adding to a multimap will be O(log n). However, the multimap will insert the elements in sorted order, while if you want to have the list be sorted, you're going to have to either sort the list in O(n log n) or insert the element in a sorted manner with something like lower_bound which would be O(n). In either case, it will be far worse (in the worst case at least) to use the list.
Generally, if you're maintaining a container in sorted order and continually adding to it rather than creating it and sorting it once, sets and maps are more efficient since they're designed to be sorted. Of course, as always, if you really care about performance, profiling your specific application and seeing which works better is what you need to do. However, in this case, I'd say that it's almost a guarantee that multimap will be faster (especially if you have very many elements at all).
",0,2639300
2554450,"
You are looking at doing double dispatch - that is calling a virtual function depending on the types of two objects rather than one. Take a look at this wikipedia article for a heads-up http://en.wikipedia.org/wiki/Double_dispatch. I have to say that whenever I find myself in this situation, I try to change direction :-)
And can I make a couple of observations about your code. There is nothing precisely wrong with it but:

in C++, the std::list is the container of last resort - you should normally default to using a std:;vector, unless you specifically need a feature that only list provides:
protected data is always a bad idea

",12,2554405
2557292,"
I might be missing something basic in the question, it seems like you're basically trying to do a 2-level sort:

1st, based on class / object type: B < C < G
2nd, amongst similar objects, you want to use the id / var field (except for GrandChild, which doesn't seem to have such a field.)

If that's the case, there are many ways to skin the cat, but why not create a virtual function (e.g. Key()) that all classes override?
Key() could return a std::pair, the first member is something indicating the class order (maybe a char such as 'b', 'c' and 'g', conveniently already in the right order), the second member indicating the rank/order within the class (this would be the id/var data member within the class).  std::pair already supports the 2-level sort.
If that's a correct understanding of the problem, maybe something like this code sample would work for you?
",1,2554405
2554471,"
Have the object provide the sort key in a virtual method, defaulting to the id:
The comparator now uses the key() method instead of directly accessing the id:
Then the Child class can override this behaviour and substitute var as sort key:
Now the sort key depends on the concrete instance that the BaseObject* point to, without casts.
EDIT: Oops, I just understood your problem well enough to realize that this doesn't actually solve. See Neil's answer.
",0,2554405
2554476,"
continute yourself :)
",0,2554405
2554540,"
I see two approaches - Which one depends on how you want to think about the issue ( and who owns the idea of which of two objects should be first).
If the objects themselves should have an idea of how to rank with each other, and you are pretty sure that you are not going to be deriving more classes with different rules, I would probably add a couple of virtual functions to the base class named 'int primarySortKey()' and 'int secondarySortKey()'.  I would use these in the comparator function.
If on the other hand the objects should not have an idea of how they should be sorted ( and the comparator function then needs to know a lot more about the objects, their meaning and structure) I would probably find some way to get the class of the object in the comparator ( either through reflection, or by introducing the idea of a type' and write some twisted logic in the comparator to figure out what to do.
",0,2554405
2555149,"
I only have one question: is it important to be able to sort them in this particular order, or would you be fine with sorting them by type (in any order) and then by key within the type ?
And the Comparator class
No you can't actually put the BaseObject before... but you can partition by category.
The only issue, as mentionned, is that you do not control which category will be the lowest. That would require some template magic (for example) but is it that important ?
",0,2554405
2541699,"
I'm not sure why your code is crashing, but recursion in that case is only going to make the code less readable. I doubt it's a stack overflow, however, because you're not using much stack space in each call.
C++ already has std::sort, why not use that instead? You could do it like this:
To then sort your lines you would call
Now, there is one problem. This will be slow because stringToDouble and getWordsFromSentence are called multiple times on the same string. You would probably want to generate a separate vector which has precalculated the values of each string, and then have CompareByStringValue just use that vector as a lookup table.
Another way you can do this is insert the strings into a std::multimap<double, std::string>. Just insert the entries as (value, str) and then read them out line-by-line. This is simpler but slower (though has the same big-O complexity).
EDIT: Cleaned up some incorrect code and derived from binary_function.
",2,2541608
2541653,"
You could try a method that doesn't involve recursion. if your program crashes using the Sort2D function with large values, then your probably overflowing the stack (danger of using recursion with a large number of function calls). Try another sorting method, maybe using a loop. 
",1,2541608
2542076,"
sort2D crashes because you keep allocating an array of strings to sort and then you pass it by value, in effect using O(2*N^2) memory. If you really want to keep your recursive function, simply pass vn by reference and don't bother with vn2. And if you don't want to modify the original vn, move the body of sort2D into another function (say, sort2Drecursive) and call that from sort2D.
You might want to take another look at sort2D in general, since you are doing O(N^2) work for something that should take O(N+N*log(N)).
",0,2541608
2541776,"
The problem is less your code than the tool you chose for the job. This is purely a text processing problem, so choose a tool good at that. In this case on Unix the best tool for the job is Bash and the GNU coreutils. On Windows you can use PowerShell, Python or Ruby. Python and Ruby will work on any Unix-flavoured machine too, but roughly all Unix machines have Bash and the coreutils installed.
Let $FILES hold the list of files to process, delimited by whitespace. Here's the code for Bash:
",0,2541608
2530027,"
Let's make the algorithm clearer:
This is a very inefficient implementation of insertion sort. 

Example run revealing the insertion sort characteristics:
",12,2529999
2530191,"
This is a kind of a hybrid between a 'classic' bubble sort and a selection sort - but closer to the classic bubble sort.
In the classic bubble sort, the inner loop swaps adjacent pairs as it walks the list/array.
In the classic selection sort, the inner loop keeps track of the largest value it finds in the remaining portion of the list, and swaps it with the first value in the portion of the list that the inner loop is currently considering.
The sort as posted in the question is like the Selection sort in that the swap is always performed with the first value in the sub-list that the inner loop is considering.  It's different from the Selection sort (and is similar to the classic Bubble sort) in that it performs a swap whenever it finds a value larger than the current first member of the inner loop's sub-list.
However, it's different than the classic Bubble sort in that it's not swapping adjacent pairs.  In the classic Bubble sort, when the inner loop has finished working a round, the largest element of the list has filtered to the bottom of the list, but in this variation, the smallest element has filtered to the top of the inner-loop's sub-list.
I'd label this more a variation of the classic Bubble sort rather than the Selection sort because the performance characteristics of the sort in the question are the same as the classic Bubble sort (O(n^2) comparisons and O(n^2) swaps), while a Selection sort has O(n) swaps.  
But, one other difference between the classic Bubble sort and this one is that a classic Bubble sort is stable, while the sort in the question isn't. Consider the following list of items when run through the sort. Only the numbers are used in the comparison - the letters are used just to distinguish between the elements that have the same rank.  The diagrams show the swap operations performed (in the interest of brevity, the comparisons aren't shown):
Note that at the end of the sort, the relative position of items 2.a and 2.b have changed, indicating a non-stable sort.
",5,2529999
2530009,"
This is pretty much bubble sort. Bubble sort performed on a linked list where the values are swapped. The checks node!=null is to confirm whether the end is reached or not.
",3,2529999
2530026,"
Insertion sort
It's very similar to a bubble sort, except that instead of wapping adjacent pairs of items, you move the smallest item to the head of the list, and then the next smallest item into the second position, and so on.
",1,2529999
2530017,"
Its similar to selection sort. In selection sort we find the min value in the list and swap with the first element and repeat the same for other elements in the list. But there we are not swapping after finding the min element, instead everytime we find an element smaller than the first element ( in the first pass) we swap it with the 1st element.
",-1,2529999
2494182,"
Tables and transformations.  
I would first convert the string to either all uppercase or all lowercase:
Next I would check for exceptions or use an equivalency table.  If the character in question is in an array of exception characters, then use an equivalency table.
",0,2494044
2494063,"
As soon as you throw unicode characters into the mix, you have to start thinking about internationalization.  Different languages have different sorting rules.  For example, in Dutch, ""IJ"" is considered a single letter and has its own place in the alphabet.  I recommend a good Unicode library for doing string lexical comparisons, namely International Components for Unicode: http://site.icu-project.org/
With that, you can simply use the ordinary std::sort with ICU's comparator.
",6,2494044
2494159,"
In the past I've used stricoll to sort names, which compares strings following the current locale. Although this worked for strings in the current locale, this not worked when you are dealing with names from different locales in the same database.
",0,2494044
2485909,"
This:
Is equivalent to:
You never swap them, you just copy one to the other. You should add this line:
In between the two. That way, you'll overwrite [i] with [j], but _temp still holds the old value of [i], so you can copy that value into [j], thus swapping them.
I suppose it's also a time for a lesson on algorithms. Your algorithm is known as a ""bubble sort"" algorithm. It is known for it's simplicity, but in a realistic setting it is known for it's inefficiency (the technical term is ""teh sux"", and the real technical term is O(n^2) (""N squared"") performance). Some more common (and more efficient) algorithms include Quicksort, merge sort, and Heapsort, among many others. For more about measuring algorithmic scalability, see the article on Big Oh notation.*
But, as vava pointed out in a comment, unless your assignment is to write your own sorting function, you're going to get better performance with qsort (in C) or std::sort (in C++).
I'm not going to stab at std::sort, but it's going to work about the same (perhaps easier).**
*Note that anyone who likes is free to change these Wikipedia links to Stack Overflow links. It would be better to link to SO, I just linked to Wikipedia because I knew how to find the info I needed faster.
**Note that anyone who likes is free to add a std::sort example. I'm just not sufficiently familiar with C++.
",10,2485899
2485954,"
You didn't swap properly, that's why it didn't work.
",2,2485899
2486066,"
Bad coding style:
1. Don't use global variables. It's better to pass your array and length as arguments into sort function. Why? Your function is not reusable. What if you will need to sort another array? Yes, you will need to write another sort function...
2. More advanced tip: use emulation of higher-order function. What if you will need to sort not only characters? Integer, floats, strings or your own types. In this case you can also pass compare() function into your sort function which can compare objects of your array.
",1,2485899
2465305,"
Polymorphic objects are referred to by pointers or references (or pointer wrappers). Swapping pointers is sufficient then. Actually, you should be able to use std::sort or std::stable_sort with a suitable predicate:
This strategy avoids object slicing.
",8,2465283
2468223,"
@ritmbo, as long as you are not familiar with polymorphism mechanisms, an explanation is needed to fine @Alexander's answer. 
Why do you have to change std::vector<A> into std::vector<A*>?
You want to have a collection of objects of base class, so in order to sort them, you need to move responsibility of object comparison from class A to B and C. To do so, in OOP you use virtual functions. They are bound to an object as a virtual table. If you cast B* to A*, e.g. A* a = new B;, the vtable of a is overwritten by methods from new B. But if you cast B to A, e.g. A a = B(), no method pointers are copied to a's vtable. 
Long story short, you won't move comparison responsibility to class B and C without using pointers (or references, but that's more difficult to maintain). 
",0,2465283
2468255,"
I've got an idea. Your 'polymorphism' tag is quite misleading if you want to store by values. How about simply overwriting the key value in A class objects, which is used by A::sort?
",0,2465283
2448731,"
I wouldn't use raw char * in this scenario as it's going to be an unnecessary headache. Use std::string instead, which will remove the need for the copy constructor, assignment operator and destructor as the compiler-generated ones will be sufficient.
If you then find that copying the data is still a major bottleneck, you could use a boost::shared_ptr to hold the string if you can live with the additional level of indirection in normal use. That way, the string will not be copied if the containing object is copied and you still get the safety of RAII.
",0,2448671
2449117,"
If using manual char* manipulation isn't part of your criteria for the exercise, you could use std::string and let it handle all the allocation issues for you. The std::swap function used by std::sort is even specialized to call std::string::swap for you, which means that it automatically only swaps the pointers to your string data rather than deep-copying.
If you want to use char* for exercise purposes, probably the easiest way to create a free-standing swap function that takes two Page references and just swaps the internal data pointers around. I believe that as long as sort can see a better match than the standard template, it will call your function instead getting the increased performance.
Finally, to answer your question about the header : Compilers are free to implement headers as actual files that include other headers (even ones that might not normally be expected). Almost certainly your iostream header is including algorithm directly or indirectly. On another compiler your code might fail to compile.
",0,2448671
2448457,"
I just kept messing around, and realized that my assignment operator needs to copy all the other parameters over as well, not just the heap allocated ones.
Man do I feel dumb. >_<
Btw followup question: Is there a way to do the sorting without needing to strncpy() all the buffers and just swap the pointer addresses around instead?
edit:
tnx dirkgently. Yeah that's what it was, sry didn't see your comment before I posted this.
",0,2448302
2436728,"
If you are only comparing two Widgets to each other, use a member operator <.  If you are comparing Widget to something else, define a global operator < (the two parameter version, optionally a friend of the Widget class but that is a separate issue.
Functor you really only want if you are doing something a little less orthodox.  Choose a functor if a ""less than"" comparison doesn't make sense in the context of widgets.  In that case, having operator < could be confusing.  Of course, functors still have to provide an ordering, but just because it is an ordering doesn't really mean it is a ""less than"" operation.  (Example, sorting states by population is probably better for a functor than an operator <.
",11,2436705
2436717,"
a. b. Comparison operator for two Widgets is not intuitive thing as for me. Now I can't see what it can do.
Also if this function is not intuitive once you will need one new comparison operator, what you can do in this case?
I prefer functor.
",2,2436705
2436719,"
They should all be the same in terms of performance, but there are other differences between them:

The first two save you having to explicitly specify the comparator, and can be used easily with other operations, possibly poorly defined ones that don't allow explicit specification of a comparator.
Only the functor allows additional data for the comparison. For example, if you were comparing ints, you could create a comparison that compares their distance from a third point, P, which would be a member of the functor instance.
Functors are generally less easy to read (to those not familiar with C++).

Note, you don't need to inherit binary_operator for it to work, although it does give you some nice typedefs.
",1,2436705
2436776,"
For most purposes, a. and b. are the same. So the real question is, when to use a/b and when to use c.
The answer is: use a or b if ""less than"" makes sense for your object in unequivocal terms. If your class is a number, use <.
If ""less than"" makes no sense in the context of your class, then please don't overload ""operator<"" for your class. It will confuse users. Use c. instead, and either make it a nested class or typedef it inside your class so you can write it as Widget::Compare.
",1,2436705
2432946,"
The standard algorithm std::sort requires random access iterators, which std::list<>::iterators are not (list iterators are bidirectional iterators).
You should use the std::list<>::sort member function.
",36,2432857
2432889,"
std::list has a built-in sort method that you need to use since std::sort only works with random access iterators, whereas std::list::iterator merely belongs to the bidirectional iterator class of iterators.
Also, your operator () should be marked const.
Finally, you don’t need to write your own comparer for that, simply use std::greater<T> (located in the standard header <functional>):
",11,2432857
2432931,"
It seems like the iterator types for Result.poly is missing operator -. std::sort doesn't work with std::list change to Result.poly.sort
",4,2432857
2400205,"
Use set_intersection as here. The usual implementation would work similar to the merge part of merge-sort algorithm.
",9,2400157
2400236,"
Since this looks like a HW...I'll give you the algorithm:
",48,2400157
4601106,"
I've been struggling with same problem for a while now, so far I came with:

Linear matching which will yield O(m+n) in worst case. You basically keep two pointers (A and B) each pointing to beginning of each array. Then advance pointer which points to smaller value, until you reach end of one of arrays, that would indicate no intersection. If at any point you have *A == *B - here comes your intersection.
Binary matching. Which yields ~ O(n*log(m)) in worst case. You basically pick smaller array and perform binary search in bigger array of all elements of the smaller array. If you want to be more fancy, you can even use last position where binary search failed and use it as starting point for next binary search. This way you marginally improve worst case but for some sets it might perform miracles :)
Double binary matching. It's a variation of regular binary matching. Basically you get element from the middle of smaller array and do binary search in bigger array. If you find nothing then you cut smaller array in half (and yes you can toss element you already used) and cut bigger array in half (use binary search failure point). And then repeat for each pair. Results are better than O(n*log(m)) but I am too lazy to calculate what they are.

Those are two most basic ones. Both have merits. Linear is a bit easier to implement. Binary one is arguably faster (although there are plenty of cases when linear matching will outperform binary).
If anyone knows anything better than that I would love to hear it. Matching arrays is what I do these days.
P.S. don't quote me on terms ""linear matching"" and ""binary matching"" as I made them up myself and there are probably fancy name for it already.
",18,2400157
2401047,"
",1,2400157
45516675,"
Let's consider two sorted arrays: -
While loop will run till both pointers reach up to the respective lengths.
Output will be: - 
",0,2400157
31011621,"
",-1,2400157
2386586,"
In a sense the other two are implicit, but more accurate would be to say that a comparison sort doesn't actually need a tri-valued comparator, and C++'s sorts are implemented in a way which doesn't use one in order to minimise the behaviour required of the comparator. 
It would be wrong for std::sort to define and exclusively use something like this:
... because you'd end up with an inefficient algorithm in terms of number of calls to lessthan. If your algorithm doesn't do anything useful with the difference between a 1 return and a 0 return, then you've wasted a comparison.
C++ refers to ""strict weak orderings"". If < is a strict weak ordering, and !(a < b) && !(b < a), it doesn't necessarily follow that a == b. They're just ""in the same place"" in the ordering, and !(a < b) && !(b < a) is an equivalence relation. So the comparator required by sort orders equivalence classes of objects, it doesn't provide a total order.
The only difference it makes is what you say when !(a < b). For a strict total order, you would deduce b <= a, read ""less than or equal to"". For a strict weak order, you can't define b <= a to mean b < a || b == a and have this be true. C++ is pedantic about this, and since it allows operator overloading it pretty much has to be, since people overloading operators need the jargon in order to tell users of their code what they can expect in terms of how the operators relate. Java does talk about the comparator and the hashCode being consistent with equals, which is all you need. C++ has to deal with <, >, ==, <=, >=, the post-condition of assignment, and so on.
C++ takes quite a pure mathematical approach to this in the API, so everything is defined in terms of the single binary relation. Java is friendlier in some respects, and prefers three-way comparisons where the definition of the fundamental unit (the comparison) is a bit more complex, but the logic leading from it is simpler. It also means the sort algorithm gets more information per comparison, which occasionally is useful. For an example, see the ""Dutch flag"" quicksort optimisation, which is a benefit when there are a lot of ""in the same place"" duplicates in the data.
In that case, a three-values comparator is a speed gain. But C++ uses a consistent definition of a comparator for sort and also for set and map, lower_bound and so on, which barely benefit from a three-value comparator (maybe save one comparison, maybe not). I'd guess they decided not to complicate their nice, general interface in the interests of specific or limited potential efficiency gains.
",11,2385690
2385710,"
My guess in C++ it was done just to reduce code duplication: once you define a compare op on a class/type, you are not only able to compare those objects by simply writing a < b, but also gain the ability to sort sets of such objects.
As for sorting, we only need less-than operator, why introduce additional stuff? :)
",1,2385690
2386205,"
if you're referring to std::sort(), its use only less() operator because it does not need to preserve relative ordering of equivalent element, so it will need just less() operator, and implicitly greater() operator. 
while std::stable_sort will preserve it, but it is slower. it need less() operator and bidirectional iterator in exchange for equal() operator to construct ""trivalue"" compare function
",0,2385690
2378876,"
1) make a function that compares two vectors based on size:
2) sort with it
",14,2378856
2380231,"

make a function which you can use whatever attributes to compare the objects and then use STL sort() algorithm to sort the container.
overload the < operation of that class and make it the same as the above function. Then you can use the sort() function provided by the STL containers (like STL list).

",0,2378856
2346721,"
The default comparator (<) using the default char_traits< char > will sort your list as C a b.
See list::sort.
In order to achieve the desired order a b C you can either:

compose your list of string types with custom char_traits, or
provide an instance of a custom string comparator to sort, e.g.


",4,2346714
2346873,"
Case-insensitive character comparisons are tricky if you want to support characters from other languages. That's why it's a good idea to do them in a locale-sensible manner:
This is how you use this class to compare two chars: 
Just use std::locale() as my_locale if you want to use the one that's set as default.
If you can use Boost then there is am is_iless functor in the String Algorithms library which does the same thing.
Extending this from comparing chars to strings is easy thanks to std::lexicographical_compare:
Now you have all that it's required to solve your problem:
",8,2346714
3009880,"
Here are what I consider to be some cleaner and one significantly faster alternative:
",1,2346714
2346731,"
yes
you can check the following code to use a custom comparator
",0,2346714
51187348,"
Since C++11, you can also use a lambda expression instead of defining a comparator function/struct:
Output:

a
  b
  C

Note: The function strcasecmp() (as also suggested in the answer by @RobertS.Barnes) is not in the C++ standard and, therefore, not available on every system. For example, if you are using Visual Studio, you could use _stricmp() instead.
If internationalization is an issue for you, then you can apply a locale as @Manuel did in his answer.
Code on Ideone
",0,2346714
2330384,"
In pretty much either one, the way is to call strcmp. If your strings (for some weird reason) aren't NUL terminated, you should use strncmp instead.
However, in C++ you really shouldn't be manipulating strings in char arrays if you can reasonably avoid it. Use std::string instead.
",28,2330350
2330363,"
I think you need to use the strcmp() function.
",13,2330350
2330389,"
Make sure the char * isn't null, and if you want, look for the stricmp() function for case insensitive comparisons.  Otherwise, use strcmp().
char * actually represents the memory address of the first character in each string.  So you don't really want to be comparing the values of the pointers, but the contents they point to.
",2,2330350
2330402,"
In C its strcmp() function as already stated. In C++ you can use the compare() function.
C:  
C++ 
",1,2330350
2330424,"
I'm of course assuming here you have char * for the car makes
You want to compare against 0 because strcmp will return 0 if there is no difference between the two strings.
strcmp takes two const char *.
http://www.cplusplus.com/reference/clibrary/cstring/strcmp/
",0,2330350
2330672,"
When you need to compare two char pointers specifically, you can compare them in the usual way: by using comparison operators <, >, == etc.
The issue in ths case is that you don't need to compare two char pointers. What you do need though, is to compare two C-style strings these char pointers are pointing to. In order to compare the C-style strings, you have to use the standard strcmp function.
On top of that, the approach to handling null elements in your sorting algorithm doesn't seem to make any sense whatsoever. Imagine an input array that contains alternating null pointers and non-null pointers. It is obvious, that your sorting algorithm will never sort anything, since the condition in your if will never be true. You need to reconsider your handling of null elements. Of course, first of all, you have to decide what to do with them. Ignore and leave in place? Push to one end of the array? Somethng else?
",0,2330350
18491208,"
strcmp() will help you to compare two char*
http://www.cplusplus.com/reference/cstring/strcmp/?kw=strcmp
",0,2330350
2330642,"
You should really use qsort (in C, #include <stdlib.h>) or std::sort (in C++, #include <algorithm>) instead of a bubble sort like this. If it's C++ and you take @T.E.D.'s advice to use std::string instead of raw C strings, you don't even have to specify a comparison because the < operator will be used and will do the right thing.
",0,2330350
2320055,"
Personally, I think your strategy class should have a ""sort"" method. That way, it can either call std::sort or not, as it sees fit. Whether as well as how becomes part of the sorting strategy.
Darios stable_sort answer is very good, if you can use it.
It is possible to do sorting based on item position in a vector, but it doesn't mean items won't move (many sort algorithms will basically scramble-then-resort your data), so you have to have some reliable way of determining where the items were when you started.
It's possible for the comparison to keep a mapping of current-position to original-position, but a lot of work. Ideally the logic needs to be built into the sort algorithm - not just the comparison - and that's essentially how stable_sort works.
Another problem - depending on the container - the order of (say) item addresses isn't always the order of the items.
",2,2319927
2319958,"

Is there a way of defining a predicate function for sorting a vector which will NOT change anything?

It depends on the algorithm. If your sort is a stable sort, the order of ""equal"" elements won't be changed (which is undefined for unstable sorts).
Consider using std::stable_sort.
",7,2319927
2319945,"
if it is simply a vector you are talking about, perhaps you can get away with providing an interface that determines whether you should sort or not. vectors are not an ordered container, so you need to explicitly sort them. Just don't sort them at all.
",1,2319927
2319981,"
There is no sort function which would keep the order of items based only on items' values. You need to provide more information to your Strategy, if it's possible.
",1,2319927
2319994,"
A different approach might be to bring the semantics of your data to the container. Consider using boost::multi_index for different ways of access and ordering on the same data:
http://www.boost.org/doc/libs/1_42_0/libs/multi_index/doc/index.html
",0,2319927
2312772,"
You could create a std::vector that holds all the indexes of the first vector. You could then sort the index-vector as you like. This should be fast and most importantly, doesn't mean you have to copy the first vector (which is probably more costly!).
",19,2312737
2312834,"
If you don't mind a little bit of Boost you can use the MultiIndex library. See this answer from me where you'll find some example code.
Basically, it allows you to keep several ""views"" of the same data, each with a different order. In your case you'll be able to keep a ""sequence"" view, where the data is in order of insertion (like a vector) and a ""sorted"" view in which the data is sorted according to some criterion (like a map). 
",4,2312737
2312773,"
Any given vector will be sorted in at most one way at any time.
There are two alternatives:
Copy to a temporary vector and sort that as desired.  Unless the vector is very large and you've got limited space, this is almost certainly the best way.  Even if you're concerned about performance, the cost of making a copy is going to be smaller than the cost of sorting, and if the cost of copying is significant the sorting's going to be a lot slower than the copying.
Alternatively, you could keep some way (the timestamp you mentioned?) of being able to sort the vector back to the original order.  This is going to be slow, since you'd only want to do this if the vector was very large, but if you can't make a temporary vector this is the only way to do it.
",2,2312737
2312778,"
Whatever item you are sorting, you could wrap it in a structure that has multiple sort-fields.
(or maybe add the sort orders to the base structure itself?)
Then when you need can calculate the different sort orders, and re-order your list depending on which sort-order you need.
",0,2312737
2313026,"
I suggest storing smart pointers, to the original data, in each vector.  std::vector allows you to supply different methods for sorting.  Also, with smart pointers, they will be destroyed automatically when all references to the item are removed.
",0,2312737
2283042,"
Are you using QItemSelectionModel to do this, or did you write it yourself?

If you wrote it yourself I would suggest using QItemSelectionModel.
If you didn't, it sounds like you want a custom sorting algorithm which would require creating a derived QTreeWidget, if you are doing that, you might as well just use QTreeView and a custom QAbstractItemModel.

Also, if you have two views of the same data, I would HIGHLY recommended using the Model/View framework and a QTreeView.
",1,2282450
2278807,"
You can use a temporary local function pointer variable of the required type to select the correct overload of DataSpecificComparison:
Here the compiler can deduce that you want to use the DataSpecificComparison overload that matches the comparer_t type, which resolves the ambiguity.
",6,2278635
2279407,"
sth already gave a correct answer, but there's also a direct alternative based on the same principle:
This uses essentially the same mechanism. The cast forces overload resolution to happen before the Template Argument Deduction for std::sort.
",3,2278635
2278845,"
call the sort function as shown below:
",1,2278635
2280286,"
I'd prefer something along the following lines: by default it compares objects with less_than (so you wouldn't have to remember to provide a function with a funny name), and there's an overload that allows giving your own comparison functor (again, value-based):
",1,2278635
2278691,"
Did you try defining DataSpecificComparison as template with bunch of specializations and giving it the type?
",0,2278635
2278754,"
Templating DataSpecificComparison should work. You can also specifically call the proper std::sort template, but it's a bit cumbersome:
",0,2278635
2202906,"
Generic adaptor to compare based on member attributes. While it is quite more verbose the first time it is reusable.
",20,2202731
2202846,"
You don't need to create a class - just write a function:
",12,2202731
2203174,"
This isn't really so much an answer in itself, as a reply to AraK's reply to my comment that sorting with a function instead of a functor can be slower. Here's some (admittedly ugly -- far too much CnP) test code that compares various sorting: qsort, std::sort of vector vs. array, and std::sort using a template class, template function, or plain function for comparison:
Compiling this with VC++ 9/VS 2008 using cl /O2b2 /GL sortbench3.cpp, I get:
I believe these fall fairly cleanly into three groups: using sort with the default comparison, and using the template class produced the fastest code. Using either the function or template function is clearly slower. Using qsort is (surprisingly to some) the slowest of all, by around a 2:1 margin.
The difference between cmp2 and cmp3 appears to stem entirely from passing by reference vs. value -- if you change cmp2 to take its arguments by value, its speed matches cmp3 exactly (at least in my testing). The difference is that if you know the type is going to be int, you'll almost certainly pass by value, whereas for generic T, you'll usually pass by const reference (just in case it's something that's more expensive to copy).
",5,2202731
2202760,"
If there's only one thing you're ever going to want to sort people by (or if there's a reasonable default that you're going to want to use most of the time), override operator< for the People class to sort by this attribute. Without an explicit comparator, STL sorting functions (and anything that makes implicit use of ordering, like sets and maps) will use operator<.
When you want to sort by something other than operator<, the way you describe is the only way to do it as of the current version of C++ (although the comparator can just be a regular function; it doesn't have to be a functor). The C++0x standard will make this less verbose by allowing lambda functions.
If you're not willing to wait for C++0x, an alternative is to use boost::lambda.
",3,2202731
2202994,"
I see that dribeas already posted that idea, but since I already wrote it, here's how you'd write a generic comparator to use getter functions.
Usage:
I think it might be a good idea to overload operator() for non-pointers, but then one couldn't typedef the argument_types by inheriting from binary_function - which is probably not a great loss, since it would hard to use it where those are needed anyway, for example, one just couldn't negate the comparison functor anyway.
",1,2202731
19165189,"
These answers are all really verbose although I love the template idea! Just use lambda functions, it makes things a lot more simple!
You could just use this: 
",1,2202731
2203665,"
I just tried this based on UncleBens and david-rodriguez-dribeas ideas.
This seems to work (as is) with my current compiler. g++ 3.2.3. Please let me know if it works on other compilers.
",0,2202731
2202780,"
You can have just a global function, or a static function. Each of these global or static functions compare against an attribute. No need to make a class. One way to hold papeters for comparison is to use boost bind, but bind is only useful for finding all classes or comparing all classes against some bound parameter. Storing data across multiple elements is the only reason to make a functor.
Edit: also see boost lambda functions, but they are only practical for simple functions.
",0,2202731
2155708,"
",21,2155675
2155915,"
You're almost there, make type a template parameter and the signature is OK:
The optimizer will spot that ( type == VARA_ID ) is a compile-time constant.
",6,2155675
2155957,"
Using Boost.Lambda and without any special sorting function, right in your code where you need sorting:
Briefly
Full example
",3,2155675
2155701,"
Does the value of type change with each comparison? It cannot, as it appears. In that case, use a curried function -- see boost::bind.
",2,2155675
2155907,"
A more generic solution might also be to make use of pointers-to-members:
",2,2155675
10508265,"
Vladimir Yaroslavskiy | 11 Sep 12:35 
Replacement of Quicksort in java.util.Arrays with new Dual-Pivot Quicksort
Visit http://permalink.gmane.org/gmane.comp.java.openjdk.core-libs.devel/2628
",7,2105737
10729915,"
To answer your question, no I have not seen this approach before. I'm not going to profile your code and do the other hard work, but perhaps the following are next steps/considerations in formally presenting your algorithm. In the real world, sorting algorithms are implemented to have:
Good scalability / complexity and Low overhead
Scaling and overhead are obvious and are easy to measure. When profiling sorting, in addition to time measure number of comparisons and swaps. Performance on large files will also be dependent on disk seek time. For example, merge sort works well on large files with a magnetic disk. ( see also Quick Sort Vs Merge Sort )
Wide range of inputs with good performance
There's lots of data that needs sorting. And applications are known to produce data in patterns, so it is important to make the sort is resilient against poor performance under certain patterns. Your algorithm optimizes for repeated numbers. What if all numbers are repeated but only once (i.e. seq 1000>file; seq 1000>>file; shuf file)? What if numbers are already sorted? sorted backwards? what about a pattern of 1,2,3,1,2,3,1,2,3,1,2,3? 1,2,3,4,5,6,7,6,5,4,3,2,1? 7,6,5,4,3,2,1,2,3,4,5,6,7? Poor performance in one of these common scenarios is a deal breaker! Before comparing against a published general-purpose algorithm it is wise to have this analysis prepared.
Low-risk of pathological performance
Of all the permutations of inputs, there is one that performs worse than the others. How much worse does that perform than average? And how many permutations will provide similar poor performance?
Good luck on your next steps!
",5,2105737
2105778,"
It's a great improvment and I'm sure it's been implemented specifically if you expect a lot of equal objects. There are many of the wall tweeks of this kind. 
If I understand all you wrote correctly, the reason it's not generally ""known"" is that it does improve the basic O(n2) performance. That means, double the number of objects, quadruple the time. Your improvement doesn't change this unless all objects are equal.
",0,2105737
2106303,"
std:sort is not exactly fast. 
Here are results I get comparing it to randomized parallel nonrecursive quicksort:
pnrqSort (longs):
.:.1 000 000           36ms (items per ms: 27777.8)
.:.5 000 000           140ms (items per ms: 35714.3)
.:.10 000 000          296ms (items per ms: 33783.8)
.:.50 000 000          1s 484ms (items per ms: 33692.7)
.:.100 000 000         2s 936ms (items per ms: 34059.9)
.:.250 000 000         8s 300ms (items per ms: 30120.5)
.:.400 000 000         12s 611ms (items per ms: 31718.3)
.:.500 000 000         16s 428ms (items per ms: 30435.8)
std::sort(longs)
.:.1 000 000           134ms (items per ms: 7462.69)
.:.5 000 000           716ms (items per ms: 6983.24)
std::sort vector of longs
1 000 000           511ms (items per ms: 1956.95)
2 500 000           943ms (items per ms: 2651.11)
Since you have extra method it is going to cause more stack use which will ultimately slow things down. Why median of 3 is used, I don't know, because it's a poor method, but with random pivot points quicksort never has big issues with uniform or presorted data and there's no danger of intentional median of 3 killer data.
",-1,2105737
23690497,"
nobody seems to like your algorithm, but I do.
Seems to me it's a nice way to re-do classic quicksort in a manner now
safe for use with highly repeated elements.
Your q1 and q2 subalgorithms, it seems to me are actually the SAME algorithm
except that < and <= operators interchanged and a few other things, which if you
wanted would allow you to write shorter pseudocode for this (though might be less
efficient).  Recommend you read
 JL Bentley, MD McIlroy: Engineering a Sort Function
 SOFTWARE—PRACTICE AND EXPERIENCE 23,11 (Nov 1993)1249-1265
e-available here
 http://www.skidmore.edu/~meckmann/2009Spring/cs206/papers/spe862jb.pdf
to see the tests they put their quicksort through.  Your idea might be nicer and/or better,
but it needs to run the gauntlet of the kinds of tests they tried, using some
particular pivot-choosing method. Find one that passes all their tests without ever suffering quadratic runtime.  Then if in addition your algorithm is both faster and nicer than theirs, you would then clearly have a worthwhile contribution.
The ""Tukey Ninther"" thing they use to generate a pivot seems to me is usable by you too
and will automatically make it very hard for the quadratic time worst case to arise in practice.
I mean, if you just use median-of-3 and try the middle and two end elements of the array as
your three, then an adversary will make the initial array state be increasing then decreasing and then you'll fall on your face with quadratic runtime on a not-too-implausible input.  But with Tukey Ninther on 9 elements, it's pretty hard for me to construct
a plausible input which hurts you with quadratic runtime.
Another view & a suggestion:
Think of the combination of q1 splitting your array, then q2 splitting the right subarray,
as a single q12 algorithm producing a 3-way split of the array.  Now, you need to recurse
on the 3 subarrays (or only 2 if the two pivots happen to be equal).  Now always
recurse on the SMALLEST of the subarrays you were going to recurse on, FIRST, and
the largest LAST -- and do not implement this largest one as a recursion, but rather just stay in the same routine and loop back up to the top with a shrunk window.  That way
you have 1 fewer recursive call in q12 than you would have, but the main point of this is,
it is now IMPOSSIBLE for the recursion stack to ever get more than O(logN) long.
OK?  This solves another annoying worst-case problem quicksort can suffer while also making
your code a bit faster anyhow.
",-1,2105737
2099518,"
If you have confidence in your work, definitely try to discuss it with someone knowledgeable at your university as soon as possible.  It's not enough to show that your code runs faster than another procedure on your machine.  You have to mathematically prove whatever performance gain you claim to have achieved through analysis of your algorithm.  I'd say the first thing to do is make sure both algorithms you are comparing are implemented and compiled optimally - you may just be fooling yourself here.  The likelihood of an individual achieving such a marked improvement upon such an important sorting method without already having thorough knowledge of its accepted variants just seems minuscule.  However, don't let me discourage you.  It should be interesting anyway.  Would you be willing to post the code here?
...Also, since quicksort is especially vulnerable to worst-case scenarios, the tests you choose to run may have a huge effect, as will the choice of pivots.  In general, I would say that any data set with a large number of equivalent elements or one that is already highly sorted is never a good choice for quicksort - and there are already well-known ways of combating that situation, and better alternative sorting methods.
",11,2099436
2099553,"
If you have truly made a breakthrough and have the math to prove it, you should try to get it published in the Journal of the ACM.  It's definitely one of the more prestigious journals for computer science.
The second best would be one of the IEEE journals such as  Transactions on Software Engineering.
",7,2099436
2033495,"
There are already similar questions, I know of Sort on a string that may contain a number and How to implement a natural sort algorithm in C. So you can also look there for more inspiration and help.
Both questions' answers suggest, http://www.davekoelle.com/alphanum.html, which is basically what Pascal Cuoq suggested.
You can also look at the Coding Horror article, where some other algorithms are linked: Sorting for Humans : Natural Sort Order
",5,2033473
2033488,"
One solution is to treat numbers (consecutive sequences of digits) as single letters from the point of view of the lexicographical order.
Then ""filenamea (3).txt"", ""filenamea (20).txt"" and ""filenamea (100).txt"" all have the same length, and end up being sorted in this order, which I understand is what you want (?)
",1,2033473
2017136,"
Basically, you need to parse the XML file into a set of records, sort the records on the appropriate field, then write the result back out as a new XML file. There are zillions of XML parsers out there that are intended to make it easy for you to parse the data. Personally, I've always written my own code to handle it. It's almost as fast to write, and executes quite a bit faster -- but that's me, and the XML I've parsed this was has mostly been fairly simple. If you lack experience at writing parsers and/or don't care as much about execution speed, chances are that using an existing parser will be a better choice.
",1,2016676
2016682,"
What do you mean by sorting an xml file?
I think this needs a bit more thought.
Either sort the values after you read them from the file in your app or to work on the XML file directly 
You may wish to look into xslt.
",0,2016676
1902321,"
doCompare must be static. If doCompare needs data from MyClass you could turn MyClass into a comparision functor by changing:
into
and calling:
Also, isn't doSort missing a return value?
I think it should be possible to use std::mem_fun and some sort of binding to turn the member function into a free function, but the exact syntax evades me at the moment.
EDIT: Doh, std::sort takes the functor by value which may be a problem. To get around this wrap the functor inside the class:
",28,1902311
1902360,"
As Andreas Brinck says, doCompare must be static (+1). If you HAVE TO have a state in your comparator function (using the other members of the class) then you'd better use a functor instead of a function (and that will be faster):
Using a functor is always better, just longer to type (that can be unconvenient but oh well...)
I think you can also use std::bind with the member function but I'm not sure how and that wouldn't be easy to read anyway.
UPDATE 2014: Today we have access to c++11 compilers so you could use a lambda instead, the code would be shorter but have the exact same semantic.
",13,1902311
24574712,"
The solution proposed by Rob is now valid C++11 (no need for Boost):
Indeed, as mentioned by Klaim, lambdas are an option, a bit more verbose (you have to ""repeat"" that the arguments are ints):
C++14 supports auto here:
but still, you declared that arguments are passed by copy.
Then the question is ""which one is the most efficient"".  That question was treated by Travis Gockel: Lambda vs Bind.  His benchmark program gives on my computer (OS X i7)
where lambda is a lambda used directly, and lambda bound is a lambda stored in a std::function.
So it appears that lambdas are a better option, which is not too much of a surprise since the compiler is provided with higher level information from which it can make profit.
",7,1902311
7930752,"
You can use boost::bind:
",4,1902311
1902447,"
There is a way to do what you want, but you need to use a small adaptor. As the STL doesn't write it for you, can can write it yourself:
Then, you can use it:
",2,1902311
42073143,"
A very simple way to effectively use a member function is to use operator<. That is, if you have a function called compare, you can call it from operator<. Here is a working example:
Then you don't even need to give the function name to std::sort:
",0,1902311
46654749,"
Updating Graham Asher answer, as you don't need the compare but can use the less operator directly.
",0,1902311
1840131,"
Most implementations of std::sort use quicksort, (or usually a hybrid algorithm like introsort, which combines quicksort, heapsort and insertion sort).
The only thing the standard requires is that std::sort somehow sort the data according to the specified ordering with a complexity of approximately O(N log(N)); it is not guaranteed to be stable.  Technically, introsort better meets the complexity requirement than quicksort, because quicksort has quadratic worst-case time.
",28,1840121
1840182,"
C++ Standard ISO/IEC 14882:2003

25.3.1.1 sort
1 Effects: Sorts the elements in the
  range [first, last). 
2 Complexity:
  Approximately N log N (where N == last
  - first) comparisons on the average. 

There is no information about method but complexity is always N log N.
",10,1840121
33141984,"
There are three algorithms that are used in MSVC2013 STL, referring to the source code of std::sort.

It is most likely to use QuickSort, or a variation over QuickSort called IntroSort.
If the recursion goes too deep, the HeapSort will be used here.
Otherwise InsertSort will be used.

",7,1840121
45998880,"
Probably all implementations of std::sort use introsort (aka introspection sort), a hybrid algorithm that combines quicksort and heapsort. Actually, introsort was particularly invented in 1997 for the purpose of a performant sort implemenation in C++ STL.
The only thing the standard requires is that std::sort somehow sort the data according to the specified ordering with a complexity of O(N log(N)); it is not guaranteed to be stable (there is a separate std::stable_sort algorithms available, if this should be required).
Technically, introsort better meets the complexity requirement than quicksort: This is because heapsort has guaranteed O(N log(N)) complexity in the worst case, whereas quicksort has quadratic worst-case time.
However, heapsort is 'slower' than quicksort in the average case, in the sense that heapsort performs C*N log(N) whereas quicksort has D*N log(n) performance, with D being significantly smaller than C (the numbers C and D are constants). In other words, the per-comparison-overhead of heapsort is higher than the one of quicksort.
To get the best of both worlds, introsort starts with quicksort —a recursive algorithm—, but when recursion depth gets too high (which means it gets into a degenerated worst-case behaviour), it switches to heapsort.
See also the Wikipedia entry for introsort or the original paper from David Musser, who invented introsort particularly for STL.
",4,1840121
1840142,"
Do you mean std::sort?  If so it can be implemented any way they want.  Its probably Quick sort but could be radix or something else.  As long as it produces you a sorted list in at least O(n log n) the implementation is fine, afaik.
",0,1840121
32230449,"
Just some empirical results:
I translated a python script using numpy 1.9.2 sort to C++ using std::sort (VS2008 toolchain).
I only get the same exact results in the python and C++ sides when I use numpy.sort argument kind='mergesort'. I get different relative ordering for elements with same key when kind='quicksort' or kind='heapsort'. So I guess that at least for the version of STL that comes with VS2008 std::sort uses mergesort.
",0,1840121
1787318,"
The STL has std::reverse_iterator<Iterator>:
An important note:

Notice however that when an iterator
  is reversed, the reversed version does
  not point to the same element in the
  range, but to the one preceding it.
  This is so, in order to arrange for
  the past-the-end element of a range:
  An iterator pointing to a past-the-end
  element in a range, when reversed, is
  changed to point to the last element
  (not past it) of the range (this would
  be the first element of the range if
  reversed). And if an iterator to the
  first element in a range is reversed,
  the reversed iterator points to the
  element before the first element (this
  would be the past-the-end element of
  the range if reversed).

",28,1787293
1787310,"
Check out the base() method of reverse_iterator.
",-5,1787293
1733442,"
Here. (Courtesy of Google)
",2,1733420
1733445,"
Here's a description of how to implement it.
",2,1733420
1731512,"
Use a functor instead of a function:
This way the method op_comp can stay non-static. However the caller needs an instance of the parser, where are all the operators are stored. This is the usage of our new functor:
Where my_parser is the instance of parser you are using. Alternatively, if you are calling std::sort from the parser, you can simply write:
",3,1731404
1731423,"
Make operators static as well, and you'll be able to use it in op_comp.
Alternatively, use a functor instead of a function:
See more examples at cplusplus.com
",5,1731404
1731582,"
If you want op_comp to be non-static you can use Boost.Lambda or Boost.Bind:
",3,1731404
1727246,"
unless it is homework you can try:
",5,1727237
1727254,"
First things first:
will give you an 14-element array sparky[0..13], not 15 elements as you seem to think.
Secondly, your inner loop isn't quite right. Yours start at index 1 and go through to index 15 whereas, because C array are zero-based, you should be cycling from 0 through to 14.
You can fix that by changing the loop condition to while (counter < howmany) and moving the counter++ to just before the end of the inner loop.

Just to clarify that point, you do actually start the loop at 0 but, because the first thing you do in the loop is counter++ before using sparky[counter], you're processing the elements starting at index 1. And, in the last run of the loop, where counter == howmany (14 as per your other comments here), you increment it to 15 and use that, which is beyond the end of the array.
And, just to clarify that clarification :-), your loop is correct if you have howmany set to 14 (i.e., one less than the number of array elements) since, as you point out in a comment elsewhere, you load up element zero before entering the inner loop. I think you do still need to set high whenever you set holder though. If that's not done, I get two 6's and two 2's in my list and no 3 or 4.
As a side issue to your comment that howmany is set to 14, I would suggest that variable names should echo their intent. You clearly have 15 elements in the array (indexes 0 through 14 inclusive). Don't take that as criticism, I'm just trying to help out.

Thirdly, (and finally, I think), you're not setting high every time you're setting holder - these should be kept in sync for your algorithm to work correctly.
Please let us know whether this is homework. If not, I'll post my solution. If so, you should work it out from the guidelines given in this, and other, answers. You should be aware that, if it is homework and you use a solution posted on a public forum on the internet (such as this one), you will almost certainly be failed for plagiarism. Do not make the mistake of thinking your educators don't check that sort of stuff.
Bottom line, while I'm happy to post my solution, you probably shouldn't use it as classwork. Top marks though for at least giving it a shot first. Most homework seeker seem to come here with nothing more than the specs :-)
Update: Since you posted the following:

Sorry to mention but this is part of an extra credit project for a class.

I guess it's classwork. So, no soup for you :-) Still, the three points above should be enough for you to fix it. If you have specific questions about them, feel free to ask in a comment attached to this answer.
Good luck.
",5,1727237
1727256,"
yes it does... 
look at where you are using holder = sparky[counter]; and sparky[high] = sparky[counter-1]
if you read your code you will see that when the value is set for the last value, counter-1 and sparky[high] are the same thing. this will happen on all values, but you only notice it on the last one
try adding some Debug code in there to say 'i am moving this value to this place' to show you what you are actually doing... it might help :)
",0,1727237
1727342,"
Try this:
basically i just fixed up your inner loop and swap. but dont use it if you dont understand it. the mistakes you made were pretty trivial, so i feel comfortable with posting code for you to use... The basic idea is, if you are using this sort of sort (no pun intended) be very carefull where your indexes end up. When dealing with two counters, make sure you keep track of them and give them meaningfull variable names. counter and counter2 are not so good. Try something like outerCounter and innerCounter. Also, high has been changed to FoundIndex. 
remember, trace code (code that just outputs the value of a varaible) is extremely valuable in figuring out this sort of problem... just putting in 'cout << counter << endl; showed it was going over the end of the array...
",0,1727237
1723131,"
Instead of creating two separate vectors/lists, the usual way to handle this is to create a single vector/list of objects that include both names and ages:
To get a sort based on age, pass a comparator that looks at the ages:
In older C++ (pre C++11, so no lambda expressions) you can define the comparison as a member overload of operator< or else as a function-object (an object that overloads operator()) to do the comparison:
Then your sort would look something like:
As for choosing between defining operator< for the class, or using a separate comparator object as I show above, it's mostly a question of whether there's a single ordering that's ""obvious"" for this class.
In my opinion, it's not necessarily obvious that sorting people would always happen by age. If, however, in the context of your program it would be obvious that sorting people would be done by age unless you explicitly specified otherwise, then it would make sense to implement the comparison 
as person::operator< instead of in a separate comparison class the way I've done it above.
",24,1723066
1723489,"
As others have noted, you should consider grouping People and Ages. 
If you can't/don't want to, you could create an ""index"" to them, and sort that index instead. For example:
Now, the name of the nth person is people[pos[n]] and its age is ages[pos[n]]
",8,1723066
1723139,"
Generally you wouldn't put data that you want to keep together in different containers. Make a struct/class for Person and overload operator<.
Or if this is some throw-away thing:
std::pair already implement comparison operators.
",3,1723066
1723233,"
It doesn't make sense to keep them in two separate data structures: if you reorder People, you no longer have a sensible mapping to Ages.
",2,1723066
1723121,"
I would suggest merging these two lists into a single list of structures. That way you can simply define operator < like dirkgently said.
",0,1723066
8748435,"
Jerry Coffin answer was fully clear and correct.  
A just have a related issue that may grant a good discussion to the topic... :)
I had to reorder the columns of a matrix object (lets say TMatrix< T >) based on the sorting of a vector (lets say sequence)... The TMatrix< T > class do not provide reference access to it's rows (thus I can not create a structure to reorder it...) but conveniently provides a method TMatrix< T >::swap(row1, row2)...
So that's the code:
I belive that's still O(n log n) since every row that is not in place will swap just one time...
Have fun! :)
",0,1723066
1717830,"
The standard doesn't require a particular algorithm, only that it must be stable, and that it complete the sort using approximately N lg N comparisons. That allows, for example, a merge-sort or a linked-list version of a quick sort (contrary to popular belief, quick sort isn't necessarily unstable, even though the most common implementation for arrays is).
With that proviso, the short answer is that in most current standard libraries, std::sort is implemented as a intro-sort (introspective sort), which is basically a Quicksort that keeps track of its recursion depth, and will switch to a Heapsort (usually slower but guaranteed O(n log n) complexity) if the Quicksort is using too deep of recursion. Introsort was invented relatively recently though (late 1990's). Older standard libraries typically used a Quicksort instead.
stable_sort exists because for sorting array-like containers, most of the fastest sorting algorithms are unstable, so the standard includes both std::sort (fast but not necessarily stable) and std::stable_sort (stable but often somewhat slower).
Both of those, however, normally expect random-access iterators, and will work poorly (if at all) with something like a linked list. To get decent performance for linked lists, the standard includes list::sort. For a linked list, however, there's not really any such trade-off -- it's pretty easy to implement a merge-sort that's both stable and (about) as fast as anything else. As such, they just required one sort member function that's required to be stable.
",43,1717773
1717834,"
It's completely implementation defined. The only thing the standard says about it is that it's complexity is O(n lg n), and that the sort is stable. That is, relative order of equal elements is guaranteed to not change after sorting.
std::list's sort member function is usually implemented using some form of merge sort, because merge sort is stable, and merges are really really cheap when you are working with linked lists.
Hope that helps :)
",13,1717773
1739852,"
Though is it implementation/vendor dependent, but most implementation I know uses Introsort whose best & worst case complexity is O(nlogn).
Reference:http://en.wikipedia.org/wiki/Introsort
",-2,1717773
1717742,"
You have to be carefull that your sorting criteria is transitive: if x ' y then y !< x.
If it is not transitive, the sort operation result depends on the ordering of the array before the call, which you probably don't want. 
",5,1717650
1717676,"
I would write it like so:
This will allow you to sort the records prioritizing by name, age and score in that order. Changing the priorities around should be a simple exercise.
",7,1717650
1718690,"
Much easier to maintain than the others, and cleaner too!
",0,1717650
19376314,"
Explanation : 
   when you make a vector and apply a sort function pass this function as parameter.
ex. vector<strudent_t> st;  
and then for sorting sort(st.begin(),st.end(), by_more_than_1_field) 
What this will do is the function accepts two const arguments of class student_t. It accepts const so the object student_t is not modifiable. It then compares as given in function. 
",-1,1717650
1679708,"
Boost::MultiIndex comes to mind.
",8,1679669
1679743,"
What you want can be achieved using the library Boost.Multi-index 
Check in particular this example  in the tutorial, which is very close to your use case.
",1,1679669
1679720,"
Could it be a kd-tree (k-dimensional tree)? In your case, k would be 2.
",0,1679669
1677302,"
You can't do that from sort.
Remove the elements before or after sort.
Though you really don't need boost::bind at all.  Heck, we can make it a bit more generic too:
",4,1677211
1677390,"
There many ways to do it. The easiest is to first remove all unwanted elements and then sort:
Note that when using boost bind you need to include the placeholder (_1), that tells it which argument is the one being iterated over.
If you prefer to to it in one step, you could conditionally copy all your ints to a multiset, which sort the items for you:
",2,1677211
1677368,"
Your idea is not quite possible as std::sort can only affect the ordering of your vector and cannot modify the values themself.
The closet thing I can think of that would approximate what you want is to have all the valid values (those that are >= 5 and <= 45) come before invalid values but have both the valid and invalid value sorted.
",0,1677211
1663183,"
In function merge(), you're incorrectly calculating the index variable:
Assuming begin = 10, mid = 14, end = 19 (for a total array size of 0 .. 19, and you're recMergeSort()ing the higher half), your index = 10, but the tempList array is indexed 0..9 (because arraySize = last - first + 1 == 10). 
So you're overflowing your tempList array, and when you ""merge"", you get data corruption.
Fix your index variable to be 0-based (rather than beginPart1 based).
",2,1663119
1663187,"
I think problem is here:
It should be 
",1,1663119
1663184,"
If I run this in C# I get an IndexOutOfRangeException on the following line:
I reckon if you trace it through you are probably running off the end of a buffer somewhere hence the random numbers.
",0,1663119
1649979,"
How about having a reordering vector? You initialize vector with 1..N/L, pass std::sort a comparator that compares elements i1*L..i1*L+L to i2*L..i2*L+L, and when your vector is properly sorted, reorder the C array according to new order.
In response to comment: yes things get complicated, but it may just be good complication! Take a look here.
",2,1649529
1649650,"
You can use a ""stride iterator"" for this. A ""stride iterator"" wraps another iterator and an integer step size. Here's a simple sketch:
Also, helper functions like these
should make it fairly easy to use stride iterators:
Implementing the iterator adapter all by yourself (with all operators) is probably not a good idea. As Matthieu pointed out, you can safe yourself a lot of typing if you make use of Boost's iterator adapter tools, for example.
Edit:
I just realized that this doesn't do what you wanted since std::sort will only exchange the first element of each block. I don't think there's an easy and portable solution for this. The problem I see is that swapping ""elements"" (your blocks) cannot be (easily) customized when using std::sort. You could possibly write your iterator to return a special reference type with a special swap function but I'm not sure whether the C++ standard guarantees that std::sort will use a swap function that is looked up via ADL. Your implementation may restrict it to std::swap.
I guess the best answer is still: ""Just use qsort"".
",2,1649529
1649971,"
I don't remember exactly how to do this, but if you can fake anonymous functions, then you can make a comp(L) function that returns the version of comp for arrays of length L... that way L becomes a parameter, not a global, and you can use qsort. As others mentioned, except in the case where your array is already sorted, or backwards or something, qsort is going to be pretty much just as fast as any other algorithm. (there's a reason it's called quicksort after all...)
",1,1649529
1654737,"
It's not part of any ANSI, ISO, or POSIX standard, but some systems provide the qsort_r() function, which allows you to pass an extra context parameter to the comparison function.  You can then do something like this:
Alternatively, if you don't have qsort_r, you can use the callback(3) package from the ffcall library to create closures at runtime.  Example:
Note that the callback library is threadsafe, since all parameters are passed on the stack or in registers.  The library takes care of allocating memory, making sure that memory is executable, and flushing the instruction cache if necessary to allow dynamically generated code (that is, the closure) to be executed at runtime.  It supposedly works on a large variety of systems, but it's also quite possible that it won't work on yours, either due to bugs or lack of implementation.
Also note that this adds a little bit of overhead to the function call.  Each call to comp_base() above has to unpack its arguments from the list passed it (which is in a highly platform-dependent format) and stuff its return value back in.  Most of the time, this overhead is miniscule, but for a comparison function where the actual work performed is very small and which will get called many, many times during a call to qsort(), the overhead is very significant.
",1,1649529
27608786,"
For the new question, we need to pass in sort() a kind of iterator that will not only let us compare the right things (i.e. will make sure to take 4 steps through our double[] each time instead of 1) but also swap the right things (i.e. swap 4 doubles instead of one).
We can accomplish both by simply reinterpreting our double array as if it were an array of 4 doubles. Doing this:
doesn't work, since you can't assign an array, and swap will need to. But doing this:
or, if not C++11:
satisfies both requirements. Thus:
If you're concerned about alignment, can always just assert that there's no extra padding:
",1,1649529
1649545,"
",0,1649529
1649692,"
I'm not sure if you can achieve the same result without a lot more work.  std::sort() is made to sort sequences of elements defined by two random access iterators.  Unfortunately, it determines the type of the element from the iterator.  For example:
will sort all of the elements of array.  The problem is that it assumes that the subscripting, increment, decrement, and other indexing operators of the iterator step over elements of the sequence.  I believe that the only way that you can sort slices of the array (I think that this is what you are after), is to write an iterator that indexes based on L.  This is what sellibitze has done in the stride_iterator answer.
",0,1649529
1649621,"
Do test with std::stable_sort() on realistic data-sets - for some data mixes its substantially faster!
On many compilers (GCC iirc) there's a nasty bite: the std::sort() template asserts that the comparator is correct by testing it TWICE, once reversed, to ensure the result is reversed!  This will absolutely completely kill performance for moderate datasets in normal builds.  The solution is something like this:
Adapted from this excellent blog entry: http://www.tilander.org/aurora/2007/12/comparing-stdsort-and-qsort.html
",0,1649529
1655523,"
Arkadiy has the right idea. You can sort in place if you create an array of pointers and sort that:
Output:
",0,1649529
1659412,"
A lot of these answers seem like overkill. If you really have to do it C++ style, using jmucchiello's example:
and then sort with:
It doesn't have to be any more complicated.
",0,1649529
1603039,"

take the first 100 scores, and sort them in an array.
take the next score, and insertion-sort it into the array (starting at the ""small"" end)
drop the 101st value
continue with the next value, at 2, until done

Over time, the list will resemble the 100 largest value more and more, so more often, you find that the insertion sort immediately aborts, finding that the new value is smaller than the smallest value of the candidates for the top 100.
",25,1602998
1603155,"
You can do this in O(n) time, without any sorting, using a heap:
Times on my machine (Core2 Q6600, Linux, Python 2.6, measured with bash time builtin):

100000 elements: .29 seconds
1000000 elements: 2.8 seconds
10000000 elements: 25.2 seconds

Edit/addition: In C++, you can use std::priority_queue in much the same way as Python's heapq module is used here. You'll want to use the std::greater ordering instead of the default std::less, so that the top() member function returns the smallest element instead of the largest one. C++'s priority queue doesn't have the equivalent of heapreplace, which replaces the top element with a new one, so instead you'll want to pop the top (smallest) element and then push the newly seen value. Other than that the algorithm translates quite cleanly from Python to C++.
",7,1602998
1664548,"
Here's the 'natural' C++ way to do this:
This is linear in the number of scores.
The algorithm used by std::sort isn't specified by the standard, but libstdc++ (used by g++) uses an ""adaptive introsort"", which is essentially a median-of-3 quicksort down to a certain level, followed by an insertion sort.
",5,1602998
1603061,"
Declare an array where you can put the 100 best scores. Loop through the huge list and check for each item if it qualifies to be inserted in the top 100. Use a simple insert sort to add an item to the top list.
Something like this (C# code, but you get the idea):
I tested it on my computer (Code 2 Duo 2.54 MHz Win 7 x64) and I can process 100.000.000 items in 369 ms.
",4,1602998
1664594,"
Since speed is of the essence here, and 40.000 possible highscore values is totally maintainable by any of today's computers, I'd resort to bucket sort for simplicity. My guess is that it would outperform any of the algorithms proposed thus far. The downside is that you'd have to determine some upper limit for the highscore values. 
So, let's assume your max highscore value is 40.000:
Make an array of 40.000 entries. Loop through your highscore values. Each time you encounter highscore x, increase your array[x] by one. After this, all you have to do is count the top entries in your array until you have reached 100 counted highscores.
",3,1602998
1603198,"
You can do it in Haskell like this:
This looks like it sorts all the numbers into descending order (the ""flip compare"" bit reverses the arguments to the standard comparison function) and then returns the first 100 entries from the list.  But Haskell is lazily evaluated, so the sortBy function does just enough sorting to find the first 100 numbers in the list, and then stops.
Purists will note that you could also write the function as
This means just the same thing, but illustrates the Haskell style of composing a new function out of the building blocks of other functions rather than handing variables around the place.
",1,1602998
1603020,"
You want the absolute largest X numbers, so I'm guessing you don't want some sort of heuristic. How unsorted is the list? If it's pretty random, your best bet really is just to do a quick sort on the whole list and grab the top X results.
If you can filter scores during the list generation, that's way way better. Only ever store X values, and every time you get a new value, compare it to those X values. If it's less than all of them, throw it out. If it's bigger than one of them, throw out the new smallest value. 
If X is small enough you can even keep your list of X values sorted so that you are comparing your new number to a sorted list of values, you can make an O(1) check to see if the new value is smaller than all of the rest and thus throw it out. Otherwise, a quick binary search can find where the new value goes in the list and then you can throw away the first value of the array (assuming the first element is the smallest element).
",0,1602998
1603043,"
Place the data into a balanced Tree structure (probably Red-Black tree) that does the sorting in place.  Insertions should be O(lg n).  Grabbing the highest x scores should be O(lg n) as well.
You can prune the tree every once in awhile if you find you need optimizations at some point.
",0,1602998
1603050,"
If you only need to report the value of top 100 scores (and not any associated data), and if you know that the scores will all be in a finite range such as [0,100], then an easy way to do it is with ""counting sort""...
Basically, create an array representing all possible values (e.g. an array of size 101 if scores can range from 0 to 100 inclusive), and initialize all the elements of the array with a value of 0. Then, iterate through the list of scores, incrementing the corresponding entry in the list of achieved scores. That is, compile the number of times each score in the range has been achieved. Then, working from the end of the array to the beginning of the array, you can pick out the top X score. Here is some pseudo-code:

    let type Score be an integer ranging from 0 to 100, inclusive.
    let scores be an array of Score objects
    let scorerange be an array of integers of size 101.

    for i in [0,100]
        set scorerange[i] = 0

    for each score in scores
        set scorerange[score] = scorerange[score] + 1

    let top be the number of top scores to report
    let idx be an integer initialized to the end of scorerange (i.e. 100)

    while (top > 0) and (idx>=0):
        if scorerange[idx] > 0:
              report ""There are "" scorerange[idx] "" scores with value "" idx
              top =  top - scorerange[idx]
        idx = idx - 1;

",0,1602998
1603349,"
I answered this question in response to an interview question in 2008. I implemented a templatized priority queue in C#.
",0,1602998
1664856,"
Median of medians algorithm. 
",0,1602998
1602922,"
Use atof() instead of atol() to have the comparison take the fractional part of the number into account.  You will also need to change the return types to doubles.
",2,1602732
1602748,"
If it's just float strings, I'd rather suggest to create a table with two columns (first row contains the original string, second row is filled with the string converted to float), sort this by the float column and then output/use the sorted string column.
",1,1602732
1602791,"
If the data are all numbers I would create a new class to contain the data.
It can have a string to include the data but then allows you to have better methods to model behaviour - in this case espacially to implement operator <
The implementation could also include use of  a library that calculates to exact precion e.g. GNU multiple precision this would do the comparison and canversion from string (or if the numbers do not have that many significant figures you could use doubles)
",0,1602732
1602974,"
I would compute the values once and store them.
Because they are not actually part of the objects state (they are just calcualted values) mark them as mutable. Then they can also be set during const methods.
Also note that MyClass is a friend of itself and thus can access the private members of another object of the same class. So there is no need for the extranious accessor methods. Remember Accessor methods are to protect other classes from changes in the implementation not the class you are implementing.
The problem with ordering is that atoi() is only reading the integer (ie it stops at the '.' character. Thus all your numbers smaller than 0 have a zero value for comparison and thus they will appear in a random order. To compare against the full value you need to extract them as a floating point value (double).
",0,1602732
1583525,"
Okay, the problem is in the inner loop condition.   Can't tell you where exactly -- that's a homework.
The first element of your ""sorted"" array will correctly be the lowest.  But the others...
P.S.  Irrelevant to the problem, but, please, read a chapter about structures in your C++ book.
P.P.S.  You have chosen the worst sorting algorithm I could possibly imagine.  Try ""Bubble sort"", at least.
",2,1583509
1583561,"
Your algorithm is busted, Pavel pointed you in the right direction, and Sam gave you a good alternative.
Your real problem, however, is that you didn't approach the problem in a systematic manner, solving the smaller, simpler problems before moving on to the larger ones.  You should have first written a simple sort algorithm to sort a single array, along with a unit test program them exercised the code.  Next you should have moved to multiple arrays as you have (or, more correctly, structures) and a unit test that proved the thing still worked.  Continue in this manner until you've built a system that works and does all you want.
Welcome to the Software Development Process.
",4,1583509
12399290,"
Using C++11 lambdas
Now you can use the returned index vector in iterations such as
Obviously, you can also choose to supply your own original index vector, sort function, comparator, or automatically reorder v in the sort_indexes function using an extra vector.
",230,1577475
1577627,"
You could sort std::pair instead of just ints - first int is original data, second int is original index. Then supply a comparator that only sorts on the first int. Example:
Sort the new problem instance using a comparator like:
The result of std::sort on v_prime, using that comparator, should be:
You can peel out the indices by walking the vector, grabbing .second from each std::pair.
",81,1577475
11715359,"
I wrote generic version of index sort.
Usage is the same as that of std::sort except for an index container to receive sorted indexes.
testing:
you should get 2 1 0 3.
for the compilers without c++0x support, replace the lamba expression as a class template:
and rewrite std::sort as
",11,1577475
43488246,"
Now a contains both both our values and their respective indices in the sorted.
a[i].first = value at i'th.
a[i].second = idx in initial array.
",8,1577475
18683662,"
I came across this question, and figured out sorting the iterators directly would be a way to sort the values and keep track of indices; There is no need to define an extra container of pairs of ( value, index ) which is helpful when the values are large objects; The iterators provides the access to both the value and the index:
as for the usage example:
now, for example, the 5th smallest element in the sorted vector would have value **idx[ 5 ] and its index in the original vector would be distance( A.begin( ), *idx[ 5 ] ) or simply *idx[ 5 ] - A.begin( ).
",6,1577475
40183830,"
Its easier than it seems to be.
Suppose Given vector is 
Create A new vector
Sort V and while sorting instead of comparing elements of V , compare corresponding elements of A
",5,1577475
24327593,"
Make a std::pair in function then sort pair : 
generic version : 
ideone
",2,1577475
43922758,"
Beautiful solution by @Lukasz Wiklendt! Although in my case I needed something more generic so I modified it a bit:
Example: Find indices sorting a vector of strings by length, except for the first element which is a dummy.
prints:
",2,1577475
1577545,"
Are the items in the vector unique? If so, copy the vector, sort one of the copies with STL Sort then you can find which index each item had in the original vector.
If the vector is supposed to handle duplicate items, I think youre better of implementing your own sort routine.
",1,1577475
31883640,"
There is another way to solve this, using a map:
This will eradicate non-unique elements though. If that's not acceptable, use a multimap:
In order to output the indices, iterate over the map or multimap:
",1,1577475
35228068,"
Well, my solution uses residue technique. We can place the values under sorting in the upper 2 bytes and the indices of the elements - in the lower 2 bytes:
Then sort the array myints as usual:
After that you can access the elements' indices via residuum. The following code prints the indices of the values sorted in the ascending order:
Of course, this technique works only for the relatively small values in the original array myints (i.e. those which can fit into upper 2 bytes of int). But it has additional benefit of distinguishing identical values of myints: their indices will be printed in the right order.
",1,1577475
36728897,"
For this type of question
Store the orignal array data into a new data and then binary search the first element of the sorted array into the duplicated array and that indice should be stored into a vector or array.
Here binarysearch is a function which takes the array,size of array,searching item and would return the position of the searched item
",1,1577475
1577490,"
If it's possible, you can build the position array using find function, and then sort the array.
Or maybe you can use a map where the key would be the element, and the values a list of its position in the upcoming arrays (A, B and C)
It depends on later uses of those arrays.
",1,1577475
51939088,"
There are many ways. A rather simple solution is to use a 2D vector.
Here is the output:
",0,1577475
52650007,"
Consider using std::multimap as suggested by @Ulrich Eckhardt. Just that the code could be made even simpler.
Given
To sort in the mean time of insertion
To retrieve values and original indices
The reason to prefer a std::multimap to a std::map is to allow equal values in original vectors. Also please note that, unlike for std::map, operator[] is not defined for std::multimap.
",0,1577475
4066591,"
You cannot access the local variables of a function from within a locally defined function -- C++ in its current form does not allow closures.  The next version of the language, C++0x, will support this, but the language standard has not been finalized and there is little support for the current draft standard at the moment.
To make this work, you should change the third parameter of std::sort to be an object instance instead of a function.  The third parameter of std::sort can be anything that is callable (i.e. any x where adding parentheses like x(y, z) makes syntactic sense).  The best way to do this is to define a struct that implements the operator() function, and then pass an instance of that object:
Note that we have to store paramA in the structure, since we can't access it otherwise from within operator().
",27,4066576
4066592,"
In C++ you cannot define a free function inside another function. So your first code snippet is ill formed.

sort(v.begin(), v.end(), Local::Compare);

The 3rd argument must be a function object. Overload () operator inside the class and then create the function object.

In C++0x you can use lambda expressions.
",12,4066576
4066675,"
One possibility is to pass the parameter when you construct your comparator object:
",5,4066576
54143263,"
//Using std::bind
//Example
",0,4066576
4008266,"
To sort an array in ascending, use:
To sort it in descending, use
HTH
",44,4008253
4008265,"
You can pass custom comparison functor to the std::sort function.
",2,4008253
4008280,"
Well first I'm hoping your array assignment was just an error when posting but all your numbers are being assigned to the same memory location. There's nothing to sort.
After that, you can use the sort() function. The example linked shows an easy method for using it. Note that there is a third parameter that's not being used that will specify how to compare the elements. By default if you don't specify the parameter it uses 'less-than' so you get an ascending order sort. Change this to specify 'greater-than' comparator to get a descending order sort.
",2,4008253
4008299,"
Generally, you can just swap the two variables in
http://www.cplusplus.com/reference/algorithm/sort/
Change 
to 
you can rename it to something else so that you have two comparison functions to use when the result needs to be ascending or descending.
If the function body has complicated expressions and involves i and j multiple times, then it is easier to swap the i and j in the parameter list instead of every i and j in the body:
The same goes for 
http://www.cplusplus.com/reference/clibrary/cstdlib/qsort/
",1,4008253
15717338,"
",1,4008253
4005316,"
You can't traverse a singly-linked list backward, but you can keep a pointer to the last two elements you have seen instead of just one.
So, traverse the list from the front, and keep two pointers: current, and previous.  If the element you are inserting is less than current, then update previous to point to it.
",1,4005284
4005303,"
No a singly linked list cannot go backwards.
",0,4005284
4005351,"
Here's my understanding of what you're asking: when you search for an insert position in a singly linked list you find it by discovering that you've gone one node too far, then, how to go back?
Well, there are two main solutions:

peek one node ahead while searching (a different viewpoint of the same idea is to keep a ""trailing"" pointer), or
make sure that there's an artifical tail-node (so that you always have a real next node), and that there are no other ""external"" pointers into the list than your search pointer. Insert your new node after the node with higher value. Swap the contents of the two nodes.

The second solution is a little brittle because of the assumption of no other ""external"" pointers into the list. But it's sort of ingenious. I learned it from Donald Knuth's ""The Art of Computer Programming"".
Alternatively to these singly linked list solutions, you can just double-link your list.
Cheers & hth.,
",0,4005284
4005393,"
You can use recursion to traverse a singly linked list backwards.
",0,4005284
4006609,"
Its easier to take an example
Traverse the list with two pointers: (i) currentNode and (ii) nextNode. 
Start with currentNode = NULL and nextNode = <10>. Move both of them forward in a loop as long as nextNode->key < insertkey is true. 
Upon exit from loop (example: for insertKey == 25, currentNode = <20>, nextNode = <30>): 

create newNode with newNode->key = insertKey and newNode->value = insertValue
""Insert"" newNode between currentNode and nextNode by doing
2.1 currentNode->next = newNode
2.2  newNode->next = nextNode

",0,4005284
3983578,"
You can use the STL sort algorithm.
In case you really want to hand code it, you may want to make some changes:
In the inner for loop, change
to
Also, reassign temp to a[i] inside the if.

Full code below:
",1,3983541
3983546,"
Unless this is homework and you're limited in which functions you can use:
",5,3983541
3983598,"
You should use one of the library-provided sort routines but, for what it's worth, the canonical bubble sort can be done as follows:
I would only use this where library-provided routines are not usable for some reason and, even then, only for small data sets.
It's relatively efficient (as far as bubble sort goes) since it doesn't re-check elements that have already been placed in the correct position (each iteration moves one more element to its correct position at the top of the list, hence the use of limit), and will exit after an iteration in which no swaps are done (i.e., the list is sorted).
",3,3983541
3983547,"
Have you looked at C's 'qsort' method? That'll sort your array.
C++ has its own built-in sort function too, as part of its standard library.
Can you not use either of those?
In your code, the inner loop ought to start with int i = x+1; rather than with i starting at 0.
",1,3983541
3885638,"
According to the C++ Standard §23.1/11:

Unless otherwise specified (either explicitly or by defining a function in terms of other functions), invoking
  a container member function or passing a container as an argument to a library function shall not invalidate
  iterators to, or change the values of, objects within that container.

§25.3 ""Sorting and related operations"" doesn't specify that iterators will be invalidated, so iterators in the question should stay valid.
",19,3885482
3885541,"
They still point to the beginning and end. The values in those slots of the vector have probably changed, but the storage location in which each resides remains the same.
",13,3885482
3885643,"
std::sort will not invalidate iterators to a vector. The sort template uses the * operator on the iterators to access and modify the contents of the vector, and modifying a vector element though an iterator to an element already in the vector will not invalidate any iterators.
In summary, 

your existing iterators will not be invalidated
however, the elements they point to may have been modified

In addition to the support for the standard provided by Kirill V. Lyadvinsky (Does a vector sort invalidate iterators?):

25/5 ""Algorithms library""


If an algorithm’s Effects section says
  that a value pointed to by any
  iterator passed as an argument is
  modified, then that algorithm has an
  additional type requirement: The type
  of that argument shall satisfy the
  requirements of a mutable iterator
  (24.1).


24.1/4 ""Iterator requirements""


Besides its category, a forward,
  bidirectional, or random access
  iterator can also be mutable or
  constant depending on whether the
  result of the expression *i behaves as
  a reference or as a reference to a
  constant.

",6,3885482
3885563,"
std::vector keeps its elements in contiguous memory. std::sort takes arguments (iterators) by value and re-arranges the sequence between them. The net result is your local variables start and end are still pointing to first and one-past-the-last elements of the vector.
",1,3885482
3834655,"
This is selection sort.  On each pass you find the i'th smallest element and put it in position i.  After the first pass, it is not necessary to look at A[0] anymore, and so on.  Selection sort is worst-case O(n2) and best-case O(n), just like bubble sort, but it has a smaller constant factor than bubble sort.  Insertion sort, an additional refinement, is even better, to the point where it's faster than most O(n log n) algorithms for very small arrays (fewer than ten elements or so) and so serious library sort primitives will cut over to it for small subproblems.
",1,3834609
3835241,"
This sort is similar to selection sort, in that each pass through the outer loop identifies the best element and removes it from further consideration.  In a traditional selection sort, however, the best element is swapped with the element to be removed and other elements are left alone.  In the sort you list (found, IIRC, in ""A Basic Approach to Basic"" among other places) some other elements will get swapped around as well.  I don't think the extra swaps accomplish anything particularly useful, and the sort loses out on just about the only advantage bubble sort has (suitability for implementation on purely-sequential-access media)
",1,3834609
3834700,"
The algorithm looks more like insert sort to me, as they share the same (outer) loop invariant -- after j-th iteration of the outer loop, the j smallest elements are in their correct positions.
On the other hand, the characteristic property of bubble sort is that it always swaps neighboring elements (a property which is not satisfied in your snippet).
The time complexity of this algorithm is O(n^2), just like bubble sort and insert sort (and quick sort in the worst case).
",0,3834609
3834848,"
It looks like a Selection Sort to me. The algorithm works as follows (as described on the wiki page):

Find the minimum value in the list
Swap it with the value in the first position
Repeat the steps above for the remainder of the list (starting at the second position and advancing each time)

",0,3834609
3797463,"
You need to limit your inner loop to <4:
",3,3794856
3795015,"
Why not use the STL sort?
",2,3794856
3795233,"
Perhaps you are printing i instead of A[i] in the printing loop, as in
",0,3794856
3797409,"
Is there a reason you are doing bubble sort, other then trying to learn it? It's one of the slower sorts.
",0,3794856
3762425,"
A std::set is sorted automatically as you insert elements into it. You don't need to (and you can't) sort it manually.
Just skip sort(begin, end); and everything will be just fine!
Also, in this case your functor mimics operator<, so all you have to write is:
",6,3762309
3762355,"

hey, i am trying to sort my set
ofc i did not forget to include algorithm

Are you trying to std::sort a set? That is meaningless and won't work
",2,3762309
3762394,"
A set is a sorted associative container.  You can't re-sort a set once it has been created.  The sorting mechanism is a template parameter of the set itself.
So if you want to represent the elements in a set in a different order, you have three options:
1) Copy the elements from the original set to another container (a vector might be simplest), and sort that.
2) Redefine the set using a different sorting mechanism
3) Create a sorted index that maps references to the set in a different order.
",2,3762309
3762408,"
A std::set object is an ordered container.  You can specify the sort comparison functor as the 2nd template argument.  The default function object used is std::less.
",0,3762309
3759152,"
Inserting n items into a priority queue will have asymptotic complexity O(n log n) so in terms of complexity, it’s not more efficient than using sort once, at the end.
Whether it’s more efficient in practice really depends. You need to test. In fact, in practice, even continued insertion into a linear array (as in insertion sort, without building a heap) may be the most efficient, even though asymptotically it has worse runtime.
",21,3759112
10761286,"
This probably comes to you a little late in the game as far as your question is concerned, but let's be complete.
Testing is the best way to answer this question for your specific computer architecture, compiler, and implementation. Beyond that, there are generalizations.
First off, priority queues are not necessarily O(n log n).
If you have integer data, there are priority queues which work in O(1) time. Beucher and Meyer's 1992 publication ""The morphological approach to segmentation: the watershed transformation"" describes hierarchical queues, which work quite quickly for integer values with limited range. Brown's 1988 publication ""Calendar queues: a fast 0 (1) priority queue implementation for the simulation event set problem"" offers another solution which deals well with larger ranges of integers - two decades of work following Brown's publication has produced some nice results for doing integer priority queues fast. But the machinery of these queues can become complicated: bucket sorts and radix sorts may still provide O(1) operation. In some cases, you may even be able to quantize floating-point data to take advantage of an O(1) priority queue.
Even in the general case of floating-point data, that O(n log n) is a little misleading. Edelkamp's book ""Heuristic Search: Theory and Applications"" has the following handy table showing the time complexity for various priority queue algorithms (remember, priority queues are equivalent to sorting and heap management):

As you can see, many priority queues have O(log n) costs not just for insertion, but also for extraction, and even queue management! While the coefficient is generally dropped for measuring the time complexity of an algorithm, these costs are still worth knowing.
But all these queues still have time complexities which are comparable. Which is best? A 2010 paper by Cris L. Luengo Hendriks entitled ""Revisiting priority queues for image analysis"" addresses this question.

In Hendriks' hold test, a priority queue was seeded with N random numbers in the range [0,50]. The top-most element of the queue was then dequeued, incremented by a random value in the range [0,2], and then queued. This operation was repeated 10^7 times. The overhead of generating the random numbers was subtracted from the measured times. Ladder queues and hierarchical heaps performed quite well by this test.
The per element time to initialize and empty the queues were also measured---these tests are very relevant to your question.

As you can see, the different queues often had very different responses to enqueueing and dequeueing. These figures imply that while there may be priority queue algorithms which are superior for continuous operation, there is no best choice of algorithm for simply filling and then emptying a priority queue (the operation you're doing).
Let's look back at your questions:
What's faster: inserting into a priority queue, or sorting retrospectively?
As shown above, priority queues can be made efficient, but there are still costs for insertion, removal, and management. Insertion into a vector is fast. It's O(1) in amortized time, and there are no management costs, plus the vector is O(n) to be read.
Sorting the vector will cost you O(n log n) assuming that you have floating-point data, but this time complexity's not hiding things like the priority queues were. (You have to be a little careful, though. Quicksort runs very well on some data, but it has a worst-case time complexity of O(n^2). For some implementations, this is a serious security risk.)
I'm afraid I don't have data for the costs of sorting, but I'd say that retroactive sorting captures the essence of what you're trying to do better and is therefore the better choice. Based on the relative complexity of priority queue management versus post-sorting, I'd say that  post-sorting should be faster. But again, you should test this.
I am generating some items that I need to be sorted at the end. I was wondering, what is faster in terms of complexity: inserting them directly in a priority-queue or a similar data structure, or using a sort algorithm at end?
We're probably covered this above.
There's another question you didn't ask, though. And perhaps you already know the answer. It's a question of stability. The C++ STL says that the priority queue must maintain a ""strict weak"" order. This means that elements of equal priority are incomparable and may be placed in any order, as opposed to a ""total order"" where every element is comparable. (There's a nice description of ordering here.) In sorting, ""strict weak"" is analogous to an unstable sort and ""total order"" is analogous to a stable sort.
The upshot is that if elements of the same priority should stay in the same order you pushed them into your data structure, then you need a stable sort or a total order. If you plan to use the C++ STL, then you have only one option. Priority queues use a strict weak ordering, so they're useless here, but the ""stable_sort"" algorithm in the STL Algorithm library will get the job done.
I hope this helps. Let me know if you'd like a copy of any of the papers mentioned or would like clarification. :-)
",74,3759112
3759564,"
To your first question (which is faster): it depends. Just test it. Assuming you want the final result in a vector, the alternatives might look something like this:
So, std::sort beats std::priority_queue, in this case. But maybe you have a better or worse std:sort, and maybe you have a better or worse implementation of a heap. Or if not better or worse, just more or less suited to your exact usage, which is different from my invented usage: ""create a sorted vector containing the values"".
I can say with a lot of confidence that random data won't hit the worst case of std::sort, so in a sense this test might flatter it. But for a good implementation of std::sort, its worst case will be very difficult to construct, and might not actually be all that bad anyway.
Edit: I added use of a multiset, since some people have suggested a tree:
To your second question (complexity): they're all O(n log n), ignoring fiddly implementation details like whether memory allocation is O(1) or not (vector::push_back and other forms of insert at the end are amortized O(1)) and assuming that by ""sort"" you mean a comparison sort. Other kinds of sort can have lower complexity.
",5,3759112
3759290,"
Depends on the data, but I generally find InsertSort to be faster.
I had a related question, and I found in the end the bottleneck was just that I was doing a deffered sort (Only when I ended up needed it) and on a large amount of items, I usually had the worst-case-scenario for my QuickSort (already in order), So I used an insert sort 
Sorting 1000-2000 elements with many cache misses
So analyze your data!
",5,3759112
3760049,"
As far as I understand, your problem does not require Priority Queue, since your tasks sounds like ""Make many insertions, after that sort everything"". That's like shooting birds from a laser, not an appropriate tool. Use standard sorting techniques for that.
You would need a Priority Queue, if your task was to imitate a sequence of operations, where each operation can be either ""Add an element to the set"" or ""Remove smallest/greatest element from the set"". This can be used in problem of finding a shortest path on the graph, for example. Here you cannot just use standard sorting techniques.
",2,3759112
3759193,"
A priority queue is usually implemented as a heap. Sorting using a heap is on average slower than quicksort, except that quicksort has a worse worst case performance. Also heaps are relatively heavy data structures, so there's more overhead.
I'd reccomend sort at end.
",1,3759112
3759405,"
Why not use a binary search tree? Then the elements are sorted at all times and the insertion costs are equal to the priority queue.
Read about RedBlack balanced trees here
",1,3759112
3759121,"
I think that the insertion is more efficient in almost all cases where you are generating the data (i.e. don't already have it in a list).
A priority queue is not your only option for insertion as you go. As mentioned in other answers a binary tree (or related RB-tree) is equally efficient. 
I would also check how the priority queue is implemented - many are based on b-trees already but a few implementations are not very good at extracting the elements (they essentially go through the entire queue and look for the highest priority).
",1,3759112
8283563,"
On a max-insert priority queue operations are O(lg n)
",0,3759112
4361860,"
The following is more or less your code. It compiles, and produces the expected output. To further help you, we need more information as to what isn't working.
",0,3752349
4360964,"
STL uses onle operator less overloading. Otherwise you can specify any boolean functor for the sort, but you have to input it at the stable_sort call.
",-1,3752349
3743802,"
You have to shift all elements to make room for the new element. This is an O(n) operation. Since you can't do better than O(n) I think it is reasonable to use this simple O(n) algorithm:

Set i to the index of the last element in the array
If the element to insert is larger then a[i] then insert the element at index i+1 and stop.
Otherwise set a[i+1] = a[i] then decrease i and repeat the previous step.
If i reaches 0, insert the element at the start.

This assumes that your array has space to insert an extra element.
",4,3743764
3743767,"
You can find the insert position using binary search.
",2,3743764
3744089,"
Think about the separate tasks that need to be done to insert:

Find the index n of where the new element should be
move every element from last to n (inclusive) up one slot in the array (only if there is unused cells in the array, otherwise give up and report an error)
put the new element in array[n]

The first two steps could easily be their own functions and would help you mentally separate the tasks:

n = index_to_put(float new_element, float *array, int array_max, int last_used);
new_last_used = move_cells_up(float *array, n, int array_max, int last_used);
array[n] = new_element; last_used = new_last_used;

",2,3743764
3704893,"
The proper way to implement swap is:
However, it only makes sense to do this when you need to write the Big Three (you're managing some resource).
You aren't, so I don't see the point. (All your swap will do is copy around some doubles, just like the default std::swap would.)
",5,3704868
3704878,"
You have to specialize the std::swap template, not overload it.
EXAMPLE:
",1,3704868
3704894,"
sort probably calls the swap member function of vector. You cant do what you are doing anyway, redefining std::swap is going to play havoc under the hood.
Plus - are you sure that double, double counts as big?
",0,3704868
3563289,"
Your sub vectors are specified incorrectly.
Remember the iterators specify the beginning to one past the end.
So this will misses the middle element and the last element in the vector.
And is also undefined for really short vectors of length 2
Imagine if a is the vector { A, B, C, D}
Or Try a bigger vector: { A, B, C, D, E, F, G, H, I}
Or Try a smaller vector: { A, B}
Should be:
The vectors passed into merge(). The dst parameter has to be passed by reference as it is an out parameter. But also note that first and second parameters are const so we can pass by const reference (to avoid the copy step).
Also the merge function:  
Is pushing the value into dst. But dst is already full from the data that came in. So before we do the merge the destination must be cleared.
",2,3563173
3563194,"
If sz == 2, &a[(sz/2)+1] will try to take the address of a[2], which will give you this error.
",3,3563173
3563391,"
Martin is right, the problem is the contructor of the auxiliar vectors:
Original vector: 1 9 7 9 2 7 2 1 9 8
iter1: 2, iter2: 8
http://www.cppreference.com/wiki/stl/vector/vector_constructors
And talking about merge-sort and other sorting algorithms, I´ve found a very useful web:
http://www.sorting-algorithms.com/merge-sort
",0,3563173
3487560,"
If you use A.at(i) instead of A[i], bounds checking will be done, and out-of-range exceptions thrown. That may be helpful for debugging.
It appears to me that the access here...
will be out-of-bounds when firstIndex is zero (the first iteration of the main loop).
",3,3487532
24352780,"
This may help you
",0,3487532
3413756,"
Create a vector of pairs (i,j) and sort it by size property.
",3,3413686
3413799,"
Use std::sort and supply a custom comparison function object to sort by a user-defined property or other relation.
As for how it should be sorted, if you want to sort it but not change it, then you will have to copy the array. The best way to do this is store your GridCells on the heap and store smart pointers to them in the vectors. This way, sorting and copying them will involve less overhead.
",1,3413686
3413804,"
You can put references in a secondary array and sort that one:
",0,3413686
3401398,"
Write a non-lexicographical comparison routine and pass it along with the iterators to std::sort.
",1,3401385
5184182,"
Create a vector of objects that contain indices to the two arrays. Define operator< for that object to do the comparison based on keys[index]. Sort that vector. When you're done, walk through that vector and put your original objects into the order defined by those proxy objects:
",2,3398819
3398928,"
Here is a sample implementation which defines a new iterator type to provide a paired view over two sequences. I have tried to make it standards compliant and correct, but since the C++ standard is hideously complex in its details, I am almost certain that I have failed.
I will say that this code appears to work when built with clang++ or g++.
This code is not recommended for general use, since it is longer and less understandable than the other answers, and possibly invokes the dreaded 'undefined behaviour'.
However, it does have the advantage of constant time and space overhead since it provides a view on existing data rather than actually building a temporary alternate representation or permutation vector. The most obvious (to me) performance problem with this code is that individual elements of the two containers will have to be copied during the swap operation. Despite several attempts, I have not found a way to successfully specialise std::swap such that std::sort or std::random_shuffle will avoid using the default temporary-copy based swap implementation. It is possible that use of the C++0x rvalue reference system (see std::move and Jon Purdy's answer) could solve this.
",2,3398819
3408845,"
You could use a map:
Here's the output:
",1,3398819
3398921,"
You can use functors to do the sorting, for example:
",1,3398819
3398975,"
This problem really got me thinking. I came up with a solution that makes use of some C++0x features to get a very STL-like parallel_sort algorithm. In order to perform the sort ""in-place"", I had to write a back_remove_iterator as the counterpart of back_insert_iterator to allow the algorithm to read from and write to the same container. You can skip over those parts and go straight to the interesting stuff.
I haven't put it through any hardcore testing, but it seems reasonably efficient in both time and space, principally due to the use of std::move() to prevent unnecessary copying.
I hope this proves useful, or at least entertaining.
",1,3398819
3406274,"
It turns out that Boost contains an iterator which does pretty much what the paired_iterator from my other answer does:
Boost.Iterator Zip Iterator
This seems like the best option.
",0,3398819
31956164,"
I don't know whether following exploitation of knowing of std::swap implementation details is UB or not. I think ""no"".
",0,3398819
3322493,"
This should help you : 
http://www.cplusplus.com/reference/algorithm/sort/
",4,3322482
3322511,"
To sort a standard C array using the std::sort algorithm:
Now if you have a two dimensional array, you can use the same idea to sort the second dimension of each item in the first dimension:
",6,3322482
3322521,"
std::sort will, by default, sort objects in ascending order.  To sort in descending order, you can use the std::greater function object:
",3,3322482
3322585,"
There are too many sorting algorithms, like quicksort and bubble sort, with different complexity. And this complexity varies upon size of data set, default order of data within data set, etc. You have to study your data set and pick one algorithm that will meet your requirement faster. You can find sorting algorithms in http://en.wikipedia.org/wiki/Sorting_algorithm.
",1,3322482
3322609,"
If this is a homework assignment, you probably don't want to use std::sort. Your teacher might consider you cheeky :P
I'd go with what Muhit said and try learning from Wikipedia's article on sorting algorithms, http://en.wikipedia.org/wiki/Sorting_algorithm. Most of the individual articles have the algorithms implemented in pseudocode, so you can just pick one to code up.
But if this is for a different project, yeah, definitely go with STL, there shouldn't really be any reason to code up a sorting algorithm by hand right now.
",1,3322482
3273817,"

It is easy to implement for linked lists, since you always swap adjacent nodes while traversing left to right repeatedly.
Bubble sort is a stable sort.

",11,3273794
3273814,"
Performance-wise, Bubble Sort is not very good (O(n^2)).  Here are some of it's advantages:

Bubble Sort is very easy to write correctly (if you're doing something quick and dirty then it might be easier just to use bubble sort).
Memory consumption is very low (because it is an in-place sort, unlike Merge Sort for arrays)

",10,3273794
3273839,"
It's simple enough to play it out in school without it ending in a total mess:
""If your left neighbor is taller than you, please switch places.""
",9,3273794
3273867,"
It's easier to program.  Even seasoned programmers get quick sort, heap sort, and merge sort wrong.  Also it does not consume an extra log(n) to O(n) in stack space.  Although you can implement heap sort non recursively.
Basically the algorithms are this
O(n^2) worst case performance
Basically this is slower....  

Insertion O(n^2) but performs O(n) on already sorted lists  
Bubble sort: similar but not always programmed with the early exit to allow for this. Generally this one seems to be the more popular one to discuss and throw out in interviews  
Selection Sort: there is generally no early exit so this always takes O(n^2)

O(n * lg(n))
Generally the fastest sorting algorithms for general sorting when you don't know anything about the input (this has actually been proven to be a lower bound on sorting without knowing anything about the input):  

Quick Sort: It is usually the faster of the high speed algorithms, but mistakes in picking the pivot can make it degenerate to O(n^2), and then it is worse than say Bubble/Insertion/Selection because it also consumes stack space.  It takes more advantage of cache locality so generally performs better than some of the other alternatives.  It needs LG(n) space to O(n) space for calls depending upon how well it pivots.  
Merge Sort:  O(n*log(n)) performance, but requires O(n) extra space in.  Generally not as fast as quick sort.  Generally requires lg(n) extra space as well for calls...
Heap Sort: Requires no extra space, can be implemented non recursively, but sort of bounces around the array so it is not as good on the cache as the others.  If implemented recursively requires lg(n) extra space for calls.

O(n) sorts
If you know something about your inputs you can often sort better than O(n*lg(n)).  Basically look up Radix Sort, Bucket Sort, Counting Sort, etc..  There are many schemes.  Generally if it is possible to sort using one of these you should....
**Other Sorts:  **
There are many other sorts available.  Things like shell sort, etc... the ones above are the more common.
But anyway in reality the faster algorithms are often harder to implement.  If someone told me to sort these numbers in 20 minutes without a library, I'd probably write selection sort.  The more complex ones are easier to get wrong.  And often require additional space.  You have to evaluate the complexity, space, and time tradeoffs.  Many programming languages have built in sorting libraries.
Also one other thing to be careful of is whether a sort is stable or not.  Basically if you have A, C, D, C, G, C will each C appear in order, or will the last C appear before one of the other C's.  This is important if you are sorting on multiple fields.  Ie if you sort by First Name and then last name (Alex Rodriguez, Jane Rodriguez, Betty Rodriguez)...first sort you'd get (Alex R, Betty R, Jane R).  Second sort if it is stable you will get Alex R, Betty R, Jane R.  If it is not stable, you could get any order.  Generally Bubble and Insertion are easy to implement to be stable.  Heap Sort and Quick Sort usually aren't stable.  Merge sort is easy to implement as stable.  This also factors into choices....
Also if you don't know O(n) notation, basically it is an upper bound on how many computations it takes.  To give you an idea, to sort 20 items you are looking at around 400 operations with O(n^2) while with O(n * lg(n)) you are looking at 20 * approx 4.3 so around 86 operations.  And for lg(n) you are looking at around 4.3.  Anyway the larger the number gets the bigger this difference is.  10000 items is 133000 operations for n*lg(n) and 100000000 for n^2.  For large lists using the slower sorts starts to become impractical.  And of course O(n) is just 10,000.  The number of operations is not exactly those numbers, but they speak to how fast it grows.  Ie with just lg(n) you grow from 4.3 for 20 to 133000.  With n you grow from 20 to 10000 with n * lgn you grow from 86 to 133000 and with n^2 you grow from 400 to 100000000.  So basically as your lists get bigger the slower ones will reach a point where they can't do them but the faster ones can.
Anyway having put it all in context I see the following advantages to bubble sort: 

Easy to implement and get right.  
Doesn't consume extra space for array or procedure calls (assuming you don't implement it recursively)...so good for low memory environments  
It reads the array sequentially so this is good for the memory cache  
Someone else mentioned it is easy to use this to sort linked lists  
It is easy to make this stable  
Some interviewer will no doubt mention this at some point  

Anyway in libraries Quick Sort and Stable Merge sort seem to be the most popular.
",9,3273794
3273929,"
Bubble sort is the fastest way to sort a list of three items. With very few exceptions, all sorts degenerate into a form of bubble sort for lists of three.
",7,3273794
3274075,"
BubbleSort is faster than QuickSort (and almost every other sort) on already sorted lists ;-)
QuickSort's best-case performance is O(N log N), BubbleSort's is O(N) !
Other than this exotic, I'd have to agree with Donald Knuth, The Art of Computer Programming, Vol. 3: Sorting and Searching:

In short, the bubble sort seems to have nothing to recommend it, except a catchy name and the fact that it leads to some interesting theoretical problems

",7,3273794
3273836,"
Realistically you would never use it for anything other than very small lists.  For a sufficiently small list the low overhead can make it superior to the fancier sorts.  I'd never use it for more than a dozen items.
",3,3273794
3259950,"
As I understand your question, you need to generalise "">"" to strings -- you can obviously use some library function (for STL strings, > is defined), but if it is a homework, you are probably in need to write your own. If we are limited to ASCII, it is pretty straightforward while ASCII codes of letters hold alphabetical order ((int)'A'<(int)'B').
 To compare strings, you should start with first letters of two strings, if they are not equal return the result of their comparison, and if they are the same proceed to the next pair.
",1,3259889
3259897,"
Create a functor that accepts an array of strings and handles the comparison however you want (if STL).
",0,3259889
3266572,"
The < and > operators are already able to handle comparing strings in alphabetical order. just overload the function to have a string array [] instead of a int array [] in the parameters. The one problem is that these operators are case sensitive so you will need to convert all the characters in the string to upper or lower case before doing the check.
",0,3259889
3170433,"
This is not an algorithm, just some thinking aloud. It will probably break if there are too many duplicates.
If there was no duplicates, you'd simply rearrange the values so the indexes are 0,1,2, and so on. So for the starting point, let's exclude the values that are double-referenced and arrange the rest
Since there are duplicates, you need to figure out where to stick them.  Suppose the duplicate  is referred to by ranges r1, r2, r3. Now, as long as you insert the duplicate between min([r1,r2,r3].minIndex)-1 and max([r1,r2,r3].maxIndex)+1, the sum of maxIndex-minIndex will be the same no matter where you insert it. Moving the insertion point to the left will reduce max-min for all ranges to the left, but increment it for all ranges to the right. So, I think the sensible thing to do is to insert the duplicate at the left edge (minindex) of the rightmost range (one with largest minIndex) of r1,r2,r3. Repeat with all duplicates.
",1,3164034
3167480,"
Okay, it looks like there is only one way to reliably solve this problem:
Make sure that no index is ever used by two ranges at once by duplicating values.
I.e scan entire array of indexes, and when you find index (of value) that is being used in more than one range, you add copy of that value for each range - each with unique index. After that problem becomes trivial - you simply sort values in the way that will make sure that values array first contains values used only by first range, then values for 2nd range, and so on. I.e. this will get maximum packing.
Because in my app it is more important to minimize sum(ranges[i].maxIndex-ranges[i].minIndex) that to minimize number of values, this approach works for me.
I do not think that there is other reliable way to solve the problem - it is quite easy to get situation when there are indexes used by every range, and in this case it will not be possible to ""pack"" data no matter what you do. Even allowing index to be used by two ranges at once will lead to problems - you can get ranges a, b and c where a and b, b and c, a and c will have common indexes. In this case it also won't be possible to pack the data.
",0,3164034
3159784,"
Use std::sort with a comparison function.
(The link has a nice example)
",7,3159754
3160124,"
The easy part: write the sort itself:
The harder part: writing the comparison itself. In pseudocode, for full generality:
where lhs site, etc. are the individual bits of data you need to sort by, picked out of the filename.
Given the strict file naming structure you have, though, and your specific sorting needs, you can actually get away with just splitting the string by the first '_' character and doing a lexicographical compare of the second chunk, followed the first chunk if the second chunk is equal. That will make the code to parse the filename much easier, at the potential cost of flexibility if the file naming format ever changes.
",2,3159754
3159785,"
Just write a method that will compare two filenames based upon your criteria, to determine which one comes first then use any standard sorting method.
",1,3159754
3159805,"
Use std::sort and implement a Compare Class  
look into http://www.cplusplus.com/reference/stl/list/sort/ for further details
",1,3159754
3159787,"
Your sort predicate which you pass to vector::sort() may create reordered temporary strings of the string which it then compares.
",0,3159754
3159779,"
You could use qsort with your own string compare function that takes into account your sorting rules, and the address of the first element in each vector where it asks for an array.
http://www.cplusplus.com/reference/clibrary/cstdlib/qsort/
But you shouldn't. Just use std::sort
",0,3159754
3169118,"
Here's a boost lambda functions version. This is overkill, and pretty cryptic, but it's brief and flexible in terms of how one can juggle with different fields criteria. Obviously you need boost. Also, expect increased compilation time. So, here it is:
",0,3159754
3149742,"
I can think of a simple transformation (well two) to get what you want. You could use std::transform with suitable predicates.

std::vector<Thing> to std::vector< std::pair<Result,Thing> >
sort the second vector (works because a pair is sorted by it first member)
reverse transformation

Tadaam :)
EDIT: Minimizing the number of copies

std::vector<Thing> to std::vector< std::pair<Result,Thing*> >
sort the second vector
transform back into a secondary vector (local)
swap the original and local vectors

This way you would only copy each Thing once. Notably remember that sort perform copies so it could be worth using.
And because I am feeling grant:
Provided with the usual caveat emptor: off the top of my head, may kill kittens...
",4,3149611
3149637,"
You can have a call to CalculateGoodness that you call for each element before sorting, and then CalculateGoodness simply updates an internal member variable.  Then you can sort based on that member variable. 
Another possibility if you can't modify your type, is storing some kind of std::map for your objects and their previously calculated values.  Your sort function would use that map which acts as a cache. 
",4,3149611
3149747,"
I've upvoted Brian's answer because it clearly best answers what you're looking for.  But another solution you should consider is just write it the easy way.  Processors are getting more powerful every day.  Make it correct and move on.  You can profile it later to see if CalculateGoodness really is the bottleneck.
",2,3149611
3149657,"
I'd create pairs of ratings and things, calling CalculateGoodness once per thing, and sort that on the rating. if applicable you could also move this to a map from rating to thing
the other option would be to cache CalculateGoodness in the Thing itself either as a simple field or by making CalculateGoodness a method of Thing (making sure the cache is mutable so const Things still works)
",1,3149611
3149736,"
Perhaps a tidy way of doing the separate vector thing is to actually create a vector< pair<float, Thing*> >, where the second element points to the Thing object with the corresponding float value. If you sort this vector by the float values, you can iterate over it and read the Thing objects in the correct order, possibly playing them into another vector or list so they end up stored in order.
",1,3149611
3142074,"
There is the equivalent to the rank function in C++: it's called nth_element and can be applied on any model of Random Access Container (among which vector and deque are prominent).
Now, the issue seems, to me, that the operate on values might actually modify the values and thus the ranks would change. Therefore I would advise storing the ranks.

std::vector<float> to std::vector< std::pair<float, rank_t> >
Sort the vector (works without any predicate)
Operate on the values
std::vector< std::pair<float, rank_t> > to std::vector<float>

Unless of course you want nth_element to be affected by the current modifications of the values that occurred.
",2,3141963
3144136,"
The answer is not to sort the floats, but instead make an array of pointers to the floats, and sort the array of pointers using a comparison function that dereferences the pointers and compares the floats they point to.
",1,3141963
3142004,"
http://www.cplusplus.com/reference/algorithm/sort/
you can stuff your float into a struct that also holds an int, build an array of these structs and store the position of each element in the int field. use the stl sort with a compare function that operates on the float field for your first step, perform your calculations, then sort with a compare function that operates on the int field to get back your original order. 
there might be a better way to do this, i'm not really a c++ guy
",0,3141963
3142115,"
The simple answer is to copy the arrays before sorting them, and restore them when you've finished. Only do something more complicated if speed is an issue.
In C++, you could sort an array of indices using a custom comparator to compare the array values, something vaguely like this (not tested, and assuming the floats are in a vector):
Or, at the cost of extra memory, you could build a vector of (float, rank) pairs, and sort that based on the float values. This approach would also work in C using qsort().
",0,3141963
3095208,"
Since std::sort is template based, the source should be available in a header. You can make a copy of it and insert your progress callback. The big problem will be predicting how close you are to completion - most sort functions will be based on Quicksort, which doesn't always do the same number of comparisons.
Writing your own Merge sort would be a possibility; the algorithm is easy and the number of steps are well defined.
",4,3095000
3095063,"
I think, even if you wrote your own sort, that you would have to do a lot of careful measurement if you wanted the progress indicator to be accurate.  If you only want an approximate progress indicator, then you can use some metric like 'average distance between compared elements' or 'number of comparisons as compared to average expected number for quicksort' as your metric and implement the comparison idea you already mentioned.
And yes, I assume that you aren't a complete idiot and do not plan on updating the progress indicator at each and every comparison.  If you did that you'd spend much more time indicating progress than sorting.
As an example, you would generally expect about n log2 n operations for quicksort.  The analysis of how many comparisons are involved is more detailed and can be more accurate than that general measure, but for the purposes of this example, lets just assume.  So you could count comparisons and report number_of_comparisons / (n log2 n) as your estimate of progress.
Since that's just an average indicator I would run a few experiments and see how far your estimate is off, and throw in some fudge factors to make it line up with the average expected case.  You could also have a progress bar that indicated the uncertainty by having sort of ""This is where I think I'll be done."" indicator and some space after the indicator.
Even if you used your own sort and came up with a more seemingly precise measure, the progress bar still wouldn't update smoothly and the effect would be similar.  The only way you know for sure how long your sort is going to take is if you use a somewhat slower, but really predictable sort, in which case you can predict how long it will take from the number of elements, or use a really fast sort that has less predictable behavior in specific cases, in which case there is no real way to have a perfectly accurate progress bar.
Predictability of subtasks and predictability of total number of comparisons are strongly linked.  So I really don't think that subtasks make a better measure than total number of comparisons.
If you want to use your own sort and predictability is your highest goal, go for heapsort.  It's still an O(n log2 n) sort, and it's close to being a minimum comparison sort (or so I remember from reading Knuth).  It also takes a very predictable amount of time to complete regardless of the dataset its fed.  It's one of the slower O(n log2 n) sorts, but still.
As one of your commenters mentioned though, you might be solving a problem that doesn't actually exist.  Run some experiments first.  The problem is a fun intellectual challenge regardless of its usefulness though.  :-)
",9,3095000
3095038,"
I would recommend your second option: use std::sort or another standard sorting function like qsort, and have the comparator report its progress. But don't update in every comparison--that would be unbearably slow--instead update every (say) 100ms.
",2,3095000
3095186,"
I see your problem as the following:

You want discrete events to be fired during a single continuous process.
This sub-division is just to tell the user things are in progress.

My suggestions are:

Use a loading icon from something like http://ajaxload.info/ ,  or if it not a gui based environment, just spell out loading. Since the event is under 2 seconds, this will not be a issue. Hang ups are expected if the wait time exceeds 10 seconds.
Writing your own sort method does bring in a lot of issues of thread safety, which might cause problems if your code is using multi-threading or is bound to do so in the future.

3.Another important information that you should consider how badly out of order will the data be everytime you want to sort, so in effect you will be measure the degree of randomness present, and the expected number of computations that you might need to do. you can use this information as an indicator as to how many swaps are required, which in turn can be counted on as you iterate thru the sort. Play around with the data.
",1,3095000
3101937,"
use brute force :)
(in case you don't want to implement your own std::sort() and since I'm lacking complete requirements)
",1,3095000
3095045,"
Use the observer pattern to signal back to the parent when each part completes. Using that and the total number of elements that need sorting you can update your progressbar in real time.
",0,3095000
3115142,"
I don't recommend trying to hack apart std::sort. That's generally implemented with introsort and is an extremely fast NLogN operation. Constructing the container you're going to sort will typically be more expensive than sorting the data.
However, if you're going to implement a progress bar, I recommend you put the sorting in a separate thread. Normally multithreaded applications are harder to write and maintain than single-threaded ones, but you can do it in a way in which it isn't for this progress bar case. Your application can still be predominantly single-threaded without any concurrent operations being performed with the exception of this progress bar and probably some event handling to keep the UI responsive. When you're ready to sort the data, simply fire off another thread to do it and put the main thread in a wait loop until the sorting thread is finished, sleeping here and there and upgrating the progress bar in the meantime.
You can generalize this non-intrusive approach to any kind of time-consuming operation without having to sprinkle update_progress_bar() type calls throughout your code or digging into the implementations of std::sort or trying to reinvent wheels. Because the main thread will be in a waiting/updating progress bar state and therefore blocking in a sense until your working thread is finished, you don't have any of the issues associated with multithreading (need for thread synchronization to access shared resources throughout your application with the exception of the progress counter, race conditions, dead locks, etc). It'll also be the smoothest progress counter you can implement since it will be updating concurrently.
If you're worried about the efficiency with associated with locking the progress counter, simply use atomic operations to increment it.
As for determining how much the sort algorithm has progressed, there are a couple ways to do it. One is to let it run once with the size of the data you have and try to predict the amount of time it would take for subsequent runs. That's completely non-intrusive but a little difficult to do, yet, if done right, it will monitor progress more accurately than incrementing a counter at regular intervals (which omits the fact that intervals may not take even amounts of time). The second approach which is simpler but a little bit evil is to modify your comparator predicate to increment a progress counter. Making predicates with state is generally frowned upon, but it's less evil than trying to implement your own introsort just because you want a progress counter.
Also if your introsort is taking so long, I have to wonder, does your container store these triangle objects or pointers to them? If the former, you might want to consider the latter as it should speed things up dramatically.
",0,3095000
3084555,"
The vector class doesn't have a sort function.
But there is a sort which works on all iterator ranges. And vector does expose iterators.
To sort a vector vec:
",23,3084528
3084537,"
Yes, there is sort() in stl algorithms. You should look at http://www.cplusplus.com/reference/algorithm/sort/
",11,3084528
3084534,"
You probably want std::sort.
a similar example using two boost libraries is below.
",6,3084528
3085292,"
As other's have mentioned in their answers, there is std::sort function. 
However, by ""the default sorting option?."" do you mean you want to sort a vector where T is a class you have defined. In that case, you have to implement ""operator<"" in your class. 
For example, 
To make sure that above ""std::sort"" line works, you need to define ""operator<"" in Foo.
",1,3084528
3052957,"
You'll need to read up on external sorting. The basic approach is to use some sort of divide-and-conquer routine like merge sort, where you read and sort a portion of the file, then read and sort another portion of the file, etc. and when you get to the end you merge the sorted portions together.
",7,3052949
3053005,"
Maybe the STXXL (Standard Template Library for Extra Large Data Sets) helps.
STXXL offers external sorting amongst others.
",4,3052949
3053013,"
You don't have to hold the whole file in memory. If this is a task you don't have to do very often, you can write an application that sorts it very slow. Something like this (pseudo):
",0,3052949
3053105,"
If you are using some unix-like OS you can use sort command. It will take care about memory consumption.
For an example something like ""cat large_file | sort"" will do the job.
Or you can write your own / use external sorting from the library. Tell us  what language are you using and maybe someone will tell you exact library to use.
",0,3052949
3045985,"
I would suggest a Schwartzian transform sort. Make a new vector (I recommend vector for more efficient sorting) of pairs of the associated value, and a pointer to its item. Sort the vector of pairs and then regenerate the list from the sorted vector. Since operator< is defined on a std::pair to be comparison by the first item of the pair and then the second, you will get a proper ordering.
Example:
Note that you will need a calcCost function that I have assumed here. This approach has an advantage over creating a comparison function if your comparison value calculation is time consuming. This way, you only pay the cost for calculating the comparison N times instead of 2 * N * log(N).
",10,3045831
3045899,"
You could make a comparison function that compares the two elements in the way that you would like.
Where ""thing_you_are_comparing_on"" is some member of the Move class that gives you the ordering you want. We use const here to make sure that we are only comparing and not  actually changing the objects in the comparison function. You can then call the sort method on the list with compare_m as the comparison function:
Something to note is that if the calculation of the comparison function is particularly expensive it may be worthwhile to precompute all the associated rank numbers before sorting.
This would require adding something to the move class to store the rank for use later:
",4,3045831
3046365,"
std::sort is used to sort STL collections.  If the elements in the collection you are sorting can be compared simply by calling operator< and the collection in question is a vector, then sorting is very simple:
If the collection in question is not a vector but a list as in your case, then you can't use the general version of std::sort, but you can use std::list's version instead:
STL's sort, along with most other algorithms in the STL, come in two flavors.  One is the simple version we have already seen, which just uses operator< to do the comparison of two elements.  The other is a 'predicated' version, which instead of using operator< uses a comparison functor you provide. This is what you need to use in your case.  There is a predicated version of sort for list, and this is what you need to use in your case.
You can create a functor in a number of ways, but one of the most useful is to derive a class from std::unary_function or from std::binary_function, depending on how many arguments your functor will take -- in your case, two.  Override the function-call operator,  operator() and add the code that compares two elements:
Here is a complete working example that puts everything together.  In this program, instead of having a list of Moves, I have a list of 10 strings.  Each string is 6 random characters.  The list is populated by the call to generate_n, which uses the functor generator to create each random string.  Then I dump that list of strings, along with their values, by calling copy and passing an output iterator that dumps the values to stdout (ostream_iterator).  The value of each string is simply a sum of the numeric value of each character, computed by the function strng_val.
Then I sort the list using list's predicated version of sort.  The comparison predicate used by sort is evaluator.  Then I finally dump the resulting list and the string values to the screen again as above:
",0,3045831
3041941,"
You can use std::sort (C++) or qsort (C or C++) to perform the sorting operation. The tricky part is that you need to define a custom comparison function for comparing your rows. For example:
",9,3041897
37516971,"
I used the following code:
",0,3041897
2999161,"
Create a functor to compare the correct field, then specify the functor when you sort:
Starting with C++11, you can use a lambda expression to do the comparison ""in place"", something like this:
",26,2999135
2999181,"
These are two easy ways:
Or write a compare function:
",8,2999135
2999196,"
Or if you don't have access to a compiler with lambda statements:
Or do it Coffin's way.  I tended to avoid the standard algorithms when you had to do it like that though...I'm lazy.
",8,2999135
3001538,"
In addition to earlier comments, you can also define multidimensional filters, like this:
Just like the operator above, you can make more advanced filters if needed.
",3,2999135
3000003,"
in general, boost::multi_index provides a lot of this functionality. This comes in especially useful if you need rapid access on more than one key. This answer won't help you with your homework though ;-)
See http://www.boost.org/
",0,2999135
2990530,"
First, in C++ you don't need to repeat ""struct"" every time.
You can use the std::sort() function and give it a custom predicate.
",6,2990505
2990529,"
You can use qsort.
",4,2990505
2990551,"
Do you have to implement your own sorting algorithm?
If so I strongly suggest typing ""Sorting Algorithms"" into google and/or checking out the wikipedia page.
Bubble sort is REALLY easy to implement (But is a poor sorting algorithm).  It will come down to checking each number against each other and then swapping them is one is less than the other.  String sorting is easy too as strcmp returns you a value less than 0 for a string ""less"" than the one being compared to and greater than zero for one ""greater"" than.
If you don't need to implement your own algorithm then use std::sort.
",1,2990505
2993707,"
You could add a comparison method to your structure:  
Now you can use the std::sort algorithm because your object has the '<' operator defined.
",0,2990505
2979638,"
You can't use a member function as the comparator. A member function needs the this pointer which cannot be passed from sort.
Instead, you have to create a function object to include the extra info, like:
Note that, since you have a list of Edge, not Edge*, the input arguments of the comparator should not be Edge*. I have changed those to const Edge&. 
",5,2979584
2979617,"
This line has unbalanced brackets and is horrible to read (the former is a consequence of the latter I suspect). Without seeing your Vertex class it's hard to say what it is supposed to do - after fixing the brackets, maybe you should reformat for readability.
",1,2979584
2972393,"
First, premature optimization is the root of all evil. That is, first benchmark your code and make sure the sorting is the one that's actually taking the most time. If another part of your performance-critical code is taking 80% of the execution time, you will get drastic performance improvements optimizing that first.
Considering you have 5 elements, the point is pretty much moot. Any algorithm you use (except bogosort :D) should have a pretty much constant execution time, unless you run the algorithm a few hundred times per second, or more.
Second, provided you still want to optimize the search, if you know for sure you always will have 5 elements, the optimal method is by hard-coding the comparations (It can be proven mathematically that this method is optimal, providing a minimal number of executed operations in the worst case scenario - we had this as a laboratory application in university). The same applies if you have less than five elements, but the algorithm becomes prohibitive to write and execute if you have more than seven elements - the logic is convoluted to write and follow so your code will become difficult to maintain.
Let me know if you need help with writing the optimal hard-coded algorithm itself (though I think you should find the implementation and theory online).
If you do not always have five numbers (or for some reason want to avoid the hardcoded comparisions algorithm), use the sort provided by the library. This page concludes that the stl sort is optimal in terms of time (not only number of executed operations). I do not know what implementation was used for search.
",2,2972146
2972220,"
Insertion sort and Bubble sort are great for tiny data pairs.
Another option is to hard code the compare logic, with a couple if statements.
Check out What is the fastest possible way to sort an array of 7 integers? for some ideas.
",6,2972146
2972223,"
It makes no sense to read about benchmarks. You can read about and compare the complexity (Big-O) of algorithms, because it only depends on the algorithms themselves, but benchmarking is something that depends on too many factors. 
You need to do the benchmarking for yourself, using the tools that you use, in the environment that matters to the users of your application. 
",5,2972146
2972165,"
For the data you have mentioned (0-5), use STL sort methods. ( historically qsort based)
stable_sort -- if you want to maintain the order for duplicates. ( historically merge sort based)
",3,2972146
2972204,"
Any particular reason why you need this code optimized? For n==5, pretty much any sort will do. Even Bogosort should have a reasonable runtime, since there are only 5! == 120 possible permutations in your data. Have you profiled your algorithm to find out whether this is a bottleneck? 
",3,2972146
2976283,"
Use a somewhat nasty set of ifs for the fastest sort of 5 items, or if you want a sort that is just a little bit slower, but much less of a headache, you can use a sorting network. Use this site with the number of inputs equal to five to get an optimized sorting network. It even shows how you can do some parts in parallel though that seems a bit excessive for only 5 inputs. It will require 9 comparisons which is quite good. You will implement the sorting network with a set of ifs as well, but the difference between the somewhat nasty set of ifs, which I mentioned at the beginning, which truly optimal and an optimal sorting network is the number of swaps: the sorting network doesn't minimize the number of swaps. 
",2,2972146
2972245,"
If you're really certain (that is, you have measured) that this is a bottleneck and needs to be optimized, and just any sort algorithm from STL won't be fast enough (and you've measured that too), then perhaps you know something more that you can use? Standard sorting algorithms are general, and will work (reasonably well) for any data set: different numbers of elements, different ranges of values, and so on. If you really need performance, the trick is often to use additional information to make a more specialized algorithm.
Here you have said one thing: there are 0-5 elements to sort, As Nick D said in his answer, perhaps this will make it faster to use hard-coded if statements instead of the typical loops or recursion of general sorting algorithms.
But perhaps there is more? For example, are there any restrictions on the float values that can occur?
",1,2972146
4419080,"
Here is a routine for sorting 4 elements in optimal number of comparisons. I would have posted for 5 elements, but stackoverflow limits posts to 30000 characters.
Whether this is actually the fastest depends on how much pressure your CPU instruction cache can take, so benchmark within real program!
",0,2972146
2962050,"
C++ provides lots of options for sorting, from the std::sort algorithm to sorted containers like std::map and std::set. You should always try to use these as your first solution, and only try things like ""optimised bubble sorts"" as  a last resort.
",3,2961996
2962053,"
I implemented this a while ago. Also, I think you mean ordering a vector B in the same way as the 
sorted values of A.
Index contains the sorting order of data.
",1,2961996
2952636,"
Simple approach: insertion sort on every insert. Since your elements are not aligned in memory I'm guessing linked list. If so, then you could transform it into a linked list with jumps to the 10th element, the 100th and so on. This is kind of similar to the next suggestion.
Or you reorganize your container structure into a binary tree (or what every tree you like, B, B*, red-black, ...) and insert elements like you would insert them into a search tree.
",1,2952407
2952438,"
Running a quicksort on each insertion is enormously inefficient. Doing a binary search and insert operation would likely be orders of magnitude faster. Using a binary search tree instead of a linear array would reduce the insert cost.
Edit: I missed that you were doing sort on extraction, not insert. Regardless, keeping things sorted amortizes sorting time over each insert, which almost has to be a win, unless you have a lot of inserts for each extraction.
If you want to keep the sort on-extract methodology, then maybe switch to merge sort, or another sort that has good performance for mostly-sorted data.
",2,2952407
2952468,"
I think the best approach in your case would be changing your data structure to something logarithmic and rethinking your architecture. Because the bottleneck of your application is not that sorting thing, but the question why do you have to sort everything on each insert  and try to compensate that by adding on-demand sort?.
Another thing you could try (that is based on your current implementation) is implementing an external pointer - something mapping table / function and sort those second keys, but I actually doubt it would benefit in this case.
",1,2952407
2952656,"
Instead of the array of the pointers you may consider an array of structs which consist of both a pointer to your object and the sort criteria. That is:
Instead of
You may do this:
You may also remove the m_SomeField field from your struct, if you only access your object via this array.
By such in order to sort your array you won't need to dereference m_pObj every iteration. Hence you'll utilize the cache.
Of course you must keep the m_SortCriteria always synchronized with m_SomeField of the object (in case you're editing it).
",1,2952407
2952639,"
As you mention, you're going to have to do some profiling to determine if this is a bottleneck and if other approaches provide any relief.
Alternatives to using an array are std::set or std::multiset which are normally implemented as R-B binary trees, and so have good performance for most applications.  You're going to have to weigh using them against the frequency of the sort-when-searched pattern you implemented.
In either case, I wouldn't recommend rolling-your-own sort or search unless you're interested in learning more about how it's done.
",1,2952407
2966907,"
I would think that sorting on insertion would be better. We are talking O(log N) comparisons here, so say ceil( O(log N) ) + 1 retrieval of the data to sort with.
For 2000, it amounts to: 8
What's great about this is that you can buffer the data of the element to be inserted, that's how you only have 8 function calls to actually insert.
You may wish to look at some inlining, but do profile before you're sure THIS is the tight spot.
",0,2952407
2906884,"
Use a std::map. In the incredibly unlikely event that it ever shows up in your profiling, you could maybe think about changing to something more exotic. Memory overhead for 50k users will be around a megabyte or two.
I doubt that iterating over a map with 50k entries every 5-10 seconds, to find the top scores, will introduce significant overhead. If it does, though, either use a Boost multi-index container, or maintain a separate structure for the hi-scores (a heap, or just an array of pointers to the current top 20, in order). Just with an array / vector of 20, the code to increment a score might look something like this (assuming scores only go up, not down):
And the code to get the hi-scores:
If your ""auto-increment"" and ""no delete"" policies are fixed forever (i.e. you will never delete users from the DB), and therefore user ids truly are a contiguous range from 0 to the limit, then you should just use a std::vector instead of a std::map.
",1,2906850
2906930,"
You might be interested in Fibonacci Heap. This has O(1) (amortized) increaseKey and findMax.
For more info on Heap in general refer: Heap Data Structure, especially the table which compares different heaps.
An implementation of Fibonacci Heap can be found here which you can perhaps use/get inspired from: http://resnet.uoregon.edu/~gurney_j/jmpc/fib.html
",1,2906850
2907414,"
First of all, given that you have a Key/Value scenario, you should probably use an Associative Container.
If you are using plain old C++ and do not have Boost available, follow Steve Jessops's suggestion and simply use a std::map, if you have either C++0x or Boost, you'd better use a hash_map or unordered_map: it just matches your requirements better (you don't need to order the players by id after all, you just want to find them quickly) and will probably be faster given the number of players.
For managing the top20 you have 2 choices:

You could use the Boost.MultiIndex library to create one unique container that both offers fast lookup on ID (using a hash map) and an ordered index on the score... however it's a bit of a waste to order all players when you only need 20 of them
You can simply manages a separate structure, like a vector of pointers to users, and each time you modify the score of a user check it should replace a user in the vector

The last solution, though simple, assumes that a player cannot lose points... it's much more difficult if that may happen.
Note (1): using a set may seem a good idea however a set presumes that the elements do not change and it is not the case. It could work if we were very careful:

remove the user from the set before changing the score
putting the user back in once it has changed
optionally popping the last elements if there are too many of them

",0,2906850
2907021,"
Your code is a mess.  There are a number of problems both semantic and logical, but fundamentaly the logic that decides where to insert new nodes is the most flawed.  Change it to this (note my new code in the else block):
BUT the fact that you had enough difficulty writing this code that you would ask SO for help in fixing it illustrates an important point:  the best code is code that you never have to write.  You have written both a linked list type structure (bare bones tho it may be) and a sorting algorithm.  Both are flawed, and both have working, tested and efficient versions available as part of the standard C++ libraries.  You should be using them.  Use strings instead of char*s.  Use vectors instead of your linked list.  Use sort instead of your hand rolled sorting algorithm.  Taken together, all your code can be replaced by this:
Why hand-roll a bunch of stuff and expose yourself to countless defects when you can use tools that already work and do what you want?
",4,2906478
2906502,"
Perhaps I'm not answering your question, but why aren't you using the STL?  It will do the sorting for you; you shouldn't have to write sorting routines like this these days.
",4,2906478
2906515,"
Some tips:

use strcmp to compare strings
prefer using pointers to char inside your struct. This allows you to blindly assign them without copying and it won't waste space inside your struct
if you really need to copy them use strdup to allocate new strings
keep track of two current elements instead that just one, this will avoid counting how many you got so far and go through the list twice when you found right position

",1,2906478
2906632,"
You can make you life here a lot easier if you implement a simple insert sort using STL vector (vector has a member 'insert'). 
that code will look much cleaner too :)
lookup cplusplus.com for examples there of, you will find it helpful. 
",1,2906478
2907064,"
As others have already suggested, the STL makes life a lot easier. It seems all you need is a sorted container of strings:
",1,2906478
2900890,"
Use std::sort with a non-default comparator:
",18,2900862
2900899,"
Assuming the following:
You can sort it like so:
Note that the second parameter (last) is pointing to one past the end of your 4-element array; this is the correct way to pass the end of your array to STL algorithms. From there you can then call:
To reverse the contents of the array. You can also write a custom comparator for the sort routine, but I'd consider that a step above beginner-level STL; it's up to you.
",1,2900862
2819287,"
std::pair uses lexicographic comparison: It will compare based on the first element. If the values of the first elements are equal, it will then compare based on the second element.
The definition in the C++03 standard (section 20.2.2) is:
",49,2819245
2819309,"
According to my copy of the C++0x standard, section 20.3.3.26, std::pair has an operator< defined such that for two pairs x and y, it returns
I'm not certain if this is part of the 2003 standard as well.  I should also note that this won't compile if the elements themselves are not LessThanComparable.
",7,2819245
2819307,"
Documentation from SGI

The comparison operator. It uses lexicographic comparison: the return value is true if the first element of x is less than the first element of y, and false if the first element of y is less than the first element of x. If neither of these is the case, then operator< returns the result of comparing the second elements of x and y. This operator may only be used if both T1 and T2 are LessThanComparable. This is a global function, not a member function. 

Looks like it's actually a combination of both elements. 
",1,2819245
2819311,"
Yes.  operator<() is defined for std::pair<T1, T2>, assuming that both T1 and T2 are themselves comparable.  
",0,2819245
2808241,"
Make Sorter::sortByNumber static.  Since it doesn't reference any object members, you won't need to change anything else.
You should also use const references as sortByNumber should not be modifying the objects.
",5,2808216
2808411,"
Unless you have a really good reason to do otherwise, just define operator< for the type of items you're sorting, and be done with it:
The way you're writing your sorter class depends on knowing a lot about the internals of the D class, to the point that they're practically a single class (e.g., it looks like neither can do much of anything without the other).
At a guess, your sorter may be a somewhat stripped-down version of your real code. The SortByNumber makes it sound like the original code might support a number of different kinds of keys, something like:
and you'd want to be able to sort D objects by name, height, or weight. In a case like that, the comparisons are really still related to the D class, so I'd probably put them into a common namespace:
Then sorting would look something like:
Note that this does not use free functions. For this kind of purpose, a functor is generally preferable. I've also used a namespace to show the association between the object being sorted and the different ways of sorting it. You could make them nested classes instead, but I'd generally prefer the common namespace (keep coupling as loose as reasonable).
In any case, I would not give access to the raw data (even read-only access) via the object's public interface if it could be avoided (and in this case, it can be).
",3,2808216
2808326,"
I see no reason for sortByNumber() to be a member function. When it's a member function it gains access to things it doesn't need (and therefore shouldn't have access to). Either extract the method and refactor it into a function object:
or make it a free function. Given the choice you should prefer a function object, because that makes it possible for the compiler to inline the code if it so chooses. Then, you can sort like so:
That said, you can get the code to compile as is like so, with boost::bind():
You will need the boost libraries for that to work, and you will need to #include <boost/bind.hpp>.
",2,2808216
2808316,"
I don't see any reason to make sortByNumber as a member function of class Sorter. You can do the sorting much more easily avoiding all the ugly bind code if you make it a free function. Also, you should use const wherever it is applicable in the code. Following is the example of doing it using free function:
First change the   int getNumber()  to const function as int getNumber() const;
Then write your free function sortByNumber again taking parameters by const reference.
 bool sortByNumber(const D& d1, const D& d2);
You can call sort as :
std::sort(vec_D.begin(), vec_D.end(), sortByNumber);
",1,2808216
2803150,"
This is C++, not C. Sorting an array of strings is easy.
",41,2803071
2803094,"
std::qsort is inherited from the standard C library. It will not work.
You need to use std::sort for sorting strings.
Specifically, cast std::string to void* and then to char* is undefined and won't work.
",9,2803071
2907145,"
algorithm sort in CPP has the same complexity as qsort:
",5,2803071
14869307,"
You can use boost::sort, like this:
If you want use find use boost::find, like this:
See 2 useful functions (m_stringarray should be member of ClassA):
",1,2803071
52626121,"

Here is C++ another way to sort array of string without using <vector>.

",1,2803071
23770436,"
As many here have stated, you could use std::sort to sort, but what is going to happen when you, for instance, want to sort from z-a? This code may be useful
If you want to reverse the order of sorting just modify the sign in the cmp function.
",0,2803071
2800168,"
Note that this is probably not a bubble sort.  
",2,2800126
2800156,"
Don't bubble sort - point number 1.
Point number two:
Compare the first character of each sub array (i.e. array[x][0]) if it needs to be shifted then shift all characters in sub-array x using a while loop...or by saving the sub-array and shifting it like that...
",0,2800126
2800227,"
C++ doesn't support copying or comparing C-style arrays, but it does support such operations on very thinly-wrapped C-style arrays. Try boost::array, which is the same as tr1::array and std::array in C++0x.
Or, roll your own:
If your compiler doesn't insanely add padding to the above structure, you can safely reinterpret_cast a C-style array an an array:
",0,2800126
2785988,"
most likely reason it fails, is because char = 453  does not produce 453 but rather different number, depending what char is (signed versus unsigned).  your immediate solution would be to use numerical_limits, http://www.cplusplus.com/reference/std/limits/numeric_limits/
you may also need to think about design, because char has small range, you are likely to overflow often when adding two chars.
",2,2785969
2786023,"
The maximum value of any type is std::numeric_limits<T>::max(). It's defined in <limits>.
Also, consider a redesign. This is not a good algorithm. And I would make sure I knew what I was doing before calling my sort function recursively.
",1,2785969
2786195,"
I haven't put too much time reading your algorithm, but as an alternative to std::numeric_limits, you can use the initial element in your array as the initial minimum value.  Then you don't have to worry about what happens if you call the function with a class that doesn't specialize std::numeric_limits, and thus can't report a maximum value.
",0,2785969
2784176,"
Is there any way to do with without writing a mini-parser?
Let someone else do that?
I'm using this implementation: http://www.davekoelle.com/alphanum.html, I've modified it to support wchar_t, too.
",5,2783814
2784255,"
It really depends what you mean by ""parser."" If you want to avoid writing a parser, I would think you should avail yourself of library functions.

Treat the string as a sequence of subsequences which are uniformly alphabetic, numeric, or ""other.""
Get the next alphanumeric sequence of each string using isalnum and backtrack-checking for + or - if it is a number. Use strtold in-place to find the end of a numeric subsequence.
If one is numeric and one is alphabetic, the string with the numeric subsequence comes first.
If one string has run out of characters, it comes first.
Use strcoll to compare alphabetic subsequences within the current locale.
Use strtold to compare numeric subsequences within the current locale.
Repeat until finished with one or both strings.
Break ties with strcmp.

This algorithm has something of a weakness in comparing numeric strings which exceed the precision of long double.
",2,2783814
2783991,"
Is there any way to do it without writing a mini parser? I would think the answer is no. But writing a parser isn't that tough. I had to do this a while ago to sort our company's stock numbers. Basically just scan the number and turn it into an array. Check the ""type"" of every character: alpha, number, maybe you have others you need to deal with special. Like I had to treat hyphens special because we wanted A-B-C to sort before AB-A. Then start peeling off characters. As long as they are the same type as the first character, they go into the same bucket. Once the type changes, you start putting them in a different bucket. Then you also need a compare function that compares bucket-by-bucket. When both buckets are alpha, you just do a normal alpha compare. When both are digits, convert both to integer and do an integer compare, or pad the shorter to the length of the longer or something equivalent. When they're different types, you'll need a rule for how those compare, like does A-A come before or after A-1 ?
It's not a trivial job and you have to come up with rules for all the odd cases that may arise, but I would think you could get it together in a few hours of work.
",0,2783814
2784157,"
Without any parsing, there's no way to compare human written numbers (high values first with leading zeroes stripped) and normal characters as part of the same string.
The parsing doesn't need to be terribly complex though. A simple hash table to deal with things like case sensitivity and stripping special characters ('A'='a'=1,'B'='b'='2,... or 'A'=1,'a'=2,'B'=3,..., '-'=0(strip)), remap your string to an array of the hashed values, then truncate number cases (if a number is encountered and the last character was a number, multiply the last number by ten and add the current value to it).
From there, sort as normal.
",0,2783814
2761075,"
In your design, you must have a variable that maintains the size of the array.  This value will be adjusted as items are added or removed.  The C++ language has no facilities for obtaining the size of an array variable.  
Also, prefer to use std::string instead of char *.  If your instructor says to use char *, then provide it as a parameter to your functions, but convert to std::string inside functions and classes.  This will make your life a lot easier.  
Don't implement your own sort algorithms.  Prefer to use std::sort and different compare functions.  The std::sort algorithm has been tested and will save you time and effort.  
Implement the Visitor design pattern.  This will allow you to access your tables in different ways without writing new methods in the table class.  For example, with a Visitor base class, you can derive classes for reading from files, writing to files and displaying content without changing the table class.  
Lastly, don't use system(""pause"") which may not be portable.  Instead, prefer cin.ignore which can be found in std::istream::ignore.
",2,2760840
2760983,"
Unless you have some sort of terminator to the array, there is no easy way to get the size of an array pointed to by T. 
You would have to do a loop through the array pointed to by T and count up elements until you find a terminator. (E.G. '\0' for char *)
",0,2760840
2758100,"
Overload less than operator, then sort. This is an example I found off the web...
Source: here
",74,2758080
2758095,"
where, pred() is a function object defining the order on objects of myclass. Alternatively, you can define myclass::operator<.
For example, you can pass a lambda:
Or if you're stuck with C++03, the function object approach (v is the member on which you want to sort):
",109,2758080
2758223,"
A pointer-to-member allows you to write a single comparator, which can work with any data member of your class:
Output:
",15,2758080
2758352,"
Like explained in other answers you need to provide a comparison function. If
you would like to keep the definition of that function close to the sort
call (e.g. if it only makes sense for this sort) you can define it right there
with boost::lambda. Use boost::lambda::bind to call the member function.
To e.g. sort by member variable or function data1:
",9,2758080
24354831,"
this is my approach to solve this generally. It extends the answer from Steve Jessop by removing the requirement to set template arguments explicitly and adding the option to also use functoins and pointers to methods (getters)
",2,2758080
2741852,"
Replace return 0 by the same comparison algo on this.y and obj.y.
By the way, reassigning to tmp is unnecessary here. The optimized picture can look like:
",6,2741846
2741911,"
BalusC provides the correct answer: basically you give priority to x over y. Here's a variant written using nested ternary operators that makes the priority clear.
Another way to do this, if you don't want to write a custom Comparator<T> for every priority scheme, is to do multiple sort using a stable algorithm.
If you want to order by x (primary), and then y (secondary), then:

Sort on y first (!!!)
Then sort on x using a stable sort

This is asymptotically still O(N log N) but of course you're doing multiple phases. It's convenient when you have many sorting criterias. Rather than writing the complex code, just do the multiple phase (and only optimize if/when proven necessary).
So if you have sorting keys k1, k2, k3, ..., kM, in that order of priority, you do:

Sort on kM
Stable sort on kM-1
...
Stable sort on k1
DONE!

Note that Collections.sort is stable.

This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort.

",2,2741846
2727902,"
sort expects a function that returns bool, which is true iff the lhs precedes the rhs:
Also note the change to const Book& parameters, to avoid copying.
",11,2727890
2717489,"
As others have mentioned, it needs a boolean return type. Here's an example which works:
[Edit] Updated the code above to make it a little simpler. I'm not suggesting it's nice code, but without know more about the OPs real implementation, it's difficult to give a better example!
",0,2717297
2717321,"
std::sort takes a comparator that accepts value of the type held in the collection and returns bool. It should generally implement some notion of <. E.g., assuming your distanceList elements have collections of integers (I assume they don't, but for the sake of the example):
And of course you only need to supply a comparator if there isn't already a < operator that does the right thing for your scenario.
",4,2717297
2717322,"
It should be a boolean method (sort uses operator <()  by default to compare values)
",1,2717297
2717457,"
The comparison function you've provided has the signature of the one needed by qsort, which is the sorting function that C provided before C++ came along.  sort requires a completely different function.
For example if your declaration of distanceList is std::vector<DistanceNode> your function would look like:
Notice that sorting a std::list with the standard sort algorithm isn't efficient, which is why list supplies its own sort member function.
",1,2717297
2717323,"
First, the return type should be bool. Actually the requirement is only that the return type be assignable to bool, which int is. But the fact that you're returning int suggests that you might have written a three-way comparator instead of the strict weak ordering required by std::sort.
Your CompareIt function takes two void* pointers as parameters. Is distanceList.at(q) a vector<void*> (or vector of something convertible to void*)? If not, then the comparator inputs aren't right either. Using void* with algorithms also suggests that you're doing something wrong, because much of the point of generic programming is that you don't need opaque pointers that later get cast back to their original type.
",0,2717297
2714523,"
STL functors are required to be monomorphic because STL functors are passed by value.
If you need polymorphic behavior, you need to wrap that functionality in a monomorphic class:
i.e.
",5,2714489
2714518,"
You should use std::bind as Comparator::compare is instance method, thus it needs a Comparator object as parameter.
Something like that:
",1,2714489
5103744,"
Make your own comparator, that will work with pointers and then use qSort: http://qt-project.org/doc/qt-5.1/qtcore/qtalgorithms.html#qSort-3
",9,5103682
5104280,"
A general solution to the problem would be to make a generic less-than function object that simply forwards to the pointed-to-type's less-than operator. Something like:
You could then do:
",13,5103682
38936796,"
In C++11 you can also use a lambda like this:
",8,5103682
5102174,"
",14,5101997
5102035,"
",21,5101997
5102322,"
Use a structure that maintains ordering: std::multiset
Invocation:
(Note: the number of arguments is not constrained)
",2,5101997
5102144,"
It depends on your requirements. If you just want to sort them, and speed is only of moderate concern, an insertion sort would be fine for such a small n-value (10). Quick to implement (from scratch), and suitable for small set sizes.
",0,5101997
35233171,"
",0,5101997
5102020,"
You can write something yourself, but really should use qsort function.
",-7,5101997
5071340,"
I would store these values in two parallel structures.  First, have an array of the double values, each of which stores a pointer.  Next, store all the strings in a hash table along with an auxiliary integer.  The idea is that the pointers in the array point to the nodes in the hash table or trie holding the string associated with the double, while the integer value with each string stores the index of the double paired with that string.
To insert a string/double pair into this structure, you add the string to the hash table, append the double to the array, then store a pointer to the new string in the array and the index of the double in the hash table.  This has complexity O(k), where k is the length of the string.
To change a priority, look up the string in the hash table, then get the index of the double in the array.  You can then modify that element to change tye associated priority.  This also has complexity O(k).
To discard all but the top B key/value pairs, run a selection algorithm on the array to put the top B elements in one part of the array and the remaining C elements in the other.  Whenever you perform a swap, follow the pointers out of the array and into the hash table and update the indices of the elements you just swapped.  Finally, iterate across the last C elements of the array, follow their pointers back into the hash table, and remove the elements they point at from the table.  This takes expected O(n) time to do the selection step, or worst-case O(n) time using the median-of-medians algorithm, followed by O(n) time to remove the elements from the hash table, for an expected runtime of O(n), where n is the number of elements in the structure.
To summarize, this gives you O(k) insertion and lookup of any string, where k is the string length, and O(n) retaining of the best elements, where n is the total number of elements. 
",1,5071141
5071394,"
Well, I think you will be fine just using a std::vector<Item> and doing a std::nth_element (on the score) once at end of iteration. E.g. if you want to keep 10000 items, do like this:
Actually, if you do it like this, updating values (by linear search and string comparison) will probably be slower than sorting. You can speed up the comparisons by putting a string hash into your Item instead of the pure strings.
If you want even faster updating: Before updating, sort items on string hash. Then you can do a binary search instead of linear search to find the item you want to update.
",1,5071141
5058751,"
The algorithm you are looking for is usually named ""merging"". Basically you sort the two data sets and then look at data in pairs: if the keys are equal then you process and output the pair, otherwise you process and advance only the smallest one.
You must also handle the case where one of the two lists ends before the other (this can be avoided by using special flag values that are guaranteed to be higher than any value you need to process).
The following is pseudocode for merging

Sort vector1
Sort vector2
Set index1 = index2 = 0;
Loop until both index1 >= vector1.size() and index2 >= vector2.size() (in other words until both vectors are exhausted)
If index1 == vector1.size() (i.e. if vector1 has been processed) then output vector2[index2++]
Otherwise if index2 == vector2.size() (i.e. if vector2 has been processed) then output vector1[index1++]
Otherwise if vector1[index1] == vector2[index2] output merged data and increment both index1 and index2
Otherwise if vector1[index1] < vector2[index2] output vector1[index1++]
Otherwise output vector2[index2++]

However in C++ you can implement a much easier to write solution that is probably still fast enough (warning: untested code!):
The idea is to just build two maps data1 and data2 from name to values, and at the same time collecting all keys that are appearing in a std::set of keys named allkeys (adding the same name to a set multiple times does nothing).
After the collection phase this set can then be iterated to find all the names that have been observed and for each name the value can be retrieved from data1 and data2 maps (std::map<std::string, int> will return 0 when looking for the value of a name that has not been added to the map).
Technically this is sort of overkilling (uses three balanced trees to do the processing that would have required just two sort operations) but is less code and probably acceptable anyway.
",4,5058443
5058781,"
6502's solution looks fine at first glance. You should probably use std::merge for the merging part though.
EDIt:
I forgot to mention that there is now also a multiway_merge extension of the STL available  in the GNU version of the STL. It is a part of the parallel mode, so it resides in the namespace __gnu_parallel. If you need to do multiway merging, it will be very hard to come up with something as fast or simple to use as this.
",3,5058443
5058555,"
A quick way which comes to mind is to use a map<pair<string, int>, int> and for each value store it in the map with the right key. (For example (Tom, 2) in the first values set will be under the key (Tom, 1) with value 2)
Once the map is ready iterate over it and build whatever data structure you want (Assuming the map is not enough for you).
",1,5058443
5058552,"
I think you need to alter how you store this data.
It looks like you're saying each number is logically associated with the name in the same position:  Jim = 1, Mary = 3, etc.
If so, and you want to stick with a vector of some kind, you could redo your data structure like so:
You'll need to write your own operator< which returns based on the sort order of the underlying names.  However, as Nawaz points out, a map would be a better way to represent the associated nature of the data.
",0,5058443
5056905,"
Not an expert here but...
If I understand correctly, what you describe as phases are the number of passes your algorithm will make over the input, right? In this case, a running time approximation would be the number of passes (2 in your case) * the time necessary to read and write the whole input to the external device.
When evaluating complexity of such algorithms it is hard to put it in usual running time terms. There are many aspects that could influence the result (sequential/non-sequential access, technology, etc). The common approach is to provide complexity in terms of passes, which accounts from the number of devices used, the number of items in the input, and the number of items that can fit in memory.
The point is that the sorting algorithm is dominated by the IO operations. Internal quick sort should be ok (although its quadratic worst case).
Also, I'm not sure if you counted the initial distribution. This is also a pass.
",0,5056487
5038025,"
How expensive is Element's copy constructor?  Does it do a deep copy of the contained Record object?  Sorting a vector<Element> will require many copies of Element objects unless swap is overloaded properly.  I'm not sure what the rules are about whether sort must use swap and if it must use a user's overloaded version of swap; http://accu.org/index.php/journals/466 has some information about that.  Sorting vector<Element*> will only be copying pointers around, which is likely to be cheaper.  C++0x changes this, assuming Element has an efficient move constructor and move assignment operator.
",2,5037978
5038047,"
It depends on how copying of Elements is done. As you've shown it above, an Element contains a pointer to a Record, but doesn't define a copy constructor. If that's correct, copying Element objects should be cheap and quick, so you'd gain little or nothing by storing pointers to Elements.
At the same time, I have to point out that doing shallow copies can easily introduce errors. When/if you change Element to do deep copying, you might gain a lot more from storing and sorting pointers instead of Element objects (but it'll depend on how expensive it is to copy a Record).
",0,5037978
5007714,"
Whatever you're going to do, given your conditions I'd make sure you draw up a big pile of tests cases (eg get a few datasets and shuffle them a few thousand times) as I suspect it'd be easy to choose a sort that fails to meet your requirements.
The ""do not care"" is tricky as most sort algorithms depend on a strict ordering of the sort value - if A is 'less than or equal to' B, and B is 'less than or equal to' C, then it assumes that A is less than or equal to C -- in your case if A 'doesn't care' about B but does care about C, but B is less than C, then what do you return for the A-B comparison to ensure A will be compared to C?
For this reason, and it being small vectors, I'd recommend NOT using any of the built in methods as I think you'll get the wrong answers, instead I'd build a custom insertion sort.
Start with an empty target vector, insert first item, then for each subsequent item scan the array looking for the bounds of where it can be inserted (ie ignoring the 'do not cares', find the last item it must go after and the first it must go before) and insert it in the middle of that gap, moving everything else along the target vector (ie it grows by one entry each time).
[If the comparison operation is particularly expensive, you might do better to start in the middle and scan in one direction until you hit one bound, then choose whether the other bound is found moving from that bound, or the mid point... this would probably reduce the number of comparisons, but from reading what you say about your requirements you couldn't, say, use a binary search to find the right place to insert each entry]
Yes, this is basically O(n^2), but for a small array this shouldn't matter, and you can prove that the answers are right. You can then see if any other sorts do better, but unless you can return a proper ordering for any given pair then you'll get weird results...
",3,5007523
5007673,"
You can't make the sorting with ""don't care"", it is likely to mess with the order of elemets. Example:
So even with the don't care between A and B, B has to be greater than A, or one of those will be false: B > C or A < C. If it will never happen, then you need to treat them as equals instead of the don't care.
",2,5007523
5007906,"
What you have there is a ""partial order"".
If you have an easy way to figure out the objects where the order is not ""don't care"" for a given objects, you can tackle this with basic topological sorting. 
If you have a lot of ""don't care""s (i.e. if you only have a sub-quadratic number of edges in your partial ordering graph), this will be a lot faster than ordinary sorting - however, if you don't the algorithm will be quadratic!
",1,5007523
5010037,"
I believe a selection sort will work without modification, if you treat the ""do-not-care"" result as equal.  Of course, the performance leaves something to be desired.
",0,5007523
4987490,"
Be carreful when looping through your array. The loop has to start from 0 to size-1.
So instead of using less-than-or-equal:
You should use less-than:
",7,4987477
4987489,"
The array size is declared to be 6 elements and then 7 elements [0...6] are placed in it.
Redeclare array size to be 7 and then change all the <= to < in the loops.
",3,4987477
4916524,"
Unless you iterate through the structure from ""begin"" to ""end"", you can't know if it is already sorted, so the best you can do it is in O(n).
I would go for the first choice, the already_sorted one.
",3,4916485
4916528,"
I don't think you can do this any better than O(n) checking if the array came back in a different order than which it started.  Hijacking the comparator to see if things are out if order isn't guaranteed to work, since in theory the sort function can do whatever comparisons it likes without necessarily moving anything.  Moreover, tracking whether any swaps were performed doesn't necessarily tell you if the order changed, since the sort could also move things around and restore them to the same order at the end of the sort (think heapsort, for example).
",3,4916485
4916535,"
Do you consider a range modified if two equal values were exchanged? In that case the already_sorted variant won't work.
Otherwise it should be the fastest way.
",1,4916485
4916815,"
If the objects being sorted are of class type, you could introduce a subobject with an operator = overload that would be called by std::swap. However, that could in theory still allow false positives, if objects were swapped and then swapped back.
Probably you should stick with already_sorted until you're sure that it is taking a significant amount of the total execution time.
",1,4916485
4906582,"
Yes, the bin indeed can be empty.  There's a subtle but important difference between the bin being empty and the bin existing.  You are correct that the bin is a member of the array, and so there exists a bin in position i for any i that's in bounds in the array.  However, that bin doesn't necessarily have to have anything in it; it could have nothing in it at all if none of the elements in the input list happen to fall into that bin.
There's a good physical analogy to this problem if you have a row of glasses set out on a table and start filling some of them with water.  All the glasses in a row exist and are well-defined, but they don't all have to be empty, especially if you start pouring them out (as you're doing in this bin sort example above).
",1,4905582
4892701,"
Use a comparison function:
and then use std::sort in the header #include <algorithm>:
",72,4892680
4892699,"
Just make a comparison function/functor:
Or provide an bool operator<(const data& a) const in your data class:
or non-member as Fred said:
and just call std::sort():
",30,4892680
4892703,"
Yes:  you can sort using a custom comparison function:
my_custom_comparison needs to be a function or a class with an operator() overload (a functor) that takes two data objects and returns a bool indicating whether the first is ordered prior to the second (i.e., first < second).  Alternatively, you can overload operator< for your class type data; operator< is the default ordering used by std::sort.
Either way, the comparison function must yield a strict weak ordering of the elements.
",6,4892680
4892733,"
As others have mentioned, you could use a comparison function, but you can also overload the < operator and the default less<T> functor will work as well:
Then it's just:
Edit
As James McNellis pointed out, sort does not actually use the less<T> functor by default. However, the rest of the statement that the less<T> functor will work as well is still correct, which means that if you wanted to put struct datas into a std::map or std::set this would still work, but the other answers which provide a comparison function would need additional code to work with either.
",1,4892680
4890733,"
Your comparator doesn't implement strict weak ordering. For example two items A and B with equal col_Sensitivity and col_Precision, both A < B and B < A are true. As you can imagine, trying to sort with a sort function that doesn't actually provide an ordering can produce undefined behavior. 
Thanks to (and quoting) @David Thornley for the standard reference:

Standard, part of 25.3/3: ""For the
  algorithms to work correctly, comp has
  to induce a strict weak ordering on
  the values."" This means that not
  having a strict weak ordering is
  undefined (the Standard says nothing).

I think in this case you just want to remove all the epsilon checks completely:
",4,4890510
4890665,"
The STL sort can corrupt data if the comparison operator can produce inconsistent results, such as x < y < z < x.
Your comparison operator can produce inconsistent results.
",4,4890510
4843942,"
There is a special class of algorithms for this called external sorting. There is a variant of merge sort that is an external sorting algorithm (just google for merge sort tape).
But if you're on Unix, it's probably easier to run the sort command in a separate process.
BTW. Opening files that are bigger than 2 GB requires large file support. Depending on your operating system and your libraries, you need to define a macro or call other file handling functions.
",5,4843910
4818496,"
Why don't you simply write:
It's simpler interface than what you're doing in your post.
",7,4818424
4818513,"
I can't make much sense of your sample code, but if you want to insert items into a vector in order, you usually want to use push_back. For a trivial example:
The numbers should now be in order, like: (1 2 3 4 5 6 7 8 9 10).
",2,4818424
4818595,"
I really don't think you want to do a map that uses a vector as a key, do you? This smells like you have more significant design problems.
As for adding stuff to vectors in a known (and presered order), use push_back().
",0,4818424
4806936,"
No, no, no. It's not supposed to work that way at all. Your current assignment operator destroys the object it's called on, then calls itself (oh hey, infinite recursion) on a destroyed object (oh hey, undefined behaviour). You are not supposed to destroy the existing object. At all. And this code *this = s does not invoke any constructor at all, it invokes the assignment operator- which is what you're just defining. A copy constructor call would look like new (this) Student_info(s);. This is a known pattern and it's terrible in many, many ways. If you have a book that's recommending it, throw it in the bin.
The assignment operator is supposed to copy the data from the right-hand-side into the left-hand-side. The easiest way to do that in most cases is just to copy each data member. The semantics of this operator do not involve destroying anything. Anyone using this operator has the right to expect that there is no destruction of any Student_info objects going on.
Just call the member's existing assignment operators and then implement whatever additional logic you need.
",6,4806827
4806933,"
this is endless recursion. it's not copy-constructor, it's assignment operator
",2,4806827
4807204,"

Getters, setters, and other member functions ommited for brevity

If you have public getters and setters which are just boilerplate, consider marking the corresponding data members as public instead.
",1,4806827
4775313,"
I would imagine that STL will do what you want nicely.  Re-writing your own sort routines and containers is likely to be error-prone, and slow.  So only worry about if you find it's a bottleneck.
",2,4775203
4775619,"
In general with large objects it can be faster to sort an array of pointers/indices of the objects rather than the objects. Or sort an array of nodes, where each node contains a pointer/index of the object and the object's sort key (in this case the key is one byte). To do this in C++ you can just supply a suitable comparator to std::sort or std::stable_sort. Then if you need the original objects in order, as opposed to just needing to know the correct order, finally copy the objects into a new array.
Copying 128 bytes is almost certainly much slower than performing a byte comparison, even with an extra indirection. So for optimal performance it's the moves you need to look at, not the comparisons, and dealing in pointers is one way to avoid most of the moving.
You could build your run-length encoding as you perform the copy at the end.
Of course it might be possible to go even faster with some custom sorting algorithm which makes special use of the numbers in your case (64, ""around 128"", and 1). But even simple questions like ""which is fastest - introsort, heap sort or merge sort"" are generally impossible to answer without writing and running the code.
",2,4775203
4775573,"
The sort would not be slower because you will be sorting pointer or references to the structs and not the actual struct in memory.
",1,4775203
4775309,"
The fact that your keys are integers, and there really aren't a lot of them,
odds are the Bucket Sort, with a bucket size of 1, would be very applicable.
",0,4775203
4772143,"
Here is an implementation of an odd-even merge sort network in C99 (sorry for the ""wrong"" language):
I timed it on my machine against insertion sort
For about 10 million sorts (exactly 250 times all the 40320 possible permutations), the sort network took 0.39 seconds while insertion sort took 0.88 seconds.  Seems to me both are fast enough. (The figures inlcude about 0.04 seconds for generating the permutations.)
",12,4770651
4770676,"
The fastest would be to simply write a lot of if statements to compare them to determine their exact order. That will remove the overhead that any sorting algoritm has.
",7,4770651
4770665,"
For only 8 integers and given that the range is much greater than 8, insertion sort is probably the best. Try it to start with, and if profiling indicates that it's not the bottleneck then leave it.
(Depending on many factors, the cutoff point at which quick-sort becomes better than insertion sort is usually between 5 and 10 items).
",5,4770651
4770710,"
The fastest way is a sorting network implemented in hardware. Barring that, the fastest way is determined only by measuring. I'd try

std::sort,
pigeonhole (bucket) sort with reuse of the buckets,
a bunch of if statements, and
insertion sort

in that order, because it's the easiest-to-hardest order (try to get insertion sort right the first time...) until you find something that's maintainable once the constant eight turns out to have the value nine.
Also, bubble sort, selection deserve and shell sort deserve notice. I've never actually implemented those because they have bad rep, but you could try them.
",5,4770651
14396415,"
Years later) for up to 32 inputs,
see the Sorting network generator.
For 8 inputs, it gives 19 swaps, like Sven Marnach's answer:
",3,4770651
4801330,"
I ran a library of sort algorithms against all permutations of {0, 429, 857, 1286, 1714, 2143, 2571, 3000}.
The fastest were:
For more on AddressSort see http://portal.acm.org/citation.cfm?id=320834
",2,4770651
4770920,"
The following citation from Bentley et al., Engineering a sort function could be interesting here:

Various improvements to insertion sort, including binary search, loop unrolling, and handling n=2 as a special case, were not helpful. The simplest code was the fastest.

(Emphasis mine.)
This suggests that plain insertion sort without fancy modifications would indeed be a good starting point. As Peter has noted, eight items is indeed a bit tricky because that lies squarely in the range which usually marks the cut-off between insertion sort and quicksort.
",1,4770651
4770685,"
A good source for comparing sorting algos is http://www.sorting-algorithms.com/.
Note that even the initial order status affect the results. But anyway for 8 integers even a plain bubble sort should do the job.
",0,4770651
4770712,"
For positive integers, the fastest sort is known as abacus sort- it's O(n)
http://en.wikipedia.org/wiki/Abacus_sort
If you only have a very few items, then it's unlikely that you will notice any performance difference from choosing any particular algorithm.
",0,4770651
4771240,"
For very small numbers of ints, bubble sort can be very fast.  Bubble sort with numerical comparisons can be written with a very low overhead and for small n, the actual speed differences between O(n log n) and O(n^2) washes out.
",0,4770651
4772243,"
Have you profiled your code to show that the sort is a bottleneck?  If it isn't a bottleneck, then speeding it up won't buy you much.  Sorting eight short integers is pretty fast.
In general, std::sort() will be faster than anything you can write, unless you are a real sorting guru.  
",0,4770651
9862665,"
For integers, you could try radix-sort. It's O(N).
",0,4770651
4770094,"
You don't/can't sort maps.  They are automatically sorted by key based on the optional third parameter to the template arguments, which is a function object class used to compare two elements to determine which should come first. (it should return true if the first should come before the second, false otherwise)
So you can use something like this:
But since map<int,int> is your value, and not your key, this won't exactly work for you.
",2,4770043
4770117,"
What you're looking for has been done in Boost with MultiIndex.  Here's a good tutorial from Boost on how you can use it to solve what you're asking of your data collection and their selection of examples.
Of course, using this collection object will probably change how you store the information too.  You'll be placing it within a struct.  However, if you want to treat your information like a database with a unique order by specification this is the only way I know how that's clean.
The other option is to create your own ordering operator while placing the items in a std::map.  Hence:
Honestly this way is a pain and invites a very easily overlooked logic fault.  Using Boost, most of the ""tricky"" stuff is taken care of for you.
",2,4770043
4769467,"
If you can change the structure of your Sorter class, you could make it a function object by defining operator () like this:
Then you can just pass an instance of your Sorter class to std::sort.
",4,4769420
4769484,"
Unfortunately, the standard library is a bit lacking in combinators for things like this. However, boost::lambda can do the job:
",0,4769420
4778864,"
If you have some control over the in-memory layout of the data, you might want to look at Judy arrays.
Or to put a simpler idea out there: a binary search always cuts the search space in half.  An optimal cut point can be found with interpolation (the cut point should NOT be the place where the key is expected to be, but the point which minimizes the statistical expectation of the search space for the next step).  This minimizes the number of steps but... not all steps have equal cost.  Hierarchical memories allow executing a number of tests in the same time as a single test, if locality can be maintained.  Since a binary search's first M steps only touch a maximum of 2**M unique elements, storing these together can yield a much better reduction of search space per-cacheline fetch (not per comparison), which is higher performance in the real world.
n-ary trees work on that basis, and then Judy arrays add a few less important optimizations.
Bottom line: even ""Random Access Memory"" (RAM) is faster when accessed sequentially than randomly.  A search algorithm should use that fact to its advantage.
",15,4753977
4867332,"
Benchmarked on Win32 Core2 Quad Q6600, gcc v4.3 msys. Compiling with g++ -O3, nothing fancy.
Observation - the asserts, timing and loop overhead is about 40%, so any gains listed below should be divided by 0.6 to get the actual improvement in the algorithms under test.
Simple answers:

On my machine replacing the int64_t with int for ""low"", ""high"" and ""mid"" in interpolationSearch gives a 20% to 40% speed up. This is the fastest easy method I could find. It is taking about 150 cycles per look-up on my machine (for the array size of 100000). That's roughly the same number of cycles as a cache miss. So in real applications, looking after your cache is probably going to be the biggest factor.
Replacing binarySearch's ""/2"" with a "">>1"" gives a 4% speed up.
Using STL's binary_search algorithm, on a vector containing the same data as ""arr"", is about the same speed as the hand coded binarySearch. Although on the smaller ""size""s STL is much slower - around 40%.

",9,4753977
4757235,"
I have an excessively complicated solution, which requires a specialized sorting function. The sort is slightly slower than a good quicksort, but all of my tests show that the search function is much faster than a binary or interpolation search. I called it a regression sort before I found out that the name was already taken, but didn't bother to think of a new name (ideas?).
There are three files to demonstrate.
The regression sort/search code:
And then there is the regular search functions:
And then I wrote a simple main to test out the different sorts.
Give it a try and tell me if it's faster for you. It's super complicated, so it's really easy to break it if you don't know what you are doing. Be careful about modifying it.
I compiled the main with g++ on ubuntu.
",4,4753977
4754102,"
Unless your data is known to have special properties, pure interpolation search has the risk of taking linear time. If you expect interpolation to help with most data but don't want it to hurt in the case of pathological data, I would use a (possibly weighted) average of the interpolated guess and the midpoint, ensuring a logarithmic bound on the run time.
",3,4753977
4783849,"
One way of approaching this is to use a space versus time trade-off.  There are any number of ways that could be done.  The extreme way would be to simply make an array with the max size being the max value of the sorted array.  Initialize each position with the index into sortedArray. Then the search would simply be O(1).  
The following version, however, might be a little more realistic and possibly be useful in the real world.  It uses a ""helper"" structure that is initialized on the first call.  It maps the search space down to a smaller space by dividing by a number that I pulled out of the air without much testing.  It stores the index of the lower bound for a group of values in sortedArray into the helper map.  The actual search divides the toFind number by the chosen divisor and extracts the narrowed bounds of sortedArray for a normal binary search.  
For example, if the sorted values range from 1 to 1000 and the divisor is 100, then the lookup array might contain 10 ""sections"".  To search for value 250, it would divide it by 100 to yield integer index position 250/100=2.  map[2] would contain the sortedArray index for values 200 and larger.  map[3] would have the index position of values 300 and larger thus providing a smaller bounding position for a normal binary search.  The rest of the function is then an exact copy of your binary search function.  
The initialization of the helper map might be more efficient by using a binary search to fill in the positions rather than a simple scan, but it is a one time cost so I didn't bother testing that.  This mechanism works well for the given test numbers which are evenly distributed.  As written, it would not be as good if the distribution was not even.  I think this method could be used with floating point search values too.  However, extrapolating it to generic search keys might be harder.  For example, I am unsure what the method would be for character data keys.  It would need some kind of O(1) lookup/hash that mapped to a specific array position to find the index bounds.  It's unclear to me at the moment what that function would be or if it exists.
I kludged the setup of the helper map in the following implementation pretty quickly.  It is not pretty and I'm not 100% sure it is correct in all cases but it does show the idea.  I ran it with a debug test to compare the results against your existing binarySearch function to be somewhat sure it works correctly. 
The following are example numbers:
Here is the quick-and-dirty implementation:
The helper structure needs to be initialized (and memory freed):
",3,4753977
16707107,"
Look first at the data and whether a big gain can be got by data specific method over a general method.
For large static sorted datasets, you can create an additional index to provide partial pigeon holing, based on the amount of memory you're willing to use.  e.g. say we create a 256x256 two dimensional array of ranges, which we populate with the start and end positions in the search array of elements with corresponding high order bytes.  When we come to search, we then use the high order bytes on the key to find the range / subset of the array we need to search.  If we did have ~ 20 comparisons on our binary search of 100,000 elements O(log2(n)) we're now down to ~4 comarisons for 16 elements, or O(log2 (n/15)).  The memory cost here is about 512k
Another method, again suited to data that doesn't change much, is to divide the data into arrays of commonly sought items and rarely sought items.  For example, if you leave your existing search in place running a wide number of real world cases over a protracted testing period, and log the details of the item being sought, you may well find that the distribution is very uneven, i.e. some values are sought far more regularly than others.  If this is the case, break your array into a much smaller array of commonly sought values and a larger remaining array, and search the smaller array first.  If the data is right (big if!), you can often achieve broadly similar improvements to the first solution without the memory cost.
There are many other data specific optimizations which score far better than trying to improve on tried, tested and far more widely used general solutions.
",3,4753977
4757024,"
Posting my current version before the question is closed (hopefully I will thus be able to ehance it later). For now it is worse than every other versions (if someone understand why my changes to the end of loop has this effect, comments are welcome).
",2,4753977
50671395,"
The implementation of the binary search that was used for comparisons can be improved.  The key idea is to ""normalize"" the range initially so that the target is always > a minimum and < than a maximum after the first step.  This increases the termination delta size.  It also has the effect of special casing targets that are less than the first element of the sorted array or greater than the last element of the sorted array.  Expect approximately a 15% improvement in search time.  Here is what the code might look like in C++.
",0,4753977
4708437,"
The Quick sort performs worst ie, at O(n^2) when all the values of the pivot chosen is either the largest or smallest of the taken set. Consider this example.
1 2 3 4 5
The pivot chosen say is 1, you will have 4 elements on the right side of the pivot and no elements on the left side. Applying this same logic recursively and the pivot chosen is 2, 3, 4, 5 respectively, we have attained a situation where this sort has performed at its worst possible time.
It has been recommended and proven that Quicksort performs well if the input is shuffled well. 
Moreover, selection of a sort usually depends on a clear knowledge about the input domain. For example, if the input is huge, then there is something called as external sort which may use external memory. If the input size is very small, we may go for a merge sort but not for medium and huge input sets since it uses extra memory. The main advantage of Quick sort is its ""in-place""ness meaning, no extra memory is being used for the input data. Its worst case time on paper is O(n^2) but still is widely preferred and used. My point here is, sorting algorithms can be changed based on the knowledge on the input set and its a matter of preference.
",7,4708419
4708489,"
To expand on what Bragboy said, instead of only running:
Run:
Where the definition of shuffle() could be:
Doing so will, likely, deal with the case of getting input which makes quicksort() slow.
",1,4708419
4716547,"
Hoare’s Quicksort algorithm chooses a random pivot. For reproducible results I'd suggest Scowen's modification which, among other things, chooses the middle item from the input. For this variant a sawtooth pattern with the pivot being the smallest appears to be the worst case input:
",0,4708419
4708160,"
std::clock() is not a viable timing clock. You should use a platform-specific higher resolution timer, like the Windows High Performance Timer. More than that, the way that you call clock() is that first, text is output to the console, which is included in the time. This definitely invalidates the test. In addition, make sure that you compiled with all optimizations.
Finally, I copied and pasted your code, and got 0.016 for qsort and 0.008 for std::sort.
",93,4708105
5434553,"
I am surprised that no one mentions caches.
In your code, you start by touching ary and *ary_copy* so they are resident in the cache at the time of qsort. During qsort, *ary_copy* might get evicted. At the time of std::sort, the elements would have to be fetched from memory or a larger (read slower) cache level. This will of course depend on your cache sizes.
Try to reverse the test, i.e., start by running std::sort.
As some people have pointed out; making the array larger will make the test more fair. The reason is that a large array is less likely to fit in cache.
",18,4708105
4708126,"
The two sorting algorithms, without optimizations enabled, should have comparable performance.  The reason that the C++ sort tends to appreciably beat qsort is that the compiler can inline the comparisons being made, since the compiler has type information about what function is being used to perform the comparison.  Did you run these tests with optimization enabled?  If not, try turning it on and running this test again.
",12,4708105
4708270,"
Another reason that qsort may perform much better than expected is that newer compilers can inline and optimize through the function pointer.
If the C header defines an inline implementation of qsort instead of implementing it inside of a library and the compiler supports indirect function inlining, then qsort can be just as fast as std::sort.
",10,4708105
4708281,"
On my machine adding some meat (making the array 10 million elements and moving it in the data section) and compiling with
I get as result
Be also careful about modern ""green"" CPUs that may be configured to run at a variable speed depending on the load of the system. When benchmarking this kind of behavior can drive you crazy (on my machine I've setup two small script normal and fast that I can use when making speed tests).
",4,4708105
35141789,"
Writing accurate benchmarks is difficult, so let's get Nonius to do it for us! Let's test qsort, std::sort with no inlining, and std::sort with inlining (the default) on a vector of a million random integers.
// sort.cpp
#define NONIUS_RUNNER
#include <nonius.h++>
#include <random>
#include <algorithm>

// qsort
int comp(const void* a, const void* b) {
    const int arg1 = *static_cast<const int*>(a);
    const int arg2 = *static_cast<const int*>(b);

    // we can't simply return a - b, because that might under/overflow
    return (arg1 > arg2) - (arg1 < arg2);
}

// std::sort with no inlining
struct compare_noinline {
    __attribute__((noinline)) bool operator()(const int a, const int b) {
        return a < b;
    }
};

// std::sort with inlining
struct compare {
    // the compiler will automatically inline this
    bool operator()(const int a, const int b) {
        return a < b;
    }
};

std::vector<int> gen_random_vector(const size_t size) {

    std::random_device seed;
    std::default_random_engine engine{seed()};
    std::uniform_int_distribution<int> dist{std::numeric_limits<int>::min(), std::numeric_limits<int>::max()};

    std::vector<int> vec;
    for (size_t i = 0; i < size; i += 1) {
        const int rand_int = dist(engine);
        vec.push_back(rand_int);
    }

    return vec;
}

// generate a vector of a million random integers
constexpr size_t size = 1'000'000;
static const std::vector<int> rand_vec = gen_random_vector(size);

NONIUS_BENCHMARK(""qsort"", [](nonius::chronometer meter) {

    // Nonius does multiple runs of the benchmark, and each one needs a new
    // copy of the original vector, otherwise we'd just be sorting the same
    // one over and over
    const size_t runs = static_cast<size_t>(meter.runs());
    std::vector<std::vector<int>> vectors{runs};
    std::fill(vectors.begin(), vectors.end(), rand_vec);

    meter.measure([&](const size_t run) {

        std::vector<int>& current_vec = vectors[run];

        std::qsort(current_vec.data(), current_vec.size(), sizeof(int), comp);

        return current_vec;
    });
});

NONIUS_BENCHMARK(""std::sort noinline"", [](nonius::chronometer meter) {

    const size_t runs = static_cast<size_t>(meter.runs());
    std::vector<std::vector<int>> vectors{runs};
    std::fill(vectors.begin(), vectors.end(), rand_vec);

    meter.measure([&](const size_t run) {

        std::vector<int>& current_vec = vectors[run];

        std::sort(current_vec.begin(), current_vec.end(), compare_noinline{});

        return current_vec;

    });
});

NONIUS_BENCHMARK(""std::sort inline"", [](nonius::chronometer meter) {

    const size_t runs = static_cast<size_t>(meter.runs());
    std::vector<std::vector<int>> vectors{runs};
    std::fill(vectors.begin(), vectors.end(), rand_vec);

    meter.measure([&](const size_t run) {

        std::vector<int>& current_vec = vectors[run];

        std::sort(current_vec.begin(), current_vec.end(), compare{});

        return current_vec;

    });
});

Compiling with Apple Clang 7.3.0,
$ clang++ -std=c++14 -stdlib=libc++ -O3 -march=native sort.cpp -o sort
$ ./sort

and running it on my 1.7 GHz i5 Macbook Air, we get
qsort                211 ms +/- 6 ms
std::sort noinline   127 ms +/- 5 ms
std::sort inline      87 ms +/- 4 ms

So std::sort with no inlining is about 1.7x faster than qsort (perhaps due to different sorting algorithms), and inlining bumps that up to about 2.4x faster. Certainly an impressive speedup, but much less than 670%.
",3,4708105
33051392,"
Don´t know how std::sort was implemented years ago.
But std::sort can be much faster, because std::sort is quicksort with a heap sort fallback. Heapsort is a linearhitmic alghoritm, meaning if you have twice the sorting data, the sorting time doubles. Actually it more than doubles because it is not exactly linear, but however, qsort can be quadratic, so needing exponential more time for sorting twice the input.
",-2,4708105
4665311,"
Check out locale-dependent ordering for std::string for locale-specific character and string comparison.
",2,4665159
4650123,"
You are not following the Rule of Three:  you haven't defined a copy constructor and copy assignment operator for your class.
You make a copy of mhdr when you pass it as the functor to std::sort.  The order data member of that copy and of the original mhdr both point to the same object.  The copy is destroyed, causing the object pointed to by its order to be deleted, then the original is destroyed when main ends, causing a double deletion, undefined behavior, and other fun things to happen.
(In fact, even more copies might be made inside of std::sort, so it might crash even earlier.)
Why are you dynamically allocating the std::vector?  If there are any good reasons to do that, there are very few of them.
",12,4650096
4650138,"
You're passing mhdr by value to std::sort(), with a default copy constructor that duplicates the pointer to your vector, and deletes it when that instance goes out of scope. That's not what you want.
You should probably use a comparator object distinct from the thing holding that vector, or reference count the pointer to the vector (using an appropriate smart pointer class, probably).
",5,4650096
4650164,"
You don't need bool operator()() on that class - the longs can be sorted with default comparison (see std::sort). The runtime-reported problem is that the third argument is copied, and you don't have a copy constructor, nor copy assignment operator in Hdr (see rule of three).
",2,4650096
4650221,"
The problem is that std::sort takes the comparison functor by value, so the destructor will be invoked for the copy and for the original mhdr object, and thus, since you havent supplied a copy constructor, order will be deleted twice.
The easiest fix would be to use a normal std::vector instead of a pointer to a std::vector. By doing this the implicit copy constructor will work for you.
Beside that you could define your copy constructor and make a deep copy of the order vector, or use a smart pointer to wrap it.
But the best solution would be to make the compare function a static member function (or a global function) and using that as parameter for std::sort. You should always use dedicated functor classes. DONT just add an operator() to a class which already does something else. It might work as expected, but most certainly it wont be as effective as a dedicated functor class, because much more copy-operations might be needed (for member variables, like in this case).
Of course you still should fix the copy-constructor of the Hdr class (or just declare a copy-ctor without definition, to remove the implicit one, which fails in this case).
",1,4650096
4651664,"
As others mentioned, the main cause of it is that when you pass mhdr as the comparator, you are making a copy.  This copy contains a pointer to the same vector.  When that copy gets destroyed, that vector gets destroyed, corrupting the collection that was between your iterators.
This would have been apparent if you prevented copying and assignment by declaring those operators private and not implementing then.
The reason you got into this mess is that your Hdr class has two distinct functions -- maintaining the vector, and having the comparator function.  Classes should do one thing, and one thing well.
The solution below fixes these problems, as well as some other problems like exposing data members as public (though I preserved the pointer to the vector since I suspect you were trying to illustrate something about that case even though I agree with the other answerers that this is a questionable decision)
",0,4650096
4622537,"
You can create a custom comparison function to use with std::sort.  This function would have to check if the string begins with a numeric value.  If it does, convert the numeric part of each string to an int using some mechanism like a stringstream.  Then compare the two integer values.  If the values compare equally, compare the non-numeric part of the strings lexicographically.  Otherwise, if the strings don't contain a numeric part, simply compare the two strings lexicographically as normal.
Basically, something like the following (untested) comparison function:
And then...
EDIT: Of course, this algorithm is only useful if you're sorting strings where the numeric portion appears at the beginning of the string.  If you're dealing with strings where the numeric portion can appear anywhere in the string, then you need a more sophisticated algorithm.  See http://www.davekoelle.com/alphanum.html for more information.
",7,4622516
4624419,"
If you are targeting Windows (XP+) and can afford to convert your strings to utf-16, you can use the StrCmpLogicalW function from Shlwapi. See msdn for details.
Otherwise, ICU provides this functionality in its collators. See UCOL_NUMERIC_COLLATION.
",4,4622516
27411027,"
Here's a version that doesn't convert to integer and thus works for long strings of digits regardless of sizeof(int).
",2,4622516
4618795,"
I don't think VC++ supports UTF-8 locales.  You should probably convert to wstring and use collate<wchar_t>, or switch to a C++ library that supports UTF-8 locales.
Locale names on Windows/VC++ are different than on UNIXes; see Language and Country/Region Strings (CRT) on MSDN.
",1,4618265
4610244,"
std::pair overloads operator< to sort first by the first element then by the second element.  Thus, if you just sort the vector using the default sort ordering (operator<), you'll get your desired ordering.
",37,4610232
4610363,"
I really like James' answer, but there's one other option you might want to consider - just funnel everything into a std::map:
Or, if you have duplicate strings, a std::multimap:
This does have the added advantage that if you then need to add or remove new key/value pairs, you can do so in O(lg n), as opposed to O(n) for the sorted vector.
If you really must use a vector, then go with James' answer.  However, if you have a vector of pairs, there's a good chance that you really want a std::map.
",3,4610232
4610314,"
You can use a custom comparator to order on the pairs' .first only.
",0,4610232
53314033,"
Answer to ""duplicate question"" of this:
link: Sort a vector of pairs by first element then by second element of the pair in C++?
",0,4610232
4583426,"
Seems like an ideal candidate for the boost multi-index container!
Or, you could maintain two maps, one by name one by index, both holding pointer to the same object (should look at smart pointers by the way - such as shared_ptr!)
Or create a more complex key (i.e. a struct with the name and index, provide operator<) which can check both the name and the index etc.
",4,4583411
4561805,"
You have this:    
The parameter declaration for a pointer to a function returning a bool and two arguments of type T is wrong. You probably really wanted:
Although typically functions like these are written like this:
This way, users can not only pass in function pointers, but function objects that provides an operator()():
Some of the algorithms provided by the C++ standard libraries are written like this.
",7,4561760
4561853,"
See my corrections in the lines that have whichCompare in them.
You could also templatise the function itself thus:
I used to do this initially just because it was easier but also allows functors / boost-function/boost-bind etc. to be used with your algorithm.
",2,4561760
4563400,"
there is a much more sexy solution:
",0,4561760
4561268,"
Without getting into the discussion on stream buffers, you can get rid of the seek_back and generally make the code much simpler by doing:
Edit:
Added binary capability
",5,4558068
4558426,"
In decreasing order of performance (best first):

memory-mapped I/O
OS-specific ReadFile or read calls.
fread into a large buffer
ifstream.read into a large buffer
ifstream and extractors

",3,4558068
4559553,"
A program like this should be I/O bound, meaning it should be spending at least 80% of it's time waiting for completion of reading or writing a buffer, and if the buffers are reasonably big, it should be keeping the disk heads busy. That's what you want.
Don't assume it is I/O bound, without proof. A way to prove it is by taking several stackshots. If it is, most of the samples will show the program waiting for I/O completion.
It is possible that it is not I/O bound, meaning you may find other things going on in some of the samples that you never expected. If so, then you know what to fix to speed it up. I have seen some code like this spending much more time than necessary in the merge loop, testing for end-of-file, getting data to compare, etc. for example.
",2,4558068
4558385,"
You can just use the read function of an ifstream to read large blocks.
http://www.cplusplus.com/reference/iostream/istream/read/
The second parameter is the number of bytes.  You should make this a multiple of 4 in your case - maybe 4096? :)
Simply read a chunk at a time and work on it.  
As martin-york said, this may not have any beneficial effect on your performance, but try it and find out.
",0,4558068
4558399,"
I think it is very likely that you can improve performance by reading big chunks.
Try opening the file with ios::binary as an argument, then use istream::read to read the data.
If you need maximum performance, I would actually suggest skipping iostreams altogether, and using cstdio instead. But I guess this is not what you want.
",0,4558068
4558270,"
Unless there is something very special about your data it is unlikely that you will improve on the buffering that is built into the std::fstream object.
The std::fstream objects are designed to be very effecient for general purpose file access. It does not sound like you are doing anything special by accessing the data 4 bytes at a time. You can always profile your code to see where the actual time is spent in your code.
Maybe if you share the code with ous we could spot some major inefficiencies.
Edit:
I don't like your algorithm. Seeking back and forward may be hard on the stream especially of the number lies over a buffer boundary. I would only read one number each time through the loop.
Try this:
Note: This is not optimal (and it assumes stream input of numbers (while yours looks binary)) But I am sure you can use it as a starting point.
",0,4558068
4530411,"
Works fine over here
",3,4530401
4523483,"
Edit
Better than before approach without using helper vectors: (source on ideone):
I am using lambda from C++0x, but it can be replaced with simple functor object:
Source of old solution with std::map: ideone
",3,4523220
4523567,"
I would say the best way would be to create a vector of ints 0..N and then sort that array with a comparison function that compares the corresponding elements of the vector you're trying to find the sorted permutation of.  Something like:
This minimizes the allocation overhead, as we don't create any large temporary object that we sort and then extract the final permution -- the same vector that is being returned is the temp for sorting.
",5,4523220
4523326,"
You can use std::sort to sort the list of pairs {(24, 0), (55, 2), (22, 0), (1, 1)}. It isn't particularly pretty, but I usually do something like this:
Here is the test:
",4,4523220
4498102,"
In general there are issues I would address as follows:

Your class TrainManager has char* members not std::string, and you are not managing the memory. Not to mention that all the members are private, which may give you issues when you try comparing its members.
You would do better to swap the ""links"" rather than swap the actual data inside them.

",2,4497820
4498070,"
The compiler error is quite obvious.
Use Swap(*(curr->m_data),*(curr->m_next->m_data));
 instead of Swap(&(curr->m_data),&(curr->m_next->m_data));. 
",1,4497820
4425493,"
All the above is valid.
A possible solution is to customise std::less itself using template specialisation:
You then get your custom behaviour using the default template comparator for std::set.
Depending on how you build your system, you may have problems if the set is ""used in a million places "" and the custom std::less is not consistently available.
",3,4425212
4425375,"
The std::set constructor's formal argument type for the comparator object is Compare const&, where Compare is the template parameter.
So even if the set object retained a reference to your actual comparator object (instead of copying it), it would be treated as type Compare, which you have defaulted to std::less.
And since std::less is non-polymorphic it's std::less::operator() that is called, not your operator() down in TestClassLessThan.
So the short of it is, ""you can't do that"".
Or rather, you can, as your code illustrates, but you don't get any behavior change.
To change the comparision object you have to specify some other Compare type as template argument.
Which is what you wanted to avoid, but sorry, there's no way around (that I know of).
Cheers & hth.,
",3,4425212
4425410,"
That is not the way to use set with a comparator. operator() of std::less is not a virtual function and will not be overridden.
Instead use this way to initialize and it will do the trick.
For this to work, your compare function should accept const pointers and not pointers to const. To be safe you can change it to
",1,4425212
4414999,"
Try declaring your function as:
And omitting the return statement.
The problem is that arrays are passed by pointer in C and C++.  Each recursive call receives a copy of a pointer to the same block of memory and modifies the same array, allowing the modifications to the array made by the recursive calls to be seen by the caller.
Vectors are objects, so each recursive call is passed a complete copy of the vector.  Any modifications made by the recursive calls are not seen by the caller.  The change above instead passes a reference to the vector so that it is not copied for each new function call.  Instead, all the calls operate on the same object.
Also, check your initialization of middle.  As written, you're taking the middle element of the array, which will be the same in each call.  (Remember, qlist2.size() isn't going to change from call to call).
",3,4414980
4408789,"
Write a custom comparator: 
and then sort e.g. by using std::sort(myvec.begin(),myvec.end(),CustomComp<0>()); (this sorts by the first key entry)
Or with a more recent compiler (with c++0x lambda support):
",12,4408767
4408788,"
By using a a custom comparator.
then
Note: I did not use a template because, while using a template enables the compiler to optimize for that specific index, it prevents you from selecting the index at runtime, e.g. based on userinput, so it's less flexible/can't do as much as the nontemplated version. And as we all know, premature optimization is evil :)
",10,4408767
4409432,"
I'm not sure why so many of the answers posted are focusing on functors.  There is no need for a functor with the OP's stated requirement.  Here are 2 non-functor solutions:
1:  Overload operator< in the Custom class
2:  Create a custom comparison function
",2,4408767
4408835,"
",0,4408767
4399579,"
You need to define your map outside of the loop in line 5 and move your printing loop (the one with JAM_test_print_tag_start) outside of that outmost loop right before the return.
",0,4398791
4391396,"
Try std::partial_sort instead of std::sort. :)
",12,4391372
4391406,"
This is what std::partial_sort is for.
",7,4391372
4391572,"
If you require ordering then partial_sort will do it, otherwise if you only need to partition the range nth_element will do it faster.
",2,4391372
4391698,"
Just tell the sort routine where you want to stop sorting:
",0,4391372
4385391,"
You probably know this already: if you are new to C++, please don’t use the MFC collection classes (CObList, CArray etc.). Instead, use the STL (std::vector, std::list etc.). The Product Manager for Visual C++ said as much here (look for the post by RonaldLaeremans).
But sometimes you have legacy code and you have to use the MFC collections.

Do you really need to sort the list, or can you live with a sorted copy of the list? If the latter, it would be pretty easy to copy the list into a std::vector and sort that. Of course you would only copy pointers or references, so you do not incur the overhead of creating additional copies of the objects stored in the list.
Something like this:
",0,4382844
4343001,"
As has already been said, the standard library provides a nonmember function template that can sort any range given a pair of random access iterators.  
It would be entirely redundant to have a member function to sort a vector.  The following would have the same meaning:
One of the first principles of the STL is that algorithms are not coupled to containers.  How data is stored and how data is manipulated should be as loosely coupled as possible.
Iterators are used as the interface between containers (which store data) and algorithms (which operate on the data).  In this way, you can write an algorithm once and it can operate on containers of various types, and if you write a new container, the existing generic algorithms can be used to manipulate its contents.
The reason that std::list provides its own sort function as a member function is that it is not a random accessible container; it only provides bidirectional iterators (since it is intended to represent a doubly linked list, this makes sense).  The generic std::sort function requires random access iterators, so you cannot use it with a std::list.  std::list provides its own sort function in order that it can be sorted.
In general, there are two cases in which a container should implement an algorithm:

If the generic algorithm cannot operate on the container, but there is a different, container-specific algorithm that can provide the same functionality, as is the case with std::list::sort.
If the container can provide a specific implementation of the algorithm that is more efficient than the generic algorithm, as is the case with std::map::find, which allows an element to be found in the map in logarithmic time (the generic std::find algorithm performs a linear search because it cannot assume the range is sorted).

",17,4342957
4342991,"
A vector-specific sort would provide no advantage over std::sort from <algorithm>. However, std::list provides its own sort because it can use the special knowledge of how list is implemented to sort items by manipulating the links instead of copying objects. 
",6,4342957
4342963,"
You can easily sort a vector with:

UPDATE: (answer to the comment): Well, they have certainly provided it by default. The difference is that it's not a member function for vector. std::sort is a generic algorithm that's supposed to work for anything that provides iterators.  However, it really expects a random access iterator to sort efficiently. std::list, being a linked list, cannot provide random access to its elements efficiently. That's why it provides its own specialized sort algorithm.
",4,4342957
4342964,"
std::sort() in <algorithm> does sorting on containers with random access iterators like std::vector.
There is also std::stable_sort().
edit - why does std::list have its own sort() function versus std::vector?
std::list is different from both std::vector and std::deque (both random access iterable) in how it's implemented, so it contains its own sort algorithm that is specialized for its implementation.
",3,4342957
35227042,"
There are already interesting elements of answer, but there is actually more to be said about the question: while the answer to ""why doesn't std::vector has a sort member function?"" is indeed ""because the standard library provides member functions only when they offer more than generic algorithms"", the real interesting question is ""why does std::list have a sort member function?"", and a few things haven't been explained yet: yes, std::sort only works with random-access iterators and std::list only provides bidirectional iterators, but even if std::sort worked with bidirectional iterators, std::list::sort would still offer more. And here is why:

First of all, std::list::sort is stable, while std::sort isn't. Of course there is still std::stable_sort, but it doesn't work with bidirectional iterators either.
std::list::sort generally implements a mergesort, but it knows that it is sorting a list and can relink nodes instead of copying things. A list-aware mergesort can sort the list in O(n log n) time with only O(log n) additional memory, while your typical mergesort (such as std::stable_sort) uses O(n) additional memory or has a O(n log² n) complexity.
std::list::sort doesn't invalidate the iterators. If an iterator was pointing to a specific object in the list, it will still be pointing to the same object after the sort, even if its position in the list isn't the same than before the sort.
Last but not least, std::list::sort doesn't move or swap the objects around since it only relinks nodes. That means that it might be more performant when you need to sort objects that are expensive to move/swap around, but also that it can sort a list of objects that aren't even moveable, which is totally impossible for std::sort!

Basically, even if std::sort and std::stable_sort worked with bidirectional or forward iterators (and it would totally be possible, we know sorting algorithms that work with them), they still couldn't offer everything std::list::sort has to offer, and they couldn't relink nodes either since the standard library algorithms aren't allowed to modify the container, only the pointed values (relinking nodes counts as modifying the container). On the other hand, a dedicated std::vector::sort method wouldn't offer anything interesting, so the standard library doesn't provide one.
Note that everything that has been said about std::list::sort is also true for std::forward_list::sort. 
",1,4342957
4343052,"
Answering the question of ""Why?""
A sorting algorithm for std::vector is the same as sorting a native array and is the same (probably) as sorting a custom vector class.
The STL was designed to separate containers and algorithms, and to have an efficient mechanism for applying an algorithm to data that has the right characteristics.
This lets you write a container that might have specific characteristics, and to get the algorithms free. Only where there is some special characteristic of the data that means the standard algorithm is unsuitable is a custom implementation supplied, as in the case of std::list.
",0,4342957
4340725,"
this code works fine for me 
",1,4340469
4340582,"
It's rather broken. You need to move the pivot item out of the way (conventionally to the beginning of the array you are partitioning) since it's very unlikely that half the elements are less than the pivot and half greater.
And as others have said, you're including the pivot in both sub partitions when you recurse.
I would start by proving one partition run works (i.e don't recurse for now, stop when the partitioning is done, and check the array is now how you would expect)
",1,4340469
4340545,"
One problem is that the last two lines should read:
Another problem is that you need to be prepared to move the pivot around (and keep track of its index). Your code would only work if the pivot already happens to be in the correct spot, which is unlikely.
For comparison, take a look at the several versions of the pseudocode available in Wikipedia.
",1,4340469
4340614,"
The way you compute the pivot has a problem. Ask yourself what happens when the indices are 5 and 9. Instead of this:
Try something more like:
",1,4340469
4340714,"
this should work
}
",1,4340469
4340896,"
This should work
",0,4340469
4340559,"
I tried:
And it worked fine.
What we really need is an example of it failing.  
Hopefully with a full test harness that just compiles and runs and shows the error.
",0,4340469
4328527,"
Sounds like homework.  Rather than store the entire object into the array, consider just storing a pointer to the object.  Then the sort only moves the pointers.  It'll be fast.
",5,4328513
4310099,"
Unless you're programming for a very memory-constrained embedded environment, I suspect you've got a recursion bug in your sort implementations that is causing stack overflow.  Changing the stack size shouldn't be necessary unless you're dealing with truly enormous (many GB) arrays.
Care to post some code?
",6,4310080
4310203,"
In function int a_bubble(int array[], int size) : you return array[size], that is out of bound. The same is true for a_quick().
And post also your main() please.
EDIT: no, it returns the element that is after the last element of the array. Some could say that even accessing it is UB, and they would be right.
Is it debug build you are running? I think the error code corresponds to ""out of bound exception"", but I don't understand why it have to be so cryptic.
EDIT2: it's worse. What int array[1 << 20] stands for? The old version was OK, you just had to remove return array[size]. Make the functions returning void, you already have both, array and its size in the callee.
",1,4310080
4309801,"
An alternative approach you could try is to use a hash table instead of a vector to look up ids in:
This runs in linear time since unordered_set::find is constant expected time (assuming that we have no problems hashing ints). However I suspect it might not be as fast in practice as the approach you described initially using vectors.
",2,4308912
4308982,"
Since your vector is sorted, and you want a subset of it sorted the same way, I assume we can just slice out the chunk you want without rearranging it.
Why not just use find_if() twice. Once to find the start of the range you want and once to find the end of the range. This will give you the start and end iterators of the sub vector. Construct a new vector using those iterators. One of the vector constructor overloads takes two iterators.
That or the partition algorithm should work.
",1,4308912
4309207,"
If I understood your problem correctly, you actually try to create a linear time sorting algorithm (subject to the input size of numbers M).
That is NOT possible.
Your current approach is to have a sorted list of possible values.
This takes linear time to the number of possible values N (theoretically, given that the map search takes O(1) time). 
The best you could do, is to sort the values (you found from the map) with a quick sorting method (O(MlogM) f.e. quicksort, mergesort etc) for small values of M and maybe do that linear search for bigger values of M.
For example, if N is 100000 and M is 100 it is much faster to just use a sorting algorithm.
I hope you can understand what I say. If you still have questions I will try to answer them :)
edit: (comment)
I will further explain what I mean.
Say you know that your numbers will range from 1 to 100.
You have them sorted somewhere (actually they are ""naturally"" sorted) and you want to get a subset of them in sorted form.
If it would be possible to do it faster than O(N) or O(MlogM), sorting algorithms would just use this method to sort. 
F.e. by having the set of numbers {5,10,3,8,9,1,7}, knowing that they are a subset of the sorted set of numbers {1,2,3,4,5,6,7,8,9,10} you still can't sort them faster than O(N) (N = 10) or O(MlogM) (M = 7).
",0,4308912
4287869,"
Based on the ""sample results"" you show, it looks like you don't understand what a priority queue is.
A priority queue guarantees that when you remove elements from it (using top() and pop()), the elements will be removed in priority order.  The elements are not stored in priority order, they are stored in a heap.  
You can consult your favorite algorithms book or website for more information on how a priority queue stores its elements.
",7,4287716
4287756,"
Try changing 
to
",0,4287716
4164899,"
1) Create std::map<int, std::string> and push all data to it (or your QString and QMap).
or
2) Create std::vector<std::pair<int, std::string>> vec,
   push all data to it and call std::sort(vec.begin(), vec.end());
or
3) Use boost::bimap
",4,4164809
4164943,"
",0,4164809
4112850,"
Try to export MyComparer from the .dll with _declspec(dllexport)
",0,4112489
4107326,"
std::sort doesn't preserve the order of the equivalent elements, std::stable_sort does. However, in case of ints you will not notice the difference unless you use some non-trivial ordering as in the following example:
",16,4107315
4107370,"
@vitaut is right. I just want to add that you would not notice if the order of equal integers is changed. This only matters if you sort values which happen to have an indentifying property. For example if you store pointers to integers and sort by the integer value.
",6,4107315
4103167,"
When you want ""iterators"" into an array, you use pointers to elements in the array.  Such pointers can be used as random access iterators:
",2,4103109
4084070,"
Your operator()() is const-incorrect. Change it to
Make sure stock::getSymbol() is also a const function. If it isn't and you can't change it then take the parameters of operator()() by value, not by (const) reference.
",6,4084035
4084063,"
The error message says it all - apparently the G++ STL implementation expects a comparison predicate to take const arguments. Try changing the declaration of operator() to
and check if it helps.
",1,4084035
5858060,"
It seems you read one entry too much. You first read an entry in the line r >> head->data;
 just before the for-loop. Then you read an additional numberOfInts entries in the for-loop for a total of numberOfInts+1 entries.
",0,5857914
5841517,"
The normal way to define a predicate for sorting is as a functor.
Make your class define the operator() to do the comparing, and you can just pass an instance of the class to std::sort.
So really, all you need to do is to define the class like this instead:
And then you can call sort like this:
or, of course, use an existing instance of the test class, instead of constructing a new one. But you just pass in a class instance, and don't need to mention the member function at all.
If the sorting takes place in another member function (it looks that way from your reference to _exprs), write
One thing to note is that std::sort, like most other standard library algorithms, copies the predicate object, and so your predicate class must be able to handle copying safely (which your classes should always do anyway)
In short, the way to achieve this is to follow the ""rule of three"".
If your class defines a destructor, copy constructor or assignment operator, then it should almost certainly define all three.
If the compiler-generated copy constructor is used, it will simply copy your class' pointer members, so you will have two objects containing pointers to the same object.
If the class has a destructor which calls delete on that pointer, then that ends up being done twice. Which is an error.
If your class is intended to be copyable (and most of the standard library requires this), then you must define appropriate copy constructors and assignment operators to implement it safely (for example, copy the resource pointed to by the pointer, or use a smart pointer instead).
IF your class is not intended to be copyable, then you should define the copy constructor and assignment operators to be private, so that attempts to copy the class will result in a compile-time error, instead of runtime crashes.
You should never ever define a class which can be copied, but doesn't do so correctly. Either define the necessary copy constructor/assignment operator/destructors to handle copying, or make copying impossible by making copy ctor/assignment operator private.
Wrapping pointers to dynamically allocated memory owned by the class in smart pointers is a simple way to get copyability for free.
If the class contains only RAII objects, then you don't need to define a destructor at all, and so the rule of three doesn't require you to define copy constructor and assignment operator either.
",2,5840939
5840962,"
You need to make test::cmp() static:
Alternatively, if test::cmp() cannot be static for some reason, you need to use (boost:: or std::tr1::) bind() to bind the (implicit) this parameter of cmp():
",1,5840939
5840975,"
Use operator() and then pass '*this' as a Predicate to Sort algorithm. 
Whatever you pass as predicate must have public accessibility,
",0,5840939
5827059,"
Sorting a linked list is probably best served by mergesort (still O(n log n) even for a list) since you don't have random element access. If you can switch to std::list the list::sort function will take care of it for you.
Alternately use a non-list container instead of list and you can use any sort method you please.
",2,5826952
5826995,"
Sorting a linked list in place is not so efficient because of the lack of random access. You could always use a simple algorithm like bubble sort if you know your list won't be very long, or perhaps if you can afford the small bit of extra complexity, insertion sort would be better.
An alternative method that is probably better than trying to sort a linked list is to just insert each new node in the right place, so that after adding an element the list is sorted.
",-1,5826952
5815004,"
It sounds like you are looking for a set and not a vector. It will be sorted according to the natural ordering (the < operator).  To remove an element by value call erase.
Alternately you can just use sort on a vector to sort the elements. If you need random access to the elements then you will want this approach; the sorted containers do not provide random access.
To find an element in a sorted vector you can use binary_search.
",1,5814915
5815003,"
Sounds like you want std::set or std::multi_set.
",2,5814915
5814976,"
I know no such container.
std::sort exists, in which you can specifiy the sorting function, but it is often even more efficient to actually insert items in the right place directly.
If you always do that, the only ""problem"" you have to solve is to add an item into an already sorted list, which can be done at worst in linear time.
Note that std::vector<T>::insert() takes an iterator as a parameter, to indicate where to do the insertion. You might want to write a findPosition() methods that returns such an iterator. Then, writing an sorted_insert() method is trivial and becomes something like:
",2,5814915
5815012,"
Depends on what you need and why do you need it.
No, in the standard lib, there's no ""sorted"" vector or queue. You have 2 options, if you want to use only the standard library:

sort the container(vector or queue) on each insertion/deletion
implement your own insert/delete, by implementing the insertion sort

Other option is to use map or set, if they'll be OK for your problem (as we don't know what it is)
The other option is to look for some 3rd party lib - I guess boost will have such container, but I don't really know that.
""Also is there an easy way to delete an item from a vector or queue if you know what it is""
- what do you mean by that? You have an iterator to it or ? Or its index? I'll edit my answer when you update (:
",0,5814915
5805005,"
See if this gets you thinking properly about the problem:
You start with a deck of cards face up. You want to sort the deck of cards but you have to follow some strange rules.  
You place the unsorted deck of cards so that you can only see the top card.  Start by moving the first card to your sorted pile (one card is automatically in sorted order).  
Look at the next unsorted card.  If it is bigger (or smaller, whatever) than the top sorted card then move the top sorted card to a third pile.  Continue moving cards one by one to the third pile until your new card is smaller than the next sorted card or the sorted pile is empty, then move the unsorted card onto the sorted pile.  Move the cards one-by-one back from the third pile to the sorted pile.
Repeat previous step until the unsorted pile is empty.
",0,5804663
5787087,"
You operator is effectively invalid.
The operator < must have a number of mathematical properties if you want it to be usable for sorting. One is the AntiSymmetry property:

x < y => !(y < x)

Let's define x = ""b"" and y = ""aa"".

x < y because the length of ""b"" is inferior to the length of ""aa""
y < x because ""aa"" is inferior to ""b""

Hum ?
Also note that your definition is weird for numbers in case they are prefixed by 0s.
Oh, and comparing strings is way slower than comparing numbers.
My take ? Stop altering the node with comparison information. The actual comparison mode has nothing to do within the node itself.
Then you'll just write two comparison methods, one that compares by cost and the other by origin.

And to come back to the original issue, how to write a comparator that consider [""a"", ""b"", ""aa""] sorted ?
You were almost there, but the ""length"" comparison is incomplete. You need to fall back to the actual lexical comparison only in the case the lengths differ, thus you forgot the case where the right hand side argument's length is inferior to the left hand side's one.
Thus the correct form is, supposing two strings:
",10,5786296
5787053,"
Found the following code segment which was throwing the error, then thought about how my overloaded operation was working.
Working solution is this (modified again thanks to comments left by Matthieu M.)
Thanks to everyone who helped!
",1,5786296
5786369,"
Why don't you use a single comparator and make that function a little smarter?  Have it check for numeric characters at the beginning, if so, do a pair of strtol() or atoi() and compare the results.
Otherwise compare the length of string and the characters as per your non-numeric requirements.
",0,5786296
5818643,"
Are you saying you want to sort an collection of strings using that function?
Or if you're using std::wstring:
Then you can call std::sort using that function, let's say you have an std::vector<std::wstring> called v:
",0,5780796
5781431,"
I finally got it figured out. Here is the function. It is critical that you put the shlwapi.h and vcclr.h header files before any of your own header files if you have any. That was the issue I have been struggled with. Don't fully understand why it is. If anyone have an good explanation, welcome to make comment. Also, if anyone know how to combine the last three line of code to a single return statement, welcome to add comment.
",0,5780796
5773229,"
There's no such thing as new in C. Are you using a c++ compiler? 
Ignoring that, the problem is you aren't copying anything, and in fact are creating a memory leak: 
You create a new node on the heap, assigning the pointer to tempPtr ... then reassign tempPtr to headPtr. You just lost that newly allocated Node (memory leak).
To make a copy of the list, you need to iterate through your existing list, copying the data into new nodes that you're adding to a new list. 
(untested and I've not done C for a while but that should do it)
",3,5773188
5767970,"
Your comparator is incorrect.  The comparator needs to return a bool:  true if a is ""less than"" b and false otherwise.  It needs to provide a strict weak ordering.
",4,5767959
5751333,"
The posted code didn't compile but when I was trying to make it compile I noticed you probably want:
Also:
This fixed version of yours compiles for me:
This part came before the full code was posted but may still be useful to someone trying to figure out sort so I'll keep it in:
Generally for sorting you may need to provide a way of comparing the pairs, e.g. see here:
http://www.cplusplus.com/reference/algorithm/sort/
If you use the sort algorithm it will work automagically for anything that has the less than operator defined but not for other types.
std::pair should provide a default less than operator so perhaps there is another issue - can we see the code?  As Tomalak notes, that is probably because you have no way of comparing T's.
",2,5751316
5751341,"
Provide your own comparison function (or functor) as the last argument to sort. Your comparison should take the first of the pair and compare it.
for instance:
",2,5751316
5751363,"
If you start with:
Add a comparator for T, that std::pair<int, T>'s default-generated comparator will invoke:

The errors you were probably getting
The good result

",1,5751316
5751438,"
It looks like these are member functions of a class template. If that is the case, then sortlevel will need to be static (or a non-member) in order to be used as the comparator in std::sort().
Also, you've written e.g. order[x]->first in a few places, when it should be order[x].first.
",1,5751316
5751409,"
Whenever you're using T you need to make sure it is in a class or a function with a template<typename T> before it.
in your code:

you need template<typename T> before the definition of sortlevel, get_level and level_order
when calling sort you need to classify sortlevel<T>.
when calling these function, call them with the actual type.

",0,5751316
5749766,"
It's normally called a topological sort. Most books/papers/whatever that cover topological sorting will also cover cycle detection as a matter of course.
",2,5749732
5750839,"
I don't exactly get why is it so hard to find the dependecy cycle if there is any! you just have to check if there is any node you already passed over while appling bfs algorithm to find out all the dependecies. if there is one you just roll back the way you came down to revisit a node alll the way up and mark all the nodes until you reach the first visit at the specified node. all the ones in your pass will be marked as a cycle. (just leave a comment and i'll give a code to do that if you need)
",1,5749732
5733281,"
Functors don't have to be functions; they can be objects.
",7,5733202
5733307,"
You can tell sort exactly how to sort through the use of a comparison functor.
Working example:
Output:
",2,5733202
5708010,"
to 
or
",2,5707977
5708148,"
Edit: For the moment, I'm assuming numbers was an array of int. If not, well, I'll hope you can figure out what to do...
",2,5707977
5708048,"
First, where is numbers defined, and what is its type?  
Second, the number of elements in numbers is i at every iteration of the while loop, so you do not need to calculate it.
Third, why are you sorting numbers every time you insert a new element?  Why not insert all the elements, and then sort once.  After the while loop that is.
",0,5707977
5708074,"
My wild guess, since you are not showing the important detail of how numbers is declared, is that it is a pointer, and the sizeof trick is failing to calculate the allocated size. It is better to use a template based sizeof like:
or:
As those will trigger compile time errors if a pointer is used, instead of silently failing and yielding unexpected results as the sizeof(x)/sizeof(x[0]) trick.
",0,5707977
5706031,"
Your comparison function is incorrect - it doesn't enforce strict weak ordering.
Use this:
",9,5706010
5706079,"
Your comparison operator doesn't enforce strict weak ordering. If you're able to use boost one trick I've seen is to bind your object to a boost::tuple and use its strict weak operator<.
If you need to write it yourself, something like this should work:
",2,5706010
5672329,"
Because your 'closeness' metric obeys the triangle inequality, you should be able to use a variant of BK-Trees to organize your elements. Adapting them to real numbers should simply be a matter of choosing an interval to quantize your number on, and otherwise using the standard Bk-Tree procedure. Some experimentation may be required - you might want to increase the resolution of the quantization as you progress down the tree, for instance.
",1,5671457
5671483,"

but short of comparing all nodes to
  the new node I haven't been able to
  come up with an efficient solution

Without any other information about the relationships between nodes, this is the only way you can do it since you have to figure out the closeness factor between the new node and each existing node. A O(n) algorithm can be a perfectly decent solution.
One addition you might consider - keep in mind we have no idea what data structure you are using for your objects - is to organize all present nodes into a graph, where nodes with factors below a certain threshold can be considered connected, so you can first check nodes that are more likely to be similar/related.
",1,5671457
5671507,"
If you want the optimal algorithm in terms of speed, but O(n^2) space, then for each node create a sorted list of other nodes (ordered by closeness).
When you get a new node, you have to add it to the indexed list of all the other nodes, and all the other nodes need to be added to its list.
To find the closest node, just find the first node on any node's list.
Since you already need O(n^2) space (in order to store all the closeness information you need basically an NxN matrix where A[i,j] represents the closeness between i and j) you might as well sort it and get O(1) retrieval.
",1,5671457
5671559,"
If this closeness forms a linear spectrum (such that closeness to something implies closeness to other things that are close to it, and not being close implies not being close to those close), then you can simply do a binary or interpolation sort on insertion for closeness, handling one extra complexity: at each point you have to see if closeness increases or decreases below or above.
For example, if we consider letters - A is close to B but far from Z - then the pre-existing elements can be kept sorted, say: A, B, E, G, K, M, Q, Z.  To insert say 'F', you start by comparing with the middle element, [3] G, and the one following that: [4] K.  You establish that F is closer to G than K, so the best match is either at G or to the left, and we move halfway into the unexplored region to the left... 3/2=[1] B, followed by E, and we find E's closer to F, so the match is either at E or to its right.  Halving the space between our earlier checks at [3] and [1], we test at [2] and find it equally-distant, so insert it in between.
EDIT: it may work better in probabilistic situations, and require less comparisons, to start at the ends of the spectrum and work your way in (e.g. compare F to A and Z, decide it's closer to A, see if A's closer or the halfway point [3] G).  Also, it might be good to finish with a comparison to the closest few points either side of where the binary/interpolation led you.
",1,5671457
5672568,"
ACM Surveys September 2001 carried two papers that might be relevant, at least for background. ""Searching in Metric Spaces"", lead author Chavez, and ""Searching in High Dimensional Spaces - Index Structures for Improving the Performance of Multimedia Databases"", lead author Bohm. From memory, if all you have is the triangle inequality, you can use it to some effect, but if you can trim your data down to a sensible number of dimensions, you can do better by using a search structure that knows about this dimensional structure.
",1,5671457
5671481,"
Facebook has this thing where it puts you and all of your friends in a graph, then slowly moves everyone around until people are grouped together based on mutual friends and so on.
It looked to me like they just made anything <0.5 an attractive force, anything >0.5 a repulsive force, and moved people with every iteration based on the net force.  After a couple hundred iterations, it was looking pretty darn good.
Note: this is not an algorithm it is a heuristic.  In the facebook implementation I saw, two people were not able to reach equilibrium and kept dancing around each other.  It turns out they were actually the same person with two different accounts.
Also, it took about 15 minutes on a decent computer and ~100 nodes.  YMMV.
",0,5671457
5671532,"
It looks suspiciously like a Nearest Neighbor Search problem (also called a similarity search)
",0,5671457
5670912,"
The following expression is invalid when i == (listLength-1) (assuming that listLength is a count of the number of elements in arrayOfStructs):
",2,5670888
5670916,"
You should iterate up to listLength - 1 only, or check that you're not at the last element before referencing arrayOfStructs[i+1].
",1,5670888
5670928,"
It looks like you are indexing off the bound of the array:
arrayOfStructs[i+1]
I assume that listLength is the length of the list, meaning that it is one more than the last element of the list. Your for conditional of i < listLength keeps i within bounds, but not i+1.
That may, or may not, cause a crash.
",1,5670888
5670919,"
I believe it's because of the following lines:
More specifically, the i+1 part.  If your for loop runs from zero to listLength - 1, on the last iteration you will try to access one element past the actual range.
You can use i < listLength - 1 to fix the problem, or just use an if statement inside the loop.  Changing the condition is probably better practice.
",0,5670888
7199398,"
Your code was way too complex for this simple algorithm, check code below:
The second algorithm is just a boost that I wrote for the optimization of quick sort, for example on a 40000 elements array regular quick sorts did about 800k actions, the median one did 650k and the random median one did about 620k. That's the best I got so far. :)
",5,5666717
5666965,"
Maybe the problem is here:
First, you're changing some elements of the array, when you should be swapping them with others. If you don't you are destroying data.
Second, your array has size 10, but you're asking for an index at a random position between 0 and 99. Obviously, you can't do that, and that's why you're getting garbage.
",0,5666717
5665609,"
It seems to me you should really think about Insertion Sort algorithm. Every time you need to add a new value just put it into the end your current temp array and push the value down the array until you'll find it's place and knowing the current index for this item you'll be able to find all elements < or > than this one.
This algorithms has O(n^2) complexity in the average case. You could achieve O(n log n) using binary trees.
",1,5665165
5665214,"
I think you need an std::set:
The set will sort and eliminate duplicates efficiently
",0,5665165
5665592,"
There're two things you're missing:

A way to know how many elements are in an array. (C++ arrays are fixed-size (6 for both in your case) but presumably tempArr starts out empty.)
A way to insert an element into an array (which you'll be doing to tempArr).

.
Any element will be either >, < or = to any other element, always. (Well, except when there are some funky operator overloads.)
Elaborate on your pseudo-code. And maybe add a function call or two.
",0,5665165
5665664,"
You could do this very easily with another loop.  If you are sure you will always have 6 items in your file (which is what you currently have based on the size of your arrays above) then you can do something like this:
Additional things will need to be adjusted if the number of input elements is variable, but otherwise this will, one by one, move each element in ""numbers"" to the ""temp"" array, and on each move, it will look through the entire list of other items and check if the new value is less than, greater than, or equal to the one just added.
EDIT: If you are trying to sort the items in the tempArray, then look up an insertion sort as others have suggested.  If you just want to get the elements in the numberArray in ascending (or descending) order, you can look into bubble sort which is likely easier for a new programmer to handle, since it doesn't require a second array.
",0,5665165
5663753,"
Just implement your own search algorithm (use bubble sort or whatever you think might be most efficient) and do the comparison/swapping similar to the following pseudo code:
If you'd like to sort based on multiple collumns you'd just have to repeat this comparing other sub array elements and sorting the least significant column first.
Edit:
I thik this should also be possible using qsort(). You just have to set the element size accordingly (should be 2 * sizeof(int) in your example). Leave the rest of your code unchanged (although I'm not sure about this and can't test run it right now).
",2,5663695
5663915,"
One way to do this:
",0,5663695
5664036,"
Do you have to have an array of type int[][]? If not, you could do something like the following (more or less like Asha answered, I was already typing it up when his answer appeared).
",0,5663695
5650520,"
Your pivot value will always be the value of arr[(i)/2], which is arr[2], no matter which portion of the array you happen to be sorting at the time. Pass the values of left and right to partition so it knows which values to consider for the current call to quickSort.
Also, the values of left and right that you pass for the initial call to quickSort are 20 and 21, respectively, which surely isn't what you intended. You have an array of length 100, and you have initialized the first 21 elements, so you probably want to pass 0 and 21 for those parameters.
But the first thing you should probably do, if you want to test quicksort with a different pivot strategy, is to get it working first with a typical pivot strategy, like the one demonstrated in your textbook. Start with a working implementation, and only then should you start experimenting with variations. You should be able to find a working implementation in your textbook or your class notes.
",3,5650447
5650559,"
I didn't find any place you compare values from the array.
I suppose you should check this place:
Probably it should be:
",2,5650447
5636260,"
The most straightforward approach is to define a function
What I would suggest is a generic functor to take care of all pointer arrays
Armed with this, define the usual c1::operator< ( const c1 & ) and likewise for other classes.
Generally, best practice is to avoid pointers entirely, including arrays of pointers.
",7,5635909
5635993,"
To answer your title question, you can't.
Pointers are built-in types, you cannot override operators where all operands are built-in types.
Luckily, there's an overload of std::sort that allows you to specify a comparison function (or functor) so the operator< isn't used.
",3,5635909
5635954,"
bool operator < (c1 *w) compares a c1 to a c1 * - Your sort compares a c1 * to a c1 *
",1,5635909
5636236,"
You need to pass a compare function to std::sort:
Or if you are using GCC >= 4.5 or Visual Studio 2010 (I'm do not know sure about Intel compiler) you can use lambdas (they are part of the C++0x standard):
",1,5635909
5636000,"
Add a external operator< and keep de original one:
Now sort will work on the vector.
",0,5635909
5636009,"
phimuemue's answer sums it up, I'll just add that, as a workaround, you can create a wrapper class that contains only one member - a pointer to c1, and then overload its operator <. Then you could sort a vector of object of that class.
",0,5635909
5636860,"
And in your example, vector<c1*> is sorted.  Just not to the
criteria you seem to want: by default, sort uses
std::less<T> as the ordering criteria, and std::less<ci*>
compares the pointers (which is what you'd expect).  If you
don't want the default criteria, then you have to pass a third
argument to sort, a predicate defining the ordering you want.
And of course, your member operator<(c1*) will only be called
when you compare a c1 with a ci* (and only if the c1 is an
rvalue).  Such operators are very, very rare---normally, both
sides of a < operator should take the same type (and should be
const, since a < operator which modifies the values of the
objects it compares would be surprising, to say the least).
",0,5635909
5623274,"
I recommend processing your data in 3 passes:

Use std::sort to get all repeated elements adjacent to each other.
Iterate over your sorted range recording the length and position of each equal_range.
Now you can resort your sequence based on the data you've recovered in step 2.  You may consider using stable_search in this phase if you could like a secondary search key to be alphabetical.

",3,5622925
5623039,"
I would have liked to explain this in words and have you write the code, but I'm finding that I'm so familiar with C++ now, that it's a lot easier for me to just write code.  Slight variation on what Steve said.  Your original vector of strings is v.
",1,5622925
5623282,"
There's no built-in way to do this. A relatively simple way is to build a map<string, size_t> containing the counts of each element (just iterate over your input vector, incrementing the count for each string you see). Then write all the keys in the map to a vector, and std::sort that vector with a comparator that compares the number from the map.
That involves more map lookups than strictly necessary, so you could instead write a vector of pairs from the map, then sort the pairs, and finally create your vector of strings from the sorted pairs.
",0,5622925
5609186,"
The only array index which is meaningful to the user is zero, which is the minimum element. So, after removing k elements, the k'th smallest element will be at zero.
Probably you should destroy the heap and return the value rather than asking the user to concern themself with the heap itself… but I don't know the details of the assignment.
Note that the C++ Standard Library has algorithms to help with this: make_heap, pop_heap, and nth_element.
",7,5609157
52466836,"
I am not providing a detailed answer, just explaining the key points in getting k smallest elements in a min-heap ordered tree. The approach uses skip lists. 

First form a skip list of nodes of the tree with just one element the node corresponding to the root of the heap. the 1st minimum element is just the value stored at this node. 
Now delete this node and insert its child nodes in the right position such that to maintain the order of values.  This steps takes O(logk) time.
The second minimum value is just then the value at first node in this skip list.   

Repeat the above steps until you get all the k minimum elements. The overall time complexity will be log(2)+log(3)+log(4)+... log(k) = O(k.logk). Forming a heap takes time n, so overall time complexity is O(n+klogk). 
There is one more approach without making a heap that is Quickselect, which has an average time complexity of O(n) but worst case as O(n^2).
The striking difference between the two approaches is that the first approach gives all the k elements the minimum upto the kth minimum, while quickSelect gives only the kth minimum element. 
Memory wise the former approach uses O(n) extra space which quickSelect uses O(1). 
",-2,5609157
5608859,"
Try the quickselect or quicksort algorithms (very similar but depends on what you need). In any case, these are just relatively simple and popular algorithms - more importantly, in practice they are fast (although they do have bad worst cases).
Regards,
Dennis M.
",2,5608834
5608850,"
For all intents and purposes, vectors are arrays with added niceties. Random access is as fast as the C-style array. Removing/inserting elements in the middle of a vector is slow - but the same applies to C-style arrays, too. Shell sort should be as fast on vectors as it is on arrays. To me, it sounds like you're doing something unorthodox.
Quicksort or introsort (std::sort is one) should be the fastest comparison-based sorts available to you. Mergesort is slightly slower than quicksort, but it does not have quicksort's susceptibility to pathological cases. On average, all of those take O(n lg n) time (with quadratic worst-case for quicksort).
EDITED UPDATE
Code: C-array and Vector based shellsorts. With optimisations or without, sorting 1 million elements takes twice as long for vectors, for a reason unbeknown to me. Looks like STL is doing a lot of error-checking when you access a vector.
",9,5608834
5608876,"
An algorithm such as quicksort is ideal for sorting data in-place, as one would with a vector.  That is, no insertions or deletions, just moving data around in the fixed-size buffer.
",2,5608834
5597584,"
The algorithm in your Sort function is wrong. It doesn't sort at all.
Anyway, don't reinvent the wheel, better use std::sort as:

As for your Sort function, which you want to implement using bubble-sort algorithm, possibly for learning purpose. the correct implementation is this:
",2,5597532
5597575,"
You are only making n swaps.  You need an outer loop on sort (assuming it's bubble sort) so that you continue doing that until you stop doing swaps.
",1,5597532
5597629,"
That only does one pass over the data, here is an example showing you what happens
After going through your function the result would be
",0,5597532
5597567,"
I think your C++ teacher simply has a poor choice of wording.  ""partition of 3 elements"" almost certainly means: choose the pivot element by picking the median of the first, middle and last elements -- this is the most common coding technique and has good properties when the array is already sorted.
Extrapolate that definition for 5, 7, 9, 11.
",5,5596403
5596474,"
Partitioning is an essential part of the quicksort algorithm.  Review the algorithm to understand what partitioning is. Good luck.
",0,5596403
5572920,"
Use Boost.MultiIndex:
I don't have any performance tests on it, but it certainly better expresses your intent, and that's usually indicative of improved performance anyway.
",1,5572309
5572394,"
I think the easiest way is two containers. Your current key->value map, and a second heap of keys that orders by priority of the object (possibly just use priority_queue as your heap implementation). This would have difficulties of priority can change on the fly though.
",1,5572309
5572412,"
If you use std::set or std::priority_queue instead of std::map, you can define a functor, or simply implement operator< for your class so that the std::set orders the objects in priority order for you.
",1,5572309
5569230,"
Don't you mean to use db[l] - the variable - rather than node - the type.
",1,5569109
5628813,"
Azorath wrote:
(strcmp(cityTemp.fname, node[i]) < 0) && (l <= ct )
and after some give and take we've got, with some confusion between i, I and l....
(strcmp(cityTemp.fname, db[i]->getcity()) < 0) && (l??? <= ct )
yes? (how does Erik know that db[i] is in the code?)
I'm taking a guess that cityTemp is an instance of node, not a pointer to node, and that db[] is an array of pointers to nodes, yes?
One thing wrong is ""cityTemp.fname"" - there is no ""fname"" member in the class. Its looking for a structure containing a member ""fname"". Do you mean cityTemp.city?
Try that and trport what you get...
",0,5569109
5534537,"
It depends on how you intend to use the data.  If you only occasionally need to access the data by key but generally just need to access it in the order in which it is inserted, you should just store the data in a std::vector:
As long as you always add elements using push_back and never reorder the elements (e.g. using std::sort), the elements will remain in the order in which you inserted them.  You can use the std::find to perform a linear search over the sequence to find the element with a given key.
If you need to frequently access elements by key but still need to maintain the order of insertion, you can use a std::map and a std::vector to contain the data:
Whenever you insert an element into data, add the key to the end of the key_insertion_order sequence.  Whenever you remove an element from data, remove the key from the sequence.
",3,5534508
5535345,"
Maybe you can trick the map that, you add always the biggest elementh therefore map puts them at the end. But be carefull that this is not a safe code. Use it, if you make your insertions from a single point and single thread. here is the sample code
",1,5534508
5509948,"
You could create a struct for a single date/snowDepth pair, and keep an array of such pairs. After you could add more fields there, and sort by whatever you like. The data will always be consistent.
By the way: why bubble sort? Quicksort is much faster.
",2,5509904
5509916,"
Since both elements is in the same struct, the two elements should move together.  Your array should be an array of structs.  How do you have it configured now?
",1,5509904
5510171,"
Update Added a std::map based example for good measure (see below)
I wouldn't work on sorting as much as on datastructures :)
Here is a sample that I wrote in order to brush-off the dust of my C++ skills :)
Sorry if I threw in more than the kitchen sink. 
Also note, that for this 'tivial' datatype you could probably use std::pair as the 'Report' struct and std::map as the container type, requiring substantially less manual coding, but I wanted to show you how things are done if you coded the struct manually:
Compile and run using:
Output:

For completeness, here's what it would look like when using std::map as I suggested above. Note that ordering by keys is implicit:
Did I mention I'm a bit lazy? Hence the hack to display the items using stream operator. 
To use custom ordering, see here for example
",1,5509904
5514933,"
If your homework assignment is specifically about learning to write a sorting algorithm, replace this code:
with this:
If your assignment is not about learning to write a sort, use std::sort:
P.s. Your data type Array is misnamed. It doesn't hold an array, it holds a single observation. 
",1,5509904
5510822,"
Since you've asked this under a C++ tag, here's one way in C++:
Also, see this stackoverflow question.
EDIT: std::pair.second is not a function.
",1,5509904
5510930,"
You were so close! It's correct that you compare the snowDepth values of the array elements, but you shouldn't just re-arrange those values. Instead, you should re-arrange the entire Array value.
Instead of this:
Do this:
That will move both the snowDepth value and the date value (because they're members of the same struct).
",0,5509904
35734068,"
You're already storing the data in a struct, so the simplest thing would actually be to just define operator< and swap for your Array type.
",0,5509904
5507285,"
You can't overload operator< for pointers, but you don't need to, since std::sort can accept any comparison function (or functor).
Another problem is that the sort algorithm cannot swap arrays, because they are not assignable. But you can sort an array of pointers into the two-dimensional array (leaving the original array as it is).
",1,5506021
5506147,"
That code actually looks suspiciously like C code, not C++ which would use std::string.
There's no way to write an operator< that will work with std::sort because there's no swap that will work right unless you write that TOO.
Using std::string would make this pretty trivial, otherwise you'll have to write your own operator< (look at the C function strcmp) and swap  functions.
EDIT: Note that swapping std::strings will almost certainly be faster than swapping huge swaths of memory in a char array.
",4,5506021
5506064,"
It's not possible to write an operator< to work with char arrays.
",3,5506021
5506564,"
Assuming you really do need to sort a 2D array row-wise, it's a bit difficult to make std::sort() do this for you, even given a working comparer functor: it would need some sort of iterator adapter.
However, you can easily use other in-place sorting algorithms, such as selection sort:
test run: https://ideone.com/15hRB
",2,5506021
5463672,"
Hah!  Took me a while to see this one. 
The trick is, in MPI_Scatter, the sendcount is the amount to send to each process, not in total.  Same with gather; it's the amount to receive from each.   That is, it's like MPI_Scatterv with counts; the count is to each process, but in this case, it's assumed to be the same.
so this
works for me.
Also, be careful of allocating big arrays like that on the stack; I know this is just an example problem, but for me this was causing crashes right away.  Doing it dynamically
solved that problem.
",3,5462046
5462242,"
Both iterators and ends are array of integer pointers pointing no where or garbage. But in the for loop trying to keep values as if they are pointing to some location, which results segmentation fault. Program should should first allocate memory, iterators can point to and then should keep the values at locations pointed by them.
Since the program manages resources( i.e., acquired from new ), it should return resources to free store using delete[] when no longer needed. Use std::vector instead of managing resources your self, which is very easy.
",1,5462046
5438913,"
I think you are blowing the stack.  The sort function is implemented recursively, so if you give inconsistent answers about the order relationships among elements, the algorithm may fail to terminate.
",4,5438862
5438918,"
Your comparison function must return false when the inputs are equal, not true.
",4,5438862
5438945,"
The problem is your compare-function:
If the elements are equal the expression r1 < r2 is false - but in case of equality (in your case if first 6 ints are equal) you return true.
",2,5438862
5438963,"
This is not necessarily related to the question (it would not contribute to a crash), but the code is skipping one column.  The code compares 6 (8-2) columns and then (if using the uncommented code), it would compare the last column.  The next-to-last is not examined.  However, that might be the intent ... if so, though, a comment would probably be good if the code has to exist for any amount of time.
",1,5438862
5439427,"
If you want to sort in lexicographical order you can use the standard library:
",1,5438862
5438916,"
I expect you are running off the end of one of your vectors, which will have undefined results in release builds.
On linux, run your program using the excellent Valgrind.
You can also make your code so it only examines actual slots in the vectors, such as:
However, if you are expecting an exact number of slots then that's a logic bug and making your compare function ignore it is not necessarily a good solution.
",0,5438862
5411613,"
About how many elements we are talking?
I made an short test with 10.000.000 integers (prepared in an vector) and inserted them in three different ways into the set.
Prepare Input:

Insert into set item by item with insert:
Release: 2,4 seconds / Debug: 110,8 seconds

Insert into set with insert(itBegin, itEnd):
Release: 0,9 seconds / Debug: 47,5 seconds
So insertion could be heavily speeded up, but even the slow way should be far from several minutes.

EDIT:
I made an test with debug-mode meanwhile - wow - I know debug costs performance, but it is more than I thought. With 50.000.000 elements there is an bad alloc in debug-mode, so I updated my post to 10.000.000 elements and showed times for release and debug build.
You could see the immense differences here - 50 times with the faster solution.
Additionally the fast solution (insert(itBegin, itEnd)) seems to be linear to the amount of elements (with presorted data!). The previus test had five times more elements and the insert-time was reduced from 4,6 to 0,9 - about five times.
",6,5411251
5411404,"
Have you tried the range constructor?
Tried 4 techniques with [0 -> 10,000,000) items (sorted in file):
Times in clock() average over 3 runs (normal) and 3 runs(-O4)
Conclusion 1: for sorted data:
Conclusion 2: Optimization counts.
",2,5411251
5411504,"
It's possible the set is rebalancing. How many items do you REALLY have that take 5.6 min? If your set of items is big enough you might be hitting physical RAM limits and thrashing, or just having really bad cache misses.
There's definitely no way to disable the rebalancing. If you could, then the set would be able to break its invariants which would be bad.

Get a profiler and profile your code rather than guess what's taking the time.
Did you try the two param insert using end instead of the previous iterator as another data point?
Did you try inserting into a pre-reserved vector instead to compare the time?
Can you get away with another container type like heap or (sorted) vector?
If you can quickly load into a vector, do that, then random_shuffle it, and then try inserting into the set again and see what happens.

",1,5411251
5410429,"
The simplest way to get this in C++ would be to call map::upper_bound and decrement the returned iterator:
but beware of corner cases (if upper_bound returned begin(), or the map is empty, etc)
test run: https://ideone.com/TP3DL
",5,5410141
5410593,"
Use a priority queue.  Is there a reason you must use a map?
",0,5410141
5726753,"
The program doesn't terminate because it is deadlocked.  Your code is very close to correct, but the problem is that 'g' is a global pointer to a task_group and your doing a recursive task decomposition and this is not a combination that mixes well.
If you broke into the debugger, I expect that you would see lots of threads in task_group::wait, waiting for the tasks to complete.
The tasks aren't completing because you're sharing your task_group amongst the threads and tasks and they're all effectively waiting for each other.
To fix this, declare a task_group (or structured_task_group) on the stack inside the bitonic_merge function, this will still allow tasks to be scheduled and executed during the calls to wait, just like using parallel_invoke will, but because the task_group isn't shared amongst tasks, the call to wait will complete after all the child tasks have completed and avoid the deadlock.
Note that I answered a similar question with a performance slant on the msdn forums for the PPL and remember that syntax and semantics of task_group, structured_task_group, parallel_invoke and parallel_for / parallel_for_each are consistent between the PPL and TBB; use what makes sense for you or your platform.
",4,5404058
5425171,"
Use tbb::parallel_invoke if the number of sub problems is constant.
otherwise use recursion and task_group.
Since the number of sub problems is 2 parallel_invoke is suitable and easier to implement.
Refer Intel TBB design patterns for more details
",0,5404058
5438436,"
Waiting on the task group is important here. Without wait(), the function will return before the recursive ""calls"" done with task_group::run() complete, and obviously it breaks the algorithm.
parallel_invoke is indeed applicable, and it automatically waits for the ""invoked"" functions to complete, so easier to use.
What makes me (as TBB developer) worry is why the given program snippet does not terminate. It should work well as far as I can tell. Would you mind submitting a full source of the program (either here or at the TBB forum?)
",0,5404058
5374986,"
You use merge sort for multi-threaded applications.
The reason:
Merge sort divides the problem into separate smaller problems (smaller arrays) and then merges them. That can be done in separate threads.  
Quick sort does a pivot sort on a single array, so it's harder to divide the problem efficiently between threads.
",8,5374969
5376221,"
Every divide and conquer algorithm can be quite easily parallelised. Merge sort and quicksort both follow the same basic schema which can be run in parallel:
Where they differ is that in quicksort, the division is difficult and merging is trivial (no operation). In merge sort, it’s the other way round: dividing is trivial and merging is difficult.
If you implement the above schema, quicksort is actually easier to parallelise because you can just forget about the merge step. For merge sort, you need to keep track of finished parallel tasks. This screws up the load balancing.
On the other hand, if you follow the above schema, you’ve got a problem: the very first division, and the very last merging, will only use a single processor and all other processors will be idle. Thus it makes sense to parallelise these operations as well. And here we see that parallelising the partitioning step in quicksort is much harder than parallelising the merge step in merge sort.
",4,5374969
5374976,"
A merge sort seems like it would be easier to parallelize and distribute...think about it, you're breaking it up into clean sub problems that can easily be divided and distributed. But then again, the same is true of quicksort. However, I would probably prefer doing it with merge sort as it would likely be easier.
",3,5374969
5375831,"
Assuming a decent pivot selection, it's not all that different. 
Subproblems are trivial to parallelize; they use (mostly) disjoint memory and need no synchronization, so the actual difference lies in the bottlenecks: the initial partition of quick-sort vs. the final merge in merge-sort. Neglecting to parallelize these will result in bad speedups for many cores or few elements (This gets noticeable a lot faster than you might think!).
Both algorithms can be parallelized efficiently. See this MCSTL paper for some experimental results and implementation details. The MCSTL was the base for what is now the GNU C++ std-lib parallel mode.
It's not all clear which algorithm will perform better in all circumstances as it depends on data distribution and about whether swaps or comparisons are slower.
",3,5374969
5375701,"
I think they are looking for merge-sort as an answer, since it is easy to see how to split this between threads. Though another comment indicates that qsort can also be split into smaller problems. Likely many can be split into smaller problems.
There is one critical aspect that cannot be ignored. Communicating with the other threads takes a lot of time. The data set your are sorting has to be huge, or very expensive to compare, before creating the threads and doing the communication between them will be better than just using a single thread.
Further to this, with any sort, you have a serious problem of false sharing. Having multiple threads work with the same data can (communication time notwithstanding) be slower as the CPU is forced to share and update data between multiple cores. Unless your algorithm can properly align the data, passing it off to various threads will slow it down.
",1,5374969
5347856,"
What do you think this does?
The assignment is the same as:
But you just found out x == classes.size() so
And for any N, N%N is zero, so that means
Is that what you want?

The if in question is only capable of dealing with classes offered only in the fall.  Perhaps you wanted:

Maybe this would work?
",2,5347725
5348043,"
I think the problem is that you're never able to fulfill the requirements for all courses. The starred code
only allows you to take fall courses. If a required course is only available in spring, your code will attempt to assign courses over an over not being able to add new courses due to missing requirements.
Now, lets assume you fix that if and allow the course requirements to be fulfilled. You would still depend on the data being correct (i.e. no cyclic course dependencies). I suggest reading up on topological sorting, in case you're not familiar with it already. A simple (albeit inefficient) way to deal with the possibility of infinite loops is using the observation that at each step through the entire course list, there should have been at least one course removed from the list. So you could write something like:
",2,5347725
5347825,"
An & by itself is a bitwise and.  You want a &&.  That part inside the if statement is probably never being reached, so size doesn't change.
",1,5347725
5332331,"
In most of your loops, you use this condition:
Your array indices range from 0 to librarySize - 1 (since these are the indices populated by loadData), so the last valid entry in your array is books[librarySize - 1]. Try changing the loop condition to:
Edit: There's also another problem in your sort function: you're trying to access books[iteration+1] which will once again be out of bounds during the first pass. Your inner loop should only go up to librarySize - pass - 1:
",1,5332254
5332393,"
The problem is where your ""bubble"" is happening.  In both loops you start at array pos 0, you need to move up as each first element is in the correct place.  The end never gets sorted.
Here is some code that I have not tested so it could be off by 1 etc.  But you get the idea
Or you could do it like this
",0,5332254
5314723,"
Your predicate does not satisfy strict weak ordering criteria.  Look at your function and ask yourself, what happens if e1's date comes after e2, but e1's time comes before e2?
",3,5314672
5314784,"
I think what your predicate really should be is something like this:
What you wrote - if e1._date>e2._date, the first condition will be false, but the second may still be true and the function will still claim that e1<e2 which is probably not what you want.
",2,5314672
5314809,"
Your code needs to be:
If e2's date is after e1, then your version treats goes on to compare the time and size. This is not what you want. This eventually confuses std::sort because if you swap e1 and e2 you will not get a consistent answer.
",1,5314672
5274574,"
You can use a functor:
You could also use lambda either from boost, or from the langage (if you use C++0x). With C++0x syntax, it would be something like (can't check as I don't have access to a C++ compiler that supports C++0x right now):
",13,5274542
5274581,"
You can sort with the std::sort algorithm:
Simply supply a function object (comp) that performs a less than compare for the attribute you're interested in.
",5,5274542
5274729,"
Use std::mem_fun and a wrapper:
and to sort, do
If you want to sort by member variables, there is unfortunately no std::mem_ptr. Use the ideas from my answer there to build your own.
",2,5274542
5217251,"
Since you are aiming for efficiency even before starting to write a program, do it other way around : first write a correct program, then profile it and optimize bottlenecks.
Therefore, I can only recommend what other already did : std::sort
",1,5216976
5217001,"
The Standard library's <algorithm> header has a sort function you can use, see: http://www.cplusplus.com/reference/algorithm/sort/
",8,5216976
5217041,"
Normal std::sort should do the job for you, see this snippet on ideone.
",1,5216976
5217023,"
You can use trie trees http://en.wikipedia.org/wiki/Trie
",0,5216976
5188836,"
Well for one thing, that would be char *word_array[], the way you declared it would be a string.
Anyway the way to do this is you declare a structure to keep these things paired:
",1,5188813
5189140,"
If by simple, you mean a more direct way then yes. The std::sort() does support sorting of raw arrays as well:
As Blindy showed, you need a comparator function to tell sort how the ordering is suppose to be done for your list of words. Otherwise you'll end up sorting by the memory address that the string resides at instead of by the letters in your string. Something like this should work:
One other note, in practice you'll want to prefer std::vector over just raw pointer arrays since the latter isn't as safe.
",0,5188813
5189226,"
I've tried to find a solution to a similar problem before and ultimately had to sort it manually. Another way I imagine you could do this would be to write a sorter functor that can somehow figure out, based on which string is being sorted, which integer is associated, and sort based on that. This is terribly inefficient, so I would highly advise doing your own manual sorting using std::swap.
",0,5188813
5185916,"
Yes, in C++ list::sort() is stable, per ISO 14882:2003 23.2.2.4[lib.list.ops]/31
",11,5185829
5185894,"
Yes, the standard requires the list::sort to be stable.
",6,5185829
5174694,"

There are several different objects and several different properties that could it be sorted by.

While the solution Erik posted is correct, this statement leads me to think that it's impractical at best if you are in fact planning to sort by multiple public data members of multiple classes in multiple ways in the same program, as each sorting method will require its own functor type.
I recommend the following abstraction:
Usage would look like:
This will work for any type with public data members, and will save a lot of typing if you need to sort your classes more than a couple of different ways.
Here is a variation that works with public member functions instead of public data members:
With usage like:
",13,5174115
5174136,"
Use std::sort and a functor. e.g:
The functor's operator() should return true if L is less than R for the sort order you desire.
",17,5174115
19165859,"
Here is my version of the answer, just use a lambda function! It works, it uses way less code, and in my opinion it's elegant! 
",3,5174115
5175042,"
EDIT: replacing with lambda_compare, because I'm a masochist:
You can also just create a helper that lets you specify which value to use via a lambda expression:
",1,5174115
5174094,"
This isn’t really a classical “sorting” problem … since there are only a fixed number of possible values, this is known as a partitioning problem and there exists an efficient solution for the three-ways partition known as the Dutch flag sort, first proposed by Edsger Dijkstra.
This algorithm runs in O(n) and needs only a single pass over the array.
The algorithm can also be found rather trivially by developing the loop invariant.
",11,5173999
5174098,"
I think this is perfect for bucket sort: Basically create a list of 256 int counts and each time you encounter a value in your list, increment the count for that value. Then iterate over the counts to put them back in order. This is O(n).
",3,5173999
5174859,"
Another option would be two calls to partition:
",3,5173999
5174026,"
Have you taken a look at this? http://www.sorting-algorithms.com/few-unique-keys
",2,5173999
5174029,"
std::sort. Then an O(n) search for boundaries.
",0,5173999
5158818,"
Use std::find
A better solution would be to pick a more suitable container, such as the mentioned std::map
",7,5158764
5158786,"
You should use std::map for that.
",7,5158764
5158821,"
As vissi says - you really want an associative array
If you have to use vectors you can sort the vector and then use one of the std::find  functions to return an iterator ie a pointer to the position.
ps. You say you have two vectors? Presumably you want to keep them in order, which means sorting just the strings would be bad. You probably want a container class that has a string and value - a vector of which can be sorted
",1,5158764
5136880,"
std::sort won't do it easily because arrays aren't assignable.
However, std::qsort will do it:
OK, so std::qsort doesn't benefit from template inlining optimization, but it gets the job done and at least you aren't allocating a lot of memory and doing unnecessary copying.
You could instead look to replace your array of int[3] with an array of structs with an int[3] as a data member. That would then be assignable and you could use std::sort normally. Depends how much other code you have written that relies on the current type, and whether it's OK to break the interface that code uses.
",3,5136724
5136767,"
Yes -- sorting with such large items tends to be slow simply because copying large items is slow.
You can (probably) speed it up by creating an index that contains the key (the item from the first column that you're using to do the sorting) and a pointer or index to the original row of data. Sort the index, then use that to copy the data into a new array in sorted order (and, if necessary, back to the original). This helps reduce the copying to a minimum, which can save a fair amount of time if your have a lot of columns.
OTOH, given that you're only talking about tens of kilobytes (or so) of data, you could pretty easily get by with just using qsort directly on the table (with a suitable comparison function). This is one of those rare situations where it may actually make sense to use qsort in C++. Since Steve Jessop has corrected his answer showing this method, I'll leave this to him rather than showing it here.
",2,5136724
5136765,"
Personally I would write a simple sort, like bubble sort to do it for me rather than converting, using sort , converting back.
For bubble sort you just loop through the table looking at the data in a row and the row ahead of it,  then switch them if a > b etc, rinse and repeat till your data is sorted.  Its not the most efficient but its simple and fast over small sets of data.
",-2,5136724
5135238,"

it's even impossible to sort using condition like that ?

No. The comparer in sort must satisfy the criteria of a strict weak ordering which yours clearly doesn’t (for instance it’s not irreflexive).
",5,5135216
5135308,"
This problem cannot be solved in O(N log N) time. I don't know if it's NP-hard, but it's quite non-trivial. I do think it's safe to say that a program solving the problem as expressed in your code would require exponential time. There are such programs: I think it could be fiddled around and plugged into a linear optimizer.
No standard library function will get you even most of the way to a general solution. There are no standard library functions slower than O(N log N), and none solve problems that may be intractable.
This problem is intractable if, for example, every size equals 10 * d.
",2,5135216
5135251,"
You're using the sort() method wrong.
STL sort is used to order a list of elements. For an 'ordering', you need to satisfy conditions like:

if check( A, B ) == false AND A != B, then check( B, A ) returns true.
if check( A, B ) == false AND check( B, C) == false AND A, B, C are distinct, then check ( A, C ) returns false.

A good idea for where you can use STL's sort() is, given your list of items S and the order you want the items to be in:

If the order of the items in S changes, the output order should remain the same.
The output is unique.
All the items in the output order have some relation that is a strict partial order relation.

If this is the case, then you probably can write the check function to work for you :)
",0,5135216
5123582,"
Got it.
I assumed it'd figure out that the > operator returned a bool (per documentation).  But apparently it is not so.
",111,5122804
47178902,"
To much code, you can use it like this:
Replace ""vec"" with your class and that's it.
",7,5122804
5124079,"
Can the problem be with the ""a.mProperty > b.mProperty"" line?  I've gotten the following code to work:
The output is:
",3,5122804
7180090,"
You could use a combination of the std::sort and std::unique algorithms to accomplish this:
If you are working with a raw array (not, say, a std::vector), then you can't actually reclaim the space without copying the elements over to a new range.  However, if you're okay starting off with a raw array and ending up with something like a std::vector or std::deque, you can use unique_copy and an iterator adapter to copy over just the unique elements:
At this point, uniqueElements now holds all the unique elements.
Finally, to more directly address your initial question: if you want to do this in-place, you can get the answer by using the return value from unique to determine how many elements remain:
Hope this helps!
",6,7180011
7180168,"
Now uniqueItems contains only the unique items. Do whatever you want to do with it. Maybe, you would like v to contain all the unique items. If so, then do this:
Now v contains all the unique items. It also shrinks v to a minimum size. It makes use of Shrink-to-fit idiom.
",1,7180011
7180058,"
You could use the flyweight pattern. Easiest way to do so, would be using the Boost Flyweight library.
Edit: I'm not sure if there is some way to find out how many objects are stored by the Boost flyweight implementation, if there is, I can't seem to find it in the documentation.
",0,7180011
7180172,"
An alternative approach to applying algorithms to your array would be to insert its elements in a std::set. Whether it is reasonable to do it this way depends on how you plan to use your items.
",0,7180011
7168804,"
I believe that one of your errors is in this line in main:
The problem here is that set is an array allocated with new[].  To free its memory, you need to delete it with a matching call to delete[].  This can be fixed by rewriting the line as
Additionally, your code has the chance to infinitely recurse in some cases.  In particular, suppose that you try sorting a list that's two copies of 0.  In that case, consider what this code will do:
Since your pivot element is 0 (it's the only choice!), you'll iterate across the array and put both of the 0's in the array into greater.  Consequently, when you recursively invoke quicksort on greater, you'll end up recursively trying to sort the exact same range that you started with, leading to infinite recursion.
To fix this, try updating your code so that you partition into three groups - elements less than the pivot, elements greater than the pivot, and elements equal to the pivot.  You would still recurse on the less and greater ranges, but you wouldn't recursively invoke yourself on the equal values.  This would ensure that the recursion always is invoked on smaller ranges than what you started with.
Finally, as others have pointed out, your current implementation leaks a lot of memory because you never free any of the temporary arrays you construct.  To avoid this, consider replacing your use of raw arrays with std::vector, which does its own memory management and won't leak any memory.  Plus, it makes it substantially easier to split the array into regions, since you can just use push_back to append the elements.
Hope this helps!
",7,7168758
7127502,"
A few ideas you can try. In some quick tests with N=100 and M=15 I was able to get it around 25% faster in VC++ 2010 but test it yourself to see whether any of them help in your case. Some of these changes may have no or even a negative effect depending on the actual usage/data and compiler optimizations.

Don't allocate a new maxValues array each time unless you need to. Using a stack variable instead of dynamic allocation gets me +5%.
Changing g_Source[i][j] to g_Source[j][i] gains you a very little bit (not as much as I'd thought there would be).
Using the structure SourcePoint1 listed at the bottom gets me another few percent.
The biggest gain of around +15% was to replace the local variable sample with g_Source[j][i]. The compiler is likely smart enough to optimize out the multiple reads to the array which it can't do if you use a local variable.
Trying a simple binary search netted me a small loss of a few percent. For larger M/Ns you'd likely see a benefit.
If possible try to keep the source data in arr[][] sorted, even if only partially. Ideally you'd want to generate maxValues[] at the same time the source data is created. 
Look at how the data is created/stored/organized may give you patterns or information to reduce the amount of time to generate your maxValues[] array. For example, in the best case you could come up with a formula that gives you the top M coordinates without needing to iterate and sort.

Code for above:
",5,7126201
7126387,"
If you want to go into micro-optimizations at this point, the a simple first step should be to get rid of the Points and just stuff both dimensions into a single int. That reduces the amount of data you need to shift around, and gets SourcePoint down to being a power of two long, which simplifies indexing into it.
Also, are you sure that keeping the list sorted is better than simply recomputing which element is the new lowest after each time you shift the old lowest out?
",4,7126201
7127313,"
(Updated 22:37 UTC 2011-08-20)
I propose a binary min-heap of fixed size holding the M largest elements (but still in min-heap order!). It probably won't be faster in practice, as I think OPs insertion sort probably has decent real world performance (at least when the recommendations of the other posteres in this thread are taken into account).
Look-up in the case of failure should be constant time: If the current element is less than the minimum element of the heap (containing the max M elements) we can reject it outright.
If it turns out that we have an element bigger than the current minimum of the heap (the Mth biggest element) we extract (discard) the previous min and insert the new element.
If the elements are needed in sorted order the heap can be sorted afterwards. 
First attempt at a minimal C++ implementation:
Small test/usage case: 
",4,7126201
7126285,"
You're looking for a priority queue:
You'll need to figure out the best underlying container to use, and probably define a Compare function to deal with your Point type.
If you want to optimize it, you could run a queue on each row of your matrix in its own worker thread, then run an algorithm to pick the largest item of the queue fronts until you have your M elements.
",2,7126201
7126306,"
A quick optimization would be to add a sentinel value to yourmaxValues array. If you have maxValues[M].value equal to std::numeric_limits<float>::max() then you can eliminate the q < M test in your while loop condition.
",2,7126201
7128137,"
One idea would be to use the std::partial_sort algorithm on a plain one-dimensional sequence of references into your NxN array. You could probably also cache this sequence of references for subsequent calls. I don't know how well it performs, but it's worth a try - if it works good enough, you don't have as much ""magic"". In particular, you don't resort to micro optimizations.
Consider this showcase:
",1,7126201
7128411,"
First of all, you are marching through the array in the wrong order!
You always, always, always want to scan through memory linearly.  That means the last index of your array needs to be changing fastest.  So instead of this:
Try this:
I predict this will make a bigger difference than any other single change.
Next, I would use a heap instead of a sorted array.  The standard <algorithm> header already has push_heap and pop_heap functions to use a vector as a heap.  (This will probably not help all that much, though, unless M is fairly large.  For small M and a randomized array, you do not wind up doing all that many insertions on average...  Something like O(log N) I believe.)
Next after that is to use SSE2.  But that is peanuts compared to marching through memory in the right order.
",1,7126201
7126607,"
You should be able to get nearly linear speedup with parallel processing.
With N CPUs, you can process a band of rows/N rows (and all columns) with each CPU, finding the top M entries in each band.  And then do a selection sort to find the overall top M.
You could probably do that with SIMD as well (but here you'd divide up the task by interleaving columns instead of banding the rows).  Don't try to make SIMD do your insertion sort faster, make it do more insertion sorts at once, which you combine at the end using a single very fast step.
Naturally you could do both multi-threading and SIMD, but on a problem which is only 30x30, that's not likely to be worthwhile.
",0,7126201
7144872,"
I tried replacing float by double, and interestingly that gave me a speed improvement of about 20% (using VC++ 2008). That's a bit counterintuitive, but it seems modern processors or compilers are optimized for double value processing.
",0,7126201
7126897,"
Use a linked list to store the best yet M values. You'll still have to iterate over it to find the right spot, but the insertion is O(1). It would probably even be better than binary search and insertion O(N)+O(1) vs O(lg(n))+O(N).
Interchange the fors, so you're not accessing every N element in memory and trashing the cache. 

LE: Throwing another idea that might work for uniformly distributed values.
Find the min, max in 3/2*O(N^2) comparisons.
Create anywhere from N to N^2 uniformly distributed buckets, preferably closer to N^2 than N.
For every element in the NxN matrix place it in bucket[(int)(value-min)/range], range=max-min.
Finally create a set starting from the highest bucket to the lowest, add elements from other buckets to it while |current set| + |next bucket| <=M.
If you get M elements you're done.
You'll likely get less elements than M, let's say P.
Apply your algorithm for the remaining bucket and get biggest M-P elements out of it.
If elements are uniform and you use N^2 buckets it's complexity is about 3.5*(N^2) vs your current solution which is about O(N^2)*ln(M).
",-1,7126201
7114666,"
If you only want to sort based on the second column, then you just need to provide a custom comparison operator.  Once way to do that is:
Edit: If you won't know until runtime which column you'll be sorting on, you can encode that in the sorting object:
Notice how we've added a constructor that takes which column it'll act on.  You can use it like this:
You don't even need to make the local variable if you don't want to:
[Code at ideone]
",1,7114442
7114785,"
Alright: new -simpler- answer, having learned that vectors are comparable: 
",4,7114442
7114544,"
I'm going to assume each vector represents an record of some type, and compare the internal strings from left to right.  Obviously the sorter() code is easily replaceable.  You should to add a sorter() function somewhere to your code, and pass it to the std::sort algorithm.
",1,7114442
7114512,"
Check out the sort function from algorithm:
Click here for an example + docs
",0,7114442
7100141,"
Change the data structure. Repeatedly accessing the largest element, and then quickly inserting new values, in such a way that you can still efficiently repeatedly access the largest element, is a job for a heap, which may be fairly easily created from your array in C++.
BTW, please don't talk about ""C/C++"". There is no such language. You're instead making vague implications about the style in which you're writing things, most of which will strike experienced programmers as bad.
",3,7100044
7100120,"
You could use a binary search to determine where to insert the changed value after you removed it from the array. Note that inserting or removing at the front or somewhere in the middle is not very efficient either, as it requires moving all items with a higher index up or down, respectively. 
ISTM that you should rather put your changed items into a new array and sort that once, after you finished iterating over the original array. If memory is a problem, and you really have to do things in place, change the values in place and only sort once.
I can't think of a better way to do this. Keeping the array sorted all the time seems rather inefficient.
",0,7100044
7100145,"
I would look into the http://www.cplusplus.com/reference/stl/priority_queue/, as it is designed to do just this.
",0,7100044
7100164,"
Since the array is already sorted, you can use a binary search to find the location to insert the updated value. C++ provides std::lower_bound or std::upper_bound for this purpose, C provides bsearch. Just shift all the existing values up by one location in the array and store the new value at the newly cleared spot.
",0,7100044
7100200,"
Here's some pseudocode that may work decently if you aren't decreasing the removed values by much:
For example, say you're processing the element with the maximum value in the array, and say the array is sorted in descending order (largest first).

Remove array[0].
Let newVal = array[0] - adjustment, where adjustment is the amount you're decreasing the value by.
Now loop through, adjusting only the values you need to:

Pseudocode:
Again, if you're not decreasing the removed values by a large amount (relative to the values in the array), this could work fairly efficiently.
Of course, the generally better alternative is to use a more appropriate data structure, such as a heap.
",0,7100044
7100144,"
Maybe using another temporary array could help.
This way you can first sort the ""changed"" elements alone.
And after that just do a regular merge O(n) for the two sub-arrays to the temp array, and copy everything back to the original array.
",-1,7100044
7098540,"
You can use mktime to convert a std::tm value to a time_t which can be compared.
",3,7098432
7098515,"
The easiest solution is to convert the std::tm instance into an integral value, such as seconds since the epoch.  Do this for both objects in the ComparePointers function, then compare the values.  
Another more complicated method is to compare each member of the std::tm, such as year, month, day, minutes, etc.  
By the way, the comparison function is misnamed.  You are not comparing pointers, but time and date values.
",2,7098432
51245842,"
As suggested by @ChristianAmmer, you can use mktime() to convert tm to time_t for comparison. But since C++11, you can also use a lambda expression instead of defining a comparison function:
Output:

Mon Jul 09 11:24:34 2018
  Mon Jul 09 11:24:41 2018
  Mon Jul 09 11:24:47 2018

Note 1: As an C++11 exercise, I replaced your raw pointers by instances of unique_ptr<>. This way, your example code no longer leaks the MyClass pointers on program exit.
Note 2: The function mktime() might modify the passed tm struct. If this causes any issues, then you can copy the tm struct in the lambda expression first.
Note 3: I used the functions localtime() and asctime() just for demonstration. Recent Microsoft compilers consider them unsafe and suggest to use localtime_s() and asctime_s() instead.
Code on Ideone
",0,7098432
7074903,"
You can use the std::partial_sort algorithm to sort your vector so that the first five elements are sorted and the rest remains unsorted. Something like this (untested code):
",9,7074797
7074832,"
Why don't you sort (std::sort or your own implementation of Quick Sort) the vector based on popularity and take the first 5 values ?
Example:
",2,7074797
7074930,"
If you just want top 5 popular uses, then use std::partial_sort().
",2,7074797
7074894,"
First off, cache that it->getPopularity() so you don't have to keep repeating it.
Secondly (and this is much more important): Your algorithm is flawed. When you find a new top1 you have to push the old top1 down to the #2 slot before you save the new top1, but before you do that you have to push the old top2 down to the #3 slot, etc. And that is just for a new top1. You are going to have to do something similar for a new top2, a new top3, etc. The only one you can paste in without worrying about pushing things down the list is when you get a new top5. The correct algorithm is hairy. That said, the correct algorithm is much easier to implement when your topN is an array rather than a bunch of separate values.
Thirdly (and this is even more important than the second point): You shouldn't care about performance, at least not initially. The easy way to do this is to sort the entire list and pluck off the first five off the top. If this suboptimal but simple algorithm doesn't affect your performance, done. Don't bother with the ugly but fast first N algorithm unless performance mandates that you toss the simple solution out the window.
Finally (and this is the most important point of all): That fast first N algorithm is only fast when the number of elements in the list is much, much larger than five. The default sort algorithm is pretty dang fast. It has to be wasting a lot of time sorting the dozens / hundreds of items you don't care about before a pushdown first N algorithm becomes advantageous. In other words, that pushdown insertion sort algorithm may well be a case of premature disoptimization. 
",2,7074797
7074835,"
Sort your objects, maybe with the  library if this is allowed, and then simply selecte the first 5 element. If your container gets too big you could probably use a std::list for the job.
Edit : @itsik you beat me to the sec :) 
",0,7074797
7074942,"
Do this pseudo code.
",0,7074797
7075131,"
Well, I advise you improve your code by using an array or list or vector to store the top five, like this
",0,7074797
7075224,"
You also may consider using Randomized Select if Your aim is performance, since originally Randomized Select is good enough for ordered statistics and runs in linear time, You just need to run it 5 times. Or to use partial_sort solution provided above, either way counts, depends on Your aim.
",0,7074797
7038955,"
Create a vector of integer indexes, initialised to { 0, 1, 2, 3, etc }. Each integer represents one position in your vector. Sort your vector of indexes using a custom comparision function that uses the indexes to refer to vector1. When finished you can use the sorted indexes to reorder vector1 and vector2.
But I don't think you can do this reordering in place, so you going to have to copy from vector to vector anyway, so I think Kerrek's suggestion is good too.
",1,7038838
7001406,"
One can do:
but I'd rather do (clearer):
",2,7001009
7011944,"
If your compiler supports TR1, you can simply:
Or, if you have boost, replace std::tr1::function by boost::function.
",2,7001009
7001079,"
You will need a auxiliary class to resolve this in run time, do something like:
And then you use it like that:
",2,7001009
6986705,"
The very first page of the Thrust user guide gives an example to do exactly that:
Instead of int you can use your own POD structure, and you can pass a comparator to the sort algorithm.
",1,6986489
6978325,"
The comparison function must define a strict weak ordering which means that a < b and b < a cannot be both true. Your comparison function does not have this property. 
It does not define any ""before-after"" relationship, so it's no wonder that the algorithm relying on this property does not function properly.
",14,6978201
6978318,"
Third argument of std::sort should be a function (or functional object) such that if compare(a, b) is true then compare(b, a) should be false, but your one isn't such. So your program is UB and can give any result.
",8,6978201
6978337,"
No your code is wrong. Comparison functions for std::sort must use < or it's equivalent, using != is not correct. Probably you want this
",7,6978201
6978404,"
Define your comparison function as
",1,6978201
6953019,"
You need to use  seekg  to set the position at the beginning of the file, once you have read it (you have read it once, to count the lines (which I don't think you actually need, as this size is never used, at least in this piece of code)
And what is the point if the inner while? On each loop, you have
So on each loop, i gets 1, so you output the element with index 1 all the time. Which is not the first element, as indices start from 0. So, once you put seekg or remove the first while, your program will start to crash. 
So, make i start from 0. And get it out of the two while loops, right at the beginning of the if-statement.
Ah, the second while is also unnecessary. Leave just the first one.

EDIT:
Add 
before seekg to clear the flags.
Also, your algorithm is wrong. You'll get seg fault, if h > 1, because you'll get out of range (of the vector). I'd advise to do it like this: read the file in the while, that counts the lines. And store each line in the vector. This way you'll be able to remove the second reading, seekg, clear, etc. Also, as you already store the content of the file into a vector, you'll NOT lose anything. Then just use for loop with step h.

Again edit, regarding your edit: no, it has nothing to do with any flags. The if, where you compare i==j is outside the while. Add it inside. Also, increment j outside the if. Or just remove j and use n-1 instead. Like
",0,6952886
6953316,"
Several things.  
First you read the file completely, just to count the number of lines,
then you read it a second time to process it, building up an in memory
image in v.  Why not just read it in the first time, and do everything
else on the in memory image?  (v.size() will then give you the number
of lines, so you don't have to count them.)
And you never actually use the count anyway.
Second, once you've reached the end of file the first time, the
failbit is set; all further operations are no-ops, until it is reset.
If you have to read the file twice (say because you do away with v
completely), then you have to do myfile_in.clear() after the first
loop, but before seeking to the beginning.
You only test for is_open after having read the file once.  This test
should be immediately after the open.
You also set noskipws, although you don't do any formatted input
which would be affected by it.
The final while is highly suspect.  Because you haven't done the
clear, you probably never enter the loop, but if you did, you'd very
quickly start accessing out of bounds: after reading n lines, the size
of v will be n, but you read it with index i, which will be n * h.
Finally, you should explicitly close the output file and check for
errors after the close, just in case.
It's not clear to me what you're trying to do.  If all you want to do is
insert h empty lines between each existing line, something like:
should do the trick.  No need to store the complete input in memory.
(For that matter, you don't even have to write a program for this.
Something as simple a sed 's:$:\n\n\n\n:' < infile > outfile would do
the trick.)
EDIT:
Reading other responses, I gather that I may have misunderstood the
problem, and that he only wants to output every h-th line.  If this is
the case:
But again, other tools seem more appropriate.  (I'd follow thiton's
suggestion and use AWK.)  Why write a program in a language you don't
know well when tools are already available to do the job.
",0,6952886
6953173,"
If there is no absolutely compelling reason to do this in C++, you are using the wrong programming language for this. In awk, your whole program is:
Or, giving the whole command line e.g. in sh to filter lines 1,5,9,13,...:
",-1,6952886
6939158,"

read file line by line. you can use fgets for this 
add every line to a list (ex std:list) that contains string and the value
(sscanf_s(""%d %d %d ..."") to get second value from right) 
sort using std:stable_sor 
write everything to output file

Sample
note that the code above was not tested
",0,6939017
6939487,"
if you just want the data be stored in an array like ""array[line_data, line_number]"" you can do this:

open the file using an ifstream
use std::getline to read each line
save the data from getline into a container

so, the reading would look like this, given you use an std::ifstream named ""file"" and a container named storage:
With this, in storage[0] would be the first line of your textfile.
",0,6939017
6936181,"
The post is not completely clear, but with the given information this is what I came up with on the fly:
First make a container (array, vector, list, map, whatever) to hold the names of the States. You will need this to check if a series of entries is valid.
Now, you said entries (each individual record [ie name, name, state, company]) is separated by newlines. Using this information I would read in lines until you hit a blank line and store them into a container for temporary holding.
When you reach the new line (signaling a new record), check the temporary container. If it contains 4 strings (lines) and are in the order of: non-state, non-state, state, non-state; then consider it a valid record and store it in a permanent container and clear the temp container.
Continue this until you reach the end of the file.
Hope this helps and makes sense as you asked explicitly for no code.
",2,6936087
6936123,"
Keep a bitmap of states:
Initialize it with all the states:
For each string read at a state position, make sure it is in the bitmap:
If the problem is about duplicate names, you can follow a similar approach.
Read each string and map it to a bool, if it is not already there in the map:
",0,6936087
6936322,"
A Radix Sort can be used to sort data with fixed size keys. As this condition is not often met the technique isn't discussed much, but it can be O(n) when the key size is factored out.
",3,6935219
6935387,"
If memory usage is truly limited. I would separate each byte and store them into a trie data structure from most significant to least significant byte. If you insert the bytes in sorted order you can then iterate the trie and have all your data sorted.
",0,6935219
41533204,"
Signature sort is good with large word sizes with 'O (n lg lg n)' expetcted time complexity, but with small word sizes you can get the same complexity with von Emde Boas sort. Also recently even faster sorting algorithm was published from Han and Thorup with 'O (n sqrt(lg lg n))' expected time complexity. I'm not sure if u can find implementations of these algorithms online, but there are probably some great articles and lectures on MIT and Harvard.
",0,6935219
6935505,"
I think the most reasonable thing to do is to create an array of pointers to the bigints, and sort the array of pointers.  I would suggest some sort of templated quicksort, with a smart compare function.
The compare function should be able to decide most of the time by looking at the most significant 4 bytes.  If they don't match, then the compare is decided.  If they do match then you look at the next 4 bytes until end of int.
I am guessing that the data range, is probably large enough, that a radix sort would be impractical.  Quick sort is generally faster enough if you data is random, and has cache performance that beats most non-radix sorts.
",-1,6935219
6933333,"
You don't have to define an extra function; the C++ Standard Library already has one.
It's called std::greater.
",5,6933320
6867117,"
I believe that your problem is in this line:
The problem is that when the std::sort algorithm uses a custom callback, it passes in the actual values stored in the vector at particular locations, not the indices of those locations within the vector.  As a result, when you call
The Comp comparator you've written will be getting passed as parameters the values stored in the v1 vector and will then try indexing at those positions into the v2 vector.  Since the values in v1 are larger than the size of v2, the call to _V.at(i) will cause an out_of_range exception to be thrown.
If you want to sort the two ranges with respect to one another, you'll need to adopt a different approach.  I'm not aware of a straightforward way of doing this, but I'll let you know if I think of one.
",9,6867092
6867119,"
Size of v1 is just 3, but you're using each value of v2 as index of v1. And as v2 has one value 9 which is greater than the size of v1, that is what gives std::out_of_range error in here:
std::vector::at function gives std::out_of_range exception of the index passed to it as argument is greater than the size of vector. That is, the index must be less than vector::size().
",6,6867092
6867390,"
Ok, now you're probably aware of the fact, that i and j are actual values held in vector rather than indices. There is a good reason for that: sorting is all about values, not indexes. Note you're passing iterators to sort method, so there is no way it can extract index for you. Of course, you could get index relative to first iterator, but there is no reason for doing this.
However, let's be insane for awhile and imagine you would get indices rather than values in your comparator. Assume that your code does what you want and let's think about following scenario:
v1 = {20,10}; v2 = {2,1}
I secretly assume you want the following output:
v1 = {10, 20}
right? Now imagine I'm a sorting function you're calling and I do following steps:

v2[0] < v2[1] is false, so swap(&v1[0], &v1[1])

It's sorted, isn't it? But wait, I'm a crazy sorting function, so I want to make sure it's sorted, so I do the following:

v2[0] < v2[1] is false, swap(&v1[0], &v1[1])

And again:

v2[0] < v2[1] is false, swap(&v1[0], &v1[1])

and again, again, again...
Can you see a problem? Sorting function has some requirements and for sure you're breaking fundamental one. 
I suspect you need completely different container (maybe std::map with keys from vec1 and values from vec2) or at least something like vector< pair<double, double> >, so you can easily sort by either first or second value. If not, consider creating vector with values in range [0, v2.size()), sorting it using your comparator (values are equal to indices, so will be all right) and then print correct values from v1. This code works fine:
",4,6867092
6867275,"
Like said in other answers, the problem is that the sort algorithm passes the actual values to compare rather than indices.
Here is how you can solve it:
",4,6867092
6800859,"
The difference should be really small, but starting with the smaller numbers will be slightly more accurate. Consider for exposition purposes that your floating point number contained only 4 significant digits and an exponent, and that it was decimal rather than binary. Using the numbers:
If we add c first, then either a or b, the smaller of the two falls off the representation and is rounded. The end result of c + b + a will yield 1000e4. If on the other hand, we add a and b first we get 1e4 as the first intermediate value, and adding that to c will yield 1001e4 which is a more precise result for the operation.
",4,6800810
6794017,"
There are many ways that you can do this.
If you happen to know that the second argument to z_distance is always going to be some fixed value, then you could convert the function into a comparator by writing an auxiliary function that actually does the comparison.  For example:
If you don't know what the second parameter to the z_distance function should be, or it can only be determined at runtime, then you may need to use a function object.  A function object (sometimes called a functor) is an object that mimics a regular function.  You can invoke it by passing in some number of parameters, but because it's an object the function that ends up getting called can access local state in addition to the parameters.  One such function object you could build might look like this:
Now, if you wanted to sort everything at some time t, you could write
For more info on functors, and as a shameless plug, here's a chapter on functors that I wrote for a C++ course I taught a year ago.
Hope this helps!
",2,6793863
6793995,"
When you define
you can do
However, I don't know what to do with the second argument of your function z_distance(). Maybe you can get it from your files or you have to use a functor instead of a function to compare. For functor see the answer @templatetypedef gave.
Since you tagged VC++10, you can also use a C++0x feature: write a lambda expression (an adhoc function) to pass arguments:
",3,6793863
6794120,"
Overload the operator< to return &A < &B, and sort should work with just begin(), end() and nothing else.
So
And you should be able to call it like this.
",2,6793863
6793953,"
Okay, here's where you're confused...
The function compares two elements at a time, readjusting the internal container (tree or whatever) based on the result.  So, all C++ needs to know in the STL functions is is elmement A less than element B based on your function.
So, for all you care your comparison function can compare their distances, first names of people, or whatever the heck you want.  The function just has to return true if one element is less than the other, and C++ will handle how to sort with it.
",1,6793863
6790833,"
If you put in an array, the array name is essentially a pointer to the first element, and the array name + x is the poitner to the xth element - so you have this part correct.
The problem is that this is not the case for a vector, which is why you need to use the .begin() and .end() functions to get the pointer to these locations.
You could try sorting by pulling the addresses of the dereferenced start/end elements - that might let you treat a vector the same as an array.
",2,6790659
6790825,"
In your code, input_data is a reference, but sort would need it to be a pointer to the start of an array. It should be:
Although it would be proper STL usage to make such a template that the user can provide any kind of random access begin and end iterators instead. Thus you could later switch to a vector or any other container that sort can work on…
",2,6790659
6790688,"
I hope the argument you're passing is actually a reference to the first element in an array.
",1,6790659
6771418,"
You need to combine the two criteria into one. 
Heres an example of how you'd sort a struct with a first and second field 
based on the first field, then the second field.
NOTE: implementation of compare_entry updated to use code from Nawaz.
",26,6771374
6755935,"
You could partition the file into chunks and pass your load function an fseek offset so that your load function can read from the file starting at fseek for some length (and load that into memory) and then operate on that information in the threads (using your secret sorting algorithm). So lets say, take the file size, divide by 8 and calculate fseek offsets or you could take fixed sized chunks and read until you run out of file contents to process (mapping 11gb of HD contents to RAM takes a while and quite a bit of resources so you might want to do this incremenetally). Does this make sense to you?
",0,6755899
6756054,"
A thread could load into memory in chunks, passing each chunk to its own thread for processing, so that processing can start as early as possible. I don't think that it's a good idea to have multiple threads trying to read from the same file at the same time.
",0,6755899
6765208,"
Solution 1: Reserve FILE_SIZE memory on the heap, start one thread for reading the file, report back as soon as the reading hits DATA_READED/NUMBER_OF_DESIRED_THREADS_FOR_PROCESSING value start a thread that processes that block of readed data from memory, increment the pointer for reading by DATA_READED/NUMBER_OF_DESIRED_THREADS_FOR_PROCESSING.Repeat.
Solution 2: Reserve FILE_SIZE memory ,create NUMBER_OF_DESIRED_THREADS_FOR_PROCESSING and the same number of queues , when reading (again one thread for disk IO), when a chunk is readed distribute the buffer pointers and size of data to process to thread's queues via some locking mechanism. That way all the threads will start working as soon as data is available.
Hans Passant is right if you could use more disks, then you should assign multiple threads to read chunks
",0,6755899
6680619,"
Why not cache results in say an (std::vector), sort the vector, then iterate over the sorted vector to perform your processing?
For example:
",3,6680446
6671315,"
If you want only the internal vectors sorted, then you can simply use the default sorting order:
This example uses the latest version of the standard. An example for older C++ compilers would be a little more verbose.
",2,6671167
6671218,"
The std::sort function uses the std::less<T> function for the default ordering. To get reverse order, explicitly use the std::greater<T> function instead.
I'd just use a loop to go through the outer vector, then sort each inner vector separately. Unless I'm misunderstanding the question.
",3,6671167
6671251,"
You can't define functions in-line in C++03. The newest versions of GCC and MSVC support C++0x lambda functions, which you can use for this purpose.
",2,6671167
6671267,"
I think this should be pretty close
",2,6671167
6626490,"
That entirely depends on how you store the UTF-8 characters and how your comparer looks like. The sort function is completely agnostic of the elements it sorts.
But you probably mean “… when stored in a char array” and then the answer is no since the chars will store individual bytes of a given UTF-8 character, instead of the logical character. The sort function sorts elements delimited by iterators. sort works only if the iterators / the elements they refer to are aware of the data that they contain. This isn’t the case for an array of chars that encode UTF-8.
The “correct” solution here is to parse the UTF-8 input into an array of proper (normalised) Unicode code points, sort those, and translate back to UTF-8.
",8,6626423
6626738,"
All that is required is the proper comparison function. You can probably find one in ICU - International Components for Unicode . Look specifically at Collation.
",2,6626423
6626578,"
c++0x supports UTF
This has nothing to do with STL.
",1,6626423
6626591,"
I assume that you refer to the Standard Template Library - and the answer is no.
None of the standard libraries has a text string type. There are char arrays, - but that's just a vector of bytes. There is std::string but that's a string of bytes (or 16bit words, or anything like that) basically. It has no notion of characters, let alone encodings.
",1,6626423
6576016,"
Your operator< should take its parameters by reference-to-const, I think that might be it:
",8,6575993
6576007,"
check the post How to use std::sort with a vector of structures and compare function? . it explains how to use sort with a customized predicate function
",0,6575993
6567699,"
Implementations are free to use any efficient sorting algorithm they want so this is highly implementation dependant
However I have seen a performance comparison of libstdc++ as used on linux and against libc++ the new C++ library developed by Apple/LLVM. Both these libraries are very efficient on sorted or reverse sorted data (much faster then on a random list) with the new library being considerable faster then the old and recognizing many more patterns.
To be certain you should consider doing your own benchmarks.
",26,6567326
6567359,"
No. Also, it's not logical to have is_sorted() called for any STL implementation. Since, is_sorted() is available already as a stand-alone. And many users may not want to waste execution cycles unnecessarily to call that function when they already know that their container is not sorted.
STL also should be following the C++ philosophy: ""pay per use"".
",20,6567326
6575580,"
Wow!  Did you have optimizations all the way cranked up?
 the results of your code on my platform (note the values on the vertical axis).
",11,6567326
6567802,"
I suggest you read this comparison of sorting algorithms, it is very well done and informative, it compares a number of sorting algorithms with each other and with GCC's implementation of std::sort. You will notice, in the charts on the given link, that the performance of std::sort for ""almost sorted"" and ""almost reverse"" are linear in the number of elements to sort, that is, O(n). So, no guarantee, but you can easily expect that an almost sorted list will be sorted in almost linear-time. But, of course, it does not do a is_sorted check, and even if it will sort a sorted array in linear-time, it won't be as fast as doing a is_sorted check and skipping the sorting altogether. It is your decision to determine if it is better to check before sorting or not.
",4,6567326
6758079,"
The standard sanctions only std::sort implementations with complexity O(n log n):

Complexity: Approximately N log N (where N == last - first) comparisons on the average.

See section 25.3.1.1 Sorting [lib.sort] (ISO/IEC 14882:2003(E)).
Thus, the set of allowed sorting functions is limited, and you are right that it does not guarantee linear complexity.

Ideal behavior for a sort is O(n), but this is not possible in the average case.

Of course the average case is not necessarily the exact case you have right now, so for corner cases, there's not much of a guarantee.
",4,6567326
6568197,"
And why would any implementation do that check? What would it gain? -- Nothing in average. A good design rule is not to clutter implementation with optimizations for corner cases which make no difference in average. This example is similar to check for self-assignment. A simple answer: don't do it.
",2,6567326
6568371,"
There's no guarantee that it'll check this. Some implementations will do it , others probably won't.
However, if you suspect that your input might already be sorted (or nearly sorted), std::stable_sort might be a better option.
",1,6567326
6499537,"
You would do something like this:
This generates a vector of indices, and then sorts them based on the vector of actual stuff.
",4,6499413
6499559,"
",4,6499413
6499544,"
No; you have to do it yourself.
Fortunately, it's quite easy! (which may be why it's not provided)

Consider input vector v
Create a vector of indexes 0..n, where n is the size of your input v
std::sort the vector of indexes, providing a reference to the input v, and a custom comparator that returns v[left] < v[right].

",2,6499413
6499712,"
Another example, using boost::ref...
",1,6499413
41062340,"
With just a few modifications to Nicol Bolas' answer, this allows any random access iterator to be used as input (as long as it is a random iterator and has a reference type member).
The comparison function could also be provided (just like in std::sort, the default being std::less).
A working example could be find here.
",0,6499413
6498128,"
You seem to be looking for the std::priority_queue, which is located in the <queue> header file. With push(), you can insert an element into the priority queue; with top(), you will get the currently largest element in the queue (or the smallest one, depending on how you implement operator<); and with pop(), you will remove the largest/smallest element.
As far as I know, it's implemented with a heap, which makes the time complexity of each push and pop operation O(lg n). Simply looking at the top element is done in O(1).
",20,6498098
6498144,"
There are four sorted containers in the C++ standard library:
std::set - A sorted sequence of unique values.
std::map - A sorted sequence of unique key/value pairs.
std::multiset - A sorted sequence of values (possible repeats).
std::multimap - A sorted sequence of key/value pairs (possible repeats).
If you just want a sorted queue, then what you are looking for is std::priority_queue, which is a container adaptor rather than a stand-alone container.
If you want to store your own types in a priority_queue then you need to define operator< for your class.
Creating a priority_queue of Persons would then give you a queue with the oldest people at the front.
",53,6498098
6498206,"
The STL container choice flowchart (from this question):

",51,6498098
6498110,"
std::map for sorted container
std::queue for queue.
std::priority_queue for sorted queue
",7,6498098
6498210,"
std::set is an ordered collection; iterating over it will give you the elements in order (either as defined by the < operator or a custom predicate). Finding and removing the first element are O(1).
Alternatively you could use std::priority_queue, which is basically a heap and allows efficient insert and least item removal.
In fact it's harder to find unordered (hashed) containers - they weren't part of the original standard, although they were widely available in non-standard form.
Of course you may find that simply holding your items in a sorted vector is faster, even if it is theoretically slower, if the number of items is not significantly large.
",2,6498098
6456042,"
The first two params of the callback are designed to be the elements to compare on this iteration, the third param is designed to be used for order, column, and other criteria. The callback performs the comparison and returns an integer value representing what direction to move an element, if any.
In that sense it can be a stable sort if you compared lparam ids and did a less than or subtraction comparison ensuring a non-decreasing order. In reality you could implement the callback differently or pass additional sort criteria in the third parameter to do ascending, descending, or some other custom sorting comparison so there is no guarantee.
As a side not it is probably more efficient to maintain a container of data separate from the control like a std::vector and perform a stable sort algorithm on that optimized container like std::sort then use LVS_OWNERDATA style on the CListCtrl to draw from the container of data via the LVN_GETDISPINFO callback.
",1,6455187
6445032,"
Either you declare sort as a template function with one template argument (Compare) inside the class. Then your definition has to look as follows:
And you also need to remove the now redundant friend class Compare declaration from your List class.
Or you keep Compare and sort as-is. In this case, simply don’t have sort as a template, and omit the Compare template argument:
Of course this only works if you have defined (not just declared!) the class Compare before this function.
But this second solution would be highly unorthodox and pretty useless since the compare argument doesn’t make much sense: there is only one Compare class and the user cannot change it. Normally, this should be a template argument (first solution).
",4,6444986
6434403,"
You are storing Vertex * in the container not Vertex. When you call std::sort, you're actually sorting the value of the pointers, not the items themselves.
If you really need to be storing pointers (which I doubt), you can use a workaround like this (untested):
",6,6434357
6434449,"
If you want to save yourself writing all those classes yourself (and violating the double-underscore rule!), you could consider just using a
and using std::sort. Pairs are by default lexicographically compared (which is what you asked for), so you don't need any extra code.
",1,6434357
6434444,"
You are sorting pointers, not the actual Vertex objects. Try this:
I.e. get rid of the pointer in the list container and the new's in the calls to push_back.
",1,6434357
6434423,"
Seems like you want to sort be abolute values for some reason:
Try this:
Note: you do not need to call b.x() to get the member of another object when you are the same class. You can just access the other member.
Note: Don't use double underscore in your identifiers. Prefer not to prefix identifiers with underscore.
",0,6434357
6430365,"
A linked list will be O(1) and an array will be O(n) for a move operation as you have described. For small n the array will probably be faster, but the only way to know for sure is to benchmark.
In a case like this I would code what's clearest and only worry about efficiency if it proves to be a bottleneck.
P.S. I made an assumption that you already had a pointer to the character you want to move. If this is not the case, then finding the character will be O(n) in the linked list and you will lose any advantages it might have.
",3,6430303
6430403,"
Use an array.  The linked list will be huge and unwieldy for storage of char data.
",1,6430303
6430400,"
A linked list would be a good approach since you don't need to move all the intermediate elements around. std::list works just fine, combined with splice(). You will need an iterator to the element you want to move to the front:
(Using the pretty printer for a quick demo.)
As others have said, whether that's more efficient that a random-access container depends on how you are tracking the element that you want to move.

Update: In light of Steve's remarks I should like to offer a raw C-array solution, too. It has the benefit that you can access it by position in O(1) time and that it requires minimum space:
The rotate call could be wrapped in a function:
",1,6430303
6430399,"
In C++, you can use a vector instead of array or linked list. The complexity of a Linked List is O(1) like @Mark Ransom said. With the vector, you can use the command rotate to perform the action you desire. The complexity is determined by the number of swaps. 
From MSDN, how to use rotate:
Or you can do it with arrays:
How fast is this? I don't know. I haven't benchmarked it. But it is much easier than having to manually swap elements of an array.
",1,6430303
6430402,"
The array will be O(1) to find the item and O(n) to move it and the other items into the correct position. The linked list will be O(n) to find the item and O(1) to move everything to the right position. The complexity is the same either way.
They're both easy to implement, so implement both of them and run tests to see which one lets your program run faster with real-world data.
",0,6430303
6430367,"
C++ arrays are linked lists, so moving an element to the front of your list is cheap, provided you already know where the element is (i.e. you have an iterator on it). Using a vector would cause the entire list to be shifted each time an element is pushed in front of it.
",-2,6430303
6398215,"
This is a solved problem, as explained on this wiki page: http://en.wikipedia.org/wiki/External_sorting
Basically, read in some set amount, sort it, save into a file, and repeat.
Then, read in a smaller amount from each file, sort these, and continue until done.
UPDATE: 
You may want to look at the java code he uses, it sounds like he solved what you need.
http://www.codeodor.com/index.cfm/2007/5/10/Sorting-really-BIG-files/1194
",4,6398174
6398199,"
One strategy is to sort chunks of it with quick sort or some other fast memory sort algorithm and then do a merge sort of these chunks.
",4,6398174
6398195,"
If they won't fit into memory, they won't fit into memory, and that's pretty much that. You can't memory map above your memory limit- a sort algorithm would need all the data at once.
However, you could write a specialized sort algorithm. If you are sorting by byte, for example, you should be able to just loop through the file in chunks, count the occurrence of each byte, and then emit them in order. This could also work for if you're sorting each larger type as long as there are plenty of duplicates to be found.
",0,6398174
6398206,"
Using a memory mapped file should work. It needs to fit in your address space (~2 Gb on 32-bit) or LOTS (if 64-bit).
Pages of the mapped file will be swapped in/out as you access them, much like the virtual swap file, so it should work.
",0,6398174
6294681,"
The sort algorithm will call the comparison function multiple times, each time with two entries from your array. You don't know and shouldn't care how many times or what order your comparison function will be called.
",4,6294359
6294863,"
Check for yourself:
Just be aware that the results are only applicable to your specific implementation.
",1,6294359
6294802,"
Sorting algorithm could be any possible algorithm. You don't need to know which one is used (bubble sort, quicksort, etc.). The algorithm will successively choose a pair of data, and compare them, then decide if it moves them or not. At each comparison, your compare function will tell to the algorithm if first element is smaller than second, or not. Sorting function will just receive two values pointed by the iterator.
",0,6294359
6230257,"
The use of quicksort and introsort (which is a variant of the former, with guaranteed O(n log n) performance achieved by switching to heapsort on worst case inputs) in place of other theoretically better algorithms like mergesort is due to the fact that the average case is the same, and the constants much lower (in the constants you can include the fact that it can be sorted in place, so there are no reallocations, and copies). And the worst case is bad, but quite improvable. In general, it is assumed that the performance of sort is O( n log n ). 
If you are concerned about the hidden constants, then the question is not theoretical, but rather a question of performance. When trying to optimize you are better off measuring the algorithm on your actual data, analyzing the results of the measurement, and then determining where the time is spent and if it can be improved. But that is a completely different problem from the theoretical one.
",5,6230180
6230493,"
If your standard library makes no guarantees beyond ISO 14882, then there seems to be no formal bound on the worst-case behavior of sort() — only the average complexity is listed.  There's a footnote in the standard which mentions you should use stable_sort() or partial_sort() instead of sort() if you care:
http://www.kuzbass.ru:8086/docs/isocpp/lib-algorithms.html#lib.alg.sorting

25.3.1.1 - sort [lib.sort]

Effects: Sorts the elements in the range [first, last).",3,6230180
6230278,"
Introsort has actually O(n log(n)) worst-case running time, not O(n^2).
Also see this remark at the SGI STL Specs:

Earlier versions of sort used the
  quicksort algorithm, using a pivot
  chosen by median of three. Quicksort
  has O(N log(N)) average complexity,
  but quadratic worst-case complexity.
  The current implementation of sort, however, uses the introsort
  algorithm whose
  worst case complexity is O(N log(N)).
  Introsort is very similar to
  median-of-three quicksort, and is at
  least as fast as quicksort on average.

",2,6230180
6230276,"
Yes it is a variation of quicksort, using heapsort for suspected pathological quicksort input. It looks at recursion depth and when it falls too deep it sorts using heapsort removing any pathological behavior. This guarantees N log N.  The constant overhead of N log N (qsort vs heapsort) is not something to worry about. 
Insertion sort is used when there are very few elements (about 16). 
",1,6230180
6230241,"
http://en.wikipedia.org/wiki/Sorting_algorithm lists several sorting algorithms with n^2 performance. It has one with n! performance. It also lists several non-comparison sorts which have performance based on other factors.
",0,6230180
6218721,"
The correct answer, as others have pointed out, is to learn what a ""strict weak ordering"" is.  In particular, if comp(x,y) is true, then comp(y,x) has to be false.  (Note that this implies that comp(x,x) is false.)
That is all you need to know to correct your problem.  The sort algorithm makes no promises at all if your comparison function breaks the rules.
If you are curious what actually went wrong, your library's sort routine probably uses quicksort internally.  Quicksort works by repeatedly finding a pair of ""out of order"" elements in the sequence and swapping them.  If your comparison tells the algorithm that a,b is ""out of order"", and it also tells the algorithm that b,a is ""out of order"", then the algorithm can wind up swapping them back and forth over and over forever.
",6,6218591
6218621,"
If you're looking for a detailed explanation of what 'strict weak ordering' is, here's some good reading material: Order I Say!
If you're looking for help fixing your comparison functor, you'll need to actually post it.
",6,6218591
6218624,"
If the items are the same, one does not go before the other.  The documentation was quite clear in stating that you should return false in that case.
",6,6218591
6218665,"
The actual rule is specified in the C++ standard, in 25.3[lib.alg.sorting]/2

Compare is used as a function object which returns true if the first argument is less than the second, and false otherwise.

The case when the arguments are equal falls under ""otherwise"".
",3,6218591
6218650,"
A sorting algorithm could easily loop because you're saying that A < B AND B < A when they're equal.  Thus the algorithm might infinitely try to swap elements A and B, trying to get them in the correct order.
",1,6218591
6218622,"
Strict weak ordering means a < b == true and when you return true for equality its a <= b == true. This requirement is needed for optimality for different sort algorithms.
",0,6218591
6212709,"
",21,6212619
6213013,"
An alternate solution is to construct a vector of the keys, sort the vector, and print per that sorted vector. This will be considerably faster than the approaches that constructed a map from the ordered map, but will also involve more code.
",17,6212619
6212682,"
Are you sure you need this? Because that is not possible. An unordered_map is a hash container, that is, the keys are hashed. Inside of the container, they don't have the same representation as on the outside. Even the name implies that you can't sort it. It's one of the criteria to choose a hash container: You do not need a specific order.
If you do, get a normal map. The keys are automatically sorted in a strict-weak ordering. If you need another sort, write your own comparator.
If you only need to print it sorted, the following may be inefficient, but it's as close as you'll get if you still want to keep the unordered_map.
Example on Ideone.
Note that in C++0x, you can replace the two overloads with one function with a default template argument:
",12,6212619
52911135,"
Similar to David's answer, we can use std::set to sort the key first:
",0,6212619
53939447,"
You can use vector to store your key value pairs, then sort them in vector, put them back at map at last.
Compile with following commands.
The result is:
",-1,6212619
6175524,"
This doesn't work either for types that have pointers to ""related"" objects. Such pointers have many of the issues associated with ""inner"" pointers, but it's a lot harder to prove precisely what a ""related"" object is.
A specific kind of ""related"" objects are objects with backpointers. If object A and B are bit-swapped, and A and C pointed to each other, then afterwards B will point to C but C will point to A.
",2,6174955
6175034,"
Any type that is not a POD type is not usable with qsort(). There might be more types that are usable with qsort() if you consider C++0x, as it changes definition of POD. If you are going to use non-POD types with qsort() then you are in the land of UBs and daemons will fly out of your nose.
",5,6174955
6175109,"
You are completely mistaken. Any non-POD type working with qsort is complete and utter luck. Just because it happens to work for you on your platform with your compiler on a blue moon if you sacrifice the blood of a virgin to the Gods and do a little dance first doesn't mean that it actually works.
Oh, and here's another one for not trivially movable- types whose instances are externally observed. You move it, but you don't notify the observer, because you never called the swap or copy construction functions.
",1,6174955
6175424,"
""If I'm not mistaken, it will work with all standard containers""
The whole question boils down to, in what implementation? Do you want to code to the standard, or do you want to code to implementation details of the compiler you have in front of you today? If the latter, then if all your tests pass I guess it works.
If you're asking about the C++ programming language, then qsort is required to work only for POD types. If you're asking about a specific implementation, which one? If you're asking about all implementations, then you've sort of missed your chance, since the best place for that kind of straw poll was C++0x working group meetings, since they gathered together representatives of pretty much every organization with an actively-maintained C++ implementation.
For what it's worth, I can pretty easily imagine an implementation of std::list in which a list node is embedded in the list object itself, and used as a head/tail sentinel. I don't know what implementations (if any) actually do that, since it's also common to use a null pointer as a head/tail sentinel, but certainly there are some advantages to implementing a doubly-linked list with a dummy node at each end. An instance of such a std::list would of course not be trivially movable, since the nodes for its first and last elements would no longer point to the sentinel. Its swap implementation and (in C++0x) its move constructor would account for this by updating those first and last nodes.
There is nothing to stop your compiler switching to this implementation of std::list in its next release, although that would break binary compatibility so given how most compilers are managed it would have to be a major release.
Similarly, the map/set/multimap/multiset quartet could have nodes that point to their parents. Debugging iterators for any container might conceivably contain a pointer to the container. To do what you want, you'd have to (at least) rule out the existence of any pointer into the container in any part of its implementation, and a sweeping statement like ""no implementation uses any of these tricks"" is pretty unwise. The whole point of having a standard is to make statements about all conforming implementations, so if you haven't deduced your conclusion from the standard, then even if your statement is true today it could become untrue tomorrow.
",1,6174955
6131299,"
If its not a homework, then why don't you use std::sort providing a comparer as third argument?
",7,6131247
6132249,"
If you still want to use your own quick sort, this is what it would look like.  I assume you are using std::string.
Then you would call it like this:

quickSortCritics(your_vector, 0,
  your_vector.size() - 1);

",0,6131247
6086489,"
If you look at the implementation of the above algorithms, you'll see that lower/upper_bound don't do 3-way branches at all, binary_search does only in the last iteration to check equality and about sort() I don't know but I'm almost sure it doesn't do 3-way branches too. So your 'optimization' won't give you any boost. The opposite is true, your comparisons will be slower.
",4,6086446
6083464,"
The ASCII value of 'A' and 'a' are not the same. 'A' == 65 and 'a' == 97.
So, when you compare, you need to compare using either tolower or toupper to make sure that your value is right. After you make that comparison, you need to then also compare to see if it's upper versus lowercase (to ensure upper, then lower ordering).
",7,6083432
6084023,"
You first need to do a case insensitive comparison and, if the letters are the same, a case sensitive comparison.
#include <stdlib.h>
#include<iostream.h>
#include<string.h>
int main (void)
{
    char string[128], temp;
    int n, i, j;

    printf(""\nEnter string: "");
    gets(string);
    n = strlen(string);

    for (i=0; i<n-1; i++)
    {
        for (j=i+1; j<n; j++)
        {
            int  s = tolower(string[i]) - tolower(string[j]);
            if ( s == 0 )
            {   // letters are the same... now watch out for case
                s = string[i] - string[j];
            }

            if (s > 0)
            {
                temp = string[i];
                string[i] = string[j];
                string[j] = temp;
            }
        }
    }
    printf(""\n%s"", string);
    printf(""\n"");
    return 0;
}
",4,6083432
6083489,"
You need a customer comparison function to pass to sort (or qsort).
",3,6083432
6083503,"
This doesn't work
A file only has one position. You have to do your seeks when you need them, when changing from reading to writing or vice versa.
",3,6082862
6059635,"
Short of any other specific requirements, you should default to a std::vector.  You mention that you want to remove items later; this implies that you may want to consider a std::list instead.
To find the median, you can use std::nth_element, asking it to pivot on the N/2-th (or (N-1)/2-th) element.  This runs in O(N) time.
",6,6059535
6037416,"
By default, std::sort uses using operator<, but you can also supply a comparison function object.
So:
",8,6037338
6037499,"
Another way is usage std::set container for storing your objects. And you always will have sorted container. All you need is define operator < for stored classes.
Usage vector with push_back is not effective way in terms of time. It cause unnecessary memory rellocations.
",-1,6037338
5957608,"
Voilà, a sorted set.
",5,5957421
5957473,"
unordered_set doesn't have non-const iterators, because if you could mutate the item pointed to by an iterator you could violate the invariants of the set (uniqueness among others). Additionally if you sorted an unordered_set you would no longer be able to look up the item in the container anymore (assuming it works by hash).
If you really want to sort the set of items, you'll need to copy it into a vector first and then sort that. But in that case have you considered if unordered_set is the right container for you in the first place? What about using a normal set which is ordered at the expense of lookups being slower.
",7,5957421
5907819,"
If I've understood correctly your algorithm should take O( nlogn + mlogm [sort both arrays] + n + m [to go through the arrays and compare]).
It may not be much of an optimization but you try to sort just one of the arrays and use binary search to check if the elements of the other array are present or not. So now it should take O( n [to copy one array as the new array] + nlogn [to sort it] + mlogn [to binary search the elements of the second into the sorted new one] ).
HTH
",0,5907478
5907832,"
Sorting object might be expensive, so I would try to avoid this.
One faster way might be to create an index for each array using a std::hash_map with the string as has index and the array index as value. You get two containers that can be iterated at one time. The iterator for the lesser will be advanced until you find a match or the other points to a lesser value. This will lead you to a predictable iteration count.
",0,5907478
5907900,"
The possible solution is to use unordered_map. The algorithm whould be as following:
The complexity of this algorithm is aproximatelty O(n+m)
",0,5907478
5907905,"
I feel that sorting is not needed. You can use following algorithm.

Start with the first element of
recordarray1; put into the new array
Search elements in recordarray2.
If the element is found increment count in new array. Also set the
recordarray2[N]::count to negative value; so that it will not be checked again in step 3
Put all the elements from
recordarray2 which doesn't have
count set to negative into new
array. If negative count is
encountered then simply change it to
positive.

Note: This algorithm doesn't take care if you have similar string elements in the same array. Also don't use string as a variable name. As it's also a typename as std::string.
",-1,5907478
5897358,"
In C++0x/11 we get std::begin and std::end which are overloaded for arrays:
If you don't have access to C++0x, it isn't hard to write them yourself:
",98,5897319
5897332,"
In C++11:
",62,5897319
5897354,"
If you don't know the size, you can use:
Even if you do know the size, it's a good idea to code it this way as it will reduce the possibility of a bug if the array size is changed later.
",28,5897319
5897355,"
You can sort it std::sort(v, v + 2000)
",16,5897319
31912284,"
",3,5897319
42742731,"
you can use sort() in C++ STL.  sort() function Syntax : 
",3,5897319
42943836,"
C++ sorting using sort function
",2,5897319
50238670,"
It is as simple as that.....c++ is providing you a built-in function in STL(Standard Template Library) called sort(arr_name ,arr_name+arr_size) which runs 20% to 50% faster than the hand-coded quick-sort. Also you better include the header file  
Here is the sample code for it's usage:
",2,5897319
35811331,"
sorting method without std::sort:
Run complete example:
",0,5897319
42956310,"
Use the C++ std::sort function:
",0,5897319
54226360,"
",0,5897319
35146054,"
you can use,
",-1,5897319
5887635,"
It's almost certainly easiest to use std::sort instead of qsort:
Edit: to keep the comparison separate from the items being compared, you use a separate function or functor to do the comparison, and pass that to std::sort. There are a few things about your class that you really want to change in any case though -- at the very least, since your Point::X(), Point::Y() and Point::Z() don't modify the Point object, you want to make them const member functions. Once you've done that, the sorting is fairly trivial:
Technically, I suppose I should add one more minor detail: if the x value in any of your points is a NaN, this won't work correctly. A NaN isn't equal to anything (not even itself) which violates the strict weak ordering required for std::sort.
",1,5887524
5887633,"
The arguments of the cmp function are actually const Point *px in your case. You may not be able to declare them as arguments this way, but you can surely cast the void pointers later.
Further reference here.
",0,5887524
5875372,"
std::sort (and other STL functions) take comparator objects by value, so your object is being copied, but the derived part (including its vtbl) is being ""sliced away"".
You could wrap your object in a proxy:
",8,5875323
8130929,"
Say the list is { 90, 13, 5, 12 }. Start a pointer at the beginning.
{ * 90, 13, 5, 12 }
Find the smallest member after the pointer and move it just before the pointer.
{ 5, * 90, 13, 12 }
Find the smallest member after the pointer and move it just before the pointer.
{ 5, 12, * 90, 13 }
Again.
{ 5, 12, 13, * 90 }
Again.
{ 5, 12, 13, 90 }
Pointer runs off the end of the list, we're done, list is sorted.
",1,8130885
54012012,"
Here is C++ implementation of selection sort on linked list without STL.
To ease testing of program for different cases , this program create linked list of given size with random numbers.
For more details visit-
https://github.com/SahdevKansal02/Data-Structures-And-Algorithms.git
",0,8130885
8117115,"
I think that k should be a double here :)
",2,8117070
8117135,"
You're initializing several values at the start of your quickSort method that may need to be doubles. Specifically k and p. Also it needs to take a double high and low value as parameters.
A quick audit through for data types will probably solve your problem :)
",1,8117070
8108742,"
You can sort the range directly:
Even more hip: a template:
",4,8108712
8108739,"
This allocates place for the items, but does not change the size() of the vector. In effect, end() is the same as begin() so you're sorting an empty vector. You should use
",2,8108712
8100250,"
The problem is that the graph that's in scope in the call to kruskals is the global graph, declared as a vector<pair<int,Edges> >. So you can't use EdgeLess to sort it, because EdgeLess compares Edgeses, not pair<int,Edges>es.
Might I suggest that it's needlessly confusing to have a global variable named graph that has type vector<pair<int,Edges> > alongside various local variables named graph that have type vector<pair<Edges> >? If you really need all of these distinct variables, with their current scopes and current types, then you should probably rename the global variable to something that indicates that it's global.
",2,8100007
8088118,"
This is the Stooge sort.  It's an algorithm constructed to show that amateurs really shouldn't implement their own algorithms without properly analyzing them first.  Its running time is approximately O(n^3).  
",10,8087969
8088015,"
It's not too hard to do the calc.

Every time this algorithm do 3 calls to itself splitting into 3 (equal) part the portion of the input of the current step. Note: The first call and the third are the same.
The local complexity is just a O(1) (which means constant) since it will do just a swap, an if and the calculation of k

",2,8087969
8044420,"
How many entries do you have? Could an unsigned 32-bit integer be used as an index (would allow 4,294,967,296 indexes) which could be used to identify how to sort the original array?
i.e. create pairs of 32-bit indexes and account balances, sort on the balances then use the 32 bit indexes to work out what order the original data should be in?
",1,8044343
8038176,"
Feed the lists as individual lines into it.
",3,8038063
8048615,"
To do this in Tcl, assuming there's not huge amounts of data (a few MB wouldn't be “huge”) the easiest way would be:
# Read the values in from stdin, break into lists of lists
foreach line [split [read stdin] ""\n""] {
    lappend records [split $line "",""]
}

# Sort twice, first by secondary key then by primary (lsort is _stable_)
set records [lsort -index 1 -real $records]
set records [lsort -index 0 -real $records]

# Write the values back out to stdout
foreach record $records {
    puts [join $record "",""]
}

If you're using anything more complex than simple numbers, consider using the csv package in Tcllib for parsing and formatting, as it will deal with many syntactic issues that crop up in Real Data. If you're dealing with a lot of data (where “lot” depends on how much memory you deploy with) then consider using a more stream-oriented method for handling the data (and there are a few other optimizations in the memory handling) and you might also want to use the -command option to lsort to supply a custom comparator so you can sort only once; the performance hit of a custom comparator is quite high, alas, but for many records the reduced number of comparisons will win out. Or shove the data into a database like SQLite or Postgres.
",3,8038063
8038139,"
You can use STL's sort, and then all you have to do is to write a comparison function that does what you want (the example in the link should be good enough).
",1,8038063
8049044,"
Since you asked for a Tcl solution:
Hope that helps.
",1,8038063
15797086,"
Here is a C++ solution:
",0,8038063
8014641,"
if there was a switch you have to re-evaluate a board, because there might be previous positions where now you could find an enhancement.
Note that you are going to find only a local minimum with those swappings. You might won't be able to find any enhancements but that doesn't mean that's the best board configuration.
One way to find a better configuration is to shuffle a board and search for a new local minumum, or use an algorithm-skeleten that allows you to make bigger jumps in the state, eg: Simulated annealing.
",0,8014410
8003716,"
Shell Sort consists of many insertion sorts that are performed on sub-arrays of the original array.
The code you have provided is insertion sort.
To get shell sort, it would be roughly having other fors around your code changing h (that gap in shell sort) and starting index of the sub-array and inside, instead of moving from k to k-1, you move from k to k+h (or k-h depending on which direction you do the insertion sort)
",5,8003600
8003696,"
I think you're right, that does look a lot like an insertion sort.
This fragment assumes A[0] is already inserted. If n == 0, then the k > 0 check will fail and execution will continue at A[k] = key;, properly storing the first element into the array.
This fragment also assumes that A[0:n-1] is already sorted. It inspects A[n] and starts scanning the array backward, moving forward one place every element that is larger than the original A[n] key.
Once the scanning encounters an element less than or equal to the key, it inserts it in that location.
",1,8003600
8024984,"
It's called insertion sort because the line A[k] = key inserts the current value in the correct position in the partially sorted array.
",0,8003600
7996190,"
std::sort only works on random access containers.  And the only non-random access container in the standard library that it makes sense to sort is std::list.
std::sort certainly doesn't work on associative containers as you seem to think.  What sense would that make?  Associative containers are accessed by the value of their key, not by position.
As noted by Mike, C++11 also has std::forward_list, which, by no accident, also has it's own sort function.
",12,7996116
7996207,"
std::sort only works for random access iterators, but a std::list only provides biderectional iterators. Since it therefore cannot be used with std::sort, it needs its own implementation, which is also likely to be more optimized for a doubly linked list.
Likewise you cannot use std::map or std::set iterators with std::sort. But for these you don't need it anyway, as they are always sorted.
As a side note, there are also std::map::find and the like. These are indeed not required, as you can use all iterators with std::find. But the member function versions provide optimized algorithms for the individual containers, which are more efficient than std::find's linear complexity.
",6,7996116
7981341,"
You are asked to use recursion.  Your problem sorts a size n array.  The first step is sorting n-1 elements of that array.
Consider m = n-1.  Can you apply your problem to a size m array?  i.e. sort the first m-1 elements and then place the m'th element in its correct position?
Consider k = m-1.  Can you do the same with a size k array?
Do you see how you can use recursion with this problem?
Also consider how you will end the recursion; what will you do with a size 1 array?
",1,7975787
7962756,"
Getting the sorting to work is pretty easy -- just define an operator< for that type:
Note that you may want (for example) to use the student's first name as a secondary sort field, to be used only when/if the last names are identical.
As far as reading the data for a student goes, you normally want to do that in a function named operator>>, like:
If at all reasonable, I'd avoid making the entry interactive as you have though. Although common in student assignments, it renders the program nearly unusable. Printing out the information is normally done with operator<<, which is essentially a mirror image of operator>> (i.e., it writes instead of reads, but should write the fields in the same order, in a format that operator>> can read).
",0,7962702
7933001,"
First, it's completely normal for the comparison function to be called more times than you have elements in the collection. That's part of what's meant when we say a sorting algorithm's complexity is O(n log n), for example. The number of comparisons performed on a collection of size n will be about n × log(n). (In fact, n is pretty much the minimum number of times to call it; otherwise, we wouldn't even be able to tell whether the collection was already sorted in the first place.)
Second, you get an error when you make the parameters be const references because you've declared GetDisplayOrder as a non-const method. You're not allowed to call non-const member functions on a const object because the compiler assumes the method will attempt to modify the object, even though in this case it doesn't modify anything. Add const to the end of the declaration and definition:
Finally, there's the matter of the segmentation faults. The code you've shown here isn't enough to pinpoint a cause. You're correct that changing the way you pass the iterators to sort shouldn't have any effect. My suspicion is that your Item class needs a copy constructor and an assignment operator, but that they either aren't implemented, or they're not implemented properly. Sorting a vector obviously involves moving items around in the collection, and that requires a working assignment operator. Passing those items to your original comparison function, which accepted parameters by value instead of by const reference, requires a working copy constructor. If you're doing any dynamic memory allocation (such as with new or malloc) you need to make sure you either make a ""deep copy"" of the memory when you assign or copy an object, or you figure out a way for multiple objects to share the same allocation. If multiple objects think they all own the same block of memory, one of them is likely to free that memory before the others are finished with it, and that can certainly lead to segmentation faults (as you access freed memory).
",4,7932845
7933222,"
In addition to what Rob Kennedy said, try putting a breakpoint in std::swap (the std::sort actually swaps elements to move them around). You could even implement your own swap and do a little bit of ""printf debugging"" if you can't use the debugger for whatever reason.
When you hit the breakpoint, observe carefully whether objects are copied around correctly and ensure nothing gets corrupted. The idea is to try to locate the exact place of the corruption, that may not necessarily crash the program right away, but leads to ill effects later.
",0,7932845
7930664,"
Yes, you can use boost::bind:
",6,7930403
7930436,"
You need to provide the function as a callback:
Assuming your function is already static, I don't see any other problem.
",0,7930403
7907402,"
I believe that the following would be the optimal solution, at least based on time / space complexity:
Step 1:
Store the integers in a hash map, which holds the integer as a key and the count of the number of times it appears as the value. This is generally an O(n) operation and the insertion / updating of elements in the hash table should be constant time, on the average. If an integer is found to appear more than twice, you really don't have to increment the usage count further (if you don't want to).
Step 2: 
Perform a second pass over the integers. Look each up in the hash map and the first one with an appearance count of one is the one you were looking for (i.e., the first single appearing integer). This is also O(n), making the entire process O(n).
Some possible optimizations for special cases:
Optimization A: It may be possible to use a simple array instead of a hash table. This guarantees O(1) even in the worst case for counting the number of occurrences of a particular integer as well as the lookup of its appearance count. Also, this enhances real time performance, since the hash algorithm does not need to be executed. There may be a hit due to potentially poorer locality of reference (i.e., a larger sparse table vs. the hash table implementation with a reasonable load factor). However, this would be for very special cases of integer orderings and may be mitigated by the hash table's hash function producing pseudorandom bucket placements based on the incoming integers (i.e., poor locality of reference to begin with).
Each byte in the array would represent the count (up to 255) for the integer represented by the index of that byte. This would only be possible if the difference between the lowest integer and the highest (i.e., the cardinality of the domain of valid integers) was small enough such that this array would fit into memory. The index in the array of a particular integer would be its value minus the smallest integer present in the data set.
For example on modern hardware with a 64-bit OS, it is quite conceivable that a 4GB array can be allocated which can handle the entire domain of 32-bit integers. Even larger arrays are conceivable with sufficient memory.
The smallest and largest integers would have to be known before processing, or another linear pass through the data using the minmax algorithm to find out this information would be required. 
Optimization B: You could optimize Optimization A further, by using at most 2 bits per integer (One bit indicates presence and the other indicates multiplicity). This would allow for the representation of four integers per byte, extending the array implementation to handle a larger domain of integers for a given amount of available memory. More bit games could be played here to compress the representation further, but they would only support special cases of data coming in and therefore cannot be recommended for the still mostly general case.
",11,7907335
7907441,"
All this for no reason. Just using 2 for-loops & a variable would give you a simple O(n^2) algo. 
If you are taking all the trouble of using a hash map, then it might as well be what @Micheal Goldshteyn suggests
UPDATE: I know this question is 1 year old. But was looking through the questions I answered and came across this. Thought there is a better solution than using a hashtable.
When we say unique, we will have a pattern. Eg: [5, 5, 66, 66, 7, 1, 1, 77]. In this lets have moving window of 3. first consider (5,5,66). we can easily estab. that there is duplicate here. So move the window by 1 element so we get (5,66,66). Same here. move to next (66,66,7). Again dups here. next (66,7,1). No dups here! take the middle element as this has to be the first unique in the set. The left element belongs to the dup so could 1. Hence 7 is the first unique element.
space: O(1)
time: O(n) * O(m^2) = O(n) * 9 ≈ O(n)
",1,7907335
7907414,"
Inserting to a map is O(log n) not O(n log n) so inserting n keys will be n log n. also its better to use set.
",0,7907335
7907473,"
Although it's O(n^2), the following has small coefficients, isn't too bad on the cache, and uses memmem() which is fast.
",0,7907335
23519424,"
",0,7907335
25341550,"
@user3612419
",0,7907335
7894685,"
Use a map where the key is the ID number and the value is the quantity:
Loop through your list and update the corresponding entry in the map. You can use the [] operator on the map to access the value corresponding to a given key. For example, if you had an ID and the quantity from your data, you could do this:
That works without having to initialize the map because if the [] operator asks for an entry that doesn't yet exist in the map, it's automatically inserted with a default value, and the default value for int is zero.
Now, you can go through the map and find the prices of all your items. The map's iterator gives you a pair, where the first element is the map's key and the second element is the value for that key. You can write a loop like this to print the map's contents:
If you find the price for each item and multiply it by it->second, you'll have what you're looking for.
",4,7894600
7894755,"
A std::map would be useful - it's basically an array that's indexed by keys.  In your case, the item ID would be the key.  Normally you just put an element in a map with:
So for example, assuming readFromFile() fills in id and qty:
The first time through, the [] will create the element.  To iterate through the final list you can use standard iterators on a map, just like other STL containers.
",1,7894600
7894717,"
I would define a struct product to hold the information about each item.  The struct would hold the ID, quantity, and price.
You would make a std::map<int, product> where the index is the item's ID.
You would read in the price file, and for each line, make a new product with that ID and price, and then add it to your map, with the ID as the index.
You would then read in the sales file, and for each line, get the product by reference from the map by the ID, and add the number to the quantity.
Finally, you would iterate through the map, and write out each ID, and the quantity ordered multiplied by the price.
Did I understand correctly?
",0,7894600
7894738,"
This looks like a relational database set up.
One table will have records like [Item_ID, Quantity].
Another table will have records like [Item_ID, Price].  
Your task, should you choose to accept it, is to create two tables one for each file.  Use the Item_ID in the first table to find the quantity.  Use the Item_ID into the second table to find the price.  Multiply these two variables to determine the total cost for the Item_ID:
Start by researching the std::map data structure.  Also search Stack Overflow for ""while getline c++"" to find out how to read files.
",0,7894600
7942186,"
The code posted here could use some improvements in readability...Here they are.  Verified this is a working merge_sort:
",0,7879529
7878814,"
While Java 6 and earlier versions use merge sort as the sorting algorithms, C# uses QuickSort as the sorting algorithm.
QuickSort performs better than merge sort even though they are both O(nlogn). QuickSort's has a smaller constant than merge sort.
",2,7878768
7878914,"
It typically depends on the data structures involved.  Quick sort is
typically the fastest, but it doesn't guarantee O(n*log(n)); there are
degenerate cases where it becomes O(n^2).  Heap sort is the usual
alternative; it guarantees O(n*log(n)), regardless of the initial order,
but it has a much higher constant factor.  It's usually used when you
need a hard upper limit to the time taken.  Some more recent algorithms
use quick sort, but attempt to recognize when it starts to degenerate,
and switch to heap sort then.  Merge sort is used when the data
structure doesn't support random access, since it works with pure 
sequential access (forward iterators, rather than random access
iterators).  It's used in std::list<>::sort, for example.  It's also
widely used for external sorting, where random access can be very, very
expensive compared to sequential access.  (When sorting a file which
doesn't fit into memory, you might break it into chunks which fit into
memory, sort these using quicksort, writing each out to a file, then
merge sort the generated files.)
",14,7878768
10955685,"
Mergesort is quicker when dealing with linked lists. This is because pointers can easily be changed when merging lists. It only requires one pass (O(n)) through the list.
Quicksort's in-place algorithm requires the movement (swapping) of data. While this can be very efficient for in-memory dataset, it can be much more expensive if your dataset doesn't fit in memory. The result would be lots of I/O. 
These days, there is a lot of parallelization that occurs. Parallelizing Mergesort is simpler than Quicksort (in-place). If not using the in-place algorithm, then the space complexity for quicksort is O(n) which is the same are mergesort.
So, to generalize, quicksort is probably more effective for datasets that fit in memory. For stuff that's larger, it's better to use mergesort. 
The other general time to use mergesort over quicksort is if the data is very similar (that is, not close to being uniform). Quicksort relies on using a pivot. In the case where all the values are the similar, quicksort hits a worst case of O(n^2). If the values of the data are very similar, then it's more likely that a poor pivot will be chosen leading to very unbalanced partitions leading to an O(n^2) runtime. The most straightforward example is if all the values in the list are the same. 
",9,7878768
7878803,"
There is a real-world sorting algorithm -- called Timsort -- that does exploit the idea that data encountered in the wild is often partially sorted.
The algorithm is derived from merge sort and insertion sort, and is used in CPython, Java 7 and Android.
See the Wikipedia article for more details.
",6,7878768
7878812,"
Of the two, use merge sort when you need a stable sort. You can use a modified quicksort (such as introsort) when you don't, since it tends to be faster and it uses less memory.
Plain old Quicksort as described by Hoare is quite sensitive to performance-killing special cases that make it Theta(n^2), so you normally do need a modified version. That's where the data-distribution comes in, since merge sort doesn't have bad cases. Once you start modifying quicksort you can go on with all sorts of different tweaks, and introsort is one of the more effective ones. It detects on the fly whether it's in a killer case, and if so switches to heapsort.
In fact, Hoare's most basic Quicksort fails worst for already-sorted data, and so your ""good test cases"" with some level of sorting will kill it to some level. That fact is for curiosity only, though, since it only takes a very small tweak to avoid that, nothing like as complicated as going all the way to introsort. So it's simplistic to even bother analyzing the version that's killed by sorted data.
In practice, in C++ you'd generally use std::stable_sort and std::sort rather than worrying too much about the exact algorithm.
",5,7878768
7878802,"
Remember in practice, unless you have a very large data set and/or are executing the sort many many times, it probably won't matter at all.  That being said, quicksort is generally considered the 'fastest' n*log(n) sorter.  See this question already asked: Quick Sort Vs Merge Sort
",1,7878768
7869647,"
The comparison operator will be called on a const-reference of a class instance, so it must be declared as a const member function.
It is also good practice to pass the argument by const-reference rather than by value, although it doesn't make much of a difference for your simple class:
It is generally highly recommended to declare all member functions constant which do not mutate your object. This does not only communicate your intention and design, but it would also not be possible otherwise to use those functions on constant objects or references.
",17,7869606
7869620,"
An operator< should be const for both arguments:
",5,7869606
7869631,"
You should write an operator with const operands. Have a look here.
",0,7869606
7856534,"
std::sortexpects a ""less than"" predicate. You should implement your comparisonFunc() like this:
(Note the consts; they are important.)
Your current implementation couldn't possibly work because you just return if the values are equal or not. That information is not enough to sort - you need to know which one is smaller and which one is bigger (unless, of course, the values are equal).
",11,7856514
50952141,"
With modern C++, you can define the comparison method inline:
Note that strcmp returns -1/0/+1 to indicate ordinality, hence the < 0 comparison.
",0,7856514
7856988,"
I more often want to sort a vector of pointer to records than just plain C-strings...
This redefines comparison of foo* such that the default comparison works in the sort. To me this style feels more declarative, the other more procedural. If you need multiple orderings this use of the default is problematic; if you want to be sure that all ordered collections of foo*s are in the same order it's good.
",-1,7856514
7833118,"
How about std::sort.
It sorts a vector.
See: http://www.sgi.com/tech/stl/sort.html
",4,7833065
7833107,"
use std::sort
http://www.cplusplus.com/reference/algorithm/sort/
",3,7833065
7833706,"
An idea would be to create a struct for each card:
Then you can easily sort those cards..
",1,7833065
7813195,"
In what follows:

arr is the input array;
seen is a hash set of numbers already encountered;
l is the index where the next unique element will be placed;
r is the index of the next element to be considered.

Since you're not looking for code, here is a pseudo-code solution (which happens to be valid Python):
On your test case, this produces
",8,7812914
7813084,"
I would use an additional map, where the key is the integer value from the array and the value is an integer set to 0 in the beginning. Now I would go through the array and increase the values in the map if the key is already in the map.
In the end I would go again through the array. When the integer from the array has a value of one in the map, I would not change anything. When it has a value of 2 or more in the map I would swap the integer from the array with the last one.
This should result in a runtime of O(n*log(n))
",2,7812914
7813077,"
The way I would do this would be to create an array twice the size of the original and create a set of integers.
Then Loop through the original array, add each element to the set, if it already exists add it to the 2nd half of the new array, else add it to the first half of the new array.
In the end you would get an array that looks like: (using your example)
1,7,4,8,2,6,3,9,10,-,-,8,7,-,-,-,-,-,-,-,-,-
Then I would loop through the original array again and make each spot equal to the next non-null position (or 0'd or whatever you decided)
That would make the original array turn into your solution...
This ends up being O(n) which is about as efficient as I can think of
",2,7812914
7813230,"
I have been out of touch for a while, but I'd probably start out with something like this and see how it scales with larger input. I know you didn't ask for code but in some cases it's easier to understand than an explanation.
Edit: Sorry I missed the requirement that you cannot use a buffer array.
",2,7812914
7813145,"
Check sort and unique.
",2,7812914
7813090,"
http://ideone.com/3choA
Not that I would turn in code this poorly commented.  Also note that unordered_set probably uses it's own array internally, bigger than data.  (This has been rewritten based on aix's answer, to be much faster)
",2,7812914
7813113,"
If you know the bounds on what the integer values are, B, and the size of the integer array, SZ, then you can do something like the following:

Create an array of booleans seen_before with B elements, initialized to 0.
Create a result array result of integers with SZ elements.
Create two integers, one for front_pos = 0, one for back_pos = SZ - 1.
Iterate across the original list:

Set an integer variable val to the value of the current element
If seen_before[val] is set to 1, put the number at result[back_pos] then decrement back_pos
If seen_before[val] is not set to 1, put the number at result[front_pos] then increment front_pos and set seen_before[val] to 1.


Once you finish iterating across the main list, all the unique numbers will be at the front of the list while the duplicate numbers will be at the back.  Fun part is that the entire process is done in one pass.  Note that this only works if you know the bounds of the values appearing in the original array.  
Edit: It was pointed out that there's no bounds on the integers used, so instead of initializing seen_before as an array with B elements, initialize it as a map<int, bool>, then continue as usual.  That should get you n*log(n) performance.
",2,7812914
17633218,"
This can be done by iterating the array & marking index of the first change.
later on swaping that mark index value with next unique value 
& then incrementing that mark index for next swap 
Java Implementation:
output is 1 7 4 8 2 6 3 9 10 8 7
",1,7812914
7813238,"
It's ugly, but it meets the requirements of moving the duplicates to the end in place (no buffer array)
",0,7812914
23088125,"
If the input array is {1,7,4,8,2,6,8,3,7,9,10}, then the output is {1,7,4,8,2,6,10,3,9,7,8}. Comparing with your answer {1,7,4,8,2,6,3,9,10,8,7}, the first half is the same, while the right half is different, because I swap all duplicates with the tail of the array. As you mentioned, the order of the duplicates can be arbitrary. 
",0,7812914
7803650,"
In this scenario you should write a function that compares two Word structs and pass that function to std::sort.
In this question you can find solution if you want to write a generic comparator for comparing objects based on an attribute.
Update Since we've had C++11 and C++14 for a while now, I'm adding a solution using a lambda, because that is probably the better practice now:
",21,7803634
7803651,"
you should implement operator< to your struct Word
",5,7803634
7804139,"
Instead of sorting the vector afterward, you can also use a container which stores its items in a sorted manner.
",2,7803634
7804463,"
If your compiler supports lamda expressions you could just add one as the compare function.
",0,7803634
7800739,"
Menu::show() is declared const, so inside of it Menu::recipes is considered to have been declared as std::vector<Recipe> const.
Obviously, sorting a std::vector<> mutates it, so Menu::show() must not be const (or Menu::recipes must be mutable, but this seems semantically incorrect in this case).
",7,7800646
7800777,"
You have marked your show method as const which isn't true because it is changing the recipes vector.  When I compile the code you have outlined with gnu gcc 4.2.1 the error is specific to disqualifying the const qualifier, not the error you've posted.  
You could mark your vector with the keyword mutable but I suspect that isn't what you really want? By marking the vector mutable it ignores the constness the compiler would normally enforce within Menu::show() const of the vector and it gets changed everytime Menu::show() is called.  If you really want to use the vector, and not an ordered set like others have suggested, you could add a dirty state flag to let your program know when it should resort, or not.  
The following code I have compiles by changing the vector to mutable to show you the difference, but I still recommend that you don't use sort from with a const show method.
",0,7800646
7796993,"
From the very short snip of code you posted, it can be seen that you use recipes first as an object and then as a type. Your comparison function probably wants as parameters Recipes > const& instead. Note that if the operation does not depend on the Menu class it would be better to declare this function as a static member function.
The function signature should be:
and you would then use it like this:
Both last statements are the same, I think the later is more explicit about compare.
",3,7796962
7780653,"
You declared myvec as const -- how would you expect to modify it?
Declare myvec as:
",7,7780640
7780654,"
You have defined your vector as const; this makes it immutable after initialization. If you intend to sort the vector, you'll need to un-const it, or make a copy to sort (which would be slow, of course, if you intend to do this more than once).
",5,7780640
7780665,"
You've declared the member variable myvec as const, but std::sort has to modify the vector to sort it.  You could:

Make the vector non const by removing the const keyword from its declaration
First make a copy of the vector and sort the copy
replace std::vector with std::multiset, which will keep the items in sorted order to begin with.

",2,7780640
7776094,"
Arrays of chars (or any other type, for that matter) are also arrays of bits - chars are made of bits, after all. So you don't have to create a separate array, you just have to find a way to access a given bit in the array. For that, you'll have to use some bit manipulations. You can find a few examples of how this could be done here: Any smarter way to extract from array of bits?.
Basically, you first have to figure out the byte the required bit is at, and then get that specific bit's value. Something along:
Now wrap this in a function (possibly with additional bound checks, to make sure the given required_bit is not outside of the array), and use with x[i].
",1,7775963
7762159,"
It's not so difficult. Consider the recursive merge:
If you notice, when you split, you don't really do anything. You just tell the recursive function to partially sort the array. Sorting the array consists of first sorting both halves and then merging it. So basically, what you have is this:
Now from here it should be obvious. You first merge elements of the array 2 by 2, then 4 by 4, then 8 by 8 etc. That is the outer for gives you 2, 4, 8, 16, 32, ... (which is what it calls size of the segment because the i of the loop contains that number) and the inner for (say with iterator j) goes over the array, i by i merging array[j...j+i/2-1] with array[j+i/2..j+i-1].
I wouldn't write the code since this is homework.
Edit: a picture of how the inner for works
Imagine if i is 4, so you are at this stage:
you will have a for that once gives you 0(which is 0*i) as j and then 4 (which is 1*i) as j. (if i was 2, you would have j going like 0, 2, 4, 6)
Now, once you need to merge array[0..1] with array[2..3] (which is formulated by array[j..j+i/2-1] and array[j+i/2..j+i-1] with j = 0) and then array[4..5] with array[6..7] (which is formulated by the same formulas array[j...j+i/2-1] and array[j+i/2..j+i-1] because now j = 4) That is:
Hope this is clear at least a little.

Side help: Just a hint if you don't really know how for works:
is like writing
So, if you always wrote
it meant starting from 0, while i is smaller than 10, do something with i and then increment it. Now if you want i to change differently, you just change statement2 such as:
(Try to understand how that final for works based on its equivalent while that I wrote you)
",44,7761974
17902897,"
Here's my lazy, iterative/bottom-up merge-sort implementation that uses std::merge:
Here's an in-place version that uses std::inplace_merge:
",2,7761974
24977705,"
Here is C# version of bottom-up-mergesort (for some more details you may refer to my blog @ http://dream-e-r.blogspot.com/2014/07/mergesort-arrays-and-lists.html)
And merge is defined as:
Just for reference here is the TopDownMergesort:
UnitTests
",0,7761974
35181060,"
Here is the Java Implementation
Here is the Unit Test
    private Integer[] seed;
",0,7761974
7746745,"
One way would be to use a min heap (std::priority_queue in C++). Here's how you'd do it, assuming you had a MinHeap class.  (Yes, my example is in C#. I think you get the idea.)
According to the standard references, running time should be proportional to n log k, where n is the number of passengers and k is the maximum number of items on the heap. If we assume that passengers' weights will typically be 100 lbs or more, then it's unlikely that the heap will contain more than 30 items at any time.
The worst case would be if the passengers are presented in order from lowest weight to highest. That would require that every passenger be added to the heap, and every passenger be removed from the heap. Still, with a million passengers and assuming that the lightest weighs 100 lbs, the n log k works out to a reasonably small number.
If you get the passengers' weights randomly, performance is much better. I use something quite like this for a recommendation engine (I select the top 200 items from a list of several million). I typically end up with only 50,000 or 70,000 items actually added to the heap.
I suspect that you'll see something quite similar: the majority of your candidates will be rejected because they're lighter than the lightest person already on the heap. And Peek is an O(1) operation.
For a more information about the performance of heap select and quick select, see When theory meets practice. Short version: if you're selecting fewer than 1% of the total number of items, then heap select is a clear winner over quick select. More than 1%, then use quick select or a variant like Introselect.
",101,7746648
7815661,"
This won't help for your proxy problem, however:
For 1,000,000 passengers to drop 3000 pounds of weight, each passenger must lose (3000/1000000) = 0.003 lbs per person. That could be achieved through jettisoning every ones shirt, or shoes, or probably even fingernail clippings, saving everyone. This assumes efficient collection and jettison before the weight loss needed increased as the plane used more fuel.
Actually, they don't allow fingernail clippers on board anymore, so that's out.
",118,7746648
7746821,"
Below is a rather simple implementation of the straightforward solution.  I don't think there is a faster way that is 100% correct.
This works by filling up the set of ""dead people"" until it meets the threshold.  Once the threshold is met, we keep going through the list of passengers trying to find any that are heavier than the lightest dead person.  When we have found one, we add them to the list and then start ""Saving"" the lightest people off the list until we can't save any more.
In the worst case, this will perform about the same as a sort of the entire list.  But in the best case (the ""dead list"" is filled up properly with the first X people) it will perform O(n).
",42,7746648
7746800,"
Assuming all passengers will cooperate: Use a parallel sorting network. (see also this)
Here is a live demonstration
Update: Alternative video (jump to 1:00)
Asking pairs of people to compare-exchange - you can't get faster than this.
",31,7746648
7748458,"
@Blastfurnace was on the right track.  You use quickselect where the pivots are weight thresholds.  Each partition splits one set of people into sets, and returns the total weight for each set of people.  You continue breaking the appropriate bucket until your buckets corresponding to the highest weight people are over 3000 pounds, and your lowest bucket that is in that set has 1 person (that is, it can't be split any further.)
This algorithm is linear time amortized, but quadratic worst case.  I think it is the only linear time algorithm.

Here's a Python solution that illustrates this algorithm:
Output:
",21,7746648
7746952,"
Assuming that, like people's weights, you have a good idea of what the maximum and minimum values are likely to be use a radix sort to sort them in O(n).  Then simply work from the heaviest end of the list towards the lightest.  Total running time: O(n).  Unfortunately, there isn't an implementation of a radix sort in the STL, but it's pretty straightforward to write.
",11,7746648
7746795,"
Why don't you use a partial quicksort with a different abort rule than ""sorted"".
You can run it and then use just the higher half and go on until the weight within this higher half does not contain the weight that has at least to be thrown out anymore, than you go back one step in the recursion and sort the list. After that you can start throwing people out from the high end of that sorted list.
",6,7746648
7750356,"
Massively Parallel Tournament Sort:-
Assuming a standard three seats each side of the ailse:-

Ask the passengers in the window seat to move to the middle seat if they are heavier than the person in the window seat.
Ask the passengers in the middle seat to swap with the passenger in aisle seat if they are heavier.
Ask the passenger in the left aisle seat to swap with the passenger in the right aisle seat id they are heavier.
Bubble sort the passengers in the right aisle seat. (Takes n steps for n rows).
-- ask the passengers in the right aisle seat to swap with the person in front n -1 times.

5  Kick them out the door until you reach 3000 pounds.
3 steps + n steps plus 30 steps if you have a really skinny passenger load.
For a two aisle plane -- the instructions are more complex but the performance is about the same.
",6,7746648
7747153,"
I would probably use std::nth_element to partition off the 20 heaviest people in linear time. Then use a more complex method to find and bump off the heaviest of the heavies.
",4,7746648
7746792,"
You could make one pass over the list to get the mean and the standard deviation, then use that to approximate the number of people that have to go. Use partial_sort to generate the list based on that number. If the guess was low, use partial_sort again on the remainder with a new guess.
",3,7746648
7746910,"
@James has the answer in the comments:  a std::priority_queue if you can use any container, or a combination of std::make_heap and std::pop_heap (and std::push_heap) if you want to use something like a std::vector.
",3,7746648
7819948,"
Here's a heap-based solution using Python's built-in heapq module. It's in Python so doesn't answer the original question, but it's cleaner (IMHO) than the other posted Python solution.
If k = the number of passengers to toss and N = the number of passengers, then the best case for this algorithm is O(N) and the worst case for this algorithm is Nlog(N). The worst case occurs if k is near N for a long time. Here's an example of the worst cast:
However, in this case (throwing people off the plane (with a parachute, I presume)) then k must be less than 3000, which is << ""millions of people"". The average runtime should therefore be about Nlog(k), which is linear to the number of people.
",2,7746648
7675595,"
1) You never set n, but you try to use it.  Change the constructor to this:
2) In the loop which prints values, you attempt to delete the array after you have printed just one element, then move on to the next element.  Change print to:
3) Don't use a dynamically allocated array if ints.  Use a vector instead.
",2,7675447
7675554,"
You have several bugs in the code, like:

Calling delete[]x inside the loop that loops over x - move it to after.
Sort and print rely on class member n that is never initialized.

Try debugging and iterating, and even experimenting with Unit Tests!
",2,7675447
7675552,"
I'd hazard, it has something to do with this:
Now - that should be enough of a hint...
",1,7675447
7675769,"
",0,7675447
7670021,"
Try functor with parameters:
",6,7669971
7684776,"
Everything works fine except the last call when *ptrTowardsLeft and *ptrTowardsRight both are equal to 30. So in this case also swapping is done. To avoid this :
and after this else part won't work and you can carry on your partition.
output
Though this code requires many fixes.
",0,7662694
7685000,"
Actually, it is all wrong:


NOT fine! 200 is more than 30 (the pivot), so it should be to the right of it. 1, OTOH, should be to the left of it (something like 2 1 30 200 100).


This is not gonna work once you have ptrTowardsLeft/Right arguments not pointing at the end/beginning of the array. Try to use your pointers only, and don't touch arr.
Also, the structure of your algorithm doesn't even resemble to QuickSort. QuickSort swaps the elements so that all values less than the pivot are in the left part and values greater than the pivot are in the right. Then recurse to sort the two parts of the array. You don't do anything like that.
",0,7662694
7628570,"
is wrong. That just assigns 1 to n.
You mean
I've not looked beyond this. No doubt there are more problems, but this is the most significant.
This is the kind of thing you can work out very easily with a debugger.
",2,7628562
7628591,"
Look at this expression:
What do you think the value of n is after this?  (1)
Is that the appropriate value? (no, the value should be 5)
Does that explain the output you are seeing? (yes, that explains why only one number is shown)
",1,7628562
7628815,"
My advice would be that if you're going to do this in C++, you actually try to use what's available in C++ to do it. I'd look up std::max_element to find the largest element in the input, and use an std::vector instead of messing with dynamic allocation directly.
When you want the number of elements in an array in C++, you might consider a function template something like this:
Instead of dumping everything into main, I'd also write the counting sort as a separate function (or, better, a function template, but I'll leave that alone for now).
",1,7628562
7625968,"
I had answered a similar question (99 % similar :) )  HERE 

Now its for integer i guess, for string you can compare using std::string compare function or strcmp provided by C library


As per my  opinion and seeing other answers it would be better for your application (if it needs sorted linked list ) to sort the data as you insert .


",1,7625936
7625975,"
first solution: insert k elements unsorted, just insert them to the start, it is O(1) each. and one sort: O(nlogn) after these k elements. you get amortized time of O(nlogn+k)/k  = O(n(logn/k)).
second solution: inserting an element to a list is in sorted order is O(n), since you need to find the place in the list. for k insertions, it will be O(n*k), and amortized of O(n*k/k) = O(n).
So the first solution is better for logn < k, and the second for logn > k
For better efficiency, you will probably want a sorted data structure that access elements in O(logn) such as a skip-list [which is basically a variation of linked list with additional information for easier accessing] or an avl tree
",4,7625936
7625951,"
I think it doesn't actually make a difference how you do it, when you sort while inserting, you'll have O(n) on the insert, cause you might have to traverse the entire list before you find the right spot to insert.
However when you sort after adding all items to the list, you'll also have at least O(n) to move items around the list.
",0,7625936
7626090,"
The simplest solution is to use what C++ already offers - std::list and std::list::sort:
If you can get away with it (memory-wise), you could also use std::vector to pre-sort the items (through std::sort) before inserting them into linked list, which could be somewhat faster.
You could also use std::map (or even std::set) instead of list - it will ""auto-sort"" your items as you insert them.
If you still want to use your own list, you could implement begin and end in it, and use std::stable_sort. Note that std::stable_sort expects bidirectional iterators, (unlike std::sort which expects random-access iterators). To implement bidirectional iterators in your list, you'll need to make it doubly-linked, not just singly-linked.
If you want to implement the sort itself, it is possible to implement both Quicksort and Mergesort on linked lists.
",0,7625936
7585567,"
Sorting the edges is not idiomatic boost::graph.  Look at the BGL implementation of Kruskal's algorithm for spanning trees.  The algorithm needs to look at each edge in increasing order of weight.
It uses a separate data structure to sort the edges and later iterates through the edges in that order.  In your case, you want the highest weighted edges first, so you would look change the comparator operator.
",2,7584320
7588345,"
You could write your own EdgeList or OutEdgeList class which sorts the Elements automatically.
I give an example because it's imho not that obvious how to do that.
Output:
",7,7584320
7588545,"
I don't know about any interactions with the Boost Graph representation, but IIRC you can use std::list::sort(Cmp)
",0,7584320
37656527,"
Previous answer, though very useful, manages bgl tags in a bit incorrect manner, that results in redundant push_dispatch definition and may lead to build problems if other *_dispatch functions being called (in case of erase operations, e.g.).
Second confusing circumstance is that per-node edge list is substituted in adj_list template, but the unaffected whole-edge list is printed.
There are some code that presumably corrects these flaws:
",0,7584320
7549254,"
Is the result of compareTo being -1 mean that it is less than the current node? 
And if previous==NULL you set current->next to point to the newNode, which means they are pointing to each other, as newNode->next is also pointing to the current node.
I think the root of your problem may be this, actually.
Hopefully by putting it this way you can see what I am talking about.
",0,7549211
7548378,"
Simply
assuming that operator< is overloaded for the Data type
The minimal idiomatic way to provide std::less<> compliant weak total ordering (I.o.w. implement operator<):
If you have an large/complicated structure and all the members participating have comparison defined for their types, you can do this neat trick with TR1, Boost or C++11 Tuples:
",3,7548313
7548367,"
In your while loop you are comparing newData (which is a pointer) with ""current->data"" which is an integer (I suppose) ?
i.e. if(newData < current->data)
",1,7548313
7548376,"
you could use memcmp to compare your data
",0,7548313
7548418,"
should be 
I guess.
If there is no operator<, implement it or use the slow memcmp.
Also if this is a practical code (why not use stl?) consider using skip lists - they will be much faster.
PS: operators are a powerful feature, do not hesitate to use them.
",0,7548313
7540588,"
Hope that you have really put your effort in it..I am posting the whole function for inserting data into list in sorted order which I had written long time back



void addData(node * head, int data){

        if(head == NULL) {  // First node

                node * temp = new node;
                temp -> data = data;
                temp -> next = NULL;
                head = temp;
                root = head;
        }else{

                node * prev = NULL;

                while(head -> next != NULL){  // Sorted Addition Logic is HERE

                        if(data >= head -> data){
                                prev = head;
                                head = head -> next;
                                continue;
                        }else{

                                node * temp = new node;
                                temp -> data = data; 
                                temp -> next = head;
                                if(prev != NULL)
                                   prev -> next = temp;
                                else
                                   head = temp;
                                break;
                        }
                }

                if(head -> next == NULL){

                        node * temp = new node;
                        temp -> data = data;
                        head -> next = temp;
                        temp -> next = NULL;
                }

        }
}




Seeing your code, it seems that your logic itself is wrong...you are always ending on the last node (while loop) and in the next if statment you are trying to compare the data of the next node which is not present

",1,7540554
7520888,"
You set hs after calling BuildMaxHeap. Switch those two lines.
",6,7520133
7536522,"
When I implemented my own heapsort, I had to be extra careful about the indices; if you index from 0, children are 2x+1 and 2x+2, when you index from 1, children are 2x and 2x+1. There were a lot of silent problems because of that. Also, every operation needs a single well-written siftDown function, that is vital.
Open up Wikipedia at the Heapsort and Binary heap articles and try to rewrite it more cleanly, following terminology and notation where possible. Here is my implementation as well, perhaps it can help.
Hmmm now that I checked your code better, are you sure your siftDown/heapify function restricts sifting to the current size of the heap?
Edit: Found the problem! You do not initialize hs to n before calling BuildMaxHeap().
",1,7520133
7520524,"
I suspect it's because you're 1-basing the array. There's probably a case where you're accidentally 0-basing it but I can't spot it in the code offhand.
",0,7520133
43912761,"
Here's an example if it helps.
",0,7520133
53579343,"
",0,7520133
7465693,"
You probably want to use the STL libabry and declare the argument as 
std::vector< std::string >
then the sort function will work directly, like this
",2,7465647
7465688,"
If you are sorting string objects then there's a lot of problems. The code you wrote sorts characters. This:
is an array of characters. These:
are arrays of strings. You will have to change your function appropriately with either of these.
",0,7465647
7446778,"
Because you sort the pointer values, not the Nodes they point to.
You can use the third argument of the std::sort algorithm to specify a custom comparator.
For example :
(note that this code is just an indication - you'll have to add extra safety checks where needed)
",18,7446743
7446790,"
Your less-than operator takes const Node& arguments, but your vector is sorting Node*s. You need to specify a comparison function as the third parameter to std::sort.
Also, your operator< needs to be declared const.
",11,7446743
7446783,"
Your operator<() operates on references to Node objects; but the vector contains pointers to Node objects, which can't be compared with that function. You'll have to explicitly supply a proper function (one that accepts pointers as arguments) to the sort() algorithm.
",6,7446743
7438932,"
The Problem is that in this line:
it doesn't compare string characters, but rather compares memory adresses.
If you still want to use char arrays, you have to use the strcmp function. However, I recommed that you use string instead.
",1,7438909
7438964,"
The problem is this line:
The line compares the pointers, it does not compare the contents.
It should be:
Another alternative is to use std::string instead, which has built-in comparisons. For example:
",0,7438909
7434409,"
It depends on how you want your elements to be sorted:

Sort as pairs, keyed on a: (1,12), (3,2), (5,8), (10,4)
Sort as pairs, keyed on b: (3,2), (10,4), ...
Sort as pairs lexicographically: same as sorting on a, since there are no repeated values for a.

In case (1) you use compare1, in case (2) you use compare2. (For case (3) you would have to write another predicate, or just use std::pair<int,int>.)

Case 4: If you want the values of a and b sorted separately and destroy the pairing, then you need to put the values into separate vectors of ints and sort those individually:
There is no way around this. A container of Entry objects can only move elements around as a whole.
",3,7434344
7434714,"
I think you are confusing what sort does. It does not hort the members that you use in the comparison function, but rather the whole objects. In your case that means that the because you initialized one object with value pair (5,8), there will always be an element in the vector that is (5,8). 
Sorting the array by the first member means that it move to the second to last position (5 being the second to last biggest first element), and sorting by the second element will move the object to, well in this case also the second to last position, but that will only move the object in the container, it will always be (5,8).
",1,7434344
7434402,"
If you want both to impact the comparison, include both in the check (i.e. compare) function. Else, it's either one or the other. If you need to have different ""views"", you need a smarter container (such as boost::multi_index)
",0,7434344
7433248,"
Your program is recursive, probably the first recursive bubblesort I've ever seen :-)
Recursive implies that the function doesn't return until the work is done, instead each time sort() is called an extra call is pushed onto the stack.  And after a number of recursive calls the stack is full and overflows.
So, get rid of the recursion, it's not useful here, just use a loop.
Regarding the variables that get negative values, start by getting rid of the static modifier on mySwaps, myTime and myCompare as it inhibits their correct initialization on each test run.
",2,7433140
7372163,"
The third argument is called a predicate. You can think of a predicate as a function that takes a number of arguments and returns true or false.
So for example, here is a predicate that tells you whether an integer is odd:
The function above takes one argument, so you could call it a unary predicate. If it took two arguments instead, you would call it a binary predicate. Here is a binary predicate that tells you if its first argument is greater than the second:
Predicates are commonly used by very general-use functions to allow the caller of the function to specify how the function should behave by writing their own code (when used in this manner, a predicate is a specialized form of callback). For example, consider the sort function when it has to sort a list of integers. What if we wanted it to sort all odd numbers before all even ones? We don't want to be forced to write a new sort function each time that we want to change the sort order, because the mechanics (the algorithm) of the sort is clearly not related to the specifics (in what order we want it to sort).
So let's give sort a predicate of our own to make it sort in reverse:
Now this would sort in reverse order:
The way this works is that sort internally compares pairs of integers to decide which one should go before the other. For such a pair x and y, it does this by calling isLarger(x, y).
So at this point you know what a predicate is, where you might use it, and how to create your own. But what does greater<int> mean?
greater<T> is a binary predicate that tells if its first argument is greater than the second. It is also a templated struct, which means it has many different forms based on the type of its arguments. This type needs to be specified, so greater<int> is the template specialization for type int (read more on C++ templates if you feel the need).
So if greater<T> is a struct, how can it also be a predicate? Didn't we say that predicates are functions?
Well, greater<T> is a function in the sense that it is callable: it defines the operator bool operator()(const T& x, const T& y) const;, which makes writing this legal:
Objects of class type (or structs, which is pretty much the same in C++) which are callable are called function objects or functors.
",24,7372132
7372149,"
There is a class template called greater which needs a type argument. So you provide int as one. It became greater<int> and you create an instance of this class and pass it to the function as third argument.
Such an object is called function object or simply functor in C++, as the class overloads () operator. It's a callable entity. Its like this:
If you create an instance of greater<int> and, say, the object is g, then you can write g(100,200) which evaluates to a boolean value, as the expression g(100,200) calls operator(), passing 100 as first argument and 200 as second argument, and operator() compares them and return either true or false.
Output:
Online demo : http://ideone.com/1HKfC
",6,7372132
7372180,"
A binary predicate is any function/object that receives two objects (hence binary) and returns a bool (hence predicate); the idea is that it evaluates if the two objects satisfy some particular condition - in the example, if one is greater than the other.
You can create a predicate either by just defining a function with the correct signature
and passing the name of the function as the argument (this will result in passing a function pointer), or creating a function object (a functor), i.e. an object which overloads the function call operator and thus can be used as a function; the std::greater<T> type is a template functor, and in your snippet a temporary object of type std::greater<int> is created and passed to the std::sort algorithm.
Functors have several advantages over functions, especially when they have to be passed as arguments, have a look here for more information about this.
",2,7372132
7372156,"
See comp in http://www.cplusplus.com/reference/algorithm/sort/
It is the function that does the comparison.
",1,7372132
7348347,"
Yes, you can use std::sort and tell it to use a custom comparison object, like this:
The code for the FileNameModificationDateComparator class (feel free to use a shorter name):
stat struct definition here, just in case.
Warning: I didn't check this code
",0,7337651
7330119,"
you can create a class ABC, which will hold 3 fields: int a, int b, char c.
implement the operator< for this class, and create a ABC[] of the approppriate size and populate it such that ABC[i] = ABC(a[i],b[i],c[i]).
implement the operator< so it will compare only a, and use sort on the ABC array.
after done sorting, you have all your elements in the desired order, just iterate the ABC array and populate the other arrays.
EDIT: 
simplified [and hard coded] code sample:
works good for me on codepad: http://codepad.org/eCyNkyqR
",3,7330063
7330246,"
It's not exactly what you need, but you can achieve similar results by using std::map and std::sort:
",0,7330063
7303693,"
Instead of using two arrays, can you use an array of pairs and then sort THAT using a special comparison functor rather than the default less-than operator?
",1,7303572
7303721,"
The simplest way is to rearrange your data into an array-of-structs instead of a pair of arrays so that each datum is contiguous; then, you can use an appropriate comparator.  For example:
If you can't refactor your data like that, then you need to define a custom class that acts as a RandomAccessIterator:
",0,7303572
7303804,"
Generate an array the same size as the original, containing the indexes into the array: {0, 1, 2, 3}. Now use a custom comparator functor that compares the elements in an associated array rather than the indexes themselves.
Once you have a sorted list of indices, you can apply it to the original array a, or any other b array you want.
",0,7303572
7232335,"
When you're using redirection on the command line, argv does not contain the redirection. Instead, the specified file simply becomes your stdin/cin. So you don't need to (and shouldn't try to) open it explicitly -- just read from the standard input, as you would read from the terminal when input isn't redirected.
",5,7232297
7232324,"
Since you are piping the file on the stdin, you don't have the file name on argv[1], just read the stdin as the user was typing at the console, for example using cin:
",3,7232297
7233411,"
The other answers are completely correct, but here's the rewritten code to claify:
",2,7232297
7234703,"
As everyone has stated, use std::cin directly -- you don't need to open the input file, your shell has already done that for you.
But, please, please, please, don't use cin.eof() to test to see if you have reached the end of your input. If your input is flawed, your program will hang. Even if your input isn't flawed, your program may (but won't necessarily) run the loop one extra time.
Try this loop instead:
Or, add robustness by using std::vector which will automatically grow:
Or, use generic algorithms:
",1,7232297
7184958,"
You can sort anything you want using existing C++ sorting routine ""sort"", by just defining your own comparison function, For eg in your case
where mycomp is
",6,7184943
7184996,"
If you want to create a lexicographic tuple comparator using a scalar comparator, simply compare the last pair of components that is not equal. Something like this:
",2,7184943
8770412,"
I'm not sure what you're having trouble with, but if you'd tried to compile this code, you'd have found that
is illegal: you can't have a const qualifier on a freestanding function. Also, operator< is a binary operator, so it should take two arguments, both of type const firefly &.
You can also implement operator< as a member function, as you suggest yourself, but then drop the friend declaration.
Apart from that, there's nothing wrong with your code, except maybe that sorting a vector of entirely equal elements is a waste of time.
",0,8770383
8770892,"
Excuse me but why you choose vector+customized sorting rather than set/map with a customized comparator?
Normally, we use vector mostly due to a requirement on random access its elements via index. If that's not the case and especially in your case, you need a sorted vector, I'd suggest the set/map.
",0,8770383
8770920,"
For the second question you will have to pass the overloaded function to sort as an argument
sort (myvector.begin()+4, myvector.end(), myfunction);
",-2,8770383
8692997,"

(i.e. this would require me to swap two objects without deep-copying
  them -- is this possible in C++03 and earlier? How about later?)

std::swap is a Standard function. All Standard types provide a swap operation as a member function. swap is very common and necessary for all kinds of algorithms. The Standard std::sort will use swap to swap the nodes, so you don't have to deepcopy. You merely need to implement swap().
",3,8692066
8692989,"
Although I think in silico is correct (i.e. std::vector<T> can't be a member of T because T is incomplete), let's ignore this for now. Instead, I guess your question is about how to move the object: as is, 
(with a suitable predicate) would exchange the positions of two nodes by std::swap()ing them. This would create a deep copy and two deep copying assignments. The easy fix is to make std::sort() use a custom swap function which just swaps the children vectors:
In general, for value types using allocation (directly or indirectly) you probably want to implement a swap() function. Since it isn't needed for the correct behavior it is something often added later to get better performance.
",1,8692066
8692985,"
You can recursively traverse the tree and use std::sort() on each node to reorder the nodes. See the sort() method I have added to node.
This will, however, do lots of copy operations. So you will probably need to change the structure of node to contain by reference rather than by value its children. That is adjust the typedef of storage_t to be either node* or some shared pointer based on what suits the rest of your program. You will also need to change the line (*i).sort() to (*i)->sort().
",-2,8692066
8687453,"
Sorting, sorting, sorting! Otherwise you'll get an O(N2) algorithm. Not good. But you don't have to sort the files, instead construct a sorted index to the files array as follows:
Here file_type is your struct describing a file.
",3,8687387
8687446,"
You are correct that you'd be better off sorting your offsets first, but the specific bug in your algorithm is how you initialize current_offset.  Just outside the for (j ... loop you need to set it to ""infinity"", or some offset value so high that it will not prevent the first j that passes the last_offset test from becoming current.
",1,8687387
8662046,"
Any RDBMS, i.e. PostgreSQL, MySQL etc. Any spell checker, though searching there is rather different and is based on string similarity algorithms (like Levenstein distance). There are also open-source search engines. They do all sort of things - similarity, semantics analysis, data collection, search etcetera. Some of the interesting C++ projects in this regard is Google's Spare Hash - a collection of amazing hash tables. In other words - sorting and searching is everywhere.
",4,8662008
8662106,"
One interview question i was given was about a data structure of names, such as a phone book.
Which would be the best data structure, and which sorting & searching methods would be best if: 

You commonly search for one name at a time...or,
You commonly print out all the names in a row...or,
You commonly search for names when you don't know the full name, such as only first, or only last
etc.

",2,8662008
8661098,"
Why use a custom linked list when the standard library has an std::list template class? Replace your struct with
Stick these in an std::list<WordCounter> and use its sort member function.
",0,8661065
8661127,"
It would depend on many things. I am assuming you have a task that requires you to implement the sort by yourself.

The size of the linked list. Insertionsort fares well with linked lists of moderate size. Otherwise quicksort should do the trick.
The distributions of ""word_count"" which I am assuming you are sorting on.
The requirements for your task. Is standard sorting i.e. std::sort acceptable?

For the problem I am reading between the lines a std::map pair< word_count, word> > would be the c++ way to go.
Or quite possibly an insertion sort if this is a school project, and you have not still covered Quicksort.
The most relevant response to your question is ""What have you tried?"", this is not an easy task. You have both the linked list concepts as well as the sorting concepts to sort out and get a hang of. 
",0,8661065
8677096,"
Well, vector has a resize method that will allow you to basically preset the vector's size before inserting data. Then from there you'll be able to use the operator[] to insert data at the appropriate spaces.
As a side note, I personally would not use STL if I'm working on this project/homework.
",3,8649356
8640833,"
Ordinarily a queue is sorted by insertion order - items are sorted by the order in which they were inserted into the queue. It appears you want to break that essential quality of a queue.
I'm only going to cover merge sorting with this answer. Hopefully others will cover the other algorithms or you can derive them yourself.
A single linked list can be treated as a list of lists simply by knowing when one list ends and another begins. For a merge sort you need to start with sorted lists - if each list has a length of 1, it is sorted simply because no other order is possible. Merging two linked lists into one is easy - you take the smallest item from each of two lists and link it into a new list, until both lists are exhausted. So for the first pass, you break the list into sublists of length 1, and combine them into sublists of length 2. The second pass you merge the sublists of length 2 into sublists of length 4. Each pass doubles the size of the sorted sublists. You're finished when the size of the sorted sublist is greater or equal to the size of your entire list.
",0,8638887
8627633,"
Have a look at sorting networks.
A few links:
http://en.wikipedia.org/wiki/Sorting_network
http://www.cs.uky.edu/~lewis/essays/algorithms/sortnets/sort-net.html
Fastest sort of fixed length 6 int array
",5,8627177
8627217,"
Did you profile your application and this turn out to be a bottleneck? Or are you trying to overoptimize?
Bubblesort can work very well, too. In particular, when your data is already sorted, it actually is optimal and will beat any textbook merge or heap sort. Unless you give the full constraints (cost of swapping elements, stability requirements, in-place or not...) nobody can answer this fully.
Anyway, for four elements it is rather obvious how to implement an efficient merge sort inline.
For odd (non-power of 2) sizes I belive that backwards insertion sort is a common optimization. Have a look at Javas sorting implementation. I believe it has such a small array optimization already. Did you check that the sort routine you would have called doesn't already do this kind of optimizations?
",6,8627177
8627388,"
All answers to optimization questions must be prefaced by the warning that you should profile and only optimize bottlenecks, so: be sure to do that.
In the spirit of C/C++ I will now trust you to have done so and answer the question you have asked.
You determine the answer to your question by iteratively profiling.
Write template <int N> inline void sort_n(int * list) whose default implementation uses an std lib sort. Use this template whenever appropriate in your code. Then write a template specializations for the smallest N case for which you do not already have a specialization. After writing this specialization, profile your program and see if you made a significant performance gain. If you make a performance gain which you judge significant, repeat. Once you write a specialization and don't get much out of it, stop.
",4,8627177
8627268,"
For any reasonable number of items, you will always get a performance benefit from coding up the comparisons explicitly. However, sorting so few items takes so little time that it rarely matters what method you use anyway.
The threshold where you won't get any performance benefit is when you get so much code that it won't fit in the CPU cache any more, so where the threshold is will differ depending on which CPU you are running it on.
You should also consider how you would test such code. The more code you have, the harder it will be to verify that it's bug free.
",2,8627177
8627195,"
You'll need to do some profiling of your application first to determine if doing this optimization is worth your time. I suspect it will not be. The standard library (or boost) functions will almost certainly be your best bet for sorting.
",1,8627177
8627283,"
Insertion sort and bubble sort are generally used for small data.
I believe insertion sort is preferred, citing these 2 wikipedia texts:

quicksort implementations use insertion sort for arrays smaller than a certain threshold

And:

Bubble sort also interacts poorly with modern CPU hardware. It requires at least twice as many writes as insertion sort, twice as many cache misses, and asymptotically more branch mispredictions. Experiments by Astrachan sorting strings in Java show bubble sort to be roughly 5 times slower than insertion sort and 40% slower than selection sort.

As always, you should profile if you're really concerned with the speed. 
",1,8627177
8627234,"
I'm told that the standard library sorts have optimized cases for small n - I've never tried to verify it.
",0,8627177
8623672,"
Your first line of your milk.in:
You're going to end up looping through trying to read in 100 inputs from this file because n = 100.
If you change milk.in to:
That seems to work.
Perhaps a better idea is to just check if you're done reading input from the filestream:
",3,8623575
8623758,"
You need this loop to load  the data from the file in:
And remember to close the file.
Also, I made some minor changes to your code:
Output:
",1,8623575
8600705,"
As all tests cases, you must test normal functionality and extreme cases.
Normal functionality:
Extreme cases:
",2,8600159
8601603,"
TioPepe has listed the required test cases, which answers the first part of your question. For the second part: If you detected a bug and fixed it, QA might reject the fix if the test haven't been extended to show what you fixed. Therefore
1.) Detect the bug
2.) Write a test which fails because of the bug.
3.) Fix the bug. The test should pass. 
4.) Commit the changes.
If you omit 2.), QA should reject the change because it is not clear what you fixed. 
",2,8600159
8599043,"
Here's a theoretical way which should work. Say you've got your 2000 512mb files, ready to create one 1TB file.
If you simply loop through every file, find which one has the lowest FIRST value, then move that into your destination file, and repeat then you'll end up with everything in order. RAM usage should be tiny as you'll never need to open more than one line at a time.
Obviously you should be able to optimize this - keep the first line of every file in RAM as you go and it should be somewhat faster.
",3,8599012
8599039,"
The short version of how you merge is like this:
1) You create a table with one slot for each machine you are merging from.
2) You ask each machine for the lowest entry they have that they have not given you yet.
3) You remove the lowest-valued entry from your table, output it, and ask that machine to refill the slow with the lowest entry it has not given you yet, leaving the slot empty if the machine is out of entries.
4) You repeat step 3 until the table is empty.
This allows you to merge from N machines storing only N entries at a time. Of course, you can trivially optimize it to hold M entries from each machine. In that case, you need to store N*M entries, and when a slot is empty, ask that machine for M entries to refill it.
",6,8599012
8599055,"

Now say, i had 2000 machines each sorted 2000, 512 megs of chunk. Now
  when i merge them back, how does that work? Won't the size keep on
  increasing again? For example merging two 512 megs will make 1024Megs
  which is size of my RAM so how would this work? Any machine can't
  merge a chunk of more than 512 megs chunk with another chunk because
  then size > 1 GB.

That's not how a practical mergesort implementation works. The cool thing about mergesort (and related sort algorithms) is that you don't need to have the entire dataset in memory to make it work. When merging you only need to read into memory a tiny portion of the file at a time, which will be then written out soon later.
In other words, you don't need random access for mergesort. If it weren't for this nice property it would be impossible to sort the data on tape drives with the technology available at the time. Tape drives are of course not random access media and RAM back then were measured in kilobytes.
",4,8599012
21754386,"
This problem can be reduced to a simpler problem. This problem was designed to force you to an approach. Here it is:

Pick up chunks =~ 1GB, sort & store them as separate sorted files.
You end up with 1000 1GB sorted files on the file system.
Now, its simply a problem of merging k-sorted arrays into a new array.
Merging k-sorted arrays need you to maintain a min-heap (Priority Queue) with k elements at a time.

i.e. k = 1000 (files) in our case. ( 1GB ram can store 1000 numbers )
Therefore, keep poping elements from your priority queue and save to disk.
You will have a new file, sorted of size 1TB.
Refer: http://www.geeksforgeeks.org/merge-k-sorted-arrays/
Update
PS: Can be done on a single machine with 1 GB RAM with a better data structure
Merge can be done in less than O(N) space with Priority Queue i.e. O(K) space i.e. the heart of the problem.
",4,8599012
8599049,"
The great thing about a merge sort is that you don't need random access; sequential access will do. That's what makes it a perfect solution when the dataset won't fit in memory.
A single merge pass requires 2 (or more) inputs and produces one output. You just keep combining inputs into outputs until there is only one file left.
",1,8599012
8595230,"
Your member function should be declared as const member function as:
because the pointers which you're using in operator() are pointing to const objects of type Network.
",3,8595160
8595221,"
The compiler is warning you that Network::airtime() is ignoring the const qualifiers on n1 and n2.
The solution would be to create a ""const-correct"" version of Network::airtime() (assuming it actually doesn't modify anything).
See this answer for an example.
",5,8595160
8595308,"
Network::airtime() is not const, and so can't be called via the const Network* you have in sort_by_airtime.
If possible, the best solution is to make airtime() const; otherwise change the sort_by_airtime arguments to Network*.
",1,8595160
8581742,"
By overloading operator(), you have made EWriter a functor.
Just pass it an instance of EWriter.
If EWriter has a default constructor, you can use:
Or pass it an EWriter that already exists.
",2,8581674
8581764,"
You are overloading the parentheses operator:
}
Try with:
}
",0,8581674
8561250,"
Just define an 
and pass it to std::sort 
Or make swapTest a static function and do
std::sort( v.begin() , v.end() , &AddressManager::swapTest );
",3,8561139
8561496,"
Either make swapTest a static function, or use a lambda:
",3,8561139
8556318,"
CitySortHelper needs to take parameters by const reference, not by value. Another thing to keep in mind is that sort uses assignment operator for the City; check that your assignment operator is working correctly. Taking care of these two issues should fix the problem.
",4,8556296
8556316,"
Change your sort helper to have 
And also check that City copy constructor and assignment operator do the proper thing
",1,8556296
27748154,"
You shouldn't use std::sort() if you want to preserve order, you should use std::stable_sort(). stable_sort guarantees elements maintain their relative order, sort doesn't.
Also, it doesn't seem like sort is your problem here. It seems there are City objects getting pushed into the vector somewhere, and you aren't noticing them because you're checking on a variable for size instead of the vector's iterators. Try printing like this instead and tell us what comes out:
",1,8556296
8555475,"
There are a few basic parameters that characterize the behavior of each sorting algorithm:

average case computational complexity
worst case computational complexity
memory requirements
stability (i.e. is it a stable sort or not?)

All of these are widely documented for all commonly used sorts, and this is all the information one needs to provide an answer in the format that you want. However, since even four parameters for each sort make for a lot of things -- not all of which will be relevant -- to consider, it isn't a very good idea to try and give such a ""scripted"" answer. Furthermore, there are even more advanced concepts that could come into consideration (such as behavior when run on almost-sorted or reverse-sorted data, cache performance, resistance to maliciously constructed input), making such an answer even more lengthy and error-prone.
I suggest that you spend some time familiarizing yourself with the four basic concepts mentioned above, perhaps by visualizing how each type of sort works on simple input and reading an introductory text on sorting algorithms. Do this and soon enough you will be able to answer such questions yourself.
",6,8555439
8555452,"
For starters, take a look at this comparison table on wikipedia, the comparison criteria will give you clues on what to look for on an algorithm and its possible tradeoffs.
",1,8555439
8532361,"
Your comparator returns true when both relevant fields are equal. This is invalid, so it may well be what the sort implementation has detected via assert.
You're supposed to pass a ""less than"" predicate to sort: formally a ""strict weak order"". Anything else is undefined behavior. It seems in this case you got lucky, and the implementation detects that it has got into an impossible situation due to inconsistent comparisons.
",32,8532224
8512474,"
Seems simple enough.
Unless you meant C is supposed to be another map:
http://ideone.com/bBoXq
This requires the previous map to remain in scope longer than dest, and have no pairs removed until dest is destructed.  Otherwise src will need to have been holding smart pointers of some sort.
",2,8512330
8512759,"
You can use std::reference_wrapper, like this:
This prints:
",2,8512330
8513752,"
Sounds like you are using multiple containers to represent multiple views into the same dataset. The trouble with this approach is in keeping the containers synchronized and avoiding dangling pointer issues. Boost.MultiIndex was made for just this purpose. A boost::multi_index container stores only one copy of each element, but allows you to access the elements via several indices.
Example:
Result:

Records sorted by key:
alpha -1
bravo -3
charlie -2

Records sorted by sortFunc(const Record&):
alpha -1
charlie -2
bravo -3

",1,8512330
8512422,"
The place I'd start is to:

look at Boost::bimap
create ordering from V -> K via a comparator function object which evaluates f(V&) the way you suggested. (e.g. as in std::map<K,V,C> where C is a comparator class)

",0,8512330
8512428,"
How about, 
where compfunc is a functor which takes two shared_ptr objects and applies the logic in your function?
Excuse the formatting, not good on my phone.
",0,8512330
8512516,"
How about something like this (untested pseudo code):
",0,8512330
8477613,"
Just define your predicate in the logical way, using the major key for comparison and using the minor key as a fallback when the major is inconclusive:
or, for the general case:
",3,8469933
8480248,"
You can use std::tuple (or boost::tuple for older C++03) to do this comparison in one line:
",0,8469933
8454821,"
There are a few things here that beat me:

Why are you using an array of std::pair to emulate the behaviour of a std::map?
Why do you start indexing at 1 instead of 0?

Anyway, std::sort takes a third argument, as Max Lybbert already mentioned. That argument is a pointer to a sorting function. This one works in your case:
",3,8454757
8454793,"
I'm surprised you aren't getting a compiler error.  std::sort has no idea how to compare the elements in your array.  You need to pass that information in as std::sort's thrid argument (as a pointer to a function or as a functor).
",2,8454757
8452571,"
Side note: Your time cost is actually O(n), since the per-element insertion time is a constant (O(log 10)).
The basic idea is sound — you won't do better than O(n) in terms of cost — but rather than rolling your own heap, use std::priority_queue.
",3,8452547
8452799,"
I chose to show A1 and A1 as static arrays, but if you're getting them as int*s to heap-allocated arrays, and if it's important that the finished array be placed in L2, you can then say delete[] L2; L2 = out; after the call to semiMerge(). I chose not to do this in main because I represented A2 as a static array, while switching it out for the contents of out would require it to be a pointer to a dynamic array.
",2,8452248
8452771,"
Now that I've figured out what L1 and L2 are:
B contains [merged sorted part][unsorted A2].  Is that the correct format?  This is the algorithm you posted.  In place (like Nim) is slower, but uses less memory, so it's a trade-off.
",1,8452248
8452345,"

Copy A1 and A2 into one array
std::inplace_merge with begin, begin + L2, end

(well you didn't specify no library functions!) ;)
This sounds like a homework problem, and I normally hesitate before providing code for homework. However it looks like an example is required here:
",0,8452248
8435039,"
You are trying to pass an array of 50 strings to sort, which takes a reference to a single string.
Try declaring sort as any one of these:
If you do any of those, you won't have to change your function call at all:
But, really, just stop using raw arrays and pointers the moment you discover std::vector<> in your studies.

EDIT: 2nd bug.
For some reason, you have this code:
You have declared tmp to be one type (int), but have used it as if it were a different type (string). It doesn't make sense to say ""Assign a copy of this string inside that int.
You should declare tmp to have the appropriate type for its use.
P.s. Once you learn about std::swap(), you can dispose of the tmp variable altogether.
",2,8434883
8435054,"
You're passing an array of string (a string *) to a function expecting a string reference.  Either make the reference to name constant (which you can't do as you are modifying the original, or pass it as a pointer.
Or use a better container than a straight array.
",0,8434883
8435213,"
I do not understand the exercise, but because the name and the number are linked together, your data structure should reflect this. It would be easiest to just use std::pair.
#include<string>
#include<list>
#include<utility>

int main()
{
  typedef std::pair<std::string, int> name_and_number_t;
  std::list<name_and_number_t> names_and_numbers;

  //...
  name_and_number_t name_and_number;
  while ((infile >> name_and_number.first) && (infile >> name_and_number.second))
  {
    names_and_numbers.push_back(name_and_number);
  }
  names_and_numbers.sort();
  //...
}

I do not know enough about the rating thing. Maybe I'd go for
",0,8434883
8434323,"
Since this is homework, I'm not going to post any code, but here's an idea: 
Put your data into a std::map, and iterate over that. Iteration over a map is in order of the keys. 
",3,8434272
8434309,"
you need to do a bubble sort (http://en.wikipedia.org/wiki/Bubble_sort) and when you swap the array you're sorting on, swap the ones that are in parallel to it.  
",1,8434272
8404321,"
That's the incorrect upper bound.  You want to go from 1 to maxvalue.
This loop is also completely incorrect.  I don't know what it does, but a brief mental test shows that the first iteration sets the element of B at the index of the value of the last element in the array to the number of times it shows.  I guarantee that that is not correct.  The last loop should be something like:
As a final note, why are you playing with pointers like that?  
",5,8403814
8404155,"
Since you're using C++ anyway, why not simplify the code (dramatically) by using std::vector instead of dynamically allocated arrays (and leaking one in the process)?
Other than that, the logic you're using doesn't make sense to me. I think to get a working result, you're probably best off sitting down with a sheet of paper and working out the steps you need to use. I've left the counting part in place above, because I believe that much is correct. I don't think the rest really is. I'll even give a rather simple hint: once you've done the counting, you can generate B (your result) based only on what you have in C -- you do not need to refer back to the original array at all. The easiest way to do it will normally use a nested loop. Also note that it's probably easier to reserve the space in B and use push_back to put the data in it, rather than setting its initial size.
",1,8403814
8394590,"
I don't want to give too much away, since it's homework, so I'll move some of your code around, keeping it as close as possible, and show you why it currently won't work.
At the moment you're kind of thinking the do...while loop is some sort of double block, it's not. The code after the while(...); in your code will only be executed once, after you break out of the do...while loop, it's in no way connected. You're going to need two loops, an outer one that prompts for names, and an inner one that looks for that name in your list.
You're also not resetting friends and last after asking the user to enter another name. An easy fix is to move your declarations (which contain initialisations) inside the first loop.
This is what your code will look like after mostly rearranging it and apply the above changes:
There's two different prompts this time, so that if the user enters ""END"", the outside loop terminates immediately, rather than having to add an extra check inside the loop.
Also, as with your other question, search(friendArray, maxsize); should be search(friendArray, sub);, for the reason I told you last time - sub is a count of valid items in the array, maxsize is the capacity of the array.
NOTE: If the name doesn't exist in your list, it'll cause an infinite loop. I'll let you work that out since it's homework and I don't want to change any of your actual logic. A hint though is to think about what's actually happening - if a value doesn't exist you'll just keep incrementing and decrementing last around the area where the value should be if it existed.
Perhaps if your logic incorporated first being modified somewhere, so that the condition first <= last would fail and you'd break out of the loop...
",1,8394313
8394360,"
Your do while statement is wrong, it run this order:
And then this block:
Modify it:
",1,8394313
8392881,"
Your problem isn't necessarily that temp inside bubblesort is not a char, the problem is that array is declared as a string and not a string[].
The reason you're getting the error is because array[count+1] is of type char, and temp is of type string. std::swap expects two elements of the same type.
However, that may be the least of your problems, your code doesn't compile for quite a few reasons. Not just that but you're passing in maxsize to bubblesort at each iteration. There's a flaw in both your logic and your syntax.
EDIT: Since you're still having trouble getting the sorting to work, here's a working modification of your code:
bubblesort could also be written as: void bubblesort(std::string *array, size_t size). There's no difference in this case since, when passed to a function, arrays decay into pointers.
Since arrays are passed by reference, a pointer to the first element, any modifications made to array inside of bubblesort will actually be modifying your array in main. So that's how arrays are ""returned"".
std::vector is a good alternative to the standard array, since it automatically resizes and obviously contains the length of the internal array so that you don't have to pass the size everywhere you pass an std::vector. You can also use it the same way as a regular array.
",5,8392739
8392756,"
temp is a string, array[count] is a char (since an std::string is a vector of char elements.) I'm not sure what you're trying to do here, but the compiler is correct - you can't assign a char to a string.
You could change temp to be a char, since all you do with it is assign a char to it, and then assign it back to an element of array, which is also a char.
",4,8392739
8392761,"
You need to declare temp as char. You can use std::swap to avoid such mistakes in the future:
This would make your code compile, but it would not do what you're trying to do (bubblesort). The problem is that you are passing a single string (which is also an ""array"" of characters) instead of an array of strings, which is, in a very lose sense, ""an array of arrays of characters"". Your bubblesort needs to accept string *array as its first parameter.
",4,8392739
8383096,"
The issue is in ""Sort"": 
First you sort an array, then you Delete it (resulting arr1 is a null-Pointer) 
the same thing you do with arr2. 
When you start to merge it, you already have deleted the data and released the memory
A solution could be, to move the ""delete""-statements below the Merge-call: 
This way you dont loose your data. 
Because you create your Array with a ""new"" - statement, you should not try to leave the ""delete""'s away. 
Hope this solves your Problem
",0,8382997
8383108,"
Right now, the arguments to to Merge is arrays of pointers, but it's enough to pass them as ordinary arrays:
It would also have worked to pass them as pointers:
Personally I think the first alternative might be better, from a readability point of view.
In sort, just pass the arrays without the &:
Also, you have another problem, which is really serious: You delete arr1 and arr2 before passing them to the Merge function! This means that Merge will access unallocated memory, which is very bad.
",0,8382997
8373147,"
@Kerrek's answer involving lambdas is better. But, if you must avoid C++11 features, then replace your sort function with a functor. Allow that functor to store a reference to whatever data is required, as so:
",2,8372918
8372978,"
With lambdas:
With std::bind:
",9,8372918
8373096,"
=== UPDATED ===
Here is a workaround without using C++11 features:
I omitted range checking for the sake of simplicity.
Output:
",0,8372918
8340734,"
Make it part of Comparator:
",3,8340641
8340732,"
Why not simply save the referencePoint or rather the integer value inside Point as a member inside your Comparator, that way you always access it in the comparator function.
",1,8340641
8340739,"
Avoid global variables. That is start of writing multi-threaded code.
Use local variables instead:
Or simpy this,
where Comparator is a functor defined as:
You're done!
Notice the implementation of operator(). This makes the class a functor.
",1,8340641
8341443,"
You can simply store this variable, either in a destructured or structured manner.
And then use it as:
I would advise not using a list if you need sorting through. list are not good at it...
",0,8340641
8333382,"
Generally, you want a custom comparator to sort with.
If you can't just use a single custom operator, you can use a stable sort.
As pointed out by Mark, std::sort is not a stable sort.  Instead you would need to use std::stable_sort.
You want to sort them independently in order of increasing importance.  So, you sort by numbers and then by the string.
You would prefer the first obviously, but the latter can come in handy for keeping combinatorial and/or run-time configurable algorithms simplistic.
For reference:
cplusplus.com C++ : Reference : STL Algorithms : stable_sort
cplusplus.com C++ : Reference : STL Algorithms : sort
",2,8333337
8333372,"
If you store your data as a vector<pair<string, int> > then  you can just use std::sort(vec.begin(), vec.end()); and it will just work because pair's operator< will already use both parts of the object to do the sorting.
",2,8333337
8333402,"
you could overload your < operator then you could use vector.unique() and then vector.sort()
",2,8333337
8333694,"
In your case you need a custom comparator cause you are mixing data Types you couldn't compare your standart comparator could only compare same data Types and doesn't know with which criteria you would sort.
",2,8333337
8329945,"
As soon as the range of the integers is fixed, an array of one bucket for each value in the range needs space O(1). Remember, any fixed, problem-instance-independent amount of space is O(1).
The full solution assumes random access to the output.

We start by counting the frequency of each input integer (O(n) time, O(1) space) 
From the frequencies, we can compute the first output index for each input integer in O(1) space and time
We do a second pass over the input, and store each input item at the correctly ordered output position. After storing one item, we increment the output index for the integer value of the item. (O(n) time, O(1) space) 

The total complexity is O(n) time, O(1) space, as advertised.
I do not see a solution meeting the requirements when we do not have random access output.
",3,8329690
8329738,"
If you know the range of the ints then you can do it in constant space, with the constant being the range.
",1,8329690
8321921,"
Recursive algorithm doesn't affect complexity. Any recursive algorithm can be implemented with an equivalent iterative algorithm (Computation Theory 101).
Unless you have some prior knowledge (for example, knowing that it is sorted, like it is in your example, might help. If it is, of course), you have no choice but to go through all of them (at worst case).
",0,8321885
8302905,"
as others said, you mixed iname and jname.... and why did you do this?
Because you copy pasted! 
So, a good early lesson in programming is to try and avoid copy paste!  instead try and create functions.....
in your case...
then you can do
This approach redues a LOT of errors related to copy pasting and in general, helps make your programs a lot more modular
",7,8302797
8302886,"
Use STL algorithm library:
or (suggested by @Kerrek SB)
",12,8302797
8302955,"
The standard suggests that you should not use [] operator on string to modify it's contents.  string is designed as an immutable object and your code is breaking that standard.  So I guess the answer is that it's hard to say what may be happening because you are using the class in a way in which it was not designed.  It could be messing up some internal index or something else.  We don't know what the string class may be doing internally.
That said, it seems like it should work :)
",-2,8302797
8286758,"
In the ifs you should check if the indexes are in the bounds of the array before you try to compare the stings:
",0,8286707
8287578,"
It is your array indexes.  Check out the left & right functions and the for loop parameters that feed them.  With an odd numbered 'heapSize' value left will eventually return an index past the end of the array.  With an even numbered 'heapSize', right will do it.  
e.g.
when 'heapSize' == 15, then the max 'i' passed to 'heapify' will be 7 ((15-1) / 2).  Pass that into 'left' and you get 15.  Too big for the array, so it croaks when trying to get the string for the 'strcmp'.
Maybe I've done something wrong, but I'm not getting your code to run regardless of heap size.
PS. build with '-g3' flag to get better debug symbols in gdb. g++ -g3 heap.cc
",0,8286707
8282616,"
You can't do it in constant time unless you limit the input to a small number of predetermined values.  Just use binary search.
The C++ function for binary search is lower_bound.  (There are others too but you want lower_bound.)
",1,8282580
8282618,"
I doubt you can do it in constant time but you can do it in log(log(n)) using a van Emde Boas tree under certain assumptions. Binary search may be the best option in terms of implementation ease.
",3,8282580
8282195,"
You can just call the sort function directly if your value type has operator< defined.
Or if it doesn't you need to provide a functor that will do the comparison.
",5,8282166
8282178,"
You can just call the sort member function if the types you are storing can be compared with < already:
And if print_list printed the list, it would print 1 2 3.
You only need to pass sort an argument if the type you are storing in the list doesn't have operator< defined. You can do that like this:
",1,8282166
8279453,"
You cannot sort an std::map. The map is always kept in sorted order of keys. This is an essential invariant of the data structure, and there's nothing you can do do mutate that. Best you can do is to copy the map into a different container and rearrange that one, e.g.:
",3,8279430
8279568,"
As Kerrek said, you can simply construct a std::vector< std::pair< T, int> > from the begin and end iterator of your map, but this will also give you the keys and values. You can use std::transform to only get the values:
",0,8279430
8271216,"
They are equivalent.  In fact, not only are they equivalent, they are identical, because in each case you are calling the exact same function:
But, on to the larger question -- should you use an array or should you use a vector.  As a general rule of thumb, which I think I'd be hard pressed to find many legitimate exceptions to -- you should always use a vector by default in C++ unless you have a specific reason not to.  Speed will not be one of those reasons except in extraordinarily rare circumstances.
",4,8271154
8271229,"
The swap operation should be more or less the same speed, maybe array is negligibly faster, but not the swap operation itself, but the way you access elements through vector.
You should probably look for non performance-related criteria here.
",1,8271154
8271221,"
Accessing elements in array will have a little bit better locality because when accessing element in array, you will apply offset to the address of the first element. When accessing element in vector, you will apply two offsets - one to get a pointer to array stored in vector class, and then another offset to get the element in that array. But this is not significant at all and compiler may (or even should) optimize this different away. 
What in theory might slow you down here is a string comparison, and accessing contents of those strings. You see, std::string allocates its data on the heap, and if you get unlucky, every string's data will point to memory locations too far from each others. Given that contents of strings cannot fit in L1 cache and randomness of memory locations, prefetcher will fail to make data available to your code, and CPU will simply get stuck waiting for memory bus.
I'd start with more high-level optimizations. First, run a profiler to see what exactly is the bottleneck in your program. If that turns out to be sorting, I'd see if I can use different sorting algorithms (i.e. partial sort instead of a full sort). Then try to optimize memory access. And only then think whether I should use std::vector or not. What you are doing here I think is a premature optimization, which is no good.
",0,8271154
8269441,"
I think this should work:
Use a functor to implement the comparison between the rows. The sort will take pointers to the beginning of each row and swap them according to the contents of the rows. The rows will stay in the same places in memory.
",2,8267238
8267260,"
you can use std::sort(); however, this is complicated by your array being 2D.
In general, std::sort() can't eat 2D arrays; you have to create a class to cast around the compiler warnings and complaints:
It becomes much easier if you use a std::vector to hold your items that really are of type row_t or such.  Vectors are dynamically sized and sortable.
",4,8267238
8267550,"
OK, the OP has a three-column integer arrays, which is not straightforward to sort, because you can't assign arrays.
One option is to have arrays of structs, where the struct contains one element for each column, write a custom compare routine and use std::sort.
Another option is to pretend we have such an array of structs and employ the evilness of reinterpret_cast, like below:
Of course, whether or not this is standards compliant is highly debatable :)
EDIT:
With the added requirement for the matrix to by dynamically allocated, you can use an array of std::vector, or a vector of std::vector:
",1,8267238
8267252,"
use this for the second column and then for the third. Now it works  for single dim arrays 
",0,8267238
8267317,"
You can do this using the bubble sort algorithm (http://en.wikipedia.org/wiki/Bubble_sort)
Basically iterate through all records, comparing the current record, with the next. If the current record's 2nd column is higher then swap these records. If the current record's 2nd column is equal but the 3rd column is higher, then swap also.
Continue iterating until no more swaps are made.
To use your example:
10 0 1
11 0 2
12 1 2 (swap with next)
13 0 1
10 0 1
11 0 2(swap with next)
13 0 1
12 1 2
10 0 1
13 0 1
11 0 2
12 1 2
And done!
",-1,8267238
8261549,"
String class has its own swap function.
It's the fastest way to do this because it accesses the string internals and avoids all copying. 
See here.
",20,8261516
8261527,"
You can use std::swap():
But there's no guarantee that this will be measurably faster, and this probably isn't the slow part of your code anyway. Have you measured the performance of the swap operation compared to the rest of your code?
",9,8261516
8261534,"
Use std::swap; it will do the best job it can. If your compiler supports C++11's rvalue references, this means that it will take advantage of move semantics to avoid the copy that occurs in your swap function.
However, if your compiler doesn't support rvalue references, it will most likely perform the same way as your swap function does.
Most standard library implementations will implement std::swap as something similar to:
The std::move function will return an rvalue reference (T&&) to the variable passed in. When you attempt to assign this rvalue reference, it will invoke the type's move operator, if one is available. If a move operator isn't available, it will invoke the copy operator as usual.
In the case of std::string, the above swap function will do no string copies with C++11; only the internal data, such as the string length and C string pointer, will be copied. Without C++11, it will perform three copies of the actual string contents.
",6,8261516
8261532,"
You could change your algorithm to work on elements of type string* instead of string. Then all the assignments in your swap function would operate on pointers, and be faster because no string copying would be involved.
",4,8261516
12731041,"
Functions for radix sort.    
Have a look here in this blog that I have written. Download link of the full source code and test input files are available there. It works really fine for sorting strings of arbitrary length. I had lots of pain  while solving this problem. So thought to share if it helps someone else. Happy sharing. :) 
",1,8233240
8234304,"
The problem with trying to use a radix sort for strings is that strings can be arbitrarily long.  Radix sort really only makes sense for fixed-size keys.
You can still do it if, as an initial pass, you find the length of the longest string (or, as a refinement, the second-longest string), then do radix iterations starting at that position.
Note that, rather than saving an array per radix iteration, you can use only a source and destination array -- swapping them between iterations.
",0,8233240
8234984,"
Here is a horrible, untested mix of c and c++ which shows one way to handle strings.
There are many ways to improve it, both in clarity and performance...
The first thing to tackle would be some way of avoiding creating a huge number of vectors on the stack.  @comingstorm's idea about using two arrays is a good place to start.
",0,8233240
8221565,"
It depends on your STL implementation.  The GCC STL implementation uses a combination of introsort and insertion sort.  It appears that std::swap (or your specialization) will be invoked in the introsort loop, but it will not be invoked by the insertion sort.
If you don't have a specialization of std::swap, then the default std::swap implementation will use a temporary copy to implement swap.
It does not use binary copy (except for some POD types, which may have specializations hidden deep within the STL libraries).
Also, in C++0x, it seems likely that the insertion sort will use move semantics (rvalue references).
",3,8219525
8219674,"
No, std::sort from the C++ Standard Library is not allowed to do a binary copy on objects with non-trivial copy/assignment operators.  I don't see why it can't do binary copies on objects with trivial copy/assignment operators though.  Consider this object:
The C++ algorithms are guaranteed to not set off either assert, which means a binary copy would not be valid.
",6,8219525
8219718,"
I've seen before that std::copy employs memmove in GNU libstdc++, depending on whether the element type is POD has_trivial_assignment_operator. See the source here:
At least in SGI, rotate, reverse, swap_ranges, random_shuffle, partition, next_permutation all employ swap.
See http://www.sgi.com/tech/stl/stl_algo.h
Also, the c++11 standard doc for std::sort specificly mentions in § 25.4.1.1:

Requires: RandomAccessIterator shall satisfy the requirements of ValueSwappable (17.6.3.2). The type of *first shall satisfy the requirements of MoveConstructible (Table 20) and of MoveAssignable
  (Table 22).

Now § 17.6.3.2 contains this:

An object t is swappable with an object u if and only if:

the expressions swap(t, u) and swap(u, t) are valid when evaluated in the context described below, and
these expressions have the following effects:
  
the object referred to by t has the value originally held by u and
the object referred to by u has the value originally held by t.


The context in which swap(t, u) and swap(u, t) are evaluated shall ensure that a binary non-member function named “swap” is selected via overload resolution (13.3) on a candidate set that includes:

the two swap function templates defined in  (20.2) and
the lookup set produced by argument-dependent lookup (3.4.2).


",3,8219525
8219611,"
It swaps, but since it's a template function it might inline the swapping code. The compiler can choose to do a binary swap as an optimization if it's a simple type.
",2,8219525
8206121,"
I haven't looked too carefully, but I think the book's pseudocode uses one-based indexing, and for coding in C (or most modern languages) you need to adjust it to zero-based indexing.
The principal suspect is 
Where you might want to start at 1 instead of 2.
The termination condition
might also need to be changed to ensure you're above -1 rather than 0.
EDIT:
After a bit closer look, I'm pretty sure you do also have to adjust that while.
You should also of course review all upper limits for similar off-by-one issues.
",9,8205967
8206113,"
change to for (int j = 1; ...)
",5,8205967
8247503,"
Actually your code is correct but the problem in there in your for loop initialization. the pseudocode for insertion sort is :
Actually your code is not considering the first element of the array. It is just staring sorting from second element of the array that's you getting that type of result.
Just change the initialization of j to 1 and it would run correctly.
",2,8205967
36554952,"
You can use this code , I have corrected your error
",0,8205967
42640623,"
Take a look at the CLRS insertion sort algorithm translated in java.
",0,8205967
8195805,"
You might consider doing this with sort-merge. First use a stable sort by user id to put all of the sequences for a given user together, keeping the original order. Then sort all the 3-web page sequences, and finally count runs of equal sequences. This is also O(n log n). It probably takes a bit more time in practice, but might take less store if run using internal memory, and can be run with sorts in external memory, if you have too much data to fit in store at any one time. Whether it's actually any better depends on the details of your particular situation.
",0,8195625
8194912,"
If I understanded it corretly you only want to sort about 500-600 pointers to object, but its too slow for you. First what algorithm do you use? some algorithm has almost linear complexity in mostly sorted data. if your data only contains a few unsorted elements, you might want to try insertion sort (it takes O(n^2) on avarage, it works well on mostly sorted data), or TimSort (its a little hard to implement but its really quick).
i don't know if the 1..32 range is just an exaple, but if you really work with such a small set of values, the fastest way of sorting is when you create 32 list (linked list for example), and when you encounter the value X, you put it in the X-th list. when your done, you select the first not empty list, and there you have it.
",0,8191014
8187934,"
The first problem I see is that while (*array) { ... } won't terminate where you want it to because what is beyond the last element of your array is not certain to be 0 or NULL, or it may terminate in the middle of your array if you are sorting an array that includes 0.
Instead you want to say something like:
",4,8187906
8187954,"
You seem to have the concepts of pointers and values reversed. For example, your change function, as it is now, is
when it should be
Which is almost exactly the opposite.
There are also several misuses of pointers in the max function that I can see as well as the sort function, and that is what I see after only a very brief glance at the code. You need to go back and learn pointers, and then try this again.
",2,8187906
8187960,"
The second problem is that the array++; in the sort() function is not part of the while loop.    I wouldn't be suprised if this never exits.
",2,8187906
8188008,"
I would try to explicitly show what you're trying to do by using the right type; for example:
would be a lot easier for you to debug if it said something more like
or even
Also, your change function seems like it should swap two values that the pointers point to, but it doesn't.
Just in case it helps, I think the technical name of what you're doing is called ""Selection Sort"". This might help if you need to ask anyone else for advice!
Good luck!
",0,8187906
8174548,"
You can use std::lexicographic_compare with a custom predicate to compare strings with a custom character ordering – as Gnawme already said. The following code brings together the std::set with the std::lexicographic_compare.
",3,8173495
8173591,"
There is no built-in solution to this particular problem, as the libraries expect you to build your own custom comparator to handle this.
However, you may want to look into defining your own char_traits type, which would let you customize how strings are ordered and compared.  While there aren't the best tutorials online about this, this is potentially the cleanest and easiest solution to your problem.  As a shameless plug, I wrote an answer to this earlier question about char_traits that might be useful for what you're doing.
I would suggest that you not mess around with locales.  Locales are designed for localization and are designed to have large, profound effects on how text is handled.  A custom comparator or a new char_traits type more directly addresses the problem at hand.
",7,8173495
8174228,"
Matt Austern wrote a paper on ""How to do case-insensitive string comparison"" that handles locales properly. It may contain the information on locales and facets that you're looking for.
Otherwise, if you're just looking to reverse the usual comparison order of a couple of characters, shouldn't using std::lexicographical_compare with your own comparison function object do the job?
""word0"" evaluates less than ""word_"" in the first case, and greater in the second, which is what you're after.
If you're already doing something similar, that's the easiest way to go.
Edit: On the subject of using char_traits to accomplish this, Austern's article notes:

The Standard Library type std::string uses the traits parameter for
  all comparisons, so, by providing a traits parameter with equality and
  less than redefined appropriately, you can instantiate basic_string in
  such a way so that the < and == operators do what you need. You
  can do it, but it isn't worth the trouble.
You won't be able to do I/O, at least not without a lot of pain. You
  won't be able use ordinary stream objects like cin and cout.

He goes on to list several other good reasons why modifying char_traits to perform this comparison isn't a good idea.
I highly recommend that you read Austern's paper.
",4,8173495
8173725,"
There is a collate class and here is a brief explanations of facet usage in C++ with a few examples of how it can be used. 
But you'd probably need to implement the actual logic yourself anyway.
And: ""The string class in the Standard C++ Library does not provide any service for locale-sensitive string comparisons."" Hence you'd also need to wrap the locale-usage in a separate comparison function.
So if an existing locale doesn't compare the strings the way you like, going this way looks a bit like an overkill.
",1,8173495
8172231,"
It works just as you want already:
But you have syntax error. You are missing a brace:
For efficiency you should pass by const reference:
",1,8172173
8172197,"
Write your comparison function as the operator() method of a structure called a functor:
Then pass an instance of that functor object to std::sort:
",4,8172173
8172203,"
If you are using an array of foo like this:
The above code would sort your array in reverse order, since sort expects a less-than comparator.
Additionally to avoid copying a lot of foo-objects around just for comparison, declare your comparator to take const foo& instead of foo as arguments.
",3,8172173
8172196,"
You're supposed to pass iterators — a generalized superset of pointers — to the STL sort function:
",2,8172173
8172602,"
Note that in worst case sort function is up to N^2 comparsions.
And stable_sort complexity is between N*logN and N*(LogN^2)
",0,8172173
8172241,"
Make it an operator.
If you really want to sort using operator>, pass std::greater<foo>() as the functor.
",0,8172173
8148027,"
At least as far as I know, none of the sorting algorithms built into the standard library will do this for you directly. The most obvious possibility would probably be to use a Boost Zip Iterator to make the two arrays act like a single collection. 
",5,8147911
8148019,"
Create vector indexes; fill it by values 0..n-1 than 
than you have in vector indexes order of items in both arrays. Than you can create mass/velocity vectors in correct order or convert index during access: mass[indexes[i]], velocity[indexes[i]]
",10,8147911
8149926,"
Why don't you use std::pair as you have two values which are linked, you than can then implement your own comparison method/function to pass on to the std::sort function via pointer(there exist an overloaded version of std::sort which supports that). 
But be sure that you have a strict weak ordering implemented, because else std::sort might lead to a SEGFAULT
",5,8147911
9780533,"
If you're planning on using a member function as the comparator passed to std::stable_sort() it needs to be a static function.
",3,9780150
9778437,"
Just use std::vector as ""array"" and std::sort as sort algorithm.
",1,9778379
9753752,"
If you really want to implement the three different comparison
operations as members you can do something like this:
and use them like this:
mem_fun_ref returns an binary function object that takes a reference to the class of which the function is a member and all the rest of the arguments (only in C++11, this is limited to binary functions in C++03) of the member functions.
Although it seems much more reasonable to implement the comparison
operations as free functions.
",3,9753663
9753794,"
You have to provide a comparator function (or a function object). For example: 
Then invoke the sort () method in the following way:
",1,9753663
9753769,"
std::list::sort() accepts a comparison function object, which lets you define custom sort criteria. This can be a normal function (free function or static member) or an instance of a class with a compatible operator(). See some documentation for details and an example.
",0,9753663
9753771,"
The various sorting functions in the standard C++ library take comparision objects. These may contain whatever data they need. The key requirements they have is that they are copyable and that their function call operator yields a strickt weak order when applied to objects of their argument type. It is easy to create a comparison object which e.g. stores a pointer to member function used to map an object to an attribute, especially if all the attributes have the same type (if the attributes have different types things are bit more interesting). With this it is rather straight forward to sort the same list into different orders.
",0,9753663
9753783,"
The best way to do this is to implement a comparison function for each parameter and pass that to sort when calling the sort.
That function boolean comparison(Box a, Box b) should be equivalent to a < b, that is, it is true if a comes before b when sorting by that parameter.
",0,9753663
9753761,"
If you want to pass member functions as parameters then your best option is to use boost::mem_fn
",0,9753663
9747797,"
There is a function that does exactly what you want in glibc. Unfortunately it is C, not C++, so if you can live with that here is the simplest possible solution ""out of the box"", without reimplementing anything and reinventing the wheel. BTW: this is exactly as ls -lv is implemented. The most important part of it is the versionsort function which does the natural sort for you. It is used here as a comparison function for scandir. 
The simple example below prints all files/directories in current directory sorted as you wish.
",5,9743485
9745132,"
You need a function which makes the natural comparison between two strings. After that you can use std::sort with the comparison function as third argument (as @chac already pointed out). In the following I tried to implement such a function in a recursive way. Note, that it can handle arbitrary filenames which don't need to begin with a number part and end with a string part:
Here's a simple test case:
The result is:
1.txt
1_t.txt
10.txt
20.txt
z2.txt
z10.txt
z100.txt

",9,9743485
9744663,"
you can use std::sort, splitting your filenames in number + string (both optional).
output:
That almost works, but there is the problem that the '_' precedes '.', thus a further tweak is needed:
output:
",3,9743485
33880554,"
I have come across an algorithm which works pretty nicely: http://sourcefrog.net/projects/natsort/
I have modified the source a little to meet my needs:

pass std::string as parameter.
use with std::sort and std::vector.

My version of source is here.
A use case example:
Output:
This is the strnatcmp.hpp header.
",0,9743485
9706592,"
You should implement an operator< on cat so that cats can be sorted:
You can then include the ""algorithm"" header and use std::sort on your array:
",14,9706517
9658056,"
Just to answer your last question: no, there is no guarantee whatsoever where new allocates memory. The allocations can be distributed throughout the memory. Depending on the current fragmentation of the memory you may be lucky that they are sometimes close to each other but no guarantee is - or, actually, can be - given.
",2,9658008
9658348,"
If you want to improve the locality of reference for your objects then you should look into Pool Allocation.
But that's pointless without profiling.
",2,9658008
9658273,"
It depends on many factors.
First, it depends on how your objects that are being pointed to from the vector were allocated. If they were allocated on different pages then you cannot help it but fix the allocation part and/or try to use software prefetching.
You can generally check what virtual addresses malloc gives out, but as a part of the larger program the result of separate allocations is not deterministic. So if you want to control the allocation, you have to do it smarter. 
In case of NUMA system, you have to make sure that the memory you are accessing is allocated from the physical memory of the node on which your process is running. Otherwise, no matter what you do, the memory will be coming from the other node and you cannot do much in that case except transfer you program back to its ""home"" node.
You have to check the stride that is needed in order to jump from one object to another. Pre-fetcher can recognize the stride within 512 byte window. If the stride is greater, you are talking about a random memory access from the pre-fetcher point of view. Then it will shut off not to evict your data from the cache, and the best you can do there is to try and use software prefetching. Which may or may not help (always test it).
So if sorting the vector of pointers makes the objects pointed by them continuously placed one after another with a relatively small stride - then yes, you will improve the memory access speed by making it more friendly for the prefetch hardware.
You also have to make sure that sorting that vector doesn't result in a worse gain/lose ratio. 
On a side note, depending on how you use each element, you may want to allocate them all at once and/or split those objects into different smaller structures and iterate over smaller data chunks.
At any rate, you absolutely must measure the performance of the whole application before and after your changes. These sort of optimizations is a tricky business and things can get worse even though in theory the performance should have been improved. There are many tools that can be used to help you profile the memory access. For example, cachegrind. Intel's VTune does the same. And many other tools. So don't guess, experiment and verify the results.
",1,9658008
9699494,"
Normally text input in Windows is done with an edit control, that allows the user to type into the edit control.  To get the contents of the control, you use the GetWindowText API passing in the HWND of the edit control.
",4,9649759
9651145,"
Forget about GetKeyState.
If you're doing all custom rendering, handle the WM_CHAR message.
If you can use widgets (child windows), the the EDIT control as Larry suggested would be best.
",1,9649759
9651306,"
I found a soultion that was pretty easy.
I made a big fault that I couldn't see after hours of programming:
I initiate my string pName again ang again from the beginning. So I moved it to my constructor and now it all works fine.
To get a better sensibility, you have to change 
(GetKeyState(VK_LETTER)) 
to
Now it works much better!
",0,9649759
9640347,"
You could store in your SortableInfo pointers to the start positions in the corresponding vec2
populate your vec3, sort it and then at the end make an ordered copy of your vec2 using the sorted pointers.
",1,9640204
9640313,"
I don't know what the specific constraint that causes you to bundle your data that way is, but your vec3 option is close to the object oriented way of doing things.  
What I would do, is to just make 1 vector, of your struct(or class depending on your needs) in the first place, and forget about the separate vectors in the first place. 
Is there a particular reason why you can't do this?
",0,9640204
9640368,"
Just keep a offset in Info ?
offset is just the offset in your vec2
so now you can have for example
If you also want to support delete you have to redefine all your offset and this solution might not be that efficient.
Now you can just sort and still use your offset to find the data.

Just define a new Struct and use it as a wrapper.
",0,9640204
9621670,"
First problem.
unique used wrongly
You are calling the three operand form of unique, which takes a start, an end, and a predicate. The compiler will pass words.end() as the predicate, and the function expects that to be your comparison functor. Obviously, it isn't one, and you enter the happy world of C++ error messages.
Second problem.
either use the predicate form or define an ordering
See the definitions of sort and unique.
You can either provide a 
, but only do this if a less-than operation makes sense for that type, i.e. if there is a natural ordering, and if it's not just arbitrary (maybe you want other sort orders in the future?).
In the general case, use the predicate forms for sorting:
If you can't C++11, write a functor:
I guess in your case (""frequency of words""), operator<makes sense.
Also note vector::erase: This will remove the element indicated by the passed iterator. But, see also std::unique, unique returns an iterator to the new end of the range, and I am not sure if you really want to remove the new end of the range. Is this what you mean?
Third problem.
If you only need top ten, don't sort
C++ comes with different sorting algorithms (based on this). For top 10, you can use:

nth_element: gives you the top elements without sorting them
partial_sort: gives you the top elements, sorted 

This wastes less watts on your CPU, will contribute to overall desktop performance, and your laptop batteries last longer so can do even more sorts.
",5,9621064
9621157,"
The most probable answer is that operator< is not declared for the type of object vec contains. Have you overloaded it? It should look something like that:
",2,9621064
9621160,"
That code should work, as std::unique returns an iterator pointing to the beginning of the duplicate elements. What type is your vector containing? Perhaps you need to implement the equality operator.
",0,9621064
9582259,"
Remove the ; from #define  nbucket 5; and the other defines.
At the moment, line 22 is expanded by the preprocessor to become the obviously-invalid:
",5,9582217
9582310,"
The #define lines are not part of the compiler, it's part of a pre processor that runs before the compiler. The lines handled by the pre-processor should not be terminated with semicolon.
Take for example this line:
This creates a macro named narray. When the pre-processor runs it replaces all instances of narray with the replacement text, in this case 8;. As you can see, having 8; inside an expression will add a semicolon where there shouldn't be any.
",0,9582217
9544701,"
First of all I would like to give you one tip: instead of using the syntax *(ptr+min_index) you can use ptr[min_index] and it will have the same effect. I believe this version is more natural.
Second - your problem. You should swap ptr[min_index] and ptr[start] rather then just copying the values of one of them to the other.
That is instead of:
Write this:
Or if you are using c++ simply use the swap function:
Why should you swap instead of what you are currently doing? Well, you should preserve all the fields in ptr[min_index] in order to be able to assign them to ptr[start].
Hope this helps. 
",4,9544650
9544693,"
I think you should use memcpy function in the standard library...
And one more thing:  
This line seems to overwrite the data, but NOT swap them as they should be.  
",1,9544650
9544717,"
First lesson in C++ : In C++ we have operator overloading, so the line like this:
can have meaning if your Student class has any pointer in his member attributes.
and you must use a swap and not just assign.
",0,9544650
9500887,"
Two options as from the comments above:
1.) Use std::vector. There you can have variable size arrays.
2.) Use an ""in place"" version of quicksort that does the sorting in your original array. See http://en.wikipedia.org/wiki/Quicksort#In-place_version
",1,9500758
9501020,"
Lets say you have array size N
and you pivot value is x
what you should do is like that, have two pointers one to the beginning(0) and one to the end (N-1). they should both move to the middle. when ever the beginning pointer value is greater than x and the end pointer value is lower than x switch their values. after you finished and placed x in his new location (where the two pointers met) continue recursionally for the part left to x and right to x.
",0,9500758
9462216,"
Without seeing the definition of minLocation, we can't tell. But it's a safe bet that it doesn't take two arguments - compilers don't lie to you just for the fun of it, you can usually assume that what they're saying is true :-)
You need to find the definition, something like:
and figure out how you're actually meant to call it. Given that it looks like it's trying to find which of two indexes has the lower value, it may be that it needs more than two arguments.
And, on top of that, you need to decide whether you want that variable called mIndex or minIndex. Most compilers aren't quite smart enough to figure that out for you.
Based on your edits that muinFunction is defined as:
it seems evident that it also needs the string array as well as the two indexes. You will need to change the call to:
And keep an eye on the swap call as well. It may have a similar requirement, based on the coding style.
",1,9462193
9423615,"
std::list has an overloaded member function sort, that

Sorts the elements in ascending order. The order of equal elements is guaranteed to be preserved. The first version uses operator< to compare the elements, the second version uses the given comparison function comp.

To give the comparison function you can use functors:
or simpler free functions
and you call it either
or
the accessors get_name() and get_last_name() must be const.
",6,9423480
9423507,"
Don't do your own sorting. Use std::sort(). You'll need to supply a custom comparator — something like this:
If you have access to a C++11 compiler, you can do better:
",4,9423480
9423651,"
Expanding on the answers given using std::lexicographical_compare and lists internal sort.
",1,9423480
9401031,"
From the C++ standard, all we can say is that they both have the same asymptotic complexity (O(n*log(n))).
The set may be faster for large objects that can't be efficiently moved or swapped, since the objects don't need to be moved more than once. The vector may be faster for small objects, since sorting it involves no pointer updates and less indirection.
Which is faster in any given situation can only be determined by measuring (or a thorough knowledge of both the implementation and the target platform).
",5,9400895
9401056,"
The use of vector may be faster because of data cache factors as the data operated upon will be in a more coherent memory region (probably).
The vector will also have less memory overhead per-value. 
If you can, reserve the vector size before inserting data to minimize effort during filling the vector with values. 
",2,9400895
9400964,"
In terms of complexity both should be the same i.e, nlog(n).
",0,9400895
9402877,"
The answer is not trivial. If you have 2 main sections in your software: 1st setup, 2nd lookup and lookup is used more than setup: the sorted vector could be faster, because of 2 reasons: 

lower_bound <algorithm> function is faster than the usual tree implementation of <set>,
std::vector memory is allocated less heap page, so there will be less page faults while you are looking for an element.

If the usage is mixed, or lookup is not more then setup, than <set> will be faster. More info: Scott Meyers: Effective STL, Item 23.
",0,9400895
9442768,"
Since you said sorting in a range, you could use partial_sort instead of sorting the entire collection.
If we don't want to disturb the existing collection and want to have a new collection with sorted data and no duplicates, then std::set gives us a straight forward solution.    
",0,9400895
9385938,"
Your arr parameter holds an array of PhoneEntry values. You attempt to read an entry from that array and store it in a string when you write temp = arr[j]. You can't assign a PhoneEntry to a string. Change temp to have a type that can hold PhoneEntry values, namely PhoneEntry:
Better yet, use the swap function from the <algorithm> header. Remove the temp variable and replace the three lines above with this one:
",2,9385632
9385847,"
Try 
instead of
But I am guessing really.
",0,9385632
9385972,"

object.cpp: In function 'void mySort(PhoneEntry*, int)':
  object.cpp:35:29: error: no match for 'operator=' in 'temp = *(arr +
  ((unsigned int)(((unsigned int)j) * 20u)))'

So, you're assigning a PhoneEntry to temp. temp is a std::string and PhoneEntry is not - hence the error.
Note that temp is only used in the innermost scope, so you should declare it there, and initialise it on the same line. (In general, you should not declare a local variable without initialising it.)
I would also suggest that you might have a look at the std::swap function.
",0,9385632
9384709,"

arr should be an array, not a reference, like this PhoneEntry arr[]
You should be passing an entire array to the sort, not a single element, like this: mySort(entry, count);

Other than this, your code appears OK.
I should add that this is not a C++ - ish solution: the preferred way of managing arrays in C++ is through using the std::vector<T> container from the standard library. The nice thing about vectors is that you do not need to pass their size ""on the side"".
",5,9384675
9384844,"
You can use pointer notation - mySort(PhoneEntry * arr, int size) or array notation - mySort(PhoneEntry arr[], int size).
If you want to pass the whole array when you call the function, just do mySort(entry, count).
",2,9384675
9384715,"
arr is not an array in your method.  
change your method signature to 
void mySort(PhoneEntry *arr, int size)
and call your method with 
mySort(entry[count], count);
",1,9384675
9384719,"

from my understanding I'm passing an object array right?

No, you are not passing an object array. You are passing a reference (indicated by the & in the function header) to the PhoneEntry element that is at the count-th position in the entry array. You probably meant PhoneEntry* arr in the header of mySort -- that would require a pointer to a PhoneEntry instance, and since the name of an array can be interpreted as a pointer to the first element of that array, you could simply pass entry as the first argument to mySort.
",1,9384675
9384723,"
Substitute this:
Instead of this:
... do one of these (as appropriate):
",0,9384675
9373827,"
You want to pass a reference, so the argument has to be defined as call-by-reference in the function definition/declaration, which is already done:
As you can see, PhoneEntry::alphaGreater takes a constant PhoneEntry reference. So simply use
",3,9373787
9374264,"
There are several things wrong with your code.  The first, the one the
compiler is complaining about, is that there is no postfix operator &
in C++.  I don't know exactly what you're trying to do with it, or what
you think it means, but it doesn't exist in C++.
The second is that mySort takes a reference to a single PhoneEntry;
you have an array of PhoneEntry, so you'll have to select one to pass
it.  Except that the name of the function and the fact that you pass a
count as well suggest that you really want to pass an array. 
And I can't figure out what mySort is supposed to be doing.  It
certainly doesn't sort anything; in fact, it seems to be fundamentally
an expensive no-op, since it doesn't return anything, it doesn't modify
arr, and it doesn't access or modify any global state.
For the rest, you need more error checking on the input (did the open
succeed, etc.), and you really should be using std::vector, rather
than a C style array.  (There are cases where C style arrays are
appropriate, but this isn't one of them.)
More fundamentally, I'd suggest you get a good book and study it.  (I'd
recommend Stroustrup's Programming Principles and Practice Using C++.)
You can't write a program in any language without knowing at least the
most basic fundamentals and basic syntax.
",1,9373787
9374076,"
you can pass it as pointers also
",0,9373787
9372770,"
Code like this:
Should be like this:
",0,9372744
9372797,"
You need to have a getter method in your PhoneEntry class that returns the last name.
You can not directly access them since you have declared them as private variables.
You need to have public getter methods for them.
    public getLastName()
    {
     return lastname;
    }
",0,9372744
9373122,"
Use public member function function to access private data members. 
public function can be called outside class as objectname.memberfunction();
+1 for posting it as home work question!!
",0,9372744
9369882,"
This line of code is wrong (two lines that look just like this):
If you dereference, use parenthesis around it:
But to make it easier to read, I would suggest:
This should show you your real problem:  compareTo() is expecting a Book object and getBook() returns a char *. Use the following and it compiles fine for me. Without a main function that uses the classes, I couldn't tell you if your code logically works right but now it compiles. 
You should really overload the equality operator in Book.h for comparisons. Hope this helps.  
",1,9369207
9369495,"
Well, the logical error that jumps out at me is that you never say
before
Of course, there are STL libraries for linked lists, there's no bounds-checking in your printing function (which should probably be using a std::string anyway), and this never cleans up the memory it allocates... but I assume this is for an intro programming assignment.  You won't be able to instantiate your class without a delet() method defined either.
",1,9369207
9370101,"
You need to add a forward declaration of BookList class before you start declaring the BookNode class as you have the line friend class BookList; inside the definition of your BookNodeclass.
Change the following:
to this:
Without this, the compiler will complain that BookList is not a struct/class/union.
Obviously you'll have to get rid of the other compiler errors in your code after doing this.
",0,9369207
9351631,"
First, your compile error:
vectorcompare is a function, not a type. That is, it's not an object that you can construct. So you don't do () on it; you just pass the function as is:
Now, for a worse problem:
Take your parameters by const&, not by value. std::vectors are big; you shouldn't needlessly copy them.
And an even worse problem:
This does not constitute a strict-weak ordering. This provides less than or equals to, which is not a strict-weak ordering. std::sort requires sorting based on a strict-weak ordering.
",12,9351587
9352446,"
You may not need to write your own comparison function. std::vector already has an operator< defined that performs the equivalent of std::lexicographical_compare. Have you tried simply calling std::sort on your vector<vector>?
Note: added my comment as this answer because the user found it helpful.
",1,9351587
9351629,"
Please look at this site, it has a nice example.
In your case, you would call std::sort like this:
",0,9351587
9347905,"
std::sort requires random-access iterators, so it cannot be used with std::list iterators.
http://msdn.microsoft.com/en-us/library/ecdecxh1(v=vs.100).aspx
Make sure you read the documentation for template functions carefully. Template errors can be a nightmare to deal with.
Edit:As Christian mentioned, std::list has its own sort method.  You could just make these two changes:
bool sorter(const Node<T> * lhs, const Node<T> * rhs);
static bool sorter(const Node<T> * lhs, const Node<T> * rhs);
std::sort(Node<T>::Nodes.begin(),Node<T>::Nodes.end(),&Node<T>::sorter);
Nodes.sort(&Node<T>::sorter);
",3,9344790
9339364,"
This is kind of strange, and something your compiler should warn about
You are not testing the value of t_sort but always setting it to false. 
Testing  a bool against true or false is bit unnecessary anyway, as this is what the if-statement is doing already.
Try this code instead
",4,9336579
9380523,"
Are you sure that having an ordering for your record class has a real meaning, not only for arbitrary sorting purposes? Consider a class for large integers, where a such an ordering for your objects makes sense, but would it make such valid sense for your records? Or does it lose its meaning if you never sort?
[imo] Do not couple this ordering introduced by operator< with your class definition unless it has a real correspondence with it, in other words, if it is intuitively clear for human beings that some ""object a"" is smaller than some ""object b"". 
This holds especially true if you ever want to have different orderings for non intuitively order-able class objects, think of ascending vs. descendening, by first name, by last name, by number of cars, et cetera. Then nobody will remember what your default ordering is without looking up the documentation/code, thus loosing even its convenience.
Instead, either pass functors or in-place lambda function:
",0,9336579
9318053,"
Here's a bucket sort based on the info in the OP question.
Notes Using a 2d array for the bucket wastes a lot of space... an array of queues/lists usually makes more sense.
I don't normally program in C++ and the above code was written inside the web browser, so syntax errors may exist.
",3,9317248
9326589,"
The following code uses hex digits for a bucket sort (for BITS_PER_BUCKET=4). Ofcourse it is meant to be instructive, not productive.
",1,9317248
40776329,"
a rewrite of Louis's code in C++11 with STL queues.
",1,9317248
9316491,"
I thought the names would explain it, but here we go:
Also note: my original algorithm/code had a bug, we have to do an extra check of ""current"" after the loop ends, as it never finds ""the one after the last"".
",4,9316352
9316408,"
You have almost everything.
You can take advantage of the fact that the array is sorted.
Just go through the array keeping track of both the current equal consecutive numbers, and the greatest number of equal consecutive numbers you have found until that point (and which number produced it). In the end you will have the greatest number of equal consecutive numbers and which number produced it. That will be the mode.
Note: For a solution which does not require the array to be sorted, see for example one based in the histogram approach in a related question.
",6,9316352
9316445,"
Hints: 
Q: How do you define the mode? 
A: The number whose count is greatest within the array.
Q: How do you count numbers in an ordered array?
A: Iterate through the array, and while the next item is equal to the previous, increment the count for that value.
Q: If the count of the previous value is less than the count of the current value, then can the previous value be the mode?
A: No
",2,9316352
41207134,"
If the input array is sorted, here is the same approach as described in other answers but implemented in a different way, a better and easy to understand way.

Run a loop over the input array.
Keep global mode value and mode count.
Run a sliding window till you find equal elements.
If local equal element count is greater than global mode count, then update global mode and mode count.

Here is working and tested code in C++.
",0,9316352
9314882,"
You declared temp as a pointer. You need to allocate it on the heap before dereferencing and assigning to it later. However perhaps a variable on the stack would be preferable?
FYI: You should be aware of the memory leak in readArray as well which is leaving callers responsible for calling delete []
Edit: I hope this will help clear up some of the other problems.
",2,9314788
9314921,"
You make temp an int pointer (uninitiialized), and then set the thing it points at (anything/nothing) to arrPTR[ccount].  Since you are using temp only to swap, it should be the same type as those being swapped, in this case: an int.
If it absolutely must be a pointer (there is no good reason for this, it's slow, confusing, adds potential for errors, and adds potential for memory leaks):
",3,9314788
9314907,"
temp is a ""pointer to int, which you're not initializing. When you say *temp = ... you're actually assigning to whatever temp happens to be pointing, but since you haven't told it what to point to, it can write pretty much anywhere in the address space of your program.
Because of the way you're using them, it seems that temp and swap shouldn't be pointers at all, just a plain int and bool.
",1,9314788
9314892,"
You didn't initialize the temp pointer do when you dereference it you are writing to a random part of memory.  Temp doesn't need to be a pointer, it can just be an int.  Just replace EVERY instance of *temp with temp.
",0,9314788
9279096,"
At the very first invokation of max_heapify(), you invoke it with i = v.size() - 2
Thus, when you set right = i + 2; you actually set: right = v.size()
Now, look at this:
Note that right <= v.size(), and you are now trying to access v[right], which is out of bound.
Note that the last index of v is v[v.size() -1] - so all your if statements should be right < v.size() [instead <=]
I assume solving these issues will solve your bug eventually.
",4,9278979
9279614,"
Your ""for"" loop in build_max_heap() is running backwards. You can't build a heap that way. You start with the first element of the array as a heap and then add subsequent elements to it. This does not work starting from the end, because the rest of the array is not a heap yet.
Also, what amit said.
In particular, a heap will be defined by the array and the size of the heap - not the array because it's not always ALL part of the heap. So you're missing a parameter (the heap size). The only time the whole array is a heap, is after build_max_heap() is done and before you run the second pass to pull it into sorted order. At every other time, the heap size is not the array size.
",0,9278979
43717140,"
",-1,9278979
9242106,"
As the error points out, there is no operator< for Employee, but you are trying to use it in your sorting function.
You need to choose an ordering criteria (e.g. numerically by employee id) and implement operator< accordingly.
E.g.:
If you want to give the caller the choice of the ordering criteria, you can do it like std::sort() by allowing a functor or function pointer to be passed that will be used for the comparisons:
... which you could then e.g. use like this:
",2,9242048
9242141,"
You need to implement the < operator for your employee class.  Don't expect the compiler to know how to do this for you.  You need to tell it what you want that operator to do for the class.
",1,9242048
9234923,"
It's not true that you can make a stable sort out of an unstable one by sorting repeatedly. Consider the final sort: it isn't guaranteed to preserve the previous orderings when it sees equal keys (that's what unstable means).
Instead, what you need to do is sort on a key which unambiguously orders the input - so you need to do one sort, where the key you sort on is all the columns rather than an individual column.
So when you compare the records ""Myrtle,Araucana,2011-08-01,N/A,0"" and ""Myrtle,Araucana,2011-05-01,2011-07-13,0"" you need to compare fields in order until you find a pair that are not equal. (This is known as lexicographic ordering.) You may even need to incorporate the original position, if you need to preserve the order of completely equal records.
Of course if this wasn't homework you'd probably be looking at std::stable_sort. (A sequence of stable sorts on the columns in reverse order would be fine.)
",3,9234516
9236410,"
Well, your sorting looks stable as you have chosen the pivot to be the rightmost element. However, in the end the line.
is swapping the two records just like that, even when they would be equal. Add a check to sort only when they are not equal:
",0,9234516
9220830,"
I'm not sure what the confusion is but I suspect that it is what ""splicing"" refers to: the std::list<T> has an splice() member function (well, actually several overloads) which transfer nodes between lists. That is, you create a std::vector<std::list<T>::const_iterator> and apply the sorting algorithm (e.g. std::partial_sort()) to this. Then you create a new std::list<T> and use the splice() member with the iterators from the sorted vector to put the nodes into their correct order without moving the objects themselves.
This would look something like this:
",3,9220750
9221270,"
Let's say you wanted to do a partial_sort on a list. You could store the iterators to the list in a set, by providing a comparison function that can sort using the iterators, like this:
The you could let set perform the sort, but since it contains iterators to list, you could you list::splice to splice them into a partial_sorted list:
",2,9220750
9220817,"
An ordered container would be either std::set or std::map. If you're willing to make a comparator that takes iterators you would use std::set<std::list<mydata>::iterator,comparator>, otherwise you could use std::map<mydata,std::list<mydata>::iterator>. You go through your list from begin() to end() and insert the iterators into the set or map; now you can use it to access the items in the list in sorted order by iterating the set or map, because it's automatically sorted.
",1,9220750
9221894,"
Ordered containers are std::set and std::multiset. std::set implements a BST. So what it says is that you should crate an std::set<std::list::iterators> and then use the inherent BST structure to do the sorting. Here is a link on BST to get you started.
",1,9220750
9220761,"
Edit Ah. Just noticed ""ordered container of iterators"". That would imply creating an index into another container.
Boost Multi Index has many example of such things (where a single collections is indexed by several different ordering predicates and the indices are nothing more than collections of 'pointers' (usually iterators) into the base container.


""A third is to use the information in an ordered container of iterators to iteratively splice the list's elements into the positions you'd like them to be in""

One thing I think would match that description is when doing std::sort_heap of a list/vector which has had std::make_heap/push_heap/pop_heap operating on it.

make_heap : convert a sequence to a heap
sort_heap : sort a heap
push_heap : insert an element in a heap
pop_heap  : remove the top element from a heap

Heaps are organizations of elements within sequences, which make it (relatively) efficient to keep the collection in a known ordering under insert/removal. The order is implicit (like a recursive defined binary tree stored in a contiguous array) and can be transformed into the corresponding properly sorted sequence by doing the (highly efficient) sort_heap algorithm on it.
",0,9220750
9220613,"
You forgot to dup2 and close before exec. With your code that way it is, sort has no idea which file descriptor to use for what. I don't know what _close_less_than does, but if it closes descriptors 0, 1, or 2, you're calling sort with an environment it cannot understand. You have to plumb your pipes to child's stdin and stdout.
",2,9219989
9217583,"
Imagine every letter as a node in a graph. Each word represents a directed pathway between two letters in. ""ACCA"" defines A->A  ""BAAC""  B-->C . Within this graph you would like to find a Eulerian Path. http://en.wikipedia.org/wiki/Eulerian_path  . The Eulerian Path  is defined as a path that visits every edge exactly once and since each edge represents a word that means you have used all the words!
",1,9217415
9217526,"
A better approach may be to build a directed graph using the strings. There will be an edge from string s1 to string s2 if the last character of s1 is the same as the first character of s2. Then you can try to find the longest path in the graph.
",0,9217415
9199970,"
Your problem is that you're trying to base your loops around the actual values in the vector, not the indexes in the vector.
So if your vector is randomly generated, and you say this:
There is a chance that the value at v[0] is greater than v[30]. Thus the loop would never run. I see the same problem in this loop:
So I'd recommend using indexes for the actual looping. Try something like:
etc...
EDIT: As mentioned below, it would also be better to base your loop of the size of the of the vector. However, to save your self from calling the expensive size() method every time the loops runs, just grab the size before the loop starts. For example:
",1,9199910
9199995,"
You should use 0, pos+1 and v.size() as end points in your for-loops.
",0,9199910
9190633,"
Or you use a vector of pairs, which you then can sort easily with the stl sort algorithm, or you write your own sort method. Therefore you've several options.
Within your own sorting algorithm you can then take care of not only sorting your x-vector but also the y-vector respectively.
Here as an example using bubble sort for your two vectors (vec1 and vec2).
But again, as others pointed out here, you should defenitely use std::vector< std::pair<double, double> > and the just sort it.
",1,9190521
9190558,"
I would probably create a vector of pairs and sort that by whatever means necessary. 
It sounds like your data abstraction (2 separate collections for values that are actually ""linked"" is wrong).
",3,9190521
9190761,"
As an alternative, you could write some kind of iterator adaptor that internally holds two iterators and increases/decreases/assigns them simultaneously. They dereference to a special type that on swap, swaps the two values in both vectors, but on compare only compare one. This might be some work (extra swap,op<, class ), but when done as a template, and you need this more often, could pay out.
",2,9190521
9190835,"
The idea is easy: implement a sort algorithm (e.g. quicksort is easy, short an OK for most use cases - there are a lot implementations available: http://www.java-samples.com/showtutorial.php?tutorialid=445 ). 

Do the compare on your x-vector and 
do the swap on both vectors.

The sort method has to take both vectors a input, but that should be a minor issue.
",1,9190521
9170209,"
The comparator you give to std::sort must establish a strict weak ordering. That means:

For all x, it is not the case that compare(x, x) (irreflexivity).
For all x ≠ y, if compare(x, y) then it is not the case that compare(y, x) (asymmetric).
For all x, y, and z, if compare(x, y) and compare(y, z) then compare(x, z) (transitivity).
For all x, y, and z, if x is incomparable with y, and y is incomparable with z, then x is incomparable with z (transitivity of equivalence).

Your original comparator is not irreflexive: compare(x, x) is true. Using such a comparator results in undefined behaviour, which you experienced first-hand as a std::bad_alloc.
",6,9170080
9107552,"
There is a sorting algorithm in the standard library, in the header <algorithm>. It sorts inplace, so if you do the following, your original word will become sorted.
If you don't want to lose the original, make a copy first.
",123,9107516
9107540,"
See here
",13,9107516
33770211,"
You have to include sort function which is in algorithm header file which is a standard template library in c++.
Usage: std::sort(str.begin(), str.end());
OUTPUT:

abcd

",1,9107516
44945290,"
You can use sort() function. sort() exists in algorithm header file
Output: 

achklors  

",0,9107516
9098715,"
Create 21 random numbers between 1 and 49:
Then you order the numbers:
And finally you print them the way you want.
You can find the quicksort c++ code at wikipedia. Here it is, anyway:
",0,9098375
9098985,"
Do it like the lotto machine does it.  Load all the numers from 1-49 into a list/array. Use rand() to create an index 0-48, get the number from the list at that index and replace it with '0' to flag that it's been drawn. Repeat, (ignoring any '0's that are retrieved), until 21 numbers have been drawn. Sort.
",0,9098375
9099332,"
You can do it like this:

Build an array of 49 numbers
Shuffle the array
Sort the first 7 numbers, print them
Sort the next 7 numbers, print them

Keep repeating step 4. for as many rows you need (at most 7 ;-)). Here's a code sample which implements this strategy. No checking for duplicates needed.
",0,9098375
9099071,"
As the other folks beat me to an answer, I will just add that using the already provided algorithms is usually better than implementing from scratch.  Also, you have to store the random numbers somewhere if you are going to sort them.  In this case, I used the already provided vector class.  Also I believe in C++ you should use the header ctime and not time.h even though they are really the same thing I believe.
",0,9098375
9098719,"
Ok first have a look at loops, mostly the for loop. It should be used to generate the random numbers. For example, to fill an array with 6 random numbers between 1 and 49 you can use:
In your question you say that numbers must be completely random, but I feel you imply that numbers must be unique within the array. If this is the case you should check if each number already exists in the array before adding it again. You can do this with a set structure, but for simplicity you can use something like:
Once you have the numbers in the array, you can sort them. You can use qsort:
http://www.cplusplus.com/reference/clibrary/cstdlib/qsort/
This should be enough to get you started.
Good luck :)
",-1,9098375
9057268,"
boost has a complete (and complex) functionality in MultiIndex, but if I understand your requirements, it's overkill in this case. A fairly easy way could be to build a list of pointers to myStruct and sort. Then you can easily check for duplicate keys (these became adjacents).
sort should use a functor of type less<const myStruct*>, i.e.
",1,9057134
9057185,"
What meaning is there in ""sorting"" a map? Sure, the map may be internally organized as a BST or something to make access faster, but conceptionally the elements of the map are in no particular order.
Other than that, you CAN supply an ordering method for the keys (because even if you do organize the map in a particular way, it is by the order of the keys, not by that of the values), but not for the values with the third template argument for map.
",0,9057134
9057149,"
You can't do this, using std::map - the first in the pair is used for comparing (it's called key). In your case, thestd::string is the key.
You can use std::set< std::pair< std::string, MyStruct > > and then implement operator< for two std::pair< std::string, MyStruct >-s. 
Or, you can change the std::map's definition, if it's possible/allowed/suitable/etc. It really depends on what you're trying to do and what you're allowed to do.
Or some other container (that keeps the order of elements, as inserted - like std::list, std::vector, etc.), and then using std::sort or container's sort method, if exists.
",0,9057134
9057223,"
I agree with the other answers that it's not clear why you need to sort the map. But you can use a bidirectional map to let you view both myStruct and string as keys.
There's one in boost:
http://www.boost.org/doc/libs/1_48_0/libs/bimap/doc/html/index.html
There's an example here
http://www.boost.org/doc/libs/1_48_0/libs/bimap/doc/html/boost_bimap/examples/simple_bimap.html
",0,9057134
9025633,"
You are storing the index of your pivot element in the pivot variable, so swapping the elements can potentially change the choice of pivot element during the loop. Not a very good idea. I would suggest storing the actual value of the pivot element inside pivot instead.
Also, if this really isn't homework, why don't you simply use the standard library facilities?
You will get heavily optimized and tested code that will outperform your handwritten Quicksort anytime.
",4,9025502
21799585,"
Quick Sort that can implement any number of i/p integers.  it also deal with duplicate keys
",0,9025502
16267455,"
Actually, the first one is a bad idea. Use either the second one, or this:
That way your code won't silently break when someone decides numbers should hold long or long long instead of int.
",97,9025084
9025216,"
Use the first:
It's explicit of what's going on - less chance of misreading rbegin as begin, even with a comment. It's clear and readable which is exactly what you want.
Also, the second one may be less efficient than the first given the nature of reverse iterators, although you would have to profile it to be sure.
",56,9025084
37757410,"
With c++14 you can do this:
",46,9025084
32493239,"
What about this?
",25,9025084
38685461,"
Instead of a functor as Mehrdad proposed, you could use a Lambda function.
",20,9025084
9025224,"
According to my machine, sorting a long long vector of [1..3000000] using the first method takes around 4 seconds, while using the second takes about twice the time. That says something, obviously, but I don't understand why either. Just think this would be helpful.
Same thing reported here.
As said by Xeo, with -O3 they use about the same time to finish.
",15,9025084
50131528,"
The shortest approach is:
",6,9025084
44382270,"

First approach refers:   

You may use the first approach because of getting more efficiency than second.
The first approach's time complexity less than second one.
",5,9025084
42956527,"
",4,9025084
38933942,"
You can either use the first one or try the code below, which is equally efficient:
",1,9025084
43695167,"
I don't think you should use either of the methods in the question as they're both confusing, and the second one is fragile as Mehrdad suggests.
I would advocate the following, as it looks like a standard library function and makes its intention clear:
",1,9025084
9048857,"
One option is to use a std :: priority queue to maintain a heap of iterators, where the iterators bubble up the heap depending on the values they point at.
You could also consider using repeating applications of std :: inplace_merge. This would involve appending all the data together into a big vector and remembering the offsets at which each distinct sorted block begins and ends, and then passing those into inplace_merge. This would probably be faster then the heap solution, although I think fundamentally the complexity is equivalent.
Update: I've implemented the second algorithm I just described. Repeatedly doing a mergesort in place. This code is on ideone.
This works by first concatenating all the sorted lists together into one long list. If there were three source lists, this means there are four 'offsets', which are four points in the full list between which the elements are sorted. The algorithm will then pull off three of these at a time, merging the two corresponding adjacent sorted lists into one sorted list, and then remembering two of those three offsets to be used in the new_offsets.
This repeats in a loop, with pairs of adjacent sorted ranges merged together, until only one sorted range remains.
Ultimately, I think the best algorithm would involve merging the shortest pairs of adjacent ranges together first.
",4,9013485
9013599,"
The first thing that springs to mind is to make a heap structure containing iterators to each vector, ordered by the value they currently point at. (each entry would need to contain the end iterator too, of course)
The current element is at the root of the heap, and to advance, you simply either pop it, or increase its key. (the latter could be done by popping, incrementing, then pushing)
I believe this should have asymptotic complexity O(E log M) where E is the total number of elements, and M is the number of vectors.
If you are really popping everything out of the vectors, you could make a heap of pointers to your vectors, you may want to treat them as heaps too, to avoid the performance penalty of erasing from the front of a vector. (or, you could copy everything into deques first)

Merging them all together by merging pairs at a time has the same asymptotic complexity if you're careful about the order. If you arrange all of the vectors in a full, balanced binary tree then pairwise merge as you go up the tree, then each element will be copied log M times, also leading to an O(E log M) algorithm.
For extra actual efficiency, instead of the tree, you should repeatedly merge the smallest two vectors until you only have one left. (again, putting pointers to the vectors in a heap is the way to go, but this time ordered by length)
(really, you want to order by ""cost to copy"" instead of length. An extra thing to optimize for certain value types)

If I had to guess, the fastest way would be to use the second idea, but with an N-ary merge instead of a pairwise merge, for some suitable N (which I'm guessing will be either a small constant, or roughly the square-root of the number of vectors), and perform the N-ary merge by using the first algorithm above to enumerate the contents of N vectors at once.
",2,9013485
24205288,"
I've used the algorithm given here and did a little abstracting; converting to templates.  I've coded this version in VS2010 and used a lambda function instead of the functor.  I don't know if this is in any sense 'better' than the previous version, but maybe it will be useful someone?
The algorithm priority_queue_sort::value_vectors sorts vectors containing values only; whereas priority_queue_sort::pair_vectors sorts vectors containing pairs of data according to the first data-element.  Hope someone can use this someday :-)
",0,9013485
9008363,"
If you want to count the number of swaps needed in insertion sort, then you want to find the following number: for each element, how many previous elements inn the array are smaller than it?  The sum of these values is then the total number of swaps performed.
To find the number, you can use an order statistic tree, a balanced binary search tree that can efficiently tell you how many elements in the tree are smaller then some given element.  Specifically, an orde statistic tree supports O(log n) insertion, deletion, lookup, and count of how many elements in the tree are less than some value.  You can then count how many swaps will be performed as follows:

Initialize a new, empty order statistic tree.
Set count = 0
For each array element, in order:

Add the element to the order statistic tree.
Add to count the number of elements in the tree less than the value added.

Return count,

This does O(n) iterations of a loop that takes O(log n) time, so the total work done is O(n log n), which is faster than the brute-force approach.

If you want to count the number of swaps in selection sort, then you can use the fact that insertion sort will only perform a swap on the kth pass if, after processing the first k-1 elements of the list, the element in position k is not the kth smallest element.  If you can do this efficiently, then we have the following basic sketch of an algorithm:

Set total = 0
For k = 1 to n:

If the element at index k isn't the kth largest element:

Swap it with the kth largest element.
Increment total


Return total

So how do we implement this efficiently?  We need to efficiently be able to check whether the element at a given index is the correct element, and also need to efficiently find the position of the element that really does belong at a given index otherwise.  To do this, begin by creating a balanced binary search tree that maps each element to its position in the original array.  This takes time O(n log n).  Now that you have the balanced tree, we can augment the structure by assigning to each element in the tree the position in the sorted sequence that this element belongs.  One way to do this is with an order statistic tree, and another would be to iterate over the tree with an inorder traversal, annotating each value in the tree with its position.
Using this structure, we can check in O(log n) time whether or not an element is in the right position by looking the element up in the tree (time O(log n)), then looking at the position in the sorted sequence at which it should be and at which position it's currently located (remember that we set this up when creating the tree).  If it disagrees with our expected position, then it's in the wrong place, and otherwise it's in the right place.  Also, we can efficiently simulate a swap of two elements by looking up those two elements in the tree (O(log n) time total) and then swapping their positions in O(1).
As a result, we can implement the above algorithm in time O(n log n) - O(n log n) time to build the tree, then n iterations of doing O(log n) work to determine whether or not to swap.
Hope this helps!
",22,9008044
10265912,"
The number of interchanges of consecutive elements necessary to arrange them in their natural order is equal to the number of inversions in the given permutation.
So the solution to this problem is to find the number of inversions in the given array of numbers. 
This can be solved in O(n log n) using merge sort.
In the merge step, if you copy an element from the right array, increment a global counter (that counts inversions) by the number of items remaining in the left array. This is done because the element from the right array that just got copied is involved in an inversion with all the elements in present in the left array.
Hope this helps
",8,9008044
9008108,"
I'm not sure, but I suspect finding the minimum number is a difficult problem. Unless there's a shortcut, you'll just be searching for optimal sorting networks, which you should be able to find good resources on with your favorite search engine (or Wikipedia).
If you only care about the big-O complexity, the answer is O(n log n), and you can probably get more concrete bounds (some actual constants in there) if you look at the analysis of some efficient in-place sorting algorithms like heapsort or smoothsort.
",1,9008044
21643106,"
",1,9008044
13536544,"
Each swap in the insertion sort moves two adjacent elements - one up by one, one down by one - and `corrects' a single crossing by doing so.  So:

Annotate each item, X, with its initial array index, Xi.
Sort the items using a stable sort (you can use quicksort if you treat the `initial position' annotation as a minor key)
Return half the sum of the absolute differences between each element's annotated initial position and its final position (i.e. just loop through the annotations summing abs(Xi - i)).

Just like most of the other answers, this is O(n) space and O(n*log n) time.  If an in-place merge could be modified to count the crossings, that'd be better.  I'm not sure it can though.
",0,9008044
26319406,"
",0,9008044
8988071,"
A two-level approach:
Sort the the string s into a sorted string t, and add an entry to a map<string, vector<string> as m[t].push_back(s);. Then each entry of the map is a vector of mutually anagrammatic strings.
You could implement the same logic in a single, flat multimap, but that would be far more expensive  (since you'd have to sort the string each time); or you could make a comparator that lexicographically compares the sorted string first and the actual string second, but again that's very expensive.
",1,8988009
8988063,"
The obvious and also the best way is quite similar to the one you chose in Java: implement a custom comparer.
In C++, that’s a specialisation of a less-than predicate:
And call it like this:
But (just like your Java code) this is quite inefficient since the sorted anagrams have to be computed repeatedly. It would be much more efficient to only compute them once (on first use, say) and cache them.
You could for instance maintain this cache inside the less_than_sorted_anagram predicate as a std::map<std::string, std::string> (or a similar dictionary mapping strings to strings).
",5,8988009
8948920,"
You're looking for std::set. It keeps things sorted as you insert, and gives you a quick ""not in"" operation.
",9,8948900
8948960,"
The very best option when you know that the numbers you're sorting will always be between 0 and a max_value is Counting sort, with an unsurpassable complexity: O(n).
",3,8948900
8948922,"
The best option would be to not sort the array at all and then wait until the end before sorting.  Sorting repeatedly in an array will be expensive, because you will have to shift elements over one way or the other.
Since you are interested in the operations

Insert an element
Check if an element is there
Maintain sorted order

You should consider looking into a different structure than an array, perhaps a binary search tree, which supports fast (O(log n)) insertion and can be used to retrieve the sorted order.
Hope this helps!
",2,8948900
8940690,"
Your compare function needs to return a boolean 0 or 1, not an integer 1 or -1, and it should have a strongly-typed signature:
The error you were seeing are due to std::sort interpreting everything non-zero returned from the comp function as true, meaning that the left-hand side is less than the right-hand side.
NOTE : This answer has been heavily edited as the result of conversations with sbi and Mike Seymour.
",7,8940629
8940821,"
int (*)(void*, void*) is the comparator for C qsort() function. In C++ std::sort() the prototype to the comparator is:
On the other hand, you can use std::pair struct, which by default compares its first fields:
",5,8940629
8940774,"
Without knowing what concurrent_vector is, I can't be sure what's causing the segmentation fault. Assuming it's similar to std::vector, you need to populate it with hits.push_back(obj) rather than hits[i] = j; you cannot use [] to access elements beyond the end of a vector, or to access an empty vector at all.
The comparison function should be equivalent to a < b, returning a boolean value; it's not a C-style comparison function returning negative, positive, or zero. Also, since sort is a template, there's no need for C-style void * arguments; everything is strongly typed:
Also, you usually don't want to use new (and certainly never malloc) to create objects to store in a vector; the simplest and safest container would be vector<hits_object> (and a comparator that takes references, rather than pointers, as arguments). If you really must store pointers (because the objects are expensive to copy and not movable, or because you need polymorphism - neither of which apply to your example), either use smart pointers such as std::unique_ptr, or make sure you delete them once you're done with them.
",5,8940629
8940721,"
The third argument you pass to std::sort() must have a signature similar to, and the semantics of, operator<(): 
When you store pointers in a vector, you cannot overload operator<(), because smaller-than is fixed for all built-in types. 

On a sidenote: Do not use malloc() in C++, use new instead. Also, I wonder why you are not using objects, rather than pointers. Finally, if concurrent_vector is anything like std::vector, you need to explicitly make it expand to accommodate new objects. This is what your code would then look like: 
",4,8940629
8941069,"
This doesn't look right:
here you already are sorting the array based on 'i' because you set position to i as well as it becomes the index of hits!
also why using malloc, you should use new(/delete) instead. You could then create a simple constructor for the structure to initialize the hits_object 
e.g. 
then later write instead
or even
Finally, your compare function should use the same data type as vector for its arguments
",0,8940629
8932915,"
Indeed you are not putting anything in pairs.
See constructor of std::pair.
Also if you want to reorder Items based on attribute value, you probably want to call std::sort on a list of std::pair<double, Items> (not a pair of list) and provide the appropriate comparison function.
",2,8932764
8921475,"
You need to declare your simpleComparator as a static method, otherwise it won't fit the type expected by std::sort. 
To be perfectly correct, you should also then pass it as TeamMatcher::simpleComparator, see here for details.
",8,8921421
8921530,"
Try this instead for your comparison function:
Note that the comparison function is not a member of your TeamMember class, and passing const references in prevents needless copying.
You can take one step further and define a comparison method for Students
Now you can just call sort on your students and it'll have a comparison method to use:
However in this case I recommend the first approach, unless you always want to compare Students by the number of hours available. For instance, this may be confusing to another programmer:
It may be confusing because it's not readily apparent how you would compare two students (GPA, attendances, hours available, height, IQ, whatever...)
",1,8921421
8872993,"
You need to make it static cmp_big_first.  Without being static, the method takes an implicit this parameter (of the class type), which does not make sense for your usage.
",4,8872979
8864654,"
Any nonstatic member function of class X has an extra argument - a reference/pointer to (const) X which becomes this. Therefore a member function's signature isn't such that can be digested by sort. You need to use boost::bind or std::mem_fun or std::mem_fun_ref. When using C++11, you can use std::bind.
Come to think of it, the best solution in this case would be to make your comp function static, because it doesn't need this at all. In this case your original code will work without change.
",6,8864633
10677313,"
The line causing the error is:
I'm not quite sure what you're trying to do here, it looks like you just want to print it in which case the numbers = isn't needed.
The structure of your loop to read all the data is problematic also. The line: while (!inputFile.eof()) isn't idiomatic C++ and won't do what you hope. See here for a discussion on that issue (and here).
For reference you can do this quite simply with less work by using std::sort
This program also uses a std::vector instead of an array to abstract the ""how big should my array be?"" problem (which your example looked to have a possible problem problem with).
",6,10677119
10677260,"
Here is what you need to do to get your program to work:

Change ANYSIZE_ARRAY to 5
Where you read the numbers, replace the while with this:


This way, you will create an array which can hold 5 numbers, and you will read the numbers into that array. I used 5 because I saw that you were using the same number in the sorting algorithm, so I assumed that you only have to read 5 numbers. This is a bad thing, because your program will only work with 5 numbers.
If you need it to work with a variable amount of numbers, you can use a std::vector<long> to store the numbers. You can create a vector, and then use push_back() to add numbers to it. The vector will resize automatically and will hold as many numbers as you put in it. Then you can replace the 5s in your code with the vector's size() method.
You were getting your original error because this line doesn't make sense:
C++ views that line as if you are trying to print out the number to the stdout stream (which is in our case the console, the screen), and then assigning that stream to the ""numbers"" array. You cannot assign an output stream to an integer array (hence the error cannot convert from ostream to int[1]).
",3,10677119
10677340,"
First, you should not assign an outstream variable to an int.
Second, n is long type and numbers is an integer array. There is type-unsafety.
Third, you should pre-allocate array size.
Forth, you can directly use sort() in STL function to do the sorting.
Try the following code:
",3,10677119
10652701,"
You can't use std::sort to sort std::list, because std::sort requires iterators to be random access, and std::list iterators are only bidirectional.
However, std::list has a member function sort that will sort it:
",40,10652674
10652700,"
You should use list::sort, which may use a different algorithm. std::sort requires random-access iterators (supporting jumps of arbitrary size) whereas list iterators can only go forwards or backwards by one link at a time.
See C++11 25.4.1.1:
and 23.3.5.5/27 (members of std::list):
",8,10652674
10641741,"
temp should be a double, not an int, if you don't want things you assign to it to become integers.
",4,10641718
13822281,"
If you use ""i"" only as counter then you can declare it inside the for loop such as
This will save some trouble. Anyway, 
Change
int i, temp; 
to
Double means it can hold decimal numbers, integer means whole numbers. When you are swapping around to do the bubble sort, it is converting your double to integer type. Your compiler should given a type conversion error, but should compile.
",1,10641718
10641789,"
Check 
temp must be double!
",0,10641718
10641761,"
Try this:
",0,10641718
10633621,"
Not sure exactly what you're trying to achieve but perhaps you need to employ a bloom filter as a preliminary check for existence of an element to speed up the process.
Please note, when the article says ""m different hash functions"", what it really means is, m different functions that can be the same algorithm with different parameters that produce unrelated results.  For example you can simply prepend the data to be hashed with a byte valued 0 through m-1.  Or you could take the 256 bits of a SHA256 hash and chop it up into groups of 24 bits or however big you need your filter to be.
",0,10633439
10634181,"
Using a std::map:
The main function:
",0,10633439
10589246,"
I would first try to pass a function pointer to std::sort, and thus use it in the qsort way:

the algorithm itself is precompiled
the comparison function is JITed and passed dynamically

I think it would still be superior to qsort because the algorithm would manipulate the memory meaningfully and only the comparison would be called (really).
",2,10587250
10584944,"
Instead of sorting integers of array1, sort their indexes using array2[index] to compare items, and then re-arrange array1 in accordance with the permutation that you get back from the sort.
Here is a quick demo:
",5,10584894
10584930,"
yes. You need to group the two arrays into one array of pair, and then define the compare function.
the compare function could be:
",2,10584894
10585323,"
Well, you just have to use the position of the elements to index the other array in your comparision function (the standard guarantees that the pointer arguments of the comparison function always point into the to be sorted array):
The disadvantage is, that the comparison function explicitly needs to know the specific arrays, as it cannot take any additional parameters.
I would question the use of qsort anyway, since your question is tagged C++. Although std::sort has the same problem, you can reach much more genericity/abstraction by using a comparison functor that encapsulates the depending arrays.
",1,10584894
10581051,"
Using C++11, the following should work just fine:
",36,10580982
10581191,"
You could try something like this:
",7,10580982
10585614,"
Adding to @Konrad answer:
If for some reason you are not able to use C++11, then you can use boost::phoenix to simulate it like
",4,10580982
10581099,"
For C++03, I think this guru of the week can help you :
The original article is here.
",2,10580982
10579045,"
I think you are in dire need of Templates!
You can write a template function and then write a specialization for the said types to do something specific if the need be.
",18,10579022
10579329,"
Using templates, define two versions of the function, one where the parameters are the same type and one where they can be different:
Output:
",25,10579022
10579214,"
call as
",5,10579022
10579338,"
Most probably you need to use templates as other people suggest:
Because you normally want compilation to fail when the operation implemented by a generic function does not make sense for particular types,  so you would either use conditional definition (in the below example is_arithmetic):
or static assertion in the code to yield the same result:
",3,10579022
10579759,"
I'm going to stick my neck out here and say you don't need Templates to do this. I'm not saying don't use them, but just that depending on exactly what you're wanting to do, there are alternatives.
What it sounds like you want is the ability to compare two generic objects provided that they adhere to a common set of ground rules. You could actually implement this using traditional inheritance or using templates. The choice of which you want comes down to how flexible you need it to be and whether you want some of the decisions to be made at runtime or compile time. If the latter - i.e. you want to pick up on casting errors etc., - then go for templates.
Either way, your objects will either have to adhere to some basic groundrules for how you compare them and preferably encapsulate that - this way your comparitor would be generic. or you'd have to write different comparitors for each object comparison. While it sounds like the latter is what you want, be wary of letting too much of your class implementation leach out into the comparitor function and thereby breaking encapsulation.
From my own experience, going straight to the template approach can occasionally result in a lot of bloated, messed up code which is hard to read, debug and maintain. Take a hard look at you design and what you actually need first.
",1,10579022
10580478,"
OP seems to want to know if the 2 objects are comparable or not. You can use template specialization to achieve this (note: this doesn't compile on VC 10, but does on g++ 4.7). The only nuance, is you want this function to 

they are compared and a comparison value is returned otherwise some other value is returned to indicate a comparison was not possible

But you need to define some sort of structure to signify that a comparison was not possible; using a magic number '-500' or whatever is not good style. Alternately, you could throw an error, and allow it to be caught an handled.
Output:
C:\MinGW\MinGW>a
Comparable
0
Not comparable
-500
Comparable
1
",0,10579022
42083227,"
It seems that you are referring to Common Lisp / CLOS -style generic functions which do multiple dynamic dispatch. C++ does single dynamic dispatch with methods but only single static dispatch with functions. So the answer is no. C++ doesn't support this at the moment. There have been proposals along the years to add it into the language but that hasn't happened yet.
",0,10579022
10543163,"
It is a good idea to separate different actions into functions. This makes your code cleaner, easier to read, and more modular. 
For example, in this problem, you have three distinct things going on: reading your data into a file, sorting it, and printing it. Write your own functions to read the data in and print it. You know there is already a function to sort, so use that.
Here is an example (using a little bit of C++11), that uses techniques that you might not be ""allowed"" to use, but it gives you a good starting point to learn what you need to modify in your own code.
Notice that in main, the code is self-documenting: it says to read the players from a file, sort them, then print them.
",1,10542930
10543139,"
Dont sort while reading the data. Put the sort function outside reading:
sort(players, players+30);
And if you're wondering about overloading dont, cause std::string provide it's own overloaded <, >, =, etc, etc.
",0,10542930
10471623,"
Also, move prev = curr forward:
",0,10471472
10471517,"
The while exit condition is inverted:
should be
If curr is NULL, it will crash (well, UB to be exact) before it checks for NULL.
",1,10471472
10401969,"
The line 
Creates a vector of size src.size() filled with default elements (here: pair(0, 0.0));
The .push_back() adds additional elements to the end of that array (now the size of (2*src.size())
Then after the sort you print only the first src.size() elements, which are all the initial 0,0.0 ones
To fix, just declare the vector empty:
",5,10401839
10398357,"
The common technique is to provide comparison operators, <, >, <=, >=, == and !=, for a class that can be compared.  Most sort algorithms require that items in the container can be ""less than comparable"".  
Look up the Boost library as it has tools that will define all comparison operators when only  less-than and equality are defined.
In your design, you will need a container for your students.  Use std::sort or your preferred sorting function on the container.  If this is homework, you may want to put the container in main() along with the sorting logic.
Also, either search the web for ""C++ overloading operators"" or define your own method.  If you are clever, you can design your class to have different comparison functions to allow sorting by the different fields.  
",0,10398099
10396592,"
The normal method is to have a bool student::compareAges(Student const& otherStudent) method, aand pass that as an extra argument to your comparison function. E.g. it's the third argument to std::sort when you're not using the default operator<
",3,10396527
10396594,"
The sort_array function must not be in a different file but in the .cpp of your Student class decleration.
And you do not have to pass the id as a parameter since you can access (even if it is private) it because you will be in that class's scope.
",0,10396527
10396680,"
sort_array doesn't belong in the student class! Nor does it make sense ""to sort the int id"" for an instance of student.
Sorting a collection of students by id using the C++ standard library's std::sort() function is certainly possible.
You can define a less-than operator for your student class, thus:
Since it is a member of the class it can access all of its data.
It must be public:, then std::sort() function will be able to use this to sort a standard C++ container (or array) of student. based on the id. If you want to compare multiple attributes of the class, be sure to implement strict weak ordering.
",0,10396527
10383632,"
If you only want the top three values, the most efficient way may be to define three variables (or a three-element array), read the file line-by-line, and if a newly read line belongs in the top three, put it there.
But if you want to use containers, I'd go with a std::vector and use std::sort, assuming that the file is small enough that all the data fits in memory.
",3,10383563
10383733,"
I would prefer to put them into a std::map (if you have unique keys. If not use a std::multipmap instead.) So as you insert data into the map, they will always be sorted. And if you want to get the 3 highest values, just get the first 3 items of the map.
",2,10383563
10362534,"
You need to make the arguments to your comparison operators const-references and make the operators const themselves.
",4,10362509
10321137,"
You are passing A by value instead of by reference, so quickSort is making a copy of A and sorting that. Instead try passing the vector by reference:
... and
",5,10321117
10321242,"
Because you pass the params by value and not by reference. Actually you should have a function with iterators for the start and the end of an array (vec.begin(), vec.end()) as parameter. Additionally your algorithm should accept any kind of iterator. So you should use templates!
",0,10321117
10309341,"
The first thing is that there is no advantage in implementing the operator as a member function, and there can be advantages in doing it as a free function. In particular, a member function is not symmetric with respect to the types of the two operands, the left-hand-side (lhs) must be of the exact type of the class on which it is being called, while the right-hand-side (rhs) can use implicit conversions. In the case of free function operators, the same conversions can be applied to lhs and rhs.
Note that the main difference here are the implicit conversions, and that makes a difference only if your type can be implicitly converted from other types. If there are no implicit conversions into your type, then this point would be moot, but considering that there is no disadvantage in using a free function and there are advantages in some cases, I would use free functions whenever possible.
I wrote some time ago about operator overloading here, you might find some suggestions there.
",3,10308936
10308722,"
bool operator< (constPoint &p1,constPoint &p2 )
",6,10308686
10288028,"
The obvious starting point would be a structure with operator< defined for it:
...and an std::vector to hold the data:
and std::sort to do the sorting:
The simple fact is, that the normal containers (and such) are sufficiently efficient that using them doesn't make your code substantially less efficient. You might be able to do better by writing some part in a different way, but you might about as easily do worse. Start from solid and readable, and test -- don't (attempt to) optimize prematurely.
Edit: of course in C++11, you can use a lambda expression instead:
This is generally a little more convenient to write. Readability depends--for something simple like this, I'd say sort ... by_number is pretty readable, but that depends (heavily) on the name you give to the comparison operator. The lambda makes the actual sorting criteria easier to find, so you don't need to choose a name carefully for the code to be readable.
",16,10287924
10288111,"
std::pair and std::sort fit your requirements ideally: if you put the value into the pair.first and the index in pair.second, you can simply call a sort on a vector of pairs, like this:
",5,10287924
10288143,"
std::sort has proven to be faster than the old qsort because of the lack of indirection and the possibility of inlining critical operations.
The implementations of std::sort are likely to be highly optimized and hard to beat, but not impossible. If your data is fixed length and short you might find Radix sort to be faster. Timsort is relatively new and has delivered good results for Python.
You might keep the index array separate from the value array, but I think the extra level of indirection will prove to be a speed killer. Better to keep them together in a struct or std::pair.
As always with any speed critical application, you must try some actual implementations and compare them to know for sure which is fastest.
",3,10287924
10289470,"
It might be worth separating numbers and indexes and then just sorting indexes, like this:
This prints:
The idea is that the elements being sorted are small and thus fast to move around during the sort. On modern CPUs however, the effects of indirect access to numbers on caching could spoil these gains, so I recommend benchmarking on realistic amounts of data before making a final decision to use it.
",3,10287924
10288024,"
",1,10287924
10287992,"
Use std::vector and std::sort. That should provided the fastest sort method. To Find the original index create a struct. 
Then make your own compare Predicate for sort that compares the num in the struct.
std::sort(vec.begin(), vec.end(), Predicate())
",1,10287924
10288876,"
This will be used on supercomputers?
In that case you may want to look into parallel sorting algorithms.  That will only make sense for sorting large data sets, but the win if you need it is substantial.
",1,10287924
10289325,"
You might find this to be an interesting read. I would start with STL's sort and only then try and improve on it if I could. I'm not sure if you have access to a C++11 compiler (like gcc4.7) on this super computer, but I would suggest that std::sort with std::futures and std::threads would get you quite a bit of the way there with regard to parallelizing the problem in a maintainable way.
Here is another question that compares std::sort with qsort. 
Finally, there is this article in Dr. Dobb's that compares the performance of parallel algorithms.
",0,10287924
10287671,"
If you are using C++, the stable_sort function is stable and have O(nlogn) performance.
Otherwise, in-place quicksort is by its nature, unstable (I believe so). The trivial variant that use an extra array to store information is stable, however.
I've used at least one version of qsort() that is unstable, because once I found that the result produced by qsort() and stable_sort() for a input case on my machine were different.
",3,10287599
10287715,"
You can't take an unstable sorting algorithm such as quicksort and make it stable just by changing the comparison operator. You have to start with a stable sorting algorithm, and then the comparison doesn't matter (as long as it's strict weak ordering in C++).
",2,10287599
10288007,"
If the arrays that you're sorting really are all that small, then you might be better off using another sort algorithm.  See e.g. the answers to : Fast stable sort for small arrays (under 32 or 64 elements) and Fast algorithm implementation to sort very small list.
",0,10287599
10271457,"
The only difference is that the first will not include vec[finish] in the output, while the second will.
",3,10271410
10271694,"
Seems like your just copying a range from the vector, you can use std::copy for that. Also for good practice, pass by const-reference when possible. And as other have pointed out the difference between the two is that the first function treats finish as one pass the end while the second one includes it. Generally you might want to stay consistent and use the first one since it would be consistent with STL.
",0,10271410
10259938,"
The problem is that the ""compare"" function parameter that bubble_sort expects is of type:
While the ""cmp"" function is of type:
In order to fix it, modify the ""compare"" parameter's type:
",2,10259846
10663668,"
This is how I handled with this problem:
Now it should work fine in MS Visual.
",0,10259846
10246634,"
Quick sort: With 32000 elements, quick sort only goes about 15 deep in recursion, you shouldn't worry about the stack size. Problem might be though that the object you try to pass is a local variable in a function, thus has a limited size. Try allocating it as a global or a static variable, eg:
Merge sort: I see you call new a tons of times, but no delete. I don't see why you need to allocate memory anyways, you could just use pointers instead. Try adding 
At the end of merge;
Next  time try to give a little more diagnostics help, than it doesn't work. Error message perhaps.
Cheers, hope it was helpful.
",3,10246235
10234720,"
Right now the argument to < is const but the member is not.  This means a < comparison between 2 const WordEntry& objects will fail because it can't bind to <.  You need to make the member and the argument both const
Note: As pointed out in the comments you should also pass WordEntry by reference
",7,10234682
10234936,"
The getWord member function creates a copy of the internal member attribute and returns the copy. Two consecutive calls to getWord will return two different std::string instances with the same contents, but they are different objects none the less. The lexicographical_compare function requires that the first and second arguments are iterators into the same container, and similarly the third and fourth arguments. In your case you are passing iterators into different containers (string), which will be compared inside the function and will yield undefined behavior.
The simplest solution is have getWord return a const reference to the internal std::string, in that way, the iterators will both refer to the internal object in the right hand side object.
As others have also mentioned, you should pass the WordEntry by const reference, and the operator< should be const, to improve the code. But the issue in your implementation is the mixture of iterators from different container.
",2,10234682
10234736,"
Use a const reference for the rvalue and make the method const to promise the compiler you won't change the object.
You also don't need to explicitly call the operator.
Once defined for the WordEntry object you can do this:
Since you aren't using a custom comparing predicate you could just use the std::string::operator<:
David makes an excellent point on returning the internal member by value. If you want to use lexicographical_compare with an accessor instead of the _word member directly (which can as you're in the class scope) then you should define it like so:
",2,10234682
10202876,"
It isn't clear whether the ranges can overlap, but if they can't, then this should work.  I've included a complete example with tests.
",1,10202275
10197447,"
When poking around on the net for issues related to -Warray-bounds in GCC, it seems that problems with it crop up occasionally but those problems usually seem to be tied to very specific code scenarios. The feature seems to rely on the optimizer - this is why the -O2 option is necessary for you to see the problem. (see http://gcc.gnu.org/bugzilla/show_bug.cgi?id=35903#c9 where it's mentioned that ""the reason this requires -O2 is that -Warray-bounds requires VRP to warn"" - VRP is Value Range Propagation). Minute differences in source can easily cause different behavior in the optimizer.
Anyway, I think the more important thing about these problems with -Warray-bounds is that they seem to also be tied to very specific compiler versions.  For example, this bug (http://gcc.gnu.org/bugzilla/show_bug.cgi?id=43949) reported against 4.4.3 (for all I know, this bug may be what's causing the warning for you) is reported as working for 4.2.4, 4.5.1, and 4.6.0, while it's also broken in 4.5.0.  The fix for it apparently went into some 4.5.x version of the compiler.
Anyway, the bottom line: if this is really a problems for you (ie., it's not just a curiosity), you might want to consider one of the following workarounds/fixes:

move to a version of GCC that's 4.5.1 or better
work around the problem with a code change. As mentioned, small changes may prevent the warning from being triggered
turn off the warning with -Wno-array-bounds

",1,10191163
10196063,"
Irrespective of which one got compiled without warnings, there is a bug in both the codes. In both the codes you are using n uninitiated (also array a[10]).
So, before using ""n"" in the sort function, you might like to store the length of array ""a"" in it.
Here is the proper version of your code - 
",-1,10191163
10189611,"
You can store data with indexes in pairs...
First sort by values, second sort by indexes...
You just need these classes:
",9,10188920
10172966,"
It seems that you have to use cvContourArea to calculate area of each contour and then sort them using any sorting algorithm.
Good luck!
",0,10171677
10141916,"
A priority queue only gives you access to one element in sorted order -- i.e., you can get the highest priority item, and when you remove that, you can get the next highest priority, and so on. A priority queue also allows duplicate elements, so it's more like a multiset than a set. [Edit: As @Tadeusz Kopec pointed out, building a heap is also linear on the number of items in the heap, where building a set is O(N log N) unless it's being built from a sequence that's already ordered (in which case it is also linear).]
A set allows you full access in sorted order, so you can, for example, find two elements somewhere in the middle of the set, then traverse in order from one to the other.
",37,10141841
10142015,"
std::priority_queue allows to do the following:

Insert an element O(log n)
Get the smallest element O(1)
Erase the smallest element O(log n)

while std::set has more possibilities:

Insert any element O(log n) and the constant is greater than in std::priority_queue
Find any element O(log n)
Find an element, >= than the one your are looking for O(log n) (lower_bound)
Erase any element O(log n)
Move to previous/next element in sorted order O(1)
Get the smallest element O(1)
Get the largest element O(1)

",24,10141841
10141881,"
set/multiset are generally backed by a binary tree.  http://en.wikipedia.org/wiki/Binary_tree
priority_queue is generally backed by a heap.    http://en.wikipedia.org/wiki/Heap_(data_structure)
So the question is really when should you use a binary tree instead of a heap?
Both structures are laid out in a tree, however the rules about the relationship between anscestors are different.
We will call the positions P for parent, L for left child, and R for right child.
In a binary tree L < P < R.
In a heap P < L and P < R
So binary trees sort ""sideways"" and heaps sort ""upwards"".
So if we look at this as a triangle than in the binary tree L,P,R are completely sorted, whereas in the heap the relationship between L and R is unknown (only their relationship to P).
This has the following effects:

If you have an unsorted array and want to turn it into a binary tree it takes O(nlogn) time.  If you want to turn it into a heap it only takes O(n) time, (as it just compares to find the extreme element)
Heaps are more efficient if you only need the extreme element (lowest or highest by some comparison function).  Heaps only do the comparisons (lazily) necessary to determine the extreme element.
Binary trees perform the comparisons necessary to order the entire collection, and keep the entire collection sorted all-the-time.
Heaps have constant-time lookup (peek) of lowest element, binary trees have logarithmic time lookup of lowest element.

",22,10141841
36473457,"

Since both std::priority_queue and std::set (and std::multiset) are data containers that store elements and allow you to access them in an ordered fashion, and have same insertion complexity O(log n), what are the advantages of using one over the other (or, what kind of situations call for the one or the other?)?

Even though insert and erase operations for both containers have the same complexity O(log n), these operations for std::set are slower than for std::priority_queue. That's because std::set makes many memory allocations. Every element of std::set is stored at its own allocation. std::priority_queue (with underlaying std::vector container by default) uses single allocation to store all elements. On other hand std::priority_queue uses many swap operations on its elements whereas std::set uses just pointers swapping. So if swapping is very slow operation for element type, using std::set may be more efficient. Moreover element may be non-swappable at all.
Memory overhead for std::set is much bigger also because it has to store many pointers between its nodes.
",4,10141841
10140832,"
Eigen matrices are column-major per default.  That means, that a row of a matrix is not a contiguous C array and you cannot use the data pointer as an iterator.
For example, a 3x4 matrix would be stored as:

0 3 6  9
1 4 7 10
2 5 8 11

Now, row(1) would be

1 4 7 10

But the pointer iterator you are passing to nth_element() will access

1 2 3 4

Your code works if you change your matrix typedef to row-major:

Update: Your edited example works since you copy the row to a vector.  For vectors (one-dimensional matrices), it does not matter if the data is stored row-major or column-major.
",6,10140746
10082196,"
Your right.erase(right.erase(right.begin())); code looks dodgy. The erase function returns an iterator to the successor of the element which was deleted, which is the end() if you deleted the last element.
You're guarding this code with  right.size() > 0 which only guarantees there is one item. You have two erase operations.
Have you looked into the consequences of doing erase on right.end()?
",1,10081781
10039064,"
std::list has a sort function to which you can pass a comparator, so write one of those like this:
Then you can sort the list like this:
",4,10039018
10039109,"
First, why are you using a list? It's virtually always a poor choice. Why are you using a container of pointers? There's good reason for that a little more often than using list, but we're still only talking about .05 percent of the time instead of .02 percent. Who knows -- in this case it might even work out for the best.
Anyway, we'll assume for the moment that those really make some sense for some reason. I'm also going to assume you can't modify the original collection (not clear whether this is true -- if not, just skip copying it, and sort the original collection -- but if you didn't need to maintain the order for some reason, it's nearly certain didn't really want a list. 
Under those assumptions, you probably want to copy the collection, sort that, then present:
If you have C++11 available, you can use a lambda to shorten that a bit and keep the logic where it's a bit easier to see what's going on without chasing around the code to find the comparison:
Note that to get descending order, we're reversing the usual order in the comparison.
",2,10039018
10033363,"
I suspect that m_list is storing the items by value and that swapping them is expensive. You could try to either implement a faster swap or store them in the container by smart pointer.
Of course a profiler could help you pinpoint the problem much more precisely.
",2,10033312
10033494,"
Since m_list is a QList it does not have the same interface or performance characteristics as a normal list. For example, apparently a QList stores an array of T* internally. This representation could be sorted without any copying if the sort algorithm is aware of this implementation detail. By contrast std::sort is probably deep copying the values around, or maybe moving them, which is going to be more work than sorting pointers in the QList array.
It's probably best to use Qt containers with Qt algorithms, since Qt algorithms are more likely to be specialized for Qt containers. Or you could avoid using Qt containers and just stick with the standard library.
Anyway, try using Qt's qSort algorithm:

Original answer
std::sort can't take advantage of the fact that nodes in the list can be moved around without copying the element. Assuming you're using std::list or something similar, use the sort member function.
If you can't do that then you may be able to optimize all those copies by making sure that your elements are move-enabled if you're using C++11.
",1,10033312
9981646,"
If your problem demands that:

you store your elements fully sorted in an actual C/C++ array, and
you maintain your items in sorted order at all times,

then you've painted yourself into a corner:  your requirements spell ""insertion sort"".
No matter what algorithm or auxiliary datastructure you choose, inserting a new element in the middle will require you to move the larger elements up by an index, and deleting any element (except the largest) will require you to move the larger elements down by an index.  Since an insertion sort does exactly that, without any additional logic or datastructure, you might as well use it.
The only exception is if your comparison is particularly expensive.  If that is the case, then you can use a binary search to find your insertion point (instead of comparing your new element against each old element as you move it).  However, you will still need to move all elements larger than the mutation point, so you will never be able to improve your performance past O(N) (although a bulk data move should be pretty fast...).
Also, you should evaluate your requirements:  if you know that N < 256, and the worst case of inserting an object in position 0 is fast enough for your application, you should stop there.  There's no point in making things more complicated than necessary, to save time you don't need.

On the other hand, if:

you don't actually need to keep all elements fully sorted at all times, and
what you do actually need is to repeatedly find and remove the largest/smallest element in the array

then what you need is called a priority queue, and you can implement it (in memory-efficient, in-place fashion) by using an implicit heap.  Implicit heap operations are O(log N), and typically have a good performance factor; even for N = 255, this can make a big difference in worst-case performance.
",9,9980892
9981173,"
I often use this algo in microcontroller environment, it keeps the table always sorted. It doesn't use binary lookup, but the loop that searches a greater element will run faster then binary algorithm if you only going to use it for a small number of elements. For larger arrays, you may want to do a binary lookup.
This algorithm is also very easy to implement in assembler and only uses 2 additional int's on stack.
",3,9980892
9981311,"
Honestly for something like this, I'd just do a shell sort and call it good.  You can hard code the skip elements into a register/asm friendly format to prevent that from leaking onto the stack.  Plus, the performance will be very close to O(log(n)).  That and you can code it or copy it from elsewhere almost instantly.  Very small code/mem footprint as well.  This was my sort of choice on a very, very similar situation on a GBA game sorting actor by (int) Y depths.
",1,9980892
9981219,"
If you are going to frequently be sorting an array of integers that is already sorted, or partially sorted, then smooth sort might be a good choice.  It requires O(1) auxiliary storage, runs in O(n log n) in the worst case, and as the input array becomes more sorted the runtime approaches O(n).
I've only ever really compared smooth sort with quick sort.  I'll post some of the numbers here, but more numbers and a Go implementation of smooth sort are available here.
Number of swaps and comparisons on 1k elements:
Smoothsort on 1k elements:
Quicksort on 1k elements:
",0,9980892
9981468,"
I would just do an introsort, unless you know the distribution of the data.  That's a quicksort with maximum depth of log(n), then it switches to either heapsort or insertion sort depending on the size left. (In your case, that will always be insertion sort.
If you know the distribution of the data, you might try a bucket sort.  For instance, if they're evenly distributed, between 0 and 2147483648, count how many are in each ""range"" of 46341ish values, and then rearrange them into the correct ""range"".  Then sort each ""range"".  I explained that terribly so heres an example (with values 0-15, ranges of 4 values)
For that last step, you simply do any fast sort on each of the small ""buckets"".  It's hard to do in-place though.  (I've done it, but it's hard)  Quicksort is much easier to program.
",0,9980892
9982869,"
I've implemented comb sorts for relatively small lists (<1000) on SPEs (not quite embedded processors, but they have serious limitations) with good results -- small memory footprint, in-place sort, n log n average complexity with n best case, not prone to quicksort's poor median choice problems, easy to understand, and simple to implement.
The only real annoyance I might see is most implementation's tendency to use floating point ops to calculate the gap size -- but you can usually skirt that if you're careful.
",0,9980892
9984576,"
If your list were larger, timsort would be excellent - it's Supernaturally Fast (tm), and does very well with already sorted, or mostly sorted, arrays.  Both Python and Java use timsort now in their standard libraries.
Since you have a small array, I'd probably do an insertion sort or bubble sort (!).  The variant of a bubble sort that keeps going until no adjacent values are exchanged would likely be pretty nice here.
Don't let people tell you all sorts are the same for this - the sorts that are good for huge arrays tend to have higher constants than the sorts that are good at small arrays, and the constants can be a big deal at low values of n.  That's why a great sorting algorithm will generally use an nlogn sort in the large, but switch to a low constant, O(n^2) algorithm for small sublists.
But is an array really the best choice?  If you're messing with this datastructure a lot, you might be better served by a treap or red-black tree.  Both of these datastructures are always sorted, and can do almost any operation in O(logn) time (except getting a sorted list, which is O(n)).  Treaps give better average operation time than red-black trees, but red-black tree operation durations have a lower variance.  This is because treaps are almost always faster than red-black trees, but treaps will infrequently do a big, internal reorganization that could try an enduser's patience for large n.
As another poster mentioned, you might consider a heap as well, but you're saying you need things always sorted, so probably an array, treap or red-black tree is what you need.
",0,9980892
9961925,"
The struct you have is fine, except that you may want to add an overload of operator< to do comparison. Here I'm doing the ""compare by name, then date"" comparison:
[Edit: What's required is called a ""strict weak ordering"". If you want to get into detail about what the means, and what alternatives are possible, Dave Abrahams wrote quite a detailed post on C++ Next about it.
In the case above, we start by comparing the name1 fields of the two. If a<b, then we immediately return true. Otherwise, we check for a>b, and if so we return false. At that point, we've eliminated a<b and a>b, so we've determined that a==b, in which case we test the dates -- if a<b, we return true. Otherwise, we return false -- either the dates are equal, or b>a, either of which means the test for a<b is false. If the sort needs to sort out (no pun intended) which of those is the case, it can call the function again with the arguments swapped. The names will still be equal, so it'll still come down to the dates -- if we get false, the dates are equal. If we get true on the swapped dates, then what started as the second date is actually greater. ]
The operator< you define in the structure defines the order that will be used by default. When/if you want you can specify another order for the sorting to use:
",6,9961890
9961910,"
That data structure right there should work just fine.  What you should do is override the less than operator, then you could just insert them all in a map and they would be sorted.  Here is more info on the comparison operators for a map
Update:  upon farther reflection, I would use a set, and not a map, because there is no need for a value.  But here is proof it still works
Proof this works:  
",0,9961890
9962786,"
Actually you can use function object to implement your sorting criteria
suppose that you would like to store the entries in the set
",0,9961890
9929391,"
std::map uses a balanced tree (like red-black tree) itself, so there is no point in re-implementing it.
A sorted std::vector with binary search has the same performance of a balanced binary tree. The difference is that placing a key in the middle of the vector is costly.
Since your keys have a very limited range, your best choice is similar to your first suggestion:
This way, a simple check of data[key] == NULL shows you whether data for this key exists or not. If it was me, I would even make it simpler:
",2,9929310
9929365,"
If the key is in the range [0, 0xFF), then you could use this:
Note that I used empty string to indicate that data doesn't exist.
",1,9929310
9930101,"
I didn't use it but take a look at Regionerate. It is a plugin for Visual Studio. I am sorry, I saw now that it is also only for C#. I thought that it worked with C++ too. Sorry.
",0,9929045
9929766,"
I have looked for a long time and talked to many co-workers and am now convinced we should not do it. Too many headaches and one of the developers said he didn't want that because of the way he writes his code. Thank the lord he said something!
If anyone else is looking to do this and trying to find a solution, I would just like to let you know that it is not worth the trouble. If you HAVE to do something like this in C++ then you have got to do it by hand. Pray that you don't have to.
",0,9929045
9930945,"
I realize you've concluded you don't want to do this, but just in case someone else does, you might be able to use Doxygen to do the ""heavy lifting"" and extract the functions from your source.
You can configure Doxygen to extract the code structure from undocumented source files.
You'd then have to extract starting line numbers of the functions from Doxygen's output, sort, and reassemble. It gets messy because you might need to introduce forward declarations.  
Thankfully you decided against doing it.
",0,9929045
9908224,"
Use the sort provided by the stl algorithms package, example:
",10,9908179
9908291,"
I would recommend you storing Customers in std::set.
You should create operator <
Now, after each insert, collection is already sorted by id.
And you can iterate over whole collection by:
This is fastest solution because you don't need to sort anything, and each insert takes O(log n) time.
",4,9908179
9908222,"
Using std::list.sort method should be the fastest way.
",0,9908179
9908404,"
Define operator< for your structure to provide an ordering relation between Customer instances:
Use this cheatsheet (in particular the flowchart at the bottom) to decide which container you should use in your particular program. If it’s std::set, your sorting is done whenever you insert a Customer into the set. If it’s std::list, call the sort() member function on the list:
If it’s std::vector or std::deque, use std::sort() from the <algorithm> header:
If you need to sort in multiple ways, define a sorting function for each ordering:
Then tell std::list::sort() or std::sort() to use that comparator:
",0,9908179
9866676,"
Your function cmpRow sorts the given arrays in ascending order based on the first two members (by first comparing the first members, and if they are the same then comparing the second members).  This works fine and produces the results you reported, which are correct according to that logic.  If this was not the expected result, what result did you expect?
",1,9866028
9866164,"
Change your code like this?
",-1,9866028
9862442,"
If the third argument to std::sort() is not provided, objects are sorted using operator< like:
So all you need to sort objects of type Foo is to have either:
or

That being said, if you have an array of pointers, then you will need to provide a custom predicate unless you want to sort objects by their memory address (I highly doubt this is what you want).  You can do something like:
And use it like:

Edit: the sample you posted will work fine and sort the data, but the vector does not act as a proxy for the data stored in the itemPtr array.  Read it again with my annotations:
If you want to sort the contents of [itemPtr,itemPtr+8) in-place, you can just do:

Edit: OK, following the code you posted, I would fix the readFile() method from its original definition to:
",4,9862410
9860778,"
The presence of the empty array at the end of the structure indicates this is C style code rather than C++ (it's a C Hack for flexible arrays). I'll continue with C style code as idiomatic C++ code would prefer use of standard containers for the child and data members.
Some notes and comments on the following code:

There were a number of issues with the pseudo-code in the linked paper to a point where it is better to ignore it and develop the code from scratch. The indentation levels are unclear where loops end, all the loop indexes are not correct, the check for finding an insertion point is incorrect, etc....
I didn't include any code for deleting the allocated memory so the code will leak as is. 
Zero-sized arrays may not be supported by all compilers (I believe it is a C99 feature). For example VS2010 gives me warning C4200 saying it will not generate the default copy/assignment methods.
I added the createNode() function which gives the answer to your original question of how to allocate a node at a given level.
A very basic test was added and appears to work but more thorough tests are needed before I would be comfortable with the code.
Besides the incorrect pseudo-code the paper has a number of other errors or at least questionable content. For example, concerning Figure 2 it says ""which clearly depicts that the slope of graph is  linear"" where as the graph is clearly not linear. Even if the author meant ""approaching linear"" it is at least stretching the truth. I would also be interested in the set of integers they used for testing which doesn't appear to be mentioned at all. I assumed they used a random set but I would like to see at least several sets of random numbers used as well as several predefined sets such as an already sorted or inversely sorted set.

.
",2,9859625
9847509,"
The data set is huge compared to cache, so it will be cache to memory limited.
Using indirection will make this worse because there is cache for the pointers, and memory is being accessed in a more random order, i.e. comparison isn't with neighbours. The program is working against any pre-fetch mechanisms in the CPU
Consider splitting the struct into two structs, in two arrays. 
As an experiment, compare pass 1, with a pass one, where the struct is only { float val; int idx; };
If it is cache and bandwidth bound, it should make a significant difference.
If cache locality is a key issue, it might be worth considering multi-way merges, or Shell sort; anything to improve locality.
Try sorting cache-size subsets of the records, then do multi-way merge sorts (might be worth looking at the processor cache manager spec to see if it is clear about the number of pre-fetch streams is tries to anticipate. Again, reducing the size of the data sets, by reducing the size of the structs streaming in from RAM may be q winner.
How is the idx field derived? It sounds like it is the original position in the array. Is it the index of the original record?
If that is the case, just allocate a second array, and copy the first into the second:
There is no second sort. If that is is the case, merge the allocation of the val2 value with this pass.
Edit
I was curious, about relative performance, so I wrote a program to compare the 'library' C sort functions, qsort, mergesort, heapsort, and also compare sorting to idx with copy to idx. It also re-sorts sorted values, to get some handle on that. This is quite interesting too. I did not implemenet and test Shell sort, which often beats qsort in practice.
The program uses command line parameters to choose which sort, and whether to sort by idx, or just copy. Code: http://pastebin.com/Ckc4ixNp
The jitter on run-time is quite clear. I should have used CPU clocks, done many runs, and presented better results, but that is an 'exercise for the reader'.
I ran this on an old-ish MacBook Pro 2.2GHz Intel Core 2 Duo.
Some of the timing is OS C specific.
Timing (reformatted slightly):
WARNING: Those are single runs. Many runs would be needed to get reasonable statistics.
The code at pastebin actually sorts the 'reduced size', 8-byte array. On the first pass, only val and idx are needed, and as the array gets copied when val2 is added, there is no need for val2 in the first array. This optimisation causes the sort functions to copy a smaller struct, and also fit more structs in the cache, which are good. I was disappointed that this gives a few % improvement on qsort. I interpret this as qsort quickly gets chunks being sorted to a size which fits in the cache. 
The same reduced-size strategy gives more than 25% improvement on heapsort.
Timing for 8 byte structs, without val2:
WARNING: Those are single runs. Many runs would be needed to get reasonable statistics.
",4,9846681
9846718,"
Generally speaking, C++'s std::sort located in algorithm will beat qsort, because it allows the compiler to optimize away the indirect call over the function pointer, and makes it easier for the compiler to perform inlining. However, this is only going to be a constant factor speedup; qsort already uses a very fast sorting algorithm.
Do note that if you decide to switch over to std::sort, that your comparison functor will have to change. std::sort accepts a simple less than comparison returning bool, while std::qsort accepts a functor returning -1, 0, or 1 depending on the input.
",14,9846681
9846846,"
When sorting by index, radix sort might be faster than quicksort. You probably want to do it in a base that is a power of 2 (so you can use bitwise operations instead of modulus).
",3,9846681
9847550,"
std::sort() should be more than 10% faster on this. However, you need two things:

Using a function pointer takes heroics from the compiler to detect that the function can be inlined. A function object with an inline function call operator is comparatively easy to inline.
In debug mode std::sort()'s core won't be optimized while qsort() is optimized a lot: try compiling in release mode.

",3,9846681
9846757,"
Right now you are sorting the array of structures, which means that every swap in the array is at least two assignments (copying of entire structures). You may try to sort an array of pointers to structures, that will save you a lot of copying (just copying pointers), but you would use more memory. Another advantage of sorting array of pointers is that you may have a few of them (each one sorted different way) - again more memory needed. Additional pointer indirection may be expensive though. You may also try to use both approaches proposed here by others together: std::qsort with array of pointers - and see if there is any speedup in your case.
",1,9846681
9846725,"
All the sorting algorithms are known and out there. They're easy to implement. Benchmark them.
Quick-Sort may not be the quickest in all cases, but it is pretty efficient on average. However 40 million records is a lot, sorting that in 3-4 seconds is not unheard of.
edit
I'll summarize my comments: It's been proven that under Turing (here, spelled right!!!) model, comparison sort algorithms are bounded by Ω(n log n). So complexity-wise there's not much place for improvement, but the devil is in the details. To discover the differences in performance of complexity-wise equivalent algorithms - you need to benchmark them and look at the results.
If, however, you have some additional knowledge about your data (for example - idx would be within a certain preset and relatively small range), you can use algorithms which are not comparison-sorts, and have a complexity improvement. You should still benchmark to make sure that the improvement is actually happening for your data, but for a large volume the difference between Ω(n log n) and Ω(n) will probably be noticeable. An example of such algorithms is bucket-sort.
For a more comprehensive list and complexity analysis - start here.
",1,9846681
9844617,"
Why do you think:
is the same as
?
Unless function is a class instance and sort returns an integral type, it's certain it won't work.
The statement:
dynamically allocates x objects of type Type. It's fairly obvious why x has to be of integral type.
EDIT: As per your comment:
The size to be allocated needs to be of integral type, but you return a float. But even then, it wouldn't make sense. You need to return the size of inputs.
",1,9844588
9844630,"
i'm gonna go out on a limb and say function.sort() returns void. meaning this line:
is the same as writing...
which doesn't make any sense. you probably want the length of whatever function.sort() is working on?
",-1,9844588
9835972,"
You're probably not going to find an asnwer in the Standard, since your ""duplicates"" sound like they're not transitive either. That's to say that a==b && b==c does not imply a==c.
For that reason alone, any algorithm has to compare all pairs, which gives you (N*N-1)/2 comparisons (assuming your equality is symmetric, i.e. a==b does imply b==a). 
",3,9832313
9833086,"
I doubt there is a 'standard algorithm' for achieving what you want, but if you define a distance metric describing the difference between two polygons, then you can select (any) one polygon (call it the base polygon) and sort all the others on the distance from that polygon.  Only polygons whose distance from the base are similar may be similar to each other.  
Now you only need to consider groups of polygons with similar distances, when deciding which to delete.  Without proving it - and I suspect the proof may be involved - I believe this is N log N.
",1,9832313
9841368,"
I actually saw this in the Java Code Style plugin the other day. It will alphabetize your properties and methods. I'd never use it, but i guess it's there for a reason. This would be the place to look if there is an equivalent for CDT:
http://help.eclipse.org/galileo/index.jsp?topic=/org.eclipse.cdt.doc.user/reference/cdt_u_c_code_style_pref.htm
",0,9823488
9825580,"
Can't do this in Eclipse. I am going to switch to Visual Studio as i see there are many plugins for this idea.
",0,9823488
9824299,"
Your vector does get sorted. The issue is that your vector is empty, and all you do is write and read outside of the vector.
The comment is quite ironic, because here is your error. vec.reserve(NP) does not change the size of the vector, it just does something to save work in the future. You need to replace reserve with resize, or even better just initialize it from the start:
On a side node, this:
is illegal, because you have non-const ints as template arguments. You need to replace int N with int const N (likewise for NP).
",4,9822707
9824615,"
I've put together a somewhat simplified version of your code, that at least works to generate and sort some objects. I've also (at least IMO) fixed a few places that your design struck me as somewhat problematic (though the result still falls well short of perfect, at least IMO).
de_target_param.h:
de_target_param_vector.h:
And, I've written a small main that creates, sorts, and prints, (in sorted order) some objects:
Based on how you designed your DETargetParam class, I think a bit of Googling for ""pseudo object oriented"" or something similar should turn up some useful, relevant reading. A great deal of your code seems (at least to me) to exemplify the genre.
",1,9822707
9798149,"
Its easier to change the greater() method into operator()().
",1,9798127
9797835,"
What tools are you using to compile the program? There are some flags which switch on checks for this sort of thing in e,.g. gcc (e.g. -fmudflap, I haven't used it, but it looks potehtially useful). 
If you can use a debugger (e.g. gdb) you should be able to add a 'data watch' for the variable n2, and the debugger will stop the program whenever it detects anything writing into n2. That should help you track down the bug. Or try valgrind.
A simple technique to temporarily stop this type of bug is to put some dummy variables around the one getting trashed, so:
Variables being trashed are usually caused by code writing beyond the bounds of arrays.
The culprit is likely R[5] because that is likely the closest. You can look in the dummies to see what is being written, and may be able to deduce from that what is happening.
ANother option is to make all arrays huge, while you track down the problem. Again set values beyond the correct bounds to a known value, and check those values that should be unchanged.
You could make a little macro to do those checks, and drop it in at any convenient place.
",1,9797029
10894962,"
I had used the similar Merge function earlier and it doesn't seem to work properly. Then I redesigned and now it works perfectly fine. Below is the redesigned function definition for merge function in C++.
I hope it helps.
",1,9797029
9797111,"
You only allocate L[5], but the n1 bound you're using is based on inputs q and p -- and the caller is allowed to call the function with values of q and p that allow writing outside the bounds of L[]. This can manifest itself as over-writing any other automatic variables, but because it is undefined behavior, just about anything could happen. (Including security vulnerabilities.)
I do not know what the best approach to fix this is -- I don't understand why you've got fixed-length buffers in Merge(), I haven't read closely enough to discover why -- but you should not access L[i] when i is greater than or equal to 5.
This entire conversation also holds for R[]. And, since *A is passed to Merge(), it'd make sense to ensure that your array accesses for it are also always in bound. (I haven't spotted them going out of bounds, but since this code needs re-working anyway, I'm not sure it's worth my looking for them carefully.)
",0,9797029
11939332,"
It seems like your using some sort of selection sort, which is known to be slow. IRL applications usually use quicksort or merge-sort (not so much the latter).
I suggest you do the same (assuming this is for educational purposes).
Otherwise, use std::sort defined in <algorithm>.
Also, note that your code is not standard:
VLA's are not supported in C++. You're better of using a std::vector instead. If you use C++, don't write C code.
",6,11939315
11939365,"
Your algorithm is selection sort, an O(n^2) algorithm: if the input size grows linearly in n, then the running time is proportional to a quadratic function of n. The minumum time complexity for comparison based sorts on arbitrary input (i.e. without prior knowledge about the input) is O(n log n). The STL function std::sort provides this guarantee.
For small inputs, selection sort (or insertion sort) can sometimes be fast enough. You can also code this as a few-liner in C++11 (it uses a lambda-expression)
From this code, it is also obivous how selection sort works: repeatedly find the minimum element in the remaining part of the array, and swap it into place. It should be equivalent to your own code, but I hope you agree it is much easier to understand (once you get to know the STL, that is).
",3,11939315
11939366,"
You are using Selection sort to sort your array. The running time of this algorithm id O(n^2). You can use Merge sort or Heap Sort to sort which has running time of O(nlog(n)).
You can also use Intro Sort which uses a very neat trick to push QuickSort's worst case down to O(n log n) while maintaining the other good performance characteristics
Check out the wiki page on sorting algorithms for more details.
",0,11939315
11907141,"
You never reset the value of temp in the loop. After the first pass it is equal to the largest element in the array; on every subsequent pass it's still the largest so it doesn't change.
",2,11907062
11887744,"
",11,11887668
11887916,"
If you don't need the lower half sorted, use std::nth_element.  If you need the lower half sorted and the vector contains fewer than 100,000 elements, use std::partial_sort, if your vector is larger then use std::nth_element to partition the vector into lower half and upper half, then use std::qsort on the lower half.  I've confirmed this on an Intel Xeon X5570 @ 2.93GHz running CentOS with g++ 4.4.3 and give timings at the end of this answer.  Scott Meyers and others have found it astonishing that std::nth_element followed by std::qsort can be that much faster than std::partial_sort for large vectors:
http://www.velocityreviews.com/forums/t745258-nth_element-sort-versus-partial_sort.html
If you just want the lowest half of the values and don't need those to be sorted then std::nth_element is fastest (complexity is linear).
http://www.cplusplus.com/reference/algorithm/nth_element/
On an Intel Xeon X5570 @ 2.93GHz running CentOS and using g++ 4.4.3 I measure the following times.  It is clear from the data that std::nth_element is linear and faster than std::partial_sort for all sizes, and 94 times faster when N is 1 billion elements.
",4,11887668
11887997,"
I'm pretty sure you can do a partial quicksort, stop the algorithm after it has sorted at least half your array. See here for a visual representation.
In the worst case, the entire array will be sorted, and the best case half will be sorted.
",0,11887668
11888010,"
I don't think there could be any algorithm with less than O(log N) time complexity for this problem. But in average cases, this could be enhanced.
You can fine tune the quick sort algorithm for this particular use case as below.
You may already know, quick sort comprises of an internal algorithm called partition, which partitions the array into two which has a pivot element in the middle such that values on the left are less than the pivot and values on the right are greater the the pivot.
So, your problem reduces to a problem of partition an array so that you have equal number of elements on either side of the pivot.
The following algorithm should work, which splits the array into two, so that lower half of the array has element less than median and the upper has element greater than the median.
Invoke this function as
After the execution of the function, all the elements to the left of (len(arr) / 2) should be less than it and those on the right should be greater than it.
You should easily get the algorithm for partition.
",0,11887668
11890508,"
You could sort everything with radix sort, it might be faster than quicksort. I'm not sure if it's faster than partial sort. It is useful if you need to sort a limited range of numbers (32bits representation for example)
Here is an implementation I made some time ago
edit: seems that this implementation of radix sort is even faster
",0,11887668
11818784,"
You could just use std::sort on, for example, a vector of std::tuple - the default comparison is lexicographic, so first column counts most.
",7,11818757
11818797,"
Assuming you are sorting a std::vector<std::vector<int>>
C++11:  
Assuming you want lexical order:  
",5,11818757
11809171,"
By its definition std::set is a sorted container. Its part of the standard. Having it sorted helps maintain that its a set rather than just an arbitrary collection.
Source: http://www.sgi.com/tech/stl/set.html
",20,11809163
11812871,"
Actualy std::set and std::map are not really sorted. Both of these containers are implemented as a red-black trees. So when you iterate such kind of containers, iterator walks through the tree in such way that it looks like that container is sorted. At first it visits the most left node then the parent of the most left one and so on...
",12,11809163
11809217,"
Yes, std::set stores its elements in such a way that iterating over the elements will be done in sorted order (and the call to std::adjacent_find is to show that std::set stores unique items as well).
Live Example
",6,11809163
41424708,"
C++11 N3337 standard draft 
23.2.4 ""Associative containers"":

1 Associative containers provide fast retrieval of data based on keys. The library provides four basic kinds of
  associative containers: set, multiset, map and multimap.

and:

10 The fundamental property of iterators of associative containers is that they iterate through the containers
  in the non-descending order of keys where non-descending is defined by the comparison that was used to
  construct them.

so yes, order is guaranteed, which as https://stackoverflow.com/a/11812871/895245 mentioned basically requires a balanced search tree implementation.
Also contrast with C++11 unordered_set, which may provide better performance since it has less restrictions: Why on earth would anyone use set instead of unordered_set? e.g. using a hash set.
",2,11809163
13384803,"
You cannot do it. TIBDataSet is a representation of the underlying database. Basically it fetches the records in the order defined in the SQL.
The easiest way is to use TDBClientDataset but it is not included in Starter version of c++ Builder. You can explore other ways, for example pre-loading all records in a std::list and then use the order function to order the records. Finally you can show them using a simple TGrid o TStringGrid.
In any case, I recommend to upgrade C++Builder since TClientDataSet is one of the main pieces in most of data projects, specially when you need to create medium-large projects.
Mixing database specific components like TIBDataSet  with the user interface penalizes the scalability and maintenance of the project.
",0,11804731
11756193,"
C++ is case-sensitive: shellSort vs ShellSort. You've declared and called one function, but implemented a completely unrelated function!
The reason this is a linker error rather than a compiler error, is that the forward declaration tells the compiler ""there's going to be a definition of this function shellSort somewhere"", but doesn't specify where. Since it's not in this .cpp file, the compiler takes your word for it that it must be in a different .cpp file that will be linked together with this .cpp file later. When you get to the linking stage, there's still no function shellSort.
",5,11755984
11665984,"
",4,11665914
11666010,"
C++11.
http://liveworkspace.org/code/5f14daa5c183f1ef4e349ea26854f1b0
",4,11665914
11690061,"
Change
into
should work.
",0,11665009
11641788,"
Without the presence of NaNs, infinities are fine with the regular operator <:

+∞ < +∞ is false: < is irreflexive;
if +∞ < x is true then x < +∞ is false for non-infinity values: < is antisymmetric;
if +∞ < x is true and x < y is true, then +∞ < y is true: < is transitive;
if +∞ is incomparable (not less, not greater) with x, and x is incomparable with y, then +∞ is incomparable with y: < displays transivity of equivalence.

(similar properties are valid for -∞)
Given those properties operator< on floats without NaNs is a strict weak ordering, and thus suitable for standard library style ordering operations.
However, with NaNs, the antisymmetry property is broken: NaN < 1 is false, and 1 < NaN is false too. You can solve this by ordering all NaNs either before or after all non-NaNs, in a manner similar to your proposed strategy:
(isnan can be found on the C++11 standard library, or implemented quite easily as return x != x;)
With this, we get NaN < 1 as true, and 1 < NaN as false, while the other properties still hold.
",10,11641605
11641731,"
If you use this:
Then the infinites are considered of the same order, since none comes before another one...
",0,11641605
11614948,"
The Standard C++ Library uses iterators in standard algorithms, such as sort(). This allows the algorithm implementation to ignore the exact details of the underlying container. Also, this approach doesn't allow for indexing with operator[]().
With that in mind, I have two suggestions for you to consider:
1) Revise your specialized sort to use iterators, rather than operator[]() to access elements in the container. If it is possible to maintain your desired O(n) speed, then this is probably the most desirable method for flexibility.
2) Implement your sort with the container class templatized. Something like
should do the trick.
",2,11614758
11620942,"
The wonderful thing about templates is that they're not fully compiled until the template type is filled in, so the compiler can apply optimizations based on the final code. A T* pointer fulfills all the required properties of a random access iterator and can be easily used in any template code that requires them.
",0,11614758
11610093,"
You can use std::sort with a suitable comparison function:
",3,11610027
11610088,"
Use the sort algorithms with a user-defined sorting criterion, e.g.
",1,11610027
11598951,"
Try an STL std::priority_queue? The output is guaranteed to be sorted, and if you polarize the inputs to be 2-D objects (that contain a row number for example) you're queue will build literally perfectly. At that point simply slurp the number off the queue in batches of 'n' where 'n' is your row size and each one will be sorted correctly. You will need a element type that encodes both the value AND the row in your priority queue, and sorts biased to the row # first, then then value. Your example uses long int as the data type for your values. Assuming your rows are no larger than the size of a system unsigned int:
Note: this takes advantage of the priority queue's default comparison operator invoking std::less<>, which simply compares the items using the item-defined operator <(). Once you have this simply push your matrix into the queue, incrementing the row index as you switch to the next row.
MyQueue mq;
Popping the queue when finished will result in the following sequence:
99
100
100
101
Which I hope is what you want. Finally, please forgive the syntax errors and/or missing junk, as I just blasted this on the fly and have no compiler to check it against. Gotta love web cafes.
",1,11598601
11586599,"
Consider what happens in your code when there are several nodes with the pivot weight - for simplicity, consider the weights [1, 9, 5, 2, 7, 5, 6, 8, 3, 7] and perchance the pivot index is 5, so 
we have p = 5
l = 0 and r = 9
1 < 5, then increment l, l = 1, v[1] = 9 > 5.
7 > 5, decrement r, r = 8, v[8] = 3 < 5. Swap v[1] and v[8], giving [1, 3, 5, 2, 7, 5, 6, 8, 9, 7].
Next round, l = 1 < 8 = r. v[1] = 3 < 5, l becomes 2, v[2] = 5 isn't smaller than 5, end of loop. Now the second inner loop is entered, v[8] = 9 > 5, v[7] = 8 > 5, v[6] = 6 > 5; v[5] = 5 isn't larger than 5, swap v[2] and v[5], giving [1, 3, 5, 2, 7, 5, 6, 8, 9, 7].
Next round, l = 2 < 5 = r, v[2] = 5 isn't smaller than 5, v[5] = 5 isn't larger than 5, swap v[2] and v[5]. Oops, we're stuck.
The usual way to prevent this is to swap the pivot out of the way and have one of the two conditions a weak inequality, also one must check the condition l < r also in the inner loops, or in the case all entries are equal one would run off the end of the array/vector. Then after partitioning, one swaps the pivot into the right place.
The following code uses the standard way (untested, typos possible):
",1,11585365
11586507,"
You have a problem with b,l use and stop condition .
b is an index from where to start patition, e is an index where to stop .
So when you call a function for the first time for e you have to refer last index and not size .
Also you are missing stop condition in huff_sort_partition - in order not to run forever you should check if b and e indices are ok relatively to each 0ther.
please try the fixed version of your code below  
",1,11585365
11570278,"
You are doing it wrong. You cannot change the value of temp variable returned by a function. 
But you can make it work this way.. 
though this is not good practise. Instead just use the setter you have.. 
",1,11570193
11570245,"
The statement
will never work, you are trying to assign something to the return value of a function. I don't know how you defined Node, but you probably meant something like
i.e., assign something to a member of Node.
",0,11570193
11570895,"
change 
to
",0,11570193
11566955,"
Since there are only 31 different object variations (1 to 32 bytes), you could easily create an object type for each and select a call to std::sort based on a switch statement. Each call will get inlined and highly optimized.
Some object sizes might require a custom iterator, as the compiler will insist on padding native objects to align to address boundaries. Pointers can be used as iterators in the other cases since a pointer has all the properties of an iterator.
",1,11562124
11565137,"
The most practical solution is to use the C style qsort that you mentioned.
(Or, you can call qsort_r if you prefer.) Since STL sort inlines the comparision calls, you may not get the fastest possible sorting. If all your system does is sorting, it may be worth it to add the code to get custom iterators to work. But, if most of the time your system is doing something other than sorting, the extra gain you get may just be noise to your overall system.
",2,11562124
11562876,"
I'd agree with std::sort using a custom iterator, reference and value type; it's best to use the standard machinery where possible.
You worry about memory allocations, but modern memory allocators are very efficient at handing out small chunks of memory, particularly when being repeatedly reused.  You could also consider using your own (stateful) allocator, handing out length s chunks from a small pool.
",1,11562124
11562455,"
If you can overlay an object onto your buffer, then you can use std::sort, as long as your overlay type is copyable.  (In this example, 4 64bit integers).  With 4GB of data, you're going to need a lot of memory though.
As discussed in the comments, you can have a selection of possible sizes based on some number of fixed size templates.  You would have to have pick from these types at runtime (using a switch statement, for example).  Here's an example of the template type with various sizes and example of sorting the 64bit size.
Here's a simple example:
",1,11562124
11565341,"
Given the enormous size (4GB), I would seriously consider dynamic code generation. Compile a custom sort into a shared library, and dynamically load it. The only non-inlined call should be the call into the library.
With precompiled headers, the compilation times may actually be not that bad. The whole <algorithm> header doesn't change, nor does your wrapper logic. You just need to recompile a single predicate each time. And since it's a single function you get, linking is trivial.
",1,11562124
11563847,"
To skip the #define
",0,11562124
11534921,"
This code is broken:
If nCount is modified during all those assignments, nonsense will result. It should be
",3,11534862
11536423,"
You can use the Stream Compaction functions in the Thrust library.
For example,
EDIT: Relevant Thrust documentation link
If you are unfamiliar with Thrust, here's a quick overview. It's basically a lot of STL style containers and algorithms, plus some Boost-style bells and whistles. The really cool thing is that if you write your algorithm with Thrust instead of cranking out custom kernels, you can actually run the exact same algorithm on either the CPU or GPU. So the implementation sketch I have here would run on the CPU since the memory is allocated in main RAM. But if instead of using a regular array for the data, you use thrust::device_vector (a lot like std::vector), then Thrust would copy your data to the GPU, and the same thrust::remove_if() call paired with the same functor would produce the same result. I hope this gives you a taste for Thrust, and I encourage you to find more on their quick start guide.
",3,11534862
11548773,"
As suggested by SchighSchagh, thrust would be one way to go. ArrayFire provides a more mathematical representation of what is going on.
",1,11534862
11528364,"
Mostly reposting from comment.
Change your implementation to:
",1,11528170
11501154,"
This is just a matrix transpose operation. And there is even a problem and solution for in-place matrix transposition on Wikipedia.
No extra space is impossible, since you need to at least go through the array. O(1) additional memory is possible, with heavy penalty on the time complexity.
The solution is built on follow-the-cycle algorithm in the Wikipedia page: for each cell, we will find the cell with the smallest index in the cycle. If the cell with the smallest index is greater than or equal (>=) to the index of the current cell, we will perform chain swapping. Otherwise, we ignore the cell, since it has been swapped correctly. The (loosely analyzed) upper bound on time complexity can go as high as O((MN)2) (we go through M * N cells, and the cycle can only be as long as the total number of cells).
",8,11500993
11501885,"
Impossibility
It is impossible to implement this algorithm without extra use of memory and an arbitrary length because you need a an iterator to traverse the list and that takes up space.
Finding the right indices to swap
For fixed lengths of the array and fixed n you can use a matrix transpose algorithm.
and in order to swap the elements y
The algorithm you are looking for is a matrix transpose algorithm.
so you have to swap every element exactly once iterating through it.
http://en.wikipedia.org/wiki/Transpose
basically you have to swap the m -th element in the n - th component with the n - th element in the m -th component. This can be done by a double loop.
Note: For fixed m and n this loop can be completely unrolled and therefore m, i, j can be replaced by a constant. 
Swaping without Memory consumption
In order to swap every element without using extra space you can use the XOR swap algorithm as pointed out in the comments:
",4,11500993
11501389,"
The simplest way to swap two numbers (a and b) without using a temporary variable is like this:
If you write that in a function, then you're part of the way there. How you keep track of which variable to swap within the arrays without using a temporary variable eludes me right now.
Bear in mind voters: he doesn't actually need to sort the array, just swap the right values.
Edit: this will work with large values in Java (and in C/C++ unless you turn on some very aggressive compiler optimisations - the behaviour is undefined but defaults to sane). The values will just wrap around.
Second edit - some (rather untested) code to flip the array around, with I think 4 integers over the memory limit. It's while technically massively unthreadsafe, but it would be parallelisable just because you only access each array location once at most:
Apologies if this misunderstands the question; I read it carefully and couldn't work out what was needed other than this.
",1,11500993
11501144,"
Take a look at Quicksort algorithm
For more information about available algorithms, go to Sorting algorithm page.
",-1,11500993
11490815,"
this isn't the most easiest task. Here are two links:
http://en.wikipedia.org/wiki/N-puzzle#Solvability
http://cseweb.ucsd.edu/~ccalabro/essays/15_puzzle.pdf
",4,11490742
11492242,"
It is better to use some AI algorithm like A* with the Manhattan distance heuristic.
For A* algorithm read here
For the Manhattan distance heuristic read here
",0,11490742
11487357,"
In order to sort a container of Rooms, you will need to call std::sort on it. It has an overload that takes a comparator, i.e. a function object determining which Room is ""less"". If you want to sort first by floors and then by room numbers, you have to write an appropriate function object (or simply function).
",3,11487310
11487363,"
Well, what must be defined is simply the less than operator.
Basically if Room1.floor < Room2.floor then Room1 must come first than Room2. If Room1.floor==Room2.floor and Room1.number < Room2.number, Room1 still need come before Room2. Otherwise Room2 has to come first.
Code:
Edit:
This code is compatible with C++11. To compile it you should use 
-std=c++0x flag (on g++ 4.5 and 4.6), or -std=c++11 if using g++ 4.7
",3,11487310
11487358,"
Every sorting algorithm must eventually compare two items to determine which should come first. At this point you should compare both values as one set.
Let's think about what should happen:

If the floor number is bigger, it is bigger.
If the floor number is smaller, it is smaller.
If the floor number is the same, compare the room number to decide.

",0,11487310
11449984,"
A straightforward solution could be:
However, this solution has quite a high cost, O(N^2 log N). Depending on the size of the vectors this might be a problem or not.
Another approach would be to use an intermediate vector as an indirection:
This solution has O(N^2) cost, at the expense of some overhead every time you access v2.
Finally, you could try to come up with a custom sort solution. Still, I believe it is not possible to solve this problem with a smaller cost than O(N^2).
",0,11445829
11380115,"
Your comparator is wrong:
std::sort is not like qsort in the comparator. You just have to return the same as the less than operator. For example
",1,11380080
11368797,"
Maybe map/multimap<std::time_t/dt::ptime, std::string/fs::path>?
",2,11368735
11368839,"
You could use Boost.Filesystem to iterate over the directory, and call last_write_time() on each file. 
Then store the file name in an std::multimap using the result of the last_write_time call as the key. That way the sorting is done automatically upon insertion into the container.
",2,11368735
11368820,"
I know that within Qt's framework there is a QFileInfo class that will provide that info. http://doc.qt.nokia.com/4.7-snapshot/qfileinfo.html
I'm not as familiar with boost, but I think this should work similarly: http://www.boost.org/doc/libs/1_32_0/libs/filesystem/doc/operations.htm#last_write_time
",0,11368735
11369174,"
I don't mean to start up the great C++ system() fight, but you mentioned ""ls -lhctr"" returns your answer almost immediately, so why not use the system() function?  Try:
system(""ls -lhctr > out.txt"");
And then use the fstream header to getline() that data?
Using system(), of course, guarantees that this solution won't be portable to other OSes, but you may not care about doing that anyway.
",0,11368735
11341531,"
You can use std::sort on vectorAll with the Compare function designed to take into account the contents of vectorSpecial:
",2,11341498
11342144,"
For your First Step, you can use C++11 lambda's to great effect (special.size() = K, and all.size() = N)
Explanation: first, for every point in special, compute the distance between the beginning of all and the location of the special element in all, and store that result into the indices vector. Second, sort all elements of special by comparing for every pair of element the corresponding elements in the indices vector.
For your Second Step, you only have to change the way you compute indices
Explanation: the only change compared to your First Step is that for every element in special you find the element in all that is closest to it, which you do by computing the minimum Euclidean distance as you suggested in your question.
UPDATE: You could make a space/time tradeoff by first storing the index of every element of all into a std::unordered_map hash table, and then doing the comparison between elements of special based on lookup into that hash table. This reduces the time complexity of the first step to O(N) (assuming K < N), but adds O(N) of storage for the hash table.
",0,11341498
11317711,"
You can use an adaptation of the streaming median algorithm to track the k smallest terms of a set of terms. You can use std::priority_queue for your min and max heaps.
The algorithm would work like this:

The max heap is used to hold the k smallest terms
The min heap is used to hold all the other terms
For every term to be tracked, decide which heap it should be added to, and add it there


If the size of the max heap is smaller than k add it there, else
if the term is smaller than the top of the max heap, add it there, else
add the term to the min heap

If the top of the max heap has more than k terms, pop off the top term, and push it into the min heap

If you need your terms sorted, you can pop them off the max heap in descending order, placing them in a array in reverse order, leaving you with a sorted array. If you passed in the container to the max heap's constructor, you can copy the container, and sort it.
The std::priority_queue is a max heap by default. To make it a min heap, you modify some of the template parameters.
",1,11317099
11311021,"
Timsort is designed specifically for that case.

Timsort is a hybrid sorting algorithm, derived from merge sort and
  insertion sort, designed to perform well on many kinds of real-world
  data. It was invented by Tim Peters in 2002 for use in the Python
  programming language. The algorithm finds subsets of the data that are
  already ordered, and uses the subsets to sort the data more
  efficiently.

Another alternative is Smoothsort, also designed to take advantage of partially sorted data.

It is a variation of heapsort developed by Edsger Dijkstra in 1981.
  Like heapsort, smoothsort's upper bound is O(n log n). The
  advantage of smoothsort is that it comes closer to O(n) time if the
  input is already sorted to some degree, whereas heapsort averages
  O(n log n) regardless of the initial sorted state.

",7,11310991
11312506,"
std::sort in general.
Although the exact implementation details are a quality of implementation, a good implementation of std::sort should take advantage of the partially sorted nature of the data. libc++ does, for example.
Note that if you know where are the sorted pieces, you can use std::inplace_merge. For example, supposing that v is a vector with [1, 7) being sorted and [7, 10) being sorted too, then you can use std::inplace_merge(v.begin() + 1, v.begin() + 7, v.begin() + 10) however this is more error-prone.
As for the order of the result: if < does not suit you, feel free to provide your own comparison function.
",0,11310991
11315426,"
If you're sorting inside a loop, consider a treap or red-black tree instead.  Treaps are fast on average (but with a largish standard deviation), red-black trees give low variability in operation times (not as good on average operation time, but low operation time standard deviation).  IOW, for batch applications use a treap, for interactive applications you Might want a red-black tree so your user doesn't have to wait a long time once in a while.
If you're not sorting in a loop, then Timsort.
",0,11310991
11302629,"
The second overload in the reference you linked to takes a Comparer – pass in an instance of std::greater<T>.
",7,11302608
11302631,"
According to your link: http://en.cppreference.com/w/cpp/algorithm/partial_sort,
another definition of partial_sort allows you to include a comparator.
Just include a comparator with the order of the elements reversed.
",1,11302608
11302655,"
You just have to use the second form of the function and pass the correct comparator. Eg. std::greater might be a good tip.
",0,11302608
11254327,"
Instead of using a, b ...f, I'd use a std::vector of CUser (BTW, I don't like CUser as a class name):
If this is the only order you care about with respect to users, I'd define the ordering as part of the CUser class:
Then when you need the users sorted into the correct order, you can do:
You will, however, probably need to add an ID number (or something like that) to the CUser class to keep track of which user is which, regardless of the order in which they happen to be arranged at the moment.
Edit:
To just get the values of ints in a...j into nHold in ascending order, you probably want to just insert them in their existing order, then sort:
",2,11254262
11254300,"
First brilliant idea: avoid using raw C-style arrays, they do little error checking for you...cannot be dynamically resized...and don't really help you that much in terms of performance even when you get them right.
(std::vector is good, std::array if you feel that you must).
Second brilliant idea: employ already-written sorting algorithms, such as std::sort.
",2,11254262
11234290,"
The argument to that constructor is the number of elements you need, not the number of bytes those elements take. This will create sizeof(int)*N elements, where N is the number you need. After sorting the first (sizeof(int)-1)*N will be 0.
The file has .txt extension, but you are reading it as if it was binary. If the file is a binary dump, then this read is... well... a code smell but not completely wrong. If the file is text then this is completely wrong.
You can read a text file that contains only space separated integers using the copy algorithm and a istream_iterator:
",12,11234252
11234299,"
The error's in this line:
The argument should be the number of elements, not the number of bytes, so take out the *sizeof(int) from the end. As it is, your vector has 4 times as many elements as you want. The ones you haven't read into are all zero, so when you call sort, they go to the front of the vector, and then you only print out the zero ones, not the ones with real data.
",3,11234252
11217636,"
Possibly among other things, you aren't actually looking at the contents of the vector when you move your indices to find a swap.  This section:
should be changed to this:
As one of the commenters mentioned, the bigger lesson is to learn to use a good debugger to step through your code.
Similarly, you should be selecting pivot as an array value.  E.g. pivot = numbers[start]
",2,11217572
11217599,"
This line looks out of place:
You're picking for your pivot the middle element of the numbers vector regardless of the start and end positions.
",3,11217572
11167045,"
Don't use getReal2D. It's quite slow. 
Convert image to cv::Mat or Mat. Use its data pointer to get the pixel values. Mat.data() will give you pointer to the original matrix. Use that. 
And as far as sorting is concerned, I would advise you to first make an array of all the pixels, then sort it using Merge sort (time complexity O(n log n))
Using this you can access pixel values from the main matrix.
Warning: This is not how you compare it. I'm suggesting that by using something like this, you can access pixel values.
Mat.data() gives you pointer to the original matrix. This matrix is a 1 D matrix with all the given pixel values.
Image => (x,y,z),(x1,y1,z1), etc..
Mat(original matrix) => x,y,z,x1,y1,z1,...
If you still have some doubts regarding how to extract data from Mat, visit this link OpenCV get pixel channel value from Mat image
and here's a link regarding Merge Sort http://www.cplusplus.happycodings.com/Algorithms/code17.html 
",1,11166760
11167617,"
There are few problems in your code:

As Froyo already said you use cvGetReal2D which is actually not very fast. You have to convert your cvMat to cv::Mat. To do this there's cv::Mat constructor:



And after this use direct pixels acces as mentioned in this SO question. 

Another problem is that you use push_back which actually also not very fast. You know the size of array, so why don't you allocate needed memory at the beginning? Like this:

vector<int> vect_sortPixel(mat.cols*mat.rows);
And than just use vect_sortPixel[i] to get needed pixel.

Why do you call sort in the loop? You have to call it after loop, when array is already created! Default STL's sort should work fast:


Complexity
Approximately N*logN comparisons on average (where N is
  last-first). In the worst case, up to N^2, depending on specific
  sorting algorithm used by library implementation.

",1,11166760
11085373,"
If you have small vectors you can write something that does the trick, but if the vectors are not sorted there's no way to avoid the n*n comparisons. Imagine you have 1,000,000 elements in both vectors, that's 1,000,000,000,000 comparison operations.
If you just need the equal/not equal you can copy both, sort the copies, compare them and destroy the copies...
",2,11085282
11085511,"
You could take copies. Either in the obvious way copying as vectors and then sorting, or if the vectors are likely to contain a lot of dupes:
It might be faster to use unordered_set instead, and also less memory since you only need a ""copy"" of one of the collections. You'd have to write a hash function, though, which might not be easy depending what your predicate does. You'd also have to write the intersection code, but that's simple.
Other potential options: sort v1 immediately after it is finished being populated; have X use a set instead of a vector; supply the criteria as a set instead of a vector. Whether they're applicable or not depends whether X and/or the caller can see pred. And as above, if you can write a hasher then you can replace set with unordered_set.
",1,11085282
11076073,"
You are trying to access an element out of proper range.
temp2 has range [0...maxInt-1] but the following code uses temp2[maxInt] which is out of range.
You'll have to fix temp2 to have maxInt+1 elements or i < maxInt to not to see the error.
",2,11076015
11076103,"
Isn't the whole point of you doing this:
To get the max element?   
I'd change your code to the following.  
",1,11076015
11076337,"
Shouldn't temp1 be dimensioned numbers.size()+1?
",0,11076015
11071472,"
I am not sure about the problems, because you were not precise enough about what exactly ""does not work"" means in your case (does not compile, does compile but does not sort etc). In case it does not compile (most likely guess) you did not post the error messages, which also makes finding and explaining the problem very hard.
Here are some guesses based on the code you posted:
Both static function as well as the functor use the member d to decide which column to sort on. However d is an instance variable, so it is not available for anything which is static. Neither the functor nor the static member function would know which of the possible ds to use, as there is one d per instance.
The best way to do this without resorting to C++11 features (lamdas) is to provide a constructor to the functor which takes the d you are planning to use. Something like this:
This should do the trick.
There are some more things wrong with the code you posted though:

Arrays should be indexed using type size_t not a unsigned int. Same goes for std::vectors
The types in the std::binary_function instantiation do not match the actual types in the method (may be a problem of reducing the code).
Do not use using namespace std (I assume you do from the declarations in your code).
Functors such as these should take parameters as const-reference, not by value.

That's all I can think of. Next time try to present short, self contained, complete examples, then people will not have to resort to guessing.
",0,11071247
11071477,"
The error is because you are accessing a non-static member d from a static context of the comparator function. Use the second approach, in the following way:

Provide a constructor to that struct, which takes a parameter unsigned int and sets a member to that value.
Create an object of type compareMyDataFunctor, and pass in the value of d to the constructor.
Use this object for sorting (3rd argument to std::sort)

",1,11071247
11054767,"
This snippet does what you want, by combining an std::set, a lambda and std::multiset::count:
You might want to reverse the vector. This outputs:
Edit: Taking into account you also need the item count, this will do it:
Which outputs:
",6,11054558
11016938,"
This means your code has an error.  C and C++ let things compile and run that actually have errors in them.  Like this:
Will do different things on different machines.  I would call it an error.  The compiler won't.
Now as for where your error is, here is my ""use a debugger"" speech.  Use a debugger.  It will take you less time to use a debugger and have a decent chance of finding the error than it did for me to read your code to see if anything jumped out.  Compile with -g.  Google ""gdb cheat sheet.""  Run with gdb.  Follow the cheat sheet.  See where your code does something unexpected.
Seems smart to do this on the machine that is giving the wrong output.  And see where it's doing something wrong.
",1,11016823
11017485,"
To expand on what @djechlin said, what you most likely have is ""undefined behavior"".
Most programming languages strictly define what can and can't be done, and compiler writers use that to generate compiler errors. Undefined behavior, on the other hand, means that it is up to the compiler writer and system; anything can happen - it can work correctly, it can erase your boot sector, zombie Alan Turing rise and feast on your brains, etc.
For example, using an uninitialized variable like so:
on some compilers will give you a pattern like 0xCECECECE in debug builds to help find uninitialized variables. In release builds it might be set to 0 by the compiler, or it might be garbage data.
",0,11016823
11016844,"
You could adopt option (2) you suggested - sort the data while you insert elements.
Use a skip list, sorted according to time, ascending to maintain your data.

Once a new entree arrives - check if it is larger then the last
element (easy and quick) if it is - simply append it (easy to do in a skip list). The
skip list will need to add 2 nodes on average for these cases, and will be O(1) on
average for these cases.
If the element is not larger then the last element - add it to the
skip list as a standard insert op, which will be O(logn).

This approach will yield you O(n+klogn) algorithm, where k is the number of elements inserted out of order.
",3,11016630
11016747,"
I would throw in merge sort if you implement the natural version you get a best case of O(N) with a typical and worst case of O(N log N) if you have any problems.  Insertion you get a worst case of O(N^2) and a best case of O(N).
",2,11016630
26665692,"
You can sort a list of size n with k elements out of place in O(n + k lg k) time. 
See: http://www.quora.com/How-can-I-quickly-sort-an-array-of-elements-that-is-already-sorted-except-for-a-small-number-of-elements-say-up-to-1-4-of-the-total-whose-positions-are-known/answer/Mark-Gordon-6?share=1
The basic idea is this:

Iterate over the elements of the array, building an increasing subsequence (if the current element is greater than or equal to the last element of the subsequence, append it to the end of the subsequence. Otherwise, discard both the current element and the last element of the subsequence).  This takes O(n) time.
You will have discarded no more than 2k elements since k elements are out of place.
Sort the 2k elements that were discarded using an O(k lg k) sorting algorithm like merge sort or heapsort.
You now have two sorted lists.  Merge the lists in O(n) time like you would in the merge step of merge sort.

Overall time complexity = O(n + k lg k)
Overall space complexity = O(n)
(this can be modified to run in O(1) space if you can merge in O(1) space, but it's by no means trivial)
",2,11016630
11023971,"
Without fully understanding the problem, Timsort may fit the bill as you're alleging that your data is mostly sorted already.
",1,11016630
11019510,"
There are many adaptive sorting algorithms out there that are specifically designed to sort mostly-sorted data.  Ignoring the fact that you're storing dates, you might want to look at smoothsort or Cartesian tree sort as algorithms that can sort data that is reasonable sorted in worst-case O(n log n) time and best-case O(n) time.  Smoothsort also has the advantage of requiring only O(1) space, like insertion sort.
Using the fact that everything is a date and therefore can be converted into an integer, you might want to look at binary quicksort (MSD radix sort) using a median-of-three pivot selection.  This algorithm has best-case O(n log n) performance, but has a very low constant factor that makes it pretty competitive.  Its worst case is O(n log U), where U is the number of bits in each date (probably 64), which isn't too bad.
Hope this helps!
",0,11016630
11019597,"
If your OS or C library provides a mergesort function, it is very likely that it already handles the case where the data given is partially ordered (in any direction) running in O(N) time.
Otherwise, you can just copy the mergesort available from your favorite BSD operating system.
",0,11016630
11006819,"
I haven't looked for algorithmic errors, but the temp vectors should be sized up, and initialized to 0 (this is just for paranoia, the default initializer for int should be 0).
After fixing that, the program seems to run on my system, correctly sorting a reverse sorted array. But, you should test with a more complete set of test cases.
Because of the way counting sort works, the maxInt parameter needs to be a value at least one larger than the largest value held by the input array.
You could modify the function to make a pass over the vector to locate the largest.
Then, you wouldn't have to pass it in.
You might want to add some code to print out what you read in for your input, so that you are sure it is what you think it ought to be.
",4,11006791
11006760,"
Using std::array, std::string, and std::sort...
This can also be trivially adapted to use C arrays or std::vectors if you don't have access to std::array.
",2,11006627
11006681,"

I wish to know if there is a function to sort easy way?


Try to use C++ constructs such as string, vector and sort. Your job becomes much easier then. 
However, if you want to use C, you can look up qsort. You will need to provide a custom comparator function though.


bubble sort is the easiest ?

The choice of a sorting algorithm depends on factors such as worst-case performance, number of elements etc. Think about the number of elements that you need to sort. Think what sort of performance will be acceptable. IMO, implementing bubble-sort is about as easy as insertion-sort or Shell-sort. Merge sort/quick sort/radix sort OTOH, are perhaps slightly more involved.
",1,11006627
11007806,"
If you want it to use plain C, like you seem to, then you are missing out on strcmp and qsort. Note that your code has nothing to do with C++, it's a classic C code and the question is mistagged. If you want it done in C++, see other answers that actually use C++ containers. There's no point to using C++ if you don't actually, you know, use the part that makes it C++, not merely C!
Below is a self contained working example. Note that there is an example both for your 2D array and for an array of pointers to strings. Your 2D array declaration had a superfluous 1st array size. It's unnecessary, the compiler knows how many strings are there.
",1,11006627
11002092,"
Start by calculating minimum and maximum:
Apply some changes to the following code, replacing a[i] by a[i] - k_min; the rest should be easy.
",6,11001797
11020136,"
thnks  Anatolyg my new code is:
",0,11001797
10977556,"
Like larsman told you using a pointer to a SmartPointer is highly probably wrong. Since smart pointers are used to avoid memory leaks, the reference counter is updated on object copy or assignment, so a SmartPointer * is probably useless.
For what concerne a better approach, you could reuse std::list::sort instead of reimplementing your own sort operation. The only things to do is let your Selector implement comparison operator in order to be able to sort your list.
Have a look here.
",3,10977300
10953838,"
Assuming length is the number of characters (excluding the NUL char) in the character array. You need to call the quicksort function as:
because the last argument to the function QuickSort is the index of the last element of the array and in a character array of length length this index is length - 1.
By passing length to the function you are making even the NUL character participate in the sorting and as it is smaller than other characters it gets moved to the beginning of the sorted array which gets printed as a blank when printed.
",6,10953750
11222126,"
You can set the sorting role of the QSortFilterProxyModel to something different then the default Qt::DisplayRole withsetSortRole(Qt::UserRole). Then, in your model's data() method return a proper sort key if it gets called with the role Qt::UserRole, e.g. by concatenating the strings of the involved columns.
",7,10893843
11835863,"
There's one slightly inelegant solution, that is always used to sort multiple columns.
You have to subclass QSortFilterProxyModel and reimplement bool lessThan(const QModelIndex &rLeft, const QModelIndex &rRight) const. Instead of only comparing between the two given indices, check all the columns:
Then you can call sort(0) on your QSortFilterProxyModel subclass and it will sort all the columns. Also don't forget to call setDynamicSortFilter(true) when you want the sorted rows to be dynamically resorted when the model data changes.
To support sorting on arbitrary columns in ascending or descending order, you would have to keep this info in a QList and compare accordingly when lessThan is called. In the list you would have the columns in order of their priority and do the comparisons in the same order. You should also sort the other ""inactive"" columns in some predefined order, otherwise they will not be sorted by default.
",5,10893843
10793983,"
Make three sweeps through the array. First from j=2 up, filling an auxiliary array a with minimal element so far. Then, do the sweep from the top i=n-1 down, filling (also from the top down) another auxiliary array, b, with maximal element so far (from the top). Now do the sweep of the both auxiliary arrays, looking for a maximal difference of b[i]-a[i]. 
That will be the answer. O(n) in total. You could say it's a dynamic programming algorithm.
edit:",8,10793048
10803277,"
This should be possible in a single iteration. max(a[i] - a[j]) for 1 < j <= i should be the same as max[i=2..n](a[i] - min[j=2..i](a[j])), right? So you'd have to keep track of the smallest a[j] while iterating over the array, looking for the largest a[i] - min(a[j]). That way you only have one iteration and j will be less than or equal to i.
",4,10793048
10793606,"
You just need go over the array find the max and min then get the difference, so the worst case is linear time . If the array is sorted, you can find the diff in constant time, or do I miss something?
",1,10793048
12675210,"
Java implementation runs in linear time
",0,10793048
10779135,"
You're still checking the file given by the name """". When you put the line 
it opens the stream to the file specified by the name """" (the value of file at that point). Later, you say 
without actually updating the file used.
Try this:
This will open the stream to the inputted value of file.
A better way to do this would be to just declare and open the file in place of the second line and lose the first:
Using global variables is a generally bad idea if you don't have any reason to. It's better to pass them around in functions, or contain it all in a class.
Also, I notice you've declared using namespace std;, but still use std::vector etc. I would definitely opt for the latter and remove the former. Take care to add the resolution to the couple of things there missing it then though.
",1,10779102
10779119,"
You need to open() the file before you check the status.
",0,10779102
10736479,"
This is not possible.
Unless you go ahead and create a custom structure, it would seem that you need one structure to keep trace of all the items (pairs here), and one to actually count them.
The actual choice mainly depends if the sort operation is a one-off computation or if you actually need to maintain both synchronized.
If it is a one-off computation, then just count when you need and be done with it.
If you need to maintain this order, then I would suggest reading on Boost.MultiIndex and using it as a base to develop a custom class.
",5,10736101
10736724,"
This isn't possible. The comparer has the limitation that when two things are compared, they always compare consistently. Eg: If 'a' is less than 'b', this must always be true.
In your comparer, you break this rule because adding more 'a' or 'b' to the multimap could suddenly cause the result of the comparison to change.
The multimap uses the comparer to organize how it stores its elements in memory. If two elements could compare one way and then suddenly a different way, the entire organization of the elements in the multimap would have to change. multimap isn't implemented to rearrange all of its existing content when you insert only one new element as to do so would be highly inefficient.
",1,10736101
10718557,"
Since number are already sorted when you are printing it, you can store the last printed number and compare against this before printing.
Something like:
",5,10718496
10718584,"
filter duplicate out when printing (assuming m being int[])
or this way if you don't like too much vars
Alternatively you could remove duplicates on sort
",4,10718496
10718517,"
You can add the number to a std::set as soon as you print it, and check all numbers if they are in the set before printing them.
EDIT: I missed the restriction that the numbers are sorted. In that case, a set is overkill and less efficient than just keeping track of the last number printed, and only printing numbers that are different from it afterwards.
",2,10718496
10716977,"
Instead of calling advance, just call ++iterator as many times as needed. After each call, compare the iterator to end().
",2,10716909
10709445,"
In you partition function the
is always true. Thus you're getting the infinite while(true) loop.
And there may be a problem in you size() function from the SortData.h which we can not see yet.
Since the data is random you see the problem from time to time on some input sets.
Slight modification must help:
Sorry for the double-check :)
",4,10709339
10709492,"
partition gets stuck if left < right and theData[left] == theData[right].
",1,10709339
12913261,"
You could simply find that unordered object (O(n)), take the object out (O(1)), find the correct position (O(n)), then insert it again (O(1)).
Assuming C++11,
Before C++11 you need to implement std::is_sorted_until yourself. 
",7,12913193
12913407,"
For this very limited case, writing your own bubblesort would probably be faster than std::sort.
",1,12913193
12913263,"
If you have that level of knowledge, why don't you just swap the items yourself rather than trying to coerce sort to do it for you?
Surely that's a better way.
Even if you don't know where it has to go, you can find that out quickly, remove it, then insert it at the correct location.
",0,12913193
12913282,"
I suppose you could use the insert method to move the element, but I'd like to know more about the way you calculate its ""correct"" position: there could be a better suited algorithm.
",0,12913193
12913355,"
If you think about the traversal possible for a list, it's clearly only end-to-end.  So:

if you don't know where the mis-ordered element is you have to first scan through the elements one by one until you find it, then
you can remember the value and delete the out-of-order element from the list, then
there are two possibilities:

that element is greater in your sorting order than any other element you've yet encountered, in which case you need to keep going through the remaining elements until you find the correct place to insert it.
the element would belong somewhere amongst the elements you've already passed over, in which case:

you can move backwards, or forwards from the first element again, until you find the correct place to put it.


if you've created some records from your earlier traversal you can instead use it to find the insertion place faster, for example: if you've created a vector of list iterators, you can do a binary search in the vector.  Vectors of every Nth element, hash tables etc. are all other possibilities.



",0,12913193
12914488,"
This is If you dont use std::list.
With a Selection sort algorthm, you simply  sort items  0 to 3 ( selectionSort(list,3)) if you know that thats the range.
Not the entire range till the end.
Sample code :
Output:
",0,12913193
12875516,"
Well, C is declared as int* and returned as int rather than as int*. Of course, your program is full of memory leaks as you allocate memory in multiple places but never release it. You might want to have a look at std::vector<int> to represent your arrays.
Also, in the main() function you try to assign an int to an array: you can’t assign to buiLt-in arrays at all, you can only assign to individual elements. Using std::vector<int> would avoid this problem, too.
",2,12875456
12811408,"
std::sort takes its predicate by value, meaning
will copy the contained map.
Next, you're doing a map lookup twice during the comparision, which is O(log N), while it's expected that pred(a,b) is a constant operation.
You can fix this by defining a seperate comparator for std::sort and using std::unordered_map (C++11).
",7,12811352
12811393,"
A map is already sorted. std::sort is probably based on Quicksort, whose worst-case performance is when the input is pre-sorted.
",1,12811352
12787560,"
Giving the OP some options to choose from: (note: not exhaustive)
Option 1: Internal operator <()
called using the default std::less<> template.
Option 2: Internal Functional operator()():
called with optional comparison object, as dasblinken pointed out, odd, but works:
Option 3: External operator <()
This, like (1), uses the default std::less<> comparator, but requires that the external operator also be a friend of class Parola to have access to the private data members if declared as such. Its use is the same as (1).
Option 4: External Functor
And used by:
Like (3), the CompareParola class must be friended to Parola if the members being accessed are private:
Option 5: External Function
Similar to an external operator or external functional class, this also requires being friended to the object class to gain access to the private members. Invoked like such:
Option 6: Static Class Function
This is often under-utilized, and has the very nice attribute of having access to all the object member variables, including private ones (obviously, its defined with the class). You can use this by doing:
Note that this, like (1) and (2), keeps everything in the class. 
Of all of these I prefer (1) for its simplicity, and (4) for its independence, but everyone has their tastes. There are times that (5) or (6) really comes in handy (and I'm a personal fan of (6)).
If you can think of any more and have the rep to edit it, kindly update this as needed. Please do try to make them at least somewhat useful =P
",5,12787165
12787211,"
Your comparator takes pointers, but the vector holds Parola instances. You need to change that. But the easiest would be to implement a less-than comparison operator.
Then you can call sort without a 3rd argument:
",6,12787165
12787248,"
Your immediate problem is that your comparison operator doesn't get passed Parola const* objects but Parola const& objects: the iterators get dereferenced to get a value which is actually compared.
The next problem is that you probably shouldn't try to bundle your comparison object into your actual objects: the comparison object doesn't really behave like a Parola object. You want to have a separate comparator which is then used with std::sort():
Alternatively, you can define a suitable operator<() for your Parola objects:
",3,12787165
12787220,"
Make the operator take const references instead of pointers. I.e.  
",2,12787165
12787240,"
Generally when-ever you have an object that you want the STL to sort for you, either using the sort method, or putting it in a std::set, you need a operator< method.
Hence it's best to make it a member of the class. The signature of that method should be something like:
bool operator<(const Parola& left, const Parola& right)
How you implement it is dependent on your class itself.
",-1,12787165
12786615,"
sort_heap assumes the input to be already in the form of a heap. This means it can theoretically work more efficiently than std::sort, since there are some constraints on the order of the input (unlike the std::sort, which has to work for all inputs).
As mentioned in the comments it is worth noting that those performance benefits are in no way ensured and obviously depend on the input data, so if performance matters there is really no way around profiling.
",10,12786518
12787041,"
In the case where the data already has the heap property, there's an obvious sorting algorithm that doesn't apply to data without the property -- repeatedly remove the maximum element of the heap and restore the heap property. This is how heapsort works (first heapify the data, then use the heap property to sort it).
So, suppose that you have a heap and you want it sorted. You could call std::sort, but std::sort_heap exists to hint that this algorithm be used[*]. It makes at least some sense to provide the programmer with a means to potentially improve the sort performance. Whether it's actually faster or not is another matter.
Observe that std:sort is permitted to be implemented as a heapsort, although I doubt that it ever is.
The world would go on if sort_heap were not available, since there's another way to get the same behavior: repeatedly call pop_heap on a smaller and smaller initial segment of your original heap. So if it troubles you, view it as a pure convenience function. It's possible there are optimizations than can be applied, though, to make sort_heap a little better than this.
A historical note that might have affected the thinking of the authors of C++03: in the SGI version of the STL, sort was defined to use introsort and partial_sort was defined to use heapsort. I don't think that's exactly the rationale for including it in the standard, though: it's also an ""obvious"" function to include with the heap algorithms.
[*] it's a pretty strong hint, since the complexity requirement for sort_heap is ""at most N log N comparisons"", not ""O(N log N) comparisons"". So an implementation can't have sort_heap call sort unless it knows that its own sort implementation performs at most that many comparisons when the input data has the heap property.
",4,12786518
12786583,"
Taken from: http://www.sgi.com/tech/stl/sort_heap.html

sort_heap turns a heap [1] [first, last) into a sorted range. Note that this is not a stable > sort: the relative order of equivalent elements is not guaranteed to be preserved.

std::sort might provide you a O(N^2) complexity in worst case based on the implementation and works on an unsorted set of data. std::sort_heap works on a heap and always gives you O(nlogn)
",0,12786518
12772258,"
You almost had it:
Note that your code had several issues:

You never deleted the allocated memory.
new int[max] does not initialize the array with zeros. You need to use new int[max]() instead. Note the empty parentheses which will set all elements to zero (see ISO C++03 5.3.4[expr.new]/15).
Negative values in the input array will result in memory access violations.

",4,12771582
12769942,"
You explicitly pass begin and end positions, and yet you choose the pivot element from the complete list. That doesn't sound right. You should choose a pivot element between begin and end. Also, x should start at begin, and y should start at end. Otherwise, you are always processing the complete list in each recursive step, which would explain the infinite recursion you are experiencing.
",3,12769848
12745434,"
std::sort requires a comparer that defines a strict weak ordering. This means, among other things, that the following condition must be met:

We define two items, a and b, to be equivalent (a === b) if !cmp(a, b) && !cmp(b, a)
Equivalence is transitive: a === b && b === c => a === c

As you already say in your question, your function cmp() does not meet these conditions, so you cannot use your function in std::sort(). Not only the result of the algorithm will be unpredictable, which is bad unless you are actually looking for this unpredictability (cf. randomize): if you have a few values that are very close to each other, such that any of them compare true with some, but false with some others, the algorithm might enter an infinite loop.
So the answer is no, you cannot use your function cmp() in std::sort() unless you want to risk your program freezing.
",5,12744911
12745059,"
Why would you bother to make an approximate less-than comparison? That makes no sense.
Just sort your array strictly by actual values.
Then use your approximate comparison function to determine which of the elements you wish to consider to be equal.
(The equivalent in English would be the infamous ""almost better"". Think about it.)
",4,12744911
12745587,"
It's possible to define a comparison function for floating point that groups similar values. You do so by rounding:
Now cmp(a,b)==true implies that a<b, and a==b and a>b both imply cmp(a,b)==false.
",-1,12744911
12754947,"
As the comments pointed out, what you propose is a rather convoluted way to solve a basic problem.
Your question could be made more attractive replacing time(NULL) in random generator initialization with a constant that gives the observed behaviour to debug.
Without that, I will place a bid on culprit:
I think should be
or you never consider the top element.
",2,12740058
12740458,"
There are facilities in the Standard library for sorting:
",1,12740058
12741156,"
Based on the comments, let's assume we have a structure something like:
And, we'll assume we have a vector of these:
If we want to insert a new item into the vector in order, we don't really want to do a binary search followed by std::insert. This requires an O(log N) search followed by an O(N) insertion. Instead, we can combine the two, so we only need a single O(N) operation to find the right place and do the insertion. Here's a simple version:
In your case, you want to insert a data struct, and compare (pos+1)->fval > new_val.fval, but the basic idea is otherwise pretty much the same. In reality, this should probably be implemented as a generic algorithm, but I don't have time at the moment.
",1,12740058
12751212,"
I wrote a C++ program with the goal of quickly inserting an element into a sorted vector
You shouldnt have done that.  std::vector is not suitable for quick insertion to custom position. 
EDIT: BTW you are doing replacement, not insertion. For that use of vector is ok. 
Also your code suffers from not using standard functions. std::sort, also you have std::swap if you really want to manually swap elements. 
Also this is unnecessary :
Compiler can and do easily optimize /2 to >>1;
EDIT:
Your code is broken, this will hopefully show you why:
http://ideone.com/pV5oW
",0,12740058
12745181,"
I changed it and am pretty sure it works in all cases now:
@LeGEC and @chac, thank you for looking into the algorithm I posted, it helped a lot. @Jerry Coffin, I did get std::upper_bound to work for this but not for a variable of my Node class, thank you as well though.
",0,12740058
12674882,"
OK, please do not down vote it right away. I know this is a bad example. I wrote it be cause OP specifically asked for a no-STL solution, and to present how (bad) would/could it look like.
Well, there you go. The code is not completed. But you should get the general idea. One thing I did skip is the sorting of integers itself. Since it should be trivial. As you can see, the mapping, is a little bit of PIA and looks quite bad. But since you forbid to use STL there is no std::map. Moreover, I implied static size of N for all the tables. It could be allocated dynamically, no problem, and no std::vector.
I used else ifs for map* functions to mimick std::map functionality. Probably switch ... case could be used, but it should work pretty much the same on a decent compiler.
The code I wrote below is pretty much the same in terms of functionality provided as Armen's does. I would recommend his solution. I skipped same parts. So you can see it's uglier and more typing. It looks almost like  pure C. Maybe with one modification if you really yearn for speed at very large cases. That would be using a temporary data structure that would hold mapped values, to sort it, and then map it back. Precisely I would advise to avoid calling map::operator[](const &T) (or any accessor) on std::string under high performance constraints to avoid hash computations. But that's only it.
There is also some more to discuss. Like what if you wanted two colors to have the same value, or use non-integer weights. STL based solution is way more adaptable.
Cheers.
The code:
",1,12673187
12673251,"
You should write a custom comparator. Here's how I would go about it.
",4,12673187
12674457,"
First thing I would do is to create a mapping. You could do this either via a map or by linearly iterating over a presorted array of strings and taking the index of the matching entry. A very simple way (for demonstration purposes really) might be simply to encode the logic into an encapsulated function as follows:
This will provide an ordering integer based on the input string. The next step is to create a comparator:
This will allow us to compare strings together returning negative if lhs < rhs and positive if lhs > rhs
This can now be used within the STL - either as the comparitor within an associative container or directly in a sort algorithm - with relative ease. Alternatively, if using STL is out of the question or the point of this is to understand how sorting works, you could implement your own sort like the simple and (very) inefficient algorithm below:
",0,12673187
12662491,"
You provided a comparison method with the wrong signature. You need to accept a const reference or a value, but not a (modifiable) reference to your type, while the former should be preferred unless it's a primitive type. So the signature of your comparison method should look like this:
This is because std::sort (and a lot of other methods) are designed to not modify the contents. This is guaranteed if they take a value (but this will be slow for large types) or a const reference.
Note that you defined the comparison method to compare the size of the vectors, not their contents. All your vectors are of equal length. So they are treated to be equal by std::sort. So std::sort wouldn't change v4... If you intend to compare the contents in a way similar to string comparison (the first entry counts first, if equal then take the next and so on...), use this:
",3,12662460
12662490,"
Your forgot a const!
",1,12662460
12662514,"
One thing you'd need is to use const in the parameter to your operator, otherwise it can't match anything that is read-only (which would be the common case).
Keep in mind though that sorting vectors-of-vectors would copy entire vectors every time swaps occur.  This will not be particularly efficient.  If the vectors were stored separately and you had something like vector-of-pointer-to-vector, at least the sorting would be faster.
Be sure to read the definition of ""strict weak ordering"", too.  It is very important for the ordering to be consistent with itself, or standard algorithms like std::sort() can badly misbehave (to the point of corrupting memory in some implementations).
",1,12662460
12645843,"
You should implement double division, because with integers, when you have for example 5/6 it results in 0, and division by 0 is not possible as we know. That's why the program crashes.
SO change the members of the structure to doubles.And then you should take care of some precision issues but at least the program won't crash assuming that you are not allowing 0 value for dy.
",3,12645725
21906280,"
You can use tuple which overrides different operators for lexicographic comparisons (http://en.cppreference.com/w/cpp/utility/tuple/operator_cmp)
But it's a bit annoying to change your struct to a tuple. You can use tie that will make the tuple for you.
However, this solution won't compile because it works with references.
It's not the most efficient solution, but readability is quite good.
Of course, you still have the division by 0 in this example.
",1,12645725
12634292,"
will reserve enough space, but the elements are not actually constructed. This is wrong.
You need resize instead. Or just use push_back, instead of operator[].
",1,12634257
12634431,"
You are using std::vector wrong. reserve only reserves memory for further inserts, it doesn't change the number of actual elements the vector contains (i.e. doesn't change what size() reports).
Thus, you're passing a vector of size 0 to std::sort(), and it consequently does nothing.
Either replace reserve(5) with resize(5), or replace the element assignments with calls to push_back().
The only reason to ever use reserve() is to avoid reallocations (and hence copying) when inserting a large number of elements. std::vector stores the elements in a continouos block of memory, and must therefore copy all elements if a newly inserted elements doesn't fit into the previously allocated block. std::vector usually doubles the allocated size of the memory region each time that happens, which drives the average cost of an insert down to O(n) (from O(n^2), which it would be if the copying happened upon every insert). But the costs of all that copying can still be significant, e.g. if you insert tousands (or more) elements into a previously empty std::vector. In that case, you'd make it allocated a memory block of the desired size in advance with reserve(), and the individual inserts then only have to store the element and increment the vector size. But reserve() never modifies observable state, only internal invisible state of the vector.
",1,12634257
12626900,"
Add flags -Ofast to turn on almost all possible optimization flags of g++.
Yes, -O2/-O3 is enough for this problem. For more information about flags of g++ to optimize, see here https://stackoverflow.com/a/3005673/1095974. 
",1,12626871
12579380,"
Since getting operator< for multiple tests right is rather hard, I advocate my way of doing this with tuple (in this case with make_tuple instead of tie since we're dealing with temporaries returned from functions):
This should work and you can get tuple and make_tuple from Boost too, if your compiler doesn't offer them yet.
",3,12579102
12579195,"
You need to prioritorise your key field comparisons... only if the most important field is equal, then you compare the second most important - if that's equal then you compare the third most important etc..  As soon as there's an inequality, you return true or false as appropriate.  So, it's not a && operation, it should be ? : or an if-else chain, as in:
For the set to operate correctly, you must ensure the keys are never equal - so that last false is never actually used.
",3,12579102
12579337,"
If you have three member foo, bar and baz to compare on, this is a common way to compare them:
Do you see the pattern? ;)
",2,12579102
12579214,"
I have problem understanding your sorting rules, but if the relation is a simple sub-sort than the code should look like this:
",1,12579102
12579396,"
Your class MyLaneConnectionSorter has a flaw.
std::set expects a comparison class that can order elements. So your comparison function must provide behaviour similar to less functor or operator<, i.e. either a < b or a > b (which is b < a) or a == b (which is !(a < b) && !(a > b))
If we take your comparison function, it will consider Lanes (6, 5, 4) and (7, 3, 4) (in format (PPID, PID, ID)) to be equal, because neither one is less than another. So you need to compare like this:
",1,12579102
12578412,"
std::set keeps track of elements based on the key. In your comparator you have return a->getLaneID() < b->getLaneID();. Thus Lane ID implicitly becomes the key. Since if a and b have the same LaneID, then both MyLaneConectorSorter(a, b) and MyLaneConectorSorter(b, a) are returning false.
Your set thus can not contain more than one LaneConnectior with the same LaneID.
",1,12577571
12578060,"
There is a very simple way to catch problems like this way before they get a chance to expose themselves. Write unit tests!
My guess is that all your LaneConnectors start at the same line. So, GetLaneFrom()->GetLaneID() yields the same result on all LaneConnectors
",0,12577571
12576781,"
First, you cannot sort an std::set. It is a sorted structure, sorting happens upon construction or insertion.
Second, you can construct an std::set with your own sorting functor, and you can avoid unnecessary const_casts by making it take const pointers:
and instantiate the set like this:
or, if you want to construct it from a different set, with a different ordering,
",10,12576763
12574776,"
If you never have any NULL pointers:
If you do have NULL pointers, it's only slightly more verbose:
",3,12574729
12555926,"
Probably like this:
std::sort requires that the comparison function (your less-than operator in this case) defines a strict weak ordering. Your implementation does not, because it is possible for both A < B and B < A to be true.
",5,12555891
12555930,"
If T is castable to bool,
template<class T>
bool foo<T>::operator<(const foo<T> &f)
{return a - f.a;}

will return true always except a == f.a. Maybe you need something like:
template<class T>
bool foo<T>::operator<(const foo<T> &f)
{return a < f.a;}

Obviously, runtime error occurs because your less operator is incorrect for sort function.
",4,12555891
12549312,"
std::sort() expects the comparison operation to be stable - if a particular result is returned when two items are compared, the comparison must return the same result if those items are compared again later.  When you return a random value, obviously that's not necessarily going to hold.
C++03 25.3/4 ""Sort and related operations"" says:

If we define equiv(a, b) as !comp(a, b) && !comp(b, a), then the
  requirements are that comp and equiv both be transitive  relations:

comp(a, b) && comp(b, c) implies comp(a, c)
equiv(a, b) && equiv(b, c) implies equiv(a, c)    

[Note: Under these conditions, it can be shown that 

equiv is an equivalence relation
comp induces a well-defined relation on the equivalence classes determined by equiv
The induced relation is a strict total ordering.  

—end note]

And for clarification, Table 28 defines an equivalence relation:

== is an equivalence relation, that is, it satisfies the following
  properties:   

For all a, a == a.   
If a == b, then b == a.


So your Compare() operation will not produce an equivalence relation.
It's kind of nice to get an assertion rather than losing data randomly.
One way to solve the problem of randomizing the sort order when two (or more) entries in _vec are equal is to make up a random value for those indexes and keep track of those random values in a map of index => random value or something.  Just make sure that you keep track of and use those random values in such a way that the transitive and equivalence properties of Compare() hold.
",7,12549289
12549317,"
std::sort expects your less-than operator to supply a transitive relationship, i.e. when the sort sees A < B is true and B < C is true, it implies that A < C is true as well.
In your implementation, the transitivity rule does not hold: when two items are equal, you randomly tell the sort that one of them is greater than the other. This triggers the debug assertion.
Return false for equal values to fix this.
",3,12549289
12545816,"
For std::sort, you are just using the default comparator, which will just compare pointer values.  You need to pass a comparator that does a proper comparison (using strcmp, for example):
That's one problem, there may be others.
",2,12545754
12545832,"
One problem is in your compare function for qsort:
You are not comparing strings here, because a and b are just chars. You might as well avoid them:
",2,12545754
12545888,"
These are the errors I obtain trying to compile your code:
24:15 c_str() is a member function of string not of stringstream. See here.
31:23 strcmp() wants two const char * not two char. See here.
55:23 and 35:6 char* is not the same type as string.
",2,12545754
12545955,"
This function isn't working
and if it was sort of fixed (ss.str().c_str()), it would return a pointer to a temporary.
If you have a compiler with some C++11 support, you can use std::to_string from the standard library. Otherwise, change the return type to std::string (no pointer!).
",2,12545754
12556858,"
Ask Stroustrup ;) just allocate space for the C string array and enter characters ino it.. remember to deallocate it..
",0,12545754
12542885,"
Is an exception thrown by new when it cannot allocate requested memory successfully.
It seems the requested memory size is too large, which means you need to track values of high, low.
",3,12542840
12542891,"
Be aware of dynamic memory allocation. Its really slower. Consider twice before you will leave your code in this form. You can make a simple testcase with std::chrono
http://en.cppreference.com/w/cpp/chrono/duration
you dont need dynamic allocation, everything is done in one local namespace.
",1,12542840
12483309,"
I think you're coming at this with the wrong paradigm.  Java is an Object oriented language, and you should be using it as such.
Then you can use one of the many Java collections available to hold and sort them however you like.  It's some extra coding, but it will allow for more robust and extensible implementations.  For instance:  what if your row has two seats available, but they're on either end? Your current implementation would have to be scrubbed entirely.  Here, you'd just have to change the logic in a couple places, and BAM, you've got v2.
Please, strongly consider using the language to your advantage.  Don't use java as a scripting language, that's not what it's for.
",6,12483188
12468388,"
If currentP=(x,y) is your current point, lastP is the previous point, then test all possible points p by taking the dot product

(currentP-lastP)*(p-currentP)

and choose the p with the biggest dot product. See wikipedia for dot product.
",2,12468132
12465529,"
That's basically mergesort, but with a n^2 in-place merge step. If you do the standard math, like you would to analyze mergesort, you should find that it has n^2 running time. The relevant equation you would need to solve to do this is f(n) = n^2 + 2f(n/2).
",2,12465327
12444103,"
The fastest solution is not to ""sort"" at all: 

Run through the array and count the number of occurrences of 1,2 and 3. These counts should hopefully fit in registers...
Fill the array with the right number of 1s, 2s and 3s, overwriting whatever is there already.

At the end you will have a fully sorted array.
In general, this can be a useful O(n) sorting algorithm when you have a very small range of possible values compared to the size of the array.
",11,12444083
12448247,"
Dutch National flag algorithm is the commonly cited algorithm for this and is actually the partition step in one of the variants of quicksort (1 corresponds to less than, 2 to equal to and 3 to greater than). In that variant, you don't need to sort the middle portion.
",2,12444083
12432204,"
You're correct, a sort of std::vector is going to be slow if copying an element is slow. C++11 introduces move semantics which might help, elements can be moved instead of copied.
A linked list is quite easy to sort with a merge sort, which is O(n log n) the same as any other good sorting algorithm. The difference is in the overhead.
As always benchmarking your particular case is a good idea if the results are important to you.
",2,12431981
12432047,"
Sorting of list is specialized (i.e. list has function sort and cannot be sorted with std::sort).

Complexity: Approximately N log(N) comparisons, where N == size().

std::sort in generalized.

Complexity: O(N log(N)) (where N == last - first) comparisons.

Note that result of std::list::sort is same as std::stable_sort.
Note that there are no information in standard, how sort should be realized. It's implementation-defined.
",3,12431981
12432099,"
You can always sort by sorting a parallel collection of indices or pointers or whatever. This works for both lists and vectors.
The reason sorting a list is slower is the fastest sorting algorithms require random access, i.e. the ability to be able to fetch immediately the value at a given index. You don't get that with lists. To get the 10th item in a linked list (say) you have to start at the beginning and move forward 10 times.
",2,12431981
12363816,"
Read single numbers into integers, pushing them into an std::vector, then use std::sort to sort them, then write them to an output file. Each one of these steps is trivial and has been covered in a multitude of SO questions.
",6,12363782
12363829,"
You should use merge sort for sort array from files like that.
Take a look at the merge sort algorithm at this http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/Sorting/mergeSort.htm.
and the sample source code at this
http://www.c.happycodings.com/Beginners_Lab_Assignments/code27.html
",2,12363782
12364499,"
I think its better tp use merge sort in such situations. read one number from both the files compare them and insert the smallest into output file. by this approach i think time complexity will be less. 
",1,12363782
12359643,"
By default a function has external linkage, meaning any source file that has a declaration of the function can use it no matter which file has the definition. The linker is responsible for connecting the different uses, which is why it complains when it finds more than one.
To keep a function private to the source file it's contained in you must use the static keyword on it or put it in an unnamed namespace.
If all the function definitions are identical you can use the inline keyword to indicate to the linker that they are identical, but in that case you should put the function into a header file to be completely safe.
",3,12358989
12359306,"
try writing it as
or
This should give it the per-cpp scope you're looking for.
if you're writing the function inside a header file, use
",1,12358989
12359089,"
Those seem to be free functions, not members of a class. To define a class member, you'd need bool Class1::Sorter( blah ) { foo; } and bool Class2::Sorter(blah) { foo; }
",0,12358989
12359097,"
Sorter is a global function -- not a class or an object instantiated from a class.  If the same global function is declared in two compilation units, you will get a linkage error.
",-1,12358989
12308375,"
First of all, DON'T.
If you just want to muck about, you can replace iterators with actual pointers:
Apart from not doing all the work std::sort does, there is one unexpected thing about qsort. It is slower.

sort (myvector1.begin(), myvector1.end());
sort (myvector2.begin(), myvector2.end(), myfunction);
sort (myvector3.begin(), myvector3.end(), myobject);
qsort(&myvector4[0], myvector4.size(), sizeof(int), cmyfunction);

4 is the slowest, followed by 2 (function pointer passed to std::sort). 1 and 3 (default and functor) are the fastest (compiled with gnu's g++ with -O3 flag).
",21,12308243
12290511,"
std::sort requires a sort function that creates a strict-weak ordering. This does not. This is <=, which is not a strict-weak ordering. If lhs and rhs are equial then comp(lhs, rhs) and comp(rhs, lhs) must both return false.
Your function does not. Thus, you get undefined behavior.
",22,12290479
12259766,"
Let me give you an example let's only take 3 numbers. So you input
Now you start sorting how you did it. so it compares 13 and 3
13 > 3 so switch both of them.
now we have.
Now it'll compare as you said the next pair = 13 and 1
13 > 1 so the new order would be
now your loop is finished and you missed to compare  3 and 1
Actually the first loop only sorts the greatest number!
",14,12259622
12259735,"

since only a single loop can do the sorting(In my opinion)

This is not correct. Without getting to details, a constant number of loops is not enough to sort, since sorting is Omega(nlogn) problem. Meaning, an O(1) (constant, including 1) number of loops is not enough for it - for any algorithm1,2.
Consider the input
a single loop of bubble sort will do:
So the algorithm will end up with the array: [ 4, 3, 2, 1, 5], which is NOT sorted.
After one loop of bubble sort, you are only guaranteed to have the last element in place (which indeed happens in the example). The second iteration will make sure the 2 last elements are in place, and the nth iteration will make sure the array is indeed sorted, resulting in n loops, which is achieved via a nested loop.

(1) The outer loop is sometimes hidden as a recursive call (quick sort is an example where it happens) - but there is still a loop.
(2) Comparisons based algorithms, to be exact.
",11,12259622
12259764,"
For bubble sorting a pass simply moves the largest element to the end of array. So you need n-1 passes to get a sorted array, thats why you need other loop. Now for your code 1 pass means
so as you can see IF statement repeats itself, its just that after all 9 IFs the largets element moves to the end of array
",2,12259622
12260038,"
This is not correct because

The algorithm gets its name from the way smaller elements ""bubble"" to the top of the list. (Bubble sort)

So, at the end of the first loop, we get the smallest element. So, for complete sorting, we have to keep total n loops. (where n = total size of the numbers)  
",1,12259622
12246896,"

You run the bubble loop only once - you should run it until everything is sorted
Your bubble loop goes to ten, accessing number[i+1], which is an undefined behavior

Here is how you can fix your main loop:
",2,12246861
12246898,"
This is only the first pass of a Bubble Sort. You need to repeat your sort part until no sorting is performed during a pass.
",3,12246861
12246907,"
its quite dangerous to have
and ask the user to enter 10 values ;-)
",1,12246861
12246909,"
You are going out of bounds of the array. Make the loop run 5 times, not 10.
Secondly you are trying to sort the array in just one pass.
Make nested loops. for complete sort.
For Example if you have this array.
After one pass, as you are doing, it would look like this.
So this array is not completely sorted. Make two loops for complete sorting.
And make sure to run the loops till size - 1
",1,12246861
12246904,"
Bubble sort is O(n*n)(worst case)---->need an inner-loop beginning from iteration to the end. Then you should put a checking if finished in the half-way to get better situations such as O(nlogn) or O(n).
Your error was iterating only once from 0--->N

Outer loop should go from 0--->N-1 since next element will be N at last.
Inner loop should go from i+1 to N.  i+1 denotes next element.

If you need to break when it is completed before n*n iteratitons, you need to inform with a boolean
Example:
Initial : 4 9 3 6 2 5 7
",1,12246861
12246936,"
It may be happening because you are declaring an array of size 5 number[5] but trying to enter and access 10 elements.
If you want to have 10 elements in the array declare it as int number[10];
And use the for loop as:
",0,12246861
12237618,"
You can solve this problem more efficiently using std::nth_element. This will only do a partial sorting of the vector, and has linear complexity. This is an example for an odd-sized vector:
the median value is 
You can easily extend this to cover even-sized vectors.
",3,12237456
12231842,"
Your code is a bit odd to me, it is better and more to use cout and cin instead of printf and scanf but beside that you have something like this:
so for first item j is 0 and then it will decremented to -1 and since operator[] of vector take std::size_t and it is an unsigned type it will be interpreted as 0xFFFFFFFF and this is a really large value and large index much larger than your vector size and hence you get ""vector subscript out of range"" 
",2,12231707
12230813,"
prev_permutation and next_permutation generate all permutations in lexicographical (""alphabetical"") order and they return false once the cycle has been completed (i.e. if after calling prev_permutation on the first permutation or after calling next_permutation on the last one).
What happens is that you prepare the array with the first permutation in lexicographical order, then you call prev_permutation. This is however the first, so prev_permutation sets the array to the last permutation and the returns false, so you exit the loop.
Now you enter the next_permutation loop, but the current content of the array is the last permutation in lexicographical order, so next_permutation will set the first one and will return false.
If you remove the prev_permutation part however the loop for next_permutation will start from the first and so it will generate correctly all 6 permutations before returning false.
You can visualize the effect considering all permutations listed in order and with the current configuration as a pointer in this list:
when calling next_permutation you are moving down, when calling prev_permutation you are moving up. When going outside the list both function will move the pointer to the other end and will return false to inform you of this fact.
If you start with prev you move to 2-1-0 and function returns false, then you call next and the function move to 0-1-2 and returns false again.
Using for example instead of 0, 1 and 2 the permutations of two zeros and three ones the lexicographical ordering is:
So to enumerate all of them you need to start from 0-0-1-1-1 and use next_permutation or you need to start from 1-1-1-0-0 and use prev_permutation.
In this case calling next_permutation on the last one 1-1-1-0-0 will change to the first 0-0-1-1-1 and will return false; in a similar way calling prev_permutation on 0-0-1-1-1 will change to 1-1-1-0-0 and will return false because of the flip.
",8,12230763
12230824,"
All the permutations considered by both prev_permutation and next_permutation have a well-defined lexicographical order.  The array you provided to them has some position in that order.
That's why neither function is guaranteed to provide all permutations.
If you provide the first possible permutation to prev_permutation, which you did, there will be no permutations before it.  Likewise, if your array were defined as (2, 1, 0), next_permutation would not provide any new permutations.
If you need all the permutations of some collection, you would want to sort the collection first and then use next_permutation.
",3,12230763
12392714,"
You have a bug in the algorithm itself. E.g. there is undefined behaviour here:
The insertion sort potentially reads out-of-bounds in the marked following line:
It reads before the first element. I suggest you meant
Update quickly benchmarked with GNU g++ 4.6.1 on 64bit linux. I rearranged the timing to be at totals, so I didn't have to reimplement the clock functions (I'm lazy). 
Adapted code: http://ideone.com/LgAgs
Built with
Here's the result: The insertion sort appears to be roughly ~60-100x slower than the others.
",5,12220546
12220587,"
So finally I think I figured out at least a part of what's wrong.
Thanks to sehe for the hint.

When compiled with -O3 (on GCC, or /Ox on MSVC) mixed_inplace is the fastest and pretty close to std::sort()

I suppose this means that at least some of the expected optimizations (tail-recursion) weren't applied by compiler when compiling at lower optimization level.

Build should be release build (w/o -g on GCC).
@sehe: insertion sort performance is irrelevant.
std::sort() implementation on GCC and MSVC are different, so it's not really right to compare the two.

Here are the results on windows and linux with and w/o optimization options:
Windows with MSVC:

Windows with GCC:

RedHat Linux with GCC:

",0,12220546
12205423,"
You've got an ""off-by-one"" error:
",2,12205337
12205411,"
must became
for an array of dimension N index goes from 0 to N - 1
",3,12205337
12205181,"
All the sort methods in the C++ standard library assume that the comparison method you're passing returns true if the left side is ""less than"" the right side. So your compare method will probably do basically the opposite of what you hope it will do.
Also, do consider writing an operator < method for your struct-- that can effectively be used as an implicit compare function, and you can call sort with only two arguments.
",2,12205140
12205274,"
It means that you order point using the x coordinate and, if x coordinates are equal, using the y coordinate. Something like that (not tested):
",1,12205140
12145902,"
QDir::SortFlags is actually a typedef of QFlags<QDir::SortFlag>, type-safe way of storing OR-combinations of enum values.
So what you do is simply QDir::Name | QDir::Time in your case as the argument to QDir::entryInfoList() method.
",2,12145165
12127500,"
I am not sure that you understood the answer to the other question, but you do want the whole pair to be reordered according to the double value. The original index (the int) must be attached to the double that was in that location in the original vector so that you can recover the location. Note that if you sorted only the double within the pair, then the value of the int would be the location in the array... which does not need to be maintained as a datum at all.
Alternatively, you can consider a similar (although slightly different) solution. Create a single vector of integers that is initialized with values in the range [0..N) where N is the size of the vector of doubles. Then sort the vector of indices using a comparator functor that instead of looking at the value (int) passed in will check the value in the original double vector:
In this approach, note that what is not being reordered are the doubles, but rather the vector of indices. After the sort completes the vector of indices will contain locations into the vector of double such that i < j => d[ ints[i] ] <= d[ ints[j] ].
Note that in the whole process, what you want to reorder is the indices (in the original approach to be able to reconstruct the unsorted vector, in this approach to be able to find the values in sorted order), and the original vector is there only to provide the criterion for the sort.
Also note that the only reason to sort only the indices and not a modified container with both the value and the index would be if the cost of moving the data was high (say that each datum is a large object that cannot be cheaply moved, as a struct holding an array --not vector-- of data).
",0,12127197
12127210,"
If you want the results to depend on the original order, use std::stable_sort.
",5,12127197
12127214,"
This approach sorts pairs as a single unit, which is what it is expected to do: it never make sense to break up the first and the second of the pair. If you would like to sort only the first item and leave the second in place, you will end up with a different set of pairs.
If you want to sort the first separately from the second, place them in separate arrays (better yet, use vectors) and sort the first vector. Then iterate both vectors, and make a new set of pairs.
",2,12127197
12083800,"
Did you try changing meanResponse to const?
Since you are passing the Policy objects to the compare function with const reference you can't call non-const methods on them.
http://www.parashift.com/c++-faq-lite/const-member-fns.html
",4,12083770
12055115,"
If you are trying to sort the vector, you could define a custom less-than comparator for your objects, and use std::sort.
If you want it all to go to a new vector, then just copy the original, then sort the copy:
",3,12055044
12055208,"
Because you are not removing your smallest person from the old array when you put it into the new one. Consider the values [5,4,3,2,1]
Your algorithm will on the first value for i find that the smallest is j=4 (value 1) and push 1 onto the new array, then it will do this for i=2 and so on until you have only [1,1,1,1,1]
Here is what you are doing, where the bold numbers are the ones being looped over, and the second array is the output array.
Pass 1:
[5 ,4, 3, 2, 1]
[1]
Pass 2:
[5, 4, 3, 2, 1]
[1,1]
Pass 3:
[5, 4, 3, 2, 1]
[1,1,1]
Pass 4:
[5, 4, 3, 2, 1]
[1,1,1,1]
Pass 5:
[5, 4, 3, 2, 1]
[1,1,1,1,1]
Just remove the item that you just found to be the smallest from the old vector when you add it to the new one each time. Of course as other people have pointed out it would actually be better to just use std's sorting algorithms
",1,12055044
12030723,"
Based on the code here: http://cplusplus.happycodings.com/algorithms/code17.html
",17,12030683
12030854,"
To answer the question: Creating dynamically sized arrays at run-time is done using std::vector<T>. Ideally, you'd get your input using one of these. If not, it is easy to convert them. For example, you could create two arrays like this:
However, allocating dynamic arrays is relatively slow and generally should be avoided when possible. For merge sort you can just sort subsequences of the original array and in-place merge them. It seems, std::inplace_merge() asks for bidirectional iterators.
",24,12030683
25883550,"
I have completed @DietmarKühl s way of merge sort. Hope it helps all.
",8,12030683
15364676,"
I've rearranged the selected answer, used pointers for arrays and user input for number count is not pre-defined.
",6,12030683
19670365,"
",3,12030683
15451854,"
I know this question has already been answered, but I decided to add my two cents. Here is code for a merge sort that only uses additional space in the merge operation (and that additional space is temporary space which will be destroyed when the stack is popped). In fact, you will see in this code that there is not usage of heap operations (no declaring new anywhere).
Hope this helps.  
",2,12030683
23438024,"
Here's a way to implement it, using just arrays.
",1,12030683
42850813,"
The problem with merge sort is the merge, if you don't actually need to implement the merge, then it is pretty simple (for a vector of ints):
",1,12030683
29549758,"
This would be easy to understand:
",0,12030683
12026414,"
You can do it in linear time O(N) with this algorithm: construct vector len of the same size N as the original vector, such that len[i] contains the length of the longest consecutive ascending run to which element seq[i] belongs.
The value of len[i] can be calculated as follows:
With len in hand, find the index of max(len) element. This is the last element of your run. Track back to len[j] == 1 to find the initial element of the run.
Note that at each step of the algorithm you need only the element len[i-1] to calculate len, so you can optimize for constant space by dropping vector representation of len and keeping the prior one, the max_len, and max_len_index.
Here is this algorithm optimized for constant space. Variable len represents len[i-1] from the linear-space algorithm.
Here is a link to this program on ideone.
",7,12026361
12026409,"
You need 4 indexes (begin, end, tmp_begin, tmp_end). Iterate through the original array using tmp_begin, tmp_end as the work indexes and each time you find a longer sorted sequence update begin and end indices. 
To check that a subsequence is sorted, you have to check that element at i is greater than element at i-- for each pair of consecutive items in the subsequence.
In the end: print all the elements in the original array starting at begin and ending at end.
",5,12026361
12026406,"
",1,12026361
12019617,"
You are returning a pointer from your merge function which points to a local variable. The local variable will go out of scope the moment you return from your merge function. So you return a pointer that is not pointing to any valid memory.
",2,12019581
12019613,"
Your merge function is returning a pointer to a local variable.
",0,12019581
12019950,"
You have more than simple initialization problems:
When I compile I get the following errors:
Out of these I would say:
That one is critical. But you should fix all of them.
",0,12019581
11986203,"
The cause is in c++ std io synchronization. The following code:
gives
The C-version gives this:
Edit: As RiaD correct mentioned sync_with_stdio of course is static function, so it enough to call the function once for all std io streams.
",27,11985859
11986109,"
You're also using two different I/O libraries. This will completely screw up any timing information, as the C and C++ I/O libs are very different. IOstreams are plain not designed for speed. 
In addition, I/O is completely untimable. If the source of I/O data simply happened to be coming in slower one time, one program would appear to be slower regardless of the sort time- for example, if the OS happened to have it in cache for one run but not for another.
You need to time purely the time taken to sort a pre-existing std::vector<std::string>, say.
Oh yeah, and your getl is full of memory leak.
",11,11985859
11985948,"
My guess is that you don't measure sorting speed, but memory reallocations. Instead of doing a.push_back one element at a time, try allocating the vector memory upfront like you did with the C program
Depending on whether your compiler uses re-allocations with an expansion factor of 1.5 (VC++) or 2 (g++), you have 29 and 17 re-allocations with 140,190 lines in your file (i.e. log(total lines) / log(expansion factor)).
The comment by R. Martinho Fernandes also hits the nail: use std::chrono::high_resolution_clock::now() around the sort statements in both programs to get the timing differences. This isolates you from memory and IO differences.
",7,11985859
11990480,"
Others have noted that most of what you're measuring is the speed of the I/O library. I think it's worth noting, however, that contrary to some statements that have been made here, C++ iostreams can be entirely competitive with I/O using C FILE *s. So, what you're measuring is mostly ""how crappy are gcc's iostreams?"", not ""how crappy are iostreams in general?""
For example, I started by concatenating together all the .txt files I had in one directory to create a fairly large text file. I then compiled your C code with VC++ 10 and used it to sort that file (writing the output to another file). That ran in 3.2 seconds.
I also wrote what I'd consider reasonably idiomatic C++ to do the same task:
This is about the same length as your C++ code, but (I'd claim) simpler than either of your programs. If you actually cared, it would be pretty easy to make it somewhat shorter still. It makes no particular attempt at optimization at all. Compiled with VC++ 10 (with the same optimization flags as I used on your C code -- -O2b2 -GL) it runs in 2.8 seconds, roughly 10% faster than your C code.
I'd expect that if you run this on Linux, you'll find that it's slower than your C code. Adding the two sync_with_stdio(false); calls will probably fix that, just like they did with your C++ code. The sync_with_stdio(false); calls generally make quite a large difference on Linux, but I've never been able to measure any improvement from using them on Windows (with any of the compilers I've tried -- VC++ and MinGW recently, and longer ago Intel, Comeau, CygWin, and Borland as well).
",5,11985859
11989104,"
I/O issues aside (not to say that these aren't genuine), the two sorts do two different things. The C++ version moves string objects around, and the C version moves pointers. The latter will usually (see below) be faster. Rewrite the C++ code to move pointers instead of objects, i.e. use a std::vector<std::string*>, and explicitly new each string object. Yes, it's not idiomatic, but it's a fairer speed comparison.
If std::sort is move-aware, moving strings becomes much faster, and std::vector<std::string> doesn't suffer anywhere near as much. But move semantics are new in C++11, and even if you have a C++11 compiler, move semantics may not have migrated into std::sort.
",2,11985859
11965377,"
Instead of doing std::sort(quantile.begin(), quantile.end()) a somewhat cheaper way would be
This would not sort the complete array, but only do a ""between groups"" sort of the 4 quartile. This saves on the ""within groups"" sort that a full std::sort would do. 
If your quantile array is not large, it's a small optimization. But the scaling behavior of std::nth_element is O(N) however, rather than O(N log N) of a std::sort.
",19,11964552
37708864,"
Here is Quantile function which is MATLAB's equivalent with linear interpolation:
Find quartiles:
",6,11964552
11964854,"
You need to preallocate first and third vectors before you set the contents.
or use push_back instead of assignments to first[i] and third[i]
",1,11964552
48240847,"
This C++ template function calculates quartile for you:
To use it do:
",1,11964552
11964589,"
If only one element in vector, this instruction is out of range:
""i"" starting from mid so third[0] is out of range
",0,11964552
11964621,"
Here is one error:
The vector first doesn't have any contents, but you try to access the contents. Same problem with third and its loop. Do you mean to use push_back instead?
",0,11964552
13573557,"
That's what templates are for!
Since I've templated the operator rather than specializing the comparer directly, the compiler can deduce the types, so we don't have to put the types directly.
I use std::less rather than operator<, because it safely compares pointers to pointers (like char**), rather than relying on Undefined Behavior.  std::less falls back on operator<, so it doesn't add any complexity to calling code, and there should be no downside.
I'm certain this one compiles
",8,13573532
13573555,"
What about a template?
used like this:
",10,13573532
13524479,"
Its average case complexity is considered to be O(n log(n)), whereas in the worst case it takes O(n^2) (quadratic).
Consider the following pseudo-code:
The partition is determined by the line passing through two distinct extreme points: the rightmost lowest r and the leftmost highest points l. Finding the extremes require O(n) time.
For the recursive function, it takes n steps to determine the extreme point z, but the cost of recursive calls depends on the sizes of set A and set B.
Best case. Consider the best possible case, when each partition is almost balanced. Then we have
T(n) = 2 T(n/2) + O(n).
This is a familiar recurrence relation, whose solution is
T(n) = O(n log(n)).
This would occur with randomly distributed points.
Worst case. The worst case occurs when each partition is an extremely unbalanced. In that case the recurrence relation is
Repeated expansion shows this is O(n^2). Therefore, in the worst case the QuickHull is quadratic.

http://www.personal.kent.edu/~rmuhamma/Compgeometry/MyCG/ConvexHull/quickHull.htm
",4,13524344
13527025,"
Let's do the selection sort for a 10 size int array using pointer notation, you can simply change it to an array list.
",0,13520530
13520579,"
This sorts the string into an already allocated buffer, and if the buffer isn't large enough tells you how big it has to be:
This does the poor ""allocate a new string"" pattern, using the above implementation:
And don't use variable names that start with an _, it is a bad practice because it wanders really near compiler reserved names.  _Capital is reserved everywhere, and _lower in global scope, and foo__bar everywhere.
",0,13520530
13496806,"
Yes, you can do it using std::sort using a comparison function.  
",8,13496767
13499449,"
In general, implementing comparison operators (and functions) for multiple fields is more clearly expressed in terms of tie when lexicographical ordering is required.
However, even that leaves some duplication and route for inconsistency. The following helper sees to that:
which can then be applied simply:
Taaadaaam :)
",5,13496767
13496803,"
std::sort takes a custom comparison function. I haven't tested this, but yours might look something like:
",2,13496767
53709264,"
Since C++11, you can also use a lambda expression instead of defining a comparison function:
This way you can keep your code rather short.
Code on Ideone
",2,13496767
13495209,"
You can use std::sort with a custom comparison function object
Usage:
",28,13495207
34135780,"
Just give a solution using the lambda function if C++11 is available.
Then you can access contours[0] to get the contour with the smallest area and contours[contours.size()-1] to get the one with the largest area because the contours are sorted in ascending order. 
",2,13495207
13488806,"
I think your error is that when you do the insertion sort you are still using the original size of the array. Therefore you end up doing an insertion sort on the whole array.
",5,13488755
13465332,"
testSorter is a non static member function of the class WilxList which is causing the difficulty. To use function pointers to non static member functions is relatively more difficult, and is impossible to use in cases which expect a free (or static member) function like the sort algorithm. 
One option to fix this is to move testSorter into the struct itself and rename it to operator<. This will let you do stuff like x1<x2 and you can call sort as just std::sort(sortedTests.begin(), sortedTests.end()); This is assuming the function actually represents a < operation, if it isnt, it might get confusing and would be neater to just make it a static member function. The errors will go away in either case.
",5,13465301
13465333,"
The problem is that the comparator function is a member function, which std::sort doesn't expect.
You can solve this in a number ow ways: The first is to make the comparator function static, another is to make it a free-standing function, a third way is to use a C++11 lambda expression.
",1,13465301
13465392,"
Change the code to:
Non-static testSorter takes an implicit this pointer which is incompatible being using as an predicate in std::sort, which takes two arguments.
Also you can declare testSorter as global function, either is okay.
",1,13465301
13465354,"
You want 
or something similar. Check here http://www.cplusplus.com/reference/std/functional/mem_fun/
",0,13465301
13461195,"
In general, to find the lowest value in an array, you can follow this psuedo-algorithm:
However, you can't ""drop"" a value out of a static array. You could look into using a dynamic container (eg. vector), or swapping the lowest value with the last value, and pretending the size of the array is 1 less. Another low level option would be to create your own dynamic array on the heap, however, this is probably more complicated than you are looking for.
Using an vector would be much easier. To drop the lowest element, you just have to sort in reverse order, then remove the last element. Personally, I would recommend using a vector.
",3,13461049
13461342,"
The obvious approach to find the smallest element is to use std::min_element(). You probably want to use std::vector<T> to hold your elements but this isn't absolutely necessary. You can remove the smallest value from an array like this:
Assuming you, reasonable used std::vector<int> instead, the code would look something like this:
",2,13461049
13461459,"
First find the index of the lowest number:
Now that we know the index, move the numbers coming after that index to overwrite the index we found. The number of numbers to move will be 19 minus the found index. Ie, if index 2 (the third number, since the first is at index 0) is lowest, then 17 numbers comes after that index, so that's how many we need to move.
Good luck!
",0,13461049
13461817,"
Sort the array ascending.
The lowest value will be at the beginning of the array.  
Or sort the array descending and remove the last element.  
",0,13461049
13462005,"
Further to what others have said, you may also choose to use something like, perhaps a std::list. It's got sorting built-in, also offering the ability to define your own compare function for two elements. (Though for ints, this is not necessary)
First, I typically typedef the vector or list with the type of the elements it will contain. Next, for lists I typedef an iterator - though both of these are merely a convenience, neither is necessary.
Once you've got a list that will holds ints, just add them to it. Habit and no need to do otherwise means I'll use .push_back to add each new element. Once done, I'll sort the list, grab the element with the lowest value (also the lowest 'index' - the first item), then finally, I'll remove that item.
Some code to muse over:
Oh, and the choice to use printf rather than cout was deliberate too. For a couple of reasons. 

Personal preference - I find it easier to type printf(""%d\n"", someVar);
than cout << someVar << endl;
Size - built with gcc under windows, the release-mode exe of this example is 21kb.
Using cout, it leaps to 459kb - for the same functionality! A 20x size increase for no gain? No thanks!!

Here's an std::list reference: http://www.cplusplus.com/reference/stl/list/
",0,13461049
26824880,"
In my opinion the most optimal solution to your problem would be to use a linked list to store the numbers, this way you can use an algorithm with complexity O(N) = N to find the smallest element in the list, it is a similar finding method given by user1599559 or Mikael Lindqvist, you only need stored together with the minimum value the pointer to the Item(ItemX) in the linked list that store it, then to eliminate Item X just tell Item X - 1 points to Item X + 1 and free memory allocated by Item X
",0,13461049
13448670,"
If I understand the edited question correctly your graph is a circular linked list: each node points to the previous and next nodes, and the ""last"" node points to the ""first"" node as its next node.
There's nothing particularly special you need to do the sort that you want.  Here are the basic steps I'd use.

Put all the nodes into an array.
Sort the array using any sorting algorithm (e.g. qsort).
Loop through the result and reset the prev/next pointers for each node, taking into account the special cases for the first and last node.

",3,13448385
13448470,"
Here is a C++ implementation, hope is useful (it includes several algorithms like dijkstra, kruskal, for sorting it uses depth first search, etc...)
Graph.h
Graph.cpp
",3,13448385
13448412,"
If you are looking for sorting algorithms you should just ask google:
http://en.wikipedia.org/wiki/Sorting_algorithm
My personal favourite is the BogoSort coupled with parallel universe theory. The theory is that if you hook a machine up to the program that can destroy the universe, then if the list isn't sorted after one iteration it will destroy the universe. That way all the parallel universes except the one with the list sorted will be destroyed and you have a sorting algorithm with complexity O(1).
The best .... 
",0,13448385
13448745,"
Create a struct like this:
This lets you resort things however you want.
Now, make a std::vector<SortHelper<blah>>, sort it, and you now have a vector of instructions of where everything ends up going after you sort it.
Apply these instructions (there are a few ways).  An easy way would be to reuse container pointer as a bool.  Walk the sorted vector of helpers.  Move the first entry to where it should go, moving what you found where it should go to where it should go, and repeat until you loop or the entire array is sorted.  As you go, clear the container pointers in your helper struct, and check them to make sure you don't move an entry that has already been moved (this lets you detect loops, for example).
Once a loop has occurred, proceed down the vector looking for the next as-yet-not-in-right-place entry (with a non-null container pointer).
",0,13448385
13446477,"
It is cleaner to write it this way
You should also be able to do temp = e[i] and so on since the members are all ints.
This (and the code you submitted) should do the task you want I think.
If you are having stability issues, thats because quicksort isnt stable. You could get around it by adding more conditions so that lhs==rhs doesnt happen. Alternatively you can try Mergesort
I dont have much experience with Quick sort frankly, but your impl does look markedly different from Wikipedias In Place Algorithm. For instance, your pivot is not moved at all. Could you check if that is the problem?

Edit
After looking at your link
It looks like the algorithm linked also uses pivot as a value instead of as an index (as you do). It looks syntactically identical to yours until you consider that your pivot value might move, after which your pivot index would point to something else 
Does this help?
",1,13446454
13446513,"
EDIT: Here's pseudocode for in-place quicksort: http://en.wikipedia.org/wiki/Quicksort#In-place_version
This differs from your code in that the pivot is a value (an average of the left and right values) rather than an index.
If you're looking for a simple non-optimal solution, mergesort the entire list by destination vertex, then mergesort the entire list by origin vertex, then mergesort the entire list by edge length.  This takes advantage of the fact that mergesort is a stable sort algorithm and has running time O(E) on the number of edges.
",0,13446454
30827304,"
",5,13443795
13444622,"
Let's think about how Insertion Sort works: It ""splits"" (in theory) the list into three groups: the sorted subset (which may be empty), the current item and the unsorted subset (which may be empty). Everything before the current item is sorted. Everything after the current item may or may not be sorted. The algorithm checks the current item, comparing it with the next item. Remember that the first item after the current item belongs to the unsorted subset.
Let's assume that you are sorting integers in increasing order (so given ""3,1,5,2,4"" you want to get ""1,2,3,4,5""). You set your current item to the first item in the list. Now you begin sorting: 
If the next item is greater than the current item, you don't need to sort that item. Just make it ""current item"" and continue.
If the next item is less than the current item then you have some work to do. First, save the next item somewhere - let's say in a pointer called temp - and then ""remove"" the next item from the list, by making current->next = current->next->next. Now, you need to find right place for the removed item. You can do this in two ways:

Either start from the beginning of the list, going forward until you find the correct position. Once you do, you insert the item there and you continue your insertion sort. This is the simplest solution if you have a singly-linked list.
You go backwards, until you find the correct spot for the item. Once you do, you insert the item there and you continue your insertion sort. This is a bit more involved but can work well if you have a doubly-linked list.

You continue this process until you reach the end of the list. Once you reach it, you know that you have completed your insertion sort and the list is in the correct sorted order.
I hope this helps.
",3,13443795
13443828,"
Think about this - if the list is empty, temp will initially be NULL, so you get undefined behavior when you do temp->next  = head;.
Try some debugging, it will surely help. You'll probably either want to keep the previous node as well, so you can insert afterwards, or look 2 nodes forward.
",1,13443795
53996372,"
Here is the Java Implementation of Insertion Sort on Linked List:


Time Complexity: O(n^2)
Space Complexity: O(1) - Insertion sort is In-Place sorting algorithm


",0,13443795
46127068,"
",-1,13443795
13428967,"
First, all three major templates can be exposed using just an operator <() so long as you enforce strict ordering:
Next, your class must implement operator <() to compare a *this against a parameter. A sample appears below:
Lastly. sort your list like so:
Or as Juan pointed out, use the list-sort directly:
Hope that helps.
",2,13428840
13428861,"
You can use the std::list::sort method directly, instead of std::sort:
But you have to implement lessThan and greaterThan or similar functions in terms of Point types. For example:
Note that the above comparison function is just an example, you have to decide how to implement less-than and greater-than with 2D points.
For completeness, here's a lexicographical comparison using std::tie:
",1,13428840
13417626,"
From what I understand of your question, you want to separate odd and even numbers. If that's the case, std::partition will do just that.
If you want to sort by ascending values AND separate odd and even numbers, I would use something similar to this piece of code (still, you will have to figure out which component of your Point you want to sort on)
This function can be used with std::sort, here's a short example:
Will give you the following output:
For other types simply change the int or make it a template parameter
",5,13416712
13416911,"
For this, you should use std::partition instead of std::sort
With sorting, you typically want the sorting to be based on the relative order of any two elements. In this case, you just want to partition your input based on an inherent property of your elements. Both cases can be reduced to the other, but it is always a little easier to take the direct approach.
",5,13416712
13416814,"
If you look at a  reference for std::sort you will see that the function it uses to compare should take two arguments that it should compare. So your code will not work at all.
I recommend you instead iterate over the vector, sorting out even values into one temporary vector, and the odd values into another temporary vector. Then you clear the actual vector, and append the two temporary vectors in the order you like.
",1,13416712
13416838,"
You can write a comparison function like
Then you can use that as third argument to std::sort.
",1,13416712
13981561,"
In C# it is even simpler:
",0,13416712
35657309,"

The catch is that there are two functions you can use.
template< class BidirectionalIterator, class UnaryPredicate >
BidirectionalIterator partition( BidirectionalIterator first, BidirectionalIterator last, UnaryPredicate p );

template< class BidirectionalIterator, class UnaryPredicate >
BidirectionalIterator stable_partition( BidirectionalIterator first, BidirectionalIterator last, UnaryPredicate p );


The functions partition() and stable_partition() reorganize
  elements of the collection in such a way that all elements for
  which predicate p returns true will precede all those for
  which p returns false. It means that the elements will be
  divided into two ranges:
• [first, return_value)
• [return_value, last)
where return_value is the iterator returned by either of functions.
  The sequence of elements in the resulting groups is where
  partition() and stable_partition() differ. 
partition() does not guarantee any particular order within the
  ranges.
stable_partition() will keep a relative order of elements before
  the split. It means that if there are two elements a and b, and a
  precedes b, and if they both belong to the same group after the split,
  element a will still precede element b.

Here is a sample code:
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

bool IsOdd(int i) {
    return (i & 1); //use !(i & 1); if you want to place even elements first in the vector
}

int main() {
    vector<int> v;
    // set some values and shuffle them:
    for (int i = 1; i<10; ++i)
        v.push_back(i);
    random_shuffle(v.begin(), v.end());

    cout << ""All elements:"";
    for (vector<int>::iterator it = v.begin(); it != v.end(); ++it)
        cout << ' ' << *it;
    cout << endl;

    //sort the vector
    cout << ""Sorted vector:"";
    sort(v.begin(), v.end());
    for (vector<int>::iterator it = v.begin(); it != v.end(); ++it)
        cout << ' ' << *it;
    cout << endl;

    //change to partition and see the difference
    vector<int>::iterator bound = stable_partition(v.begin(), v.end(), IsOdd);

    // print content:
    cout << ""odd elements:"";
    for (std::vector<int>::iterator it = v.begin(); it != bound; ++it)
        cout << ' ' << *it;
    cout << endl;

    cout << ""even elements:"";
    for (vector<int>::iterator it = bound; it != v.end(); ++it)
        cout << ' ' << *it;
    cout << endl;

    cout << ""Sorted odd-even vector:"";
    for (vector<int>::iterator it = v.begin(); it != v.end(); ++it)
        cout << ' ' << *it;
    cout << endl;

    return 0;
}

Output:
All elements: 5 6 2 1 9 4 7 8 3
Sorted vector: 1 2 3 4 5 6 7 8 9
odd elements: 1 3 5 7 9
even elements: 2 4 6 8
Sorted odd-even vector: 1 3 5 7 9 2 4 6 8

I hope it helps for understanding.
",0,13416712
13413075,"
Define a comparator for your class or simpler, a operator<() overload (which you need to do anyway for your templates to work).
First, fix your templates:
Next, define an operator<() on your class.
Now just invoke sort:
Invoke using your lessThan template as such:
Or your greaterThan template:
",4,13412986
13413140,"
In C++11 you could write a lambda function to do it.
Using boost, if you want a ""one-step on the fly"" functor it would have to be something like:
Not sure if that will work exactly. (Will the 2nd and 3rd binds convert properly to placeholders?)  Easier to write a very generic functor that combines what you are trying to do, i.e. extract something from your class (a transformation) then pass that into the predicate.
should work and you've kept Comparator generic.
(Not sure if boost already offers something like this).
",3,13412986
13413180,"
There are a few issues with your code:

Class is missing semicolon at the end.
Your comparison templates should return bool instead of a T.
You miss comparison operators inside your class:
or fix your templates to only use operator<() for all the comparisons (which is a common practice BTW).

When you fix above you just use your templates like that:
BTW, you do not need custom templates to sort your class in such an easy way. Reuse what is already in STL:
You can find those in functional header. You also cannot use operator==() for sorting but it may be useful for unordered containers introduced in C++11.
EDIT: If your sorting algorithms for Map2D class are fixed (what is lessThan does not change with time) than I suggest following my answer. Otherwise if now you want to sort by X and after a few lines by Y than @MikeSeymour answer may be better suited to your needs.
",3,13412986
13413322,"
If you are in C++11, you can write something like this:
Otherwise you have to implement compare functor, i.e
and then
But really it isn't a good style to have lessThan, greaterThan, since you can compare x directly. And if you want some special comparison for Map2D maybe it is better to make these compare functions only for Map2D objects.
Upd: you can also use just function pointer as your comparator, i.e:
and then
But you may loss some performance (see comments below).
",2,13412986
13413132,"
You first need to overload operators <, > and == to use Map2D with your templates: 
After you have done you just use it:
",1,13412986
13413108,"
You can't really. You'll need to define functors (either functions, or classes that overload operator() appropriately) to do the particular object-member comparisons you need, and your function templates don't do that. You need something like:
In C++11, lambdas can save you a bit of typing:
",1,13412986
13413070,"
Be aware that lessThan is a prediacte function that should return instead of T value of type bool
Some additional explanation:
",0,13412986
13413095,"
A good way, I don't think it's the best. 
You can overload the operator (<) & (!=) in the class. If you only want to sort for X.
And just use sort(map2d.begin(), map2d.end()) for ascending. and sort(map2d.rbegin(), map2d.rend()) for descending .. And that solves your problem.
OR:
You can make 2 functions to compare 1 relevant to x & the other relevant to Y.
As:
And so for Y. 
Not sure if map2d.rbegin() will sort this descedingly or you'll  have to do it on your own as well.
",0,13412986
13408818,"
The error in your program is that you reset duration throughout the loop. A cleaner way to handle the time would be to put the duration variable modification outside the for loop. For example:
EDIT: forgot to remove the part inside the loop. Fixed now.
",7,13408765
13408960,"
Number one, you don't seem to reset duration between runs of the different sorts.  This means the sum of individual iteration durations would be propagating down through each sorting phase (if the next point weren't also a problem).
Next, you need to setup a separate variable, call it durationSum and use that as you are currently using duration in the summary phase after iterating. Currently, you're blowing away your sum on every iteration.
For example:
Next, you're making a type error when amortizing duration.  You have:
With minimal edits, this would work more precisely (but should use durationSum):
Before, you were saying ""use integer division to divide duration by 2000, THEN promote it to a double and divide by CLOCKS_PER_SEC (this time with floating-point division because one of the operands is a double and one integral). Using 2000.0 forces duration to be promoted to a double for a floating-point division by 2000.
Finally, it would be better to consider the loop overhead negligible compared to a single sort iteration and do only two calls to clock() per 2000 sort-iterations.
For example:
Finally, note that you are using duration as an int whereas in reality it is a clock_t, and if you are on a 64-bit system, it is very likely that this is a 64-bit number being returned by clock() and ""narrowed"" (downcast) into a 32-bit integer int. Use clock_t.
",2,13408765
13408123,"
I often sort linked lists via an index-pointer-list. To build one requires a memory allocation equivalent to the number of nodes (N) * the size of a node pointer. The concept is simple enough.
Note: this algorithm is in C, as I was not entirely sure if the OP meant to class this as a C++ question (who the hell uses linked lists in C++ with the standard containers at your disposal??)

Determine the number (N) of nodes in the list
Allocate a pointer-array for N node pointers.
Load the pointer array with every node pointer in the list. I.e. walk the list, and put a pointer in each slot of the pointer-array, incrementing as you go.
Send this node pointer array to your sorting algorithm (I like the runtime library qsort() since it is standard-equipped).
After sorting, walk the entire pointer array (less one), setting each node's ""next"" pointer to point to the one that follows. The last one sets its ""next"" pointer to NULL.
Set the head pointer to be the first pointer [0] in the pointer array.
Free the memory of the pointer array

Your linked list is sorted.

Assuming your node is something like this:
Determine the number of nodes in your list. I'm assuming you have a proc that can do this, which is trivial:
Allocate a pointer array the size of the list, where nItems is the list node count greater than 1 (no sense in bothering with a list of length zero or one):
Populate the pointer array with all the items in the list:
Now send this to qsort() with an appropriate comparision function. An example comparison function that sorts based on the keyField in our structure is below:
Invoking qsort() looks like this:
Now walk the entire list. rewiring ""next"" pointers:
Rewire the head pointer.
And finally, free the pointer array.
Your linked list is sorted.

Sidebar merge-sort is the only O(nlogn) algorithm I know of that can sort a linked list with no added space requirements. A general solution that prototypes to the following would be nutz:
",3,13407880
13408006,"
If we simply show you the code we will be doing you a great disservice. I will give you, instead, two different approaches and you can implement the one that you prefer.
The first approach is to ""sort"" as you insert: when you are inserting a value, say, 7, you follow this procedure starting with the first entry in your list until you run out of nodes:
If the node you are examining has a value that is greater than 7 you insert a new node before the node you are examining and return. Otherwise you look at the next node. If there is no next node, the. You insert a new node at the end of the list since that means that 7 is larger than al other entries in the list and return.
A second alternative is to sort the entire list using one of the many sorting algorithms. I would suggest that you use BubbleSort since it's easy to understand and implement. You can read more about bubblesort (ans many other sorting algorithms) on Wikipedia.
",2,13407880
13408173,"
Good old quicksort will do the trick (C++03 friendly):
Check: http://ideone.com/OOGXSp
",1,13407880
13395207,"
AFAICS, you can leave your code as is. The only thing you must define is a comparison operator for Point2D or whatever object you're returning:
You can also remove your method_comparer class and just give appropriate comparer functions to sort:
and
Depending on your requirements, these are just a bunch of one- or two-liners. No need for templates.
",1,13394871
13394968,"
If you may use boost, how about:
std::sort(vec_p2d.begin(), vec_p2d.end(), boost::bind( &Point2D::getX, _1 ) < boost::bind( &Point2D::getX, _2 ) );
&
std::sort(vec_p2d.begin(), vec_p2d.end(), boost::bind( &Point2D::getPt1, _1 ) < boost::bind( &Point2D::getPt1, _2 ) );?
",1,13394871
13392858,"
That's how I'd code it without STL (requires additional O(n) memory):
",2,13391695
13391740,"
Scan your array (sort first to optimize, but not needed), and generate an array of the struct below. Now sort the array of these structs, then regenerate your original array.
",4,13391695
13368976,"
Just use a suitable comparison object. For example, you could use
In case you wonder why I'm using a function object rather than a function pointer: The code in this function object can entirely be inlined. The call through a function pointer cannot.
",6,13368929
13368968,"
Your comparison function needs to consider all requirements for the comparison.
",3,13368929
13355548,"
You probably copied this line from somewhere without understanding what it really means:
Since you are using regular arrays, the first argument is a pointer to the first position in the array. The second argument is a pointer to one past the last element in the array. The third argument indicates in which direction the array should be sorted (in your case, you want to find the median, so the direction doesn't matter). For your array called numbers with a length of array_size, the new function call is rewritten as:
When passing arrays to functions, they decay into pointers on their own. So, you don't need to use the & operator. The function call can be simplified to:
The purpose for sorting the data in this situtation is to find the median. Regardless of sorting the array ascending or descending, the average of the middle element(s) will be the same. If you had further use for the array where it needs to be sorted in ascending order, change the third argument to std::less<int>() (or remove it completely). It will cause the array to be sorted in ascending order.
",1,13355447
13355506,"
",1,13355447
13355530,"
For std::sort(...) function please refer to http://www.cplusplus.com/reference/algorithm/sort/.
For your question, you are dealing with built-in type. The first overloaded version of std::sort which does not take an ""Compare"" parameter will suffice. And if you don't I think, you need to specify 'less' instead of ""greater""
",0,13355447
13327297,"
If you really mean that output order is irrelevant, then you want std::nth_element, rather than std::partial_sort, since it is generally somewhat faster. Note that std::nth_element puts the nth element in the right position, so you can do the following, which is 100% standard algorithm invocations (warning: not tested very well; fencepost error possibilities abound):
The function takes three iterators, like nth_element, where nth is an iterator to the nth element, which means that it is begin() + (n - 1)). 
Edit: Note that this is different from most STL algorithms, in that it is effectively an inclusive range. In particular, it is UB if nth == limit, since it is required that *nth be valid. Furthermore, there is no way to request the best 0 elements, just as there is no way to ask for the 0th element with std::nth_element. You might prefer it with a different interface; do feel free to do so.
Or you might call it like this, after requiring that 0 < k <= n:
It first uses nth_element to put the ""best"" k elements in positions 0..k-1, guaranteeing that the kth element (or one of them, anyway) is at position k-1. It then repartitions the elements preceding position k-1 so that the equal elements are at the end, and the elements following position k-1 so that the equal elements are at the beginning. Finally, it shuffles the equal elements.
nth_element is O(n); the two partition operations sum up to O(n); and random_shuffle is O(r) where r is the number of equal elements shuffled. I think that all sums up to O(n) so it's optimally scalable, but it may or may not be the fastest solution.

Note: You should use std::shuffle instead of std::random_shuffle, passing a uniform random number generator through to best_n. But I was too lazy to write all the boilerplate to do that and test it. Sorry.
",1,13323711
13323762,"
You want to partial_sort first. Then, while elements are not equal, return them. If you meet a sequence of equal elements which is larger than the remaining k, shuffle and return first k. Else return all and continue.
",3,13323711
13323922,"
Not fully understanding your issue, but if you it were me solving this issue (if I am reading it correctly) ... 
Since it appears you will have to traverse the given object anyway, you might as well build a copy of it for your results, sort it upon insert, and randomize your ""equal"" items as you insert.
In other words, copy the items from the given container into an STL list but overload the comparison operator to create a B-Tree, and if two items are equal on insert randomly choose to insert it before or after the current item.
This way it's optimally traversed (since it's a tree) and you get the random order of the items that are equal each time the list is built.
It's double the memory, but I was reading this as you didn't want to alter the original list. If you don't care about losing the original, delete each item from the original as you insert into your new list. The worst traversal will be the first time you call your function since the passed in list might be unsorted. But since you are replacing the list with your sorted copy, future runs should be much faster and you can pick a better pivot point for your tree by assigning the root node as the element at length() / 2.
Hope this is helpful, sounds like a neat project. :)
",2,13323711
13310943,"
Call that once, at the start of main. Having that in various methods means you'll get a lot of duplicate values.
That indeed compares pointer values, since the pointers don't necessarily point into the same array, with undefined behaviour (will probably compare virtual addresses). If you want to sort by value, you need to dereference
And in
you never consider the last element, that should be
for a proper bubble sort.
",2,13310164
13310773,"
Your bubble sort doesn't seem right to me.
It should resemble this:
Key differences:  

i goes from 0 to size-1, not 0 to size
j goes from i to size, not 1 to size-1
the if statement tests i and j, not j and j-1
the swap also swaps i and j, not j and j-1

Minor differences:

the vector is passed by reference instead of as a pointer. This probably doesn't really matter, but it looks cleaner to me at least.

Note that this will sort from largest to smallest. If you want it smallest to largest, your if statement should have a > sign instead.
",0,13310164
13280744,"
Mostly you need to define operator< for your class:
Once you've done that, std::sort will work fine:
",4,13280726
13280739,"
You can sort using the standard library std::sort from the '' header. You can either provide a comparator or define an less operators.
http://en.cppreference.com/w/cpp/algorithm/sort
",3,13280726
13280768,"
You should use std::priority_queue instead...  Otherwise you'll have to sort the queue every time you push something onto it.
Note that you still need to define operator<
",0,13280726
13280786,"
You want to implement a calendar queue. Don't use the queue data structure for that but a set:
There is no need to explicitly sort, the set will keep the contents sorted at all times and you can always remove the first by eraseing the begin() iterator.
",0,13280726
13275336,"
Is the else supposed to be there? It seems like the else { return false } line should just be removed and you could add return false after the entire loop...
Should be something like:
",3,13275255
13264902,"
Use sort from the standard <algorithm> header:
",4,13264809
13264954,"
You can still use your array with STL sort algorithm by adding a compare function:
",3,13264809
13248214,"
There's no off-the-shelf functionality to achieve this, but there are work-arounds. You can, for example, keep an array of user-defined structs that also contain the original position:
And then sort this using a custom comparator function that sorts by the value and not the original index.
",3,13248149
13248269,"
Try this out:
 If you want to convert to vector:
If you want to work on raw array:
",3,13248149
13248450,"
If you cannot modify what's stored in A, you could create an index array and sort it with a special predicate:
Then, either access sorted_A[i] as A[indices[i]], or re-arrange A according to indices. New position of i-th element of A is std::find(indices, indices+5, i) - indices.
",2,13248149
13248194,"
Now sort your container of ValueWithIndex. The information about original indexes will not
be lost.
",1,13248149
13248613,"
Ok, an index normally tells you what the nth sorted element of a vector is. But this is going to do the reverse, thus it will tell you that the nth element in your vector is the mth in sorted order.
This is being done by creating a vector of indices on your non-sorted vector. You can still create a sorted copy or an index, of course.
We start off with a predicate for which a < b if v[a] < v[b]
And now ""order"" will have the ordinal position in the ordered collection. 
Of course in C++11 the predicate could be written as a lambda expression rather than having to create the class PredByIndex.
We are not done yet though. We now have an index, not a ""find me in the sorted vector"". However we can transpose our index as follows:
}
Now our transposed index gives you what you want, and the transpose itself is O(N)
In a slightly different example of data, if the inputs are [ 5, 3, 11, 7, 2 ]
The ""sorted"" order is [ 2, 3, 5, 7, 11 ]
The ""index"" order is [4, 1, 0, 3, 2] i.e. element 4 is the smallest, then element 1 etc.
The ""transpose"" order, as we fill it in
This looks like what we want. Our original data 5 is position 2, 3 is position 1, 11 is position 4 etc in the sorted data.
",1,13248149
13248254,"
You can use find to search for the element:
and use the distance to show the index:
i1 and i2 now show the index in the corresponding array.
",0,13248149
13229306,"
Yes, this is because your implementation is incorrect. The inner loop should count backward from i-1 down to 0, and it should terminate as soon as it finds an element ioList[j] that is already smaller than ioList[i].
It is because of that termination criterion that the algorithm performs in O(n) time in the best case:
If the input list is already sorted, the inner loop will terminate immediately for any i, i.e. the number of computational steps performed ends up being proportional to the number of times the outer loop is performed, i.e. O(n).
",7,13229229
13229326,"
Your implementation of ""insertion sort"" is poor.
In your inner loop, you should not scan all the way up to i-1 swapping each element greater than ioList[i]. Instead, you should scan backwards from i-1 until you find the correct place to insert the new element (that is, until you find an element less than or equal to the new element), and insert it there. If the input is already sorted, then the correct insertion point is always found immediately, and so the inner loop does not execute i-1 times, it only executes once.
Your sort is also worse than insertion sort on average, since you always do i+1 operations for each iteration of the outer loop -- some of those ops are just a comparison, and some are a comparison followed by a swap. An insertion sort only needs to do on average half that, since for random/average input, the correct insertion point is half way through the initial sorted segment. It's also possible to avoid swaps, so that each operation is a comparison plus a copy.
",6,13229229
13222562,"
Your ""middle"" variable is being overwritten during the recursion because it is a class member instead of a local variable:
It would be better to declare middle as a local variable:
",1,13221246
13216927,"
This works perfectly:
",5,13216752
13204692,"
You don't really have a 2D array of students, which is (on the whole) a good thing.  You need to apply two separate sorting processes, and they can be applied quite independently.

You need to iterate through your list of students, sorting each of the lists of classes (one per student).  It is not clear how you know how many classes a given student is taking, but that's a problem for you to solve.  You can do this before or after (but not during) the other sort operation.  It is readily parallelizable if that was of interest; you could divide the list of students up amongst N threads, giving each thread a suitable set of students to work on.
You need to sort your overall list of students.  This operation will affect the entire array of students (or, at least, the populated part of it).  You will do this sort either before or after (but not during) the other sort operation.

You will need two separate sort functions — or, if you borrow the design of the Standard C function qsort(), you will two separate comparator functions and a single sort algorithm.
So, don't try to combine the two sort operations.  Do them separately.
",2,13204619
13203650,"
When comparing Class::title you forgot to add comparison to compare value:
Your line:
Should be:
I say you forgot - because you have this explicit comparison in your function to sort students.
Now explanation of your result: at first, just by chance - the classes for some student are sorted, but after that position of your student changes (this is bubble sort) and next sorting is done on these classes - so because actually you don't sort classes, but just changes its positions, you can have their original sequence in next step. 

As a bonus I advice not to use compare for sorting - just use operator <:
much simpler, isn't it?
",1,13201680
13187287,"
One solution would be to have a container with permanent iterators (such as list) as your main storage, and auxiliary containers of iterators for fast retrieval:
Now you can use the usual multiset iteration pattern to get the tools grouped by outcome ID.
Similarly, you can make an ordering for category and name:
",1,13187153
13186856,"
I debugged it for you.
The problem is in your stringToCharArray(string s, char c[]).
My index i arrived to 104 before getting ""segmentation fault"". Since all your strings have length 50 you are clearly going out of bounds.
Another problem is in srtstr that returns NULL, but this is related to the first problem.
A quick look to your sort_name and InsertItem didn't show up anything wrong, at least in the field of ""segmentation error"", since it's not so clear what you are trying to do, but at least you are performing the right index checks.
",3,13185809
13177144,"
To swap fish around when you are sorting you should write this
You are sorting based on the fish price, but it's the whole fish that should be sorted.
On your other question, there is no need for destructor in this code. Your fish class doesn't need to do any 'clean up' so it doesn't need a destructor.
",0,13176713
13178257,"
if you're looking to sort your array by a given element the STL container should be just fine, if not i would use this method
this is a common quicksort function used to sort an array. Just replace the right variables to represent your data E.g. T * elements becomes Fish * stuff, T t = Elements[first] becomes double price = stuff[first] and so on.
",0,13176713
13164128,"
From what I recall from Steve McConnell's Code Complete, your pseudocode should ideally look a lot more like English than it does.  You're jumping too quickly to implementation in my humble opinion.
What about this:
That's what I gather from your statement:

I'm looking to create an algorithm that takes an unsorted array,along
  with two integers(Lets say B AND C) and outputs TRUE, if A contains an
  element which is both greater than B and less than C, otherwise it
  returns FALSE.

",1,13164047
13164146,"
I'd start with a function to check the condition you care about: given a number, does it fall within a specified range:
From there, it becomes a simple matter of scanning through the array and calling the function, passing each element of the array as A (and the B and C that were supplied as B and C). If the function returns true at any point, you can stop scanning and the outer function returns true as well (for what it's worth, C++11 provides std::any_of for this kind of situation).
",1,13164047
13165412,"
You are just searching for an x inside the array that matches the criteria x > B && x < C. A linear search would do - if you are going do the search only once. If search has to be done multiple times (anything more than log (size of array)) then it makes sense to sort first and then do a binary search.
",0,13164047
13166033,"
Pseudocode:
Program Code:
",0,13164047
13147538,"
What happens here on the last iteration of the loop (i.e. when count is 9)?
",1,13147475
13146299,"
Iterator ranges should be expressed as an iterator referring to the first element, and an iterator referring to one-past-the-end.  If they are equal, this is an empty range.  You aren't doing that.
To fix this, the if(first+1==last) clause should just return.  The second mergesort(middle+1,last) call should be mergesort(middle,last).  pa should just equal middle-last.  pb is calculated correctly.  And I think the -1 in the last for loop should be removed.
Having a range defined by iterator to first and iterator to last is a bad idea.
",2,13145473
13145561,"
You should do
Actually, the end() iterator points an element after the end of the vector. It doesn't point to the last element of the vector.
",1,13145473
13141266,"
As suggested use an interface (pure virtual class)
Interface Method: 
Now when you want to sort you simple do the following:
Template Method:
This is used as follows:
",3,13141106
13141163,"
Sort should be an interface or an abstract class, whereas bubble / insertion / quick-sort should be implementations / concrete classes.
It's also worth learning about the following:
Strategy Pattern:

http://en.wikipedia.org/wiki/Strategy_pattern
and
State Pattern:

http://en.wikipedia.org/wiki/State_pattern
As for templates, I don't think it's worth it in your case.
",5,13141106
13142558,"
The right way to do this in C++ is via templates.
Sorting something is an algorithm, and it generally has little to no persistent state.  A sort isn't an object -- it is a function on data (which may be objects).
The std library already has a sort, with this signature:
The iterators begin and end denote a range of values to be sorted, and comp is a functor (or function) that when passed two elements of the range of values tells you if the first one is less than the second.
To use this on a std::vector, you'd do something like this:
The std::sort is (usually?) a quicksort.  But the interface works for quick, bubble and insertion sort.
The big advantage of this approach is that one sort can use another.  As an example, while a quicksort is faster on large data sets, often on small data sets the simplicity of insertion sort wins (lower constant factor, even with the n^2 overhead).  So by writing your sorts like this, quicksort's recursive calls can instead become insertion sort when the number of elements is small.
Now, if you need run-time substitution of which algorithm you are using, you'll need to pin down what iterators you are using, and maybe even what comparitor.  This can be done with either a common function signature (what I'd do), or a base class with a pure virtual interface (which I would advise against).  Note that the overhead for a run-time chosen comparitor is non-trivial, however.  The overhead from a fixed iterator choice, or from a pointer-to-function or virtual method call, so long as it isn't done in the recursive calls of your algorithm, will be pretty cheap for any reasonable sized container.
",2,13141106
13136876,"
Your comparator, or your dynamic list. need to change. You can throw out the template portion of the comparator and simply declare it as a CVParentList comparator:
and invoke your std::sort<> as you are doing without the template argument
You can also allocate the list, sort it, then downcast the list head when you're done:
But I really recommend the first option in your case.
",1,13135298
13135381,"
It could be that you need to pass const references to your functor, since a comparison should not change the objects being compared. Compilers may or may not require this. Change the functor signature to
",1,13135298
13114810,"
It's not correct for descending-order sort..
think about array = [2, 1], it output [1, 2]
You can make it correct by change j=0 to j=i+1
But it's correct for ascending-order sort.
Simple proof here:
Suppose after each step for output for loop we have a[0] <= a[1] <= ... <= a[i-1] <= a[i], we call this suppose_i
suppose_i is right when i = 0
If suppose_i is correct for 0 <= i < M <= N. When i = M, we have a[0] <= a[1] <= ... <= a[M - 2] <= a[M - 1]. After inner loop j from 0 to M, we got a[0] <= a[1] <= ... <= a[M - 2] <= a[M - 1] <= a[M]. When continue inner loop j from M+1 to N - 1, a[M] will become even larger. So suppose_i is also correct for i = M.
",1,13114773
13115298,"
Yes, it's correct. Proof can be constructed along the following lines.
Always when j-loop (the inner) completes (so j=n, i will be increased as next op), then a[i] is the max, and the part before a[i] is in ascending order (proofs below). So when the outer cycle is about to complete with i=n-1 then a[i] is max, and the items up to the index i are ordered (and since none of the preceding items is greater than max) so the whole array is ordered.
To prove that a[i] is always max after the j-loop is simple: i is not changing while the j-loop and if j encounters an item larger than a[i] then that is brought to a[i] and since j has scanned the whole array it's not possible that it includes an element larger than a[i].
To prove that the items up to i are ordered is full induction. We will use the above statement about a[i] being max.
For i=0 trivial (no preceding elements). a[0] is max and ""it is ordered"".
i=1 (just for fun): 1 item got to a[0] (don't care about its value, it cannot be greater than max), and a[1] is max. So a[0..1] sorted.
Now if the theses are satisfied after a j-loop ending at i=k then the following happens:
i <- k+1
Let's say the current item a[i]=q.
j scans a[] to k. Since k is the max it will be swapped to i. The items beyond i are not bothered yet. So essentially max moves up by one, so one item, particulaily q was added to the first part of the array. Let's see how:
The sorted part to max is scanned by j until it finds an item at index m that is larger than a[i]. (It will find a[i-1] in the worst case.) The items up to m are sorted. Now a[i] will be inserted here, an all items in the range [m..i-1] will be moved up by one. Since m is a right place to insert a[i] so a[0..i] will be ordered after the move. Now the only thing to prove is that the j-loop in [m..i] really performs a move:
At the beginning the sequence a[i],a[m..i-1] is ordered, thus every comparison in this interval will trigger a swap: a[i] is always the smallest in the a[j..i] part. The swap (i with j) will make the j-th to be at the right place (minimal item to the front) and j steps on to the remaining part of the interval.
So j reaches i=k+1 (no swap here) and a[k+1] is max so no more swaps in this j-loop, so at the end a[0..k+1] is sorted.
So finally if the theses hold for i=k then they hold for i=k+1 after a j-loop. We'we established that they hold for i=0 after 1 j-loop, and from i-loop shows that there will be altogether n j-loops so the theses hold for i=n-1 which is just what we've promised to prove in the firs paragraph.
",1,13114773
13112489,"
Taken straight from wikipedia:



Selection sort can be implemented as a stable sort. If, rather than swapping in step 2, the minimum value is inserted into the first position (that is, all intervening items moved down), the algorithm is stable. However, this modification either requires a data structure that supports efficient insertions or deletions, such as a linked list, or it leads to performing Θ(n2) writes.



So basically you do have a stable sort, since you are always swapping a value that is less then the minimum value (as opposed to less then or EQUAL to the value).
",0,13112417
13112445,"
Your implementation is not stable. At each iteration, you take the element at position i in the array and put it at an arbitrary position in the remaining array, so you mess up the original order.
If you want a stable sort you have to:

Choose the minimum element fro the remaining list as you already do
Insert it at place i without swapping. This means moving the remaining elements to the right to make space for the ith element you are placing.

This ensures elements with the same value are placed in the same order in the sorted array and in the original array.
(Thanks to Groo in comments for pointing out mistakes)
",0,13112417
13072669,"
You can do this in three ways:
1) Overload the < operator, and call std::sort algorithm. The code will look like this:
The first way is wrong, as you can't overload the < operator in pointers.
2) Create a compare function, and then call the second version of std::sort. The code looks like this:
3) Create a compare class, which has it's () operator overloaded, and then call the third verion of std::sort. The code:
Note: the sort function is found at the algorithm header file.
",0,13072530
13072552,"
You'll need to provide a custom comparator class or function to the std::sort method to make it not sort by addresses.
where comp can be defined as:
and call sort as:
or
That, or don't keep pointers in the vector. From the code you posted, it's not clear that you actually need pointers:
should be enough.
",4,13072530
13059931,"
Your sort function should return when a < b, not a != b.  
Also, by default, std::vector<> should already support lexicographic comparison via operator<, which should do what you're expecting (compare each element in turn, with the first non-equivalent elements used for the comparison).   See http://en.cppreference.com/w/cpp/container/vector/operator_cmp
Your current sortPerms function looks like what you would pass to std::unique, but that has different behavior than a predicate used for std::sort.
",3,13059878
13008548,"
Your destructor is being called on temporary objects:
You need to respect the Rule of Five, either by writing a copy constructor, move constructor, copy assignment operator and move assignment operator, or by replacing shape with a managed container e.g. std::vector<std::vector<int>>.
",2,13008300
12947189,"
Then just iterator over stocks.
",1,12946867
12946907,"
To remove duplicates, please look at http://www.cplusplus.com/reference/stl/set/ . This container only stores ""Unique"" values. Hence it will remove the duplicates. 
",1,12946867
12943135,"
I promise you every one that is known as a good programmer today read books from those date( or even before that ), so I don't think that it hurt you, since it is about concepts and concepts never change dramatically, but if you can find a newer book it will be awesome!
",2,12943071
12943184,"
You should get a new book, but that doesn't mean your current book is necessarily harmful.
The C++ language is defined by a Standard, which is written by an international committee.  Compilers implement this Standard to varying degrees, but they all follow the C++ Standard more or less.
Since 1998, there have been not one but two new Standards produced -- one in 2003 (often called C++03), and one just recently in 2011 (C++11).  The fundamental idioms that existed in 1998 are still relevant today, so learning those is still important.  But there have been substantial changes to the Standard Library, including the parts of the Standard Library that many people (mistakenly) refer to as the ""STL"".  There has been refinement to many of the idioms known in 1998 as our experience with the language grows, and there are new idioms possible in C++11 that weren't possible in 1998.
There is an excellent Wikipedia article that enumerates many of the differences between C++11 and C++03, and there are even more differences in C++ from 1998.
Here is one new book that I have been reading. The C++ Standard Library: A Tutorial and Reference (2nd Edition)
",2,12943071
12927842,"
Try sorting the linked-list like you are sorting an integer array. Instead of swapping the nodes, swap the contents inside the nodes.
",1,12927790
12928533,"
If you don't care about efficiency you can use any sorting algorithm. What's different between linked lists and arrays is that the swap operation, to swap the position of two elements while sorting, will be a lot slower because it has to run through the links of the list.
An O(n²) bubble sort is easy to implement with a linked list since it only swaps an element with its neighbor.
If you care about efficiency you can look into implementing the merge sort algorithm even if it's a little more complicated.
",1,12927790
12928234,"
You should insert like this
No need of rear pointer..just check if list->next is null,if yes you are at the end
and your sorthour function should be
",0,12927790
12924705,"
I would post this as a comment, because I am afraid I might be missing something,  but I can't yet do this, so here goes a non-answer:
What keeps you from using the std::list? You can insert a word, check if it is non-empty, immediately apply a the standard sorting algorithm (It relies on the comparison operators of the sorted objects) and print it. It is fast, your code is short and readable and you don't spend your time reinventing the wheel.
PS: If you want to test for an empty string it should be """", not "" "" , I think.
",1,12924551
12924811,"
I think there is a number of issues here.  
For one in the initial iteration what is prevPtr->data pointing at?  If it's pointing at nothing or hasn't been allocated to any memory you shouldn't be setting this to anything yet.  
Plus you need to allocate memory for newPtr on every iteration, otherwise you are just writing over the memory location of where it is pointing to last from the in the list.
Second lets assume that prevPtr is pointing to something, on the second iteration (or more) of this while loop prevPtr has been moved farther down the list (prevPtr = nextPtr) which would cause prevPtr->data = "" "" to erase any data in that element.  So you could be printing the first node plus a bunch of spaces afterwards.
Third you should check if list is NULL first in your loop, because if loop is NULL, nextPtr->data would be pointing at junk which is not good.  This NULL check on list could be your corner case of the first element.
Try something like this, I didn't have time to test it but it should get going in the right direction:
",0,12924551
25985180,"
I guess you could use the shell extension to persist the current sort order of all windows explorer sessions to disk when they changed, with timestamps. Then you read that data into your app when needed to decide how the UI is rendered.
",0,14401016
14372713,"
In C++:
",1,14372447
14372461,"
You also have qsort, std::sort with examples of usage.
",2,14372447
14372786,"
I think what you should do is to create a utility 1-D array of pointers into the 1st dimension of your array and provide a custom comparison function to sort the utility array. Then you can do pointer math to create a sorted copy of the array (and overwrite the original array if necessary using memcpy)
",0,14372447
14376350,"

Create an array to save the numbers like this:  
int array[5] = {80,100,70,50,120};

2.Create an function to compare two elems:
3.Use library function sort() :
4.Now the array had been sort by ASC correctly.
",0,14372447
14376502,"
And there are so many types of sort like this:
",0,14372447
14369651,"
Do you mean to increment i twice, once in your for statement, once at the end of your loop? If you did, you really should modify your code so you're only doing it in one place.
",4,14369558
14348615,"
Use std::partial_sort with reverse iterators.
For example:
",12,14348602
14349307,"
Another possibility instead of partial_sort with reverse iterators and std::greater for the comparison would be to use std::nth_element to partition the collection, then std::sort to sort the partition you care about:
",5,14348602
14306855,"
You need a strict-weak ordering. Your function for ordering must return false when called with equal strings. If you compare with <=, it doesn't work. BTW: I believe that some standard library implementations have a diagnostic mode that could have caught this error for you. Use this, as there are enough ropes in C++ that you can shoot yourself in the foot with.
",3,14306682
14304148,"
Here the object is copied, and its copy is pushed into a container:
Here you modify the original object, but the copy in the container is unchanged:
",5,14304118
14268560,"
",0,14268504
14260030,"
Add:
as stated in the std::sort() reference page.
See Using std Namespace, Why is ""using namespace std"" considered bad practice? and many other questions on SO discussing using namespace std;.
",33,14259993
14187193,"
Attach a debugger. 
Or if you don't want to do that, print out L just before this and re run.
And see what you're getting.  It's presumably something unexpected.  Then look at how that value is being passed in in the recursive calls, and see what's causing you to get a bad value.  I'd wager you're incrementing off the end of the array in one or more directions.
",1,14186270
14198856,"
something like the above is a viable approach.  I wrote a bunch of it in C++11, but included comments on how to strip out the extra C++11 stuff (it actually simplifies the code in some cases, but removes the ability to handle some container-like things).
The basic idea is to sort a vector of iterators into your original container.  Then we create a temporary container, stuff trivial value_types into it, swap those trivial value_types with the correct data from the original container (as determined by the vector of sorted iterators), then swap this temporary container for our original container.
There is lots of allocation, but hopefully of cheap stuff.
For this to work, the data you are sorting needs be trivial constructable.  For this to be efficient, the data you are working with when trivially constructed needs to be cheap, and swap needs to be efficient.
I attempted to make this as ADL friendly as I can, because I find that to be good practice.
",2,14178513
15039451,"
Heap-sort is a swap-only sort which is not stable (the order of equivalent elements may change during the sorting). I answered an other similar question where I implemented the heap-sort myself (PasteBin), but you may find better and more flexible implementations out there.
The conclusion was that g++'s std::sort used 35 copy, 19 assignment, 10 swap and 35 delete (99 operations altogether) for 20 elements, my heap sort used 62 swaps and nothing else.
I just bumped into a stable sort which uses only swap here on stackoverflow. I did not look into it deeper.
",1,14178513
14170146,"
It really depend how often you are going to modify the data in the map and how often you're just going to be searching for the std::string and grabbing the vector.
If your access pattern is add map entry then fill all entries in the vector then access the next, fill all entries in the vector, etc.  Then randomly access the map for the vector afterwards then .. no map is probably not the best container.  You'd be better off using a vector containing a standard pair of the string and the vector, then sort it once everything has been added.
In fact organising it as above is probably the most efficient way of setting it up (I admit this is not always possible however).  Furthermore it would be highly advisable to use some sort of hash value in place of the std::string as a hash compare is many times faster than a string compare.  You also have the string stored in Foo anyway.
map will, however, work but it really depends on exactly what you are trying to do.
",1,14170058
14148201,"
Suppose you have an array of two equal elements. Then i == right, and you sort exactly the same array again and again, and again...
When your array contains multiple elements, that is very likely to happen at some point.
Another point of failure for repeated elements is exemplified by
The pivot is the 4 at index 2, after the first scans i == 0 and j == 2, the two 4s are swapped, i is incremented, j decremented, so now i == j == 1, and the loop stops.
The recursive calls then sort { 4, 8 } resp { 4, 5, 6}, and the result is not sorted correctly.
You can avoid that problem by replacing at least one of the scan conditions with arr[i] <= pivot resp. arr[j] >= pivot, but then you need to guard against running off the array (when the pivot is the largest or smallest element), best by including the condition i < j there.
If you in- resp. decrement the indices upon swapping,
you always have the problem that the last swap may occur in a situation
leading to i == j pointing to y, and you have no information about how y compares to the pivot.
So then you need to inspect y and handle the different possibilities.
But your implementation also is notcorrect without repeated elements; consider
First, i is incremented until it points at the pivot, j stays pointing at the 2. These two are swapped, i is incremented, j decremented, so now the situation has become
arr[i] > pivot, and arr[j] < pivot, so swap, increment i, decrement j:
Now j < i, so the loop stops, but the recursive calls are to quicksort(arr, 0, 5); and quicksort(arr, 6, 6);, so the last element in the ""sorted"" array is not the largest element in the array.
",4,14148146
14148179,"
You don't have a fallback if left == right. If you don't have a catch the code will not execute anything.
",0,14148146
14131510,"
The default std::sort comparison function is simply comparing pointers (memory addresses) with the < operator.  It's not actually lexicographically comparing the C-strings.  You need to create a custom comparison function which compares the strings lexicographically by e.g. calling std::strcmp
",5,14131491
14131521,"
The problem is simple: You're using the default comparison, which will just compare the pointer values. Usually these will have ascending addresses, so you won't see any change.
You'll have to write your own comparison function:
",3,14131491
14131513,"
Maybe because the default comparator for const char * is comparing pointer values (and the string constants happen to be allocated in the array order already)?
Use std::string.
",2,14131491
14111856,"
Yes. That is definitely possible. You could know that just by writing some sample code, such as this:
By the way, you should avoid using c-style arrays, and should prefer using std::array or std::vector. 
std::array is used when you know the size at compile-time itself, while std::vector is used when you need dynamic array whose size will be known at runtime.
",8,14111841
14111865,"
Yes:
See http://ideone.com/0TkfDn for a working demo.
",5,14111841
14111907,"
The proper way is, of course, to use std::begin() and std::end():
If you don't have a C++ 2011 compiler, you can implement corresponding begin() and end() functions, e.g.:
",3,14111841
46745376,"
Answers using sizeof(charArray) assume that the array must be completely filled. When ran using partially filled array, they produce garbage results.
In that case use:
",0,14111841
14095521,"
While solving the compiler error simply requires the operator() to be public as according to most other answers to this question, you should note that your comparator isn't a valid strict comparator. A strict comparator has to return false for elements which are treated as being equal. You should also use const references instead of values for the parameter types of your comparator.
I want to present you multiple options to solve your problem (not the compiler-error but the original problem, sorting a string in reversed lexical order). All of them return false for two equal elements.
The first option is your solution but I fixed the strictness:
The second option uses C++11's lambda function, but is essentially the same:
As a third option, as first proposed by Mooning Duck, you could simply use the std functor for operator> on your type char:
The fourth option (the simplest one) would be to use the default comparator on the reversed string, as first proposed by Peter Wood (note the r!):
",9,14095450
14095504,"
Usually, only the first error is relevant, so we have this:
Most of that is simply context, so here's the key part:
Well that's easy to fix:
This compiles fine, however, sorts are based on what's called a ""strict weak ordering"", and !(l < r) is not a strict weak ordering.  Namely, comparitor(a,a) should return false, but yours returns true.  Luckily, the idea of sorting this way is already in the standard library under the name std::greater.  (std::sort without a comparitor uses std::less by default)
",6,14095450
14095525,"
Using std::sort() is clearly the right approach. The default comparator is std::less<value_type> where value_type is decltype(*it) for the type of the iterators passed. To change the default you'd just pass a different comparator, e.g. std::greater<char>.
To use your ReverseComparator as it is defined you'd need to instantiate it correctly:
Of course, to make it work you'd need to make the operator()() publically accessible. You might want to make it a const member function as well:
Note that the expression in the operator is changed as well: using !(lhs < rhs) doesn't define a strict weak order: comparator(x, x) would yield true but it is required to yield false.
",2,14095450
14081355,"
That's so simple:
Then:
Students will be sorted alphabatically. If two students have the same name, they will be  ordered using their grade.
",14,14081335
14102214,"
Try to override operator like ""<"", "">"" using the same properties of the objects. After that you can redefine some sort operation.
",-1,14081335
14060050,"

A vector<double> is expensive to copy, so e.g. copying both intVec and
  matrix to a vector<pair<int, vector<double> >, sorting that and
  copying them back is even more inefficient than usual.

The simplest way to get the optimization you want then is to swap the elements of the source vector<vector<double>> into the temporary vector<pair<int, vector<double>>, sort it, and then swap them back to their new locations in the original vector.
There will still be more overhead than is strictly necessary (for example to construct and destroy empty vectors). However, no vector is ever copied and the code remains very similar to what you already have. So if you are correct that the problem is the cost of copying, problem solved.
In C++11 you could move in both directions rather than swapping. I doubt there's much performance difference between moving and swapping with an empty vector, but I'm not sure there isn't.
",4,14059438
14059668,"
One option: create a std::vector<std::pair<int,size_t>> where the first element is the int from intVec and the second element is the original index of that element.  Then sort that new vector.  Then shuffle your matrix and intVec to the order indicated by the second elements of the pairs (e.g., with a single pass, doing swaps).
",1,14059438
14059631,"
Based on the space between your two >'s, I'm guessing you're using pre-C++11 C++.  In C++11, std::sort seems to move elements whenever possible instead of copying.
You can pass a custom comparator to std::sort.  However, even if you do this, you're doing Theta(n log n) copies of pair<int, vector<double> >'s.
I'd guess, based on not actually trying it, that you should sort a pair<int, vector<double> *> (or pair<int, int> if int is big enough), using the second int as an index) instead to get the appropriate permutation and then apply the permutation using vector's swap member function to avoid copying the vector contents.
",1,14059438
14059568,"
If you don't want to copy the vector<double> item vector, then make a vector of pointer or indices to the vector<double> items. Sort it along with the main vector.
It is however not at all clear that you'll get a performance gain, and so I suggest that you measure both the straightforward sorting and the smart sorting, and compare.

Example:
",0,14059438
14059986,"
The obvious answer is to restructure your two vectors as one vector<pair<int, vector<double> > (since the data are clearly tightly coupled aready).
If that's really not an option then create another vector of indexes and sort that instead of the vec and matrix.
",0,14059438
14060169,"
Since std::vector::swap operates in constant time, you could use a sorting algorithm that operates via a series of swaps (like quicksort) to sort intVec while simultaneously performing identical swaps on matrix:
",0,14059438
14061031,"
I'm pretty sure that --- when you use some up to date compiler (let's say gcc 4.4 and up) --- there nothing really copied: nowadays objects within C++ standard library containers are (mostly) always moved.  Therefore IMHO there is no need to have any fear about expensive copies.
Have a look at the following example - it was written using gcc 4.4.6 under Debian.  As you can see, during the 'reordering' phase, there is no call to the copy constructor and also no call to the `operator=(... & other)'.
Output:
",0,14059438
14025890,"
You have a hard question, where the answer requires quite a bit of knowledge about your system.  Without that knowledge, no answer I can give would be complete.  However, 15 years of embedded design has taught me the following:

You are correct, you generally don't want to allocate objects during runtime.  Preallocate all the objects, and move them to active/inactive queues.
Keeping things sorted is generally hard.  Perhaps you don't need to.  You don't mention it, but I'll bet you really just need to keep your Objects in ""used"" and ""free"" pools, and you're using the index to quickly find/delete Objects.

I propose the following solution.  Change your object to the following:
And use your Objects:
Edited to fix a small glitch.  Should work now, although not tested.  :)
",1,14025663
14025757,"
The overhead of a std::vector is very small. The problem you can have is that dynamic resizing will allocate more memory than needed. However, as you have 50 elements, this shouldn't be a problem at all. Give it a try, and change it only if you see a strong impact.
If you cannot/do not want to remove unused objects from a std::vector, you can maybe add a boolean to your Object that indicates if it is active? This won't require more memory than using activeObjectIndex (maybe even less depending on alignment issues).
To sort the data with a boolean (not active at the end), write a function : 
If you want to sort using activeObjectIndex it will be more complicated.
If you want to use a structure that is always ordered, use std::set. However it will require more memory (but for 50 elements, it won't be an issue).
Ideally, implement the following function :
This will allow to use directly std::sort(objectList.begin(), objectList.end()) or declare an std::set that will stay sorted.
",1,14025663
14025799,"
One way to keep track of active / inactive is to have the active Objects be on a doubly linked list.  When an object goes from inactive to active then add to the list, and active to inactive remove from the list.  You can add these to Object
so this does not require memory allocation.
",1,14025663
14025800,"
If no dynamic memory allocation is allowed, I would use simple c-array or std::array and an index, which points into last+1 object. Objects are always kept in sorted order. 
Addition is done by inserting new object into correct position of sorted list. To find insert position lower_bound or find_if can be used. For 50 element, second probably will be faster.  Removal is similar.  
",1,14025663
14025825,"
You should not worry about having the list sorted, as writing a method to search in a list of indices what are the ones active would be O(N), and, in your particular case, amortized to O(1), as your array seems to be small enough for this little extra verification.
You could maintain the index of the last element checked, until it reaches the limit:
However, if you really want to have a side index, you can simply double the size of the array, creating a double linked list to the elements:
",1,14025663
14019564,"
Yes, it can be done this way. Your comparator would need to be an object that contains a mapping from the elements in b to the corresponding element in a, which you could use determine the ordering.
",1,14019516
14019594,"
You will have to implement compare so that it, given two elements in b, compares the corresponding elements in a. You can figure out what index something is by taking int index = element - b; where element is one of your items in the compare function. 
I would seriously suggest using pair<> or a struct/class to hold your a, b values at the same time - saves on time as well. 
",0,14019516
14003974,"
In this bit of code:
You are checking only that cur != NULL, then dereferencing cur->next. cur->next could be NULL.
temp and cur both seem to be pointing at the same node. Perhaps you intended one to be ahead of the other, in order that you have a pointer to the previous node for inserting?
Here's an (untested) implementation:
",1,14003899
13997644,"
Your call to sort looks wrong to me (though you never said what a is).  It should be sort(table, table+row, compare_function)
But I'd do it a bit differently anyway (std::lexicographical_compare comes from <algorithm>):
And use it like:
",0,13997083
13997129,"
Change your compare function to:
",0,13997083
14053989,"
Don't use struct, use class instead.
I don't think string supports <, so I used compare instead.
Since you only have a single-linked-list, not double-linked (only next variable, not previous as well), sort needs to take a **, or you need to compare ->next and ->next->next and have a blank head item.
Change sort_by_last(organizer); to sort_by_last(&head_ptr);
The sort function will look something like (assuming you want to do insertion sort, which is slow but simple): (untested)
I assume you have to use a linked-list, but std::set would be a much simpler solution (it sorts on insert).
",0,13996605
13981215,"
Sort already sorts in ascending order, so all you need is
The code you posted would sort in descending order, and would work as is, but you must #include <functional>:
",9,13981194
13981287,"
What you have now is is already correct. (Assuming it properly expresses your intent. Do you need ascending or descending sort order?).
The error message you are getting is probably caused by your forgetting to include some header file. It just happened that implementation of some important part of the algorithm (std::greater?) got included only partially, for std::string, but not for the general case.
Make sure you included <vector>, <algorithm> and <functional>, the latter being the most likely candidate for the missing header. Did you include <functional>?
",2,13981194
13981991,"
By default, std::sort will put them into ascending order.
If you want them descending, iterate backwards over the container:
",1,13981194
13937495,"
If you just want to sort the portion you have filled, use
",2,13937376
13937437,"
Could you be a little bit more specific in that what you want to achieve ? you can provide your own comparison operator when sorting
For more info read the manual
http://www.cplusplus.com/reference/algorithm/sort/
",0,13937376
13937441,"
Well they're not null values. They are 0, which is a perfectly valid number to sort. If you only want 2 rows, only add two rows. Just do int n = 2 instead of 4.
With the information you've given though, you could of course do:
This will only sort the first two rows.
",0,13937376
13937472,"
An int in C++ is never NULL. If you do the following:
The value of val is 0, which is indistinguishable from any other int whose value is 0. If you really will have those NULL ""holes"" in your multidimensional vector that you want to be ignored I suggest using a Nullable<int>.
",0,13937376
13928534,"
If you had C++11 you should try something along these lines.
I'm not a super pro in C++11 lambda syntax, but you should get the idea. If you don't have C++11 you can always roll out your own comparison functor.
",1,13928457
13928635,"
The non-lambda method of doing this would be something like:
",2,13928457
13924866,"
When std::sort is called on a container of elements of type T, the comparison function needs to receive arguments of type T or const T&. In this case, you have a 2-dimensional array, so the type of elements is a 1-dimensional array int[10]. Since 1-dimensional arrays decay to pointers, compare can be:
or equivalently:
This will fix the error you got, but your code still won't work: std::sort needs the container elements to be assignable (or movable in C++11), but arrays are not assignable.
You can use std::vector<std::vector<int> > instead as people have suggested. Note that your fear of performance problems is misguided: Even if sorting a two-dimensional array was possible, it would involve a lot of copying of one-dimensional arrays which would take a long time. Swapping vectors, on the other hand, is done by simply swapping pointers which is faster. In general, you should not make assumptions about performance if you haven't tested it first.
",2,13924120
13924873,"
The comparison function doesn't get an iterator to the element passed but the dereferenced iterator, i.e., the value type. Thus, your comparison function would need to be declared as like the one below:
You can verify that you can actually call it with array iterators:
However, this won't make it possible to sort you arrays: built-in arrays are not copy-assignable. The easiest way to sort statically sized arrays (where the outer dimension flexible) is to use std::array<T, N>:
",1,13924120
13924572,"
I say, if we're gonna use the STL and C++ .. lets write it in a modern style and really use the STL.
My attempt at the problem using modern c++11:
It uses accumulate to sum each sub array, and sorts on the sum .. it's super inefficient because it has to sum the same row multiple times .. but it's just there to show off a custom compare function.

As an exercise, I wrote this version that uses async to distribute the summing part over any available cores to do the summing, before the sort. I'm sorry it's getting a bit off topic. I hope it's still useful to some people:
It needs to be compiled with pthread library or similar:
g++ -O6 sort.cpp --std=c++11 -g -lpthread
",1,13924120
13898735,"
Standard library sort uses a user-supplied comparison function, so you can insert a comparison counter into it. The total number of comparisons for either quicksort/introsort or mergesort will be very close to log2N * N (where N is the number of elements in the vector). So that's what I'd export to a progress bar: number of comparisons / N*log2N
Since you're using mergesort, the comparison count will be a very precise measure of progress. It might be slightly non-linear if the implementation spends time permuting the vector between comparison runs, but I doubt your users will see the non-linearity (and anyway, we're all used to inaccurate non-linear progress bars :) ).
Quicksort/introsort would show more variance, depending on the nature of the data, but even in that case it's better than nothing, and you could always add a fudge factor on the basis of experience.
A simple counter in your compare class will cost you practically nothing. Personally I wouldn't even bother locking it (the locks would hurt performance); it's unlikely to get into an inconsistent state, and anyway the progress bar won't go start radiating lizards just because it gets an inconsistent progress number.
",6,13898675
13898778,"
Split the vector into several equal sections, the quantity depending upon the granularity of progress reporting you desire.  Sort each section seperately.  Then start merging with std::merge.  You can report your progress after sorting each section, and after each merge.  You'll need to experiment to determine how much percentage the sorting of the sections should be counted compared to the mergings.
Edit:
I did some experiments of my own and found the merging to be insignificant compared to the sorting, and this is the function I came up with:
",1,13898675
13898751,"
Stable sort is based on merge sort. If you wrote your own version of merge sort then (ignoring some speed-up tricks) you would see that it consists of log N passes. Each pass starts with 2^k sorted lists and produces 2^(k-1) lists, with the sort finished when it merges two lists into one. So you could use the value of k as an indication of progress.
If you were going to run experiments, you might instrument the comparison object to count the number of comparisons made and try and see if the number of comparisons made is some reasonably predictable multiple of n log n. Then you could keep track of progress by counting the number of comparisons done.
(Note that with the C++ stable sort, you have to hope that it finds enough store to hold a copy of the data. Otherwise the cost goes from N log N to perhaps N (log N)^2 and your predictions will be far too optimistic).
",0,13898675
13898798,"
Select a small subset of indices and count inversions. You know its maximal value, and you know when you are done the value is zero. So, you can use this value as a ""progressor"". You can think of it as a measure of entropy.
",0,13898675
13898730,"
Easiest way to do it: sort a small vector and extrapolate the time assuming O(n log n) complexity.
t(n) = C * n * log(n) ⇒ t(n1) / t(n2) = n1/n2 * log(n1)/log(n2)
If sorting 10 elements takes 1 μs, then 100 elements will take 1 μs * 100/10 * log(100)/log(10) = 20 μs.
",0,13898675
13904768,"
Quicksort is basically 

partition input using a pivot element 
sort smallest part recursively
sort largest part using tail recursion

All the work is done in the partition step. You could do the outer partition directly and then report progress as the smallest part is done.
So there would be an additional step between 2 and 3 above.

Update progressor

Here is some code.
",0,13898675
13859302,"
For a C answer, the following is a replacement for strcasecmp().  This function recurses to handle strings that contain alternating numeric and non-numeric substrings. You can use it with qsort():
Notes:

Windows needs stricmp() rather than the Unix equivalent strcasecmp(). 
The above code will (obviously) give incorrect results if the numbers are really big.
Leading zeros are ignored here. In my area, this is a feature, not a bug: we usually want UAL0123 to match UAL123. But this may or may not be what you require.
See also Sort on a string that may contain a number and How to implement a natural sort algorithm in c++?, although the answers there, or in their links, are certainly long and rambling compared with the above code, by about a factor of at least four. 

",6,13856975
13857078,"
What you want to do is perform ""Natural Sort"". Here is a blog post about it, explaining implementation in python I believe. Here is a perl module that accomplishes it. There also seems to be a similar question at How to implement a natural sort algorithm in c++?
",5,13856975
13857205,"
Natural sorting is the way that you must take here . I have a working code for my scenario. You probably can make use of it by altering it according to your needs :
",5,13856975
13896337,"
Taking into account that this has a c++ tag, you could elaborate on @Joseph Quinsey's answer and create a natural_less function to be passed to the standard library.
I took the time to write some working code as an exercise
https://github.com/kennethlaskoski/natural_less
",5,13856975
33495791,"
Modifying this answer:
toUpper() function:
Usage:
",3,13856975
13857452,"
Your problem is that you have an interpretation behind parts of the file name.
In lexicographical order, Slide1 is before Slide10 which is before Slide5. 
You expect Slide5 before Slide10 as you have an interpretation of the substrings 5 and 10 (as integers). 
You will run into more problems, if you had the
name of the month in the filename, and would expect them to be ordered by date (i.e. January comes before August). You will need to adjust your sorting to this interpretation (and the ""natural"" order will depend on your interpretation, there is no generic solution).
Another approach is to format the filenames in a way that your sorting and the lexicographical order agree. In your case, you would use leading zeroes and a fixed length for the number. So Slide1 becomes Slide01, and then you will see that sorting them lexicographically will yield the result you would like to have.
However, often you cannot influence the output of an application, and thus cannot enforce your format directly. 
What I do in those cases: write a little script/function that renames the file to a proper format, and then use standard sorting algorithms to sort them. The advantage of this is that you do not need to adapt your sorting, and can use existing software for the sorting.
On the downside, there are situations where this is not feasible (as filenames need to be fixed).
",0,13856975
13852072,"
You can't pass a member function directly as the comparator. When you use a function, what's actually passed is a pointer to the function -- but a pointer to a function is entirely different from a pointer to a member function.
C++98/03 has a couple of adapters named mem_fun and mem_fun_ref that (sort of) deal with this.
C++11 adds mem_fn and deprecates mem_fun and mem_fun_ref. It's quite a bit easier to use, assuming you have a compiler new enough to include it.
If your compiler is that new, however, it'll probably also include lambdas, which can make the task considerably cleaner, because you can us an ""in place"" definition of a function object to handle the comparison:
If you Google for something like ""C++11 lambda"" you should find quite a bit more information about this (much of which will almost certainly lead directly back here to SO).
",3,13851980
13852074,"
Also, you almost certainly want to pass the pairs to your sort function by const reference instead of by value.
and typedef is your friend.
",2,13851980
13852395,"
If you are sorting a std::list you should be using the std::list::sort member function. The std::sort algorithm requires random access iterators and std::list only provides bidrectional iterators.
",1,13851980
13849943,"
It seems that the algorithm has quadratic behavior: if x[0] is the largest value in the sequence tj stays 0 and you get up to ci iterations internally. Did you mean to use x[inds[0]] and x[inds[j]]?
",0,13849845
13843602,"
I had a similar problem to sorting a file by the second data type, i would give code but this seems to be a homework problem, so here is an explanation of how i solved it:

read the line into a string
iterate to the second number by skipping to the next space
grab the second number from the string and place it in a separate string, then atoi() the string to get an integer
sort the string using the integer in a sort function then call the function in std::sort of qsort()

",0,13843199
13831185,"
Your comparison function is broken. You cannot have a predicate that returns true for both u1 < u2 and u2 < u1. 
Replace the return statement with return u1 < u2; if you just need something for a quick test. 
Also, are you sure you need to use a vector? Unless you need the pointers to be stored in contiguous memory, you'd be better off using an std::set instead with an appropriate comparator. The set will keep the elements ordered after every insertion / deletion.
Also, since you're using raw pointers, if you're allocating the objects using new make sure you delete before removing elements from the container. Better yet, use an std::set<std::unique_ptr<Upgrade>, CostBenefitUpgradeOrder> instead and not have to worry about deleting the allocated memory.
",7,13831113
13831172,"
You need to pass ""strict weak ordering"" (less than) operator to the  std::sort method, and that operator must be ""valid"". 
Valid operator< have the following properties:

For all , it is not the case that  <  (irreflexivity). For all ,
, if  <  then it is not the case that y < x (asymmetric). For all
, , and , if  <  and  <  then  <  (transitivity). For all ,
, and , if  is incomparable with , and  is incomparable with , then  is incomparable with  (transitivity of incomparability).

You can see that your operator fails on the first point (CostBenefitUpgradeOrder(x, x) == true, in your case) (and on most other points, as well).
",5,13831113
13824177,"
There are two errors here. First, the compareAlbums function needs to be a free function, not a member function of the Album class. Second, the compareAlbums function must take const-references to Album objects, since that is what you store in your vector. So, this should fix it:
",3,13824041
13824146,"
You've tried to sort a std::vector using a function that takes pointers as arguments. The comparison function is given references to its arguments, not pointers.
The immediate problem should be fixed simply by taking the comparison function and adjusting it from
to
",1,13824041
13805667,"
Have a look on how you sort your second vector:
You are inserting the wrong end index, it should be pdb_**b**_list.end(), thus the segfault.
",3,13805625
13801390,"
The problem is that your cmp method needs to be static. The reason is that non-static methods expect an invisible first argument, the this pointer. The std::sort function do not pass this extra argument.
Since you reference member variables you can't make the function static, but there are other ways to solve this. I recommend using a new C++11 standard functionality, std::bind:
The std::bind call creates a callable object, setting the first parameter to this so it will be correct when being called.
",4,13801311
13790585,"
Well, the problem lies here : 
Change it to 
And it will work. I think you know the reason.
For the partition function to work correctly, you must supply 2 things :   
1) The array to work on.
  2) The number of elements it has, the size.
The problem lies in the first recursive call to partition the left subarray:  partition(a,right-1) 
The argument 2, the  size, is incorrectly specified to be right-1, when it is actually right.   
This can be worked out by using the fact that the number of elements in an array from an index a to b ( both included,b>=a) are  N= b-a+1.
Here, we have a=0, b=right-1, thus the number of elements in the left sub array, the size, N=(right-1)-(0)+1=right. 
Thus the  to work correctly, you must call it like partition(a,right);. 
The left sub array ends at right-1, but it has right-1+1=right elements. 
Happens all the time :)
",2,13790369
13790492,"
You are missing a case where there is an element in the array which is the pivot, in the partition function.
Assume arr = { 5, 5, 1 , 1, 5, } 
Next iteration, the same scenario will repeat itself, and you will actually get an infinite loop.
One way to deal with it is to determine that the ""big"" part will also increase all elements that are exactly the pivot, and swap elements if arr[right] < pivot (not <=), and decrease right if arr[right] >= pivot (not >), something like:
",2,13790369
13782364,"
You more or less answered your own question. You probably want to do something like this:
",2,13782209
29802298,"
here is another option, little bit more similar to the original one 
",2,13782209
13775827,"
I don't know which external sort you (or the interviewer) meant, but
my suggestion is a 10-way (in your case) merge:

Split the file into chunks of MAX_MEM size (100 elements)

this is O(1)

Sort each chunk in memory and store as a separate file

this is O((n/max_mem) * (max_mem) log(max_mem))) = O(n log(max_mem))

Open all chunks as streams of elements
Merge all streams by selecting the lowest element at each step.

this is O(n log(n/max_mem)) using a minHeap or O(n^2/max_mem) trivially (may be faster in practice)

Delete the chunks

Concerning computation, this is O(n (log(max_mem)+log(n/max_mem)))=O(n log(n))
Concerning disk I/O, if all merging is done in one pass, this is 2*n reads and 2*n writes only.
More generally, it's (1+[depth of the merge tree])*n
All writes are sequential.
The first read is sequential, the second one is sequential, interleaved from 10 files.
If there was much more data, you'd need repeated or recursive merge (100 per chunk, then pick N chunks repeatedly). At this point, it's worth replacing the split+sort step with Replacement/Selection as described in the @amit's answer, especially when the data is already almost sorted (you may evade the merging step completely).
Note that higher N may increase computation (very slightly, if you use the right structures), but reduces the amount of disk I/O significantly (up to a certain amount; if you merge too many chunks at once, you may run out of memory for the read buffers, causing unneccessary reads) . Disk I/O is expensive, CPU cycles are not.
",5,13775784
13776053,"
Perhaps the interviewer expected you to ask: Are those numbers the unique seven digit telephone numbers mentioned by J. Bentley (Cracking the Oyster)?
",3,13775784
13775930,"
The standard way of doing it is an External Sort.
In external sort - it is not only important to have O(nlogn) comlexity - it is also critical to minimize as much as possible the disk reads/writes, and make the most reads and writes sequential (and not random) - since disk access is much more efficient when done sequentially.
The standard way of doing so is indeed a k-way merge sort, as suggsested by @JanDvorak, but there are some faults and addition to the suggestion I am aiming to correct:

First, doing an RS (Replacement-Selection) on the input decreases the number of initial ""runs"" (number of increasing sequences) and thus usually decrease the total number of iterations needed by the later on merge sort.
We need memory for buffering (reading and writing input) - thus, for memory size M, and file size M*10, we cannot do 10-way merge - it will result in a LOT of read disks (reading each element, rather then in blocks).
The standard formula for k - the ""order"" of the merge is M/(2b) (where M is the size of your memory, and b is the size of each ""buffer"" (usually disk block).
Each merge sort step is done by reading b entries from each ""run"" generated in previous iteration - filling M/2 in the memory. The rest of the memory is for ""prediction"" (which allows continious work with minimal wait for IO) - requesting more elements from a a run, and for the output buffer - in order to guarantee sequential right in blocks.
Total number of iterations with this approach is log_k(N/(2M)) where k is the number of runs (previously calculated), M is the size of the memory, and N is the size of the file. Each iteration requires 1 sequential read and 1 sequential write of the entire file.


That said - the ratio of file_size/memory_size is usually MUCH more then 10. If you are interested only in a ratio of 10, a local optimizations might take place, but it is not for the more common case where file_size/memory_size >> 10
",3,13775784
13753307,"
Just a few suggestions.
First, I'd write a small proxy class that does nothing but let you use 1-based indexing on your collection. All the index math used in heaps assumes 1-based indexing, and it's a lot easier to compensate for 0-based indexing in one place than throughout all the code. As it stands right now, I have a hard enough time following the indexing to be sure your reheapify_down is correct. It's certainly the right general idea, but it would take a lot of work to be certain all the math is right.
Second, I'd write a check_heap (or whatever) that you can use to verify both your make_heap and your reheapify_down (as an aside, I'd decide on either ""make_heap"" or ""heapify"", so the names would be either ""make_heap"" and ""remake_heap"", or else ""heapify"" and ""reheapify"").
Beyond that, however, it's hard to be certain of the problem, especially since you haven't included the code for your make_heap in the question. If it isn't working correctly, the rest has no hope.
",0,13751477
13747915,"
Use a std::map<std::pair<int, int>, int>. Insert like this:
You don't even need to sort it afterwards, you can always just record the current maximum after each insertion!
Note that the outer pair in the insert carries a default value for your number of uses. This will be set to 0 if the element is not already in the map. So in case the permutation already exists, it will find you the map element, otherwise it will insert it and set the use count to zero. Then you just increment it either way!
",0,13747754
13747903,"
I would just make an unordered map of pair to int (assuming int is sufficient, you might need a long or an arbitrarily big integer). Just increment the value if the key already exists, otherwise set the value to 1
",0,13747754
13735472,"
The correct solution is to ditch your custom sort and use std::sort from <algorithm>. This will pretty much be guaranteed to be faster and more optimal in almost every case. Then you just have:
If you want to sort by object value rather than pointer value, either use std::vector<Heltal> instead of std::vector<Heltal *> (which is almost certainly what you should be doing anyway), or pass a comparison function to std::sort.
Example using C++11 lambda for this:
",5,13735379
13717686,"
Your main problem is that you're creating copies when you're partitioning. There's a lot of memory allocation and copying going on behind the scenes.
If you want it faster you need to sort in place (and don't pass huge vectors by value).
Unless this is an exercise to implement quicksort you should use std::sort with custom comparison functions.
",2,13717090
13718120,"
So here are a few observations:

You should, as others have noted, consider using the std implementation as a benchmark.
You could pre-reserve the vectors you're sorting into, rather than have them continually grow and re-allocate.
It might be better to skip the pivot in the loop, rather than erase it from the vector, as the latter might require a lot of copying of data.
You could not bother with copying data into new vectors and concatenating them, and instead sort in place.
You could perhaps pick a better pivot than doing so at random (especially if your data is pre-sorted).
You could alter the implementation of your Point to allow indexing xyz instead of having to use an if()

Essentially, this seems like quite a naive implementation, and you'll probably have to do quite a bit of work, and utilise specialist knowledge of your own data, in order to beat the pre-supplied version.
",1,13717090
13713764,"
Because of how distribute works:
Each of the other numbers contribute ""beads"" to the slots - there are 13 numbers so slot 1 has 13  in it when it finishes the first pass.
it ""distributes"" beads in ""columns"" I.e when you print it on its side, there are now 734 slots - the largest number. 
When distribute runs again it shifts the ""beads"" down by summing the columns - it will perform a number of additions dependent on the max element * The number of numbers - plus memory allocations
",0,13712839
16346732,"
Its my implementation! I am the original author for the bead sort in C++ that you see on rosettacode. 
The reason that the algorithm is so slow is because this sort has three major slowdown issues. One deals with the potential resize of the vector every time distribute runs O(S). This also is combined with the actual adding of the numbers one by one down each ""pole"" O(S)+O(S) or O(2S) and then doing this n times where n is the numbers to be sorted O(n)+O(2S). Since S is still larger in most cases, the algorithm is still O(S). 
To be fair, all it will take is someone making a better implementation and less verbose version of my code to improve performance. I made this algorithm this way to showcase as easily as possible for people new to bead sort. 
Also check the wiki page of bead sort if you wish to learn more about it. 
",1,13712839
13713422,"
I am not sure if this is what you want, but his is how I see it.
The idea behind bubble sort is that you go though the vector of values (left to right). I am calling this a pass. During the pass pairs of values are checked and swapped to be in correct order (higher right).
During first pass the maximum value will be reached. When reached the max will be higher then value next to it, so they will be swapped. This means that max will become part of next pair in the pass. This repeats until pass is completed and max is left at the right end of the vector.
During second pass the same is true for the second highest value in the vector. Only difference is it will not be swapped with the max at the end. Now two most right values are correctly set.
I every next pass one value will be sorted out to the right.
There are N values and N passes. This means that after N passes all N values will be sorted
",0,13711517
13708889,"
If it's meant strictly for profiling, I'd put the counting logic outside of the sorting class. That is something like the following (which just counts the number of comparisons and swaps used by std::sort):
",1,13708520
13705547,"
The ++ operator in C increments a variable. See here for a fast reference:
http://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Arithmetic_operators
In this case the variable is the array element in position i of the array named List, which is represented in C as   List[i].
",0,13700091
13700144,"
It increments the value of the i th element of your list, by 1. 
",3,13700091
13700133,"
It is simply accessing the element in the vector<int> argument to your function (called List) at index i and incrementing its value by 1
",1,13700091
13610069,"
Inside the function, make a vector positions = [0,1,2,3...]
Sort positions with the comparator (int x, int y){return data[x]<data[y];}.  
Then iterate over positions , doing result.push_back(index[*it]);
This assumes the values in index can be arbitrary.  If it is guaranteed to already be [0,1,2..] as in your example, then you don't to make the positions array, just use index in it's place and skip the last copy. 
",6,13609797
13610065,"
http://www.boost.org/doc/libs/1_52_0/libs/iterator/doc/index.html#iterator-facade-and-adaptor
Write a iterator over std::pair<double&, signed int&> that actually wraps a pair of iterators into each vector.  The only tricky part is making sure that std::sort realizes that the result is a random access iterator.
If you can't use boost, just write the equivalent yourself.
Before doing this, determine if it is worth your bother.  A zip, sort and unzip is easier to write, and programmer time can be exchanged for performance in lots of spots: until you konw where it is optimally spent, maybe you should just do a good-enough job and then benchmark where you need to speed things up.
",2,13609797
13610139,"
You can use a custom iterator class, which iterates over both vectors in parallel. Its internal members would consist of

Two references (or pointers), one for each vector
An index indicating the current position

The value type of the iterator should be a pair<double, unsigned>. This is because std::sort will not only swap items, but in some cases also temporarily store single values. I wrote more details about this in section 3 of this question.
The reference type has to be some class which again holds references to both vectors and a current index. So you might make the reference type the same as the iterator type, if you are careful. The operator= of the reference type must allow assignment from the value type. And the swap function should be specialized for this reference, to allow swapping such list items in place, by swapping for both lists separately.
",1,13609797
13610063,"
You can use a functor class to hold a reference to the value array and use it as the comparator to sort the index array. Then copy the values to a new value array and swap the contents.
",1,13609797
13610105,"
This should do it:
",-1,13609797
13590234,"
Your compare function is not strict - for two equal chromosomes, it returns true for compareChromosomes (regardless of order). Replace your condition with strict less:
",4,13590214
13624233,"
The reason why 0.858721 is changed to -0.474942 is not because of your comparison function.
There must be some other reason on the code you had not posted.
Try the code below: the output is ok.
",1,13590214
13579808,"
Complexity is a difficult beast to master, because it is polymorphic.
When we speak about the complexity of an algorithm, we generally simplify it and express it according to what we think being the bottleneck operation.
For example, when evaluating sorting algorithms, the complexity is expressed as the number of comparisons; however, should your memory be a tape1 instead of RAM, the true bottleneck is the memory access and therefore a quicksort O(N log N) ends up being slower than a bubblesort O(N ** 2).
Here, your algorithm may be optimal, its implementation seems lacking: there is a lot of memory allocation/deallocation going on, for example. Therefore, it may well be that you did not identified the bottleneck operation correctly, and that all talk of linear complexity are moot since you are not measuring the right things.
1 because tapes take a time to move from one cell to another proportional to the distance between those cells, and thus a quicksort algorithms that keep jumping around memory ends up doing a lot of back and forth whilst a bubble sort algorithm just runs the length of the tape N times (max).
",1,13579392
39850080,"
Radix sort with base 256 could easily look something like this.
",0,13579392
13575815,"

I was leaning towards building two std::map to count up each of the vector's elements.

This will be far slower than just creating sorted vectors. (Note also that std::map is powered by sorting; it just does so using red-black trees or AVL trees) Maps are data structures optimized for an even mix of inserts and lookups; but your use case is a whole bunch of inserts followed by a whole bunch of lookups with no overlap.
I would just sort the vectors (or make copies and sort those, if you are not allowed to destroy the source copies) and then use vector's built in operator ==.
",4,13575748
13575888,"
Sorting the vectors and call set_difference is still the best way. 
If the copy is heavy for you, the comparison between two unsorted arrays is even worse? 
If you want current array untouched, you can make a copy of current arrays?
",4,13575748
13575825,"
I assume for some reason you can't sort the vectors, most likely because you still need them in their original order or they're expensive to copy. Otherwise, just sort them.
Create a ""view"" into each vector that allows you to see the vector in any order. You can do this with a vector of pointers that starts out pointing to the elements in order. Then sort the two views, producing a sorted view into each vector. Then compare the two views, comparing the two vectors in their view order. This avoids sorting the vectors themselves.
",3,13575748
13575770,"
Was originally thinking of working in terms of sets since that's what you're actually thinking in terms of but that does necessitate sorting.  This can be done in O(n) by converting both to hashmaps and checking for equality there.
",1,13575748
13575793,"
just take the first vector and compare it with each element in the second vector.
If one value from the first one couldnt be find in the second the vectors are different. 
In the worst case it takes O(n*m) time which n = size of first vector and m = size second vector.
",-1,13575748
13576338,"
This util method will help you to compare 2 int[], let me know in case of any issues
public static boolean compareArray(int[] v1, int[] v2){
",-1,13575748
15035580,"
SortRoadsComparator function prototype should be:
You should make sure SortRoadsComparator returns weak ordered Road.
",2,15035506
15035608,"
It requires you to pass proper comparator into std::sort. If you read std::sort documentation you can see that it requires following signature:
and: 

The types Type1 and Type2 must be such that an object of type RandomIt can be dereferenced and then implicitly converted to both of them. 

So in your case dereferenced ""iterator"" roads has type Road& and function could be something like:
PS Looks like you are porting qsort code into C++. Though suggestion to make signature to:
will compile, it is logically incorrect and would hide the fact that you need to change returned values in your function and slightly change the logic. In current implementation std::sort will most probably crash, but definatelly will not sort your sequence the way you expect it to.
",3,15035506
15025904,"
You know what std::pair is?  It's a struct (or class, which is the same thing in C++ for our purposes).  So if you want to know what's faster, the usual advice applies: you have to test it and find out for yourself on your platform.  But the best bet is that if you implement the equivalent sorting logic to std::pair, you will have equivalent performance, because the compiler does not care whether your data type's name is std::pair or something else.
But note that the code you posted is not equivalent in functionality to the operator < provided for std::pair.  Specifically, you only compare the first member, not both.  Obviously this may result in some speed gain (but probably not enough to notice in any real program).
",3,15025742
15025910,"
I would estimate that there isn't much difference at all between these two solutions. 
But like ALL performance related queries, rather than rely on someone on the internet telling they are the same, or one is better than the other, make your own measurements. Sometimes, subtle differences in implementation will make a lot of difference to the actual results. 
Having said that, the implementation of std::pair is a struct (or class) with two members, first and second, so I have a hard time imagining that there is any real difference here - you are just implementing your own pair with your own compare function that does exactly the same things that the already existing pair does... Whether it's in an internal function in the class or as an standalone function is unlikely to make much of a difference. 
Edit: I made the following ""mash the code together"":
The results are as follows:
I ran the benchmark three times, and they are all within ~0.1s of the above results. 
Edit2:
And looking at the code generated, it's quite clear that the ""middle"" function takes quite a bit longer, since the comparison is made inline for pair and struct cl2, but can't be made inline for struct cl1 - so every compare literally makes a function call, rather than a few instructions inside the functions. This is a large overhead. 
",1,15025742
14974297,"
It looks like what you want to do is return a vector which corresponds to the input, but with each element replaced with a number which is the relative order in which that element occurred in the input.
That is, if we removed all duplicates from the input, the output for each element is the index of that element in the duplicate-free vector.
This might do the trick:
",0,14972309
14972394,"
If your question is to sort tempID in ascending order, I'd do like this:
",2,14972309
14963919,"
This [...](...) { ... } syntax is a lambda expression, a feature of C++11. You need to make sure you're using a compiler that supports them. Some compilers provide a switch to enable C++ features (-std=c++0x for GCC).
If you want to use std::sort on a normal array, use:
Alternatively, you can make your code agnostic as to whether you're using a container or an array. Where ac is an array or container:
",2,14963840
14961386,"
You have two options for using std::sort. One is to overload operator < for your class:
However, only do this if it really makes sense to always compare Card objects like this. If you only need this for a particular sorting, you can use the version of sort which accepts a custom comparator.
There are multiple ways to define the predicate. For reusable, but simple criteria, a static function in the class can be used:
Usage:
For a one-shot thing (or for complex criteria which need to preserve internal state), use a class derived from std::binary_function and implement the comaprison logic in its operator(). In C++11, you can also use lambda functions for this:
",2,14961157
14961202,"
You will need to overload the operator<:
And then use std::sort. You may need to make this operator friend for your class. Alternatively in the class definition you may implement:
",3,14961157
14962537,"
I came up with this answer, it uses compare classes, this also make it really easy to compare suites for instance. I also Improved public and private members in your class, since some values should not be public. And you class currently doesn't need a destructor.
",0,14961157
14940653,"
CPU architecture specific. How can you measure it on modern processors anyway?
However if key is not really an int (that is you anonymized it to one) and there is no specific overloaded operator for <= than the code performance of <= will be much worse than <.
In your specific algorithm, changing between <= and < is going to wreck you algorithm so that's what happened here.
",2,14940579
14940649,"
No, there is no performance difference between > and >= on any modern hardware, any timing deltas are artificial and purely coincidental. Are you sure the code snippets actually do the same thing? Are your compiler settings set to maximize optimization (it's useless to time code in debug mode)?
By the way, you probably shouldn't start your type names with ""T"" in C++. This isn't Pascal ^^
",1,14940579
14914487,"
This line does not compile. int bucket[c][k + 1];
I think the problem is with you bucket indices. This part here 
does not do the equivalent of:
First it gets the index off by one. Because of that it also misses the break for the numbers for the last bucket. There is also a small error introduced because the index calculation uses the range [0,l-s] instead of [s,l], which are only the same if s equals 0. 
When I write bucketIndex as:
and rewrite the main part of your algorithm as:
I get the items properly inserted into their buckets.
",0,14913668
14905416,"
Why not store iterators in the priority queue instead of raw pointers?  Since you are using list you do not need to worry about iterator invalidation.  Then you can just use std::list::erase.  The overhead of storing an iterator should be negligible since it just holds a pointer to the list node.
",3,14905300
14898638,"
If the other queues aren't changed while your loop is ongoing, you can use the initial minimum-search to find the two shortest queues. Something like: 
You can then use second_shortest_index as your some_other_index. This will still require you to search a new second-shortest queue, when you hit that limit (as there may be multiple shortest or second-shortest elements)
If you can reorder your vector<queue> or using an index vector with an indirect comparator, you could use std::make_heap and related functions to keep track of smallest queue much more easily. 
",2,14898320
14890736,"
You are not intializing to NULL the next and prev pointers of new node a directly in the function. Following modification in insertSorted function makes code working perfectly for me
Please check
Only problem i found was there is no checking for this condition  if(head->value == item && head->next==NULL) 
",2,14890506
14885964,"
Here is a very compact solution which should be easy to read and understand.
I am assuming that combo has enough space to fit the result and that a and b are already ordered (as your example suggests):
It could be slightly tweaked for better performance, but it is very elegant and readable. As a plus, this code is both C and C++ compliant.
",0,14885867
14885904,"
Unless this is a homework assignment, use std::merge
If this is homework, try this algorithm:
",4,14885867
14885948,"
I assume that this is some type of homework, if it is not, just use std::merge.
If you want to roll this out manually you need to consider that you are working with three cursors: two are input cursors into the two different arrays and the other one is the output (write) cursor.
After deciding from which of the arrays you want to move the next element, you need to copy and update two cursors, the read cursor in that array (since that element has already been consumed) and the write cursor in the final array (since that location has already been written to).
I hope this is enough to lead you to a solution :)
",3,14885867
14885926,"
Here's a list of standard things you could try: http://www.cplusplus.com/faq/sequences/sequencing/sort-algorithms/
Also, have you considered something like, in psuedo-code:
create a new array [size of old array minus one]
mempcy(new array, start to removal point -1)
mempcy(new array, removal point + 1 to end)
sort from new array
fine the lowest number again...
",1,14885867
14886016,"
Assuming this is for a homework assignment or something similar, and that you're not allowed to use standard stuff like std::merge, the merge algorithms for 2 sorted lists can be accomplished in linear complexity like so:
",0,14885867
14830864,"
You may want to make a struct or std::pair and sore them in std::vector
sort by value:
",5,14830661
14830726,"
A std::map is fine in this case, considering that you are mapping IDs to a count.
For future reference: 

",4,14830661
14835406,"
I usually do in following way:
create a class/struct of two int member
then create a 
then create two bool compare functions:
then sort using std::sort and those bool functions.
p.s: sorry about the formatting. typing from mobile. 
",1,14830661
14831768,"
If i had to do this in the confines of your proposed usage (maintain a key-map for quick counter updates, then dump a sorted result), I would likely use an unordered map and a pointer vector. With this I'm assuming the primary reason you want some indexed-key soluton in the first place is to make data processing significantly quicker when updating counts.
In other words, you're looking to get a good speed-bump out of code that does this:
But still be able to report output sorted not on id, but rather on the accumulated count of each id. That being said, the following, though a little dense, will do exactly that:
Sample Run
I've used this method in the past because it is swimmingly-efficient for more complex structures that are expensive to copy into temporary containers for sorting. That the ending pointer-vector references the real data in the map is a nicety that, while probably overkill for this specific problem, certainly has reaps of benefits as a general solution.
That being said, if all you want is an int-to-int dump, sorted on second-int rather than your map key, this will likewise do the trick, though it does replicate data out of your container to accomplish the end-goal:
Sample Output
",1,14830661
14832017,"
You could simply use boost.bimap. Its is a little work to understand it but its worth and I think its fits exactly your use case.
",0,14830661
14828592,"
std::sort behaves like that because it's based on the idea of a strict weak ordering, which is (usually) defined in terms of the < operator.
As to your question; it currently seems to be ""I wrote a C function that behaves differently to std::sort.  Why is it different?"".  The answer is: because you wrote a different function!
",7,14828476
14828762,"
std::sort sorts in ascending order by default. In case you are looking for descending order, here's the trick:
This way, you explicitly say that std::sort should treat your array as its end is its beginning and vice versa, which results in your array being sorted in descending order. Here's the full example.

And in case you want to use std::less and std::greater, then it could look like this:
Full example with second solution is here.
",9,14828476
14803525,"

What I do not understand is what is being represented by MyClass const & L, and MyClass const & R.

L and R, in this case are two items (instances of your class MyClass) from the container that are being compared, with L on the left of the less-than operator and R on the right. They are passed in by const-reference.

And I am not grasping how I can apply this to my code.

In your own bool operator() const(MyClass const& L, MyClass const& R), you need to compare the three data members you mention in your question, vitally remembering to apply strict weak ordering. Return true if L is ""less than"" R and false otherwise.

Following updates to the question...
It looks like you wish to pass a variable into your functor. You do this by creating a constructor, like this SSCCE (which compiles here):
Note: The const qualifier comes after the argument list and not after the method name.
Also, please don't put the entire method on one line, it makes it very difficult to read.
",1,14803445
14803500,"
SortByX is a binary predicate functor. Binary predicate means it takes two arguments and returns a boolean. Functor means it's instances are callable. For example:
Now, std::sort will internally use a copy of the instance of SortByX that you pass it in order to perform the comparisons between the elements of a std::vector<MyClass> needed to sort that vector.
Note: for this to work, the binary predicate must implement strict weak ordering.
",2,14803445
14796681,"
Assuming you intend to use std::sort to sort the string (since neither std::vector nor std::string have a sort method), the first statement is incorrect and leads to undefined behaviour (UB):
Here, std::sort will attempt to dereference str.rend(), which is a ""past the end"" iterator. De-referencing such an iterator is UB.
A correct use of reverse iterators would be
This would result in the string/vector being sorted in descending order.
",5,14796577
14796637,"
The iterators in the standard library on lots of containers and other things (like std::string) have a reverse variety which begin with r (rbegin(), rend and the like). These will iterate in the reverse-sequential order. Using just begin and end will sort your string in the correct format from start to finish.
Try to avoid using the reverse iterators and just use the regular begin() and end() on your strings:
Edit:
So... you want vector<int> to be sorted instead? If so, do the same as above, except call std::sort with the begin() and end() of your std::vector<int>.
",3,14796577
14794357,"
The following function will do a case-insensitive compare on two std::strings without external libraries (it is C++11 though). 
",2,14793902
14794056,"
As suggested in Case insensitive string comparison C++ (2012), strcasecmp() will provide the right answer if comparing const char * strings. 
If comparing C++ strings, the Boost library has is_iless(), for which the header is here, as suggested by Case insensitive string comparison in C++ (2008).
",0,14793902
14790328,"
If you are using strings, see strcmp.

man strcmp
A value greater than zero indicates that the first character that does not match has a greater value in str1 than in str2; a value less than zero indicates the opposite.

To sort your array, you can also use qsort from the standard C library.
",0,14790295
14787229,"
This is the most memory efficient layout I could come up with. Obviously the vector I'm using would be replaced by the data blob you're using, assuming endian-ness is all handled well enough. The premise of the code below is simple.

Generate 1024 random values in pairs, each pair consisting of the first number between 1 and 500, the second number between 1 and 50.
Iterate the entire list, flipping all even-index values with their following odd-index brethren.
Send the entire thing to std::qsort with an item width of two (2) int32_t values and a count of half the original vector.
The comparator function simply sorts on the immediate value first, and on the second value if the first is equal.

The sample below does this for 1024 items. I've tested it without output for 134217728 items (exactly 536870912 bytes) and the results were pretty impressive for a measly macbook air laptop, about 15 seconds, only about 10 of that on the actual sort. What is ideally most important is no additional memory allocation is required beyond the data vector. Yes, to the purists, I do use call-stack space, but only because q-sort does.
I hope you get something out of it.
Note: I only show the first part of the output, but I hope it shows what you're looking for.
Output
",2,14786731
14787236,"
With some additional constraints on both your input and your platform, you can probably use an approach like the one you are thinking of. These constraints would include

Your input contains only positive numbers (i.e. can be treated as unsigned)
Your platform provides uint8_t and uint64_t in <cstdint>
You address a single platform with known endianness.

In that case you can divide your input into groups of 8 bytes, do some byte shuffling to arrange each groups as one uint64_t with the ""first"" number from the input in the lower-valued half and run std::sort on the resulting array. Depending on endianness you may need to do more byte shuffling to rearrange each sorted 8-byte group as a pair of uint32_t in the expected order.
If you can't code this on your own, I'd strongly advise you not to take this approach.
A better and more portable approach (you have some inherent non-portability by starting from a not clearly specified binary file format), would be:
Both the inital parse/swap pass (which you need anyway) and the final conversion are O(N), so the total complexity is still (O(N log(N)).
If you can continue to work with pairs, you can save the final conversion. The other way to save that conversion would be to use a hand-coded sort with two-int strides and two-int swap: much more work - and possibly still hard to get as efficient as a well-tuned library sort.
",2,14786731
14787040,"
Do one thing at a time. First, give your data some *struct*ure. It seems that each 8 byte form a unit of the
form
If the endianness is right, you can do this in O(1) with a reinterpret_cast. If it isn't, you'll have to live with a O(n) conversion effort. Both vanish compared to the O(n log n) search effort.
When you have an array of these units, you can use std::sort like:
The key to this solution is that you do the ""swapping"" and byte-interpretation first and then do the sorting.
",0,14786731
14788049,"
C/C++ does not allow real data-types (float, double etc) as subscript operator to declare size of an array, or to access. Following is an error:
And so the following:
You must pass an integral type (int, long, char, bool, unsigned etc) to specify the size and to access the element. If the variable is of real type, you can typecast it to int (Or, more preferably size_t)
If you have a class, then you can overload subscript operator with any type you like!
",2,14784947
14784960,"
This error is caused by the nan value in your data (position 1688). The problem is that < is no longer satisfies the constraints required by std::sort when you include nans. See the standard, 25.4/4, for the definition of the ""strict weak ordering"" that all comparators have to satisfy.
",2,14784263
14764067,"
You are using c++ so quit using arrays and begin with stl types:
Convert each row into a string:
add them to a vector
Do that for each row. 
Then sort the vector with std::sort and write the vector back into the array (if you have to but don't because arrays suck)
",2,14763962
14764554,"
As usual, you need qsort:
That takes a void pointer to your starting address, the number of elements to sort, the size of each element, and a comparison function.
You would call it like this:
Where you define compare_word to sort in reverse:
Now, given that each word is 15 characters long, there may be padding to deal with.  I don't have absolute knowledge that the array will be packed as 10 by 15 instead of 10 by 16.  But if you suspect so, you could pass (&array[1][0] - &array[0][0]) as the element size instead of COLS.
If you are not allowed to use qsort and instead must write your own sorting algorithm, do something simple like selection sort.  You can use strncmp to test the strings.  Look up the function (google makes it easy, or if you use Linux, man 3 strncmp).  To swap the characters, you could use a temporary char array of length COLS and then 3 calls to memcpy to swap the words.
",2,14763962
14765138,"
The problem with your new code using string and vector is a simple typo:
sorter[count] = array[count+1]; should be sorter[count] = sorter[count+1];
",2,14763962
14762390,"
You can use a functor instead of a free function:
The overloaded () operator executes when the functor is called by sort. In there you can have a variable mode and use it as you need.
Then set mode (you could also set in on the functor constructor) and call sort using it:
",3,14762344
14762424,"
If you are using C++11, you can use a lambda:
",5,14762344
14762388,"
Create a functor:
Then pass an instance of that instead of your plain function myfunction. Here, T is the type used to instantiate your std::vector.
If you have C++11 support, you can use a lambda function:
",1,14762344
14743579,"
Couple of things you need to fix: 

PHONY->next is not null , so your initialization will fail : 

Node constructor  should initialize next to 0 instead of this , hence you will never hit NULL condition for end of your list. 
in insert in else statement you should start search from head->next, currently you start search from currn = head which is PHONY which is not correct. 
You also need to set tmp->next appropriately ,consider this case when you are inserting in middle of the list.

",0,14743474
14726924,"
If you are trying to solve task from coursera.org, you need to use
",1,14726704
14727138,"
There is one thing that I would consider a fatal error: there's
no documentation with regards to pre-conditions.  In particular,
is calling it with lo == hi legal or not.  (If it's legal, the
code has undefined behavior.)  And what do lo and hi
represent?  Under the usual C++ conventions, which I find work
very well, lo would be inclusive, and hi exclusive.  But
again, you don't tell us, despite the fact that it is important
to know if we are to judge the correctness of the code.  (The
fact that you do arr[hi] makes me think that you've adopted 
the somewhat unusual convention of making both ends inclusive.)
Without such information, it's impossible to do anything but
make stylistic comments (e.g. use != rather than ^ for
comparing results, use return with ?: rather than if ... else
if ... else, etc.).
",1,14726704
14726840,"

You should probably use != instead of ^ to compare boolean results for inequality.
Based on the textual description, you should be returning arr[hi] instead of hi (and similar for mid, lo).

",0,14726704
14716881,"
vec.begin() and vec.end() are returning iterators iterators. The iterators are kind of pointers on the elements, you can read them and modify them using iterators. That is what sort is doing using the iterators. 
If it is an iterator, you can directly modify the object the iterator is referring to: 
The sort function does not have to know about the containers, which is the power of the iterators. By manipulating the pointers, it can sort the complete container without even knowing exactly what container it is. 
You should learn about iterators (http://www.cprogramming.com/tutorial/stl/iterators.html)
",3,14716855
14716890,"
vec.begin() and vec.end() do not return the first and last elements of the vector. They actually return what is known as an iterator. An iterator behaves very much like a pointer to the elements. If you have an iterator i that you initialised with vec.begin(), you can get a pointer to the second element in the vector just by doing i++ - the same as you would if you had a point to the first element in an array. Likewise you can do i-- to go backwards. For some iterators (known as random access iterators), you can even do i + 5 to get an iterator to the 5th element after i.
This is how the algorithm accesses the container. It knows that all of the elements that it should be sorting are between begin() and end(). It navigates around the elements by doing simple iterator operations. It can then modify the elements by doing *i, which gives the algorithm a reference to the element that i is pointing at. For example, if i is set to vec.begin(), and you do *i = 5;, you will change the value of the first element of vec.
This approach allows you to pass only part of a vector to be sorted. Let's say you only wanted to sort the first 5 elements of your vector. You could do:
This is very powerful. Since iterators behave very much like pointers, you can actually pass plain old pointers too. Let's say you have an array int array[] = {4, 3, 2, 5, 1};, you could easily call std::sort(array, array + 5) (because the name of an array will decay to a pointer to its first element).
",2,14716855
14716894,"
The container doesn't have to be accessed. That's the whole point of the design behind the Standard Template Library (which became part of the C++ standard library): The algorithms don't know anything about containers, just iterators.
This means they can work with anything that provides a pair of iterators. Of course all STL containers provide begin() and end() methods, but you can also use a regular old C array, or an MFC or glib container, or anything else, just by writing your own iterators for it. (And for C arrays, it's as simple as a and a+a_len for the begin and end iterators.)
As for how it works under the covers: Iterators follow an implicit protocol: you can do things like ++it to advance an iterator to the next element, or *it to get the value of the current element, or *it = 3 to set the value of the current element. (It's a bit more complicated than this, because there are a few different protocols—iterators can be random-access or forward-only, const or writable, etc. But that's the basic idea.) So, if `sort is coded to restrict itself to the iterator protocol (and, of course, it is), it works with anything that conforms to that protocol.
To learn more, there are many tutorials on the internet (and in the bookstore); there's only so much an SO answer can explain.
",1,14716855
14716887,"
begin() and end() return iterators.  See e.g. http://www.cprogramming.com/tutorial/stl/iterators.html
",0,14716855
14716961,"
Iterators act like references into part of a container.  That is, *iter = z; actually changes one of the elements in the container.
std::sort actually uses a swap function on references to the contained objects, so that any iterators you have already initialized remain in the same order but the values those iterators refer to are changed.
Note that std::list also has member functions called sort.  It works the other way around: any iterators you have already initialized keep the same values, but the order of those iterators changes.
",0,14716855
14709097,"
Here:
Because sortarray is an int*, sizeof(sortarray) is only 4 or 8 (depending on your target).
You should probably use sortsize like you do elsewhere.
",1,14708348
14689306,"
How it is implemented is up to the implementation of the standard library. It is guaranteed to have O(Nlog(N)) complexity. Common implementations use quicksort or introsort.
The comparison function is a binary function that must return true if the first argument is strictly less than the second. The implementation uses this function to compare two elements of the container to determine which should precede which others - so a and b may be any two elements in your container. This function must give a strict weak ordering over the elements. That is:

An element is never less than itself
If x < y, then it is not the case that y < x
If x < y and y < z, then x < z

If you don't supply a comparison function, operator< is used. Equivalently, you could pass std::less as the comparison function.
",3,14689215
14689309,"
Check the reference of sort method here: http://en.cppreference.com/w/cpp/algorithm/sort
The first parameter is the starting pointer.
The second parameter is the ending pointer.
The third parameter is optional. It is the comparison function to define how to sort.
",0,14689215
14680490,"
Ideally, merge the 3 data fields into a struct so that you can have just 1 vector and so sort it simply.
",4,14680424
14669733,"
Please notice that you will need a C++11 compiler to get this code compile. You should make the lambda function accept const references to avoid expensive copies, as suggested by Blastfurnace.
Output of the program:
",8,14669533
14669724,"
My suggestion is use struct for table though:
Put each row from DB into a struct then store it in vector:
Now you could sort vector by any column
If you use C++11, could use lambda as well:
",4,14669533
14666292,"
I'm trying to be basic and simple yet actually use C++ (and basic C functions).

read all the text in the file into std::string.
split the string by the delimiter '\n' (or ""\r\n"", depends on the input) into ""std::vector lines"". (using std::string::find(), std::string::substr()).
loop lines, and for each line split by the delimiter ' ' into ""std::vector string_numbers"".
loop ""string_numbers"" and use atoi() to insert each string_number into std::vector numbers.
sort (MANY algorithms on the net. bubble sort is pretty easy but not efficient O(n^2). If you are looking to implement yourself for something more efficient look at merge-sort O(nlogn) or quick-sort O(nlogn) in average case, harder to implement but MUCH faster).

",0,14665942
14682288,"
I'd recommend using the Standard Template Library to help you control the numbers and sort. Also, I'm not sure where the numbers 2 and 3 went in your example output lines... I'm assuming that was a typo and you don't need to remove those numbers from the sorted vector for some reason. 
Anyway, I'd do something like this:
It's a little messy swapping between character arrays and strings, but I wasn't sure if you wanted to use Boost or just wanted to see the strtok solution. Also, you can specify the range of vector items you want to sort only, so a more elegant solution could utilize that.
Cheers
",0,14665942
14658008,"
The array will be sorted as [0,0,0,0,0,0,0,0,2,3], since you define the comparison operator on the x variable.
Regarding the second code snippet, it looks like you're trying to process multiple instances of the same element somehow. You usually don't want to increment a variable while you're using it again in the same statement. Try something like:
",0,14657945
14610784,"
The simplest was to sort them using a BST would be to put them in an std::map<int, std::string>. This is a self sorted data structure using a BST internally (although that isn't explicitly specified by the standard). If you do not want look-up, you can use an std::set of a user defined type instead (see next paragraph).
If you want to store them in a flat array-like structure, you could create a small struct to hold the information, store instances of it in an std::vector, and use a suitable comparison function in combination with std::sort to do the sorting.
BST:
and so on.
array-like solution:
",1,14610655
14611057,"
I think, a trie is the easiest way to implement the whole sorting and it's O(n) if the length of the id is constant.
",0,14610655
14608861,"
If you require access to the maximum valued element of a collection, you will have to incur some performance hit either (a) upfront at insertion time, or (b) during searching time. You've noted that (b) is expensive, probably due to the method you chose, and are asking how you can make this quicker.
Out of the box you have priority_queue which provides probably exactly what you are looking for. I would imagine the performance would be better than your current code.
",1,14608122
14608531,"
If you are ""collecting"" data that you are later going to select things in some order (biggest, smallest, etc), you will have a few choices:

sorting as you go.
sorting when you have collected all the data.
have poor performance when searching for your data.
create TWO sets of data, where one is sorted, with some sort of index to your unsorted data items. 

In your case, you are talking of removing some data as from the collection as well. Is it required that you actually remove the data, or that you simply keep track of what you ""no longer need""? If the latter, perhaps option four above is a good choice - you simply remove it from the sorted table. Since this is much smaller than the list of items itself [presumably ""MyClass"" is bigger than two integers].
",0,14608122
14605743,"
If i got what you want, lexigraphical sort (and std::lexigraphical_compare predicate) would help.
",1,14605568
14619996,"
What you want to is as @distantTransformer say a lexicographical_compare. It behaves almost like the StringListCompare that you have made, with the exception that it will go through the whole list of strings. You sort lists of strings not letters like the most common use case, but that doesn't matter for lexicographical_compare as it works with iterators.
If you as a learning experience rather want to do the comparison yourself, and expand your StringListCompare you can do it like this:
You could consider rewriting this using iterators, but this is a basic implementation.
",0,14605568
14647505,"
I tried it for number. But I know this is type mismatch error. 
Is there any logic available to do like this for different data type sorting? 
",0,14605568
14593888,"
Have you looked at Thrust ?
From the project page:

Thrust is a parallel algorithms library which resembles the C++
  Standard Template Library (STL). Thrust's high-level interface greatly
  enhances developer productivity while enabling performance portability
  between GPUs and multicore CPUs. Interoperability with established
  technologies (such as CUDA, TBB and OpenMP) facilitates integration
  with existing software. Develop high-performance applications rapidly
  with Thrust!

License is Apache so it should suit you.
",3,14593791
14574534,"
There is but one weakness in your plan. You need to first find the first person of the chain, the Mr New York. 
Your algorithm assumes the line starts with the first guy. For that to work, you should first scan the entire map to find the one name that does not appear as a second element. That is Mr New York and you can proceed from there. push_back is what you would need to use here.
",2,14574394
14574996,"

Create a data structure that stores a chain, its front and back. Store in a hash table with 'back' as key.
Create a bunch of singleton chains (one for each element)
Iteratively, pick a chain  find its 'front' in the hash table (i.e. find another chain that has the same element as 'back') and merge them
Do it until you are left with only one chain

",1,14574394
14566641,"
Let's stop using true, and false and return the bool expressions. It make your code so much easier to read.

Also, you created this issue you have with the threshold. Simple lower the threshold to something close to zero and the issue will go away, else you'll have to live with it. I don't see any other way.
",2,14566490
14566636,"
Unfortunately, thresholds don't work well with STL ordered containers. A requisite for the ordering criterion is that it defines a strict weak ordering; this means, amongst other things, that if a == b and b == c, then a == b (== meaning here equivalent; this is, neither greater nor lesser than, not necessarily equal).
We might have pt1.a = 0.004, pt2.a = 0.01 and pt3.a = 0.016; according to your criterion, pt1.a == pt2.a and pt2.a == pt3.a, but pt1.a =\= pt3.a. Your ordering criterion does not meet the prerequisites for std::multiset and you cannot use it.
",0,14566490
14565051,"
You cannot (or if you can, depending on your STL implementation, should not) modify items once they have been inserted into a multiset, as it could violate the provided ordering of the items in the multiset. So swapping would be a bad idea, even if you could do it.
See https://stackoverflow.com/a/2038534/713961 and http://www.cplusplus.com/reference/set/multiset/
If you would like to remove items, use multiset::erase, which takes an iterator. I believe the standard practice for ""modifying"" an item in a multiset is to remove it, then insert the modified version.
As a side note, I noticed you're checking if two floating point numbers are close enough in value by using a fixed epsilon (0.001). As explained in this article, this only works if all the floats you are comparing are sufficiently small. See the article for a comparison that works equally well for large and small floating-point values. 
",0,14564745
14553371,"
In pseudocode:
If you add p to the end of each ""half set"", then the sort order of ""sorted-by-y"" will be maintained.
",0,14553344
14549428,"
First of all: the compilers do not provide any implementation of std::sort. Whilst traditionally each compiler comes prepackaged with a Standard Library implementation (which heavily relies on compilers' built-ins) you could in theory swap one implementation for another. One very good example is that Clang compiles both libstdc++ (traditionally packaged with gcc) and libc++ (brand new).
Now that this is out of the way...
std::sort has traditionally been implemented as an intro-sort. From a high-level point of view it means a relatively standard quick-sort implementation (with some median probing to avoid a O(n2) worst case) coupled with an insertion sort routine for small inputs. libc++ implementation however is slightly different and closer to TimSort: it detects already sorted sequences in the inputs and avoid sorting them again, leading to an O(n) behavior on fully sorted input. It also uses optimized sort networks for small inputs.
std::stable_sort on the other hand is more complicated by nature. This can be extrapolated from the very wording of the Standard: the complexity is O(n log n) if sufficient additional memory can be allocated (hinting at a merge-sort), but degenerates to O(n log2 n) if not.
",18,14547801
14547913,"
If we take gcc as an example we see that it is introsort for std::sort and mergesort for std::stable_sort.
If you wade through the libc++ code you will see that it also uses mergesort for std::stable_sort if the range is big enough.
One thing you should also note is that while the general approach is always one of the above mentioned ones, they are all highly optimized for various special cases.
",6,14547801
14578502,"
Here's a two-line generic C++11 implementation of insertion sort
The algorithm takes a range of elements (given by the two iterators first and last) and a comparison function (which is defaulted to the possibly builtin operator< for the elements pointed to). 
The main loop (linear in the number of elements) keeps the subinterval [first, it) sorted, and repeatedly searches for an insertion point of where to put the next element. It's equivalent to your main loop. It does so with a binary search (logarithmic complexity). In your code you use a reverse linear search (wich has linear complexity but possibly better caching behavior). 
After it has found the insertion point, it simply rotates the two ranges [insertion, it) and [it, it+1), which means swapping the current element into the insertion point. This rotation is linear in the number of elements that has been sorted so far. Since it is nested in the main loop, the overall complexity of insertion sort is quadratic, ie.e. O(N^2). Your code integrates the swapping and searching for an insertion point, but that does not change the complexity.
Note that when the input range is already sorted, the insertion point will always be equal to the element pointed to by it, and this means that the std::rotate does not have to swap anything at all. A sufficiently smart and optimizing compiler should be able to perform that optimization. If that is the case, insertion sort on a sorted range has linear complexity.
A similar 2-line approach to selection sort is given here.
",2,14493978
14579064,"
The outer loop executes n times.
Each run of the inner loop executes somewhere between 0 and p-1 times, where p varies from 0 to n. In the worse case, it will execute p-1 times. If p varies from 0 to n, then on average, p is n/2. So, the worst-case complexity for the inner loop is O(p-1) = O(n/2-1) = O(n).
Apart from the loops, the code is all O(1) (mostly importantly, the code inside the inner loop is), so it's only the loops that matter.
O(n) * O(n) = O(n^2).
QED.
This is roughly the analysis you yourself gave.
",1,14493978
14493107,"
Your ""user"" class is simple enough such that it doesn't need an overloaded assignment operator since all it's members are plain-old-data types or already have their own assignment operators (such as string). I would recommend removing the operator= method from this class so you don't have the upkeep of maintaining the operator= method when you add new members.  C++ will automatically generate an assignment operator for your class if needed (that does memberwise assignment).  You really only need an overloaded assignment operator when you have members that are pointers, but I digress.
Your selection sort function isn't actually sorting players. It's merely re-arranging the ""age"" value on each player.  I think this is what you want to do to actually ""sort"" the ""player"" array.  (Note this is more ""C"" that ""C++"", but bare with me).
But if you want a more C++ standard way to sort, you can use the standard library for this. But that requires players to be in a type that can be iterated on.  Example
",1,14492800
14470443,"
Your algorithm has a few problems. 
First of all, it causes memory leaks, because it allocates arrays that it never deletes. A couple of delete[] instructions are needed to fix the problem. 
Second, there are indexing errors: some indices get negative, which you surely do not want (e.g. when you do tmpArray1[i] = list[lb + i - 1];, because both lb and i can be 0).
Third, you are lacking a base step: you never swap the value of two elements. Your recursion step looks fine, but recursion has to end and do something concrete at some point (i.e. when your range spans only 2 elements). Your mergeSort() function splits the range and just recursively calls itself for the first and the second subrange, but does nothing with them when recursion gets to an end.
Fourth, you are not handling correctly the cases where the two sub-ranges have different sizes (one sub-range could be larger than the other one by one element).
And here is how you should fix your code (tested on GCC 4.7.2):
",1,14469867
14470155,"
In this line:
Surely you mean this:
Otherwise you are taking one value from outside the given merge bounds, which would explain the duplicated numbers.  You don't use that logic when you write back to the list.
",2,14469867
14470173,"
I'm assuming that the mergeSort code is correct, that means ub is supposed to be the last index of the range to be sorted. If that is not the case, mergeSort is wrongly implemented (and merge would still be, but in slightly different ways).
You access an element from before the range when populating tmpArray1:
The first element in the range is list[lb], not list[lb-1].
You're ignoringing one element at the end of the range when populating tmpArray2:
That should be list[mid + 1 + j] there.
When merging, you don't merge all elements back:
That should be k <= ub there in the loop control.
But, what rubs me most is
That is bound to fail if the array contains INT_MAX, or larger values if the element type is e.g. long long.
Using sentinel values to mark the end of the arrays is unsound, you should use the indices to detect it.
",2,14469867
14429376,"
std::set and std::multiset only provide const access to their elements. This means you cannot move something out of the set. If you could move items out (or modify them at all), you could break the set by changing the sort order of the items. So C++11 forbids it.
So your attempt to use the std::move algorithm will just invoke the copy constructor.
",8,14429167
14429610,"
I believe you could make a custom allocator for the multiset to use (3rd template argument) which actually moves the elements in it's destroy method back to the user's container. Then erase each element in the set and during its destruction it should move your string back to the original container. I think the custom allocator would need to have 2 phase construction (pass it the begin iterator passed to yourtreesort function to hold as a member, but not during construction because it has to be default constructible).
Obviously this would be bizarre and is a silly workaround for not having a pop method in set/multiset. But it should be possible.
",4,14429167
14431045,"
I like Dave's idea of a freaky allocator that remembers the source of each move constructed object and automatically moves back on destruction, I'd never thought of doing that!
But here's an answer closer to your original attempt:
This sorts a multiset of references, so they don't need to be moved out of the tree.
However, when moving back into the original range the move assignments are not necessarily safe for self-assignment, so I moved them into a vector first, so that when re-assigning them back to the original range there will not be self-assignments.
This is marginally faster than your original version in my tests. It probably loses efficiency because it has to allocate the vector as well as all the tree nodes.  That and the fact that my compiler uses COW strings so moving isn't much faster than copying anyway.
",0,14429167
14426228,"
So, it seems not not to loop forever, but executes too long. It's completely different story.
You have a couple of pessimisations in your code:
The main concern is that you pass *this, to the sorting algorithm:
std::sort takes comparation predicate by value and it copies it many times. You can see it, if you define copy constructor:
And your vector gets copied along with the object itself. 
For example, if the array size is 200, std::sort copies object 13646 times. It means, that 2700000 student copy operations involved. 
So, you should not pass *this to std::sort. You'd better define static function lessThen instead of operator() and pass it to sorting algorithm.
Further improvements:

Pass by reference, rather then by value. For example, in your lessThen function declaration should look like

Refactor your studentType class.
You'd better have 2 separate functions, returning first and last name (by constant reference). In this case you could get rid of copying names to temporary variables. Note, that when you have single function, you have to copy both first and last name, even if one name will never be used:


",6,14425788
14427472,"
I'm including this only because you should know alternatives to how you're sorting this list. Lol4t0 has already talked about the hideousness of having a comparator that is expensive to copy (and you would be hard pressed to have one more expensive than your original implementation).
The std::sort algorithms work best when given as simple a comparator as possible, with as much chance for inlining it's implementation as it can get. Ideally you implement a comparator operator function like this:
First notice the use of const references. The only time you should consider NOT doing this is if your underlying data is an native intrinsic type (such as int, char, etc.). In those cases it is actually faster to pass-by-value. But in this case, your student records are most-assuredly more efficient to access by reference (no copying). 
Regarding your specific task, yours is a little more complicated based on the fact that you're sorting criteria is choice-based. If you want to maximize sort-speed you ideally have a single, tight, cheaply copyable comparator for each choice case. Then, use the proper comparator based on that choice, determined before invoking std::sort.
For example, if you know you're sorting on last name, then:
or perhaps first name, last name such as:
This makes a partial peek at your sBinary constructor now look like this:
Notice first we're making the choice for what comparison technique we're choosing prior to actually calling std::sort. When we do, we have the clear definition of what exactly that criteria is within the custom comparator we're using, and zero overhead it managing it.
So whats the trade off? You would need four comparators (cmp_LName, cmp_FName, cmp_FNameLName, and cmp_LNameFName), triggering which to use based on your incoming choice. However, the benefit for doing so cannot be overstated: This will be the fastest way to sort your list based on choice.

Addendum: Single Comparator
If you are absolutely positively married to the idea of using a single comparator, then make it as cheap to copy as possible, and bury the choice made in the sorting condition within it as const to give the compiler the best chance of cleaning up your code. I've included a full expansion of sBinary below to show how this can be done, but I stress, this is not optimal if speed is your primary concern.
",3,14425788
14412866,"
You have an undeduced template parameter T, so you need 1) move your typename T as the first template parameter: 
and 2) to qualify your call to sort as selection_sort<int>(v.begin(), v.end()); 
BTW, here's a somwhat more generic implementation of selection sort, note it takes only an iterator and comparison function as template parameters, with the comparison function taking the value type that the iterator points to (this is C++11 code because of the default function template parameter, for C++98 compilers you need to have 2 overloads, with or without the comparison function)
The call to std::min_element is equivalent to your for loop, and the iter_swap is equal to your own swap. The advantage of using STL algorithms is that they are much more likely to be correct (off-by-one errors in handwritten code are very common)
PS: you can similarly write an insertion_sort algorithm in 2 lines using std::upper_bound and std::rotate (exercise for the reader)
",7,14412846
14412863,"
The problem is that typename T which seems not to be used, can't be deduced by the compiler. You will have to specify the types explicitly:
",3,14412846
14411212,"
This line:
Causes your vector to get initialized with three <0.0,0.0> values. Changing it to     
should fix your issue.
The code seems to work like this:
",1,14411073
15638063,"
You should measure the performance of both approaches to be sure, but it's a safe bet to assume that std::sort on an std::vector is way faster than inserting into an std::set due to locality effects and the large constants hiding in the tree insertion algorithm. Also, the subsequent lookups and iteration will be faster.
(However, std::set is better suited for supporting a mixed series of insertions and deletions/lookups/iterations. Maintaining order in vector is expensive, as each insertion will take linear time on average.)
",11,15638024
15638877,"
As a good rule of thumb, the stricter guarantees are offered, the worse performance you'll get.
Inserting into a std::set guarantees that the sequence is sorted after every insertion.
Inserting into a std::vector, and calling std::sort once after all insertions have been done guarantees that the sequence is sorted once all manipulations on the vector have been done. It doesn't require the vector to be sorted during all the intermediate insertions.
A std::vector also exhibits better spatial locality, and requires fewer memory allocations.
So I would assume the vector approach to be faster, but if performance matters to you, then it matters enough to be measured.
If you don't care to measure what is faster in your case for your data sets with your code in your application, then you don't care which is faster.
",9,15638024
15638087,"
Use the container that has the appropriate semantics for your needs. Efficiency generally follows on automatically from that choice.
If you then experience performance bottlenecks, do some benchmarking.
",4,15638024
15638232,"
It indeed does depend, but it's certain that std::set is intended for random inserts and deletes. In this case you are only inserting. Go with std::vector.
Also, perhaps more importantly, if you know beforehand how many segments there are, you only have to allocate the vector only once, it will not reallocate memory everytime it doubles in size. 
",4,15638024
15616571,"
For starters, your java code only generate random numbers until 10, and c++ is until 100, obviously there would be more swaps.. usually for this kind of testing you want to test the EXACT same array..
",7,15616521
15632785,"
Where is your c++ swap? >are you using the template std::swap(T&x,T&y)? This template is best for ""big"" types with move constructor and asignment. Try with one als in your java test using indexes.
",0,15616521
15603649,"
Actually Quick Sort has a complexity of O(N^2), and it is O(N * logN) in average, not in worst case. So using quick sort is not encouraged because there will always exist such data  on which it will work O(N^2)
",-1,15600114
15599511,"
This clears values so that it contains no elements any more. Attempting to access any elements will result in undefined behaviour and the std::sort will simply sort the empty sequence of numbers.
The definition of a.clear() where a is a sequence container is:

Destroys all elements in a. Invalidates all references, pointers, and iterators referring to the elements of a and may invalidate the past-the-end iterator.
post: a.empty() returns true

",5,15599498
15599515,"
Your program has Undefined Behavior.
In order to fix it, just remove this line:
What the above line does, in fact, is to erase all elements from the vector. Then, this line:
Will try to access non-existing elements. Unlike operator [] for associative containers, operator [] for vectors won't create any new element. Thus, the expressions values[0], values[1], and values[2] are all attempts to access non-existing elements.
Per Table 101 of the C++11 Standard:

Expression: a[n]
Return type: reference; const_reference for constant a
Operational semantics: *(a.begin() + n)

This means that by doing this:
You are actually doing this:
The call to values.begin() here returns an iterator to the first element in the array. Since there is no element in the vector (§ 23.2.1/6), a call to values.begin() is equivalent to a call to values.end():

begin() returns an iterator referring to the first element in the container. end() returns an iterator which
  is the past-the-end value for the container. If the container is empty, then begin() == end();

Therefore, values[0] in your case is actually equivalent to this:
Which is in turn equivalent to this:
In other words, you are dereferencing an iterator that points to a position beyond the last element in the container. This is Undefined Behavior, and the same applies of course to values[1] and values[2].
",6,15599498
15599599,"
I think  __median function in < algorithm > header is easier.
",1,15599498
15599572,"
When you clear the vector you are setting the size to 0. The scanf line will ususally not crash since the vector will usually have preallocated some storage where the read values are stored. The result is that when you call sort, begin() and end() will be equal.
You can try either reading the values into temporaries, or calling resize(3) before reading the vaules. 
",0,15599498
15599586,"
Your attempt to clear out the actual existing elements with values.clear(); is actually removing them from the vector completely. This has the effect of making begin() and end() equal, causing the sort to have no effect (and the input where you take the address of the various elements to have undefined behavior).
I think what you really wanted to do was make sure that there aren't too many elements in the vector, so instead of clear use resize: values.resize(3) which will have the effect of removing excess elements or increasing the size of the vector to three if it's currently smaller.
",0,15599498
15588509,"
You need to wrap your function in a binary operator, like this:
Now you can use cntBitsCmp in a declaration:
Here is a demo on ideone. It correctly orders 128 ahead of 3, because 3 has two bits set, while 128 has only one.
",6,15588428
15588557,"
Basically this could work as you want:
",1,15588428
53759901,"
Since C++11, you can also use a lambda expression instead of defining a comparison function. If you combine this with std::bitset::count instead of using your own counting function, then the code becomes rather short:
Note: Similar to the solution by dasblinkenlight, I'm assuming 32-bit integers for the sake of clarity.
Please adapt the code to your needs.
Code on Ideone
",0,15588428
15582519,"
Yes, std::set, std::multiset, std::map, and std::multimap are all sorted using std::less as the default comparison operation.  The underlying data-structure used is typically a balanced binary search tree such as a red-black tree.  So if you add an element to these data-structures and then iterate over the contained elements, the output will be in sorted order.  The complexity of adding N elements to the data-structure will be O(N log N), or the same as sorting a vector of N elements using any common O(log N) complexity sort.
In your specific scenario, since you don't have key/value pairs, std::set or std::multiset is probably your best bet.
",33,15582504
53740481,"
I'd like to expand on Jason's answer. I agree to Jason, that either std::set or std::multiset is the best choice for your specific scenario. I'd like to provide an example in order to help you to further narrow down the choice.
Let's assume that you have the following class Foo:
Here, Foo overloads the < operator. This way, you don't need to specify an explicit comparator function. As a result, you can simply use a std::multiset instead of a stf:vector in the following way. You just have to replace push_back() by insert():
Output:

3 4
  2 4
  1 5
  1 6

As you can see, the container is sorted by the member val2 of the class Foo, based on the < operator. However, if you use std::set instead of a std::multiset, then you will get a different output:
Output:

3 4
  1 5
  1 6

Here, the second Foo object where val2 is 4 is missing, because a std::set only allows for unique entries. Whether entries are unique is decided based on the provided < operator. In this example, the < operator compares the val2 members to each other. Therefore, two Foo objects are equal, if their val2 members have the same value.
So, your choice depends on whether or not you want to store Foo objects that may be equal based on the < operator.
Code on Ideone
",1,15582504
15582703,"
I do not think the functionality exists in STL, a std::vector can only sort with partition, nth_element, stable_partition, partial_sort, stable_sort and sort.
You could however create a wrapper for std::vector
",-4,15582504
15575936,"
With regards to functions:

Nullary - takes no arguments, e.g. void nullary()
Unary - takes one argument, e.g. void unary(int)
Binary - takes two arguments, e.g. void binary(int, float)
Ternary - takes three arguments, e.g. void ternary(int, float, char)
N-ary - takes N arguments

So a binary function is one that takes two arguments, such as void foo(int x, float y);. The comparison function passed to std::sort should be a binary function that takes two elements from the sequence you're sorting and returns a bool. If for example, you're sorting a sequence of X, the function should have the signature bool compare(const X&, const X&);.
Here's an example usage:
Here, less_than is a binary function that just returns true if the first argument is less than the second. This is precisely what std::less does. The power of std::sort is that it allows you to give any binary function that returns bool and it'll sort using that.
",8,15575833
15568261,"
These two pages provide some informations on both sort.

Counting sort
Bucket sort

About the counting sort:

Because counting sort uses key values as indexes into an array, it is
  not a comparison sort, and the Ω(n log n) lower bound for comparison
  sorting does not apply to it.1 Bucket sort may be used for many of
  the same tasks as counting sort, with a similar time analysis;
  however, compared to counting sort, bucket sort requires linked lists,
  dynamic arrays or a large amount of preallocated memory to hold the
  sets of items within each bucket, whereas counting sort instead stores
  a single number (the count of items) per bucket.[4]

About the bucket sort:

Bucket sort can be seen as a generalization of counting sort; in fact,
  if each bucket has size 1 then bucket sort degenerates to counting
  sort. The variable bucket size of bucket sort allows it to use O(n)
  memory instead of O(M) memory, where M is the number of distinct
  values; in exchange, it gives up counting sort's O(n + M) worst-case
  behavior.

",1,15568185
15565348,"
I think the third line of its main is doing a comparison: checking if the last element of array is the smallest/biggest to determine if the array is sorted. Although it's not the correct way, let's just assume it's doing so. Change your code from
to
Then you should be able to compile your code.
To get your code to work. Modify main as following:
Then you should input your integers like this
It should work fine unless you put the biggest/smallest integer as the last input digit.
",3,15565038
15565146,"
The ""errors"" you get is because you are comparing a value with a function pointer. You do not call those functions.
As noted by kma, you can't use these function calls in expressions, as they return void, i.e. do not return a value at all.
Even if the did return something, the first call could rearrange the array so what was previous at index four of the array will not be the same in the next comparison.
",1,15565038
15565122,"
sortlow and sorthigh in your main program are not declared int variables, but function names. C++ take this as pointers (adress) to the functions. But you compare those to integers from the arrays.
Edit: How to check if an array is sorted?
Imagine you have an array of 5 cards (from a normal deck of cards) face down in front of you. You can only turn two cards at a time and compare them and put them back face down. How do you determine if the 5 cards are in order? Write down the steps you take. Once you figured out that algorithm you can start thinking about how to express it in C++ code.
",0,15565038
15559461,"
If you're sorting ints, say, in the range [begin, end):
std::greater is a binary function object that applies > to its operands. You could alternatively provide a lambda expression:
",7,15559448
15559486,"
Write a function to compare:
then to sort, say, a vector vec, call sort(vec.begin(), vec.end(), comp)
",2,15559448
15550712,"
You have at least one major problem you are not declaring lesser nor greater to have any size:
So later on when you try to access them you are going out of bounds:
and then later on when take the size it is going to be 0:
The clean solution is to use std::vector and then you don't worry about allocation or size. You should try to enable warnings and always compile with them. In gcc when running with -Wall -W -pedantic it does not allow me to compile and it tells me:
Which tells you right away what is wrong.
",2,15550556
15550633,"
In C++ the arrays you declare are not dynamic. You will either have to use std::vector or allocate data dynamically. Otherwise these calls(In the function quickSort):
Are accessing an index out of bounds.
",4,15550556
15478982,"
You can only use qsort with types that can be copied with memcpy. std::string (and any other type with a non-trivial assignment operator) does not qualify. Instead, use std::sort. It knows how to copy objects correctly.
",3,15478104
15478829,"
I'm going to nitpick at the somewhat poor quality of your question first, bear with me.
This gives you an array of one (1) string object.

(the size of an array is growing with adding more items)

False. The size of your array might do so, because you hopefully wrote code to this specific end. The size of an array does not automatically adjust. (That is what vector is for.)

I'm putting there strings. The items in array before sorting are: novot svobodovaa novakj6 3 vondraj1234 

In one string? Or as an array of strings? In the latter case, I'd like to see some proof, like thus:
Ideally just before your line:
(I just hope and assume that size actually is the correct size of names1, another thing that my little loop above would prove.)

The real reason for your troubles is, however, this line:
You're casting string * (pointer to object) to char * (pointer to plain old data), and you are doing it C style (char*) instead of C++ style (static_cast< char * >()), so your compiler cannot even complain properly.
When you are dereferencing those two pointers, you get the first byte of the two string objects, respectively. This is most likely not the first character of the contained string, but either a jump table or machine code. Hence the somewhat random result...
",0,15478104
15463910,"
For the first question: If your array have only a small set of unique values (like 28 as you say) you may want to consider some sort of counting sort (flavors: radix, pigeonhole, bucket). If you know hard limits and ranges of your array content you may be able to do something good.
But as previously said, for such small array you are probably good with std::sort, unless you have a lot of 5000-element arrays to sort.
For the second question: Length matter (see sky's answer). O(n log n) is the best any normal sort can do. O(n^2) is normally the worst case. O(n^2) means that in worst case your 20 element array would need time corresponding to 20^2 (=400) operations, and your 5000 array time corresponding to 5000^2 (=25million) operations. As you can see larger array means much more time in this case. For your case and a O(n log n) algorithm the 5000 array would need time corresponding to 5000 log 5000 (=18500) operations. 
What an operation is and how long it takes depend on the particular implementation, and is in general irrelevant for comparison (and thus ignored with Ordo notation). A slow implementation of a O(n log n) algorithm will still be faster than a fast implementation of a O(n^2) algorithm when the array size is large enough. But for a small array like 20 elements a good low overhead implementation matter most. 400 fast operations will be faster than 26 slow operations. Same comparison for 5000 array give that 25million fast operations  would still not be faster than 18500 slow operations.
Another factor is the content of the array. Some algorithms, like insertion sort, are particularly fast (approaching O(n)) on arrays that are in almost correct order, while poor O(n^2) on random input.
By utilizing predefined (known) limitations/ranges on array content (thus not a classified as a normal sort) counting sort can approach O(n), that is, the time is directly proportional to the number of elements. See wikipedia.
Happy research!
",2,15462657
15462703,"
I makes a difference, but your best bet is to use std::sort . It internally switches the sort algorithm considered best depending on the input size.
See wikipedia references:

https://en.wikipedia.org/wiki/Sort_%28C++%29
https://en.wikipedia.org/wiki/Introsort

",1,15462657
15462730,"
You may want to search for sorting algorithms like Quicksort, merge sort, insert sort, or bubble sort.
Sorting depends heavily on the number of items to be sorted, as can be seen from the notation for sorting algorithms, 'big O notation'. Average number of different values and data type often doesn't make a difference enough in runtime to matter. An algorithm of O(n^2)(bubble sort) has a complexity of the square of the number of elements you have, telling you that it time increases roughly quadratically in regards to number of items to sort. Quicksort has O(n log n) complexity, making it one of the fastest sort methods around.
Bubblesort is the easiest to implement and the slowest in runtime.
Edit: As the comments say, short arrays of only 5000 values don't really have a big difference no matter what algorithm you use, provided it's not something like Bogosort.
",1,15462657
15453135,"
it's not going through the entire array if you decrement n within the for loop, try placing it outside of the for loop
",4,15453052
15450292,"
You can certainly improve your comparator. There's no need to copy the columns and then compare them. Instead of the two push_back calls, just compare the values and either return true, return false, or continue the loop according to whether they're less, greater, or equal.
The relevant part of the complexity of sort is O(n * log n) comparisons (in C++11. C++03 doesn't give quite such a good guarantee), where n is the number of elements being sorted. So provided your comparator is O(m), your estimate is OK to sort the n rows. Since attr.size() <= m, you're right.
",2,15450173
15450269,"
First question: you don't need left and rigth - you add elements one by one and then iterate over the vectors in the same order. So instead of pushing values to vectors and then iterating over them, simply use the values as you generate them in the first cycle like so:
Second question: can the time complexity be improved? Not with sorting algorithm that uses direct comparison. On the other had the problem you solve here is somewhat similar to radix sort. And so I believe you should be able to do the sorting in O(n*m) where m is the number of sorting criteria.
",1,15450173
15450275,"
1) Firstly to start off you should convert the string into an integer array in the constructor. With validation of values being less than the number of columns.
(You could also have another constructor that takes an integer array as a parameter.
A slight enhancement is to allow negative values to indicate that the order of the sort is reversed for that column. In this case the values would be  -N..-1 , 1..N)
2) There is no need for the intermediate left, right arrays.
",1,15450173
15424244,"
You should use j < v.size() or j <= v.size() -1 (array index starts from 0), otherwise, you have index out of bound error.
Meanwhile, it is better to pass the vector by reference to save some cost.
Another point, since you used vector, it is OK to have 18647 numbers since memory space of the vector header is allocated on Stack but elements of vector are allocated on free store.
See this thread for more information:
When vectors are allocated, do they use memory on the heap or the stack?
",2,15424228
15388662,"
Here is an example using cin.
",1,15388464
15388600,"
I think you should use 2 std::set's with some ""1-time used words"" and ""forbidden words: used twice or more times"".
So there's a word you processing: cur_word. If forbidden_words contains it, just ignore it, else check if allowed_words contains, delete it from it and add to forbidden_words, else just add it do allowed_words.
",0,15388464
15388690,"
std::unordered_set may be faster than std::set (especially if the file is large).
That's unlikely to make much difference though -- unless you write everything else extremely badly, the job is going to be heavily I/O bound, so most of your work should be put into speeding up the I/O.
How to proceed from there will probably depend on the target OS. For Linux, fast file reading mostly equates to mmap. For Windows, you generally want to avoid memory mapped files, and use ReadFile with the FILE_FLAG_NO_BUFFERING flag.
",0,15388464
15375060,"
There are several errors:
numberofitems needs to be a const and I am guessing since ListItemType is string that listofitems should be an array of strings. This is delcaring a function:
what you intend is to instantiate a List and so it should be:
This:
should be:
and this argument list is not correct:
Argument two should be a ListItemType type but you are passing in an int, this it probably what you intended:
",1,15375020
15373355,"
std::string::compare returns an int which you are meant to compare to 0 to give an actual sort order. For example, to check if a.name is less than b.name (according to the ordering given by compare) you would write:
The way that you have currently written it will return true for any unequal strings, which is not a valid strict weak ordering, as required for std::sort.
There is no good reason to use compare here at all, as std::string has an operator< that gives an equivalent ordering of the two strings:
",6,15373306
15373426,"
Have a read through the std::sort reference at cppreference.com; it clearly explains that the comparison function should return a bool which indicates the first argument is less than the second.
In this case, you would call it like this:
So, what's happening in your code? If the names are equal, compare returns 0, which is cast to false. Otherwise, you will get a non-zero integer, which will be cast to true. Since the sorting algorithm in std::sort isn't specified absolutely, we can't say why you are getting a certain order precisely, but essentially, std::sort is std::swaping objects (pseudo) randomly.
So, should you define a compare function? IMHO, no. It is quite easily to define for some basic types, but as far as I can tell, it doesn't really appear in any algorithms. It is a C-ism, and unfortunately, C++ kept it. If appropriate, define a strict weak ordering using operator< instead, or just define comparators when needed.
",2,15373306
15373372,"
sort expects its comparator to behave like operator<, whereas std::string::compare behaves as described here.
",1,15373306
15373409,"
You're returning an int which std::sort sees as either ""same"" or ""not same"". You should be returning this:
And change the return type to bool
However, have you considered this instead:
And get rid of the custom comparator you're trying to fabricate entirely. With this you can then sort a collection of students using just std::sort(students.begin(), students.end()), since the default comparator, std::less<YourType>, will invoke your operator when doing comparisons while sorting.
",1,15373306
15941102,"
I found this program (and the output) here. Have a look,
",0,15370661
15318802,"
You have to write an random access iterator to your vector<Data>, that returns a reference to iLo (or iHi, resp.).
Complete example:
Live run: http://ideone.com/gr2zSj
",3,15318412
15318805,"
Trying to coax the standard library into sorting this way will be a nightmare. 
Your best bet is to copy a simple quick-sort routine and adapt it to your specific purpose. It should only be about a page of code. 
",2,15318412
15318511,"
To sort by the iLo's:
To sort by the iHi's:
",-2,15318412
15318255,"
Generally speaking, this problem is a little strange. Most 2D convex-hull algorithms (all that I know of) give out the list of points (vertices) in clockwise or counterclockwise order, or they can be modified trivially to do so.
In any case, since there are several good 2D convex-hull determination methods that run in O(N^2) or faster, you can use one of those to ""sort"" your data into clockwise order. What I'm saying is that you can run a CH algorithm on your data and get the result in the order you want.
Here's a sample code I had lying around that I think would do what you want:
There are a few points to consider:

The above code receives its input and returns its output in the same argument: pts.
The Point structure is a simple struct (or class) with two public members x and y, and a less-than operator (an operator <) that compares them very simply based on x first and then y.
I believe the running time of the above code is O(N*log(N)), but it certainly is no worse than O(N^2).
The returned points will be in clockwise order. If you want counterclockwise, you only need to change that last two lines.
This code will not handle the case that all points have the same X coordinates (I think!)
Other than that, this is a functional and fast and simple 2D convex-hull implementation.
If there are consecutive points in the input that lie on the same line, this implementation removes them. If you don't want that, you can replace the <= 0 and >= 0 tests in the while loops with < 0 and > 0 respectively.

Let me emphasize this: although the above code is a CH implementation, you can use it just to sort your points in a clockwise winding order (if they already form a convex hull.)
",3,15317876
15318551,"
You have implemented Bubble Sort, which is O(n2). You can get O(n log(n)) by using the STL sort with an appropriate comparison functor.
Here's a first effort; it uses a non-transitive comparitor, but it seems to work in my test cases and I think it's generally correct:
EDIT:
The non-transitive comparitor wasn't a good idea. This is more reliable:
",2,15317876
15318512,"
The third-smallest element has at most two descendants, which means that its child(ren) are leaves, or it is a leaf. (To prove this, you also have to prove that it is impossible for an element with only one child to have a non-leaf as the child. Easy but tedious.)
Leaves, as you almost note, have indices in the range [floor(n/2)+1, n]. If n/2 is an integer, then that element has exactly one child (which is a leaf), so adding that gives the range of indices which might contain the second-largest element.
An element whose first child is in the leaf range [floor(n/2)+1,n] has at most two children, and no non-leaf child. That range is contiguous with the [ceil(n/2),n] range, and the union of the two ranges provides all the possible positions for the third-largest element.
The first child of the element at i has index 2i, so the first element whose first child is at least floor(n/2)+1 is floor(n/4)+1.
Thus, the possible indices at which you could find the third-largest element is the range: [floor(n/4)+1,n].

Here's another approach. Take some element at index i. Its immediate children are 2i and 2i+1; its grandchildren are 4i, 4i+1, 4i+2, 4i+3 and, in general, it's descendants at level k are 2ki, 2ki+1, ..., 2ki + 2ki-1; in summary, [2ki, ..., 2k(i+1)-1 ]. These ranges are, of course, non-overlapping (indeed, unless i is 1, they're not even contiguous). So if i has at least one descendant at level k, it also has a complete set of descendants for all k' < k, of which there are 2k-2.
From all of that, we can conclude:

If n ≥ 2ki and n < 2k(i+1), then i has:

2ki-2 descendants at some level less than k
n - 2ki+1 descendants at level k;
Total: n-1 descendants.

If n ≥ 2k(i+1) and n < 2k+1i, then i has:

exactly 2k+1-1 descendants.


Roughly speaking, this means that the last 2k elements are not found in the first 1/2k part of the heap's underlying array. 
",1,15317480
15312947,"

Is it standard C++ to first move from [begin, end) into a new container, and then move from that container back into [begin, end)?

I was initially confused by your use of the word ""standard"", and edited the question so that it was asking whether this was ""legal"". The answer to that question would be: ""Yes, it is perfectly legal"". After the elements in the original range are moved from, they are still in a valid (even though unspecified) state. 
Hence, the second call to std::move() will just move-assign elements, and the type of those elements shall have a move-assignment operator without pre-conditions. As long as this is the case, I see no problem with that.
After editing your question, though, I started to wonder whether you actually wanted to ask if this is ""standard"", meaning ""common practice"", which is why I restored the original wording.
The answer to this question is ""Partly"". You would normally initialize your temporary vector by using a couple of move iterators rather than invoking std::move:
Apart from this, your implementation seems correct to me.
",2,15312773
15312886,"
No it isn't. 
I can see how you'd need it to be a random access container if it wasn't already. In that case prefer std::make_move_iterator:
In all other cases, you'd want to be sorting in-place. (Unless you need ""no effects"" on exception, maybe)
",0,15312773
15284343,"
This initialises the pointer in the Compare object to null; so you'll get undefined behaviour (a segmentation fault in practice, if the array indexes are small enough) when you try to access the arrays.
You want
with an appropriate constructor that initialises s:
In C++11, you could leave out the constructor and initialise it with Compare{this} but adding the constructor is a good idea anyway, to make the class less error-prone.
",1,15283897
15284047,"
The compare operator is dereferencing an uninitialized pointer s.  That would likely result in an exception.
",1,15283897
15247411,"
Use insertion sort if your Array is already sorted.
 Insertion sort will give the right place for your new item in less complexity.
Else
you can use binary search against your new item in array to find the proper place in array.
after that shift all other element to make the place for new item.
",1,15245986
15233775,"
Your two ""algorithms"" are two implementations of the same algorithm called Bubble sort.
This is the most simple algorithm to do sorting but performs poorly (quadratic complexity).
If you want to dig deeper into sorting algorithms, there are great books for that, I particularly like this one.
If you just want to look at algorithms that perform faster, take a look at quicksort or mergesort. They both have advantages and drawbacks, but you can usually choose one of them depending on your application and the size of your data.
More generally, prefer std::sort which does a great job at tayloring the particular algorithm needed depending on the size of your data when relevant and possible. Only if you see you have performances issues (or for learning purposes), you can look at implementing your own sort. But you really gotta know what you're doing because it is easy to write bad-performing sort implementation (even for a good algorithm).
Edit (precision): In real life, when the array is small enough (say, less than 20 items), go with insertion sort. Otherwise, go with quicksort if you do not have more hypotheses about your data. The reason for this cutoff is that the cost of recursive calls can account for too much a overhead on small amount of data than just using a quick insertion sort.
",3,15233633
15233777,"
Neither.
The differences between using arrays and pointers is negligable in most cases. 
Both Algorithm I and II are what is called a bubble sort. It is an effective sort in some cases, but is rarely the fastest sort. 
",0,15233633
15233791,"
Both the algorithms find the bigger value, then the second etc...
so if you have N elements first run of the loop will compare N-1 element, second line in the loop will compate N-2 etc..
It called bubble sort.
It take approximation of (N-1)N / 2 compare operation.
If you use quick-sort (for example) which is binary search you will need O(N log N) operation which is critical for large number of N.
Quicksort from wiki
",0,15233633
15225052,"
Okay, let's take this from the top
Your code completely omitted the needed gaps array
The outer loop needs to be across gaps rather than 0 to array_size
You need to use the gap from the gaps array in the inner loop
You need to store temp back into the array
NB: I don't have a compiler to hand right now, so I haven't checked that, but I think it's right.
Also, a few minor points, this:
is bad practice, instead declare each variable as you use it, i.e. do this instead:
",2,15224412
15433283,"
For some reason (no comments were given), my first answer was deleted (typo - you set size to 0, not 9).  The question wondered why ""it shows nothing on the screen"".  If you set size to 0, what do you expect a for loop to do when it iterates from 0 to < size???
Before looking at the algorithm, your parameters must be correct.  Start there.  If SOMETHING now gets dumped to the screen, NOW you can start debugging the algorithm (if the output was wrong).  If the output is right, then your algorithm is probably okay.
If I am wrong about this, PLEASE POST A COMMENT TO MY ANSWER.  Don't just ""delete"" it!?!
",1,15224412
15215507,"
Overloading operator> on salesTran would be a bad idea because each field of salesTran is a perfectly valid way to compare two transactions.  People reading your code (or API!) would have to look at the documentation to find out which one is used.
Instead, you can define a comparison function and use std::sort:
A C++11 lambda function would work too if you're into that.
",1,15215341
15215395,"
The problem most likely is originating in the types of the data that you are trying to compare, for example, comparing two integers with the > relational operator will work, because it supports that type of comparison. However, you cannot compare two arrays in that way, because the built-in relational operators were not made to compare whole arrays. The only way you can get away with doing something like that is by overloading the operator itself.
http://www.cplusplus.com/doc/tutorial/classes2/
",0,15215341
15214919,"
In your swap function, temp should be an object of type salesTran object, not an int.
",1,15214895
15214949,"
You are attempting to call A as a function where you apparently want swap.
Also be aware that there are functions std::swap and std::sort which do what you want, but more efficiently.
",1,15214895
15208367,"
Be careful with unsigned data types. At some point ""i"" will be 0, and you will check ""j>=0"" which is always true. Thus creating an infinite loop.
",2,15208330
15185596,"
cmp is a non-static member function. It must be called on some object. To get a pointer to that member function you would need to do as the error says, &Sched::cmp, but you would then need to bind it to some object of type Sched†.
However, there is no reason for cmp to be non-static so just change it to this:
Then you can pass it as you are doing now.
† You could do that with std::bind(&Sched::cmp, this, std::placeholders::_1, std::placeholders::_2), to bind the member function to this.
",6,15185579
15185731,"
The other option is to a make the cmp function outside the class and inside the namespace of the class so the 
",1,15185579
15211402,"
You can start your binary search with a biased stage that favours the best case. Instead of going directly to (low+high)/2, start at position i-1, then i-2, then i-4, i-8, i-16, i-32... until you find a smaller element, or until i-whatever gets lower than low. Then continue with the ordinary binary search.
Note that this optimisation comes at a cost. The best case ---sorted or almost sorted data--- takes O(N) time, but the average case and the worst case get a bit slower with respect to the simple binary search version.
Note also that high is assigned mid and not mid+1. The case where temp==data[mid] is treated exactly as the case where temp>data[mid]. This is to keep a good property of insertion sort: it is a stable sort. It makes no difference when sorting plain integers, though.
",0,15185033
15186878,"
You can also replace the last else :else if(data[mid] == temp) with simple else
because it obvious that is is true if the former two were not true... 
",-1,15185033
15184630,"
First of all, use std::sort() which works with iterators first, last as input.
Then, use recursion. Recursion is key to your solution.
For each argument, i.e. sorting criterion C_i, you have one recursion level R_i. Within each recursion level R_i, you have two steps:

Sort the given data range according to criterion C_i.
Loop through the data range. Whenever the value C_i changes, call the next recursion level R_{i+1} with arguments:

first: iterator to the last change, or, beginning of the range
last: iterator to the current element (the first element with changed C_i)
reference/pointer to the criterion list and i+1


That's it!
Discussion of this solution:

Due to the iterators, this method is efficient, as the underlying data structure need not be re-initialized, copied around, etc.
You need to write a custom comparator functor that is initialized with i and will always compare according to element i of a vector.
It is debatable what is faster: doing one grand sort that has to go through all sorting criteria in every comparison, or sorting multiple times, as in my approach, and only checking one criterion each.
In this solution a lot of vectors are swapped. However this is not a problem, as std::vector swaps are cheap.

",1,15183953
15181402,"
If your compiler supports c++11, you can use a lambda 
without c++11, you can simplify it only a little bit by using a function instead of a functor 
and use that as the last parameter.
Unfortunately (?), there are only function wrappers for unary or binary function objects. If there were wrappers for ternary function objects too, you could do something similar to 
If you consider using boost - bind, you can try this instead 
This is equivalent to std::bind in c++11.
",5,15181378
15171171,"
I don't know if this is the whole problem or not, but you have a classic error in your input loop. file.good() doesn't guarantee that the next read will succeed, it only tells you that the previous one did. Try restructuring it like this:
The expression file >> d returns a reference to file, which calls good when you try to evaluate it as a boolean.
",4,15170410
15170500,"
Is there a reason why you can't use a few megs of memory to read the entire list in at once into RAM and sort it all at once? It would simplify your program a lot. If you are trying to do this as a challenge I would start by shrinking the problem to say like 1 file of 100 doubles, split that into 4, 25 double reads, and then it should be very easy to trace through and see where the additional lines are coming from.
",1,15170410
15170527,"
Assuming your files are in text format, you can use std::merge to do an external merge just as well as an internal one, by using std::istream_iterators.
",1,15170410
15142797,"
There may be another sortFunction somewhere (e.g. in Kitchen), which causes the above error.
Try
Similar to this question.
Also, for good coding practice, you may want to change
to
The first is passes in a copy of the object, the second just passes a reference to it.
",3,15142716
15142903,"
Looks like you have method in Kicthen called sortFunction, and compiler cannot choose proper one.
You can try this:
To resolve it, or if the function you provided suppose to be method of Kitchen class you need to fix that.
Btw:
Is the same as:
",2,15142716
15143001,"
My guess is that you declare a member function Kitchen::sortFunction. Within another member function (such as printContents), that will hide the non-member function you want to use. 
The error message suggests that this is the case; it is trying to instantiate sort for a member-function type bool (Kitchen::*)(const Ingredient&, const Ingredient&).
If the member function is not supposed to exist, then remove the declaration. If it is, then either rename one of the functions, or refer to the non-member function as ::sortFunction.
",1,15142716
15143180,"
Your sort function is:
But it should probably be:
(Note the references)
Also, as already mentioned, your Kitchen class already has a function called sortFunction() and it's taking precedence, so either use ::sortFunction() or give each function a unique and more-descriptive name.
If Kitchen::sortFunction() is the one you're wanting, it'll need to be a static member function.
",0,15142716
15140618,"
If O(logN) for each operation is acceptable, obviously boost::bimap will suffice. This works like a two-sided std::map. You can get almost the same by maintaining two std::map together or write your own wrapper (but why should you?). A binary search tree with self balancing has a O(logN) for minimal retrieval, which is slightly less efficient than a heap.
If efficiency is really that important, you should implement your own container with both a heap and a hash map. Then, maintain the mapping from name to subscription in heap array in the hash map as you swaps around in the heap. This gives insertion, deletion, reassign priority a O(logN) and minimal/maximal priority element in O(1). (which is not a piece of cake to implement but not tedious either)
",2,15139975
15140113,"
I don't know if Boost will work for you but I'd check out Boost Mutli Index.  http://www.boost.org/doc/libs/1_53_0/libs/multi_index/doc/index.html
You could keep an in index on priority to allow you get at those quickly as well as insert Elements too.  I've used boost mutli index for MRU/LRU situations similarly.  
Will output:
",2,15139975
15126581,"
If it's a one-off operation, I would use a std::vector followed by a std::sort.
As far as asymptotic complexity is involved, the two solutions should be equivalent: insertion in a set is O(log(n)), and you do that for N elements, so it's O(N log(N)) (proof).
On the other hand, insertion in a vector (provided that you know the size in advance) is O(N), and sorting is O(N log(N)), so globally it's O(N log(N)).
But: a vector requires a one-off allocation (or, if you don't know the final size, it should reach the definitive size in O(log(N)) reallocations on typical implementations); on the other hand, a set, if implemented as an RB tree, requires an allocation for each node, which means that you have to call the allocator N times - and allocator calls, in a POD container, are probably going to be one of the bottlenecks. Also, a tree typically has less cache locality and uses more memory, so all this overhead is probably going to hurt performance.
Also, big-O notation shows the functional time dependency, but hides the multiplicative constants; don't take my word for this, but I'm almost sure that N*set insertion is going to cost more than a single sort at the end due to all the extra bookkeeping to do for each element (a tree insertion often needs some work to restore the RB tree properties).

On the other hand, if you have to keep your data structure sorted (with new data coming by the by) the set is usually the correct solution.

But, as always, when in doubt profile.
",6,15126377
15121693,"
The first thing you should do is stop working with raw pointers.
std::vector<int> will be just as efficient, and far less bug prone.
Second, the file format matters.  I will assume a binary file with packed 32 bit signed integers.
The signature for read and write is now:
ifstream and ofstream have seek methods -- in particular, ifstream has seekg and ofstream has seekp.
ifstream.read( char* , length ) reads length bytes from the file at the current get position (set by seekg, and advanced by read).  If you aren't concerned with memory layout of your file, you can get the .data() from the std::vector<int>, reinterpret it to a char*, and proceed to read( reinterpret_cast<char*>(vec.data()), sizeof(int)*vec.size() ) to read in the buffer all at once.
ofstream has a similar write method which works much the same way.
While writing data rawly to disk and back is dangerous, in most (every?) implementation you'll be safe with data written and read in the same execution session (and probably even between sessions).  Take more care if the data is meant to persist between sessions, or if it is output/input from your code.
",1,15121463
15121662,"
There are no C++ standard functions to jump to lines in files. So you have to read the file line by line (with getline, for example. http://www.cplusplus.com/reference/string/string/getline/).
As far as I remember, external merge sort (the old one, designed for a computer with a few tape drives), when used with separate files, doesn't need an interface like yours - you can work sequentially.
",0,15121463
15106148,"
You could make a binary tree.  Use next as your right child pointer and freeNode as your left child pointer.
Make the first of the nodes you should sort your root.
Then, take the rest of your nodes and ""insert"" them in your new binary tree.
Edit:  Like this:
Your typedef:
Some defines to make this code easier to read:
Recursive binary tree insertion:
Edit 2: solution removed when made apparent that this was homework. Figure out out dude! 
This solution would be O(n log n) best / average case but O(n2) worst case... If the incoming list is already sorted. 
http://en.m.wikipedia.org/wiki/Tree_sort#section_1
",2,15105532
15083102,"
Both gcc and Microsoft's VisualC++ provide source code for std::sort (in header file algorithm). So, you can take a look yourself. I have investigated similar issues before. My conclusion was that the code was optimized for the general code path even to the extent of making the code more complex and difficult to maintain. Trade-offs that make sense to me.
",3,15082949
15084022,"
I'll try and explain this specific implementation, which is one of the simplest you're likely to see. It not-coincidentally also has a hard restriction of allowable numbers in input domain as well (represented by the value MAX).
Suppose we have a collection of 10 numbers. the one attribute they share is that they are all in the domain [0..5]
Now, we create a ""list"" of buckets, where each bucket is represents a collection of values from the domain; not the input array. Our domain allows for 6 possible values, so we create six buckets (which are in ""order"", in case you don't notice that):
Now walk the input list, dropping each value in it's bucket. Conceptually it looks like this when finished:
Now, just walk our list of buckets, and dump the contents in each back into the original container, replacing whatever item was there.
Seems simple, yes? So why isn't everyone doing this for all their sorts? Well, consider we expand the problem. Instead of a MAX of 6 possible values, we make the 'value' bounded by 1048576 (220 in case you were wondering), but keep the number of items sorted to just 10.
Now, given the following list:
Our ""bucket"" list looks like this:
Yeah, over a million buckets to sort ten numbers, all because that is the allowable max in our problem domain. Obviously this would not be feasible for large MAX ceilings. Sub-splitting the input range into manageable sets would be a viable solution to this (and in fact, is essentially how a radix sort works.
To answer your final set of questions, obviously if you had a reasonably small input domain, you would be hard to beat this for sort speed. For example, if we had a set of a thousand numbers, all of which were in [0..9], this would be roaring-quick. Add a few orders of magnitude to that and it would be no comparison at all. However, the price, the heavy price, that you pay, is a restricted input domain. As the domain size rises, you have to approach it from a bucket-splitting algorithm perspective, and as you do so, you start down the path toward O(NlogN). Given that, there are plenty of algorithms (heap-sort, merge-sort, quick-sort, etc..) with their own set of caveats worth considering.
A place where it would be an obvious ""win"": Suppose you have to sort a million 8-bit characters (by definition a value in [0..255] ), you will not find a faster algorithm to do it. The domain is well-defined, very manageable, and if a proper table of ""buckets"" were utilized (literally a table of counters), I can't see it being beat.
",4,15082773
15082896,"
This is what Wikipedia provides as an explanation. I hope this would be enough.

Bucket sort, or bin sort, is a sorting algorithm that works by
  partitioning an array into a number of buckets. Each bucket is then
  sorted individually, either using a different sorting algorithm, or by
  recursively applying the bucket sorting algorithm. It is a
  distribution sort, and is a cousin of radix sort in the most to least
  significant digit flavour. Bucket sort is a generalization of
  pigeonhole sort. Since bucket sort is not a comparison sort, the Ω(n
  log n) lower bound is inapplicable. The computational complexity
  estimates involve the number of buckets. 

Bucket sort works as follows:   

Set up an array of initially empty ""buckets.""  
Scatter: Go over the original array, putting each object in its bucket.
Sort each non-empty bucket.
Gather: Visit the buckets in order and put all elements back into the original array.

",0,15082773
15602283,"
The explanation given is pretty cool. So, if we have negative numbers, how do we handle that case ? One way to go about it is to keep a separate bucket list for negative numbers.
Imagine this data-set: { -5, -6, 5, 3, 6, -4 }
So here our ""bucket lists"" are the following:
List 1:
Bucket list 2:
So, if our case involves only integers our bucket lists do not even have to contain other lists. They can be just lists.
",0,15082773
33513099,"
To handle the case of negative numbers, you can select the smallest negative number and add that number to each elements in the array. 
{-5,-6,5,3,6,-4}has smallest element -6. Add absolute value of -6 to the array.
Array is now {1,0,11,9,12,2} Then sort it with the bucket array, which becomes {0,1,2,9,11,12} and to get final result add -6 to each, thus {-6,-5,-4,3,5,6}. Performance wise  this is OK as subtraction and addition of the lowest range to the array is O(N). 
",0,15082773
16225239,"
I didn't find any function to do this.
The only thing that I've found is that you can create the first array as multidimensional too.
Then use:
I hope this helps.
Kindest Regards
KooKoo
",1,15079270
15052638,"
From ""Working Draft C++, 2012-11-02"" 

23.3.5.5 list operations [list.ops]
void sort();
template <class Compare> void sort(Compare comp);
  28 Requires: operator< (for the first version) or comp (for the second version) shall define a strict weak
        ordering (25.4).
29 Effects: Sorts the list according to the operator< or a Compare function object. Does not affect the
        validity of iterators and references.
  30 Remarks: Stable.
  31 Complexity: Approximately N log(N ) comparisons, where N == size().

",5,15052586
15052608,"
Sorting does not move elements of the list in the memory, only changes the next and previous link pointers. It should be fine.
",2,15052586
15048651,"
To keep your vector sorted all the time, you should always insert new elements into proper position. As you want to pop elements in ascending order and vector provides only pop_back() method you should sort elements in descending order. so first you need to find proper position and then insert there:
",24,15048466
15047037,"
I would build a buffer of void*, sort them, then produce the output buffer.
As a first step.  Because easy.  Then write everything else and look for performance bottlenecks.
As a next step, I would see if internal sorting with full type info can be done.  Because optimal.
Failing that, a pod block pseudo reference iterator with a specialized swap.  With tomfoolery for small med and big if performance tests justify further optimization so it sorts pointers for big and data for small.
But start with KISS and do the parts that have to be hard first.
",1,15046885
15041537,"
To get rid of the O(log n) performance of set, you could use unordered_set which uses hashing (and is O(1)) (or hash_set which is essentially the same, but only supported by some compilers).
Given that you're doing (max) 15 string comparisons, you don't reach this maximum all the time, and many of these could just compare one or two characters, it's quite possible that generating the hash for unordered_set (and dealing with hash conflicts) would take longer than finding the value in the set.
Also, why not get rid of the array and just use std::set<std::string> instead? You can still return a reference all the same:
Test.
",2,15041186
15041394,"
Optimization is always possible, and occasionally very worthwhile, but for 50,000 entries I'm guessing it might not be necessary.  Give that it is actually necessary, there's a few things you could try.  
Firstly, if some entries are use more commonly than others, you could store them in a separate popular words dictionary, which you search first.  To see if this is worthwhile, store a counter against each dictionary entry, incrementing it each time the entry is accessed, and have a look at these counters over a prolonged testing period.
Another thing worth having is a fixed size array of dictionaries, say 26^3 = 17576, where the first three letters of the entry are used to select the dictionary to search.  This drops you down to o(1) for words of three letters or less, and drastically reduces your search time for the remaining entries.
",1,15041186
15041227,"
Use a map.  You won't have to search through your array/list.
",0,15041186
15041226,"
I would probably just use std::set, possibly wrapping its iterator in a small class checking for invalidation, so you can keep the iterators instead of pointers.
Don't prematurely optimize. Did you profile that code? Are you 100% sure that this is the bottleneck?
",0,15041186
15041248,"
std::hash_set i suppose is the way to go
",-1,15041186
16181883,"
The third argument is called a functor, and is something that can be called. Either a pointer to a function, a C++11 lambda, or an object instance (not pointer) with an operator() member function.
In your case, don't dynamically allocate the functor object on the heap, it's enough to declare it as a temporary object in the std::sort call:
In the above std::sort call, using CardComparer() creates an object on the stack, this object is temporary and only valid while std::sort is running. The std::sort function will call this object, which is the same as invoking the operator() function on the object.
Since this comparison functor is pretty simple, it doesn't need to store any data:
So no need for the member data fields.
",4,16181859
16170198,"
You could iterate over each std::vector and use the algorithms of the standard-library.
There is std::find
there is std::find_if
As you are working with std::string this shouldn't be a large problem.
",0,16170051
16170361,"
In your scenario it is probably better to use std::multiset< vector <string> > with comparator that compares std::vector<string> in a way you need it to. This will give you sorted container with duplicated values next to each other and cheap insert/erase.
",0,16170051
16164143,"
You seem to be doing the wrong way round as usually things are sorted using keys and queries are done using the key not using the value. However, it seems a std::map<int,int> will help you here. Simply use your value as a key of the map and your key as value(so that you can query using the value). Use multimap if duplicates are allowed.
",3,16164089
16164139,"
This are some converter tools:Please visit the following links:

http://sourceforge.net/projects/convetercpptocs/
http://www.tangiblesoftwaresolutions.com/Product_Details/CSharp_to_CPlusPlus_Converter_Details.html
http://cscpp.codeplex.com/

",1,16164089
16164299,"
Like that:
",1,16164089
16158340,"
Your hand written sort function has O(N^2) time complexity. Each element is inserted (you call addNode n times), and you require n operations to find the insertion point (giving n * n = n^2).
std::list<T>::sort() is required to have O(n lg n) complexity, which is much faster than O(N^2). (lg n grows much more slowly than n)
Your hand written sort is a variant of insertion sort.
Note that for most inputs, using std::vector and std::sort instead of std::list and std::list::sort will give faster results.

If your question is asking ""Why is the handwritten version faster?"", that depends on your input. Insertion sort can be O(n) for some inputs. (For your implementation, that happens when the elements are inserted in reverse order)
",2,16153136
16131947,"
That's because what you are passing are string literals, which are arrays of characters. When passing them as arguments to a function, arrays decay to pointers. Therefore, what you are sorting is the value of those pointers (and not the strings they are pointing to).
Try this:
This works because an overload of operator < for std::string exists, and std::sort uses operator < to compare elements when a custom comparator is not passed as a third argument (which is your case).
",4,16131934
16131945,"
You end up comparing the pointers and not the actual string contents.  One way to solve it would be like this:
",3,16131934
16132317,"
IF you like to stay with calling sort3  with const char* you can add a ""specialised"" template:
With this  sort3(""B"", ""Z"", ""A"");  also will work.
But your question ""what is happening there ?"" is already answered by Andy Prowl.
",1,16131934
16125969,"
Yes, the problem, indeed there.
Will initialize first element in a with value from double rndDbl; While you need to copy whole array.
Thru I don't see what is the point of creation of array holding doubles, only to convert them to int right after it was filled with data. Why not to fill a with data directly.
",1,16125671
16108686,"
When you create your operator< you specify the order of attributes you wish to use in the comparison.
Creating such operators is actually almost trivial with boost::tie (or std::tie if you are able to use C++11):
",6,16108617
16108789,"
There are two solutions, either you have some sort of global variable [or similar] that you can access in the operator> function, or you use sort with a ""compare function"" argument. 
The second solution would look something like this:
",1,16108617
16108821,"
Everyone seems to assume you want a constant ordering based on multiple attributes. Instead interpreting your ""then"" as that you want to sort on different attributes at different times, here is an answer for that:
You can use std::sort with a lambda.
",1,16108617
16108691,"
You want to overload operator< not operator>
There are any number of variations on this, but that works for me.
",0,16108617
16105573,"
To answer this, I have to make assumptions, meaning you could have given us more information.
Assumption 1: What you call ""2D vector"" is a vector of vectors, e.g. a vector<vector<int>>.  
Assumption 2a: the inner vectors are the rows, which means, you want to sort the outer vector by e.g. the second element of its inner vectors. In that case std::sort kicks in, which has an overload that takes a comparator as its third argument. The only thing you have to do is to write a comparator (i.e. a function, function object, lambda etc.), that takes two vectors and compares them by their N-th element. Should not be too hard.
Assumption 2b: the inner vectors are the columns, i.e. you want to sort one of the inner vectors and apply the reorderings to each other row as well. That's a bit more complicated, e.g. you could make another vector of indices 0 through N and sort that with a comparator that, given two indices i and j compares them by actually comparing column[i] and column[j]. After you have sorted that vector, you can accordingly reorder all the columns.
",2,16105320
16105403,"
The sort() Function in STL can do it for you. You just need to write a function to compare 2 cases in your vector.
http://www.cplusplus.com/reference/algorithm/sort/
After, it depends the type of sort you need, you can sort the columns one by one, then the first row.
",1,16105320
16099378,"
In various places
should be
If you had used std::vector instead of new then you would have found this code easier to write, and it would have fewer bugs and limitations. 
",0,16099229
16075857,"
Note the changes:
Output (ideone):
",1,16071617
16071990,"
This doesn't look right:
Don't you mean pivot=(end+start)/2? Or else mergeSort(str1, start, start+pivot) and mergeSort(str1, start+pivot+1, end)?
EDIT:
And your merge doesn't cope well with empty strings. You should have tested this function before hooking it up to mergeSort.
",1,16071617
16071812,"
It's been ages since I used C++, but doesn't break immediately exit the loop?  Because fromStr1 = true; is never reached in that case.
",0,16071617
16065502,"
you can implement a compare function then call std::sort.
You can also overload the < operator in your struct definition instead of writing a standalone compare function.
then call std::sort
assume that A is your struct array.
",2,16065411
16065517,"
Use std::sort with a suitable comparison functor:
then
assuming p is a pointer to the first element of an array containing sum Info objects.
But in C++ you would usually prefer an std::vector over a dynamically allocated array:
then
You don't need the typedef syntax either:
",2,16065411
16038104,"
In short: constness.
You need:
Which also means your signature for CompareByTimeStamp must be:
See here.
This is all because comparing two objects should not change them.
",5,16037969
16021244,"
You need to pass a function object or a pointer to a function that compares two nodes.  
This will allow one linked list function that can be sorted by passing a comparison function object or pointer to a comparison function.  
For an example, see std::sort.  
",0,16021189
16021601,"
Without knowing your precise requirements, it appears you are over complicating this. If you just create a new string to hold Airline + Destination + Baggage Car and insert that into a sorted list, you'd achieve your data goal.
Is there any reason you must keep your data elements in a list row separate? In other words:
Then you insert strToBeSorted. This will give you one string that can be string sorted. This makes it a simple case to simply sort all entries. You will be able to know where strToBeSorted goes as far as Airlines, Destination, and even Baggage Car goes in what order.
",0,16021189
15992591,"
Here is some code. I have tried to explain as much as I can. If you are using C++ you should try to take advantage of the containers and algorithms that are already available for you.
",0,15992366
15992503,"
If optimization is an issue for you, I suggest you use STL containers as the proper sort methods are implemented. Do not use static arrays if your code should work on every given input file. I might also add that you can first merge the two files and then sort the third one. 
",0,15992366
15990464,"
Try this..  Basically after each iteration you need to run inner loop one less then outer variable... mainly because it is already sorted
",0,15990447
15990218,"
I suggest you use a structure:
Now overload operator < to enable the sort:
Now you can create vector to hold all the names:  
And you can use std::sort on the vector.  (Look up the syntax of std::sort).
If your smart, you'll research on how to write a vector to a file, rather than posting here. (Hint:  it's been answered several times on StackOverflow).
",0,15989074
15988393,"
In your call to sort(), you are specifying the name of a function template without instantiating it:
The bare name of a function template represents a whole overload set for the compiler (where the set includes all the possible specializations of that template). 
To disambiguate, you need to instantiate compare<>() in order to provide the address of one function:
Alternatively, you can make compare a functor:
Then, you can pass it to sort() this way, without template instantiation (but you need to create an instance of your functor, although a temporary is fine, as shown below):
",0,15988345
15988416,"
This looks fine so far, you must only qualify compare with the type T 
In your compare function, you can omit 
because at that point, it is always equal. You can reduce this to just 
",0,15988345
15987541,"
The easiest approach is probably to use std::sort (from the header <algorithm>), and define an 
and then call the STL algorithm 
and then write the sorted output.
",0,15987183
15952092,"
This totally depends on what data structure you use to store the list in in C++. If you're using vectors (which locks you into a single type of data for the list) then you could do something like:
Again, vectors lock you into a single type but so long as whatever you use to store the list in there is likely going to be a copy constructor (if you're using a class of some kind) if you're using a standard array then you're going to have to copy manually.
",1,15951906
15953533,"
try this code   
in python we dont need to declare variable but in c++ we need
and this trait dont allow we be free in c++ but by template we solve this problem
for using above code :(only a example)   
",0,15951906
15937833,"
Do you have to use selection sort? You could use std::sort instead if you define a custom comparison function:
Then throw your players into a vector called players and just
This is less code and it's also more efficient (O(n log n)) than implementing a selection sort (O(n^2)).
",0,15937735
15932409,"
Your  selection sort is definitely wrong:
Your insert function deals with strings, but you are doing selection sort on integers.
defines string as ListItemType.
",0,15932275
20459901,"
I'm pretty sure that what you have implemented is the Bubble sort algorithm, instead of the selection sort algorithm.
",0,15932275
15926067,"
Two problems. First, you cannot reorder the elements of a set.  Their ordering criteria is determined upon construction, it is a fundamental part of the object.  This is necessary in order for it to achieve O(log n) lookups, insertions, and deletions, which is part of the promises of std::set.  By default, it will use std::less<Edge>, which should call your operator<.  But you could also use your edge_comparator function, like this:
Second, std::sort can only be used on random access iterators or better, and std::set iterators are bi-directional.
",1,15925976
15926027,"
std::set is a sorted associative container, so it cannot be re-sorted. The sorting criterion is applied on construction and on element insertion.
Edit: You have a set of Edge pointers. If you want this to be sorted according to your own criteria, you can instantiate an std::set with the type of a functor that performs a less-than comparison between a pair of Edge pointers as second template argument:
then
Edit 2: The question has been changed again, so it is not clear whether it deals with a set of pointers or not.
",3,15925976
15925389,"
Take a look at std::inplace_merge. You can use mergesort idea and merge each pair, then next pairs, then next… And so on until only one remains.
",2,15925326
15925603,"
You can search the vector to find the concatenation points of the smaller vectors. Then by using these iterators you can do a merge one by one.
To find the concatenation points you can look for the first element that violates the sorting criteria from the beginning. And then from that position to the next and so  on..
",1,15925326
15925562,"
Timsort looks to be just what you need -- it is an adaptive sort that looks for presorted runs in the data, and merges them as it goes.  It has worst-case O(nlog n) performance, and I expect it will do much better than that if the runs (presorted subarrays) are long.
",0,15925326
15916191,"
As @tera has already pointed out, what you're describing is a histogram.
You may be interested in the thrust histogram sample code.  If we refer to the dense_histogram() routine as an example, you'll note the first step is to sort the data.
So, yes, the fact that your data is sorted will save you a step.
In a nutshell we are:

sorting the data
marking the boundaries of different elements within the data
computing the distance between the boundaries.

As shown in the sample code, thrust can do each of the above steps in a single function.   Since your data is sorted you can effectively skip the first step.
",5,15914569
15899739,"
The algorithm you need is selection sort, you can use this to sort and copy at the same time.
",2,15899228
15899611,"
You can have a look at priority queues:
http://www.cplusplus.com/reference/queue/priority_queue/
",1,15899228
15901378,"
Heres an example of a selection sort i have done recently (in which a is a vector)
should give you enough to go on hope it helps, ask questions if u like
Edit: just to clarify this is working on a vector that already has values in it in case that wasnt clear but example with code comments i think is enough to help you IMO
",1,15899228
15891742,"
I think maybe it should be:
",1,15891661
15891712,"
The issue is that your insertion position is not right.
You should do something like the following:
",1,15891661
15887957,"
Counting sort works by calculating the target index of each element to be sorted from the value of the element itself. There are three passes involved:

In the first loop, each element is counted: for example our array has six ""A""s and two ""B""s, five ""C""s and so on.
In the second loop, the index where each element goes is calculated. If there are six ""A""s, then the first ""B"" needs to go at index 6 (in 0-based indexing). What the counting sort does is a bit more complicated in order to make the code simpler and the sort stable. In the third loop it will traverse the original array in reverse order, so in the second loop it calculates the index not of the first instance of a given value, but of the last. In our example above, the last ""A"" needs to appear at index 5, but the last ""B"" needs to go at index 6 (""A""s) + 2 (""B""s) - 1 (zero based) = index 7.  So for each value it calculates the ending index of that value. It walks the count array forward, adding the previosely calculated count to the current count. So in our count array, the value for ""A"" remains at 6 (no previous element), the value for ""B"" is 6+2=8 (six ""A"" + two ""B""s), the value for C is now 6+2+5=13 (six ""A""s + two ""B""s + five ""C""s), and so on
In the last loop, the values are inserted in their position, decrementing the indexes as we go along. So the last of the ""B""s is inserted at index 7, the one before that at index 6, and so on. This preserves the original order of equal elements, making the sort stable which is essential for Radix sort.

",1,15887784
15888795,"
For each digit we count index where it starts from in sorted array. 
Example:
array: 0 0 0 0 2 2 3 3 3 9 9

index: 0 1 2 3 4 5 6 7 8 9 10

Then c[0] = 0, c[1] = 4, c[2] = 4, c [3] = 6, c[4] = 9, ... c[9] = 9.

Index in sorted array where digit appears depends on index of previous digit and number of previous digit. Second loop counts this. 
",1,15887784
15887259,"
i see that you are trying to implement a lexicographical sorting technique(but i have did it with single 1D huge vector), well i have been there and i have implemented a function which sorts the vectors but actually it is lagging way behind the lexicographical sorting, anyways i am not sure if i can post the code here, so if you need any help i would be glad to help
PS: look into the implementation of lexicographical_sort.cu in thrust example code (i have tweaked it also but that one also is lagging behind)
The comparator function you might need in order to check from two distintive places in 1D vector (which contains all the data) is listed down (by the way, this technique is way slower then CPU) but who know you might come up with idea to improve it or use it better then i do
",1,15884056
15909939,"
i have found a reasonable method which can finally beat the CPU (not in terms of time but in terms of data elements)
actually my new method involves using of thrust::mismatch and i am attaching code for the function
The good thing about this version is that running time of this function is 2ms approx. with very large amount of data such as N = 1000000 to N = 1000, anyways i am posting the function code and do let me know if you find any of user find some other improvements which can reduce the overall running time
}
PS: i feel like i really wasted my time in order to implementing my own version of this same thing, but thrust is awsome :)
",0,15884056
15880221,"
The usual approach would be to use function overloading:
",1,15880036
15880183,"
Use function overloads:
",5,15880036
15864054,"
You missed one point:
If it is not required to use insertion sort, you'd better use stl sort algorithm.
",2,15863998
15853245,"
Sorting by distance doesn't solve the transparency problem perfectly. Consider the situation where two transparent surfaces intersect and each has a part which is closer to you. Perhaps rare in games, but still something to consider if you don't want an occasional glitched look to your renderer.
The better solution is order-independent transparency. With the latest graphics hardware supporting atomic operations, you can use an A-buffer to do this with little memory overhead and in a single pass so it is pretty efficient. See for example this article.
The issue of sorting your scene is still a valid one, though, even if it isn't for transparency -- it is still useful to sort opaque objects front to back to to allow depth testing to discard unseen fragments. For this, Vaughn provided the great solution of BSP trees -- these have been used for this purpose for as long as 3D games have been around.
",8,15853158
15853272,"
Use http://en.wikipedia.org/wiki/Insertion_sort which has O(n) complexity for nearly sorted arrrays. 
In your case by exploiting temporal cohesion insertion sort gives fastest results.
It is used for http://en.wikipedia.org/wiki/Sweep_and_prune
From link above: 

In many applications, the configuration of physical bodies from one time step to the next changes very little. Many of the objects may not move at all. Algorithms have been designed so that the calculations done in a preceding time step can be reused in the current time step, resulting in faster completion of the calculation.

So in such cases insertion sort is best(or similar sorts with O(n) at best case)
",0,15853158
25524075,"
The simple answer to the question:
Version with a predicate.
Where Pred is a strictly-ordered predicate on type T. 
For this to work the input vector must already be sorted on this predicate.
The complexity of doing this is O(log N) for the upper_bound search (finding where to insert) but up to O(N) for the insert itself.
For a better complexity you could use std::set<T> if there are not going to be any duplicates or std::multiset<T> if there may be duplicates. These will retain a sorted order for you automatically and you can specify your own predicate on these too.
There are various other things you could do which are more complex, e.g. manage a vector and a set / multiset / sorted vector of newly added items then merge these in when there are enough of them. Any kind of iterating through your collection will need to run through both collections. 
Using a second vector has the advantage of keeping your data compact. Here your ""newly added"" items vector will be relatively small so the insertion time will be O(M) where M is the size of this vector and might be more feasible than the O(N) of inserting in the big vector every time. The merge would be O(N+M) which is better than O(NM) it would be inserting one at a time, so in total it would be O(N+M) + O(M²) to insert M elements then merge.
You would probably keep the insertion vector at its capacity too, so as you grow that you will not be doing any reallocations, just moving of elements.
",49,15843525
15843694,"
If you need to keep the vector sorted all the time, first you might consider whether using std::set or std::multiset won't simplify your code.
If you really need a sorted vector and want to quickly insert an element into it, but do not want to enforce a sorting criterion to be satisfied all the time, then you can first use std::lower_bound() to find the position in a sorted range where the element should be inserted in logarithmic time, then use the insert() member function of vector to insert the element at that position.
If performance is an issue, consider benchmarking std::list vs std::vector. For small items, std::vector is known to be faster because of a higher cache hit rate, but the insert() operation itself is computationally faster on lists (no need to move elements around).
",24,15843525
25167746,"
Just a note, you can use upper_bound as well depending on your needs. upper_bound will assure new entries that are equivalent to others will appear at the end of their sequence, lower_bound will assure new entries equivalent to others will appear at the beginning of their sequence. Can be useful for certain implementations (maybe classes that can share a ""position"" but not all of their details!)
Both will assure you that the vector remains sorted according to < result of elements, although inserting into lower_bound will mean moving more elements.
Example:
",7,15843525
15843727,"
Instead of inserting and sorting. You should do a find and then insert
Keep the vector sorted. (sort once). When you have to insert 

find the first element that compares as greater to the one you are going to insert.
Do an insert just before that position.

This way the vector stays sorted.
Here is an example of how it goes.
",1,15843525
15843955,"
When you want to switch between sort orders, you can use multiple index datastructures, each of which you keep in sorted order (probably some kind of balanced tree, like std::map, which maps sort-keys to vector-indices, or std::set to store pointers to youre obects - but with different comparison functions).
Here's a library which does this: http://www.boost.org/doc/libs/1_53_0/libs/multi_index/doc/index.html
For every change (insert of new elements or update of keys) you must update all index datastructure, or flag them as invalid.
This works if there are not ""too many"" sort orders and not ""too many"" updates of your datastructure. Otherwise - bad luck, you have to re-sort everytime you want to change the order.
In other words: The more indices you need (to speed up lookup operations), the more time you need for update operations. And every index needs memory, of course.
To keep the count of indices small, you could use some query engine which combines the indices of several fields to support more complex sort orders over several fields. Like an SQL query optimizer. But that may be overkill...
Example: If you have two fields, a and b, you can support 4 sort orders:

a
b
first a then b
first b then a

with 2 indices (3. and 4.).
With more fields, the possible combinations of sort orders gets big, fast. But you can still use an index which sorts ""almost as you want it"" and, during the query, sort the remaining fields you couldn't catch with that index, as needed. For sorted output of the whole data, this doesn't help much. But if you only want to lookup some elements, the first ""narrowing down"" can help much.
",0,15843525
15843629,"
Assuming you really want to use a vector, and the sort criterium or keys don't change (so the order of already inserted elements always stays the same):
Insert the element at the end, then move it to the front one step at a time, until the preceeding element isn't bigger.
It can't be done faster (regarding asymptotic complexity, or ""big O notation""), because you must move all bigger elements. And that's the reason why STL doesn't provide this - because it's inefficient on vectors, and you shouldn't use them if you need it.
Edit: Another assumption: Comparing the elements is not much more expensive than moving them. See comments.
Edit 2: As my first assumption doesn't hold (you want to change the sort criterium), scrap this answer and see my other one: https://stackoverflow.com/a/15843955/1413374
",-1,15843525
15833384,"
So for some reason you choose to not use std, ( you have both swap and sort)
I would like to note your attention to:
You need to make sure your indexing does not go over the array bounds..:
(Btw take a look at std::swap, might be nicer for you to use)
",1,15833297
15833386,"
There's an obvious out of bounds issue, when you do array[count
+ 1] (when count == size - 1).  And I don't see how the code
is going to sort anything.  What algorithm are you trying to
use?
",1,15833297
15833428,"
For starters, you'll get an index out of bounds exception when you reach the end of your array. Since you are accessing count+1, your for loop needs to stop at size-1. This looks like the beginning of a bubble sort, but is incompletely implemented. Do a little research into bubble sort and you should get your answer pretty quickly.
",1,15833297
15818658,"
The problem is due to how std::copy works.
The second parameter marks where to stop copying, and your parameter
represents ""The end of the stream"".  The first call to copy is reading the entire stream.
Use std::copy_n instead to copy a certain quantity.
From comment:

Is there also a way of using the second parameter of copy to get three numbers? 

That's precisely what it's for.  For some number n, if you want to copy n values, use std::copy_n.
",2,15818603
15799400,"
What is better? One way is: If the prime[] locations are known at compile time, then we could add a prefetch to get the cache lines in ahead of time. 
This is making the memory access time better.
",0,15799179
15799312,"
You can either do this when you read (or copy) values into the array, using a prime function that tells you if a number is prime or not.
A way I sketched quickly is to generate prime numbers until they reach your array capacity and simply  iterate through them and copy the desired elements from your a array. I can think of several ways of optimizing this, such as having a ""preprocess"" function that generates prime numbers in your program so you can reuse the list. 
The prime number list will get cached and it will take a lot less time to be accessed(it s unlikely that you have an extremely huge prime number list)
",0,15799179
15801860,"
Let's look at this from an algorithmic perspective. 
You want to perform a hash function on each of the entries in array A. Assuming that you know nothing about the state of the items in array A, then that places the lower bound of run time for the algorithm at O(n), linear time. You must iterate through every member because you don't have any more information that could assist you in ""skipping"" some elements or optimizing the process.
That said, the challenge then becomes keeping the algorithm down at O(n). The code you demonstrate does do this, assuming you then follow up with copying the non-prime numbers in the same manner. So for the copying step, no there is not a way to make this any faster from an algorithm point of view. That doesn't mean that how you perform the hashing step won't affect the speed, though. 
",0,15799179
15786367,"
Could use a Radix Sort and there is a very nice article on linked list sorting more efficient than performing a node to every other node comparison in O(n * n) time here.
",1,15781436
15779711,"
I wrote this after getting an idea about how qsort works. I do think qsort is not that easy to understand. It would probably need some optimalization, and is probably no where compared to the original qsort, but here it is. Thanks for peaple who tried to help with this.
",1,15769337
15734886,"
You need to pass an instance of compare_by_word. This is done by calling its constructor:
Live Demo
I also see that you're not compiling with any headers that introduce an object with a begin or end method. These are commonly used in vectors and other dynamic containers. So I think you should try passing the address range instead as feasible alternative:
Live Demo
Or if you're compiling in C++11 you can pass a lambda callback in place of an explicit functor and use the begin and end library functions instead of the address range:
Live Demo
",1,15734850
15734872,"
You're passing the type as comparator. You need to pass object of compare_by_word as comparator to sort.
",2,15734850
15734904,"
An alternative would be
",0,15734850
15734954,"
There is an error in sort statement.Replace it by:
DEMO AT IDEONE 
",0,15734850
15728728,"
What you're proposing is sometimes called a look-aside table; a
secondary table used for various lookup purposes.  In your case,
you have a number of different possible ways of organizing this
table.  The most obvious is to not organize it, and use linear
search to see if the next element is already known.  Since the
table will end up containing some 30000 elements, that's 
probably not a good idea.  From the standard library (at least
in C++11), there are two possibilities: std::set and
std::unordered_set.  std::set uses some form of balanced
tree, so makes at most lg n comparisions for each
lookup (around 15 for 30000 elements); std::unordered_set is a
hash table, and with a good hash function, will require as small
constant number of comparisons: you should be able to get it
down to under 2 on the average (but possibly at a cost of more
memory—the lower the load factor, the less the probability
of a collision).  As you mention, you do have the extra cost
of calculating the hash function, and as you point out, this
does involve visiting each element in the vector; in the binary
tree, all that it required in each comparison is that enough
elements are compared to determine order—in many cases,
that may be just one or two.  (But if you say that there are a
lot of duplicates...  you cannot detect a duplicate until you've
visited all 30 entries, since any one may vary.)  The only way
to know which solution will actually be faster is to measure
both, using typical data; for a data set such as you describe
(many duplicates), I suspect the hash table will win, but it's
far from certain.
Finally, you can use some sort of non-binary tree.  If you can
really limit the values to a specific range (e.g. -100..100),
you can use an ordinary vector or array with pointers to the
subnodes, indexing directly with the element value, transposed
as necessary.  You then just walk the tree until either you find
a null pointer, or you reach the end.  The maximum depth of the
tree will be 30, and in fact, every element will be 30 deep, but
typically, you'll find that the element is unique before getting
that deep.  I suspect (but again, you'ld need to measure) that
in your case, with many duplicates, this will in fact be
significantly slower than the previous two suggestions.  (And it
would be a lot more work on your part, because I'm not aware of
any existing implementations.)
As for hashing, just about any form of linear congruent hashing
should be sufficient: FNV, for example.  Most of the
documentation for such hashes concerns strings (arrays of
char), but they tend to work just as well with any integral
type.  I've generally used something like:
My choice of 127 as a multiplier is largely based on speed in
older systems: multiplying by 127 is a lot faster than most of
the other values which give good results.  (I have no idea
whether this is still true.  But multiplication is still a
relatively slow operation on many machines, and the compiler
will convert 127 * x into something like x << 7 - x if that
is faster.)  The distribution with the above algorithm is about
as good as that for FNV, at least with the data sets I've
tested.
",3,15728266
15728300,"
A radix map would be ideal, but you would need to implement it as there is not an implementation in the std library.
",1,15728266
15728985,"
Calculate a CRC representation of the values in the first vector.   You now have one number which represents your 30 values.  That number is likely to be unique with respect to the rest of the vectors but it is not guarenteed.
Take the CRC value as the key, and a pointer to the actual vector and insert it into a multimap {CRC, VectorPointer}.
Now for each remaining vector calculate the CRC, and look that up in the multimap. 
If you don't find it, insert the {CRC, VectorPointer}.  If you do find it, iterate though the matches and compare the data elements to decide if it is identical.  If it is discard the new vector.  If it is not, then insert the {CRC, VectorPointer}.
Rinse and Repeat until all 30,000 vectors have been processed.
You have your unique set iteratable in the multimap.
",1,15728266
15729001,"
Let's say that you have N vectors of length K, and there are only M unique of them. 

Hashing + hashmap

You can calculate the hash of every vector in O(K) time, check whether you already have such a vector in your hashmap and inserting new vector in O(1) time both. For hash function you can simply use polinomial hash without modulus, just storing hashes in 64-bit type and ignoring overflows. Implementation is very simple and it will work in O(N*K) time requiring O(M*K) memory. If you need to sort the elements first, the time will be O(N*K*log(K))

Radix tree

I think you should not use radix tree here because you will still need to look through each element of each vector. That is so because if you don't have such a vector in a tree you'll need to insert all of its elements, and if you have such a vector you'll need to go down to the leaf of the tree to see that you have really inserted such a vector before. So the asymptotiсs remain the same, but you'll need to implement the tree by yourself and it is not a very good idea :)

Looks like it is easy to show that you need at least to read all the elements of vectors. That is so because in every moment you have two possibilities - you have found current vector before and you need to read all its elements to the end to identify it, or you haven't found current vector before and you need to read all its elements to sort and save them. Yet if vectors were already sorted, you will need to read elements only to the first mismatch. But lets imagine that first 30000 vectors were unique, then you'll need to read all others vectors to the end to determine that they are not unique, no matter what algorithm or data structure you'll use. And finally we get that you need to read almost all the vectors to the end :)
If your values are really in range (-100, 100) and there are only 30 values in vector, you can notice that such vector can be saved in four 64-bit integers because you have only 8*30 = 240 bits of data in it. But it is just another idea to play with, and I don't think that any implementation using it will work faster than hashing + hashmap.
",1,15728266
15729546,"

Hashing: ... A drawback I see is that every component of every vector is touched at least once. This seems too much already.

In the worst case, how else can you compare two vectors without looking at both at least once? No, really, if you have 1,1,1 and 2,2,2 the comparison/matching ends immediately. But if you have 1,2,3 and 1,2,3?
Anyway, here's one way you could solve your problem. The implementation can be definitely improved.
Output (ideone) in 1.12 seconds with 12848 kB RAM used:
Now, the same with fewer and shorter unique vectors, so they can be printed in the console:
Output (ideone) in 0.14 seconds with 3040 kB of RAM used:
",0,15728266
15720751,"
Instead of strcmp, compare your strings using collation order, by calling strcoll.
",3,15720717
15720778,"
Use strcasecmp as the sort order is to ignore the case of the words.
",1,15720717
15719498,"
The call to compare() at the end is wrong, it returns an int that can be -1, 0 or 1 like strcmp(). Use a simple call to std::less()(a_filename, b_filename) instead. Also make sure you have unit tests that make sure the comparator creates a strict-weak ordering, as is required for std::sort.
Comparator with internal checking:
If NDEBUG is defined (i.e. assert() deactivated) the compiler should be able to optimize this to the same amount of code as before. And now, I wish you much fun writing the code that sorts the filenames 9.png, 10.png and 11.png in that order. ;)
",2,15718581
15701161,"
Looking at the above data, if we process each line backward, then the problem would become quite easy:

Split the words on one line. Say the number of words is N. 
The last word is  email, i.e words[N-1] => email address
The second last is studentid, i.e words[N-2] => student id. 
Likewise, third last is gender, fourth last is phone, and the remaining words make the name. 

That gave you enough hint. 
Code:
Input:
Output:
Online Demo

Demo at Ideone

Now spend some time to understand the code. The code I showed you is written using C++11. It demonstrates many idioms of Modern C++.

How to read file. Line by line.
How to split a line, and populate a vector of strings.
How to fill the struct (problem specific)

Hope that helps.
",4,15701015
15701234,"
This have a problem with spacing between two words is greater than 1 space ' '.
",0,15701015
15690836,"
If you make a copy of the array then copy to it, it will be slower and use more memory.
Say you have a array with N spots and I is the index where your new item goes.
Copying the array means you use N more memory and copy elements N times.  If you just shift the records, you use no more memory and perform N-I operations as you only need to shift elements after the new one.
",2,15690614
15690774,"
No it wouldn't be faster to create a new array.  It would be faster not to use a bubble sort though.  Instead use something like a quick sort.  Just google quick sort c++ to see the hundred examples of it out there.
",1,15690614
15690814,"
It sounds like you are trying to create your own sorted list. 
Your current code, which shifts the elements after the insertion, is the best that you can do when inserting into an array. You will only need to create a new array whenever you run out of space in your current array, if you want the capacity of your list to change.
EDIT:
This is one of the costs of using an array based list (as opposed to a linked list) - insertion takes linear time O(N)
",1,15690614
15690822,"
If you need it for real life, use STL qsort (http://www.cplusplus.com/reference/cstdlib/qsort/).  If you need it for homework, creating a new array will be costly because of the time to run malloc.
",1,15690614
15690678,"
It's better to check out STL data structures in your case.Try heap sort or quick sort, if you can't use STL.
",0,15690614
15690788,"
If you are not allowed to use STL containers and algorithms, you can still put records into vector and then code your own quicksort or merge sort, which is straighforward. Quick sort is more efficient than bubble sort or selection sort.
FYI:
http://www.algolist.net/Algorithms/Sorting/Quicksort
",0,15690614
15690895,"
The code will be much faster if you change your loop to go from the top down to the insertion point instead of from the insertion point up to the top. With that change, you only need to do one copy for each position instead of three.
",0,15690614
15691217,"
As has been mentioned in other posts, inserting within the same array should be faster than copying the whole array everytime.
On the other hand, the way you are describing of inserting is akin to insertion sort. One insert operation will cost you O(n). Using a heap to manage your array will make insertion cost O(log n), but may be slower for small array sizes. See http://en.wikipedia.org/wiki/Binary_heap
",0,15690614
15669996,"
As (like in C) array can be casted to pointer to the first element (but please, do not confuse array with pointer) you can use pointers to determine begin and end, so you write:
or if you use C++11 (or Boost) you can use array class:
",6,15669900
15669962,"
Pointers can act as iterators, so you just need pointers to the beginning and just past the end of the array.
",6,15669900
15669993,"
You can use sort() for an array. Pointers act as iterators.
Example:
and the output is:
",3,15669900
15670011,"
",0,15669900
45039011,"
We have to use sort function to sort the string array.
",0,15669900
46688323,"
The free functions std::begin() and std::end() (since C++11) are specialized for array types, but the size must be known to the compiler:
If you have only the start and (run-time) size, then you can use pointers as the iterators:
",0,15669900
15651274,"
This compares a Tuple against a Tuple* 
You should change it to this:
",3,15651178
15651207,"
You need of an operator that compares const Tuple* to const Tuple*. Inside the Tuple class declare:
and implement it as a regular function.

Edit
If your vector is std::vector<Tuple> then you should implement:
instead of your pointer version.
",2,15651178
15640254,"
Provide a suitable comparison binary function and pass it on to std::sort. For example
then
Alternatively, in C++11 you can use a lambda anonymous function
",6,15640202
15640244,"
You need some comparison function that you can pass to std::sort:
As you can see, it takes two sentences and returns true if the first word of the first sentence is ""less than"" the first word of the second sentence.
Then you can sort allSentences very easily:
Of course, using this comparison means that sentences like {""hello"", ""world""} and {""hello"", ""friend""} will compare equal. But that's what you've asked for.
",3,15640202
15640415,"
Generally, there are three different types of scenarios for comparison implementations you should consider.

A comparison of your object that makes always sense. It's independent from the scenario in which you want to compare objects. Then: Implement operator< for your class. This operator is used whenever two objects are compared (with <, which the standard algorithms do). (For single scenarios, you can still ""overwrite"" this behavior using the other methods below).
For this, extend your class with the following function:
Then, just call the standard sorting algorithm on your vector of sentences without other arguments:
However, your scenario doesn't sound like this is the best method, since comparing by the first word is something you don't want to have always, maybe only in one case.
A comparison of your object which will be used only once. In C++11, you have lambda functions (anonymous, literally inlined functions), which can be passed directly to the algorithm function in which it will be used, like std::sort in this scenario. This is my favorite solution:
In C++03, where you don't have lambdas, use to the 3rd solution:
A set of different, re-usable comparison methods, maybe a parameterized comparison function. Examples are: Compare by the first word, compare by length, compare by something else... In this case, implement the comparison function(s) either as free-standing functions and use function pointers, or implement them as functors (which can be parameterized). Also, lambdas stored in variables do the job in this case.
This method has the advantage to name the comparison methods, giving them a meaning. If you use different comparisons for the same object, but re-use them, this is a huge advantage:


",3,15640202
18246606,"
If you have an interval (range or array), the number of times you'll have to split the interval in half before you end up with an empty (or one element) interval is log(2,N), that's just a mathematical fact, you can work it out easily, if you want. If all goes perfectly well with quicksort, it should recurse log(2,N) times, for the same reason (and at each recursion level, it has to process all values of the interval, which leads to a O(N*log(2,N)) complexity for the overall algorithm). The problem is that quicksort could require many more recursions (if it keeps getting ""unlucky"" with picking pivot values, which means that it doesn't split the interval in half, but in an imbalanced way instead). At worse, quicksort could end up recursing N times, which is definitely not acceptable for a production-quality implementation.
Switching to heap-sort at 2*log(2,N) is just a good heuristic in general, to detect a much too deep number of recursions.
Technically, you could base this on the empirical performance of heap-sort versus quick-sort, to figure out what limit is the best. But such tests are highly dependent on the application (what are you sorting? how are you comparing elements? how cheap are the element swaps? etc..). So, most one-size-fits-all implementation, like std::sort, would just pick a reasonable limit like 2*log(2,N).
",2,18246430
25514752,"
What @Mikael Persson said regarding why the depth limit is 2*log(2,N) is partly correct. It is not just a good heuristic, or a reasonable limit. 
In fact, as you have probably guessed (depicted from your second question), there is an important mathematical reason for this: in tilde notation (search for tilde notation), quicksort makes on average ~2*log(2,N) comparisons. In big-oh notation, this is equivalent to O(N*log(2,N)).
That is why introsort switches to heapsort (which has asymptotic O(N*log(2,N)) complexity) when the depth of the recursion becomes more than 2*log(2,N). You can think of it as something which is not usual to happen and most probably means that something went wrong with the pivot picking and quicksort alone would lead to O(N^2) complexity.
You can find a short mathematical proof of the average number of compares quicksort does here (slide 21).
",0,18246430
18222576,"
You haven't shown us any code, so I'll write pseudocode:
",3,18222066
18213019,"
You could create a special iterator that acted as a iterator over an array of the corresponding elements to the vector you are sorting by. You will have to create your own reference type as is the case in std::vector. You are going to want to make sure you get move semantics (assuming you are using a modern compiler) right as this will require a whole array of items to be moved and you really don't want that to mean a copy IMO. Assignment for this reference type would iterate over a row of the different vectors, assigning the corresponding value from the other reference's row to the new one.
So to recap, you need a special reference type that can treat a row across vectors as a single object and an iterator type over these rows. If you get that right sorting should work with plain old std::sort. It will also give you an interesting view over the vectors that might come in handy elsewhere.
",0,18211741
18201598,"
Try to add const to your operator()
Also as you have captured by yourself already, myReference should be const as well
",1,18201444
18194983,"
At least if I understand what you want correctly, I'd do something like this:

Read a line into a string with std::getline.
Initialize a std::stringstream from the string
Read words from the stringstream into a vector
Sort the vector
Write the sorted words to the output.
Repeat until done.

",2,18194931
18195034,"
What you're looking for is a lexicographical sorting algorithm. Which means, sort word's just like in dictionaries, with alphabetical order.
Standard c++ supports that algorithm. Take alook here: http://www.cplusplus.com/reference/algorithm/lexicographical_compare/
In order to access the implementation just #include <algorithm>
",1,18194931
18195147,"
I'm assuming you want to write an algorithm that will do this, rather than use anything at all that's pre-written.
Once you have the strings in the vector, now you need to separate each one into words. So you would want to loop through each character in each string in the vector, find the spaces (or whatever delimiter your file is using), and then put everything before each space into another vector. And delete everything you find before each space from the string once you record it, so that it doesn't show up a second time. 
Now you have a vector of words. Then just sort that vector the same way you're currently sorting text_file.
",0,18194931
18180972,"
",3,18180880
18180968,"
Just use std::sort. I've used in programs which ran close to the 2GB process limit. ""A million"" elements perhaps sounds like a lot, but at 8 bytes that's still only 8 MB. It might even fit in cache.
",3,18180880
18181143,"
I'd personally use std::sort or similar, but I wouldn't be sorting huge elements directly in a std::vector. I would sort references to my big elements with the comparator. Each reference would be a simple container with a smart pointer to a big element.
You can also think of using std::map as a container which automatically gives you the sorted sequence.               
",1,18180880
18161797,"
A few notes about your implementation:
Firstly, To simplify your Q_Sort method and the logic, I would return an iterator from the partition method rather than an int. This will simplify the Q_Sort as below:
Please note that you do not need the check  ""if (length < 2) return;""
Secondly, in the partition method in for loop your terminating condition ""j != end+1"" does not match the pseudocode. It should be end - 1. Here is the new code for the Partition method. Please note that I am assuming the second parameter (end) points to the actual last value rather than pointing to the value beyond last.
Lastly, I believe the pseudocode assumes the second parameter to be the last element but the iterator numbers.end() points to the position beyond last element. So you will need to change the call to quick sort as below:
After considering the above points you should be able to sort correctly.
",1,18160762
18162060,"
In almost ever quicksort() algorithm that fails, the overwhelming culprit is the partition algorithm that is failing to properly exclude the pivot slot or incorrect math on the low and high side therein. This is no different. See an example live that does in-place partitioning.
In your case, I would ensure that your parition algorithm assumes the region being partitioned starts at begin and ends at the element prior to end In other words this:
should be this:
The second overwhelming cause for failed quicksort() is failing to skip just the pivot from the previous partitioning run. if you do the right thing mentioned in the code before, then this:
Should actually be this:
Remember, C++ iterators run to end(), which is the first element after the last one you want anyway, so no -1 is needed. Given a sequence such as.
and suppose the pivot slot was at the fourth slot (pivot=3), then 
I know it may seem odd, but if you accidentally did NOT want to skip the pivot slot, then the calls would look like this:
which is another common mistake in quicksort() implementations.
Work on these fundamentals and you should be good.
",1,18160762
18227307,"
You can put your data into a vector and sort it.
Here is outputs:
",0,18151322
18129209,"
Since you want to allocate memory dynamically you must use new and delete in c++. So instead of char Coul[COLORS][LINES]; use these lines:
and at the end add these:
It should compile, but I couldn't get pass the &N part, because I couldn't understand what you were trying to do.
EDIT:
Done!
EDIT2:
If I was right to assume that opening file does not load it all into RAM, then below is RAM friendly code adapted to old code, which uses temporary files as buffers (it may be a little slower and you need more disk space).
EDIT3:
Changed potentially unsafe string._Copy_s() to newly discovered string.substr()
",2,18125026
18134519,"
With the contents of the priority.csv file being:
This is the expected result:
",0,18125026
18116341,"
You are incrementing the wrong value, n++ should be pass++. Meaning right now, you're accessing out of bound indices in your array.
",7,18116297
18112870,"
In C++, you can have custom comparator functions that specify how to decide whether one element goes before another when sorting. In your case, given 2 pairs, you want the one with the lower value for the first element to go before the other one. You can write a comparator function like so:
Now, pass this function into your sort method:
",28,18112773
18112873,"
Note that you do not need a custom comparator because the default comparator of pair does the thing you want. It first compares by the first element and if they are identical, it compares the second element in the pair.
",30,18112773
18102238,"
Sort by the first character.  This gives you some number of ""buckets.""  Sort each nonempty bucket starting with the second character.  Repeat until the whole thing is sorted.
",3,18101937
18061923,"
The first two errors look like you're calling getStartPoint() on a const object, and the member function isn't const. To fix that:
The second two are because you haven't included the header that declares std::sort:
",4,18061838
18061893,"
It looks like you need to provide a const overload of node::getPoint():
Besides that, you need to include the <algorithm> header for std::sort.
",1,18061838
18061975,"
and declare your function as const
because you are calling it on const node, only functions declared const might be called on const object. Such a function cannot change any class members (except declared as mutable).
Declaring a member method results in a function declaration that takes a member pointer as a first parameter.
For example:
results in 
but:
results in 
thus the error

error C2662: 'node::getStartPoint' : cannot convert 'this' pointer
  from 'const node' to 'node &

",0,18061838
18057470,"
I figured someone might actually need to sort an array of pointers in a sane way:
The ugly middle loop is totally replace'able by range for over zippped range, but I don't have my own implementation with reference semantics right now, and I am too lazy to check the Boost one.1
Here's a live sample on Coliru.
Also, because I think we should repeat this over and over until newbies understand it:

Don't reinvent the sorting wheel (unless it's a toy implementation)
Try to avoid using pointers in C++ if reasonably possible.


1This is actually important in order to make sure both ranges (in this case two arrays) have the same length. Different zipping conventions either require the ranges to be of the same length (crashing or throwing otherwise) or fill in the empty data should one of the ranges be too short. While seemingly obvious in such a simple program, be careful in real-world code.
",9,18052204
18053376,"
If your array c[n] has for range [1 .. n], you can use the following algorithm which work in O(n) time complexity:
The idea behind it is to assign the value 1 to the pointer newptr[0], 2 to the pointer newptr[1], ..., and n to the pointer newptr[n-1]. There is no algorithm that is more efficient (especially in C++11, since std::swap will use std::move).
So for int c[8] = {3,1,5,7,8,2,6,4}, you get (disregarding the reference to value table):

1233
Success!45678


Update: If you want the reverse order:
For int c[8] = {3,1,5,7,8,2,6,4}, you get:

8765433
Success!21

",3,18052204
18057173,"
Popular approach is to implement generic sort function that sorts elements with given comparator, so you can abstract over array elements. There are some ways:
Last way is preferable because you can abstract over container type too.
",1,18052204
18052457,"
Change this first:
for(; j > -1 && *newptr[j] < *newptr[j+1]; j--)
into
for(int i=j; i > -1 && *newptr[i] < *newptr[i+1]; i--)
It seems alot more efficient..
",0,18052204
18051222,"
Order matters.
Change
to:
Presumably the bug is something that causes the code to crash. This happens because the expression in the for loop is evaluated left-to-right. So *newptr[j] is evaluated before checking if j != -1. So it's conceivable that, at some point, j is equal to -1 when *newptr[j] is evaluated, which is illegal.
Changing the order does make a difference for a second reason: short-circuit evaluation.
When evaluating two an expression made of two conditions A and B, C++ does not always need to evaluate both conditions.
For example in the statement
if A is evaluated to be false, then obviously A && B cannot evaluate to true regardless of what B evaluates to. So B's value is never even checked. So in your case, in the expression 
if j != -1 is false, C++ will not need to evaluate the rest of the expression in order to know that the whole expression is false. So *newptr[j] never happens and you don't get the bug.
",8,18051199
18051316,"
As pointed out by maditya the problem is that the expression tries to access an invalid index before checking the index itself but I see the question is tagged C++. Do you have any explicit reason to not use STL?
or even shorter in C++11:
",5,18051199
18044034,"

getSigma() returns std::vector< char >

Make sure your getSigma() function returns a reference (std::vector< char >&) rather than a copy!
",5,18043898
18044028,"
Make sure dfaVector isn't empty.  Also make sure getSigma() returns something constant (a reference).
",0,18043898
18029128,"
pairs by default compare by first element, then second. So, if you don't care about preserving the order when the first elements compare equal, then you can just use std::sort:
",8,18029110
18029137,"
std::pairs comparison operators compare pairs lexicographically, it first compares the first elements, then the second elements if the first elements are equal.
Here is an example of using std::vector<std::pair<int, int>> and std::sort.
Using std::sort that way uses std::pair's operator <, which, as said above, compares the pairs lexicographically.
UPDATE: Here is an example using std::stable_sort and a custom comparison function that compares only the first element.
By using std::stable_sort, you are guaranteed that the relative order of equal elements are preserved. That is, even if the first elements of the std::pairs are equal, the original relative order is still retained.
",1,18029110
18005448,"
From looking at your code, ""character"" is declared as a char which means it can only store one byte of information. Yet later on you start using it as if it was an array of characters.
You are also declare ""cipher"" as a char array that you manual manage like a string which is error prone. The real issue however is that you're mixing C-like code in C++. In other words, the way your code is written isn't considered idiomatic C++.
Pixelchemist already went over the important points so I'll just present a minimal refactored working example of your above code:
You'll notice in the refactor that I've done away with char and char[] arrays altogether and replaced it with std::string. I'm also performing the cipher operation inplace on the plaintext input. This is done by making a reference alias to plaintext called ciphertext for readability. Also in my example, the shift is done randomly for prototyping but you should change it to take it as a user input instead.
",0,18003975
18004597,"
To make it short: You're on c++ so just don't use the whole C stuff.

Don't use character arrays, use std::string
Don't use islower(char) but use std::islower(char,locale)
Don't use C-style arrays but std::array (compile time constant size) or std::vector (dynamic size)

You'll want to have it more like this:
This solution requires C++11 support. If you do not have C++11 you can replace the loop with:
",2,18003975
18004369,"
You are working with a single char, thats e.g. just one letter or a number. So the whole thing with size handling is useless, because the size is always 1. You probably should use const char*. But then you can't use filestream.get() at all, because it only returns a single char (not and cstring aka const char*).
And you can use fstream.get() as condition for the loop, so you don't need to ask for the eof flag.
or
for dynamic arrays in C++ use std::vector or std::list or ... one of the other STL containers, so you don't have to waste your time on memory management and using static sized arrays.
And std::string is the way to go for strings in C++. It is something similar to the STL containers, but just for char's.
",0,18003975
17963997,"
The main problem is that the arrays (b and c) passed to merge are not sorted.
Other problems are that the algorithm is not recursive and that merge
does not always put all numbers from b and c into a.
A version that seems to work with minimal changes to your code would be
",4,17963718
17964426,"
It is conventional to call merge_sort recursively in order to sort each subrange until the subrange is just one long then merge these together.
In your mergesort, b takes the first n/2 values of a, that is 5 and 4.
c takes the remaining values 3,2,1.
You then call merge (BTW Why do you pass a[] to this? It isn't used)
The first loop
will have n2 = 2 and n-n2 = 5-2 = 3
This puts 3 at the start since b[0]>c[0]=3 and 2 next since b[1]>c[1]=2 and 1 at d[2] for similar reasons.
Since you don't recurse you won't sort these.
You then finish the while loop with i = 0 which is less than n2.
You just say 
so you just copy the first thing from b which is 5.
All this gives 3, 2, 1, 5, and 0 because you made d global.
",2,17963718
17964367,"
The input for merge need to be sorted arrays, as Philip mentioned before. Mergesort is recursive. For this you need to divide them till you reach a point where you only have one element in the array (so it is sorted) and merge all arrays to become the sorted result for the input. Wikipedia is your friend to understand the algorithm: Mergesort
Btw: You need to ensure that one of both cases in the comparison in the merge checks also on equality of the values.
",1,17963718
17965767,"
Philip is right, there's no recursive in your code at all.
However, there are some more errors. I've marked it with annotations, just as a postscript of Philip's.
",0,17963718
17966465,"
",0,17963718
17955254,"
The signature of your operator<() does not match that of QTableWidgetItem, so even though it has been declared virtual, it doesn't go into the vtable in a manner that allows your QTableWidget to even call it.
The signature QTableWidgetItem's operator<() takes a QTableWidgetItem as a parameter, so you'll have to cast it to your FloatFieldTableItem to do what you want.
",1,17955253
17900541,"
You can try to read the paper ""A Killer Adversary for Quicksort"" by M. D. McIlroy, 1. It is a very readable paper, and just 4 pages. It actually contains C code for an implementation that will cause qsort to behave badly.
",2,17900059
17867522,"
Not tested. I assume that the vector contains at least one element.
This is clearly O(n). There is a slight difference from your code: each word is printed only once.
",8,17867359
17867619,"
Tested, O(n), works even if the vector is not sorted or if it's empty:
Or, the appropriate snippet re-written using range-based loops for the sake of readability (thanks Frerich Raabe):
",3,17867359
17863840,"
Consider the following polygon:

First, order your vertices by y-coordinate. In groups of equal y-coordinate sort the vertices by x-coordinate:

There will always be an even number of vertices in each group if there are no degenerate vertices. Edges will always alternate. So there is an edge between 0-1, no edge between 1-2, edge between 2-3, no edge, edge etc.

Store the associated edges for each vertex. E.g. in a map or in an appropriate structure.
Do the same for vertical edges (first sort by x-coordinate, in the groups sort by y-coordinate).
Then you have all edges of the polygon. Each vertex should now have 2 associated edges. Pick one vertex and go from edge to edge. This will give you the polyline. If you find that the line is in clockwise direction, just revert the order and you'll get a ccw polyline.
",6,17862162
17830473,"
This type of error is almost always due to the ordering function
not meeting the requirements of a strict weak ordering, as
required by the standard.  Are you sure that 1) some_order(a,
b) && some_order(b, c) implies some_order(a, c), and that 2)
some_order( a, b ) implies !some_order(b, a)?  (Off hand, it
doesn't look lke it to me, but I don't really understand what it
is doing.) 
",5,17830228
17830502,"
std::sort assumes that the comparison function models a Strict Weak Ordering

irreflexive: some_order(u, u) returns false
anti-symmetric: some_order(u, v) implies !some_order(v, u) (both could be false, in which case u and v are equivalent)
transitive: some_order(u, v) == true and some_order(v, w) == true implies some_order(u, w) == true

It would depend on the contents of your global_Data matrix whether your some_order() can be used with std::sort
A priori it seems a very strong restriction, you might want to check it. 
",5,17830228
17769222,"
Per 25.4/5:

A sequence is sorted with respect to a comparator comp if for any
  iterator i pointing to the sequence and any non-negative integer n
  such that i + n is a valid iterator pointing to an element of the
  sequence, comp(*(i + n), *i) == false.

So, for 
std::less<int>()(*(i + n), *i) will return false for all n, while std::less_equal will return true for case 3 3.
",10,17769114
17769133,"
Even if you only have the < operator you can figure out if two numbers are equivalent not necessarily equal.   
if !(first < second) and !(second < first)
then first equivalent to second 
In addition, as paxdiablo's solution actually  mentioned first, you could implement is_sorted as going up the list and continually checking for < not to be true, if it is ever true you stop.   
Here is the correct behavior of the function from cplusplus.com  
",4,17769114
17769142,"
You seem to be assuming that it's checking (for the positive case) if element N is less than element N+1 for all elements bar the last. That would indeed not work with just <, though you can use a 'trick' to evaluate <= with < and !: the following two are equivalent:
However, it's far more likely that it detects (the negative case) if element N is less than element N-1 for all but the first so that it can stop as soon as it finds a violation. That can be done with nothing more than <, something like (pseudocode):
",2,17769114
17745863,"
You essentially want to write two functions, each of which knows its sort order statically (ie, at compile time), and choose which one to call dynamically.
The simplest change is this:
Note that although there is still a ternary statement in the inner loop, it can easily be optimised away since Ascending is constant (just a different constant in each instantiation).
A cleaner way is to remove the ternary statement entirely, and and instead pass some kind of comparison function into the inner function template. We could pass a function pointer, or a lambda - I'm using the built-in function objects since they already do what we want.
",2,17745576
17745813,"
One option is to use a template, and redefine your function as
then you can call your sort with the appropriate sorting object
",1,17745576
17745817,"
If you really want performance, you could write two functions, instead of one. But leads to duplication. This is where C++ shines with templates.
",0,17745576
17711493,"
You can't sort the same vector with two different comparison functions. The second sort forget about the first sort. 
You should use only one call to std sort but with a composed comparison function (like for the lexicographic order). Here is an example for 2 dimensional vector to give you the idea:
",0,17711414
17702520,"
Technically, there is a bug in the code as well:
unsigned flag[MAX>>6]={0};
divides MAX by 64, but if MAX is not an exact multiple of 64, the array is one element short.
Line 1: Let's pick it apart:
The flag[n>>6] (n >> 6 = n / 64) gives the 32-bit integer that holds the bit value for n / 2. 
Since only ""Odd"" numbers are possible primes, divide n by two: (n>>1). 
The 1<<((n>>1)&31) gives us the bit corresponding to n/2 within the 0..31 - (& 31 makes sure that it's ""in range""). 
Finally, use & to combine the value on the left with the value on the right. 
So, the result is true if element for n has  bit number n modulo 32 set. 
The second line is essentially the same concept, just that it uses |= (or equal) to set the bit corresponding to the multiple. 
",4,17702232
17639360,"
According to the comments:

Is there any value that will never appear in arr but is representable by int?
You can take that as int max.

Now you can use removeIndices

Edit: With 
We can do:
",2,17639129
17639248,"

loop thru filter array and mark dead elements with tombstones
create a new array, and copy step-by-step while skipping tombstones

if it's possible use a tombstone value, for example if it is guranteed that -1 doesn't appear in the input then -1 can be the tombstone value
if this is not possible use an array of boolean markers, init them to false
in-place filtering after marking:
arr input length: n
arr new length: i
",2,17639129
17639365,"
May be you want something like this:
",1,17639129
17639307,"
You must add the result to a new array 1-just iterate over all all elements if the index is in the to delete array continue else copy it to the new array, you can look at the CArray class from MFC it has RemoveAt method
",0,17639129
17639300,"
PseudoCode
Edit
The above snippet consumes extra space. 
If we had to do it in-place, then every time, we delete an element we will have to shift all consecutive elements by 1. In worst case, this could be O(n**2). If you want to do it in-place without yourself copying array elements, you could use vector.
If deletes outnumber reads, then consider using multiset
",0,17639129
17640189,"
Here is a solution that does it in-place, does not allocate memory on the heap, does not require flag values, and does it in O(N+M) time:
Note that it needs full access to the source array, because I create a temporary stack buffer of bool that is the same size.  In C++1y, you'll be able to do this without that compile time knowledge using variable length arrays or similar types.
Note that some compilers implement VLAs via (hopefully partial) C99 compatibility already.
",0,17639129
17621877,"
You want to save the permutation  of your original vector, so you need another vector which builds the correct bijection from {0, ... , n - 1} to {0, ... , n - 1}:
We didn't permutate anything yet. Now you don't sort the second vector, instead you sort the permutation:
If you use C++11, cmp can be a lambda: 
If you use C++03 you'll need to use struct with bool operator()(unsigned int, unsigned int):
The sorted vector can then be traversed with vec[permutation[i]].
",11,17621769
17576561,"
Imagine you are merging the two sorted sub-sequences:
1 < 11, so you swap:
11 < 12, swap:
12 < 13, swap:
13 < 14, swap:
You've reached the end of one of the subsequences, so you stop. Is the merged sequence sorted?
",3,17576421
17555052,"
I think most of the time will be spent in these lines:
My understanding is that this is testing each active point against each active triangle, so this might loop thousands of times for each active point.
I think this would go a lot faster if you prepared a map from vertices to a list of triangles that used the corresponding vertex. You would then immediately discover all the connected triangles instead of having to search for them.
",1,17554530
17503488,"
Ok, there are two distinct problems with your code. 
The first is that in PHP the language automatically used floating point when it thinks that's needed. So your $middle = ($high+$low)/2; will result in valuves such as 0.5, 0.125, etc, and thus causes infinite recursion. Throw an cast to int on there: 
and it gives you more what you want. 
Second problem is that you are using $m = mergeSort(...); but there is no return statement in the mergeSort function. Which is why $m is NULL when you get it back. 
",0,17503294
17486013,"
This code might help!
",0,17485600
17477729,"
There is probably nothing wrong with the sort. What is clearly wrong is that you don't have an ostream& operator<< for Ticket, so you cannot do this:
So,
",4,17477680
17458859,"
You should be using std::sort and a function you use for sorting. If I understand you correctly you want to sort based on the 2nd or 3rd dimension.
Using this function you can call std::sort:
If your comparisons are rather complex then you should use functors instead of the comparison_function to inject state.
",2,17458278
17458753,"
I'm not sure I understand the question correctly, but if all you want is to sort a vector of matrices on the integer element M[y][z] of each matrix then I think the following code is what you need:
",1,17458278
17416747,"
I doubt there's a ""Textbook Answer"", and the answer is no: you can't sort maps by value.
You could always create another map using the values.  However, this is not the most efficient solution.  What I think would be better is for you to chuck the values into a priority_queue, and then pop the first 100 off.
Note that you don't need to store the words in the second data structure.  You can store pointers or references to the word, or even a map::iterator.
Now, there's another approach you could consider.  That is to maintain a running order of the top 100 candidates as you build your first map.  That way there would be no need to do the second pass and build an extra structure which, as you pointed out, is wasteful.
To do this efficiently you would probably use a heap-like approach and do a bubble-up whenever you update a value.  Since the word counts only ever increase, this would suit the heap very nicely.  However, you would have a maintenance issue on your hands.  That is: how you reference the position of a value in the heap, and keeping track of values that fall off the bottom.
",1,17416677
17413084,"
The main problem is that when you delete an element from the array, you shouldn't be incrementing the j index, because the string at the current index will have changed, so you need to check it again. 
You can fix that by decrementing j at the same time as you decrement m.
Also, it looks like you are overrunning the end of the array in the delete loop.
Note that when k reaches the last iteration (i.e. k = m-1), you're going to be copy from a position m which is past the end.
The updated loop with both fixes should look like this:
",3,17412906
17413056,"
Edit I've just seen this is for homework. Anyway, once you are done with that, here is an idiomatic C++ way to sort a vector of strings, and remove duplicates:
",3,17412906
17415695,"
If your sorting works correctly, then you dont need to loop over both i and j to compare strings. You only need to loop over one index and compare with the next string. Then you delete the next string if they are equal, and only increment the index if they are different.
Here are some pseudo code:
",1,17412906
17413092,"
This should work!
",0,17412906
17413039,"
You modify your n loop upper limit in the loop body it may be the reason of your problem,
so remove the line 
and track the remaining number of string in another variable
It's a common good practice when you write a loop of keeping the stop condition stable. 
",0,17412906
17396248,"
In C++ you can use std::next_permutation to go through permutations one by one. You need to sort the characters alphabetically before calling std::next_permutation for the first time:
Here is a demo on ideone.
If you must implement permutations yourself, you could borrow the source code of next_permutation, or choose a simpler way of implementing a permutation algorithm recursively.
",41,17397145
17396438,"

Another version
",10,17397145
25096500,"
@alexander the output of this programme is in exact order as requested by you:
HERE, is a simplest code for generating all combination/permutations of a given array without including some special libraries (only iostream.h and string are included) and without using some special namespaces than usual ( only namespace std is used).
and main:
HOPE! it helps you! if you are having problem with understanding logic just comment below and i will edit.
",2,17397145
22801796,"
",2,17397145
17396550,"
I wrote one without a function already implemented even any templates and containers. actually it was written in C first, but has been transform to C++.
easy to understand but poor efficiency, and its output is what you want, sorted.
",1,17397145
53259100,"
In case you have std::vector of strings then you can 'permute' the vector items as below.
C++14 Code
Output:
abc_def_ghi
abc_ghi_def
def_abc_ghi
def_ghi_abc
ghi_abc_def
ghi_def_abc
",0,17397145
17378266,"
One error is that descent_rep is not a class template, so you need to replace
by
You should make descend_rep's bool operator() const too, since comparing its operands does not change its state.
",1,17378237
17297088,"
The theoretical better way to do this is to use heapsort.
However, in practice, the fastest way is to append your elements to a vector, and sort them using a quicksort.
In both case, it will take O( N * log(N) ) in average, but the quicksort has lowest constant factors.
",2,17296570
17296750,"
There are at least two efficient solutions:

Append elements to a vector; sort the vector; scan the vector.
Insert elements into a priority_queue; drain it.

The vector has the advantage of O(N) load time (vs. O(N log N) for the priority_queue). (Note that it still takes O(N log N) overall, due to the sort).
The priority_queue has the advantage of freeing memory as you drain it. This doesn't reduce the maximum memory footprint, and is probably of negligible benefit, but it's worth trying anyway.
",2,17296570
17297459,"
I would suggest writing a skip list. It is exactly what you ask for - a sorted list with O(log(n)) insertion. It is also relatively easy to implement.
",0,17296570
17299950,"
If your keys are in a limited range of values, you might want to consider the use of Bucketsort.
",0,17296570
17260381,"
When applied to char *, the < operator (which sort() defaults to) orders by pointer values, not lexicographically. You need to supply a custom comparator. In C++11, this is fairly easy:
If your compiler doesn't support lambdas, you'll have to declare an appropriate comparator outside the function:
Another problem you have is that str1 isn't null terminated, as strtok() requires. But rather than adding it to the end, redefine it as a C string, which is more concise and gives you the null-terminator for free:
",11,17260343
17256826,"
Stable sorts are really only useful when the items you are sorting have satellite information. 

From CLRS (Introduction to Algorithms, 3rd Ed.):

""In practice, the numbers to be sorted are rarely isolated values. Each is usually part
  of a collection of data called a record. Each record contains a key, which is the
  value to be sorted. The remainder of the record consists of satellite data, which are
  usually carried around with the key. In practice, when a sorting algorithm permutes
  the keys, it must permute the satellite data as well.""


When a sort is stable, it means that ties are broken in the sorted array by the items' original ordering. If you are only sorting int and long types, you don't need a stable sort.
",5,17256810
17257326,"
There should be no difference (maybe with exception of things like -0.0 and 0.0). However I do not think there is any need to forward such calls, because std::sort or std::stable_sort should not know what they are sorting, so long as the comparison operation compiles. These functions don't need to be too smart.
",3,17256810
17257553,"
With the default comparator specifically (implying the natural strict ordering)? I don't see any use for stable sorting on scalars in that case. Stable sorting can't provide any additional benefits in situations when equivalent values (according to the comparator) are indistinguishable. (Although @Andrey Tuganov in his answer makes an interesting and relevant remark about negative zeros).
Nevertheless stable sorting on scalars might be useful when the ordering criterion is weaker than the natural strict ordering. For example, you can write a comparison predicate that will say that any odd number is greater than any even number. In that case the resultant ordering will simply partition the array into contiguous blocks of even and odd numbers (in that order). If you are interested in keeping the relative order of these numbers unchanged, you need stable sorting algorithm.
",3,17256810
17206064,"
Here's an approach that uses encapsulation and overloading of operator>>. I'm assuming that what you were describing for the input was just a long sequence of space separated input values with the first value being the count of players.
",0,17204884
17204949,"
Why 50 players but only 27 scores?
I assume the first line is the total number of lines you are expecting to read? If so you could dynamically allocate the arrays to hold all the data rather than just handling 50 (or is it 27) lines. You could also combine all the data for one line into a struct instead of spreading it over a bunch of disconnected arrays.
Pseudo code:
",0,17204884
17206026,"
The best way to use it will be use of vectors. but as you told that you are bound to use Arrays so here is the code for it.
Please let me know if you face any issue. I have not added some basic sanity checks like one for file, please do that in your version of it.
",0,17204884
17207341,"
I looked  again on my operators and got what is wrong. The this->getID()  construct fails. Because operator>(), is not called with two pointer arguments (as far as I understand).
I solved it with an functor:
[..] bool operator()(Multibaseleg* M,Multibaseleg* N){return (M->getID()<N->getID());}[..]
",1,17194944
19095533,"
Your getTemplates() method returns by value, making a mess here:
You are sorting an incompatible iterator range. You can fix that particular problem by returning a reference:
It is common practice to add a const overload to such a method:
You can also modify your comparison functor to avoid unnecessary copies (and for general readability and const correctness):
This will require that you make getVolumePos() a const method, which it should be anyway:
Note that is is not generally good practice to provide references to the private data of a class. If possible, you should find a way to remove that from the UltraSoundTarget interface. You could, for instance, expose a pair of iterators, and/or give the class a sort method.
",5,19095336
19095773,"
juanchopanza answer is correct, the problem is the way you are returning the vector from UltrasoundTarget. Just to touch another topic, maybe it would be nice to change a little the designing of your implementation. As UltrasoundTarget is a container of Ultrasound's, it makes sense to implement the sort as a method of this class, this way you have direct access to USTemplateVector_ and will save unecessary copies. Something like:
",0,19095336
19083935,"
I would personally define a class template for the binary predicate and specialize it as needed, e.g.:
In a real implementation, the argument type for the generic version should probably decide whether the argument is passed by value or by const& depending on the kind of type and/or based on a trait which is then specialized as needed. For example:
",1,19083745
19056961,"
This is working right? You're just looking for improvements.
The usual way to do this would be to add all the lines unsorted to a std::vector<std::string> and then call std::sort with a custom ordering to sort into the desired order, then print out.
Should be a little more efficient than your solution (which is pretty good anyway).
",0,19056602
19056971,"
As an alternative to using str.substr(54 ,4), you could have used the following method (using character positions is error prone if the format ever changes):
This directly reads the third word, regardless of its position or length.
",0,19056602
19046762,"
Since you haven't posted your code, I assume you are looking for a better optimization of code to save memory and time. Try using flags in your loops.
The ""break"" makes sure that you don't iterate over the unnecessary code after you've sorted your data, the flag tells the compiler to exit the loop statement when the iterations are comlete. Using flags in nested loops is even more important since the space complexity goes over O(n.square) and it calls better efficiency. 
This saves a lot of time over huge number of iterations and also memory space. Try optimizing your code wherever possible, makes a lot of difference in the long run.
",0,19046484
19046844,"
Using a Radix sort can speedup your sorts.
There is a parallel implementation of the Radix sort algorithm in the Nvidia cuda/openCL SDK. 
",0,19046484
19039988,"
Without seeing your swap, I say that the culprit is this line:
You are passing the values in positions 2 and 3, where indexes are almost certainly expected. This call should look like this:
Otherwise, the swap would interpret the values of the array as indexes to be swapped, reading memory outside the array.
To avoid problems like this in the future, use std::swap instead:
",3,19039903
19026097,"
Split your problem:

Filter prime number
then find_min_max

For min_max, you may use something like this:
",8,19025416
19026072,"
I believe you are starting with the programming stuff and haven't read about complexities and function calls, so putting it in a simple way that a beginner can understand it.
take a variable to check if a prime number is present or not
int foundPrime = 0;   // Use boolean here if you are comfortable
Since you want to find both max and min, change this part:
TO:
And change the final print statement:
to something like:
",1,19025416
19027458,"
Here is a worked example that defines an is_prime predicate, then uses boost::filter_iterator and std::minmax_element to get the smallest and largest prime from an unsorted range in one pass over the data
Live example.
",0,19025416
19018303,"
After that, you have two options: the hours are equal, or A.hours>B.hours. If they are equal, then it makes sense to compare the minutes. If A has more hours, then it makes no sense to compare the minutes.
Your second condition should be:
Similarly, your third condition should be:
The last return should remain the same.
Also, be aware that storing these as strings will cause them to be ordered alphabetically. (or in order of their ASCII code).
",2,19018221
19018284,"
I think to return true, you need to check all three conditions in one shot.
Just wrote the sample as below.
",0,19018221
19014767,"
Because your class is a template there are certain issues that can happen to confuse the compiler. You may think your code is straight forward and easy to understand, and in this case it is. Older compilers used to do their best to guess and compile this code.
However, newer compilers are more strict and fail on all versions of this type of code, in order to prevent programmers from relying on it.
What you need to do is use the this pointer when calling base class functions. That makes the call unambiguous and clear. That would look like this->removeAll().
Another option would be to use a full name qualification like LList<Elem>::removeAll(). I prefer using this because it is easier to read.
",2,19013005
18994625,"
std::lower_bound will do that for you.  It's in the equivalent-behavior section at the top for binary_search.
",36,18994602
18994667,"
There is a method, std::equal_range, which will give you a pair containing the lower and upper bound of the subset holding the desired value. If both of those items in the pair are identical, then the value you were looking for doesn't exist.
",14,18994602
51762765,"
",0,18994602
18981773,"
You shouldn't go up to j (""...<= j..."") when j could be a.size(). Try a.size() - 1.
",0,18981669
18977426,"
In your real code, it looks like you're passing the iterator instead of the comparison function:

(__gnu_cxx::_normal_iterator<foo::baz*, std::vector<foo::baz> >) (foo::baz&, foo::baz&)'

It's trying to call the iterator with the elements to compare. That doesn't work.
The code you showed gets it right, though: http://ideone.com/pwo5Cu
",1,18977311
18977476,"
The code you shows compiles fine. At a guess, in your actual code cmp resolves to something other than foo::cmp, giving rise to the error in question.
",0,18977311
18955212,"
You have to call std::list's sort function since it doesn't have random access iterators:
",6,18955062
18937244,"
is equivalent to:
Imagine array 1 0 1. Now counts of elements would be following:
0 - 1 time
1 - 2 times  
The preparation of positions increments counts by the amount of elements that precede them:
0 - 1
1 - 3
Position of elements in new (sorted) array is now (count - 1):
position of 0 = 1 - 1 = 0
position of first 1 = 3 - 1 = 2
position of second 1 = 2 - 1 = 1
making it 0 1 1.
",1,18936955
18934426,"
Like this
You should only compare the strings if the numbers are equal. You actually say this in your question, but the code doesn't match what you say.
",1,18934392
18928920,"
Your code:
allocates a single integer initialized to middle.  You need:
which allocates an array of middle integers.  Rinse and repeat for int *right.  Actually, you need to use:
This gets the correct size for the right array.  You then have to modify the recursive call to merge_sort() for the right sub-array:
Finally, you have to rewrite merge() to take the size of the left array and the size of the right array independently, because they may be of different sizes.  For example, if you sort 10 elements,
you then end up with a call to merge two arrays of 5 (which is fine), but at the next level you need to merge an array of 2 and an array of 3 elements (and you're hosed).
The allocation of result also has the () vs [] allocation problem.  And there are some other as yet unresolved problems.  But these are important steps in the right direction.
As mentioned in a comment to the question, you have a monumental memory leakage problem, too.  What's more, it is not trivial to fix because merge_sort() does an early exit without allocating new memory, so it isn't as simple as 'delete the memory returned by merge_sort()'.
Copy and paste is wonderful until you forget to edit the pasted copy correctly:
Methinks you should be using r and rsize in the second of these blocks.
This still isn't the whole story...
And the residual problem (apart from memory management, which is still 100% leaky and problematic) is:
You're copying into parts of right that you've not allocated.  You need something more like:
This code works as long as you always sort at least two items at the top level (you crash freeing unallocated space if you sort 1 item — that's part of the memory management problem).
This is the debug-laden code.  It's the level to which I went to get the result.  I could perhaps have used a debugger.  Were I on a machine where valgrind works, it might have helped too (but it does not work on Mac OS X 10.8.x, sadly).
There are still many, many ways to improve the code — including the memory management.  You'd probably find it easiest to pass the input array to merge() for use as the result array (avoiding the memory allocation in that code).  This would reduce the memory management burden.
When you remove the debug code, you'll need to call the dump_array() function in the main() program to get the before and after sorting array images.

Code converted to template functions and leak-free
I've simplified the code a fair bit, especially in the merge() function.  Also, more as a matter of curiosity than anything else, converted it to a set of template functions, and then used them with 4 different array types (int, double, std::string, char). The amount of debugging has been dramatically reduced, and the main debugging is conditional on being compiled with -DTRACE_ENABLED now.
The code is now leak-free; valgrind on a Linux box (virtual machine) gives it a clean bill of health when there are no exceptions. It is not guaranteed exception-safe, though. In fact, given the naked uses of new and delete, it is pretty much guaranteed not to be exception-safe.  I've left the namespace control in place, but I'm far from convinced it is really correct — indeed, I'd lay odds on it not being good.  (I'm also curious if anyone has any views on how to layout code within a namespace { … }; block; it seems odd not indenting everything inside a set of braces, but …)
",3,18928821
18936499,"
Local types (i.e. types that are defined inside a function) cannot be used as template arguments in C++03 (one of the template arguments of std::sort() is the type of the objects that should be sorted). I do not know why C++03 has this restriction. C++11 does not have this restriction anymore.
",2,18927198
18916667,"
Split your data into 2 parts. Assuming one part will fit in memory easily. Sort and make every part unique. Save it to a file (can be done concurrently). Like merging two sorted sets you only need the head of every part. Processed elements can be written to disk.
Generalization from 2 to N parts is easy.
",1,18915665
18916958,"
You may also have a look at the references given in this SO answer for parallel sorting algorithms to get some inspiration :-)
",1,18915665
18866283,"
If you are confused with that line, you can read about counting sort. One of the important things to understand abount radix sort is that it doesn't sort by itself. There is a sub-algorithm that has to be used, and it is often counting sort.
The link you provided does not tell that and it's an important confusion in my opinion. When you read 

""During first pass, sort all the data based on the least significant bit""

It doesn't tell how you sort. You could sort with any other stable sort, and the code would change drastically.
All this to say that if this is the only line that you don't understand, you got radix sort figured out. Read about counting sort to understand how it works, and make sure you understand why it's a good choice as a subroutine of radix sort.
",1,18865868
18866024,"
This function is taking the cumulative sum, now bucket[i] contains the cumulative sum of itself and all buckets before it. What the comment means is that bucket[8] == 2 would mean that the sum from of buckets 0 to 8 = 2
Edit: Personally I think http://www.youtube.com/watch?v=Nz1KZXbghj8&noredirect=1 has a great radix sort explanation.
",2,18865868
18783410,"
stable_sort is itself a template, the type of its third parameter is a template parameter. This means that you cannot pass a function template as the argument, because template argument deduction cannot apply here - there's nothing to tell which instantiation you'd be after. So you'd have to specify the template argument explicitly:
However, you'll be better off if you provide a functor for that:
That way, the actual template argument deduction is postponed until the time when the desired types are known.
",3,18783251
53764146,"
Since C++14, you can also use a lambda expression instead of using a template. This is, because C++14 allows for generic lambdas, whose function parameters can be declared with the auto type specifier:
This way your code becomes rather short, but still works for any comparable std::pair key.
Code on Ideone
",0,18783251
18787427,"
Partial ordering is, essentially, <=. If both a <= b and b <= a then you may say that a is equivalent to b. But it's also possible that neither a <= b nor b <= a - the two elements are incomparable. As a result, you cannot impose a total order (like std::sort would need to) on a set with partial ordering relation - at best you can do a topological sort. Nor can you derive an equivalence relation - again, there may be elements that are incomparable.
Strict weak ordering is like <. It doesn't allow having both a < b and b < a, and if neither a < b nor b < a, you can just pronounce a and b equivalent.
Total ordering is simply strict weak ordering where two elements are equivalent if and only if they are equal (which is only meaningful if you have an equality comparison predicate in addition to less-than predicate, and there is no C++ standard library algorithm that uses both at the same time, so the issue is largely moot in this context).
",5,18781405
18782389,"
It's not too difficult.  First, consider the ""canonical""
ordering relationship: 
Obviously, no one would actually write something like this, but
it corresponds exactly to the formal definition of what is
needed.
Of course, if we can imagine the data members as an array, we
could rewrite this as a loop, taking advantage of the previously
established !(rhs[i-1] < lsh[i-1] in each case:
Or, if all of the elements are fully ordered, so that == is
also defined on them, and we can assume that it corresponds to
the equivalence relationship established by the weak partial
ordering:
All that remains is to somehow translate this into something
that can process an arbitrary ordering of elements of arbitrary
types.  There's an old saying that the solution to every problem
is an additional level of indirection, and it applies here.
First, we need some means of handling the different types of
each element.  Polymorphism seems appropriate (although
templates could be made to work if the order in which the
elements were evaluated were fixed at compile time):
Depending on the types of the elements, you may need to hand
write specific concrete instances.  And if any of the elements
doesn't support total ordering, you will have to omit the
isEqual, and modify the following code accordingly.
Having got this far, we need exactly one static instance of each
concrete Compare:
Finally, put the addresses of these instances in a table:
You can have different tables for different orderings.  If there
are only a few, define static tables for each, and be done with
it.  If the orderings can be arbitrary, create the table on the
fly before each sort, in the desired order.
Finally:
(Please note that I haven't actually tested this code, so there
are probably typos and other errors.  Still, the basic idea
should be there.)
",4,18781212
18781376,"
I think just overloading operator < will work for you.
This way whenever any 2 instances of Struct are compared, they will be compared by the comparison function defined in operator <.
So a simple std::sort(vec.begin(), vec.end()) will just work!
EDIT:
Otherwise you can always define a functor which can be used to compare each element. This is just a class with an overloaded operator () which is used for comparison.
You can additionally define some member values of the ComparisonClass which define the order of comparisons.
Using it would be calling it like so std::sort(vec.begin(), vec.end(), ComparisonClass());
EDIT2: 
Slightly more elaborate code -
Here I'm assuming that Struct has an operator [] which returns the appropriate member variable.
",1,18781212
18781301,"
Why not have a specialized comparator function which first checks member1 and if equal then checks member2?
Like
",0,18781212
18770442,"
Try this in compare
I expect that you are losing precision when the long long int is converted to an int when you return from compare.
",0,18770375
18725059,"
You can use boost::regex to extract number as string, convert the string to number in a custom comparator for std::sort to sort the std::vector of your files
And then,
//std::vector<std::string> vec{""_X1.bla.txt"", ""_X101.bla.txt"", ""_X47.bla.txt""};
std::sort( vec.begin() , vec.end() ,mysort() );
",3,18723984
18724383,"
If you have all the names in a container (something like std::vector filenames) you can do 
and it will use the default sorting function. If you want a custom one you can do: 
",2,18723984
18724465,"
let suppose that you have used boost filesystem directory_iterator. With an iterator you have access to the filename as a string.
Use a regex (\d+) to extract the number (if more than one)
and instead of using a 'vector of pair (int , string)' you can use directly an ordered map.
",0,18723984
18697568,"
What you probably want is a std::map<My_Double_Array, size_t> along with your own My_Double_Array class that wraps your array of double variables and provides a operator <() for sorting.  Or simply std::map<std::vector<double>, size_t> might be all you need.
",1,18697425
18640311,"
This is called Maximum Cost Bipartite Matching, and the most general algorithm for it is Bellman-Ford Algorithm (you can convert your distance to negative to make the algorithm directly applicable)
You can also use Hungarian Algorithm, which is actually assignment problem, by defining the A vertices as workers and B vertices as tasks, and putting the distance in the cost matrix.
EDIT:
For simple method (like your 3-element case), you can consider complete search. This is because we can consider your n x n distance matrix as a board, and we need to select n squares, such that each row and each column has exactly one selected square.

float cost[n][n];
bool[n] used;

float solve(int row){
    float min = 999999; // Put a very large number here
    for(int i=0; i < n; i++){
        if(!used[i]){
            used[i] = 1;
            if(i==n-1){
                return cost[row][i];
            } else {
                float total = cost[row][i]+solve(row+1);
                if(total<min) min=total;
            }
            used[i] = 0;
        }
    }
    return min;
}

int main(){
    printf(""%.2f\n"",solve(0));
}


The complexity is n^n, so this only works for n <= 8.
",5,18640179
18637553,"
You care currently iterating over foos three times and sorting it once. This is what will be making your algorithm less performant over large arrays. Why not change it to do the following

iterate over it to extract the pointers into a std::vecotr<Foo*> called fooPtrVec
Change your comparison function to dereference a Foo* and use the key field on Foo for the comparison. Call the function YourNewComparisonFunction
use std::sort(fooPtrVec.begin(), fooPtrVec.end(), YourNewComparisonFunction()) to sort the vector of Foo*

",3,18636105
18636754,"
Alternatively to your attempt,
you may create an array of indexes
using a comparator:
sort this indexes array
Now you can iterates foos and/or keys with the indexes indirection:
",7,18636105
18636322,"
for(;i!=end;++end) 
you have to increment your i not your end!
",1,18636105
18638393,"
You can use a set to sort keys for you, and encapsulate them in a custom container for a more convenient usability:
If you have duplicate keys, you can't use a set. You can replace it by a vector with only a few modifications:
",0,18636105
18600614,"
The following should do the trick:
std::sort requires the value_type of the iterators to be less-than comparable, or in more technical terms, they must form a strict weak ordering. Given the code above, you should now be able to sort it like any other type:
assuming my_classes is a std::vector.
",3,18600507
18600938,"
There are 3 ways to do this using std::sort.

Implement an operator< function in the MyClass class.
Pass a function to sort that takes two const &MyClass reference parameters and returns bool true when the first object is less than the second.
Pass a functor object (a class that implements operator()) to sort; as with the stand-alone function, operator() should take two const &MyClass parameters and return a bool. Since the object can have internal state, you can use it to dynamically determine which field to sort on for example, or whether the sort should be ascending or descending.

First option:
Second option:
Third option:
",5,18600507
18600686,"
To create a comparator in the Java sense (i.e. an external comparison function which is not part of the class definition), create a functor:
and pass it into std::sort:
Alternatively, if on C++11, use a lambda:
",1,18600507
18600542,"
You can code a compare function and use STL set
To code a comparison implement like this :
",0,18600507
18560497,"
The std::sort() function uses a binary predicate as third argument which can be used to customize the sort order. You can just use two different predicates:
... and likewise for other attributes.
",2,18560411
18560450,"
All you need to do is
Use operator< to define the order you want, it returns true if x should be before y after sorting and false otherwise. From your description is sounds like you want to compare years first, and if they are equal then compare names.
Shame about your professors.
",1,18560411
18558332,"
If you really want to write it by yourself, do as they told you in comments.
If you just want to have a sorted list without duplicates, use std::set and insert all your numbers inside. You will get a sorted, unique list of ints.
",2,18558134
18558395,"
It may be easier for you to understand this solution:
",2,18558134
18558340,"
Normal way :
Remove the duplicates from the array that you've sorted
Else why not simply use STL ?
",1,18558134
18556515,"

how can I find an item only by the unique_id?

the problem with this question is that the list contains Foo classes and ordered by priority. this makes it problematic to search for items by unique_id.
what i'm suggesting is to create a new std::map
and when adding to bla a new item, add it to uniqueId_To_FooClass. that way you can find a foo class by unique_id

I would more like to store the priority in the value (not as the key), but I don't know how I can sort by value then. Is a std::map the right class/template for that?

As far as I can remember, std::map will give you the iterator that will go through the items sorted by the key. Only way to go through the sorted items by the value, and still use the map, is to rewrite whole collection to another map, with key and value reversed.
you can also look here on Oli Charlesworth answer
",3,18556452
18556559,"
If you're fine with linear search, then you can use std::find_if:
Hope that helps.
",2,18556452
18556519,"
I think std::map is not the right choice (are priorities unique?). I suggest the ""The Boost Multi-index Containers Library"" (http://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/index.html)
",1,18556452
18556716,"
If you just need to search unique_id you can have 
similar to find_if, where you can use a custom == inside the struct Foo
And then something like this
",1,18556452
18582892,"
You could use std::set or std::multiset (if you will allow repeated items) of strings, and it will keep the items sorted automatically (you could even change the sorting criteria if you want).
input:


Gerardo
Carlos
Kamilo
Angel
Bosco


output:
",5,18553097
43803059,"
You can use the sort function:
",1,18553097
18553428,"
Your code implements a single-pass of bubble sort.  Essentially missing the 'repeat until no changes are made to the array' loop around the outside.
",0,18553097
18582673,"
The code does not take care when the names are already in order.  Add the following
To the if statement.
",0,18553097
40619148,"
You are using too much unnecessary loops. Try this simple and efficient one. You need to just swap when a string is alphabetically latter than other string.
",0,18553097
18542871,"
You can either

Expand each item to include its original index (this could be done during the first counting pass).  Of course, the index digits are ignored for sorting purposes.
Store indices into buckets instead of values.  Lookup the value each time the digits are required.

The first takes more space but has better locality of reference, the second saves space.
",2,18542630
18542717,"
It is fairly straight forward to make any sort index based.
Any sort is a series of comparisons and swaps, so do this.
",0,18542630
18543348,"
I am not familiar with those implementations, but here is the inner function in one of my implementations, for integers only:
It is not directly readable because it uses lots of auxiliary structures and functions, but the idea is that you keep a separate array with the indices. Once you have the position of elements in the destination array (pos), the last two lines update the value array and index array in exactly the same way.
I guess you can apply the same idea to any implementation, but you'd have to modify the code.
",0,18542630
18533637,"
Cuda THRUST has partition function implemented (http://docs.nvidia.com/cuda/thrust/index.html#reordering).
The main idea should be following:
Using prefix sums to calculate position of element in the array and then rearrange the array.
",2,18515772
18454367,"
Posted only for the OP's reference, and not likely to live a long life. If you're so inclined to use C++11 and don't like typing, this may do the trick.
Relavent links for the functions used:
std::upper_bound, std::next, and std::rotate. Enjoy.
",7,18453945
18454030,"
I think that you are confused with dereferencing iterators/pointers. This should work:
",3,18453945
18454161,"
Its better, for a more generic solution, to pass the range to be sorted instead of the thing to be sorted, as standard algorithms like std::sort() do:
The function is a procedure, does not return anything, sorts the original range.
",3,18453945
18454001,"
it looks like a typo:
it should be:
the next element should go into the next empty space
in step1 prepares for adds type_i counts to cnt_{i+1}, this way making space for type_i elements...
step2 is a prefix on the counts
step3 uses counts as R index pointers and sends all elements from a to its final destination
invariant holded at this step:

count[ x ] points to the next empty space where an type_x element can be placed (or there are no more x elements in the input)

",1,18453886
18437891,"
You can pass a custom comparison function to std::sort. This is trivially implementable using std::tie:
then
std::tie returns a tuple of lvalue reference to the arguments, and there is a lexicographical less-than comparison bool operator< that compares two of these tuples. The effect is that you perform a less-than lexicographical comparison between two StatFaces instances. This is used internally by std::sort to sort the elements.
Note: std::tie is available in C++11 implementations. If you don't have a C++11 standard library implementation, you can use std::tr1::tie from header <tr1/tuple> or boost::tie. You can also implement the comparison function cmp by hand. That is a good exercise, but it is both tedious and error prone.
",7,18437844
18435123,"
The above is place in the wrong section of your loop. In selection sort the swapping occurs in the outter loop -- not the inner loop.
",1,18434918
18853403,"
Your observations are somewhat correct.
Randomized and Median of three pivot selection should result in good Quicksort performance, while the latter being significantly better, as recommended by R. Sedgewick.
Quicksort can be made O(nlogn) in the worst case if the array is divided in equal halves at each step (i.e. median is the pivot). Now, the Median of Medians algorithm can find the median in linear time, making Quicksort O(nlogn) in the worst case. 
However, the overhead of Median of Medians is so high that it's almost never used in practice, because it results in much slower performance. So, one cannot judge an algorithm's speed just on the basis of it's time complexity, the constant factors also need to be considered.
",1,18433290
24590885,"
see this implementation works well i guess
(http://ideone.com/QACBSZ)
",0,18424026
24590956,"
I suspect your program is producing a segmentation fault BEFORE sorting, at the insertion phase.
The segmentation fault occurs if itTemp is set to m.end() by the find(x) function call.  In that case, trying to call itTemp->second.push_back(y) causes a segfault.
That section should be
Or better,
Or using C++11,
",0,18424026
18419936,"
Some mistake on merge-sort & transferring aux initialization to the merge sort function 
",0,18407754
18577442,"
It seemed like an interesting problem so I invested some time in it. The aproach you took is far from being naive. Actually it has pretty good results. It can definetly be optimized further though. I will assume the list of chunks is not already sorted because your algo is probably optimal then.
To optimize it my aproach was to optimize the sort itself eliminating the chunks that can be combined during the sort, thus making the sort faster for the remaining elements.
The code below is basically a modified version of bubble-sort. I also implemented your solution using std::sort just for comparison.
The results are suprisingly good using my also. For a data set of 10 million chunks the combined sort with the merge of chunks performs 20 times faster.
The output of the code is (algo1 is std::sort followed by merging consecutive elements, algo 2 is the sort optimized with removing the chunks that can be merged):
You can probably improve it further using a better sort algo like introsort. 
full code:
I've seen below you mention n is not that high. so I rerun the test with 1000 chunks, 1000000 runs to make the times significant. The modified bubble sort still performs 5 times better. Basically for 1000 chunks total run time is 3 microseconds. Numbers below.
",3,18387627
18388759,"
NOTE: there was an error in my original algorithm, where I only considered blocks to the left of the current block.
Use two associative tables (e.g. unordered_map), one mapping the begin address to the Chunk, another mapping the end to the Chunk. This lets you find the neighbouring blocks quickly. Alternatively, you can change the Chunk struct to store a pointer/id/whatever to the neighbouring Chunk, plus a flag to mark to tell if it's free.
The algorithm consists of scanning the vector of chunks once, while maintaining the invariant: if there is a neighbour to the left, you merge them; if there is a neighbour to the right, you merge them. At the end, just collect the remaining chunks. 
Here's the code:
The algorithm has O(n) complexity assuming constant time access to the begins and ends tables (which is nearly what you get if you don't trigger rehashing, hence the ""tweak this"" comments). There are quite a few options to implement associative tables, make sure to try a few different alternatives; as pointed out in the comment by Ben Jackson, a hash table doesn't always make good use of cache, so even a sorted vector with binary searches might be faster.
If you can change the Chunk structure to store left/right pointers, you get a guaranteed O(1) lookup/insert/remove. Assuming you are doing this to consolidate free chunks of memory, the left/right checking can be done in O(1) during the free() call, so there is no need to consolidate it afterwards.
",8,18387627
18518258,"
I think you can not do better then N log(N) - the naive approach. The idea using an unordered associative container I dislike - the hashing will degenerate performance. An improvement might be: keep the chunks sorted at each insert, making 'unify' O(N).
It seems you are writing some allocator, hence I dig up some old code of mine (with some adjustment regarding C++ 11 and without any warranty). The allocator is for small objects having a size <= 32 * sizeof(void*).
Code:

Note: The raw allocator never release memory to the system (That
might be a bug).
Note: Without optimizations enabled the performance
is lousy (g++ -std=c++11 -O3 ...)

Result:
",4,18387627
18491367,"
Add pointers to the chunk struct for previous and next adjacent chunk in contiguous memory, if such exists, null otherwise. When a chunk is released you check if adjacent chunks are free, and if they are you merge them and update prev->next and next->prev pointers. This procedure is O(1) and you do it each time a chunk is released.
Some memory allocators put the size of current and previous chunk at the memory position immediately before the address returned by malloc. It is then possible calculate the offset to adjacent chunks without explicit pointers.
",2,18387627
18392667,"
The following doesn't require sorted input or provide sorted output. Treat the input as a stack.  Pop a chunk off and check if it is adjacent to a member of the initially empty output set.  If not, add it to the output set.  If it is adjacent, remove the adjacent chunk from the output set and push the new combined chunk onto the input stack.  Repeat until input is empty.
",0,18387627
18372301,"
you have to take the values itself into account.
",2,18372238
18372254,"
You can invert the sorting of any range by using a greater-than comparison instead of the default less-than:
Alternatively, you can reverse the order of iteration:
Edit If you want to change the comparison criteria to compare lexicographically by the pair's second first and it's first next, you can provide your own comparison function. It must still satisfy strict weak ordering as in the examples above. Lexicographical comparisons are trivial to implement with std::tie:
then
You also have the option of using a simple lambda expression instead of writing the functor by hand:
std::tie requires C++11 library support, but there are C++03 alternative implementations in boost::tie and std::tr1::tie. Lambda expressions require C++11 language support.
",7,18372238
18372458,"
To sort on both fields in one hit:
See also existing  entry
",4,18372238
18373044,"
I would like to propose an alternative, which is slightly different, and introduces the benefits of stable_sort.
This works because in case of equivalent elements (elements that compare equal) stable_sort preserve their relative order (which sort may, but does not guarantee).
Thus, imagining that you have [ (3, ""apple""), (2, ""zorro""), (2, ""banana"") ]:

sort by name yields: [ (3, ""apple""), (2, ""banana""), (2, ""zorro"") ]
stable sort by count: [ (2, ""banana""), (2, ""zorro""), (3, ""apple"") ]

It is of course more efficient to use a single sort with a more complicated predicate if you have no need for the intermediate step; however if you receive a list already sorted by name, then just applying the stable_sort by count might be faster.
Finally, a simple trick to check whether a list is sorted accorded to a criterion (or not):
Note: C++11 has a is_sorted method, though expressed in terms of iterators and not container of course.
",1,18372238
18361048,"
You're returning true when the strings are completely equal. This is a violation of the requirements: the function must define a strict weak ordering, i.e. f(x, x) must return false. Your function returns true, and the library might well contain a check that this doesn't happen.
",6,18360884
18361266,"
You could stop storing numbers in strings and use a big number library (e.g. GMP MP)
",0,18360884
18356903,"
The comparison is required to define a strict weak ordering. A strict weak ordering defines a set of equivalence classes from the incomparability relation, i.e., if x < y is false, and y < x is false too (i.e. x and y cannot be compared with <), x and y are considered equivalent. These equivalence classes have a total order, and that's the total order resulting from the sort functions.
In the example given, {1,1,1} has only a single equivalence class, the one composed of {1,1,1}.
is_sorted_until finds the first element x[i] for which x[i] < x[i-1] is true.
",6,18356782
18356954,"
To be exact, it's neither < nor <=, it is defaulted to std::less. That one in turn calls < for most types, except where it is specialized. For example, < for pointers does not generally give a strict ordering, while std::less does.
",2,18356782
18357027,"
It does indeed use operator< unless you provide a custom comparison. But the definition of ""sorted"" is not a[n] < a[n+1] (which we might call ""strictly sorted""), but !(a[n+1] < a[n]); so equal elements are considered sorted. This is equivalent to using <=, but (in common with all other standard algorithms) doesn't require that operator to be defined.
In general, all ordered comparisons must define a ""strict weak ordering"". ""Strict"" means that the comparison must be false for equivalent objects; so < is valid, while <= is not.
",2,18356782
18357019,"
If you look at the example implementation, < is used for checking if the next element is less than the previous one:
If it is, then the order is broken, and the function returns. I. e. the logic is reversed - the algorithm does not terminate if the next element is equal to the previous.
",0,18356782
18310398,"

If you want to count the number of iterations of the inner for loop, use long long. n*(n-1)/2 overflows an int for n = 100 000. If you want to count swaps, you should increment your counter whenever a swap is being done.
Two easy optimizations to make to this are:

pick the pivot randomly;
make the partitioning function more efficient by using Hoare partitioning: https://cs.stackexchange.com/questions/11458/quicksort-partitioning-hoare-vs-lomuto


There are others of course, but this should get you a decent algorithm.
",4,18309866
18308521,"
If you want to know what your CPU can do, then look at the documentation. Your CPU vendor specifies the latency and throughput of all instructions, as well as a variety of other information (how many instructions can be issued or retired per cycle, cache latencies and much more). Based on this, you can compute the theoretical peak throughput.
If you want to do what your CPU is actually doing then run your own code and measure its performance.
However, keep in mind that modern CPUs are really complex beasts, and their performance depends on a wide variety of factors, and you will very rarely be able to come anywhere near maxing out your CPU, and understanding why, or what exactly is holding your code back requires a fairly thorough understanding of the hardware. (My usual rule of thumb is that you're doing very good if you get a sustained 30-40% of the theoretical peak FLOPS)
",25,18308330
18308910,"
This is a typical case of ""In theory, theory and practice is the same, in practice they are not"". 
Modern CPU's have very sophisticated logic in them, which means that the ACTUAL number of operations performed is different from what you'd think from just looking at code or thinking about the problem [unless you have a brain the size of a small planet and know how that particular CPU works]. For example, a processor may speculatively execute instructions on one or another side of a branch, even if it hasn't quite got to the branch - if that's the ""wrong"" side, then it will discard the results of those instructions - but of course it took time to execute them. 
Instructions are also executed out of order, which means that it's hard to predict exactly which instruction will execute when. There are some exceptions. 
You will only get (anywhere near) the theoretical throughput if you are pushing data and instructions through all the available execution units at once - this means having the right mix of instructions, and of course ALL of the code and data in caches. 
So, in theory we could stuff the processor full of instructions that maxes it out, by writing very clever code. In practice, that turns very very very quickly into a hard task. 
However, the question is about measuring the throughput of instructions, and on modern CPU's, this is very much possible with the right extra software. On linux perftool or oprofile, for windows there is Intel's VTune and AMD's Code Analyst. These will allow you (subject to sufficient privileges) to fetch the ""performance counters"" in the processor, which has counters for ""number of instructions"", ""number of float operatons"", ""number of cache misses"", ""branch mispredicted"" and many, many other measurements of processor performance. So given a sufficient length of runtime (at least a few seconds, preferrably more), you can measure the actual count or clock cycles that a processor performs. 
",7,18308330
18309415,"
In practice these days, the effective number of instructions depends primarily on memory latency, which is the main bottleneck on performance. Waiting for data is bad. Processors can alleviate this problem somewhat with techniques such as caching, pipelining and concurrency, but the issue remains and will only get worse over time.
Proper implementation can make a huge difference. You may want to check out this question about cache-friendly code.
",3,18308330
18308428,"
Modern CPUs are pipelining instruction processing, so there is no constant as such.
You could however, read out number of CPU ticks at start of your algo and at the end. I think this is as low level as you can get with such measuring.
http://en.wikipedia.org/wiki/Time_Stamp_Counter
Note: There are a lot of problems why this won't be 100% accurate, I can mention few, but I am sure the community will be able to add to the list:
-OS pre-empting you process
-cache misses (algo will run slower the first time, faster if it's ran subsequently)
-on older CPUs, the CPU ticks are not invariant to the CPU frequency
",1,18308330
54806791,"
You can use Perf tool in Linux. It is easy to use.
To get statistics on CPU cycles, instructions per cycle (IPC), cache hits/misses etc., simply run your program with Perf. A sample command is
perf stat -d <exename>
For more information, visit http://www.brendangregg.com/perf.html or https://perf.wiki.kernel.org/index.php/Tutorial
",1,18308330
18294176,"

there is no way of knowing if a.at(++first) is greater than or equal to pivot

Yes you are right, a.at(++first) is just an unknown value that takes place of the swapped one. It will be compared on the next while-loop iteration in if (a.at(last) >= pivot) last--.
It works because your pivot is always at first position. 
",0,18293758
18292671,"
Edit : 
Considering all ""proper"" naming conventions (as per comments) :
Note: Dietmar Kühl's answer is best in all respect, std::begin() & std::end() should be used for std::sort like functions with C++11, else they can be defined.
",11,18292619
18292672,"
The algorithms use iterator to the beginning and past the end of the sequence. That is, you want to call std::sort() something like this:
In case you don't use C++11 and you don't have std::begin() and std::end(), they are easy to define yourself (obviously not in namespace std):
",27,18292619
18292751,"
Example using std::vector
http://ideone.com/Q9Ew2l
This completely avoids using plain arrays, and lets you use the std::sort function. You might need to update you compiler to use the = {...} You can instead add them by using vector.push_back(""name"")
",8,18292619
18292673,"
Your loop does not do anything because your counter z is 0 (and 0 < 0 evaluates to false, so the loop never starts). 
Instead, if you have access to C++11 (and you really should aim for that!) try to use iterators, e.g. by using the non-member function std::begin() and std::end(), and a range-for loop to display the result:
Live example.
",4,18292619
18292698,"
This works for me:
",2,18292619
23770218,"
As many here have stated, you could use std::sort to sort, but what is going to happen when you, for instance, want to sort from z-a? This code may be useful
If you want to reverse the order of sorting just modify the sign in the cmp function.
Hope this is helpful :)
Cheers!!!
",2,18292619
47998701,"
The multiset container uses a red-black tree to keep elements sorted.
Sample Output:
Note the advantage is that the multiset stays sorted after insertions and deletions, great for displaying say active connections or what not.
",1,18292619
44212766,"

We can sort() function to sort string array.

Procedure : 

At first determine the size string array.
use sort function . sort(array_name, array_name+size)
Iterate through string array/


Code Snippet
",0,18292619
18292758,"
My solution is slightly different to any of those above and works as I just ran it.So for interest:
",-2,18292619
19620744,"
The pseudocode is relatively close to a C++ code with some syntactic changes. Note that this C++ code is a straightforward ""translation"". A better solution would be to use containers from C++ standard library.
",1,19620564
19620643,"
A[i,j] is the same as A[j] (comma operator!), and wouldn't work.  
You might want to declare a two dimensional array for A or even better an appropriate std::array:
Also allocating B right away inside the for loop doesn't look right:
and 
won't work either as you intend (see above!).
",1,19620564
19615705,"
There are several problems here:
The key issue is that quicksort algorithm is incorrect here. it works as follows:
You are doing different things in your implementation.
",1,19615591
19605700,"
Unless I'm severely reading your code incorrectly, you are calling the wrong getCivIndex(). The one you're calling is using a static class variable. This means ALL instances of LocationData (including the internal instances in your PostTwoD objects), share the same static variable, and therefore have the same identical values. In other words, your comparator always returns false because N > N is never true. And thus your sort simply doesn't work.
I believe you want be using the getcivIndex() instance member of PointTwoD; not the static class member of LocationData
Several things should change for this to be ""fixed""
First, change this:
To this: (reasons will be apparent in a minute)
You will also have to change the implementation of this function, wherever it is, to add const to its definition as well.
Next, change this:
To this:
And I suggest you see my comment about using std::partial_sort rather than a full-blown sort if all you want is the ""top N"" results in a sequence.
",2,19605274
19604215,"
I guess you mean const MyStruct * array1?
In any case you can use const_cast to change constness of a pointer:
Or
",0,19604150
19604272,"
Works for exactly the structure from the question... But, the second array1 replaced with another pointer parray.
Maybe, you qualify this as a deep copy even if it is a shallow copy of the struct?
Then, maybe, the other answer is better.


struct MyStruct {
    int i;
    int* p;
};

int j=2;

MyStruct st={ 1, &j; };

int main() {

    MyStruct* parray1(&st;);

    MyStruct* const* array1(&parray1;);

    MyStruct * parray=new MyStruct();

    parray->i = (*array1)->i;
    parray->p = (*array1)->p;
        /*
        This is essentially the same as
        (*parray) = *(*array1);
        */

    delete parray;
}

Edit: A second example as discussed in the comments to this answer.
Here we have a non-const pointer to which we successively assign the pointer values from the const pointer-pointer array1.
The corresponding output:

After the last comments (I think) we have reached a common interpretation of the question.
The pointers in the const array are to be copied into a non-const array where they can be re-arranged and the objects can be modified.
The new output is:
",0,19604150
24366412,"
I had practically the same problem, so I wrote this generic code (maybe you may want to use a different namespace than std ;) ) The code below returns the an iterator to the largest element in the sequence which is smaller than or equal to val. It uses O(N log N) time for N = std::difference(first, last), assuming O(1) random access on [first ... last).
#include <iostream>
#include <vector>
#include <algorithm>

namespace std {

template<class RandomIt, class T>
RandomIt binary_locate(RandomIt first, RandomIt last, const T& val) {
  if(val == *first) return first;
  auto d = std::distance(first, last);  
  if(d==1) return first;
  auto center = (first + (d/2));
  if(val < *center) return binary_locate(first, center, val);
  return binary_locate(center, last, val);
}  

}

int main() {
    std::vector<double> values = {0, 0.5, 1, 5, 7.5, 10, 12.5};
    std::vector<double> tests = {0, 0.4, 0.5, 3, 7.5, 11.5, 12.5, 13};
    for(double d : tests) {
        auto it = std::binary_locate(values.begin(), values.end(), d);
        std::cout << ""found "" << d << "" right after index "" << std::distance(values.begin(), it) << "" which has value "" << *it << std::endl;
    }
    return 0;
}

Source: http://ideone.com/X9RsFx
The code is quite generic, it accepts std::vectors, std::arrays and arrays, or any sequence that allows random access. The assumption (read precondition) is that val >= *first and that the values [first, last) are sorted, like needed for std::binary_search.
Feel free to mention bugs or malpractices that I have used.
",3,19603975
24650830,"
",1,19603975
19604032,"
You searched for a character and you assumed that charaters in the buf are sorted.
If you want to search for a string use a string match pattern algorithm. 
(http://en.wikipedia.org/wiki/String_searching_algorithm)
If you want to search a character or a number in an ordered array then see this:
http://www.programmingsimplified.com/c/source-code/c-program-binary-search
",0,19603975
19604104,"
In binary search you can do value type search not reference type. If you want to search for string in string array you have to write a complex program or use has table
",0,19603975
19604137,"
This seems to work:
",0,19603975
19602543,"
There are numerous things wrong, starting with there is no actual merging being done. You ""merge"" into a local array a[100] in your merge() function, the proceed to do absolutely nothing with that hard-earned effort whatsoever. The caller-side remains unchanged, and that, as they say, is that.
Second, the fixed sizes in this should NOT be present. the algorithm is, by its definition, designed to handle arbitrary lengths, and should be implemented as such.
Several things about the mergesort algorithm are fundamental. Unless you are armed with a particularly impressive in-place merge algorithm (they do exist, but they are not trivial), you will be doing one of two operations for splitting or merging your data:

Split the current list into two sublists, copying each to temp storage, then recursing, then merging those two temp segments back to the original list as the recursing unrolls.
Split the current list by marker only, passing each list+length through the recursion, and merge into temp storage, then copy into your original container.

In short, you can either (a) split to temp storage, recurse, merge to original, or (b) index-only-split, recurse, merge to temp, copy to original. The choice is yours. Below is an algorithm that does the later, and if you're not surprised at the simplicity, you should be (but there is an even better way which I will show last):

A sample program that uses the above algorithm follows:
Output (yours will obviously vary)

The C++ Approach with In-Place Merging
Remember that comment about how particularly nice it would be to have an in-place merge algorithm? Well guess what? The C++ standard library provides one: std::inplace_merge. This makes our mergesort algorithm rival insertion-sort in its triviality:
",1,19602288
19601078,"
You are failing to detect the end of your merge arrays:
Other comments:
Identifiers that are all capitol MERGE MERGESORT are generally reserved for macros. If you use them you are likely to hit problems. Prefer function names of mixed case.
You can simulate arrays with vector:
Arrays in C++ are zero indexed. You seem to be having off by one errors (especially in accessing the end of the array). I would advice you to start the count at 0 rather than 1. Most C++ code is written in terms of iterators from [begining..1PastEnd). I think you will find your algorithm easier to implement if you adapt that style.
",3,19599914
19601187,"
There are several issues with your code, I've pointed them out in comments. This is a solution closest to your code, and it's far from best. Consider using C++ containers, like std::vector for example. Naming is at least disputable, and of course merge sort should be implemented as an in place algorithm.
Output:
Credit goes also to DyP for spotting all the mistakes in the previous version :)
",2,19599914
19598963,"
The issue here is that sortByCiv is a member function, which can only be invoked relative to some receiver object (i.e. myObject.sortByCiv(...) versus sortByCiv(...). The std::sort function expects you to provide as a parameter some function that can be called as a free function with two arguments that will then produce a value.
To fix this, make sortByCiv static. This makes it no longer have a receiver object and should resolve your issue.
Hope this helps!
",5,19598944
19599002,"
sortByCiv is a member function and it needs special treatment; for instance, you cant cast it to function pointer type, as it has an implicit (third) this-parameter.
And in your case, you don't need to. Just move the sortByCiv(..) out of the class declaration(or make it static), as it doesn't use this parameter:
",0,19598944
19592476,"
The problem right now is that you've tried to define sortByCiv nested inside of topfives. You can't define one function inside of another like that. 
You have a couple of choices here. One (that works with essentially any compiler) is to define your sortByCiv outside of topfives:
Another possibility (that is sometimes preferred is to define your comparison as a class or struct that overloads operator():
When you use this, you need to add a pair of parens to the name to create an instance of the class that will be passed when sorting:
The final possibility (that only works with relatively recent compilers is to use a ""lambda"" expression:
If your compiler supports it, the lambda expression is usually preferred, as it lets you specify the sorting criteria ""in place"".
Although it's not related to the sorting, your code to display the results looks somewhat borked as well. I think what you want is something closer to:
",3,19592243
19592433,"
There is nothing wrong with calling std::sort from within another function.  There is something wrong with attempting to declare a function inside another function (nested functions are not supported in C++).  Thus, the following code will not compile:
You can either declare sortByCiv outside of the topfives function (either as a class member or as a standalone function - though it would need to be a friend to have access to the private member data), or use a lambda function (if you can use C++11 features) for your comparison predicate.
",1,19592243
19589068,"
Use std::sort() with a suitable comparison function. This cuts down on the memory requirements.
The comparison function can use n % 10, n / 10 % 10, n / 100 % 10 etc. to access the individual digits (for positive integers; negative integers work a bit differently).
",16,19588809
19589232,"
To provide any custom sort ordering, you can provide a comparator to std::sort. In this case, it's going to be somewhat complex, using logarithms to inspect individual digits of your number in base 10.
Here's an example — comments inline describe what's going on.
Demo
There are quicker ways to calculate the number of digits in a number, but the above will get you started.
",8,19588809
19590638,"
Here's another algorithm which does some of the computation before sorting. It seems to be quite fast, despite the additional copying (see comparisons).
Note:

it only supports positive integers
in only supports integers <= std::numeric_limits<int>::max()/10

N.B. you can optimize count_digits and my_pow10; for example, see Three Optimization Tips for C++ from Andrei Alexandrescu and Any way faster than pow() to compute an integer power of 10 in C++?
Helpers:
Algorithm (note - not in-place):
Usage example:
",6,19588809
19597339,"
Here's a community wiki to compare the solutions. I took nim's code and made it easily extensible. Feel free to add your solutions and outputs.
Sample runs an old slow computer (3 GB RAM, Core2Duo U9400) with g++4.9 @ -O3 -march=native:

number of elements: 1e+03
size of integer type: 4

reference solution: Lightness Races in Orbit

solution ""dyp"":
    duration: 0 ms and 301 microseconds
    comparison to reference solution: exact match
solution ""Nim"":
    duration: 2 ms and 160 microseconds
    comparison to reference solution: exact match
solution ""nyarlathotep"":
    duration: 8 ms and 126 microseconds
    comparison to reference solution: exact match
solution ""notbad"":
    duration: 1 ms and 102 microseconds
    comparison to reference solution: exact match
solution ""Eric Postpischil"":
    duration: 2 ms and 550 microseconds
    comparison to reference solution: exact match
solution ""Lightness Races in Orbit"":
    duration: 17 ms and 469 microseconds
    comparison to reference solution: exact match
solution ""pts"":
    duration: 1 ms and 92 microseconds
    comparison to reference solution: exact match

==========================================================

number of elements: 1e+04
size of integer type: 4

reference solution: Lightness Races in Orbit

solution ""nyarlathotep"":
    duration: 109 ms and 712 microseconds
    comparison to reference solution: exact match
solution ""Lightness Races in Orbit"":
    duration: 272 ms and 819 microseconds
    comparison to reference solution: exact match
solution ""dyp"":
    duration: 1 ms and 748 microseconds
    comparison to reference solution: exact match
solution ""notbad"":
    duration: 16 ms and 115 microseconds
    comparison to reference solution: exact match
solution ""pts"":
    duration: 15 ms and 10 microseconds
    comparison to reference solution: exact match
solution ""Eric Postpischil"":
    duration: 33 ms and 301 microseconds
    comparison to reference solution: exact match
solution ""Nim"":
    duration: 17 ms and 83 microseconds
    comparison to reference solution: exact match

==========================================================

number of elements: 1e+05
size of integer type: 4

reference solution: Lightness Races in Orbit

solution ""Nim"":
    duration: 217 ms and 4 microseconds
    comparison to reference solution: exact match
solution ""pts"":
    duration: 199 ms and 505 microseconds
    comparison to reference solution: exact match
solution ""dyp"":
    duration: 20 ms and 330 microseconds
    comparison to reference solution: exact match
solution ""Eric Postpischil"":
    duration: 415 ms and 477 microseconds
    comparison to reference solution: exact match
solution ""Lightness Races in Orbit"":
    duration: 3955 ms and 58 microseconds
    comparison to reference solution: exact match
solution ""notbad"":
    duration: 215 ms and 259 microseconds
    comparison to reference solution: exact match
solution ""nyarlathotep"":
    duration: 1341 ms and 46 microseconds
    comparison to reference solution: mismatch found

==========================================================

number of elements: 1e+06
size of integer type: 4

reference solution: Lightness Races in Orbit

solution ""Lightness Races in Orbit"":
    duration: 52861 ms and 314 microseconds
    comparison to reference solution: exact match
solution ""Eric Postpischil"":
    duration: 4757 ms and 608 microseconds
    comparison to reference solution: exact match
solution ""nyarlathotep"":
    duration: 15654 ms and 195 microseconds
    comparison to reference solution: mismatch found
solution ""dyp"":
    duration: 233 ms and 779 microseconds
    comparison to reference solution: exact match
solution ""pts"":
    duration: 2181 ms and 634 microseconds
    comparison to reference solution: exact match
solution ""Nim"":
    duration: 2539 ms and 9 microseconds
    comparison to reference solution: exact match
solution ""notbad"":
    duration: 2675 ms and 362 microseconds
    comparison to reference solution: exact match

==========================================================

number of elements: 1e+07
size of integer type: 4

reference solution: Lightness Races in Orbit

solution ""notbad"":
    duration: 33425 ms and 423 microseconds
    comparison to reference solution: exact match
solution ""pts"":
    duration: 26000 ms and 398 microseconds
    comparison to reference solution: exact match
solution ""Eric Postpischil"":
    duration: 56206 ms and 359 microseconds
    comparison to reference solution: exact match
solution ""Lightness Races in Orbit"":
    duration: 658540 ms and 342 microseconds
    comparison to reference solution: exact match
solution ""nyarlathotep"":
    duration: 187064 ms and 518 microseconds
    comparison to reference solution: mismatch found
solution ""Nim"":
    duration: 30519 ms and 227 microseconds
    comparison to reference solution: exact match
solution ""dyp"":
    duration: 2624 ms and 644 microseconds
    comparison to reference solution: exact match

The algorithms have to be structs with function-call operator templates that support the interface:
A copy of the input data is provided as a parameter, the algorithm is expected to provide the result in the same range (e.g. in-place sort).
Current algorithms; note I replaced the digit counters and pow-of-10 with the global function, so we all benefit if someone optimizes.
",6,19588809
19591563,"
I believe the following works as a sort comparison function for positive integers provided the integer type used is substantially narrower than the double type (e.g., 32-bit int and 64-bit double) and the log10 routine used returns exactly correct results for exact powers of 10 (which a good implementation does):
It works by comparing the mantissas of the logarithms. The mantissas are the fractional parts of the logarithm, and they indicate the value of the significant digits of a number without the magnitude (e.g., the logarithms of 31, 3.1, and 310 have exactly the same mantissa).
The purpose of fabs(fx - fy) < limit is to allow for errors in taking the logarithm, which occur both because implementations of log10 are imperfect and because the floating-point format forces some error. (The integer portions of the logarithms of 31 and 310 use different numbers of bits, so there are different numbers of bits left for the significand, so they end up being rounded to slightly different values.) As long as the integer type is substantially narrower than the double type, the calculated limit will be much larger than the error in log10. Thus, the test fabs(fx - fy) < limit essentially tells us whether two calculated mantissas would be equal if calculated exactly.
If the mantissas differ, they indicate the lexicographic order, so we return fx < fy. If they are equal, then the integer portion of the logarithm tells us the order, so we return lx < ly.
It is simple to test whether log10 returns correct results for every power of ten, since there are so few of them. If it does not, adjustments can be made easily: Insert if (1-fx < limit) fx = 0; if (1-fu < limit) fy = 0;. This allows for when log10 returns something like 4.99999… when it should have returned 5.
This method has the advantage of not using loops or division (which is time-consuming on many processors).
",4,19588809
19590884,"
The task sounds like a natural fit for an MSD variant of Radix Sort with padding ( http://en.wikipedia.org/wiki/Radix_sort ).
Depends on how much code you want to throw at it. The simple code as the others show is O(log n) complexity, while a fully optimized radix sort would be O(kn).
",3,19588809
19595522,"
A compact solution if all your numbers are nonnegative and they are small enough so that multiplying them by 10 doesn't cause an overflow:
Run it like this:
",3,19588809
19589083,"
You could try using the % operator to give you access to each individual digit eg 121 % 100 will give you the first digit and check that way but you'll have to find a way to get around the fact they have different sizes.
So find the maximum value in array. I don't know if theres a function for this in built you could try.
This function will return the number of digits in the number
Let number of digits in max equal n.
Once you have this open a for loop in the format of
    for (int i = 1; i < n ; i++)
then you can go through your and use ""data[i] % (10^(n-i))"" to get access to the first digit then
sort that and then on the next iteration you'll get access to the second digit. I Don't know how you'll sort them though.
It wont work for negative numbers and you'll have to get around data[i] % (10^(n-i)) returning itself for numbers with less digits than max
",1,19588809
19589434,"
Overload the < operator to compare two integers lexicographically. For each integer, find the smallest 10^k, which is not less than the given integer. Than compare the digits one by one.
",1,19588809
19589578,"
While some other answers here (Lightness's, notbad's) are already showing quite good code, I believe I can add one solution which might be more performant (since it requires neither division nor power in each loop; but it requires floating point arithmetic, which again might make it slow, and possibly inaccurate for large numbers):
Though I have to admit I haven't tested the performance yet.
",0,19588809
19594434,"
Here is the dumb solution that doesn't use any floating point tricks. It's pretty much the same as the string comparison, but doesn't use a string per say, doesn't also handle negative numbers, to do that add a section at the top...
It's fast, and I'm sure it's possible to make it faster still, but it works and it's dumb enough to understand...
EDIT: I ate to dump lots of code, but here is a comparison of all the solutions so far..
",0,19588809
53148720,"
Based on @Oswald's answer, below is some code that does the same.
Input: 1 2 3 4 5 6 7 8 9 10 11 12
Output: 1 10 11 12 2 3 4 5 6 7 8 9
",0,19588809
19642697,"
As stated by other answers, a vector should be used in your situation. Regarding time-complexity, sorting a vector takes time O(n log n) where n is the number of elements you insert. For std::set, the already sorted sequence comes at the cost of O(log n) for every single insertion. Inserting n elements results in O(n log n) running time as well. But the vector solution will be faster due to better memory locality (in short, it is stored in one contiguous memory range, which can be read and written fast).
Furthermore, std::vector has only constant space overhead, while std::set has linear overhead (it is typically implemented as Rb-tree).  
If you have many iterations and n is a large number, avoid to allocate the vector's memory in every iteration. So instead of 
do something similar to this:
After some iterations the calls to container.resize() will become very rare. The calls of doSomethingWith(YourClass*) will probably become the most expensive part of your program.
",1,19585110
19585492,"
Vectors are almost always faster in practice; if you don't need to interleave updates with lookups, then there's no reason1 to use a set.
That said, you can also take a look at Google's B-tree implementation, which should be faster than set.

1 That is, unless you're also checking for and removing duplicates, and there are many duplicates.
(This is not common.)
",2,19585110
19585194,"
If you only need to sort elements once I think if you use vector you will get better performance. You may also consider using a list, though I think it again will be slightly slower than a vector. 
",1,19585110
19585242,"
Performance is always tricky: you should implement it both ways and measure which one gives better output.
That said, I think vector would be a better bet, if you reserve enough elements at creation: if you use set, the newly inserted element will be sorted into the set at every insertion.  With vector you will incur that cost at one time only.
",1,19585110
19643116,"
As everyone else answered I would also go with vector. It is simpler and gives more access on the memory layout of your objects.
",0,19585110
19579827,"
Since it's a singly linked list, we can do: (psuedo code)
",2,19579587
19580559,"
Don't feel bad this is a lot harder than it sounds.  If this were in an array it would be considerably easier.  If the list were doubly linked it would be easier.  Take a look at this code, it implements an insertion sort
",0,19579587
19580849,"
Use a recursive approach as it is the easiest way of dealing with linked structures:
Pseudocode:
so the let's say you have 5 4 3 2 1
1) 5 4 3 1 2
2) 5 4 1 3 2
3) 5 4 1 2 3
4) 5 1 4 2 3
5) 5 1 2 4 3
...
n) 1 2 3 4 5 
",0,19579587
19580496,"
Assume the Node like this:
use insertion sort algorithm to sort the List:
",0,19579587
26045612,"
",0,19579587
50384112,"
Here is my Merge sort realisation, with O(N*logN) time complexity and constant additional space. Uses C++11
",0,19579587
53582657,"
I know its late but I also search for it but didn't get one so I make my own. maybe it will help someone.
I am using bubble sort (kind of sort algorithm) to sort data in a single linked list. It just swapping the data inside a node.
",0,19579587
19579708,"
Create an array of 9 bool elements, initialized to false.  Loop through the vector, setting to true the indexes (minus one) of any number you find.  If, in this process, you run into an element that is already set to true, the row is invalid.
",1,19579545
19577411,"
Try putting code that compiles and/or ask a specific question.
line 3:  return head;
in a function which is supposed to return a boolean
",0,19577335
19577447,"
Seems like you're passing n by value.  If you need to modify the value of n inside a function, you need to either make it global (argh) or pass the address of n:
",0,19577335
19578259,"
Single linked list, or double linked list?  You mention swapping only data, but you don't provide a pointer definition (key only, or key&data pointers?),
If you want to swap the contents of the two nodes, you need to provide pointers to both nodes in the nodeSwap function,
If you want to swap the entire nodes, then you need to provide previous pointers, or go find them (the below assumes a doubly linked list, or where you see 'prev' you go find it),
And here is the nodeSwap with both pointers,
",0,19577335
19564125,"
You have a misktake in your code.
",0,19563308
19530958,"
vectorRange defined but not used.
",0,19530908
19531079,"
In your selectionSort(), the only command that changes the vector is:
Every time control reaches that line, you overwrite an element of the vector.
You must learn to swap two values, before you even think about sorting a vector.
Also, your functions are over-coupled. If all you want to fix is selectionSort, then you should be able to post that plus a main that calls it with some test data and displays the result, but no, your functions all call each other. Learn to decouple.
Also your variable names are awful.
",0,19530908
19524059,"
You're missing several things; the most important being linked lists are not arrays, and as such you cannot easily do certain algorithms with both interchangeably. With that please consider the following:

List length is determined by reaching the last node, but you don't need it for this algorithm. There should be no reason to scan the list just to find a count that you don't need in the first place. Your ""finished"" state is reached when the last segment of the bubble sort reaches a single node (i.e. it has no next to goto).
The secret to linked list (or any other node-pointer pattern) is the manipulation of the pointers. To that end, you can greatly utilize something you already use for manipulating your nodes: pointers, but not just any pointers. pointers to pointers.
Never underestimate the power of a sheet of paper and a pencil to draw out how you want your algorithm to work. Especially for something like this:

Now take a look at the following considerably different approach. There is something within that is paramount to understanding the overall algorithm, but I'll save it for after the code :
This is radically different than you probably expected. The purpose of this simple exercise is to establish that we're evaluating data, but we're actually sorting pointers. Notice that except for p, which is always the head of the list, we use no additional pointers to nodes. Instead we use pointers-to-pointers to manipulate the pointers buried in the list.
To demonstrate how this algorithm works I've written a small test app that makes a random list of integers, then turns the above loose on said list. I've also written a simple print-utility to print the list from any node to the end.
I've also modified the original algorithm to include printing after each pass that swaps something:
Sample Output
Another Sample
Notice how as soon as we have an already-sorted segment left in our ever-decreasing source list, we're done. 
Summary
I strongly advise walking through the above algorithm with a debugger to understand better how it works. In fact, I advise that with most algorithms anyway, but algorithms that perform pointer-to-pointer actions can be a little daunting until you understand how powerful that really are. This is not the only way to do this task, but is an intuitive approach if you think about how linked lists are managed, and how all you're really doing is changing values stored in pointers in predictable places.
",10,19522121
19522641,"
Basically, here is a revised sort. You mostly had the right idea. Mainly you messed up the swapping of pointers for the nodes. Here is a revised algorithm that is slightly simpler. On the outer loop is a for the number of elements in the list. Then the inner loop is the pushing of values to the end of the list progressively. We track two pointers trail and curr. And we compare curr and curr->next.   
",6,19522121
33531209,"
I think this is what you looking for:
",3,19522121
42757682,"
Bubble sort using array can be easily modified to bubble sort using linked list
",0,19522121
53996299,"
Here is the Java Implementation of Bubble Sort on Linked List:


Time Complexity: O(n^2)
Space Complexity: O(1) - Bubble sort is In-Place sorting algorithm


",0,19522121
19511998,"
Try to replace void Player::sortPrint(int n, Player arr[]) with void Player::sortPrint(int n, Player*) and call function like players->sortPrint(n, *players)
",0,19511734
19512032,"
Your problem is, that players is a pointer to array of Player, and arrays do not have member functions of the containees. As Player::sortPrint does not depend on the object itself, declare it as static and call it like Player::sortPrint(n, players);
",0,19511734
19512134,"
Unless you have a very good reason not to, you should use std::sort rather than your own sorting algorithm. You should use a comparison function which compares the score of each player.
The following should work in C++03:
(Alternatively, you could define an operator< on your Player class which compares scores, which would let you store players in a std::set or std::map.)
",0,19511734
19509368,"
The usual way to do this would be to build a collation table. That's just a table giving the relative ordering of every character. In your case, you want each upper-case letter immediately following the corresponding lower-case letter.
We can do that something like this:
For the moment, I've ignored the (possibly knotty) problem of the relative ordering of letters to other characters. As it's written, everything else sorts before letters, but it would be pretty easy to change that so (for example) letters sorted before anything else instead. It probably doesn't make a huge difference either way though -- most people don't have strong expectations about whether 'a' < ';' or not.
In any case, once the collation table is built and usable, you want to use it to compare strings:
...which we can use to do sorting, something like this:
For the moment, I've only written the collation table to handle the basic US-ASCII letters. For real use, you'd typically want to have things like letters with accents and such sort next to their corresponding un-accented equivalents. For that, you typically end up pre-building the table to (partially) match things like the Unicode specification for how things should be ordered.
Note that this output doesn't quite match what the original question says is desired, but I think in this case the question has a mistake. I can't see any way it would be even marginally reasonable to produce an order like:
This has ""T"" sorting both after and before ""t"", which doesn't seem to make sense (or at least doesn't fit with a lexical sort, which is what people nearly always want for strings).
",2,19509110
19509333,"
Your solution is almost there, you just need to make a special case if the lower case version of the strings are equal:
This could use some optimization.  Copying the string is not necessary. You can, of course, do a case insensitive comparison in place.  But that is feature is not conveniently available in the standard library, so I'll leave that exercise up to you.
",1,19509110
19525500,"

To be clear, I was aiming at the usual lexicographic type comparison but somehow make uppercase follow the lowercase if the strings were identical otherwise.

This requires a two-steps comparison then:

compare the strings in case-insensitive mode
if two strings are equal in case-insensitive mode, we want the reverse result of a case sensitive comparison (which puts upper-case first)

So, the comparator gives:
",1,19509110
19521099,"
The simplest solution is to use the collation-aware sorting provided by the standard locale object.
A locale's operator()(std::string, std::string) is exactly the locale's collation-aware comparison operator, so you can just insert it directly into your call to std::sort:
Example on ideone
",1,19509110
19509852,"
You need to do the comparison one char at a time, stopping at the first different char and then returning the result depending on the case conversion first, and on original char otherwise:
Warning: untested breakfast code
",0,19509110
19515505,"
Either use locals that already have the ordering you want, or write a character by character comparison function then use std::lexicographical_compare to turn it into a string comparison function.
I would try locals first, but if that proved frustrating the lexicographic is not horrible.
To compare chqracters, create two tuples or pairs of lower_case_letter, unchanged_letter, and call < on it.  This will first order by lower case, then if that fails by the unchanged.  I forget what order the upper vs lower will sort in: but if the order is backwards, just swap which lower case letter gets paired with which upper case letter, and you'll reverse the order!
",0,19509110
19484397,"
It's fairly easy using a custom comparator to do the dereferencing, as well as ready-made lexicographic tuple comparison:
Of course the objects pointed to by the pointers must live at least as long as you're using the pointers in v, x and y.
",2,19484368
19481737,"
You want to use the lower_bound() function.  It's a little bit funky to make it generally useful, but serves the purpose you want.
",5,19481662
19481795,"
You can use std::lower_bound (O(log(N)) and std::distance (O(1) for random access iterators):
Then, either
or plain arithmetic:
",4,19481662
19481943,"
Tweaking the std::binary_search you can get :
",0,19481662
48773067,"
Use equal_range, not lower_bound. 
You can’t simply check if the iterator returned by std::lower_bound is different from the end to know whether the element is in the collection. If the element is not present, std::lower_bound returns the location where it should have been, not the end of the collection.
See: https://www.fluentcpp.com/2017/01/16/how-to-stdfind-something-efficiently-with-the-stl/
",0,19481662
19478424,"
This code at least compiles (using c++11, except for C-style IO) via
clang++ test.cc -std=c++11 -stdlib=libc++ -Weverything -Wno-c++98-compat.
If it does what you want, I don't know.
",0,19478047
19474312,"
You are sorting a std::vector<item> of item but your predicate myCompareStruct::operator() cannot compare two items, it compares a std::string and an item. You need to write an operator like this
In order to use it in std::sort.
Alternativaly, if all your items can be converted to strings you may want to define a conversion from item to std::string as such
",1,19474212
19474330,"
As you didn't show your definitions for i, item
So, probably you need this :
Overload == for item 
This can sort special based on exact number of elements in all . If this is not the case you're having a XY problem
",0,19474212
19442092,"
I think this is causing the problem --
It should be 
Also if (low + 1 < high) should be changed to if (low < high)
Furthermore while (i < mid && j < high) should be while (i <= mid && j <= high) and single while loops below it too need to be updated with <=
",3,19441628
19442901,"
There is a bit of confusion in your handling of indexing limits.
Two very common ways to represent ranges are:

range limits are pointing between elements
range limits are pointing to elements


In the picture the numbering above is using the ""pointing between elements"" approach and the grayed out range is (2, 5).
The numbering below is instead using the ""pointing to elements"" approach and the same range is (2, 4).
As a personal preference I like the ""between elements"" approach much more: for example the size of a range is high-low and you can represent easily empty ranges or even inverted ranges. The important thing is however that you keep always clear in your mind if you're using the first or the second approach when writing code that is managing ranges.
In your code there's that kind of confusion; for example in mergesort you are checking if
and this means that you're using the ""between elements"" approach because when high - low = 1 means there is only one element and no sorting is needed. Also you recurse passing (low, mid) and (mid, high): another clear sign that the ""between elements"" approach is used because you surely don't want to move around array[mid] twice.
In the same code however you're passing the function 0 and array_size-1 in the main program, a clear sign that in this case you're using the ""pointing to elements"" approach instead.
Just double-check that all your index and range usage is coherent and the code will be fine.
",1,19441628
19442077,"
According to your sample code, only 5 numbers should be printed as result (because of const int SIZE=5).
That aside, note that you provide the position of the last element of your list as ""high"" parameter.
However, in your merge function, your while(j < high) conditions make sure that this last element in the list will not be sorted, because sorting stops just before reaching it.
Update: The for loop at the end of the merge function needs to be adapted to also copy the last (""high"") element back into the array a.
",0,19441628
19432364,"
I don't think it has a name, but it's pretty easy to accomplish.
First, you create a target vector and fill it with the indices 0...n.
Second, you sort that vector, but instead of comparing the numbers in the vector, you compare the numbers at the relevant index in the input vector.
Edit Note that I'm sorting in ascending order, whereas you're looking for descending order. Just flip the comparison in the lambda.
",13,19432272
19417283,"
You are asking too much of your ptr_vector. A ptr_vector is just a wrapper to std::vector. Likewise, there exist other wrappers to stdlib data structures.
A data structure that is always sorted (by performing sorted inserts) is the std::set. To use that functionality, you can use a boost::ptr_set. See here: http://www.boost.org/doc/libs/1_54_0/libs/ptr_container/doc/ptr_set.html
",2,19416908
19416983,"
Your logic for storing a number in a linked list is not correct.
Here is a suggested outline:

Always create a new node to store the number.
Always set the next pointer of the new node to NULL.
Find the end of the linked list at bucket[index].

If there is no linked list at bucket[index] then you have already found the end.



EDIT: You already had a while loop that follows the linked list from its head to its tail.
To get the values out of the linked list, you also start at the head and then follow the list until you reach the tail.  But, as you visit each node in the list, you get out a value.
But we can make this cleaner with a do / while loop.  You use a do / while when you want to do something at least once, and possibly more than once.  In this case, if we run this loop at all it is because we want to get out at least one number.  So:
It's cleaner to use a do / while loop, than to repeat the line that stores a value in out.
The loop can handle any length list other than length 0, and you already have the check with the continue to handle the case where there is no linked list in bucket[i].
",1,19416888
19404714,"
The algorithm ou are describing is straightforward: Iterate over all your points and find the minimum and maximum for each coordinate. This is an O(n) algorithm, n being the number of points you have.
You can't do better, since you will need to check at least all your points once, otherwise the last one could be outside the square you found.
Now, the complexity is at best O(n) so you just have to minimize the constant factors, but in that case it's already pretty small : Only one loop over your vector, looking for two maximums and two minimums.
",0,19404504
19404721,"
You can either iterate through all points and find max and min values, or do some preprocessing, for example, store your points in treap (http://en.wikipedia.org/wiki/Treap).
There is no way w/o some preprocessing to do it better than just iterating over all points.
",0,19404504
19404673,"
I'm not sure if there can be any faster way to find the min & max values in an array of values  than linear time. The only 'optimization' I can think of is to find these values on one of the other occasions you're iterating the array (filling it/performing a function on all points), then perform checks on any data update.
",0,19404504
19360949,"
The sorted sequence is
which corresponds reasonably well with your result.
You're expecting the result to be a mapping from input to output (""where would this item in the input go?""), but it's actually a mapping from output to input (""where would this item in the output come from?"").
",1,19360558
19350243,"
You forget to add:
just before
",0,19350181
19329500,"
to summarize the answers provided so far:
- use reference (or pointer ) to avoid copying vectors:
- use reserve when you know the size in advance, before using thousands of push_back (so that you do not need to reallocate dynamically whenever the capacity is exceeded)
- you can do const vector<int>& merge_sorted = ... to avoid copy when returning your vector
",1,19329425
19329602,"
Passing vectors by reference rather than by value makes a huge difference.  On my machine with SIZE=50000, compiled with -O3, before:
After:
I only changed two lines:
",3,19329425
19335681,"
Apart from the mrip answer about references, keep in mind:
""Insertion sort is one of the fastest algorithms for sorting very small arrays, even faster than quicksort. The best case input is an array that is already sorted. In this case insertion sort has a linear running time. The simplest worst case input is an array sorted in reverse order.""
",0,19329425
40859966,"
Merge sort is not necessarily slower than an insertion sort.
Time take by insertion sort to sort 'n' items is proportional to n squared (nn) while the time taken by merge sort is proportional to n times log of n base 2 (nlgn) 
So insertion sort is faster than the merge sort in some code while merge sort in others 
",0,19329425
19327930,"
for_each(sortNames.begin(), sortNames.end(), &displayOutput); goes through the entire set, and for each item, calls its displayOutput member function.
You apparently only want to call the displayOutput on the first item, sortNames.begin() and the last, sortNames.rbegin().
Sorry, but since this is apparently homework, I'm not going to give a more explicit answer than that.
As for avoiding end being shown (and being part of the collection), you have a basic problem with logic. Right now, you read a name, add it to the collection, then check if it's end, and if so quit adding more names. What you probably want to do is read a name, check if it's end, and only add it to the collection if it's not (then break out of the loop if it is).
I'd probably rewrite the code something like this:
I'd also note that there's really no need to store all the names in a set. You could just store two strings, one that's that's the first alphabetically among those seen so far, and one that's the last. When you read each string, check whether it's less than the first (and if so, save it as the first). Otherwise, check if it's greater than the last (and if so, save it as the last).
",2,19327862
19280639,"
""at the same time do not lose the elements of cities and countries those lats n longs are associated with""

When these are the values that belong together, why haven't you bundled them within a single object?

i.e.:


and once you load all locations into the std::vector<Location> then you could just define own comparator and use std::sort.  
This question might help you: How to use std::sort with a vector of structures and compare function? 
",5,19280566
19280868,"
If you create a class or a struct that holds your data together (instead of associating them via array indexes), you will find it much easier to manage:
",0,19280566
19259417,"
It's possible, but can be somewhat painful, as you'll end up writing a fair amount of boilerplate code.
Worse, when you're done, it won't work very well -- std::sort doesn't absolutely require random access iterators, but with (say) bidirectional iterators, performance will generally be fairly poor. Just for example, it's poor enough that (unlike most standard containers) std::list has a sort member function to make up for the fact that std::sort works poorly on linked lists.
Basically, operator+ and operator- just advance a pointer N items forward or backward. typically you overload operator++ to advance by one, something like pos = pos -> next; (and operator-- uses something like pos = pos->prev;. Then you can use std::advance or std::next to advance by more than one item at a time (but be aware: for a bidirectional iterator it'll do that by calling ++ or -- repeatedly -- one of the reasons for poor performance).
",1,19259326
19256793,"
By default, std::sort will use the less-than comparison operator for the elements of the container, which will perform am lexicographical comparison using the char first and then the double.
You can use your own ordering function/functor that orders based on the pair's double element only:
then
See working demo here.
",2,19256754
19256838,"
As Violet said, you may want to include your own comparison function:


std::sort uses operator < to compare the elements, and sorts them accordingly. It has an extra optional parameter for the comparsion functor, which we can include like this:


Note that this can also be done using a lambda in C++11.
",2,19256754
19256876,"
Is there a reason you're using a vector of pairs? In other words, does the order in which the elements are stored internally really matter to you? If not, you're probably better off using  a map<double,char> with a reverse iterator to get the last 5 elements sorted by double value.
",0,19256754
19256780,"
You need to write a comparison operator between the pair<char, double> operands.
http://en.cppreference.com/w/cpp/algorithm/sort
",0,19256754
19253349,"
Why don't you use the <algorithm> and <vector> library?
You can use partial_sort, which does exactly what you want
",1,19253279
19253317,"
What you need to do is call the stl functions random_shuffle and sort. Both of these functions take iterators, so you can provide just a range of values to each one.
",3,19253279
19237620,"
Yes. C++ STL library is built with separation of algorithms and containers. What links them together is iterators. Raw pointer is iterator, therefore it is possible to initialize vector with raw pointers and then sort that vector as usual.
",3,19237419
23620750,"
C++ Sorting 2-D array ascendingly
",2,19237419
19237946,"
In theory you should be able to input the 16 numbers into an array. Use a for loop, maybe even a nested one, to sort the numbers. Then as for output you want the ascending numbers in four groups of four? 
very arbitrary but I'm not quite sure of the question. 
",1,19237419
23936677,"
First Make a 2D vector .
Sort each vector in this 2D vector
Sort the whole vector 
Code :
",0,19237419
21217009,"
**Sorting 2D array in c++**
",-1,19237419
19237466,"
Here is the running version of your code, see the different for yourself:
",0,19237321
19237467,"
First off, swap won't help you order the pointer array. second I would, in your order function create a pointer array of the same size as your initial array and then perform the following inside void Order(////):
",0,19237321
19217567,"
You could use std::vector<std::pair<char,int>> to store character and it's count. 
To display the top 5 highest frequency's in order, you could sort by count in decent order:
",2,19217363
19217514,"
Assuming your example means that 'a' is at 0,0, 'b' is at 0,2, 1 is at 1,0 etc, which means that the character is always in the first row, you just have to iterate through every entry of 0[x].
This is to make your implementation work, but there are better or at least easier ways to do this. For instance, if your array sizes aren't fixed at compile time, you could use a vector of vectors. Or if you just want to track the occurrences of characters, you could use a stl map of characters to frequency.
",1,19217363
25970972,"
The
is wrong, because it causes insertion of a[j] at index 0 if a[j] were not to be moved. Change that to
Also, the shifting loop is wrong and complicated - change it to
",0,19216730
19200045,"
Since i goes all the way down to 0. Then i-2 can go to -2. Thus this line indexes before the beginning of the array, which is undefined behavior:
Here you are assigning over the value in the array without remembering what the old value was.
Thus you are loosing information and thus something is going to go wrong as a sort is not supposed to destroy information.
",2,19199963
19178368,"
The fastest data structure is an array- contiguous regions of memory, optimal for the cache.
Sorting depends. A combination of quicksort with insertion sort used to sort sub-arrays below a certain size might be your best bet without resorting to something more esoteric.
",2,19177987
19178092,"
You probably want to think about how you store these objects in your vector/map.  A smart pointer with the necessary comparison functor is probably what you want.
",0,19177987
19178180,"
If by ""set of numbers"" you mean each number only occurs once, and you want it sorted, use std::set. To be honest, unless you are dealing with huge amounts of data, std::list or even std::vector will probably be good enough.
",0,19177987
19178502,"
The Boost.Containers library contains a flat_set data structure. It implements a std::set interface on top of a std::vector data storage. Advantages according to the documentation

Faster lookup than standard associative containers
Much faster iteration than standard associative containers
Less memory consumption for small objects (and for big objects if shrink_to_fit is used)
Improved cache performance (data is stored in contiguous memory)
Non-stable iterators (iterators are invalidated when inserting and erasing elements)
Non-copyable and non-movable values types can't be stored
Weaker exception safety than standard associative containers (copy/move constructors can throw when shifting values in erasures and insertions)
Slower insertion and erasure than standard associative containers (specially for non-movable types)

",0,19177987
19178205,"

What is the fastest data structure

An array.

(and sorting algorithm)

Quicksort, provided you can tolerate the worst-case behaviour. Otherwise probably heapsort.
",-1,19177987
19165792,"
",1,19165605
19166038,"
MTYPE TYPE::*val; is a pointer on member from class TYPE. The member is of type MTYPE.
template <typename TYPE, typename MTYPE> struct it is a struct parametrised by two type.
TYPE which should be the class, MTYPE which should be the type of the member.
make_member_comparer is a helper function to avoid to use:
member_comparer<Number, int>(&Number::i)
",1,19165605
19161564,"
Are you just asking what the greaterAlpha method is for?
If so, you should use it for comparing two PhoneEntry instances where you used to use < for sorting and searching, i.e.
The binary search is also a very simple change if you've already got it implemented with std::strings. 
Side note: many would prefer to condense the comparison method to
",0,19160760
19148865,"
The closing brace for your outer for loop is in the wrong spot. This is a good example of why proper indentation is so important. Try this version:
",2,19148777
19131608,"
Because in the scenario you outlined, the vectors always have size 0.
You reserve more space in the vectors, but you never resize them. (So your for-loop just triggers undefined behavior by writing past the end of the vectors)
push_back grows the vector's size by 1, but if you don't call that, then you must call resize and set the size explicitly. (or specify the size as a constructor argument)
",2,19131541
19125331,"
First let me say your program has a lot of design problems, but to answer your actual question:
The trouble is you don't have an array of 50 pointers, you just have one pointer to the start of the array. In your sort function you have this line to swap the string pointers:
But this doesn't swap the pointers, it swaps the original strings. So instead of ending up with the original array of strings, and a re-ordered array pointing to those strings, you just end up with an array of re-ordered strings.
You should change std::string* pName; to std::string* pName[50];. At the start of your program, initialise the array to point to the strings.
Then in your sort function you should use std::swap() to swap the pointers themselves:
Finally, since pName[i] is now a pointer, whenever you actually want to access the string you have to dereference the pointer. For example,
becomes
The same problem exists with your method of sorting the ages.
A much better design for your program would be to use std::list<std::pair<std::string, int>> to store the names and ages. Then you can use the built in sorting functions to sort the list (and easily make a copy of it if you need to keep the original as well).
",0,19125204
19113558,"
the error lies in the fact that your argument to minMaxAvg.SetWindowTextA is str when you probably meant to pass someStr, ie. you are passing the original string instead of your newly formatted one.
",1,19113434
19104224,"
Create a custom comparator using std::tuple
It will use a first and then b second
",9,19104153
20107498,"
It's probably easiest to work with the array as if it were a single dimension, and keep the whole thing sorted.
Then when you display it, you can print it out either column-wise or row-wise, and it's guaranteed to meet your constraints. Of the two, printing it out row-wise will almost certainly be (quite a bit) easier.
Quick test driver program:
Results:
Of course, for any real use, you undoubtedly do not want to make the data a global, nor have functions like insert or print that implicitly operate on that global, but the I hope the basic idea comes through nonetheless.
",0,20107133
20121788,"
Take a look at the snippet I've written below.
I agree with Jerry, that its easier to just use and sort a one-dimensional array and just project it into the form you need. I used the same sort routine as Jerry except that this will lay out your numbers on a square matrix of your desired width.
Here's the output on my machine:
The output should always be sorted horizontally and verticall (even diagonally!)
",0,20107133
20103114,"
I'm posting this as a separate answer because it is totally different from my previous one.
A better method to approach this problem would be to use vector of std::arrays
This way you can treat each array as a single entity and as per this C++ Link the comparison operator would straightaway work like in a 1D array.
You do not need to loop through the sub-arrays yourself.
Of course you will need C++11 features to be enabled in the compiler.
",1,20102441
20102794,"
You should compare each sub-array with the current smallest sub-array not with the ith sub-array.
Try changing this to:
Also, IMO you should not enter the last -1 entry in you arrays.
Change this to:
Then you will have to change  
to
",0,20102441
20103356,"
This is more a comment than an answer, I'm posting it as such for the better formatting possibilities. In addition to what others have said:
You are aware that the breakwill be executed in case the comparison is false, right? It would be better to format this in a way to emphasize this if it is intentional, e.g.:
or even with an explicit else.
",0,20102441
20083003,"
No one will frown :)
This looks a decent solution.
A faster solution would be to hash each element and sort according to the hashes.
An example hash would be:
going over the original array/vector and sorting according to the hash values will be significantly faster on long vectors.
This will require more code.
As for minimal code, your is very nice. You can use lambda functions but they are less readable. 
",1,20082741
20085730,"
I would just do the same, except
Though, all that streams are quite slow, so you'd better use something like boost::spirit in case you have lots of version numbers or at least prepare data in vector<pair<array<int, 4>, string>> before sorting.
",0,20082741
20068373,"
You should point template type of SortByValue and also typename T* is wrong construction, it cannot be compiled. It should be
",2,20068308
20058394,"
The difference is one, as you say, takes a typical int array a[], but how would you know the size? So this version requires the user to send it to the function with n as the number of elements. In your Array class you provide a size so there's no need for it. In general you're providing overloads for multiple situations. 
I'm not sure what you mean by replacing int a[] w/ &arr, the signature is there, use what was given to you unless you're supposed to change it.
If you go back to your question about the Array class you can see an answer which uses the reference just as you would normally, i.e,
now apply it to this situation.
Also,
You won't be returning anything here considering void as the return and the use of the reference. You pass by reference as opposed to by value so that what you do in the function is persistent. You could choose to pass back the sorted array and not use a reference but I'm fairly certain it'd be slower overall considering the assignment and copy. That's why the example from your other question is using const Array &other. It prevents the entire array, which may be large, from being copied and sent to the function as well as being changed.
",2,20057842
20050296,"
Not an answer, but an observation. You have this code:
Consider that when n is odd, n/2 == (n-1)/2. And when n is even, (n-1)/2 == (n-2)/2. So you can replace all that code with:
",1,20047854
20051397,"
Since u is a vector of std::pair<double, std::string>, you will want to have the corresponding comparison function called. Since the name alone is not sufficient, you will have to disambiguate it for the compiler by casting it to a pointer with the right function pointer type. In your case it is a function that takes two const references to the pair type and returns a bool - so the function pointer type you have to cast to is exactly that:
Together that makes a pretty ugly cast:
Whoa.
Better use some typedefs to clarify what you are doing:
I changed some of the old C++03 stuff to C++11 in case your compiler supports it.
",1,20039912
20040007,"
You can use a functor instead:
",4,20039912
53722211,"
Since C++11, you can also use lambda expressions instead of defining comparison functions. This way, you neither need your Misc class nor worry about function disambiguation:
Code on Ideone
",0,20039912
20039045,"
It looks like you have implemented a less-than comparison for use with std::sort.
Such a comparator needs to be a strict weak ordering, such that A < B implies !( B < A ). Your function violates this if the numbers are equal and both have character M. Try this instead:
",1,20038953
20028203,"
Use the version with the getters, but replace left.pt1.getX() with left.getX(), etc.
And I'm guessing that in your Point2D class, you need to change
to
And likewise for getY.
Being passed const Point2D& left, const Point2D& right, you are under contract not to modify any values in those objects. You can only call their members functions that are declared const (they will not change the object). 
",3,20028187
20028366,"
bool Line2D::sortLine2DPtAsc (const Point2D& left, const Point2D& right)
your parameters are of type Point2D, maybe you meant to have them of type Line2D
if the function is sorting lines, why are you passing it points ;) 
pt1 and pt2 are members of the Line2D class not the your Point2D class
",0,20028187
20027684,"

Get first input.  Put it in the array.
Get another input.  Check to see it doesn't match anything else already in the array.  If it does, discard it.  If it doesn't, put it in the array in order (so the array stays sorted).
Repeat step 2.


Alternatively, if the assignment allows it, use a set.

And if you're not allowed to use a set, use a vector.  A vector will allow you to insert elements easily at a specific index to help keep things sorted.  And it will auto-resize as you add elements to it.
",1,20027656
20027810,"
There are many options by which you can do that.

First of all , if you are using only array , use std :: sort and std :: unique.
If the largest number in array is not very big you can maintain a bool array , which you can set to 0.         


Before entering the value in array check if the index value of a for that number is 0.
If it is 0 enter the value in the array ,mark that index of boolean array 1. 
Later you can sort using
3.You can maintain a set to enter values , instead of an array it will be a binary tree and will       discard any dupicate values and the values after insertion will be in a sorted order.
You can get values from the set using an iterator like 
",2,20027656
20028694,"
Since your numbers are integer between 1-40, you can use a trivial and fast solution (O(1)). And you can reuse this trick to do the sorting later. Here's the main lines:

Create an array of boolean with 40 elements initialized at false. I'll call it vals.
Every time you read a value, check the value of vals[input_value]. If it's true, it's a duplicate, otherwise set it to true.
Now, in order to sort the values, you simply do a for-loop from 1 to 40 and if vals[i] is true, then put in an other array or print it.

This is my solution:
This algorithm is inspired by the Counting Sort algorithm. The Counting Sort algorithm is a very easy and efficient algorithm that can be used when the elements are small integers.
",0,20027656
20016352,"
As per Dukeling's comment I realized that the solution I propose in fact is not linear,but linearithmic and even worse - you can't control if it takes extra memory or not. On my second thought I realized you know a lot about the array you to implement a more specific, but probably easier solution. 
I will make an assumption that all values in the array are positive. I need this so that I can use negative values as kind of 'already processed' flag. My idea is the following - iterate over the array from left to right. For each element if it is already processed(i.e. its value is negative) simply continue with the next one. Otherwise you will have a constant formula where is the position where this element should be:

If the value is odd and its index is i it should move to i*2
If the value is even and its index is i it should move to (i - n/2)*2 + 1

Store this value into a temporary and make the value at the current index of the array 0. Now until the position where the value we 'have at hand' is not zero, swap it with the value staying at the position we should place it according to the formula above. Also when you place the value at hand negate it to 'mark it as processed'. Now we have a new value 'at hand' and again we calculate where it should go according to the formula above. We continue moving values until the value we 'have at hand' should go to the position with 0. With a little thought you can prove that you will never have a negative('processed') value at hand and that eventually you will end up at the empty spot of the array. 
After you process all the values iterate once over the array to negate all values and you will have the array you need. The complexity of the algorithm I describe is linear- each value will be no more than once 'at hand' and you will iterate over it no more than once. 
",2,20016293
19989826,"
Your Java code looks bugged to me
That's not the code to swap two elements.
Does that make a difference to the execution time? I don't know heap sort well enough to be sure.
",8,19989751
19990130,"
You do not properly swap items in either your Java (as john pointed out), nor your C++ code:
In short, your code is ""more efficient"" because it doesn't do any sorting at all.
",2,19989751
19990901,"
There is one other issue in your C++ code that relates to how you're generating your random distribution:
d is always going to be 0 because you are perform an int division and then implicitly converting it to double afterwards. In short,  your randomval function isn't giving you any random values at all.
When you sort this with your own heap sort, the same code path is always executed. In your case, heapify will probably never execute this portion of code:
which is why your implementation appears to be faster.
Fixing the random test data with an actual distribution I think you'll find your implementation to be slower:
Rerunning the benchmark again shows:
",1,19989751
19979316,"
This would be an easier way to do it:
Then
Edit: std::tie requires C++11 support, but if you don't have it you can use std::tr1::tie from <tr1/tuple>, or boost::tie if you don't have TR1.
",5,19979212
19979320,"
In set<Point2D, p2d_sortby_y> the second parameter p2d_sortby_y does not name a type.
",0,19979212
19979327,"
It's usually better to define a functor class to specify the ordering, rather than a function; that way, you can specify it as a template parameter:
This has to take its arguments by value or const reference (not non-const reference, as yours does) to be used on the constant set members.
You can't directly initialise the new set from a different type of set, but you can initialise it from its range:
",0,19979212
19979334,"
Your two sets have different types (the compare function is part of the type definition).
Since std::set does not provide a constructor or assignment operator for different compare functions, you have to either initialize the new set with an iterator pair to your first set or std::copy over the elements.
That is:
or
",0,19979212
19958353,"
I haven't worked this out completely, but I think the general idea might help for integers at least. At the cost of more memory, you can maintain a separate data-structure that maintains the ending index of a run of repeated values (since you want to swap your incremented value with the ending index of the repeated value). This is because it's with repeated values that you run into the worst case O(n) runtime: let's say you have [0, 0, 0, 0] and you increment the value at location 0. Then it is O(n) to find out the last location (3).
But let's say that you maintain the data-structure I mentioned (a map would works because it has O(1) lookup). In that case you would have something like this:
So you have a run of 0 values that end at location 3. When you increment a value, let's say at location i, you check to see if the new value is greater than the value at i + 1. If it is not, you are fine. But if it is, you look to see if there is an entry for this value in the secondary data-structure. If there isn't, you can simply swap. If there is an entry, you look up the ending-index and then swap with the value at that location. You then make any changes you need to the secondary data-structure to reflect the new state of the array.
A more thorough example:
The secondary data-structure is:
Let's say you increment the value at location 2. So you have incremented 3, to 4. The array now looks like this:
You look at the next element, which is 3. You then look up the entry for that element in the secondary data-structure. The entry is 4, which means that there is a run of 3's that end at 4. This means that you can swap the value from the current location with the value at index 4:
Now you will also need to update the secondary data-structure. Specifically, there the run of 3's ends one index early, so you need to decrement that value:
Another check you will need to do is to see if the value is repeated anymore. You can check that by looking at the i - 1th and the i + 1th locations to see if they are the same as the value in question. If neither are equal, then you can remove the entry for this value from the map.
Again, this is just a general idea. I will have to code it out to see if it works out the way I thought about it. 
Please feel free to poke holes.
UPDATE
I have an implementation of this algorithm here in JavaScript. I used JavaScript just so I could do it quickly. Also, because I coded it up pretty quickly it can probably be cleaned up. I do have comments though. I'm not doing anything esoteric either, so this should be easily portable to C++.
There are essentially two parts to the algorithm: the incrementing and swapping (if necessary), and book-keeping done on the map that keeps track of our ending indices for runs of repeated values.
The code contains a testing harness that starts with an array of zeroes and increments random locations. At the end of every iteration, there is a test to ensure that the array is sorted.
",22,19957753
19958101,"

In a more specific case, if the array is initialised by all 0 values, and it is always incrementally constructed only by increasing a value of an index by one, is there an O(1) solution?

No. Given an array of all 0's: [0, 0, 0, 0, 0]. If you increment the first value, giving [1, 0, 0, 0, 0], then you will have to make 4 swaps to ensure that it remains sorted.
Given a sorted array with no duplicates, then the answer is yes. But after the first operation (i.e. the first time you increment), then you could potentially have duplicates. The more increments you do, the higher the likelihood is that you'll have duplicates, and the more likely it'll take O(n) to keep that array sorted.
If all you have is the array, it's impossible to guarantee less than O(n) time per increment. If what you're looking for is a data structure that supports sorted order and lookup by index, then you probably want an order stastic tree.
",10,19957753
19958206,"
If the values are small, counting sort will work. Represent the array [0,0,0,0] as {4}. Incrementing any zero gives {3,1} : 3 zeroes and a one. In general, to increment any value x, deduct one from the count of x and increment the count of {x+1}. The space efficiency is O(N), though, where N is the highest value.
",3,19957753
19958088,"
It depends on how many items can have the same value. If more items can have the same value, then it is not possible to have O(1) with ordinary arrays.
Let's do an example: suppose array[5] = 21, and you want to do array[5]++:

Increment the item:
(which is O(1) because it is an array).
So, now array[5] = 22.
Check the next item (i.e., array[6]):
If array[6] == 21, then you have to keep checking new items (i.e., array[7] and so on) until you find a value higher than 21. At that point you can swap the values. This search is not O(1) because potentially you have to scan the whole array.

Instead, if items cannot have the same value, then you have:

Increment the item:
(which is O(1) because it is an array).
So, now array[5] = 22.
The next item cannot be 21 (because two items cannot have the same value), so it must have a value > 21 and the array is already sorted.

",1,19957753
19958330,"
So you take sorted array and hashtable. You go over array to figure out 'flat' areas - where elements are of the same value. For every flat area you have to figure out three things 1) where it starts (index of first element) 2) what is it's value 3) what is the value of next element (the next bigger). Then put this tuple into the hashtable, where the key will be element value. This is prerequisite and it's complexity doesn't really matter.
Then when you increase some element (index i) you look up a table for index of next bigger element (call it j), and swap i with i - 1. Then 1) add new entry to hashtable 2) update existing entry for it's previous value.
With perfect hashtable (or limited range of possible values) it will be almost O(1). The downside: it will not be stable.
Here is some code:
",1,19957753
19958099,"
Yes and no.
Yes if the list contains only unique integers, as that means you only need to check the next value. No in any other situation. If the values are not unique, incrementing the first of N duplicate values means that it must move N positions. If the values are floating-point, you may have thousands of values between x and x+1
",0,19957753
19961717,"
It's important to be very clear about the requirements; the simplest way is to express the problem as an ADT (Abstract Datatype), listing the required operations and complexities.
Here's what I think you are looking for: a datatype which provides the following operations:

Construct(n):  Create a new object of size n all of whose values are 0.
Value(i): Return the value at index i.
Increment(i): Increment the value at index i.
Least(): Return the index of the element with least value (or one such element if there are several).
Next(i): Return the index of the next element after element i in a sorted traversal starting at Least(), such that the traversal will return every element.

Aside from the Constructor, we want every one of the above operations to have complexity O(1). We also want the object to occupy O(n) space.
The implementation uses a list of buckets; each bucket has a value and a list of elements.  Each element has an index, a pointer to the bucket it is part of. Finally, we have an array of pointers to elements. (In C++, I'd probably use iterators rather than pointers; in another language, I'd probably use intrusive lists.) The invariants are that no bucket is ever empty, and the value of the buckets are strictly monotonically increasing.
We start with a single bucket with value 0 which has a list of n elements.
Value(i) is implemented by returning the value of the bucket of the element referenced by the iterator at element i of the array. Least() is the index of the first element in the first bucket. Next(i) is the index of the next element after the one referenced by the iterator at element i, unless that iterator is already pointing at the end of the the list in which case it is the first element in the next bucket, unless the element's bucket is the last bucket, in which case we're at the end of the element list.
The only interface of interest is Increment(i), which is as follows:

If element i is the only element in its bucket (i.e. there is no next element in the bucket list, and element i is the first element in the bucket list):

Increment the value of the associated bucket.
If the next bucket has the same value, append the next bucket's element list to this bucket's element list (this is O(1), regardless of the list's size, because it is just a pointer swap), and then delete the next bucket.

If element i is not the only element in its bucket, then:

Remove it from its bucket list.
If the next bucket has the next sequential value, then push element i onto the next bucket's list.
Otherwise, the next bucket's value is larger, then create a new bucket with the next sequential value and only element i and insert it between this bucket and the next one.


",0,19957753
20006348,"
just iterate along the array from the modified element until you find the correct place, then swap. Average case complexity is O(N) where N is the average number of duplicates. Worst case is O(n) where n is the length of the array. As long as N isn't large and doesn't scale badly with n, you're fine and can probably pretend it's O(1) for practical purposes.
If duplicates are the norm and/or scale strongly with n, then there are better solutions, see other responses.
",0,19957753
20006152,"
I think that it is possible without using a hashtable. I have an implementation here:
",0,19957753
19957447,"

think and define a class Item that will represent a single item that will hold the data about a single student (code, name, ...)
create an empty std::vector of those structures that will hold your ""items""
open the file for reading
read the file line-by-line (use std::getline to get WHOLE lines, not just filestream.getline or file >> var operator)

(for each line that you read)
read the line as std::string, just as std::getline wants
create a Item for holding next group of data
analyze the line and cut/copy the student's code into myItem.code
analyze the line and cut/copy the student's name into myItem.name
analyze the line and cut/copy the XXXXXXXXXXXXXX into myItem.whateverelse
append the myItem that you have just read to the vector that you prepared earlier

close the file after reading all lines

Now you have a 'vector' that holds all the data, nicely stored as ""items"" that each have a code, name, and other data. You can now loop/search over that vector to find if any name or code matches.
",1,19957075
19957411,"
it looks like you need to create your own data structure to store the values. You can define your own struct 
and use a array of type  in this case Student
this is a very basic approach but it should get you going...
",0,19957075
19943973,"
sortFunc() is declared wrong, you have:
Where i and j is undeclared, the correct function declaration should be:
If you want to std::sort vector<Card>s, its best to overload the < operator:
",1,19943795
19944110,"
To add to Ben's answer, in addition to his proposed changes you'll also need to make Card::getFace and probably Card::getSuit const methods. Otherwise you cannot call these methods on an instance of const Card like in that sortFunc.
Note you have an option to either make sortFunc a free function like Ben's idea or you can also make it a static function inside deckOfCards:
This might communicate better in code that sortFunc is meant to be used with class deckOfCards.
Lastly, you should modify sortFunc so that it does a stable comparison:
The call to std::sort would then look like:
",1,19943795
19944049,"
Part of the problem appears to be that sortFunc takes two vectors, and you're trying to use it to sort a single vector. It should be defined like this:
A second problem: your call to sort is incorrect. When passing a function like sortFunc as an argument, you don't include paratheses or parameters. You just treat the function name like a variable name, like this:
Also, notice that I've defined sortFunc as a standalone function rather than a member function. If you try the call that I show above with sortFunc as a member function, it won't work, because you can't call a member function without an object of that type and sort doesn't have a deckOfCards object that it can use.
",0,19943795
19938758,"
There are several algorithms for iterative array sorting, all of them involve comparing elements and moving them as necessary to get the array sorted.
One way to do a recursive solution is to have a base case where an iterative sort is used if the array is very small, for a larger array it will split the array into smaller chunks and recurse.  Each of these chunks will be returned sorted and then they are merged (merging sorted arrays is fast).
So in pseudo code:
Note that the base case for the recursive sort may just be that array is empty or has only 1 element.  In this case nothing needs to be done in the base case so there is no dependency on an iterative sorting method.
There are of course other recursive algorithms that can be used, but the basic idea is the same: each recursive call will use some smaller chunk of the original array and those chunks are combined at the end to give a sorted result.
",1,19938539
19920690,"
If the array has been sorted already, you can count the occurrences of a number at once. Then just save the number that has biggest occurrences. And you can find out the mode in only one for-loop.
Otherwise, you'll have to do more than one for-loops.
See a details example at the link below
Find-the-Mode-of-a-Set-of-Numbers
Here is the code,
",5,19920542
19920685,"
One way is that you can use Run Length encoding. In Run Length encoding, representation would be like; (Item, Its frequency).
While doing so, keep track of the maximum frequency and Item. This will give you the mode once you complete the Run Length.
for example:
It run length encoding would be
It needs O(n) space.
",2,19920542
49504845,"
This is how I did it, my solution will take a sorted vector as input. It has O(n) time complexity and can work with the case where there are more than 1 ""mode"" number in the vector.
}
",1,19920542
21496693,"
Here is the code snippet:
",1,19920542
19920662,"
The ""mode"" is the value that occurs most often. If no number is repeated, then there is no mode for the list.
So there would be no benefit to sorting if you needed to know the ""mode"".
Are you sure you are not referring to the median? The median is the middle number in a set.
If you have 1,2,3,4,5 the Median (middle number) is the (total_number)/2) rounded up if it is odd, 2.5 -> 3 and our median would be 3. you can only really calculate the median if your numbers are sorted.
If you have an even number in a set 1,2,3,4,5,6
your mode is slots 3,4 (coincidentally also, 3,4)
(total_number)/2 slot and (total_number)/2 + 1 slot, for any even array of numbers.
http://www.purplemath.com/modules/meanmode.htm
",0,19920542
19920807,"
This code should give you the mode. If there are equal number of two different numbers, it will output the first of such.
",0,19920542
38749276,"
This code finds the mode in C++:
",0,19920542
42163511,"
I did it this way:
Also you can add another 25 to the list of numbers and see what happens if two numbers have the same occurrence!
I hope it helps.
",0,19920542
42460617,"
This code uses ""map"" to find out the MODE from the given array.
It assumes the array is already sorted.
",0,19920542
47107881,"
This had worked.
",0,19920542
53923646,"
There is an old adage that states ""If you put 10 programmers in a room and give them the same program to code you will get 12 different results"", hence my version of answering your question. It may not be as fast (I'm planning on testing it's speed versus some of the other suggestions) but I feel it is easy to understand.
",0,19920542
19918937,"
You're using the same comparison for both sides of the pivot.  That means you're allowing smaller values to stay on the right-hand side.  You need to modify as follows:
This is a classic copy-paste error.  Be careful when duplicating a section of code instead of writing it from scratch.  Your brain is very easily tricked into thinking you changed all the important bits.
",6,19918884
19888039,"
To sort a range using std::sort (or any function for that matter), it needs to know how two elements from the range are compared, in order to determine less than (or greater than) relationship. 
The Standard Library function std::sort comes in two flavors: one uses operator<, the other uses a compare function/functor. You've used both of them in your code — in particular, the third one in your example uses < and the rest use compare function/functor.
As for which one is the best approach? 
Well, it depends. The one which uses operator< is less flexible since it is fixed but requires you less typing as well. Use it when it suffices. 
The other one is more flexible as you can pass any compare function and get your elements sorted accordingly. Use it when operator< doesn't suffice. Also, when you choose this flavor, you have other choices as well : the comparer could be a function, a functor, or a lambda — if you use function or functor (defined at namespace level), then you can reuse them; on the other hand, lambda is usually defined in a function scope, so it is not that reusable, unless you define it at namespace scope, in which case it is almost same as function. 
Example, suppose you want to sort a vector of int in increasing order:
Output: -26,3,10,12. So operator< does do the job. 
But what if you want the elements sorted considering only magnitude (i.e ignore signs), then you have to use the other flavor:
Output : 3,10,12,-26. That is the output you would expect in this case.
Hope that helps.
",4,19887963
19888033,"
The sort function has two overloads
i. void sort( RandomIt first, RandomIt last ); It doesn't accept compare function, it expects the items have operator< defined. You'r method 3 uses this overload.
 
ii. void sort( RandomIt first, RandomIt last, Compare comp ); it accepts a compare function, it's useful when your items don't have operator< defined.
Methods 1,2,4 use this overload. All the passed third arguments can be called by (). Method 1, sends an object by cmp(), this object has overloaded operator() and above code invokes it. Method 2 and 4, sends pointer to functions and a pointer to a function can be invoked by ().
",4,19887963
19888149,"

How does operator() defined inside a class work? Should I not overload the '<' operator here as well? Why '()' ?

operator() is the function call operator. Instances of your class cmp are callable in the same way that a function is callable. The call is required by sort to perform the necessary comparison.

I sent an object as the 3rd parameter in method 1. But, in method 2, I sent the name of a function. Why is it like that?

Instances of cmp are callable. Function names are callable.

Which of the four methods is the best? I felt that method 3 was the easiest.

The main disadvantage of 3 is that you have defined that one Person is less than or greater than another Person according to their ages. What if you want to sort them by name elsewhere? You've already defined operator< for Person, so you can't do the same trick again. All three of the other methods define a comparison for use in a specific sort, rather than defining what it means in general to compare Person.
The main disadvantage of 2 is that it's somewhat harder for the compiler to inline than 1 or 4. It doesn't really have any advantages over 1, but for completeness it's nice that sort can take a function pointer.
The main advantage of 4 is that if you only use the comparison once, it's often nicer to have it right there in the same line of code that calls sort, instead of being off somewhere else in the file.
The main advantage of 1 is that it works in C++03 (unlike 4). 4 is more-or-less a new syntax for 1. 1 also has the advantage that it makes the comparator available for other code to use with the same name. You could achieve that with a lambda too if you wanted (you name a lambda by assigning it to an auto variable).
",2,19887963
19888045,"

You simply provide functor, object that has operator() and is used while comparing objects.
As far as I know, sort accepts functors, functions and lambda expressions to use them to compare objects.
In method 3 you doesn't provide functor, function or lambda expression to compare so it's by default sorted using standard operator<. Obviously it doesn't sort your Person objects by age, as you would like to. In my opinion the cleanest form is method 4, using lambda expression.

",1,19887963
19887628,"
Modify your vWords construction with a print statement:
And you'll notice that the entire file contents get pushed into your vector as a single string. Obviously sorting a single element won't change anything.
It's up to you to decide what should happen instead.
I'm assuming you mean that you want delimiter to be a newline. The only way I'm aware of to pass a newline to your program, as it stands, on the command line is like this:
(and note that your program works as I think you want it to)
The way I pass a newline as the command-line argument is that I have an opening "" then the enter key, then closing "" and enter again to run the command.
",1,19887477
19887607,"
I do not see the way you could pass carriage return as delimiter into your program, so you pass something else. And you get all lines from the file with carriage returns as one string. Sorting one string does not change anything, so you see the same output.
To see if that the case change output loop to this:
And check how many double quotes you see on the output.
",0,19887477
19887627,"
The problem appears to be that you are reading all the lines of the file into one string. The actual sort algorithm itself works, as demonstrated here
",0,19887477
19872232,"
std::sort, from the <algorithm> header, only works with random-access iterators, which std::list does not have.  But std::list does have its own sort member function, which uses a different algorithm.
",5,19872214
19857180,"
My guess is that the compiler optimises the temp variable away when it's in a function and the swap is recognised for what it is. But without the function the scope of the temp variable extends outside the block that it is used in, so without sufficient levels of optimisation the compiler might always store the last “temporary” value in it.
Try moving the declaration of temp from outside the loop to where you are using it, i.e., int temp = data[j].
Anyhow, this is just a guess; look at the produced assembly to verify.
",2,19857040
19858571,"

I expected it to be faster that way since function calls open up
  there own stack frames

It is perfectly reasonable to expect Swap to be inlined. In that case, the compiler does basically the same thing as you did manually and there will be no difference between the two versions.
And indeed, I have checked the code you posted here at SO both with clang 3.4 (trunk) and gcc 4.7.2, with optimization level -O3 and there is absolutely no difference between the two versions of your swap (Swap function vs. manually inlined swap).
Here is my code:
I compiled with (clan)g++ -O3 -std=c++11 sort.cpp -lboost_system -lboost_chrono -lrt.
So, the problem must be somewhere else.
",0,19857040
19849450,"
It seems you are compiling using VC++ with precompiled headers turned on. In that case, the compiler will ignore anything you have in your translation unit it find a line reading
Everything preceding this line will be replaced by the content of the precompiled header. I haven't really looked at anything else in your file because the above error needs to be fixed before you get sensible error messages for your actual code.
",0,19848942
19842086,"
std::map will sort its elements by keys. It doesn't care about the values when sorting.

You can use std::vector<std::pair<K,V>> then sort it using std::sort followed by std::stable_sort:
The first sort should use std::sort since it is nlog(n), and then use std::stable_sort which is n(log(n))^2 in the worst case.
Note that while std::sort is chosen for performance reason, std::stable_sort is needed for correct ordering, as you want the order-by-value to be preserved.
",59,19842035
19842744,"
You can use std::set instead of std::map.
You can store both key and value in std::pair and the type of container will look like this:
std::set will sort it's values both by original keys and values that were stored in std::map.
",14,19842035
19842156,"
std::map already sorts the values using a predicate you define or std::less if you don't provide one.  std::set will also store items in order of the of a define comparator. However neither set nor map allow you to have multiple keys.  I would suggest defining a std::map<int,std::set<string> if you want to accomplish this using your data structure alone.  You should also realize that std::less for string will sort lexicographically not alphabetically.
",1,19842035
19842203,"
EDIT: The other two answers make a good point. I'm assuming that you want to order them into some other structure, or in order to print them out.
""Best"" can mean a number of different things. Do you mean ""easiest,"" ""fastest,"" ""most efficient,"" ""least code,"" ""most readable?""
The most obvious approach is to loop through twice. On the first pass, order the values:
Then on the second pass, alphabetize the words, but only if their values match.
Strictly speaking, this is a ""bubble sort"" which is slow because every time you make a swap, you have to start over. One ""pass"" is finished when you get through the whole list without making any swaps.
There are other sorting algorithms, but the principle would be the same: order by value, then alphabetize.
",0,19842035
19830826,"
As some people noted, your version without the flag works, but is needlessly slow.
However, if you take the original version and just throw away the flag (together with the break), it will still work. It's easy to see from the invariant that you conveniently posted.
The version without the break has roughly the same worst-case performance as with the break (worst case is for an array sorted in reverse order). It's better than the original one if you want an algorithm that is guaranteed to finish in a pre-defined time.
Wikipedia describes another idea for optimization of the bubble-sort, which includes throwing away the break.
",0,19828888
19802341,"
There are three things in your implementation that either don't make sense or are outright wrong:
First these:
Neither of these statement have any effect at all, and I've no idea what you're trying to do.
Next, a significant bug:
The conditional clause of this for-loop is the assignment k = r + 1. Since r does not change anywhere within your loop, the only way that expression is false is if r == -1, which it never is. You've just created an infinite-loop on a counter k that will run forever up into the stratosphere, and in the process index, and write, to memory no longer valid in your process. This, as a result, is undefined behavior. I'm fairly sure you wanted this:
though I can't comment on whether that is a valid limit since I've not dissected your algorithm further. I've not take the time to debug this any further. that I leave to you.
Edit. in your main mergsesort, this is not ""wrong"" but very susceptible to overflow
Consider this instead:
And not least this:
Uses a variable-length array extension not supported by the standard for C++. You may want to use std::vector<int> L(n+1) etc.. instead.
",2,19802106
19802153,"
In your case the segmentation fault is likely being caused when you are trying to read memory in that does not exist for a variable, for example say you have an array called foo of size 10 (so foo[10]) and you this statement foo[11] would cause a segmentation fault.
What you need to do is use debug statements to print out your index variables (i, j, n, m, p and q) and see if any of these are larger than your array sizes
EDIT: Another unrelated issue is that you should not use using namespace std, this line of code can cause scoping issues if you are not careful, just something to keep in mind :)
",0,19802106
19801123,"
Just make rankor a simple functor:
Or if you have C++11
",7,19801077
19801120,"
Ranker::compare() is a member function. Member functions are tied to instances. Try using either a static method or a ""free"" function.
",5,19801077
19801167,"
The function Ranker::compare() actually has three arguments: In addition to the two Competitor objects, it also takes an implicit pointer to the object as parameter. However, the binary predicate passed do std::list<...>::sort() only takes two parameters.
The easiest fix is probably to make the function a static member. Not, however, that this is probably not the fastest approach because function pointers can rarely be inlined. If you want to reduce the function call overhead, you might want to encapsulate the logic into a a suitable function object:
BTW, a Boolean doesn't become more Boolean by returning true or false from a conditional statement! It is perfectly OK to return a Boolean value directly!
",0,19801077
19795385,"
Presumably you want to sort them lexicographically, in increasing order. You can do this:
The comparison functor is a binary predicate, and must return a boolean, and implement strict weak ordering. std::greater<std::pair<int,int>> does that for you.
",6,19795341
36205084,"
I recently wrote a little class that uses the Bose-Nelson algorithm to generate a sorting network on compile time.    
Benchmarks
The following benchmarks are compiled with clang -O3 and ran on my mid-2012 macbook air.
Time (in milliseconds) to sort 1 million arrays.
The number of milliseconds for arrays of size 2, 4, 8 are 1.943, 8.655, 20.246 respectively.

Here are the average clocks per sort for small arrays of 6 elements. The benchmark code and examples can be found at this question:
Fastest sort of fixed length 6 int array 
It performs as fast as the fastest example in the question for 6 elements. 
The code used for the benchmarks can be found here.
",12,19790522
35459892,"
The other answers are interesting and fairly good, but I believe that I can provide some additional elements of answer, point per point:

Is it worth the effort? Well, if you need to sort small collections of integers and the sorting networks are tuned to take advantage of some instructions as much as possible, it might be worth the effort. The following graph presents the results of sorting a million arrays of int of size 0-14 with different sorting algorithms. As you can see, the sorting networks can provide a significant speedup if you really need it.



No standard implementation of std::sort I know of use sorting networks; when they are not fine-tuned, they might be slower than a straight insertion sort. libc++'s std::sort has dedicated algorithms to sort 0 thru 5 values at once but they it doesn't use sorting networks either. The only sorting algorithm I know of which uses sorting networks to sort a few values is Wikisort. That said, the research paper Applying Sorting Networks to Synthesize Optimized Sorting Libraries suggests that sorting networks could be used to sort small arrays or to improve recursive sorting algorithms such as quicksort, but only if they are fine-tuned to take advantage of specific hardware instructions.
The access aligned sort algorithm is some kind of bottom-up mergesort that apparently uses bitonic sorting networks implemented with SIMD instructions for the first pass. Apparently, the algorithm could be faster than the standard library one for some scalar types.
I can actually provide such information for the simple reason that I developed a C++14 sorting library that happens to provide efficient sorting networks of size 0 thru 32 that implement the optimizations described in the previous section. I used it to generate the graph in the first section. I am still working on the sorting networks part of the library to provide size-optimal, depth-optimal and swaps-optimal networks. Small optimal sorting networks are found with brute force while bigger sorting networks use results from the litterature.
Note that none of the sorting algorithms in the library directly use sorting networks, but you can adapt them so that a sorting network will be picked whenever the sorting algorithm is given a small std::array or a small fixed-size C array:
As mentioned above, the library provides efficient sorting networks for built-in integers, but you're probably out of luck if you need to sort small arrays of something else (e.g. my latest benchmarks show that they are not better than a straight insertion sort even for long long int).
You could probably use template metaprogramming to generate sorting networks of any size, but no known algorithm can generate the best sorting networks, so you might as well write the best ones by hand. I don't think the ones generated by simple algorithms can actually provide usable and efficient networks anyway (Batcher's odd-even sort and pairwise sorting networks might be the only usable ones) [Another answer seems to show that generated networks could actually work].

",9,19790522
19793193,"
There are known optimal or at least best length comparator networks for N<16, so there's at least a fairly good starting point. Fairly, since the optimal networks are not necessarily designed for maximum level of parallelism achievable with e.g. SSE or other vector arithmetics.
Another point is that already some optimal networks for some N are degenerate versions for a slightly larger optimal network for N+1.
From wikipedia: 

The optimal depths for up to 10 inputs are known and they are
  respectively 0, 1, 3, 3, 5, 5, 6, 6, 7, 7.

This said, I'd pursuit for implementing networks for N={4, 6, 8 and 10}, since the depth constraint cannot be simulated by extra parallelism (I think). I also think, that the ability to work in registers of SSE (also using some min/max instructions) or even some relatively large register set in RISC architecture will provide noticeable performance advantage compared to ""well known"" sorting methods such as quicksort due to absence of pointer arithmetic and other overhead.
Additionally, I'd pursuit to implement the parallel network using the infamous loop unrolling trick Duff's device.
EDIT
When the input values are known to be positive IEEE-754 floats or doubles, it's also worth to mention that the comparison can also be performed as integers. (float and int must have same endianness)
",8,19790522
19792301,"
Let me share some thoughts.

Does anyone have any opinions on whether or not this is worth the
  effort?

It is impossible to give a correct answer. You have to profile your actual code to find that out.
In my practice, when it comes to low-level profiling, the bottleneck was always not where I thought.

Does anyone know if this optimisation exists in any standard
  implementations of, for example, std::sort?

For example, Visual C++ implementation of std::sort uses insertion sort for small vectors. I'm not aware of an implementation which uses optimal sorting networks.

Perhaps it would be possible to generate a sorting network like this
  statically using template magic

There are algorithms for generating sorting networks, such as Bose-Nelson, Hibbard, and Batcher's algorithms. As C++ templates are Turing-complete, you can implement them using TMP. However, those algorithms are not guaranteed to give the theoretically minimal number of comparators, so you may want to hardcode the optimal network.
",3,19790522
19779775,"

johnsearch.h(2): error C2065: 'string' : undeclared identifier

Your header file uses string , so you'll need to include <string>, before your declarations. You also need to qualify it as std::string since the string class resides in the std namespace
So your header file becomes:
(you should also use include guards in your header files)
Your JohnSearch.cpp also uses string, again, since string is in the std namespace, you'll get errors if you don't use std::string
In your TestSearch.cpp, you have a using namespace std; at the top, you could do the same in JohnSearch.cpp too, that way you can use string instead of std::string
",0,19779307
19779379,"
When in doubt, simplify. You can boil the code down to something like this:
and get the same error (and maybe a warning about an unused parameter).
Yes, string is a type of variable, but it's not innate in the C++ language itself, it's in one of the standard libraries, something you have to tell the compiler about:
",0,19779307
19779390,"
In your header file that you include, you need to have the exact same signature than your function in the cpp file. 
Also dont forget to #include <string>, and then use a string like : std::string
E.g. 
And in your cpp
Signature is ""int function(int, int)"".
",0,19779307
19763529,"
You have a couple mistakes, but not all are evident to you (yet).
I took the liberty of using a for loop and size_t, which are better practices here.
",2,19763474
19763576,"
I tried implementing your code as is. It appears to sort the vectors in descending order. Try toggling the trues and falses from your myfunc function.
Output:
After toggling the trues and falses, the following code sorts the vectors in correct order.
Output
",1,19763474
19762931,"
The simplest way to do this is to sort by each column in turn, starting with the least significant column. So if the user chooses sort by a then b then c, then you first sort by c, then you sort by b, and finally you sort by a. The last two sorts (b and a) must be a stable sort (std::stable_sort), which preserves the existing order for otherwise equal elements.
The other way of doing it -- which is almost certainly faster but might not be practical -- is to use a custom compare function. But coming up with the custom compare function is not easy. In the example you provide, where there are only three variables, then there are only six possible compare functions (one for each ordering of a,b,c -- you can put the unspecified columns at the end) but in the general case you end up with too many possibilities to enumerate. You could use a complicated collection of switch statements to write a general comparator, but the overhead of that comparator may well turn out to be more than sorting the vector multiple times.
",2,19762822
19764850,"
Since you asked to provide code that dynamically creates a suitable comparison function ...
Disclaimer: The following code probably is not comparable to sorting the vector multiple times with a stable sorting algorithm like std::stable_sort in terms of performance. It is only supposed to illustrate an idea. The following code is written using C++11 features, which may not be available to you yet. It can, however, easily be rewritten in C++03 using, for example, boost.
Let's assume that you have your class A and some getter functions for each member variable:
We are going to define functions that are returning -1, if one instance of A is smaller than the other one, 0, if they are equal and 1 otherwise. These functions can be combined more easily.
Now, for each member function we are defining a comparator:
We can easily combine comparator functions:
These functions can be converted to a less-like functor:
Sorting after first, than second column:
",1,19762822
19758854,"
If you want your algorithm to be fast, you should reduce searching as much as possible. Also, you do not need to know which intervals are ""chained together"" for determining a correct channel for each (i. e. not using more channels than absolutely necessary). Here are the steps/techniques I would use for maximum performance:

Define your interval class like this, adding the two inline function definitions (that I use a struct for the TimeDescriptor is simply a matter of style, not that this code is exactly stylish, though):

Create an array of pointers to all TimeDescriptors, two for each TimeInterval (one for the start, the other for the end).
Sort this array of TimeDescriptor pointers by the time. Make sure that you use the isEnd flag as a secondary sort key. I'm not sure how interval collisions are defined, i. e. whether the two intervals (20, 30) and (30, 40) clash or not, if they clash, sort end times after start times with the same value, if they do not clash, sort end times before start times with the same value.
In any case, I would advise to just use a standard quicksort implementation to sort your array.
Create a stack for unused channel numbers. The important things about this stack are: It must allow you to fetch/push a channel number in constant time, ideally by updating no more than two numbers in memory; and it must be bottomless, i. e. it must allow you to pop any number of values, producing an ascending sequence of integers.
The easiest way to implement such a stack, is probably to program a small class that uses an std::vector<unsigned> to store the free channels, and that keeps track of the largest channel number ever used. Whenever a pop request cannot be serviced from the internal storage, a new channel number is produced by incrementing the largest channel number by one.
Walk through your sorted array of TimeDescriptors. Every time you encounter a start time, fetch a channel number, and store it in the corresponding TimeInterval (using getInterval()). Every time you encounter an end time, push its channel number back onto the free channel array.
When you are through, your free channel stack will tell you the maximum number of channels you used simultaneously, and every TimeInterval will contain the correct channel number to use. You can even efficiently compute all the interval chains that share a channel by simply resorting the TimeInterval array by the channel number...

",0,19757146
19759893,"
This question already has an accepted answer.  However I wanted to describe a slightly different approach than the accepted answer.
You've Got To Measure
You aren't going to be able to tell anything about performance without measuring.  And to measure we need test cases.  So it seems to me that the first job is to create a program that will generate test cases.
I made a whole bunch of assumptions, which may be incorrect, and generated the following code to generate test cases:
One can vary the value of N, the range of the seeding on the random number engine (if not the choice of random number engine), the range of start times, and the type/shape of the probability distribution of time durations.  I pulled each of these choices out of thin air.  Your professor may have better ideas on the generation of reasonable test cases for this problem.  But measuring something is better than measuring nothing.
Make use of the std::lib
The standard library is full of containers and algorithms.  Not only is this code debugged, it is efficient.  Re-use of this code is good coding style because:

It teaches you to recognize containers, and when to use what container.
It teaches you to recognize algorithms, and when to use what algorithm.
It can help you identify the need for, and code your own containers and algorithms when they are not supplied by the std:lib.
It makes your code much easier to read for others, because they will know about std-defined containers and algorithms.
It makes your code much easier to debug, because the probability of bugs in your code is much higher than the probability of bugs in the std::lib (though neither probability is zero).

For Example
I augmented your TPhone struct with I/O to ease the complexity of the I/O you are doing in main:
And I chose vector<TPhone> to hold all the calls.  This simplifies this:
Down to this:
And as it turns out my version is more efficient than yours.  I get this efficiency ""for free"", just by learning how to use std::vector.
AllocChannels can now take a std::vector<TPhone>&:
In here I used the simplest possible algorithm I could think of.  Not because I thought it might be fastest, but because you need a baseline to measure against.  And as it turns out, simple is not always slow…
I've used a few C++11 features because they are convenient (such as auto and lambdas).  If you do not have these features available to you, they are easy to work around in C++03.  The basic algorithm I've used is to just sort by m_TimeFrom, and then do a linear walk through the sorted list of calls, and for each call a linear search through the set of channels looking for one that is not in use (creating a new one if all are in use).  Note the use of the standard algorithms sort and find_if.  No sense in re-implementing these, especially for a base-line test case.
I used <chrono> to time everything:
I instrumented your code in exactly the same way so that I could test both.  Here are my results, first generating a test case of length = {100, 1000, 10000, 100000, 1000000, 10000000}, and for each length running first your code then mine, both using this output only:
Here is what I got:
Summary
No one here, including myself, predicted that the most simplistic solution would consistently beat your first try by whopping amounts.  This could be a characteristic of the test cases I've generated.  That would be something else for you to study by generating other test cases to measure against.
I do not know the cause of the Segmentation fault for your case with N = 10000000.  I did not take the time to study your code.  Quite frankly, I find your code complicated.
I neglected to write a correctness test.  That should actually have been my first step.  Is the output correct?  I got lazy and simply glanced at the N == 100 case to see if it looked right.
Because of the re-use of std::containers and algorithms, my code will actually be much easier to tweak for performance than yours.  For example you could try std::lower_bound (a binary search) in place of std::find_if, and measure if it improves things or not (I'm betting not, but you should measure, and with a test.dat that you have respect for).
Factor your code into containers and algorithms.  Reuse std-defined containers and algorithms when they exist, else create ones of your own that can be reused in your future coding.  As a student, I expect the std-defined ones to be adequate for most of your use cases.
Always test for correctness (as I failed to do so here :-)) Don't assume anything about performance without measuring.  Binary searching is not always faster than linear searching, even though it has a better asymptotic complexity.  And the input data can strongly impact the performance of your algorithms.  Learn how to generate varied input data to get a feel for how your algorithms can be impacted.  <random> is great for this task.
",4,19757146
19757601,"
Store the entries in a std::vector<TPhone> instead of in a TPhone **. This will layout consecutive TPhone objects consecutively in memory, leading to fewer cache misses.
Experiment with other data types than unsigned int for the members of TPhone. See <cstdint> for types that you can try.
",2,19757146
19757815,"
If you have the collection sorted, why would you use a linear search? Use a binary search.
",0,19757146
19757269,"
Let [ai, bi) be your intervals, i = 1, ..., n.  You want to design a function channel(i) that returns a channel number for each of your n intervals.
The only constraint you have is that no two intersecting intervals can be on the same channel.  This corresponds to an undirected graph where your  intervals are vertices and there is an edge between two vertices if and only if the corresponding intervals intersect.
You can assign a channel C to a particular set of vertices (intervals) if those vertices form an independent set.
You want to find a set of independent sets of this form, where the union of all of them covers the graph, and they are pairwise disjoint.  You want as few independent sets as possible.
The (related) problem of finding a maximum independent set is NP-complete.  So I don't think you should expect to find a polynomial-time algorithm for finding the solution that gives you the minimum number of channels.
More realistic expectations come in one of two forms: either (A) spend super-polynomial time to solve the problem, or (B) use an approximation algorithm that may not give you a global optimum.
For (B) you can do this:
Now using this procedure you can exponential search for the minimum M for which feasible returns true.
Try M = 1, 2, 4, 8, 16, ... until you hit the first M = 2k such that feasible(M) returns true.  Then do binary search between 2k - 1 and 2k to find the minimum M.
",0,19757146
34053666,"
Sorry for being a necromancer here, but after reading the question and posted answers, I just could not let this one go.
Channel Assignment Algorithm:
The problem has a greedy solution which is extremely efficient. Consider the following recursion:

Assign first interval to channel 1
For each remaining interval:


For each channel (assigned at least 1 interval):


If no conflicts exist with assigned intervals, assign interval to this channel and process next interval.

If conflicts existed in all channels, assign interval to a new channel.


This will produce the optimum number of channels. Proof is trivial, by induction on number of intervals.
Sorting the Inputs
The key to speed lies in ""if no conflicts exist"". This means there will be comparisons between what has been processed and what is left to process, and it should be easy enough to convince yourself that sorting the inputs first is going to be faster in the end than sorting them as they are processed (or not sorting them at all).
If you aren't convinced, consider the following two extremes:

All intervals overlap.
No intervals overlap.

Choosing a Sorting Algorithm
We need to sort the inputs by start, then end time. This is easy enough if we choose a stable sort, and sort first by end time, then by start time. A stable version of Counting Sort is likely the best option given that all the values are integers; the number of inputs is much greater than the range of inputs; and memory usage is not an important consideration. This sort is linear in the number of inputs under these conditions.
Sorting the Channels
By sorting the inputs, we need only compare each interval to the last interval assigned to each channel. In the extreme case where no intervals overlap, this algorithm is then linear: O(n) sort, + O(n) processing = O(n). On the other end of the extreme where all intervals overlap, without further improvements the algorithm would be quadratic.
To improve this, rather than compare against all channels, if the channels were sorted by earliest end time, then a conflict with the first channel would automatically indicate that all channels conflict. Then for each interval we need only 1 comparison, and whatever is required to maintain the sorted order of the channels.
For this, I would propose keeping the channels in a min-heap (by end time). The channel needed for the comparison would always be at the top. Peek at that channel, and:

If there is an overlap, create a new channel, adding that to the heap. This new channel may have to move up the heap at a cost of O(lg m) where m is the current number of channels.
Otherwise, pop the min channel O(lg m), add the interval to it (changing it's value) and add it back to the heap normally O(lg m).

In the worst-case nightmare scenario, the sorted intervals would have monotonically increasing start times, and monotonically decreasing end times. This give us the worst-case for the algorithm of O(n + lg 1 + lg 2 + ... + lg n) = O(n + lg(n!)) = O(n + n lg n) = O(n lg n)
Real-World
Asymptotically better is not always better. It really depends on the distribution of inputs, as well as the size of the inputs. I'm confident the algorithm described here is superior to the others presented, but there is certainly room in the implementation for choices which are asymptotically identical, but will produce different results.
",0,19757146
19738481,"
There are a variety of spatial acceleration data structures that help to answer questions of 'what points are in this region'. Quadtrees are a popular solution for 2D but may be overkill for your problem. Probably the simplest approach is to have a 2D grid with points (stars) bucketed by the grid square they fall into. You then check to see which grid squares your view window overlaps and only need to look at the stars in the buckets for those squares. If you make your grid squares a bit larger than your view window size you'll only ever have to check a maximum of four buckets.
If you can zoom in and out a more complicated structure like a Quadtree might be appropriate.
",3,19738416
19740853,"
I use real star data for rendering (psychosomatic style) for years and have no speed problems without any visibility ordering/selecting under OpenGL (VBO)

I usually used BSC star catalog in the past

stars up to +6.5mag 
9110 stars

few years back I convert my engines to hipparcos catalog

118322 stars
3D coordinates


So unless you use too much stars it should be faster to just render them all
- How many stars are you rendering?
- How are you stars rendered? (I use blended Quad per star)
What platform/setup ...
- this worked well even on my old setup GeForce 4000 Ti, 1.3GHz single core AMD
- also in stereo 3D
what is your desired FPS ? ... I am fine with 30fps for my simulations
If you have similar values and low speed may be there is something wrong with your rendering code (not with the amount of data)... 
PS.
if you have a big space to cover you can select bright stars to viewer  only

after each hyperspace jump or what ever
based on relative magnitude and distance

also you use too much ifs for star selection

they are sometimes slower then the rendering
try just dot product of viewing direction and star direction vectors instead 
and test the sign only (do not see what is behind)
of course if you use quads then CULL_FACE make it for you

Also i see you are calling draw for each star

that is heap trashing
try to avoid calling functions when you can
it will boost the speed a lot !!!
for example you can add a flag to each star if it should be rendered or not
and then render them with single for and no sub-calls to render function

",0,19738416
19748231,"
You can try spatial R-tree which is now part of Boost Geometry library.
The application could work as follows:
You add your star's coordinate to the tree in some ""absolute"" coordinate system. If your stars have different sizes you probably want to add not a point but a bounding box of each star. 
As you build your universe, you populate the rtree:
When you need to render them, you compute your screen window into ""absolute"" coord system and query the tree about stars which overlap your window:
Here result_s will list the relevant stars and their bounding boxes.
Good luck!
",0,19738416
47039251,"
You can do a std::vector<std::pair<int, std::string>> and just use std::sort(<yourvec>.begin(), <yourvec>.end() to sort your members.
To create a std::pair<int, std::string>, call the constructor with your number, and the name linked with it.
",1,19715815
19715987,"
If the numbers are unique, put the numbers and names into a std::map<int, std::string>. While you are at it, count the occurrences of each name in a std::map<std::string, unsigned int>.
",0,19715815
19714436,"
You could implement that as a Counting sort
First you count how many times each element occurs, element being the index in the array that stores the number of occurrences of each value.  Then loop through that array, until each index has a value zero. 
This might not the best(or most efficient) way to implement it, but this is the solution that first comes to mind. 
",2,19714333
19714752,"
Assuming you're willing to modify your original multiset, (or work on a copy of it), do something like
This isn't very efficient.  If you have a huge dataset, then maybe you need to think about what your constraints are (memory or time?).
",2,19714333
19714949,"
In Python, you can use groupby  to get a matrix of the unique groups of items from a sorted list:
More succinctly, you can use a list comprehension to do the same thing:
Or, you can expand the Python version of a multiset, Counter, and sort the keys to get this same nested list:
Once you have the nested lists groups, invert the matrix using izip_longest, flatten the lists, and delete the None values:
Prints
",2,19714333
19715036,"
Here is how to do by hand in python without any imported libraries:
and here is the outputString
",1,19714333
19715526,"
If you may use a second sequantial container then in C++ you can simply move elements of the original container in the second container by means of standard algorithms std::unique_copy and std::set_difference.
",1,19714333
19715745,"
",1,19714333
19721548,"
in C++, instead of manipulating data structures, you could prepare a list of iterators to the beginnings of the equal ranges, and then dereference/increment those iterators in turn:
",1,19714333
19709943,"
It is impossible. swap function called by value does nothing. From where the problem is?
",1,19709855
19710000,"
I guess your teacher just want you to understand the difference between passing by value and passing by reference, through this type of question. So now you realize that passing by value will not change the calling functions' variable value.
",1,19709855
19708442,"
What platform are you running on? If you're on Windows, you could try the high-resolution time library.
If you have access to C++11, there is a header called chrono that has similar functionality, and is portable (ish)!
",4,19708417
19698668,"
make_heap is O(n), not O(n log n). For large datasets, it can be quite a lot faster than sorting.
The O(log n) operations (push and remove_min) are probably only a little faster than a balanced binary tree implementation, but their storage overhead is a lot lower, which also improves their cache friendliness. For small objects, like integers, a heap uses around a quarter of the memory that a std::set uses.
",3,19698549
19699173,"
Insertion for a sorted list is not O(log n), its worst case O(n) because you have to shift elements in the array.
",2,19698549
19698590,"

You may not want the entire sort sequence.
You may want to get hold of the first item quickly and spread the computational load for sorting among all the entries on retrieval, instead of paying it all up front.
You may want to process a collection that is larger than can fit into memory. A heap can produce a sorted run of on average 2N its own size. This technique is used in sort-merge programs, when the number of initial runs dominates the time to sort each run.

In these situations, heaps win.
",1,19698549
19695267,"
Read const and pointer declarations from right to left:
So, arrayCopy is effectively an array of constant pointers (and so is array).  Constant pointers cannot be moved (i.e. you cannot change where they point).  Thus, you cannot overwrite them, and thus, you cannot sort them.
If you wanted an array of pointers to constant TPhone (i.e., you cannot change the fields of TPhone, but you can move pointers around), then you should move the const:
Then you can change the pointers (which are just memory addresses), but you cannot change the actual TPhone objects.
",3,19695176
19692543,"
There is no one answer to this, because the right answer depends (heavily) upon how much you care about speed vs. extra storage.
If you want absolute maximum speed, and don't care at all about using extra storage, yes, you can create three copies of the data, one sorted by each field, and when a search is entered, just use the appropriate one. This may not be nearly as awful an option is it might first appear. Let's assume your strings average about 10 bytes apiece, so the overall size of the struct is ~30 bytes. 100'000 of those gives roughly 3 megabytes per copy, for a grand total of about 9 megabytes. At one time that would have been clearly prohibitive -- but with a typical machine now having at least 8 gigabytes of RAM, it's not nearly so terrible.
Assuming you rule that out, the next most obvious possibility would be to build indexes into the raw data -- put the raw data into one array, then build one index for each field, where each entry in the index contains the data for one field, and a pointer/subscript to the main data. Each index entry can be ~14 bytes, so each index is about half the size of the overall data. With only three fields you don't save a lot, but you do save some -- and at an extremely minimal cost in complexity. With more fields, you'd save even more.
Another possibility would be to implement your indices as hash tables. The primary advantage here is that you can avoid storing date repeatedly. For example, if you compute a 16-bit hash with 2 entries per bucket, you can store one index in ~512K bytes. If a bucket is full, but neither entry matches your input, you re-hash and try another bucket. Keep going until you either find your item or find an empty bucket.
",1,19691333
19692095,"
You can try Boost.MultiIndex:

The Boost Multi-index Containers Library provides a class template named multi_index_container which enables the construction of containers maintaining one or more indicies with different sorting and access semantics:


But if you want to try yourself - then one the simplest solutions will be: use one container for all data, and in addition maintain several maps with appropriate indices's:
You can use std::unordered_map in order to get O(1) average access. Here is example:
Output is:
Live Demo on Coliru
",1,19691333
19673200,"
If you know for a fact that m = O(n2), you can do a base-n radix sort to sort the array. This is like a normal radix sort, but instead of having 2 buckets or 10 buckets, you have n buckets, one for each possible base-n digit of the numbers.
Since the runtime of radix sort in base b is O(n logb U), where U is the maximum value, in this case we know that the runtime is O(n logn n2) = O(n). This is asymptotically faster than O(n log n). It also only requires O(n) memory, which is below the limitation of O(m).
Hope this helps!
",1,19673104
19673129,"
Radix sort, doesn't require the limitation on values being less than m either. 
The example implementation below is templated on the int type. If your m is always less than 2^15 you should use a vector of int16_t if possible (or better uint16_t if values are always positive to avoid the offset to handle signed integers). This will require only two sorting passes rather than 4 for 32 bit ints. If you can't change your input type you could special case the code to only do two passes and avoid the signed offset.
This implementation is O(n) and uses O(n) extra space (sort is not in place).
",3,19673104
19673146,"
No, you need to do:
",0,19673104
19651822,"
No. less doesn't have 1 argument. It has 1 template parameter. Which is not the same as 1 argument.
Also it's a class not a function. More precisely it's a functor - a class with an overloaded () operator so it can be used as a function.
Consider an implementation like this
less<int> can be called as
where a and b are ints.
So there is one template parameter (T == int), but there are 2 arguments (int left & int right).
",4,19651743
19651866,"

what is use of less? It has only one argument.

No, it only has one template parameter. The actual function call itself takes two arguments, both (const references IIRC) of the type specified in the template parameter.
",2,19651743
19649507,"
I see a couple different solutions that could work here. If you define a class like so:
with some different comparison functions (isGreaterAge(), isAlphabeticalName()), that might work.
If this doesn't have to be a linked list (is this schoolwork?), you could use maps or (more suited for your purpose) multimaps, which are specifically designed to do this sort of thing:
http://www.cplusplus.com/reference/map/multimap/?kw=multimap
",0,19649393
19649521,"
This is mainly dependent on the way you have designed your data structure and how the sorting algorithm executed on it.
Data Structure:
You need to keep both the information name/age in a given node's data pointer apart from the doubly linked lists pointers.
So the insert will have two arguments one is name and another age apart from the list head pointer (if function is re-entrant)
Sorting:
There are different ways to sort, what i would prefer is?
Initially while list creation nodes are inserted in sorted manner based on the name (considering there is priority associated for name sorting rather than age)
So whenever user asks for the named sorting we can directly list all the elements.
Now when the user is asking for age-wise sorting you need to perform actual sorting but don't change the links just print them and mark them as visited or processed whatever you call and continue.
Hope this helps you.
czar 
",0,19649393
19646723,"
",2,19646673
19646741,"
I would use std::sort
",0,19646673
19646742,"
another solution:
",0,19646673
19620891,"
You can use a functor too :
With C++11, you can use a lambda function :
",4,19620832
19620858,"
You'll need to overload the ""<"" operator, like so:
",4,19620832
19620894,"
Use std::sort and provide a custom comparator (template arg Compare)
",1,19620832
20504130,"
I am unable to see anything wrong with your code, it works perfectly fine. The only issue is you forgot to return something inside pivote.
",2,20503958
20489487,"
First, remove this line
Second, change this,
to,
If you use new, then you'll deallocate the space by delete. If you use malloc, then you'll deallocate the space by free. Mixing up between the two will cause problem.
Prefer to use new/delete over malloc/free.
According to C++ FAQ Lite,

[16.4] Why should I use new instead of trustworthy old malloc()?
FAQ: new/delete call the constructor/destructor; new is type safe,
  malloc is not; new can be overridden by a class.
FQA: The virtues of new mentioned by the FAQ are not virtues, because
  constructors, destructors, and operator overloading are garbage (see
  what happens when you have no garbage collection?), and the type
  safety issue is really tiny here (normally you have to cast the void*
  returned by malloc to the right pointer type to assign it to a typed
  pointer variable, which may be annoying, but far from ""unsafe"").
Oh, and using trustworthy old malloc makes it possible to use the
  equally trustworthy & old realloc. Too bad we don't have a shiny new
  operator renew or something.
Still, new is not bad enough to justify a deviation from the common
  style used throughout a language, even when the language is C++. In
  particular, classes with non-trivial constructors will misbehave in
  fatal ways if you simply malloc the objects. So why not use new
  throughout the code? People rarely overload operator new, so it
  probably won't get in your way too much. And if they do overload new,
  you can always ask them to stop.

",2,20489401
20487757,"
Instead of parallel vectors, why not put the related elements into a struct?
Alternately, instead of declaring a struct, you could just use a std::pair<int,int>, if you don't mind generic names like first and second for the fields.
",0,20487098
20480749,"
In the context of your function (as this is the last statement) this is exactly the same as:
Leading to infinite recursion since n is not modified in the function.  What you probably want is this:
Also, this is wrong:
You want the index to be i, not max.
",3,20480613
20480730,"
It is obvious that this statement
is invalid. There is no any sense to use the maximum element as the index. I think you meant the following
",2,20480613
20473747,"
D'oh!
I was ready to dig into the Qt Source Code. But as I single stepped through my code, I saw the cursor jumping to the return statement in the 'default' case.
I had just forgotten to add a 'break' to my switch-case! It was just a simple fall-through error :((
It works now perfectly fine with ""layoutChanged"".
",3,20471456
20472071,"
I just did this. First, you have to connect the header signal to the sort method you have created. This is a Python sample so you'll need to adapt it to C++:

When you sort, the entire view will change - or at least most of the view will change. So emitting the modelReset signal will cause the view to change. Model reset is one of the most inefficient signals to call, because it causes the entire view to be redrawn. However, most of the view will change anyway on a sort. 

You could also emit the dataChanged signal, indicating that all of the data has changed. The dataChanged signal may be faster.
Python:
C++:
(emitting a dataChanged signal, in a subclass of QTableView)

",1,20471456
20462285,"
This is a classic first C++ assignment, and I gather that it's to get you used to the various tools available in the Standard Template Library.
Firstly, sorting. There is a function in the <algorithm> header called std::sort that will do this for you. Check out this reference to learn a little more about it. It will seriously ease your pain.
For searching, try std::find.
Next you want a lookup that keep letters (chars) and a count of how many times each one occurs as the first letter of a name. An std::map<char, int> is a class that does this for you. A simple for loop with char_count[name[0]]++;, where char_count is a map, is likely what you want.
",1,20462132
20462187,"
If you need to find all the matches it might just be simpler to search linearly through the array rather then using a binary algorithm. This approach is Slower but easier to implement and get your head around if your new to C++. 
As you traverse the array you can build up an array of matches and return that. 
",0,20462132
20462251,"
If I understand step 4 correctly, if you have a list like (""Andrew"", ""Ann"", ""Dave"", ""Dominic"", ""Don""), you want to output something like: 2 A, 3 D. Correct?
If that's the case, then you simply need to loop through your sorted list examining the first character of each string.  If it's the same as the previous character, increase the count.  If it's not, output the previous character and reset the count.  A little special handing for the start and end of your looping and you're done.
BTW, I don't see a need for the binary search, or is there more to this assignment?
",0,20462132
20462291,"
Something like this works
",0,20462132
20461568,"
I see two possible problems: 

Passing the vector to the function as a value (this effectively copies the whole vector)
Creating new vectors for the smaller and bigger elements, instead of some in-place processing

Basically the function copies all balls in the initial vector for every level of your kd-tree twice. This should cause some serious slow down, so try to avoid requesting so much memory.
One way to solve it would be to access the data of the vector directly, use nth_element etc. and only pass the indices of the subvectors to the recursive call.
",1,20460581
20457425,"
If you convert the names' character to upper-case using std::toupper you should then just be able to compare the the strings using < operator.
Edit: if you don't want to use std::sort :-)
",3,20457270
20457726,"
Here's an answer using std::sort. I changed some of your C-like approach and using std::sort actually forces me to do it. The comparison function(compareStudents) needs objects so I had to create the struct. Vector has been used for the same reason although it would have been possible to keep using arrays but that's generally frowned upon.
",3,20457270
37495890,"
",0,20457270
20457339,"
if you want all the nnumbers to be sorted you can use vectors
....
At this moment the vector is sorted. 
Does that answer your question?
",0,20457266
20454959,"
Change your swap logic. Swap both name and age.
You should wrap condition inside in if to a function so that you can change your logic easily.
",1,20454905
20455019,"
When you sort the array with the ages (age) the connect between the ages and their names gets list: prior to sorting, the name and the corresponding age where stored at the same index.
To fix the problem you can do, e.g., one if these  approaches:

When swapping two ages during sorting also swap the two names.
Use an auxiliary array with pointers or indices indicating the names and swap that in addition to the ages (similar to the first approach but avoiding to swap strings). When printing you'd find the relevant name through this auxiliary areay.
Store a pair of name and age in the array and swap these pairs but use only the age part to determine the sort order.

",1,20454905
20455037,"
Also swap the corresponding names with age.
Also one more suggestion, Whenever you have such linked data, It's better to use the structure because It make sense to keep the relative data as a group.
And also if you swap them, all the data will be swapped so would not get this type of issues.
",1,20454905
20455788,"
Since age typically varies from 1 to 120 :) , we can use this to our advantage. Use a mapping technique to map the age to an array index. It will speed up sorting considerably when your data set expands. I've demonstrated this for 5 people , but it can easily be modified to work for large data sets by chaining linked lists.
",1,20454905
20448047,"
Your comparison function A::cmp is a non-static member of A. Thus, it takes three arguments: in addition to the two arguments explicitly declared, it also takes a pointer to A to become the implicitly available this. It also has a different type than normal function pointers: bool (A::)(int, int) which decays into bool (A::*)(int, int) when being passed by value.
You could std::bind() your function to a suitable object, however:
",3,20447991
51210441,"
The answer by @DietmarKühl explains perfectly, why your code does not compile.
But since C++11, you can also use a lambda expression instead of defining a comparison function or making it static:
I order to be able to access the class member text in the lambda expression, I captured the this pointer.
However, if you want an alternative to capturing this, please take a look at this answer.
",0,20447991
20447085,"
Almost certainly not. Two obstacles that spring to mind are:
1) the standard doesn't define what algorithm std::sort uses, so portable code cannot know exactly how many comparisons are performed other than just trying it.
2) even if you did know the algorithm, I think that for sensible sorting algorithms figuring out the number of comparisons required can't be any easier than figuring out the number of inversions, which itself has the same complexity as sorting. So you aren't going to get a massively more efficient solution.
The workaround for 2 would be if the sort algorithm was such that the number of comparisons doesn't depend on how close to ordered the data is, only on the size of the data. It's not too difficult to design a sort algorithm with that property. It would probably be less efficient than a ""real"" sort algorithm, but could well be more efficient than sorting twice.
So just for example in a merge sort, normally when one side of the merge is exhausted you copy the remainder of the other side straight into the destination. If at that point you did a bunch of extra redundant comparisons solely to make up the numbers, then the number of comparisons wouldn't depend on the order of the input. And the number of pointless comparisons would be worst case half the total, so it shouldn't be any worse than sorting twice. This isn't a ""fair"" comparison with std::sort, though, because merge sort isn't a valid algorithm for std::sort anyway: it uses too much extra memory.
Sorting networks use a fixed number of comparisons too, but are also no good for std::sort because you need to know the number of items to design the network...
",3,20447038
20440652,"
Your swap is wrong.
This wont do anything!!
You need to be taking reference arguments, ie cahnge the function signature to:
Also, bool sorted (string sortfirstname[3]) has errors, try:
this correct 2 things. (a) you ran over end before, (b) you decided whether they were sorted exclusively on last test. 
",1,20440598
20440622,"
The for cycle exit condition should be i<3-1 because later you are accessing (i+1)-th element.
",0,20440598
20434049,"
Use strcmp(s1, s2) for comparing C-style strings. It returns a value less than zero if s1 is less than s2.
And one more hint: C-style strings are null-terminated strings (i.e. there is a zero value after a string itself), so you need an array of size at least n+1 for storing a string of length n. In your case, 30 is not enough but 31 is.
",1,20433901
20388969,"
You can use two maps - one map to store mapping from the key (your first column) to the value (your second column) and second map to store mapping from the key (your first column) to the record number:
Then you need to scan the second map m2 in order to find the key with minimal position:
The result will be the first key, for which there are no records with this key down the road. Using this key and the first map m1 you'll be able to find its corresponding value. 
",2,20388870
20388911,"
You can check from the bottom, and remember the first(last when counting from the top) appearance of each index. And after You've done this (in time O(n)) You can take the last You found.
",1,20388870
20389486,"
What does query return? You can choose std::vector<some-structure> if it returns a known structure, or std::vector<std::vector<std::string> > if it returns a string list.
Then going from bottom and remembering all unique ids that you see you are able to get the last good value in o(n) time and o(n) memory.
",0,20388870
20388060,"
You can use std::sort from the <algorithm> header:
Or if you don't have lambda functions:
",1,20387899
20386786,"
I think you are looking for the Quicksort Algorithm
",0,20386750
20386909,"
There are more ways to sort an array.
If you are trying to implement a loop recursively, you can check out a wikipedia article. It is well explained under ""Recursion computer science"". 
Otherwise you can try to implement different sorting algorithms. The well known are Quicksort and Mergesort.
There are many sorting algorithms
",0,20386750
40269374,"
",0,20386750
40276891,"
Use std::sort defined in algorithm header file
",0,20386750
22333154,"
return p;
    }
",0,20386750
53717355,"
Well, I'm writing a Python interpreter and didn't write loop yet. I got the codebase from some website and rewrite the loop by some recursion. It works. :D
",0,20386750
20385647,"
this implies that compareAscendFreq is a member function -- that is, that it requires a this pointer. You need to supply 3 arguments to call it:
while sort needs a two argument comparison function.
There is no reason to make compareAscendFreq a member of a class; make it a free standing function.
",2,20385565
20369109,"
It's OK to write such code if you are learning algorithms. 
However note that in ""real C++"" (i.e. production code) we tend to:

use STL containers instead of arrays 
use STL algorithms instead of raw loops

Code:
Links:

Containers library
Algorithms library
Why should I use container classes rather than simple arrays? 
Scott Meyers: STL Algorithms vs. Hand-Written Loops

",2,20368663
20368877,"
Use std::sort with customized compare function

use std::vector to hold the Names array
define a customized compare function

use std::sort


",0,20368663
20368727,"
Inside selectionSort you need to get rid of the three calls to .at(0)
when you write name[startScan].at(0), the varible name is an array of strings, so name[startScan] is a string, so name[startScan].at(0) is the first letter of that string.
You need to compare by and assign by strings, not by chars. Getting rid of the .at(0)'s will do that, tho it will leave you with type errors, needing a few adjustments, and thus        char startScan, minIndex, minValue; should be 
",0,20368663
20364965,"
If I could choose, I would go for a Partial Quicksort.
Info on Partial Quicksort
But if you have to compare these two only... then Partial sort is better vs partial sort copy. Here you have more info about these two methods:
Info on Partial Sort
Info on Partial Sort Copy
Here you also find an algorithm code example for Partial Quicksort - it was implemented in C and matlab:
Example - Partial Quicksort
",6,20364848
20365638,"
Using the following code
I get the following results:
Tested using Visual Studio 2013 in 64bit release mode on an AMD Phenom II x4 2.5GHz.
",9,20364848
20370709,"
Have you tested your code? 
std::partial_sort_copy(vars.begin(), vars.end(), &tmp[0], &tmp[x]); will not copy anything to tmp[x] since &tmp[x] is considered the end of the half-open range (ie., it's just past the last valid element).  So your return statements access indeterminate or default constructed array elements.
Try the following:
Note that if given an initializer_list as the source of data, a modify-in-place algorithm such as nth_element or partial_sort won't work since initializer lists can't be modified (whether the parameter is marked const or not - the iterators into the initializer_list are const qualified). So a copy must be done to find the median using the standard algorithm functions, either by copying the list before calling the algorithm, or by using an algorithm variant that performs the copy as part of its work, such as partial_sort_copy().
",1,20364848
20365405,"
Looks like you meant to nest the 2nd and 3rd for loops in the first for loop. Like this: 
",0,20364057
20364301,"
Use std::sort with a custom comparator or define operator< for your type.
Example:
",3,20363682
20360551,"
http://en.wikipedia.org/wiki/Radix_sort
the key fact is that you're working with integers and you know the largest key, which is exactly when radix sort is used and its complexity is linear.
also second approach if k of them are already sorted you can use some version of shell sort with sequence that will yield the best result
",4,20360478
20360654,"
Selection sort is a good choice when your array is already mostly sorted; it should perform only O(n(n-k) swaps. If the sorted elements tend to be contiguous, then Timsort might also perform well. In neither case will you do better than O(n log n) for sufficiently small k, of course.
",4,20360478
20361753,"
If we do not know:

how k and n are related to each other
and how exactly the k elements are located in the array

There is simple no option we can do much better than Θ(nlog(n)) in the worst case.
Why:

Let put k=1 and good luck...
Let say that k=0.9n and let place the k elements in the front. Even if we knew that they are in the front, then we still have to sort array of size 0.1n, so in the worst case we need 0.1*n*log(0.1*n)=0.1*n*(log(0.1)+log(n))=0.01*nlog(n)-0.1*n comparisions which is Θ(n*log(n)).

Of course this is just theoretical result for the worst case. In practice the information that there  are exactly k elements on proper places, can limit significantly amount of work to be done. But for sure we need to know bit more about k and n (or at least assume something).
",4,20360478
20362691,"
Adaptive sort is a kind of sort algorithms which take advantage of existing order in its input. Insertion sort is one of the adaptive sorts, which works well when the array is almost sorted. Of course, the worst case is O(N^2).
There are other adaptive sort such as,
Adaptive heap sort, which use treap to take the advantage of ordered elements when build the heap. Adaptive merge sort(Natural merge sort) and Smoothsort 
The theoretical complexity will also be O(N*lnN), but they might perform more effectively when the data is partly sorted.
",0,20360478
20363903,"
Algorithm:

Locate the run of k contiguous elements already in order
Sort the other n-k elements
Merge the two sorted lists

Example with n=8, k=4.

['echo', 'cat', 'bat', 'board', 'hand', 'hotel', 'kilo', 'hit']

Locate the 4 contiguous elements already in order.

['echo', 'cat', 'bat', 'board', 'hand', 'hotel', 'kilo', 'hit']

(As it happens, we found 5 already in order. All the better.)
Sort the other elements

[cat, echo, hit]

Merge the two sorted lists

['bat', 'board', 'cat', 'echo', 'hand', 'hit', 'hotel', 'kilo']

Done.
The time complexities of the three steps are

O(n)
O((n-k)log(n-k))
O(n)

For any fixed the ratio k/n, the second step dominates (for large enough n).
",-1,20360478
20359267,"
To sort your data structure using the std::sort() algorithm, you could supply a comparator function as its third argument.
For example, to sort by the values of dat.a:
Then, you call sort like this:
Also, you could refactor your code to avoid the magic number 10, also to avoid duplicating it when referring to the one-past-last element in the call to std::sort().
",2,20358998
20359221,"
No, it won't work as written.
First std::sort((array.a),(array.a+10); is incorrect.  array.a is not an array, and trying to treat it as one will certainly lead to some problems.
You would need to instead sort the array itself (std::sort(array, array+10);), but again, that won't work because you don't provide an overload of opeartor<(dat).
You could provide one:
Then std::sort(array, array+10); would work as expected.
When you sort an object, it ""all goes together"".  That means that dat::a and dat::b will not be modified within a specific object, but the location of that object in the sorted array may be at a different index.
",1,20358998
20359230,"
If you want to sort the array of structures according to the value of a:
This will move the b values along with their corresponding a values, which I think is what you say you want. If you want the b values to stay where they are, then it would be somewhat messier. C++ doesn't provide any way to treat an array of dat as an array of int.
",0,20358998
20359291,"
For starters, array.a isn't a legal expression, since array
doesn't have an a member, and in fact, isn't even a struct.
If you want to sort the dat members by field a, you'll need
to either provide a custom ordering function (the preferred way,
especially if you have C++11 and can use lambda functions), or
define an operator< on dat.  If you just want to move the
a members during the sort, leaving the b members where they
are... you'd have to define a custom swap function as well: 
But this would be very wierd, and I'd suggest finding some other
way of organizing your data.
",0,20358998
20353685,"
Use a functor:
This should still work in an older version of the compiler...
",2,20353629
20345400,"
Put the file names into a vector as you read them.
When you've read all of them, use std::sort to sort the array.
Then process the sorted file names as you see fit.
",7,20345378
20319946,"
Use  :
mylist.sort(std::greater<T>());
T is type of container elements. eg. int, char, float, etc.
For T as objects you need to overload operator '>' or define your own comparator function
And then,
mylist.sort(cmp);
",3,20319882
20315823,"
This loop 
is invald because you are trying to access element array[6] that does not belong to the array. The valid range of indexes of the array are [0, SIZE -1] that is [0, 5]
",0,20315769
20315477,"
The data member is called Number, not Num.
While you're at it, change the operator to take the argument by reference:
Finally, the entire if can be succinctly expressed as
",1,20315454
20315480,"
Yes it will work, but you need to use Number
Number is what you've used as  member in your struct Card
",0,20315454
20315497,"
The name of the corresponding data member is Number  not Num.
The correct declaration and definition of the operator will look as
",0,20315454
20315498,"
you have Number member in your Card class, not Num.
refactor
to
or change function (and take argument by reference regardless if you refactor class or function body):
",0,20315454
20312238,"
You're probably compiling in C++03 mode and default template arguments for functions are not allowed there. See this SO question for details. So if you want default template arguments, you can either switch to C++11 or use a functor instead of the function.
Using class Player as a comparator would work, but you have to instantiate it every time you call insertionSort, which is not for free as the class is not empty. It seems more efficient to have separate functor for comparing Players.
Also, you don't need to call less method in insertionSort, calling the comparator directly is enough. (c(input[j], input[j-1])).
Another solution would be to specialize std::less<Player> and use std::less for the comparison all the time. Please refer to this SO question.
",1,20311747
20312223,"
The message I got back clang makes it pretty clear.
""default template arguments for a function template are a C++11 extension.""
This is a feature missing in C++98 which was later added in C++11.
",0,20311747
27981576,"
The stl sort requires the rvalue of the iterator being passed as the arguments. If you wanna use the sort function, you will have to compile in c++11 and use the array stl to store the array. The code is as follows
Compiling in c++11 can be done by g++ -std=c++11 filename.cpp -o out.
In case you do not want to use c++11 or use the ""array"" stl, use the std::qsort function. With this you can use the traditional way to define the arrays like int a[10][2]. The code is as follows
",3,20304553
20319698,"
Make your own compare function.  
See the Beginners guide to std::sort().
http://www.cplusplus.com/articles/NhA0RXSz/
",0,20304553
20296255,"
This:
Looks like you are trying to add one default-constructed element to the vector.  There's an easier way:
Apart from being easier to type, and more generic, it's also a lot more correct: we should not be newing anything here, just creating a single value at the end, and we should let the vector construct it rather than copying it in, which might be wasteful.
And of course we should never try to delete these values.
",1,20295680
20280226,"
You can use C++ itself to sort (quite efficiently) arrays, using any valid rule you want. If you want it in ascending order, you can use the default variety, which automatically uses < effectively. If you want it in descending order, you just have to use the opposite comparison, the >.
Example:
Just to be precise, a valid rule for sorting is one that produces a weak ordering of the items in the container. The Wikipedia page has the rules, but they are mostly this (calling any general ""rule"" the symbol < and x,y,z are items in your container):
1.) x < x is never true.
2.) If x < y is true that means y < x is false. (and if x < y is false and y < x is false, they are seen as ""equal"")
3.) if x < y is true and y < z is true then x < z is true.
",1,20271685
20272354,"
Just had to limit the inner loop to <9.
The fixed code:
Thank you guys!
",0,20271685
20266809,"
If speed doesn't matter:
",2,20251965
20254295,"
On the algorithmic side of things, there's an interesting optimization; pseudo-code:
If we have random-access iterators, we can skip ranges pretty quickly, once we have an initial element (preceding elements are smaller, succeeding greater or equal):

If *cur == *(cur+N), then the range with value *cur is large enough. If *cur != *(cur+N+1), or cur+N == end, then it is indeed the range we're looking for. Else, it is too big, and we can search for the next range (either linearly or with a binary search in [cur+N+1, end)).
Else, *cur != *(cur+N), then the current range is too small. Every range completely inside [cur, cur+N] is also too small, so the next range to check is a range that starts inside [cur, cur+N] and extends beyond cur+N. This range is of the value *(cur+N), so we only need to find its initial element (binary search).

Note: Due to the increased ""complexity"" of a binary search as opposed to a linear search (the constant factors), and due to the rather unpredictable memory accesses, this will probably be slower for a list of small ranges than the strictly linear approach.
",2,20251965
20253439,"
A great deal here depends on frequency of insertion and deletion vs. searching, how large of lists you're looking at, etc.
For the moment, I'm going to make two assumptions:

You're dealing with large enough lists that an asymptotically better algorithm is likely to win over the obvious linear search.
You're doing a lot of queries with the data essentially static.

If that's true, you start by run-length encoding the input data, so you get value/count pairs.
Then you sort those pairs based primarily on the count, and secondarily on the value. Finally, use std::lower_bound to find a value, with the comparison based solely on the count.
This requires O(N log N) for the preprocessing. In exchange, each query requires O(log N) instead of O(N). Therefore, you need to do O(N) queries on the preprocessed data to justify the preprocessing.
",1,20251965
20254157,"
When N is larger, the detection of N same numbers might be ""optimized"" a bit.
It relies on having at the start of the for-loop a new value.
",1,20251965
20253249,"
Here is my solution. It does not use any stl standard algorithm but it has the best possible complexity - O(n) and I believe it is quite readable and understandable:
      if (range_size == N) {
        cout << cur_value_index << endl;
      }
I assume the sequence is provided in an array a and N is the limit you talk about in the question. 
I have used vector for illustration but the very same algorithm can be applied if we don't have random access for instance for list. In that case we would keep an iterator to an element of the sequence instead of an index, but the rest would remain unchanged. 
",1,20251965
20253886,"
",1,20251965
20251104,"
If the vectors are not ordered then in any case the complexity will be equal to O( m * n ) where m and n are sizes of the vectors.
",0,20250971
20251184,"
Sorting the vectors by itself is a way slower from what you could achieve if the items are hash-able. It will take (N+M) to create a hash table from one of the vectors, and then search for the items from the other in it. 
",0,20250971
20172263,"
Yes, and if you don't want to use the std, this is a code snippet I just wrote. It works ok:
",0,20171702
20171788,"
Simplest form would be using std::vector with std::sort and std::vector::erase+std::unique
",3,20171702
20172033,"
You could try to use an std::list which will take care of the sizing for you. 
If its a vector of integers you can have sort for ""free"" already via std::sort.
std::list
Than just go over the list and delete all duplicates.
",0,20171702
20169800,"
http://www.cplusplus.com/reference/algorithm/sort/
It even has one of its examples directly relevant to your problem.
",4,20169743
20169821,"
Sorting algorithms are one of the cornerstones of most beginner computer science courses and are a rather important study in the science itself. They are also very well documented on the internet. 
You can ask for help with specific errors but asking for us to write it for you is not going to teach you anything.
",2,20169743
20168959,"
Call std::sort(RandomIt first, RandomIt last) passing a suitable comparison function as comp. The default comparison function will compare elements the way that you want them ordered.
",1,20168931
20168961,"
For your particular case, the default comparison within std::pair will work.
http://en.cppreference.com/w/cpp/utility/pair/operator_cmp
Apply this rule with one recursion step to see that this is the case:

If lhs.first < rhs.first, returns true. Otherwise, if
  rhs.first < lhs.first, returns false. Otherwise, if
  lhs.second < rhs.second, returns true. Otherwise, returns false.

In C++11, if you need to choose the sorting criterion at runtime, you can use a lambda for comparison.  It should take const references to the type, and return bool.
Here is what it would look like.
",0,20168931
20168765,"
You will need to measure but I would guess that a std::priority_queue<T> has a fair chance to be most efficient. Using any of the other heaps won't do you much good because you don't really need the additional operations (changing the priority of an element) but being able to use these operations increases the overhead quite significantly.
Especially when the size of T is a bit bigger but even if it is just an int, you may want to use a d-heap with d == 8: although this results in more comparisons it reduces the number of times an object is moved.
",2,20168663
20167120,"
a) Use sort function with lambda notation as below( if you are using c++11)
Working code:
http://ideone.com/bDOrBV
b) Make comparator function as static
http://ideone.com/0HsaaH
",4,20167035
20167079,"
",2,20167035
20165129,"
You start with an array with an empty section of 'known to be white' values, an initially large section of 'unknown' values, and an empty section of 'known to be red' values.
First:

Establish the size of the 'known to be white' section by counting the number of leading white values.
Establish the size of the 'known to be red' section by counting the number of trailing red values.

It is fine if either size is zero; you just need to know what the size is.
You can step through the 'unknown' section one value at a time:

If the next value is red, swap it with the value before the last 'known to be red' value, extending that section.
If the next value is white, swap it with the value after the last 'known to be white' value, extending that section.
Otherwise, leave it where it is.
Restablish the 'known to be white' and 'known to be red' sections.

When the loop finishes, all the white objects are at the start, all the red objects are at the end, and the black objects must be in the middle.
Note that the order of the tests is important (and reversed from the original version of this code). As Yakov points out in his comment, in the scenario where the current value is red and the value before the 'known to be red' section is white, the first test moves the red to the 'known to be red' section but moves a white into the current position. You then have to check whether the current position is white and move it.
If this is too many swaps, have fun working out how to do it another way.
This code seems to work.  It has rather extensive self-checking and testing. The full debug code is available on request (GPL v3).
Sample output:
It's been run through a few million random tests.
",1,20164204
20155657,"
Instead of addCities you really want to overload operator>> for your City class:
Then you can read the data (which you're currently doing incorrectly, BTW) like this:
Then sort something like:
And you can write out the result something like this:
Note that I've made CityList a vector instead of a std::list -- the latter is a mistake much more often than not.
",1,20155431
20155540,"
You could try to use the std::list::sort, as you can see from here
You obviously need to define your comparing method.
",0,20155431
20155556,"
If you can't use C++11 features you can still do something like this:
",2,20155220
20155574,"

[...] based on the 1st element of the pair< int , int> and if those are equal then sort them according to their second elements [...]

std::pair already has lexicographical comparison C++03 20.2.2/6:
So, as WhozCraig pointed out, you should just compare .seconds of outer pair.

This is a lambda expression, I dont have C++ 11 with me, is there no other way possible?

Use functor:
Or maybe more generic version (depends on your needs):
LIVE DEMO:
Output is:
",2,20155220
20155252,"
Where x is your container, and X is the type of an element.
",0,20155220
20135681,"
To perform a shellsort, you compute the gap sequence, sometimes called the increment sequence, using i starting at 1 and incrementing it until it's large enough to sensibly start sorting (Sedgewick suggests that when you get the largest gap sequence less than N/3).
Then you shellsort starting with the largest gap down to 1.
Note: the gap sequence equations you posted don't seem to agree with what's on Wikipedia's shellsort page and don't seem to work. You might want to verify the equations you want to use.
",2,20135527
20132764,"
Here's the code, obviously you can alter the array length and numbers to meet your specifications. 
",1,20131634
20131841,"
Sort the entire array (Choose any sort algorithm you wish to). Then take each pair from the beginning and swap the elements in the pair
Sorted to : 1,2,3,4,5,6,7,8,9,10
Pair and swap : (2,1),(4,3),(6,5),(8,7),(10,9)
result : 2,1,4,3,6,5,8,7,10,9
",2,20131634
20131859,"
I'm assuming here that the relations are inclusive (in the sense that they continue to the end of the line - a[0]>=max(a[1],a[2],...), and a[1]<=min(a[2],a[3],..) and so on). Otherwise this isn't uniquely defined, as {5,4,3,2,1} can get sorted for example into {5,1,4,3,2} or {3,2,5,1,4}. 
So, assuming this is the case, it's easily solved by sorting the entire array in descending order, then just interleave them -   
and so on. Just loop with two indices, one starting from the beginning and one from the end, or use something like this -
",1,20131634
20131922,"
If you are only sorting it in a way that you want values to rise and fall arbitrarily, you can achieve this by checking values in your array and swapping elements if they do not satisfy the constraints of your sort.
Don't have a compiler on me at the moment and you'd have to implement the swap but something like this could work:
I don't disagree with the other answers posted here so you will have to find what you need depending on the relation of the even and odd indexed elements.
",0,20131634
20132170,"
Steps taken",0,20131634
20133274,"
In case you're still lost, here's the full program:
",3,20130673
20131478,"
Your issue may be easier resolved by changing your data structures.  Instead of having an array of arrays, have an array of structures.  The structure would contain the sum and the array of values.  
With this concept, you are sorting the rows by their sums.
You can easily write a comparator for this and use std::sort:  
Edit 1 -- Overloading operator <
You could simplify and not require a comparator by providing an overloaded operator <:
The sorting call now becomes:
",4,20130673
20131362,"
Here's how I would approach the problem:
Write a swap function which switches two rows in a multidimensional array.  Something like:
Then, write a sum function, which adds all elements in a row.  Something like:
Finally, write a sort function which is able to sort a multidimensional array using the following operations:

Comparing the sum of two rows
Swapping two rows

I'll leave it up to your preference to decide which sorting algorithm to use.
",0,20130673
20133314,"

I have to create two dimensional array

I don't know what you mean by this (do you have to read it from some input, or populate it with numbers etc. ?), but lets say you create a two dimensional matrix like this:
Then you can sort the matrix by the sum of each row in descending order like in the following example. I have used std::sort together with a custom comparator functor (created with a lambda function):
That's it.
Now let's output the matrix:
Live example
",0,20130673
20120664,"
Yes, it is. 
Define 
or 
and use std::sort.

Example with only two int variables, as they are the easiest ones:
Of course, your definition will be more complicated, because the other fields are more complicated for comparing (the weekday for example), but I hope you get the point.
Then:
By the way, list is bad name for variable, as it may conflict with std::list in some cases.
",6,20120632
20123232,"
if you will implement boolean function as member it must be const type
See working example
",0,20120632
20311547,"
What I finally did is most mundane, yet solves my issue.
I wrote another c++ program which iterates over each line of the output file and asserts: current_line <= next_line.
",0,20119789
20116775,"
The obvious way is just to take the sum of both arrays and see which is larger. Something like so:
However, this introduces the possibility of integer overflow. This can be avoided by changing the last parameter of accumulate to 0LL or 0.0.
",1,20116426
20116520,"
Intuitively (which is pretty weak in my case I guess, I'm not an algorithms expert) this feels as if won't be possible without looking at each number once, and simply computing the sum. This is since integers are signed, the sum of an array can become 0 (or negative) when adding any element, so you have to look at all of them.
So, try to implement a function like this:
then simply call that on each of the two arrays, and compare.
Edit: as pointed out in Tristan's answer there's a risk of overflow when adding potentially large integers. If this is a problem (that's really quite application-spefific, perhaps overflow results is part of ""having a larger sum"") you can switch to a wider integer type, or go with double.
",1,20116426
20116761,"
",0,20116426
20116780,"
",0,20116426
21072692,"
In your comparison function, first return true if lhs.points < rhs.points. Then return false if rhs.points < lhs.points. If you've gotten to this point, you know the points are equal (if not, the function has already returned), so you can just return lhs.goals < rhs.goals.
",3,21072645
21072693,"
Overload the operator <
",3,21072645
21065296,"
Tag each element with it's position:
Sort it:
For each query walk through the result and return the elements which are within the range.
After preprocessing each query takes O(N) work.
",4,21064848
21064954,"

Are there any advanced data structures involved?

Nope, not at all. First you obtain the range given by those indexes, then you sort the resulting range. Then you print it. Seems pretty simple!
In fact, it's so simple, I'm going to show you an example:
Live demo
You could make the code even terser (and possibly more efficient) by copying the subrange into an std::set rather than a std::vector, so sorting happens during insertion rather than after-the-fact. I hardly think either is ever going to be as much as O(n^2), contrary to your claims.
Can you do sufficient preprocessing to share information between individual queries and get your complexity down still further? I don't know. I don't think so.
",2,21064848
21064928,"
If I understood your question: Sort it.
You can use any sorting algorithm you want, Wikipedia lists a few.
Depending on which algorithm you choose, you may need extra memory / data structures.
If sorting should come later, copy the array and sort the copy. Makes more sense, than sorting over and over again for every query.
",0,21064848
21059069,"
high is passed with highest index in the array which is size-1 but you have passed size which is more than highest index in the array hence you might be getting an error.
",0,21058937
21058949,"
Your high is size of array, assume 20 means array index starting from 0 to 19.
Looks like you are trying to access b[20] - > which is 21st element of the array. Clearly out of bound.
Code below looks suspiciaous to me. It should check j<high (not j<=high)
Same with code below:
",1,21058937
21050573,"
Your comparison function doesn't define an ordering.  In fact,
it seems to return true any time a.first != b.first.
I'm not sure what sort of custom order you want.  The standard
ordering of std::pair will result in something like:
It's actually a bit more complicated, since the only comparison
operator it uses is <.  But if < and != are both
available, and behave normally, the results are the same as the
above. 
You can easily adopt this to compare the elements in whatever
order you want; if you want to inverse the order for one of the
elements, just replace < with >.
And finally, false compares less than true for boolean
values.
",1,21050235
21050267,"
It should be:
In your version it returns false in both cases.
",3,21050235
21019754,"
1) Most of the intersections can be filtered if you use findContours() with CV_RETR_EXTERNAL flag. This means that contours that are contained inside other contours won't be returned. Of course this will not prevent all the cases of intersections of bounding boxes but this will considerably improve performance of your post-processing
2) vectors are definitely good for sorting. The code will be short and efficient. And it is better than list anyway since the data will be continuous in the memory.
3) Deleting values from vector one by one is not effective indeed but you don't need to do that. Just create temporary vector that will contain chosen boxes, like this:
This can be done 'inplace' as well but why bother. This memory is ignorable comparing to memory of original image, or memory of contours found by findContours.
",5,21013500
21019931,"
apart from what michael burdinov said, here's sorting by area
",3,21013500
21012008,"
This code:
swaps the ID, but copies the FirstName.  Even worse, it doesn't do anything with LastName.
Try instead:
Or better yet, use the STL.
Note, swap is in <algorithm> if you're pre C++11.
",2,21011961
21012261,"
Provide an operator< and use std::sort, and rely on the default copy constructor doing the right thing. If you need to sort in more than one way, you can provide a comparator object to the sort algorithm instead of providing operator<.
If your compiler supports C++11 you could alternately use an inline lambda expression for the sort, and omit the operator<.
",2,21011961
21012119,"
Your code is swapping just the ID field of the structure. You are assigning (copying) FirstName field and dont do anything with LastName.structs can be directly assigned to each other using the = operator :
",-2,21011961
21027622,"
Your program has multiple problems, I have given the list below

At while loop #1 lower <= upper, should be lower < upper, as we don't do any swapping when index are same (reason for your infinite loops(?))
Access out of array boundary at while loop #2 && #3 they should be ""lower < upper && thelist[lower] < pivot"" and ""lower < upper && pivot < thelist[upper]""
At line ""swap(thelist[upper], thelist[upper-1]);"" you are attempting to swap your pivot back to its position (isn't your pivot at thelist[first] and not at thelist[upper], replace thelist[upper] with thelist[first])
Need to find where the pivot fits before swapping pivot hence add ""if (pivot > thelist[upper]) upper++;"" before swapping pivot
You could remove the else part of the last if statement within while loop #1 as it add no value

I think that should make your program work! I don't have Microsoft C++ to test that you are on your own on testing :(
",0,21009562
21030561,"
As already precised here, the problems aren't (obviously) in the swap and move functions, but, in some cases, in the ever recursive quicksort function and, in another ones, in the corrupting memory quicksort function. To detect when your indexes are getting out of range, you could use wrapper functions with assert, like this:
EDIT The quicksort version that works:
I tried to keep your style (I don't use globals, arrays without size parameters) and your algorithm (I like the one iterator approach more: In-place version) as much as possible.
You can do as this to test it is really sorted:
I did it for several special cases and in a huge loop (500 randoms: remember to call srand only once ;)!).
",0,21009562
20991572,"
You may write your own iterator, something like:
Now, let's test it:
",3,20987041
20987273,"
You can copy each column into a temp array,sort them and put them back into output array
",1,20987041
20988071,"
I finally gave up and decided to write my own version to compare with.  I think I'm just going to keep all versions of the sorting algorithm similar to this.
@RichardPlunkett I tried creating my own compare function but was worried about it swapping entire rows.
",0,20987041
20977252,"
Through the help of @RogerRowland I was able to solve this issue but for those looking to do the same thing as me. Why you would actually ever want to do this I dont know, but if you need to actually sort the database table's data rather than just return sorted data and are using sqlite3 and c++ this is what you wanna do.
Step 1)
Step 2)
Grab all of your table info (column name and types and what not) and store it in a string with.
Step 3) Create a new table with the same columns and properties as your original.
Step 4) Copy all of your view's sorted data into the new table.
Step 5) Drop the old table
Step 6) Rename your new table to the old name if desired.
You may also want to drop the view if you didn't create a temp one or even if you are going to be repeating this before you close the db because if you dont the temp view lasts till you close the db.
Also by all means not claiming this is the fast route. The only reason I was using sqlite3_exec is because I recycled someone else's old code I will be replacing it with sqlite3_prepare_v2 myself but wanted to get this up for any others with the same question.
Sources.
http://www.sqlite.org/lang_createview.html
http://www.sqlite.org/capi3ref.html
",1,20972989
20956892,"
The integer literal 000101 is interpreted as an octal representation of the decimal 65, because of the leader zero.
A literal is a number written out in your source code. This does not include characters in a file, or characters inputted by a user into an I/O stream.
Any integer literal beginning 0 is an octal integer literal.
To stick to decimal literals, do not use leading zeroes.
As discussed above, this is kind of a strange way to do human-readable dates (typically you'd use a string for this, and leave the integer storage to some internal representation such as a UNIX timestamp).
",1,20956345
20956983,"
You can't modify the sorted values while sorting. It's evil. The sort algorithm may launch ""format C:"" instead of actually sorting.
Beside, values to sort are passed by value to the callback, so your modification are lost.

Process your list of date for adjustments
Sort with a non modifying callback

(also, initialize your dates without the octal prefix, as in the @Lightness Races in Orbit answer)
",1,20956345
20955276,"
If a leading 0 is significant, then you don't have an int, but a string.  You can check whether strings are sorted using < just as well as you can ints.
Also look at your if-else for adding 19 or 20; you check data1 but then modify data2 (and vice versa)....
",2,20955189
20955307,"
Starting a number with 0 in C means that the base should be interpreted as octal (base 8 rather than 10): the  literal 020324 will be interpreted as the decimal number 8404.
",1,20955189
20955550,"
First convert dates to time_t or tm, then use datetime library (http://en.wikipedia.org/wiki/C_date_and_time_functions)
",1,20955189
20943736,"
The above could be done more declaratively with e.g. std::copy and lambdas, but I don't personally see much value in doing so.
",2,20943648
20944003,"
Here is the code.
",0,20943648
20934875,"
",2,20934710
20934731,"
Use std::sort with an appropriate comparator. This example uses std::tie to implement a lexicographical comparison using a first and then b, but you can write your own by hand. The only requirement is that it satisfy a strict weak ordering:
or use a lambda:
",1,20934710
20934890,"
If you are using C instead C++, it can be done by this compare:
If you want to break ties according to member c when member a and b are both equal, add more if-else statements in the compare().
",1,20934710
20932034,"
I'm offering this up only because it was one of the few things std::qsort does well that std::sort simply does not, namely sort multi-column fixed arrays: The comparator is a string of ternary statements, but should be clear enough if you stare at it long enough:
Sample Run (yours will vary, obviously)
Notes: this specifically uses strict-value comparison rather than subtraction short-cuts in the comparator so as to avoid potential underflow issues. If that is not a problem in your restricted data-space, you could easily make that comparator significantly simpler.
",9,20931669
20931879,"
The built-in arrays of C and C++ are very inflexible, among other things they cannot be assigned.
Your best option would be the 'array' class from the C++ standard library, at least for the inner dimension:
Edit:  Some more explanations.
Here we use the property of std::array that '<' by default compares them lexicographically, i.e. starts with the first element.  In order to sort things differently we have to come up with an comparator object, so if you want to use the second column as sort key you have to do this:
And as mentioned in the first comment, sort(a, a+5 ... is just an ugly short form for the cleaner sort(std::begin(a), std::end(a) ...
",6,20931669
20932154,"
If you can, use Vector with some struct to hold two int:
",3,20931669
47463372,"
To be honest, since you have only two ints in your second dimension, I would use instead an array of pairs, which have their own built in comparison function. With something like pair<int,int> arr[200], you would be able to call the built in sort function sort(arr, arr + 200), which would sort your array by first element, and then by the second element.
When you run this program, you see that the arrays are now sorted:
Note how the second elements are also sorted, but secondary to the
",3,20931669
38249167,"
First off, if you'd given vector<vector<int>> array this would be sortable just using: sort(begin(array), end(array)) because vector defines lexicographic comparison functions: http://en.cppreference.com/w/cpp/container/vector/operator_cmp
That said, there are drawbacks to using a vector-of-vectors: What are the Issues with a vector-of-vectors? and it's clearly not what you intended. Given int array[5][2] trying to use sort will yield:

error C3863: array type 'int [2]' is not assignable

Instead of using swap to exchange 2 int[2]s we need to simply need to swap bytes of sizeof(*array), that can be accomplished using qsort as suggested by WhozCraig's answer, but we can improve upon that making our comparator capable of handling any size sub-array. Given int array[5][2] or whatever dimensions are desired we can write:
A quick note array should not be used as a variable name as it defines a standard type, with this change you can find an example here: http://ideone.com/87AoIr
",2,20931669
20931856,"
If end container doesn't matter, how about using a map ? 
You can now copy m back to your array
",1,20931669
20931996,"
The fastest way to sort a 2D array in time(using only columns) . . .will cost you reference locality... Else, every other way will involve lots of copying of rows.. . . Though (C++'s move operations may cushion this)
You would create a new array of pointers to a 2D array... Then sort the pointers...
Else, every other answer before mine seems good. But I advise you to use std::array.
",1,20931669
20925604,"
To sort an Array you could use qsort() for example (http://www.cplusplus.com/reference/cstdlib/qsort/). It would look like the following:
Functioncall:
compar-function:
For sort_descending() you have to switch value1 and value2.
edit:
included 

If the year is from 50-99, it refers to 19xx, if it's from 00-14, it refers to 20xx.

Hint: I would use long instead of int for the Date (int has 2 or 4 or 8 Byte depending on the system)
",1,20924575
20925065,"
First of a few general hints.

Storing the data as an int seems wrong. A date is not a number! It does not behave like a number. And there are many other ways to display a date than YYMMDD. The 501022 is a real problem. See http://en.wikipedia.org/wiki/Year_2000_problem
student students[100]; could be done a lot better and safer. Why use memory for 100 students if you only have 10? Why should your program blow up when there is 101 students? 
There is no need for that. read up on std::vector and other containers int the standard library. It will make your code a lot safer!

As for your actual question, DD should come out with the modulus operator %
a%b gives the remainder a's division with b. so
This way you can check the day. I'm sure you can work out how to check the month after that :-)
For sorting, you can use qsort(). See http://en.cppreference.com/w/cpp/algorithm/qsort and http://cplus.about.com/od/learningc/ss/pointers2_8.htm or http://www.geeksforgeeks.org/comparator-function-of-qsort-in-c/
the comparison function can just directly compare the student.date. Here you get a freeride because the date is an int. so you can compare student a and b directly 
Well... except for that year 2000 issue... 
",1,20924575
20924617,"
std::sort requires a comparator which can simply be called as compare(a,b). A (pointer to a) member function isn't suitable, since it requires an object to be called on, so you'll need a wrapper to bind the member function to an object and make it callable with just the two values to compare.
In C++11, you can bind a member function to an object:
or you can use a lambda:
Historically, you would have to make your own functor, perhaps along the lines of:
",12,20924450
20924622,"
Using c++11 this will work:
",1,20924450
20943349,"
The answer from @Mike-Seymour shows how to make your program work. But it seems you are interested to understand why a member function does not work.
As the terminology indicates a ""member"" function is different from a free function. Member functions are associated with an object. While a member function is executing there is a ""this"" pointer available. The ""this"" pointer refers to the instance of the object associated with the member function. 
The this pointer is used to access the member variables while executing the member function. For example, the solutionComparer function refers to the member variable mSolverHelper. Accessing mSolverHelper is a convenience to the programmer in reality, the compiler is executing this->mSolverHelper. 
The this pointer is provided to the member function as an extra parameter that is not shown or indicated to the programmer. The signature for bool solutionComparer (T first,T second) is really understood by the compiler to be bool solutionComparer (GenericGeneticSolver* this, T first,T second).
Therefore when a member function is called an object is also required. For example: MySolver->solutionComparer(…).
The comparator function signature to the sort function does not understand how to apply an object to the member function. The comparator function requires a free function (or it's moral equivalent). You'll notice that all of the solutions offered provide an object in order to call solutionComparer.
A second question occurs: why does the call to sort, compile if the sort function is called in a member function. The answer is it doesn't really compile and is related to template instantiation.
Template instantiate is lazy. The compiler will only compile the enough of a template class that is required. I believe this has to do with SFINAE. Your test program likely instantiates an instance of the class. e.g. GenericGeneticSolver solver. This causes the compiler to compile GenericGeneticSolver but only enough of the class is compiled to satisfy the linker. That is the constructor. 
If you add a call to Evolve() then the compiler will also fail:
The description of SFINAE should help to describe how and why the compiler works in this fashion.
All of these machinations are meant to be hidden from you, as you typically don't need to know. However, in cases like this it is useful to understand the underpinnings of the language and compiler in order to understand how to solve the problem.
",1,20924450
20919395,"
Replace the line
by
Also find out whether we need to check whether the indices i and j may go out of array bounds
",2,20919331
20915119,"
Suppose you have a 0-based 1-dimensional array A of n = m^2 elements.  I'm going to tell you how to get an index into A, given and a pair of indices into a 2D array, according to your diagonalization method.  I'll call i the (0-based) index in A, and x and y the (0-based) indices in the 2D array.

First, let's suppose we know x and y.  All of the entries in the diagonal containing (x,y) have the same sum of their coordinates.  Let sum = x + y.  Before you got to the diagonal containing this entry, you iterated through sum earlier diagonals (check that this is right, due to zero-based indexing).  The diagonal having sum k has a total of k + 1 entries.  So, before getting to this diagonal, you iterated through 1 + 2 + ... + (sum - 1) entries.  There is a formula for a sum of the form 1 + 2 + ... + N, namely N * (N + 1) / 2.  So, before getting to this diagonal, you iterated through (sum - 1) * sum / 2 entries.
Now, before getting to the entry at (x,y), you went through a few entries in this very diagonal, didn't you?  How many?  Why, it's exactly y!  You start at the top entry and go down one at a time.  So, the entry at (x,y) is the ((sum - 1) * sum / 2 + y + 1)th entry, but the array is zero-based too, so we need to subtract one.  So, we get the formula:

i = (sum - 1) * sum / 2 + y = (x + y - 1) * (x + y) / 2 + y


To go backward, we want to start with i, and figure out the (x,y) pair in the 2D array where the element A[i] goes.  Because we are solving for two variables (x and y) starting with one (just i) and a constraint, it is trickier to write down a closed formula.  In fact I'm not convinced that a closed form is possible, and certainly not without some floors, etc.  I began trying to find one and gave up!  Good luck!
It's probably correct and easier to just generate the (x,y) pairs iteratively as you increment i, keeping in mind that the sums of coordinate pairs are constant within one of your diagonals.
",0,20914410
20914613,"
If you can convert from a 2D array to a 1D array, then converting back is the reverse process. Take the same loop and change around the assignment.
However in your case the conversion itself is wrong. It should take indexes in the order (0;0), (0;1), (1;0). But what it does is take indexes in the order (0;0), (0;1), (1;1).
My suggestion is to use the fact that the sum of the X and Y coordinates on each diagonal is the same and it goes from 0 to AS*2-2.
Then with another loop you can check for all possible valid x/y combinations. Something like this:
P.S. If you want to be really clever, I'm pretty sure that you can make a mathematical (non-iterative) function that converts from the index in Brray to an index-pair in Array, and vice-versa. Then you can apply the bubble-sort in place. But that's a bit more tricky than I'm willing to figure out right now. You might get extra credit for that though.
P.P.S. Realization next morning: you can use this approach to implement the bubble sort directly in the 2D array. No need for copying. Think of it this way: If you know a pair of (x;y) coordinates, you can easily figure out the next (x;y) coordinate on the list. So you can move forwards through the array from any point. That is all the the bubble sort needs anyway.
",1,20914410
20914664,"
Store the ""diagonally sorted"" numbers into an array and use this to display your sorted array. For ease, assume 0-based indexing:
Then loop over this array and display as
Note that it is easier if your sorted Array is still one-dimensional at this step. You'd add the second dimension only when printing.
",0,20914410
20915451,"
Following may help you:
",0,20914410
20921501,"
Thank you for your assistance everyone, what you said was very useful to me. I actually was able to think about clearly and came up with a way to start filling the array based on your recommendation, but one problem now, Im pretty sure that my logic is 99% right but there's a flaw somewhere. After I run my code the 2nd array isnt printed on the screen. Any help with this?
Thanks again for your assistance
",0,20914410
20936045,"

If you want to handle different parts of int [] by calling the same function, try to define your function as

Regarding the sizeof(thelist) part, if you want to get the size of a int []. You need to use
instead of
Example:


PS: You also need to think twice on your code logic and rewrite it. You main function should looks like the following:
",1,20912274
20935982,"
",0,20912274
43897119,"
",0,20912274
20907882,"
First, I wouldn't hard code the 9 and 10.
Second, I assume arrayout() prints the array? You're doing that inside the loop, before it's sorted. Move it to the end, after the loop.  
Third, the AND operator is && not &.  The & is a bitwise and - not what you want.
Otherwise, it looks ok.
",1,20907757
20908809,"
So imagine the first time through with an array [1, 8, 7, 5, 4, 3, 2, 1, 6, 9].
a[0] < a[9], so it does not get swapped.  
Now you get to your while test:  gap >1 but swapped is false. so you exit.
You will have the same problem if all the items at any gap size are already in order.
You need to get all the way down to gap size 1 before you start testing swapped.
(@dsa42 is right, it should be &&, but that doesn't change the logic error.)
",0,20907757
20878282,"
Using your code just use std::sort on each row of the multidimensional array. ie.
I initiated every element of your multidimensional array a, since your declared a to be size 6 (2 rows, 3 columns). This would output 1 3 7 2 5 6, because it sorts the rows from least to greatest. If you wanted to sort the multidimensional array so that the output would read 1 2 3 5 6 7 then you would need to do something like this:
This second example is probably the worst possible way to go about sorting a multidimensional array though. Let me know if you find an error in my code, I was unable to test, or need additional help.
",1,20878101
46024311,"
As the multidimensional arrays are contiguous you can also try:
Depending on what you want. It is also possible to write a begin() and end() for multidimensional arrays.
",0,20878101
20866049,"
This code just can be one method among many good methods. I just use std::sort and lambda.
I hope this will help you a little. Happy new year!
",5,20865682
20866117,"
",1,20865682
20859860,"
For odd lengths len of s, the outer loop runs until i==len-1.  The inner loop then terminates at len - len - 1 - 2.  Since strlen returns an unsigned type, this evaluates to a very large unsigned number, causing the inner loop to read way beyond the end of s.  Eventually you'll reach memory you don't have access to read or write, causing the crash.
You can fix this by ending the outer loop sooner
",0,20859680
20859892,"
Your compiler should have warned you about the problem (you did switch on all warnings, yes? always do that!): Once i==strlen(s)-1, the loop for j is essentially unbounded, by the magic of arithmetic rules for signed/unsigned values.
does not have this problem. (i should be unsigned as well.)
Or stop the loop for i earlier. The problem in your code is still there then, but you won’t run into it. But I believe that is the worse route to take – fix the bug, and then optimize by observing i doesn’t need to go as far up, because the last character already forms a sorted sequence.
",1,20859680
20859747,"
Change this:
Into this:
Otherwise the s value be handled beyond its end-point
",0,20859680
45701006,"
here is my code 
",0,20859680
20852291,"
Use a capture in your lambda to accept the column number to sort on.
",0,20852114
20842953,"
You've given an invalid upper bound, so sort is trying to move nonexistent objects after the end of the array. You want
In C++11, there are handy library functions to avoid mistakes like this:
noting that begin needs bodging slightly due to the one-based indexing. If you can't use a C++11 library, they are easy to write yourself:
",0,20842775
20842996,"
It is hard to know but if you compile and run in debug you should be able to get a call stack to determine where your program failed and that should give you the information where your program is failing.  
Just a note, you are using your indices inconsistently (ending at 1000) in your initializing loop and 10001 in the sort algorithm.  This is out of bounds of your array.
",1,20842775
20843212,"


Silly typo!
",0,20842775
20807406,"
",1,20807317
20773263,"
I'll just give you some consecutive tips:

Create std::vector and push you data into:

Write the function which compares two structures and returns the comparison result. Don't make it a member of your structure. Notice that I've renamed it:

Call the std::sort function:

The data in your students structure will be sorted in the descending order.

This code works: http://ideone.com/iMWcfi
",1,20772973
20773256,"
See e.g. https://stackoverflow.com/a/10308722/1467943
",0,20772973
20768129,"
You modify a local map called iniFile. This has no effect on some other map, *(_shared->sections). Perhaps you wanted to make iniFile a reference?
",2,20768059
20766975,"
There is an error in your addToTail function. You don't update the tail member variable to the new node. Also searching for the tail node using while is unnecessary because you have direct access to it via tail.
There also is an error in your addToHead function but it's not important here. You are allocating a new temp node which will always leak.
Perhaps fixing these errors is already enough. If it isn't you should show your removeFromHead. I guess it messes with the head variable and will leave it in some ""uninitialized or stale"" state, so that the next access to head->next crashes.
",0,20766183
20764046,"
Your code does indeed work, so I'm not sure what the problem is.
Output:
You can improve your comparator function slightly by removing the unnecessary local variables:
",1,20763915
20764129,"
btw, to expand on the copies comment above here are two version with minor enhancements.
Cheaper: 
Shorter and Cheaper:
",1,20763915
20764073,"
Using operator < from std::pair or std::tie
Demo here
 I don't care if your code works :P I did some ""efforts"" 
",0,20763915
20744742,"
Let's say you have: (0's can really be anything)
If you only sort on the most significant digit, you get:
After this the array is already sorted and we can stop - there's no need to check the other digits.
While it may not be so ideal in practice, there are certainly cases where we don't have to evaluate all the digits of all the elements.
The if (hi <= lo + 1) return; statement should cause it to return if there's only one element in the subarray, preventing checking unnecessary data.
",0,20744603
20741666,"
For sure you can't use begin to store the result. You are still reading from begin and merging, so by writing to it you would be overwriting data that are possibly still not read.
You would need temporary memory to write the result to, and then copy back over the original. The memory could be of any type, so long as you can get an iterator over it. Say a std::vector.
There's a fundamental problem though. You have the type of all five iterators in merge as T, but at least the type of beginResult should be of a possibly different iterator. Otherwise, you can't know, as you have observed, what temporary container to use.
As you have linked yourself, the template of std::merge has different iterator types for the left, right and result iterators.

Note: to allocate temporary memory, you need to know the type of elements that T is an iterator of. This is simply done by T::value_type. See here.
",2,20741447
20786057,"
Something like this should work:
",0,20741447
29889503,"
You can create your vector as such:
in a helper function, then call your sort routine:
Then once your function comes back with results, you can copy the results to the vector denoted by the user-provided iterators.
",0,20741447
20730060,"
If you want highest frequency then lowest letter, an easy way would be to store negative values for frequency, then negate it after you sort.  A more efficient way would be to change the function used for sorting, but that is a touch trickier:
",3,20729942
20730079,"
You could simplify this a lot, in two steps:

First use a map to count the number of occurrences of each character in the string:

Use the values of that map as comparison criteria:


Here is a working example running at ideone.
",5,20729942
51309998,"
(Posted on behalf of the OP.)
Thanks to the responses of the awesome people here at Stack Overflow, I was finally able to fix my problem. Here is my final code in case anyone is interested or for future references of people who might be stuck in the same boat:
Example output:
I basically just followed the advice of @OliCharlesworth and implemented a custom comparator through the help of this guide: A Function Pointer as Comparison Function.
Although I'm pretty sure that my code can still be made more efficient, I'm still pretty happy with the results.
",1,20729942
51309810,"
Using an unordered_map for counting characters as suggested by @Manu343726 is a good idea. However, in order to produce your sorted output, another step is required.
My solution is also in C++11 and uses a lambda expression. This way you neither need to define a custom struct nor a comparison function. The code is almost complete, I just skipped reading the input:
Output:

Unsorted list:
  r = 1
  h = 1
  e = 1
  d = 1
  o = 2
  w = 1
  l = 3
  Sorted list according to frequency then alphabetically:
  l = 3
  o = 2
  d = 1
  e = 1
  h = 1
  r = 1
  w = 1

Note 1: Instead of inserting each element from the unordered_map into the set, it might be more efficient to use the function std::transform or std:copy, but my code is at least short.
Note 2: Instead of using a custom sorted set which maintains the order you want, it might be more efficient to use a vector of pairs and sort it once in the end, but your solution is already similar to this.
Code on Ideone
",1,20729942
20707430,"
You can implement your own QTableWidget item that will handle comparison in a special way. For example:
With this, you will simply have to create TableItem instead of QTableWidgetItem:
or
",1,20706819
43605864,"
Another option (easier I think) is to create an empty QTableWidgetItem and then set the data:
",1,20706819
43605999,"
Please, don't use QTablewidgetItem or QTableWidget, instead use QTableView and QAbstractTableModel - the maintenance cost is way smaller and the code is saner.
classes: 

YourTableView - the raw data
YourSortModel - the model that will do the sorting / filtering
QTableView - that will display your stff.

It's hard to initiate on the Model View on Qt, but as soon as you understand the basics you won't go back to manually dealling with the widgets.
",1,20706819
20704319,"
This is actually quite easy. First an observation:
Theorem: if two numbers x and y such that x < y are in the series and these numbers have the same number of digits, then x comes before y.
Proof: let's view digits of x as xn..x0 and digits of y as yn...y0.  Let's take the left most digit that these two differ in, assumed to be at index i. Therefore, we have:
since all digits from n to i are the same in both numbers. If x < y, then mathematically:
Lexicographically, if the digit x(i-1) is smaller than the digit y(i-1), then x comes before y.

This theorem means that in your specified range of [a, b], you have numbers with different number of digits, but the ones that have the same number of digits are in their mathematical order.
Building on that, here's a simple algorithm. First, let's say a has m digits and b has n digits (n >= m)
Notes:

In step 2, you are inserting the starting numbers of each series of numbers that have the same number of digits.
To change to a function that returns a number on each call, step 3.1 should be changed to store the state of the algorithm and resume on next call. Pretty standard.
Step 3.2 is the part that exploits the above theorem and keeps only the next number in mathematical order in the heap.

Assuming N = b - a, The extra space used by this algorithm is O(log N) and it's time complexity is O(N * log log N).
",3,20704050
20704291,"
Here's my attempt, in Python:
Result:
This uses O(log(end)) stack space, which is bounded by INT_MAX, so it won't go any deeper than five calls for your typical 16 bit int. It runs in O(end) time, since it has to iterate through numbers smaller than start before it can begin yielding valid numbers. This can be considerably worse than O(end-start) if start and end are large and close together.
Iterating through lex(0, 1000000) takes about six seconds on my machine, so it appears to be slower than Tony's method but faster than Shahbaz's. Of course, it's challenging to make a direct comparison since I'm using a different language.
",2,20704050
20706940,"
This is a bit of a mess, so I'm curious to see how other people tackle it.  There are so many edge cases explicitly handled in the increment operator!
For range low to high:

0 is followed by 1
numbers shorter than high are always followed by 0-appended versions (e.g. 12->120)
numbers other than high that end in 0-8 are followed by the next integer
when low has as many digits as high, you finish after high (return sentinel high + 1)

otherwise you finish at a number 999... with one less digit than high

other numbers ending in 9(s) have the part before the trailing 9s incremented, but if that results in trailing 0s they're removed providing the number's still more than low

 
Performance numbers
I can count from 0 to 1 billion in under a second on a standard Intel machine / single threaded, MS compiler at -O2.
The same machine / harness running my attempt at Shahbaz's solution - below - takes over 3.5 second to count to 100,000.  Maybe the std::set isn't a good heap/heap-substitute, or there's a better way to use it?  Any optimisation suggestions welcome.
Perf code for reference...
",1,20704050
20825010,"
Some Java code (deriving C++ code from this should be trivial), very similar to Kevin's Python solution:
public static void generateLexicographical(int lower, int upper)
{
   for (int i = 1; i < 10; i++)
      generateLexicographical(lower, upper, i);
}

private static void generateLexicographical(int lower, int upper, int current)
{
   if (lower <= current && current <= upper)
      System.out.println(current);

   if (current > upper)
      return;

   for (int i = 0; i < 10; i++)
      generateLexicographical(lower, upper, 10*current + i);
}

public static void main(String[] args)
{
   generateLexicographical(11, 1001);
}

The order of the if-statements are not important, and one can be made an else of the other, but changing them in any way strangely enough makes it take about 20% longer.
This just starts with each number from 1 to 10, then recursively appends each possible number from 0 to 10 to that number, until we get a number bigger than the upper limit.
It similarly uses O(log upper) space (every digit requires a stack frame) and O(upper) time (we go from 1 to upper).
I/O is obviously the most time-consuming part here. If that is removed and replaced by just incrementing a variable, generateLexicographical(0, 100_000_000); takes about 4 seconds, but by no means taken from a proper benchmark.
",1,20704050
20697857,"
The text excerpt is confusing because it is incomplete.
It appears the text assumes a big-endian bit numbering for bits within a machine word.  In big endian bit numbering, bit 0 is the leftmost bit within a word.  The hint comes from the phrase ""the leftmost bit of the words, or bit 0.""
Therefore, for a 5 bit number held in a 32 bit register, bit 0 of that number would be held in bit 27 of the machine word, for a right-aligned value in a big-endian numbered word.
Big endian bit numbering is uncommon in most places these days.  IBM POWER / PowerPC still use big endian numbering, as did older big endian architectures such as the TMS9900 / TMS99000 family.  
",0,20697650
20683551,"
Because myClass::compare is not a static method. You must make it static to pass it as a predicate for a sort. Or make it global. Also it must be public if it is to be a static class method.
OR
And you could call it as:
or
",2,20683534
20683802,"
The comparison function in problematic because you use a private member variable in it. That means you can't really use a static member function or a free-standing function or a lambda.
You also have a problem in that the comparison function is private, which means you have to sort the collection from inside a myClass object instance.
The first problem can be solved by using std::bind to bind the member function to a specific object instance. The second problem can be solved by making the function public (or by sorting from another member function inside the myClass class).

You can use std::bind like this:
",4,20683534
20652686,"
What happens when all of the elements in the partition have the same digit(a[...], w)?  
When that happens, after the while (j != i) loop, j will point at the last element of that partition, and so quicksortB(a, l, j-1, w+1) will leave that element out, and quicksortB(a, j, r, w+1) will sort a range with one element.
In this particular case, though, you need to put all the elements with the same leading digit into one partition so that the first quicksortB() call will sort them.  When you do that, the second quicksortB() will get an empty partition and do nothing, which is safe.  That's what the if statement you highlight accomplishes.
In other words, that if statement basically says ""Ok, radix sort did nothing at this level, so let's try again with at the next digit with all the elements in one partition.""
If you didn't do that, then the element you left out would fail to get sorted properly, since you've only partitioned by the digit of interest in the radix sort.
",2,20652365
20620279,"
This for loop initializes the gap between the elements in the array you are comparing against. So increment is set to 2 initially.
This says, start at element 3 and go forwards until you reach element 5, we will see why soon.
Says ok, we are starting at the element specified above (in this case, the 2nd index), and we are going to compare it against the element that is the ""gap"" length behind it. So it would take the 3rd element, and compare it against the 1st element. If the 3rd element is smaller than the 1st element, swap them, otherwise break out of the loop. We then decrement our index by the size of the gap (from 2 to 0) and keep going if our new index is at least as large as the size of the gap (so we don't have array out of bounds issues). 
Now we go back to the middle for loop and increment the element position we start at; so  we compare the

4th element against the 2nd element. Stop
5th element against the 3rd, then 3rd against the 1st. Stop

Once we have compared all elements within their ""gap"" length, we go back and change the gap length to half of what it was before, rinse and repeat, until it reaches 0.
Typically, you don't want to just divide the gap in half - there are pre-defined functions for gap length recommendation (usually primes). See wikipedia for more info.
",3,20620013
20608824,"
You can use a predicate to pass to std:sort. For example:
",2,20608778
20608855,"
Use the STL. Vector for the storage and the sort algorithm.
",1,20608778
20591299,"
I believe that it needs to be a free function, or declare it static static bool comparePriority( const ProcessControlBlock&, const ProcessControlBlock&);. The alternative is to wrap it inside a struct so it could be used as a functor (as described in the link posted in the comment.)
Because your code has numerous other compile errors, I'm finding it difficult to write up an example for you.
",2,20591269
20591700,"
First, look at the second overload of list::sort in the given link at the top of your post.
 It says,
which means it takes an object of some type (named Compare, in this case) as argument. 
It is important that the type should be able to act as comparator.
So you need to make JobTable::comparePriority as a class first.
And it should implement an binary predicate which has the form:
And then, you should pass an instance of this class as parameter of list::sort(), like

yourList.sort(Compare());

It will produce compile error if you write like below, because parameter should be an object, not type.
",2,20591269
20586719,"
You can conduct bubble sort in two passes.
In the first pass, find the smallest element and put it in the first place. Then find the element that is greater than the last element found but smallest from among the lot and put it in second place.
Do the above till you reach the maximum element.
Once you reach the maximum element, bubble sort on the remaining part of the array normally.
Order of complexity: Exactly as per Bubble sort, since you are just dividing it in two halves.
Full working code in C++:
Output:
For input of {4,5,6,1,1,3,3,4,4,4,1,9,9,8,8} 
Output:
",1,20586624
20587077,"
Keep in mind that bubble-sort is the least efficient sorting algorithm of those 3 you mentioned.
It's O(n2) average case while the others are O(n log n).
Heap-sort
A variation on heap-sort comes to mind as an efficient (O(n log n)) way to do this.

Build a heap of the items.
Have a left and a right iterator into the array, pointing to the left-most and right-most positions respectively.
While the heap is not empty:

Remove the maximum.
If the removed item is the same as the last removed item, insert it at the right iterator and decrease the iterator.
Otherwise insert it at the left iterator and increase the iterator.


Now if the items at the end need to be sorted as well, just reverse their order (they should be in reverse order at the end of the above process).
In-place alternative - selection sort
Selection sort finds the maximum element at each step, so this can easily be modified to skip the applicable elements if they're greater than an already found element.
This can be done in-place (where the above can't), but is again O(n2).
Live demo.
If the repeated elements needs to be sorted as well, this will need to be done additionally (with any sort method).
",1,20586624
20583288,"
Don't use C-style strings when you can easily use std::string.
Since your struct only contains a string you may want to just use std::string instead (which implements the operators that you need for parallel_sort to work).
and then, following the function signature, you just need to find the begin and end iterator:
",2,20582891
20582520,"
Since you have character arrays and don't care about memory (although, you do are limited by the hardware memory available, so I don't know how you can not care) you can use Radix sort. It has a complexity of O(n). And you can also very easily parallelise this algorithm.
",2,20582276
20576617,"
Seems trivial:
",2,20576494
20556276,"
std::sort provides ways of plugging in your own ordering functions.
You need to provide either a functor to the sort function, or a less than operator for your name class:
OR:
Or, if you're compiling with C++11, you can do this all inline with a lambda:
The functor or lambda is probably your best choice here. Making an operator< for this class says that you always want to sort by first name, which is probably not true in general for names.
",1,20556196
20549128,"
It is a modified version of quicksort with 1st element as the pivot.
The algorithm basically does the following:
It has two pointers, i starting at 0, and j starting at length-1.
It keeps decrementing j untill a[j] < a[i]. At this point it swaps their values.
After this, j stays at that value, and i starts incrementing again untill a[j] < a[i]. At this point it again swaps their values and now again j starts decrementing.
Hence if you see, every comparison is being done with the 1st element. After the loop ends, the 1st element lands up in its correct place.
",7,20548996
20523902,"
Oops!

There's an extra ; so the swap will always occur;
Your inner loop needs one fewer iterations, otherwise j+1 jumps off the end;
And are all those C-string conversions really necessary?
std::string::compare would do the job...

",2,20523800
20524171,"
The actual bug in your code was answered in a comment.
Your ""j+1"" index can be out of bounds and in the first iteration it is. You therefore need to loop j up to size-i-1 or iterate i from 1 onward, thus..
I assume this is some kind of exercise as the correct way to sort is simply to use std::sort.
You have also been offered alternative ways to compare two strings, the simplest of which is just its overloaded operator<, thus
",0,20523800
20524245,"
You have an out of bounds access which may be the cause   
On the first iteration you have
change the stop condition in the first loop:
hope this helps.
",0,20523800
20525131,"
This code does what you want in C++11:
",0,20523800
20510948,"
If you're intending to use std::sort to sort this array, you likely want to declare an operator< as a method in this struct.  Something like this:
The comparison function you were attempting to declare above appears to be the type qsort expects, and I would not recommend trying to qsort an array of these struct questions.  
Just use std::sort.  It's safer, nearly always faster (sometimes by huge margins), and generally easier to get right.
",1,20510854
20510954,"
Unless there is some important reason not to do so, I would use a std::vector instead of a plain array. It is easier and safer. You could use the following code to sort your vector:
This code use some C++11 features. But you could achieve the same in previous versions of C++ by using a function object, or simply by implementing operator< in the struct (assuming you always want to sort such a struct based on that field).
",0,20510854
21762948,"
Following may help:
",1,21762317
21762816,"
If your particle count is low, it won't matter much either way, and sorting them all first with a simple stl sort routine would be fine.
If the number were large though, I'd create a binary search tree whose maximum size was 10% of the number of your particles.  Then I'd maintain the minY actually stored in the tree for quick rejection purposes.  Then this algorithm should do it:

Walk through your original array and add items to the tree until it is full (10%)
Update your minY
For remaining items in original array 

If item.y is less than minY, go to next item (quick rejection)
Otherwise 

Remove the currently smallest Y value from the tree
Add the larger Y item to the tree
Update MinY



A binary search tree has a nice advantage of quick insert, quick search, and maintained ordering.  If you want to be FAST, this is better than a complete sort on the entire array.
",1,21762317
21758200,"
Bubblesort is easy enough to implement even if it is not the most performant:

Fill the array with all the pointers.
loop until all sorted

loop from first element and swap with next if their order is wrong until the sorted elements are reached (at that point the end element is highest, thus sorted)


Remark that for all other than educational purposes (or possible optimization), std::sort should be preferred over own implementations.
A comment stated that bubblesort is complex and difficult, so I added an implementation of the algorithm in my answer.  Mind you that especially the end-condition of the inner loop (j < i - 1) must be correct and that the direction of the outer and inner loop must be opposite.  And it can be optimised by stopping if no swap was done, but we weren't concerned with performance in the first place.
",0,21757943
21758343,"
Basically you need to sort your array. There are many, many sorting algorithms and you will learn the important ones in Data Structures and Algorithm courses. An optimal sorting algorithm is of O(n lg n) (see quick sort and merge sort in wikipedia. std::sort is also of O(n lg n) time complexity. 
Two simple sorting algorithms, which are quite easy to implement are bubble sort and insertion sort. With the second one being more efficient in practice (even though both are O(n2)).
And about your question style, it is a well-written first question.
PS: If you don't know what O(n) means, check this.
EDIT As why the current approach doesn't work, observe that the inner loop always finds the minimum of the whole array, thus it always return the same result.
Here is an idea if you want to change your code as little as possible, provided that the arrival times are all distinct (i.e., not two flights with same arrival time. That might be the inherent meaning of single airport in the assignment): Just store the previously found minimum arrival time and only assign j to minIdex if the arrival time of jth item is not equal to the stored minimum. Variable definition aside, it only adds one line to your code. I save the implementation as an exercise.
Another approach, for arrays with non distinct values it to remove the found minimum from the array, or set its value to a maximum. This though changes the content of the array, thus you need to make a copy of it first.
",2,21757943
21758176,"
minIndex will always be the same, so pointerArray[i] will get same value - the address of minIndex element of flightArray. You're not sorting, you're simply looking for minimum element
",1,21757943
21759693,"
First: was the idea that you write your own sort function, or
that you show the initiative of looking it up, and using the
std::sort?  (If it's a good course, I'd expect the latter.)
If you do want to write your own, insertion sort is probably the
simplest: you have a simple invariant: the array below i is
already sorted, so you just have to find the position to insert
the element i in it (pushing any following elements up one),
and the array below i + 1 is now sorted.  Start with i == 0
(since the array below 0 is empty, it is by definition
sorted), and work up until you've covered every element. 
",0,21757943
21760808,"
I would suggest learning how to use STL algorithms. They have very good performance and can be composed together to do almost any task.
Here is a sample that should integrate into your exiting data structure.
Here is an example of its usage in some test code.
Here is the output
",0,21757943
21751215,"
in the inner loop it should be a + 1 not ++a 
",1,21751128
21751229,"
for(a=0;a<5;a++) and for(b=++a;..) causes a to be incremented twice.
Did you mean for(b=a+1;b<5;b++) ?
",1,21751128
21751355,"
",0,21751128
21751271,"
this should be
",0,21751128
21740297,"
I think this line is the problem:
It should be:
Because tempArray hasn't been initialized at this point.
Even more, a temporary object should be sufficient, not an entire array.
And these lines...
too. tempArray has nothing, it should be something like this:
BTW, temp1 should be the same type of your objects (not string).
",1,21740103
21735560,"
You need to separate finding the ranges to be sorted and sorting them:

Just saw your edit: you can achieve the alternate solution by defining a custom input iterator class that skips non-sorted elements, then using a single sort() call on the whole ""range"". 
",4,21735089
21730704,"
Following may help:
Output:
",2,21730164
21734028,"
i don't have time to post working code but here is the thing you can do :
1) you can make another multimap < int , string >
2) use vector< pair >  
but these will take very much space if there are many elements. so , efficient approach should be :

I want to find the N-th most occurring keys and order them in a descending order.  

If N is NOT large , better is to create a heap of size N , where each node will contain pair> . 
",0,21730164
21694994,"
You should be double-careful about the boundaries while manipulating arrays.
1.
Your code:
Merge sort is a Divide and conquer method. The range of numbers being divided and conquered should be the same. Which part of the above code do you think has a mistake?
2.int numElemet= (right-left); is not used and should be deleted, further more, the # of elements should be right-left+1.
3.
The k is not the desired value, try find where the error is before this piece of code.
4.
A piece of advice:
Use tab to indent the code in order to improve readibility. It's good for both you and the people reading your code. And use cout to check the values of variables in case the code doesn't perform as you desired.
",0,21693962
21690400,"
You get stack overflow because of the below line. It is subtle but very important. You have to add the lower offset to the mid value that you calculate.
Try this instead :
///////////////////////////////////////////////////////////////////////////////////////////
Also, I have a simple and elegant implementation. It is templated it so that it will work with any data type. This solution makes use of C++11 move semantics and good API design.
You can optimize it by performing Insertion Sort or Bubble Sort if the array size is less than maybe 7 items which is a good idea since QuickSort itself is too much overhead for small array sizes
",1,21690140
21679961,"
operator< must get the parameters by value (const reference or copy), instead of reference:
",4,21679927
21680070,"
Your comparison operator's signature does not match what std::less expects: const reference parameters. 

sort3a.cpp:127:6: note: candidate function not viable: 1st argument ('const record') would lose const qualifier
  bool operator< (record &r1, record &r2)

Try redefining it like this:
",0,21679927
21679719,"
You can use a more structured representation to keep the information about which sort you have, for instance a std::pair, then sort it:
using a std::pair has the nice property that sorting uses the standard comparison for pairs (lexicographical comparison), so you don't have to define a comparator yourself.  
",0,21679527
21665691,"
change
if (sar[b][0] > sar[b+1][0])
to
if (stricmp(sar[b], sar[b+1]) > 0)
UPDATE: instead of stricmp, you can use strcasecmp 
",1,21665658
21647583,"
You aren't comparing to anything because your vector only has one element.
You should replace ""comparison"" with just an insertion into a vector that is declared globally.  Then, at the top-level (wherever calls testyBubblesort), and perform your comparisons there.
A more robust method would be to make a vector, where MyStruct is declared as a double and a string, so that you store {time, ""Bubble Sort""} (allowing you to associate the runtime with the sorting algorithm used.  Then at the top-level, just use the built-in sort function (you will have to use the version that accepts a function to define how to order MyStruct) on the vector and grab the first object from the vector.  Then just print out the string.
",1,21647452
21607776,"
Something like that may help.
It create an array of indexes, then sort this array according to the comparator (with indirection to initial array):
",1,21606911
21592368,"
for edit 2
",20,21592316
21592350,"
Sort the other range only, and then use std::merge.
",23,21592316
21592561,"
The optimal solution would be to sort the tail portion independently and then perform in-place merge, as described here
http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.5750
The algorithm is quite convoluted and is usually regarded as ""not worth the effort"".
Of course, with C++ you can use readily available std::inplace_merge. However, the name of that algorithm is highly misleading. Firstly, there's no guarantee that std::inplace_merge actually works in-place. And when it is actually in-place, there's no guarantee that it is not implemented as a full-blown sort. In practice it boils down to trying it and seeing whether it is good enough for your purposes.
But if you really want to make it in-place and formally more efficient than a full sort, then you will have to implement it manually. STL might help with a few utility algorithms, but it does not offer any solid solutions of ""just a few calls to standard functions"" kind.
",8,21592316
21603976,"
Using insertion sort on N - n last elements:
",4,21592316
21599646,"
The Timsort sorting algorithm is a hybrid algorithm developed by Pythonista Tim Peters.  It makes optimal use of already-sorted subsegments anywhere inside the array, including in the beginning.  Although you may find a faster algorithm if you know for sure that in particular the first n elements are already sorted, this algorithm should be useful for the overall class of problems involved.  Wikipedia describes it as:

The algorithm finds subsets of the data that are already ordered, and uses that knowledge to sort the remainder more efficiently.

In Tim Peters' own words,

It has supernatural performance on many
  kinds of partially ordered arrays (less than lg(N!) comparisons needed, and
  as few as N-1), yet as fast as Python's previous highly tuned samplesort
  hybrid on random arrays.

Full details are described in this undated text document by Tim Peters.  The examples are in Python, but Python should be quite readable even to people not familiar with its syntax.
",3,21592316
21597094,"
Use std::partition_point (or is_sorted_until) to find n. Then if n-m is small do an insertion sort (linear search+std::rotate).
",1,21592316
21599760,"
I assume that your question has two aims:

improve runtime (using a clever way)
with few effort (restricting to STL)

Considering these aims, I'd strongly recommend against this specific optimization, unless you are sure that the effort is worth the benefit.
As far as I remember, std::sort() implements the quick sort algorithm, which is almost as fast on presorted input as to determine, if / how-much-of the input is sorted.
Instead of meddling with std::sort you can try changing the data structure to a sorted/prioritized queue.
",1,21592316
21544238,"
The primary problem is here:
On the first iteration, the condition checks whether (0 > !k), and k is not 0, so !k is 0, so the condition is false and the loop never executes.  Try using:
You also have a problem in the sort phase of your bubble sort; you only iterate through the data once, which is not enough to sort it, in general.
Finally, some design issues.

You should have one function to sort the data and a separate function to print it.  Don't combine the two functions as you have done here.
Avoid global variables.  Pass the array and its operational length to the sort function, and to the print function if you have one.

",1,21544191
21544222,"
This doesn't do what you think it does. If you want something that says ""while x is not greater than k"", you want <=. Since array1[k] isn't one of the elements you sorted, though, you probably want <.
Note that for exists for loops like these:
As for the new bug, you're only doing one round of bubbling in your bubble sort. You need another for loop. Also, i is never initialized in main, and i != 0000 isn't going to check whether the user literally entered 4 zeros. It'll only check whether the user's input was equal to the number 0.
",2,21544191
21518183,"
I just noticed that you handle the type recognition within an switch and not with a typedef (like you hinted in your subject). In that case - use template functions. It's really easy to implement - for example QuickSort will become:
And so on. This solution will shorten your code by a ton.
And then you just use it like this:
Also - use containers instead of the array to make things even more simple. I would suggest std::vector.
",1,21518041
21518189,"
You can pre-processor a section out of your code using something like:
This will remove the section between the #ifndef and #endif statements if IGNORE_STOI is defined.
",0,21518041
21516599,"
std::sort() invokes operator() on its third given argument. It requires a callable object (a functor) to be used as the predicate for sorting. Your predicate doesn't supply one and thus a compilation error.
But the details of std::sort specify that it will use operator< on the each of the elements if you do not supply your own:


To elaborate, there are two overloads of std::sort, one that uses operator<, and the other that uses the custom sorting functor.

On a second look at your code, it appears you've only overloaded operator< for a righthand side of std::string. You have to overload operator< for two record objects at a time.
Inside the class you would tag it as a friend:
",2,21516562
21516583,"
Use instead
Also it is not clear what this statement means
Where is arg2 is defined?
",0,21516562
21517113,"
You call sort with a pair of iterators and (optionally) a callable object that knows how to compare two items of the type you are sorting.  If you don't provide the optional comparator, sort will attempt to use operator< on the items.
Note that the comparator must implement strict weak ordering.  That means that your comparator must be completely consistent.  Your operator< example is not completely consistent.  If you have two employees with the same last name (e.g., ""Smith, Jane"" and ""Smith, John"") you cannot simply compare last names because you won't get consistent results.  If the last names don't tell you which one comes first, then you must compare first names.  And so on.  Here's an example:
Without strict weak ordering, you may get lucky (some data sets might appear to work), you might get misordered data, you might even crash.  It depends on the details of the sort implementation and the particular data set you give it.
With a proper functor for comparisons, you can call sort like this:
",0,21516562
21472481,"
If I remember correctly this is the Ugly Numbers problem I've faced some years ago in the UVa.
The idea to solve this problem is to use a priority queue with the numbers 2, 3 and 5 as initial values. At each step remove the topmost value t and insert the values 2*t, 3*t and 5*t in the priority queue, repeat this steps till the 1500th term is found.
See this forum for more info: http://online-judge.uva.es/board/viewtopic.php?t=93
",2,21471617
21436420,"
What comes to mind is to iterate over the vector and if some event is less important, don't process it but put it aside. As soon as the entire vector has been read, have a look at the events put aside. Of course you can use several buckets with different priorities. And only store references there, you don't want to move megabytes of data. (posted as an answer now as requested by Damon)
",3,21434718
21437192,"
Use a separate vector for each priority. Then you don't need to sort them.
",3,21434718
21438336,"
Sounds like a nice example where near-sort algorithms can be useful.
Back a decade Chazelle has developed a nice data-structure that somewhat works like a heap. The key difference is the time complexity though. It has constant time for all important operations, e.g. insert, remove, find lowest element etc. 
The trick of this data-structure is, that it breaks the O(n*log n) complexity barrier by allowing for some error in the sort order. 
To me that sounds pretty much what you need. The data-structure is called soft heap and explained on wikipedia:
https://en.wikipedia.org/wiki/Soft_heap
There are other algorithms that allow for some error in favor to speed as well. You'll find them if you google for Near Sort Algorithms
If you try that algorithm please give some feedback how it works in practice. I'm really eager to hear from you how the algorithm performs in practice.
",3,21434718
21436876,"
Sounds like you want to use std::partition: move the part that interests you to the front, and the others to the back. Its complexity is in the order of O(n), but it is cache-friendly, so it's probably a lot faster than sorting.
",1,21434718
21442710,"
If you have limited ""bandwidth"" in processing events (say a 128K per time quantum), you could use std::nth_element to select the 128K (minus some percentage lost due to making that computation) most promising events (assuming you have an operator< that compares priorities) in O(N) time. Then you process those in parallel, and when you are done, you reprioritize the remainder (again in O(N) time).
This guarantees that in the case that your bandwith threshold is reached, you process the most valuable elements first. You could even speed up the nth_element by a poor man's parallelization (e.g. let each of N workers compute M*128K/N best elements for small M in parallel, and then do a final merge and another nth_element on the M*128K elements).
The only weakness is that in case your system is really overloaded (billions of events, maybe due to some DOS attack) it could take more than the entire quantum to run nth_element (even when quasi-parallized) and you actually process nothing. But if the processing time per event is much larger (say a few 1,000 cycles) than a priority comparison (say a dozen cycles), this should not happen under regular loads.
NOTE: for performance reasons, it's of course better to sort pointers/indices into the main event vector, this is not shown for brevity.
",1,21434718
21436802,"
If you have N worker threads, give each worker thread 1/Nth of the original unsorted array. The first thing the worker will do is your approximate fast sorting algorithm of preference on it's individual piece of the array. Then, they can each process their array peice in order - roughly performing higher priority items first, and also being very cache friendly. This way, you don't take a hit for trying to sort the entire array, or even trying to approximately sort the entire array; and what little sorting there is, is entirely parallelized. Sorting 10 pieces individually is much cheaper than sorting the whole thing.
This would work best if the priorities of items to process are randomly distributed. If there is some ordering to them you'll wind up with a thread being flooded by or starved of high priority items to process.
",0,21434718
21421820,"
Pretty straight forward.  If you can maintain the collection sorted then you can do better than O(n).  You're currently using .at(), multiple times, which performs bounds checking.
",2,21421709
21426183,"
Standard function for this:
",2,21421709
21421843,"
Some simple and very marginally faster methods. 
",0,21421709
21422216,"
You could try using std::sort and std::upper.
",-2,21421709
21422213,"
Why are you trying to search linearly in that vector? It's worst case. Just sort the vector then find the smallest value. simple isn’t it?
check the code:
suppose, 
then v[0] is the smallest value = 1
",-3,21421709
21415584,"
If you look at the page you linked to containing the description of the pivot, it is incorrectly implemented. That can cause the pivot not to be found and j becoming less than 0. If the pivot is correctly chosen as a number which is included in the range, I think this algorithm will work too with unsigned integers.
",0,21413528
21389552,"
Quicksort's complexity is O(n*log(n)), where n = 2000 in your case. log(2000) = 10.965784.
You can sort in O(n) using one of these algorithms:

Counting sort
Radix sort
Bucket sort

I've compared std::sort() to counting sort for N = 100000000:
Results (in seconds):
For N = 2000 both algorithms give 0 time.
",0,21388732
21389292,"
I don't know why the person who told you that would be so peversely cryptic, but indeed qsort is not the most efficient way to sort integers (or generally anything) in C++. Use std::sort instead.
It's possible that you can improve on your implementation's std::sort for the stated special case (2000 distinct random integers in the range 0-65k), but you're unlikely to do a lot better and it almost certainly won't be worth the effort. The things I can think of that might help:

use a quicksort, but with a different pivot selection or a different threshold for switching to insertion sort from what your implementation of sort uses. This is basically tinkering.
use a parallel sort of some kind. 2000 elements is so small that I suspect the time to create additional threads will immediately kill any hope of a performance improvement. But if you're doing a lot of sorts then you can average the cost of creating the threads across all of them, and only worry about the overhead of thread synchronization rather than thread creation.

That said, if you generate and sort the array, then look up just one value in it, and then generate a new array, you would be wasting effort by sorting the whole array each time. You can just run across the array counting the number of values smaller than your target value: this count is the index it would have. Use std::count_if or a short loop.

Each of these operations have to be as fast as possible.

That is not a legitimate software engineering criterion. Almost anything can be made a minuscule bit faster with enough months or years of engineering effort -- nothing complex is ever ""as fast as possible"", and even if it was you wouldn't be able to prove that it cannot be faster, and even if you could there would be new hardware out there somewhere or soon to be invented for which the fastest solution is different and better. Unless you intend to spend your whole life on this task and ultimately fail, get a more realistic goal ;-)
",7,21388732
21389546,"
For sorting uniformly distributed random integers Radix Sort  is typically the fastest algorithm, it can be faster than quicksort by a factor of 2 or more.  However, it may be hard to find an optimized implementation of that, quick sort is much more ubiquitous.  Both Radix Sort and Quick Sort may have very bad worst case performance, like O(N^2), so if worst case performance is important you have to look elsewhere, maybe you pick introsort, which is similar to std::sort in C++.  
For array look up a hash table is by far the fasted method.  If you don't want yet another data structure, you can always pick binary search.  If you have uniformly distributed numbers interpolation search is probably the most effective method (best average performance).
",1,21388732
21389000,"
Standard sorting algorithms, as well as standard nearly anything, are very good general purpose solution. If you know nothing about your data, if it truly consists of ""random unique integers"", then you might as well go with one of the standard implementations.
On the other hand, most programming problems appear in a context that tells something about data, and the additional info usually leads to more efficient problem-specific solutions.
For example, does your data appear all at once or in chunks? If it comes piecemeal you may speed things up by interleaving incremental sorting, such as dual-pivot quicksort, with data acquisition.  
",0,21388732
21389522,"
Since the domain of your numbers is so small, you can create an array of 65000 entries, set the index of the numbers you see to one, and then collect all numbers that are set to one as your sorted array. This will be exactly 67000 (assuming initialization of array is without cost) iterations in total.
Since the lists contain 2000 entries, O(n*log(n)) will probably be faster. I can think of no other O(n) algorithm for this, so I suppose you are better off with a general purpose algorithm.
",0,21388732
21372963,"
I suggest you use the C++ standard library's std::sort algorithm.
This function takes two iterators to the range you want to sort. Note that the range should be an iterator to the start of the data and one-past-the-end of the data. In this case, pointers are acceptable random access iterators.
If you aren't comfortable with the address arithmetic in my first example you can also use the equivalernt:
",1,21372538
21373080,"
Just, use std::sort(). It's very simple for this.
",1,21372538
21373113,"
I am going to suggest the use of qsort. 
Define a function to compare the shorts. Use it in the argument to the standard library function qsort.
",1,21372538
21372673,"
I'm not entirely sure how to implement bubble sort, but if you are fine with a slow (O(n^2)), look at Selection sort. The basic idea is as follows, for each element a[i] in the array, find the smallest element from a[i] to a[length-1]. If the smallest element is a[i], you're done. If min!=a[i], swap them. Note that after each iteration, we have a[0] to a[i-1] is sorted. From this loop invariant we can prove this algorithm is correct.
There is an implementation in the link I provided.
",0,21372538
21363944,"
You just miss the capture of vertices, a simple & in the capture part of the lambda.
Here how it works : http://en.cppreference.com/w/cpp/language/lambda
",5,21363792
21413068,"
Ok, so I found my error. The problem is I'm trying to use thrust on memory that is allocated on the device. I tried copying MyStructArray to the host device first and then using thrust's sort and it worked perfectly. In order to work on the device's memory I have to use thrust::device_ptr<MyStruct> pointer(MyStructArray).
Hope this helps someone else.
",2,21359666
21359030,"
Your output doesn't make sense, though I think you will want to do this:
",1,21358981
21251659,"
Two ideas off the top of my head:

Take a quicksort implementation and apply it to the ""key"" vector; but modify the code so that every time it does a swap on the key vector, it also performs the same swap on the value vector.
Or, perhaps more in keeping with the spirit of C++, write a custom ""wrapper"" iterator which iterates over both vectors at once (returning a std::pair when dereferenced). Perhaps Boost has one? You could then combine this with std::sort and a custom comparison function which considers only the ""key"".

EDIT:
I've used the first suggestion here for a similar problem back in a past life as a C programmer. It's far from ideal for obvious reasons, but it's possibly the quickest way to get something going.
I haven't tried a wrapper iterator like this with std::sort, but TemplateRex in the comments says it won't work, and I'm happy to defer to him on that one.
",3,21251492
21304780,"
I think problem may be splitted into 2 independent parts:

How to make effective iterator for virtual map  
Which sorting alorithm to use

Iterator
Implementing iterator the main problem how to return pair of key/value not creating 
unnecessary copies. We can achieve it by using different types for value_type & reference. My implementation is here.
usage sample:
Sorting algorithm
Its very hard to reason which method better without additional details. What memory restriction do you have? Is it possible to use concurrency?
",0,21251492
21333806,"
There are some issues:

Iterating both sequences together requires a pair representing
references to the sequence elements - that pair, itself, is no
reference. Hence, algorithms working on references will not work.
Performance will degenerate (the sequences are loosely coupled)  -

An implementation using a pair of references and std::sort:
This test shows a degenaration of performance (on my system) by a factor of 1.5 for const char* and a factor of 3.4 for a std::string (compared to a single vector holding std::pair(s)).
(Please adjust SAMPLE_SIZE and VALUE_TYPE)
My conclusion is a sorted view into a sequence of unsorted data might be more aprropiate (but that violates the requirement of the question).
",0,21251492
23497534,"
Depends on how strictly you define radix sort, since Boost 1.58.0 includes Spreadsort, which is a hybrid sorting algorithm that heuristically mixes bucket and comparison sorting. 
For sorting integers and with no requirement for worst-case Θ(n) efficiency, Spreadsort should satisfy you.
For argument's sake, you can also take a look at my implementation of LSD radix sort, which is fairly inefficient with memory but occasionally faster than Spreadsort. You only require the radix_sort branch but I've linked to the speed_test branch because it has the readme.
",2,21251061
29729170,"
The more actual answer is Yes since 1.58 it does:

http://www.boost.org/doc/libs/1_58_0/libs/sort/doc/html/index.html

It has something known as SpreadSort and will ""magically"" detect optimized paths for types like std::string, or floating point numbers that can be treated as byte arrays.
",1,21251061
21234524,"
There are multiple dimensions to what you could mean by generic:

generic with respect to the data
generic with respect to the container

The first is the easiest to tackle. We need to think about what sorting requires to work: a strict weak ordering of our data. Now we know the nature of the function we need to supply to our sorting algorithm and need a way to pass the function. In C++ it has become the norm to assume operator< implements such an order or to pass a Functor to the algorithm that implements it. So the signature would become:
There is another operation our sorting algorithm will necessarily perform: swapping elements. As we are in our own little world here we can just assume that all our types have a member function T::swap(T& rhs) which does exactly this. In the real world we would use the free function std::swap (with an unqualified call and a using directive, but that is an obscure technicality).
The second problem is far trickier and you actually don't want to tackle it, as you only want your sort algorithm to work on your list implementation. I encourage you to dive into std::sort and its requirement to understand why it has been implemented this way and why it does not work for std::list.
",1,21233826
21234148,"
Yes there is, you can implement insertion sort quite naturally with a linked list. You can write a templated function with similar interface as std::sort.
You can then use operator< for comparing any kind of elements or the Compare function.
You can allow your list as an input, and return a sorted list as an output.
The complexity will drop to O(n^2) with insertion sort, but that is the easiest way IMO. And I don't think you can do better with out random access container. Maybe merge sort could be implemented for list. Seems like a good candidate.
Alternatively you could copy/move your list into a structure that supports random access iterators sort it with std::sort and transform it back into a list. That would technically have better complexity, but quite big constant factors due to 2 transform operations. But for big lists it would be faster in the end.
",-1,21233826
21225156,"
This is just a guess based on the snippet of code you have provided, but I'm willing to bet that rd.msg_number is a 32-bit type. It seems likely that rd.msg_number*69 would then sometimes overflow its 32-bit result, causing incorrect calculations in the inner loop bounds. I would do something like the following:
For the incorrect output file size, the reason is your a_file output file is opened in the default text mode, instead of binary mode. In text mode, stdio will do EOL conversion which you aren't going to want. So change the file open statement to:
",2,21225080
21224853,"
There is a function available in the STL, called std::sort Which can take a comparator function, (either a function pointer, or a function object).
The comparator function has to return a boolean that says whether the first element should appear strictly before the second element.
Here's what I came up with for the comparator:
Obviously all your fields are private, so you will need to use their accessor methods rather than just accessing them directly, but here's how you use it:
std::sort is not stable, this means if two elements are considered equal, then it is not necessarily the case that they will keep their relative order, which may be important to you. If it is, then there is also a function called std::stable_sort which does have such a guarantee, and is used in exactly the same way:
EDIT Notes on the implementation

compare_students is a class that has only one, public member, so rather than do this:
I shortened it to this:
(the two are equivalent in C++, a struct is just a class with default public access.)
Then as to what inline bool operator() means.

inline is a hint to the compiler that this function can be inlined, that is to say, replace the call with the code itself.
bool is the return type of the function.
operator() is the name of the function, It is a special-case function that gets called when you treat an object like a function:



",8,21224655
21224697,"
Sounds like the first line of your comparison function should be
From there, check whether right.attempts_ == 0 as well.  If yes, check the IDs.
If no, then right has a grade and left doesn't, right is better.
Continue on with the rest of the rules.  Eventually you can use rules like if (left.attempts_ < right.attempts_) but only after you've dealt with 0 attempts.
",1,21224655
21215468,"
You just need to copy all its elements to a multiset<pair<int, int>>:
After this, multiset<pair<int, int>> b is what you want, i.e. {(1,1), (1,2), (1,9), (5,1), (5,2)}.
",1,21215214
21215293,"
If you really want to use multimap then the ordering of values is always the order in which you insert them and that cannot be changed unfortunately i.e in the example given in the question they are stored as (1,9), (1,1), (1,2), (5, 1), (5,2)
If you can relax a bit on the multimap, then you can use a set and store the above pairs in the set and define the ordering you desire on the pair definition. Since, the set stores it's values in sorted order, it will store your pairs also in the ordering you define.
",1,21215214
33406365,"
The answer is emplace_hint. Pseudo code will look like that:-
",1,21215214
21215315,"
Change the key to include both values.  Design a comparator which compares the two pairs of values in the correct order. 
Having done this you can use multiset instead of a multimap.
",0,21215214
21214559,"
possible problem here when you are copying it back into the original array, you always start from zero, you must copy it back from the left element to the right element.
try this 
",3,21214439
21190112,"
I'll answer your question with a question.
How do you handle the case where your method is called when start == end?
Each run you divide your subsection around the pivot, so each recursive run, you have 1/2 of the length of last time. So you start by sorting the first half, then the first 1/4, then the first 1/8. Eventually, you'll call the method with start = end = 0. That makes 0 - 0 / 2 the pivot, which is 0.
Run that case through your code, and you'll see that you aren't handling the case where your method tries to sort one entry with itself. It will get stuck in an infinite recursive loop, until it crashes with a...
Stack Overflow.
",1,21189873
21190387,"
You might want to look at your use of '='.  I believe you can use >= and <= when comparing to the pivot point, but it's not needed when doing the swap.
Then the kicker is the recursive call - you definitely don't want to use the = there, I think that's the cause of an infinite recursion, which will eventually crash, since j can never be less than the start.  So basically every compare with an =, remove it, and every compare without an =, add one.
",0,21189873
21180558,"
Since comparator functions aren't supposed to modify their arguments, you have to create your comparator in such a way that it accepts const references:
This is obvious from the
part of the error message (you can't pass a const object to a non-const function argument).
",6,21179413
21178886,"
Apparently, you're not required to report the minimum number of swaps, just any sufficient number of swaps. This brings to mind two strategies:

Ignore the second and third lines of input, and immediately print N^2 and return. Technically this conforms to spec! But you wouldn't be able to prove to an auditor that it's possible to arrange the cartons with exactly N^2 steps. In fact, you might have the wrong parity. So if you want to be less sneaky...
Find the carton that's supposed to go in the first spot, and swap it to the left until it gets there. Find the carton that's supposed to go in the second spot, and swap it to the left until it gets there. Repeat until done. Keep track of the steps and report it at the end. This is probably not optimal, but it shouldn't be too hard to code.

",-1,21178591
21171427,"
std::sort is defined as:
In your case, I assume c refers to an entry in a collection of customers, since the call to
will sort the n customers that immediately follow c in the collection, using compare to determine the order.
std::sort will perform the sorting for you, using some sorting algorithm (probably quicksort in most implementations). In order to do that, it needs to be able to compare two elements. This is where the compare function comes into play:
Binary function that accepts two elements in the range as arguments,
and returns a value convertible to bool. The value returned indicates
whether the element passed as first argument is considered to go before
the second in the specific strict weak ordering it defines.

In your case, the compare function will sort customers in ascending order of pi, and ascending order of fi (within equal pi).
",2,21171077
21171157,"
In C++ std::sort is a standard library function and is typically implemented using quick sort. It is implemented as a template function and this overload is templated on the type of the comparator, the function then takes a callable object as it's third parameter and uses this as the comparison function for the sort. Typically this means the compiler will be able to inline the comparison function into the template instantiation of the sort function template, although it may end up being a function call.
",2,21171077
21166582,"
Edit:
Since the context is not given, it is not clear if your code calls std::swap() or another swap(a,b) algorithm like
When a and b are vectors of 1000 ints each, this would copy all vector elements 3 times. The specialized version of std::swap() for containers like std::vector<T> call the container a.swap(b) method instead, essentially swapping only the dynamic data pointers of the containers.
Also, for different iterator types the std::rotate() implementation can utilize some optimizations (see my older, possibly misleading answer below).

Caveat: The implementation of std::rotate() is implementation-dependent. 
For different iterator categories, different algorithms can be utilized
(e.g. look for __rotate( in bits/stl_algo.h header of GNU g++).
To shift n elements by m=std::distance(first,middle) a simple (naive) algorithm like m rotations by one element needs O(n*m) moving or copying operations. But only O(n) moves are needed, when each element is directly placed to its right position, which results in a (roughly) m times faster algorithm.
An example for illustration: Rotate a string s = ""abcdefg"" by three elements:
For n and m with greatest common divisor 1 you are done now. Otherwise you have to repeat that scheme n/m time for the first m consecutive elements (n > m assumed here).
This little more complicated algorithm is much faster.
For bidirectional iterators another legendary O(3n) algorithm can be used, referred to as ""flipping hands"". According to Jon Bentley's book Programming Pearls it was used in early UNIX editors for moving text:
Place your hands in front of you, one above the other, thumbs up. Now

Turn one hand.
Turn the other.
Turn both, connected to each other.

In code:
For random access iterators large chunks of memory can be relocated by swap_ranges() (or memmove() operations for POD types).
Microoptimization by utilising assembler operations can give a small extra amount of acceleration, it can be done on top of the fasted algorithm.
Algorithms using consecutive elements instead of ""hopping around"" in memory also result in smaller number of cache misses on modern computer architectures.
",20,21160875
21164151,"
As the commentors already stated, it depends on  your Standard Library implementation. But the code that you posted is valid even for forward iterators. As such, it imposes very little requirements (only that these iterators can be incremented and dereferenced). 
Stepanov's classic Elements of Programming devotes an entire chapter (10) to rotate and other rearrangement algorithms. For forward iterators, the series of swaps in your code gives O(3N) assignments. For bidirectional iterators, three consecutive calls to reverse yield another O(3N) algorithm. For random access iterators, std::rotate can be implemented as O(N) assignments by defining a permutation of indices w.r.t. to the starting iterator first. 
All the above algorithms are in-place. Using a memory buffer, it is possible that the random access version can benefit from the greater cache locality of memcpy() or memmove() (if the underlying value type is POD) in which entire blocks of contiguous memory can be swapped. If your insertion sort is done on an array or std::vector, it is likely that your Standard Library will take advantage of this optimization.
TL;DR: trust your Standard Library and don't reinvent the wheel!
",27,21160875
21153181,"
here is my solution. the complexity is (finding 1 min from k lists)*(n nodes)
i would say its O(kn) where k is the number of lists 
the optimal solution would be O(nlogk) see here: How to sort K sorted arrays, with MERGE SORT
but that's just enough for leetcode already so i didnt do the min-heap
// http://oj.leetcode.com/problems/merge-k-sorted-lists/
",0,21153036
21153440,"
I think there is O((n1+n2+n3..nk)logk) solution for this problem where you do following:-


Add first k element to min heap
remove the min element and add into new list
remove next element from list which contained the min element and add to heap.
continue till heap is empty.


More interesting solution : -
Use merge sort like merging routine with huffman encoding like selection :-
Suppose you have k list with n elements each : -


Add all lists with there sizes as key into min heap
Select two smallest lists and merge them using merge sort like routine
Add the new list into heap with its size as key
1 to 3 till only one list remains, that list is your merged sorted list.


If there are k lists with n elements each then huffman like merging will give following time complexity:-


removing two lists from heap takes O(logk)
merge sort like merging takes O(n1+n2)


Logical iterations in the algorithm : -


merges all pairs from n lists of size n taking n/2*(n+n) = O(n^2)
merges all pairs from n/2 lists of size n/4*(2n+2n)  = O(n^2) ... done till O(logK) iterations.


Time Complexity : O(n^2*logk)
",0,21153036
21174622,"
There is no good solution here, at least not with STXXL.
The STXXL sorter is highly optimized, and the code requires the data type's size to be provided at compile time via template parameters. I don't see that this will, or even should change.
The method of instantiating classes for many different parameters is not nice, but pretty common practise. Just think of all the different std::vector instances used in simple C++ programs, which could all be handled via void* functions in C.
Depending on how much code you want to roll out, try instanciating powers of two, and then more fine grain for your common parameters.
",0,21136337
31212083,"
What if we store objects (records) of size n in a flat stxxl::vector of chars. Then, define a custom iterator based on stxxl::vector::iterator that merely skips n bytes on each increment. This will work with std::sort and even tbb::sort, when used std::vector instead of STXXL's. I see that STXXL's ExtIterator has a lot of additional traits. Is it possible to define them correctly for such an iterator?
",1,21136337
21125007,"
In the first conditional of merge, both branches have
One of them should be 
And that is why copy and paste is considered harmful.
",4,21124904
21133125,"
Change toReturn.push_back(left[left_it]); to toReturn.push_back(left[right_it]);
",0,21124904
21112241,"
Sorry but Nsight totally confused me, All this time I believed I was in release mode, but the run configuration it self was set to run the debug mode.
Now I've made sure everything is set to release, and it works much better.
The difference is only ~150% between int sort and tuple sort, which makes much more sense. Not sure what else can I do to improve the performance but it's good enough already.
The conclusion is: be careful with eclipse preferences, especially on linux.
",2,21109582
23507688,"
Just a followup on this that the use of functors gets slower if their call cannot be inlined by the compiler (which could happen due to various reasons like separate compilation units) . A good resource is here
",0,21109582
21096448,"
A std::map is sorted.  There is no way to construct a map that isn't sorted.
The problem isn't the fact that the map is sorted.  The problem is how your keys are designed.
You've said that your key is a date, but what it really is is a string.  How can the map know that the data in the string is actually a date, and that it should sort somehow by the year first, then the month, then the day?  It can't.  You have to tell it to do this.
Change your keys to be strings in this format:
YYYYMMDD
where Y, M and D are all numeric.  Don't try to use NOV for november -- use 11 instead.
You could also use unsigned longs for the key instead of strings.  This would make comparison quicker, but computing the values is a bit trickier.

If you must stick to the original format for they keys, then you have a bit of work to do.  The map is sorted according to the map's comparator, which is specified as one of it's template parameters:
[C++03 Example]
Since this appears to be homework, I'll let you fill in the missing bits above. :)
Using this comparator to compare keys, you can instantiate a map that does the correct sorting automatically:
",10,21096292
21096411,"
If all you want to do is sort the map in reverse order to what it currently uses, you just give it a std::greater comparator instead of the default, std::less.
Example:
http://ideone.com/9Guuil
",2,21096292
21096460,"
One way to go about lexical sorting temporal data is to convert it to the following form:
Now the default operator< for comparing string will work when sorting dates, since earlier dates will always be lexicographically less.
",2,21096292
21097561,"
To me, a clear design is to just define a Date class with proper day/month/year data members (and public accessors, with proper check to field values, e.g. check that months must be in range 1...12, etc.).
Then you can overload operator< defining a proper sorting on Date instances.
And then you can simply have a std::map<Date, int> (where int is used to store prices), and things will work simply ""out of the box"", thanks to proper sorting definition on the Date map-key.
If you want to format dates in a particular way, you can define a function that takes a Date as input, and returns the formatted date string (this can be modified basing on internationalization/localization issues; I think it's important to separate this output formatting aspect from the ""business logic"").
Compilable code follows (simply tested with VS2012):

Output:

15NOV1991 20
     01OCT1992 5

",1,21096292
21077692,"
Without a SSCCE it's hard to tell what is wrong with your code, but it looks like you're caught by using a class from an outdated library (blitz++), which seemed to have ceased further development/updating/debugging several years ago.
Since blitz::Array<int,1> is a dynamically allocated 1D array of integers, there is no advantage over carefully using std::vector<int> instead, when you get the full support (correct swap) and C++11 features (move semantics). So, the first thing to try is
and see if the symptoms persist. If this involves too many changes to your code, try this first with a SSCCE (which initially must show the same symptoms as your code).
",2,21077396
21073693,"
You have MergeSort(tab, A, Z) inside MergeSort, so you always call itself with exact arguments
It should be MergeSort(tab, A, st)
",1,21073560
21074546,"
You are using MergeSort(tab,A,Z) which call the same function again with same arguments which is will go one for infinite recursion hence error. You should only pass MergeSort(tab,A,sr) which will reduce your problem to half size.
",0,21073560
22275788,"

So, based on this idea, I would think MSB order would be fastest, but am I missing anything?

From my experience, recursive MSD radix sort is indeed faster than a LSD radix sort implementation. The reason for this however is not mainly the one you mentioned (which is valid, but not very relevant in practice), but a combination of these two:

cache efficiency: MSD lends itself to a recursive implementation. If the digits of the sorted objects (numbers, strings, ...) are reasonably randomly distributed, from a certain recursion depth onwards the whole subproblem fits into the faster CPU caches. Reducing the number of cache misses is in my experience the most important constant optimization you can apply when designing an algorithm, because the main memory is really slow compared to a typical CPU
Beneath a certain problem size you can use insertion sort. If the sorted objects are small enough (for example, if you sort integers) and if the whole subarray fits into cache, insertion sort might well be faster than any other sorting algorithm out there.

Your implementation is not recursive, so it might not have these advantages, depending on the order in which it solves the subproblems (I haven't really analysed the algorithm, but if you use a queue instead of a stack, you probably don't have very good cache locality).

I know that LSB performs ""stable sort"", but I don't see any practical benefit to this.

There are several applications where you need the stability property. One that comes to my mind is suffix array construction. I've written about a simple O(n log n) algorithm to do this as an answer to another SO question. It uses radix sort and requires that the sorting is stable. There are in fact stable variations of MSD radix sort, but they require additional memory. I don't know how they compare to LSD approaches.
",3,22275541
22275346,"
sort needs a two argument comparison function but the declaration as member function results in a call similar to:
There is no reason to make compairingPointsPredicate a member of a class. You can make it a free standing function (a friend of QPointF if access to private data is required).
usage:
",2,22275181
22249453,"
If your trying to implement an ordering function for one of the
standard library functions, your function is trivially wrong,
because it returns true if both passengers are rats.  To
establish a proper ordering function, comparing any two entries
in the same equivalence class must return false.
Further down... what happens if both passengers are men?  None
of your if are true, and you fall off the end, resulting in
undefined behavior.  (FWIW: it's generally a bad practice to
throw return around right and left in the function.  One
single return, as the last line in the function, and outside of
any control structure is a good general rule.) 
Anyway, the approach I would take would be to to map both values
to an integral priority, and then return Priority(pas1) < Priority(pas2);.  Much simpler, and guaranteed not to miss
any cases.
",1,22249344
22249544,"
I think the third condition pas2.status == ""child"", should be pas2.status != ""child""
Also, there is no default return statement in the function.
",0,22249344
22224246,"
You go outside the bounds of the arrays in your loops
The above loop will loop over indexes 0, 1 and 2, which is one to many for a two-entry array. This will lead to undefined behavior.
You have the same problem with the other sorting loop.
",0,22224140
22221796,"
The example below shows a non-working version of reorder called reorderfail() followed by a working version called reorder(). Both functions return vI to it's original state of 0 to vA.size()-1, but reorderfail() fails to reorder vA properly because it's missing a level of indirection needed to ""unpermute"" vA.
",0,22218698
22218699,"
A version of a working reorder that moves data instead of swapping it. This example may be easier to explain. Every permutation is a set of ""cycles"". reorder works by undoing the cycles. Assume that there are 8 elements, and vI contains the desired order. I placed the index i above vI:
Cycle 1: vI[0] == 5, vI[5] == 2, vI[2] == 0.
Cycle 2: vi[1] == 7, vi[7] == 1.
Cycle 3: vI[3] == 3.
Cycle 4: vI[4] == 6, vi[6] == 4.
undo cycle 1, t = vA[0], vA[0] = vA[5], vA[5] = vA[2], vA[2] = t.
undo cycle 2, t = vA[1], vA[1] = vA[7], vA[7] = t.
undo cycle 3, no correction needed
undo cycle 4, t = vA[4], vA[4] = vA[6], vA[6] = t.
Each time a value is stored in vA[k], vI[k] is set to k to indicate vA[k] is ordered.
",0,22218698
22217624,"
For the recursion part, one method is to recursively divide the lists into two lists, left and right, until the list size is reduced to 1 (or zero) in which case the recursive function just returns the list, else it's followed by code in the recursive function that merges the returned left and right lists, and returns the merged list.
Have you learned how to split a linked list into two lists? Normally this is done using two pointers. I'm not sure what you've been taught and what you're supposed to figure out. What level of programming class is this?
",0,22215178
22210885,"
You could allocate 50,000 bytes, initialize them to 0. Then use this array to count how many times each value occurs in the source array in one pass. You can then make a pass over the size 50,000 array and extract the values.
This is commonly known as Pigeonhole Sort.
",4,22210812
22210253,"
I'm not certain but this looks very very wrong
Maybe if you compare a to b you'll get better results.
After your edit, now your ""Correct Output"" looks insane and makes no sense to me, and your ""My Output"" appears correct, merely in reverse. Because, you know, you printed it in reverse. The problem is you're printing the last 5 in reverse.
",0,22209980
22229924,"
This is code I wrote and its work as long as it is no resize neccessary
",0,22201988
22179495,"
std::sort allows you to specify a binary function for comparing two elements: http://www.cplusplus.com/reference/algorithm/sort/
Now it's just a matter of constructing that binary function. A partial example is here: Sorting std::strings with numbers in them?
",1,22179430
22179480,"
The least painful way is to put approporiate leading zeroes into your file names (even writing a second script that takes the generated names and renames them may be easier than writing your own sort routine).
The second least painful way is to write your own sort predicate that does sorts _ delimited numbers as a number rather than lexicographically.
",1,22179430
22180271,"
Here's a comparison that handles any number of numeric values embedded in the strings:
It's deliberately ""C style"" so it can be applied directly and efficiently to character arrays.  It returns a negative number if lhs < rhs, 0 if they're equal, and a positive number if lhs > rhs.
You can call this from a comparison functor or lambda specified to std::sort.
",1,22179430
22180483,"
You can have a custom comparator something like following :
See demo here
",1,22179430
22155575,"
Simply calling std::sort will do the right thing. It performs a lexicographical comparison of each element of the vector, and this is recursive.
Output:
",5,22155451
22155743,"
This would be an example implementation:
",0,22155451
22155777,"
Very simple. You need create virtual mass of symbols, and you need to set for each symbols their index numbers, form 1 to N, and compare this indices.
Like this:
As well, you need temporary store.
",0,22155451
22143754,"
Here you go. I made a few minor fixes to some of your code, and left comments explaining what I fixed and why (all I recall at the moment is a couple of semicolons after if statements - you don't want those there!)
The loop is the answer to your question. It breaks down the input using substr, or substring, and prints it. There are also some basic sanity checks to make sure we can keep calling substr with a full word size and still keep iterating afterward. There's also a rolling counter that counts how many words we printed and prints an endl at the appropriate point.
It's also worth pointing out that, as the code stands right now, the command window will close immediately after printing everything. You might want to put a system(""pause""); or getch(); at the end so it won't close right away.
",0,22142217
22157719,"
Your print loop is doing you no favors at all. It should be a simple enumeration filtering on minimum frequency. no deleting, freeing, or otherwise memory management should be happening. Just walk the list:
This should also get you back to properly managing your lists in the wordCloud::~wordCloud() destructor to once again properly delete nodes. there are plenty of other things I would do different, but its a learning process so I'm not going to spoil your party. 

Update
Per request from the OP, below is a sample linked list insertion function that insertion sorts as it builds the list. While adapting this he identified significant differences and problems with the original implementation. Hopefully it helps someone else as well.
",2,22141944
22142429,"
I think that to print only one time every word you must make a unique list that will have words from your original list with number of appearances of them. To do this you just need two loops. One for getting every words from original list and second to check if word is in unique list. For this you should make a second list and copy every word once, if word occurs more than once you just increment frequency.
",0,22141944
22138172,"
I think you want is that if the value to insert is less than or equal to the current node, then do nothing and continue the loop, else insert and return. This can of course be written as: If the value to insert is larger than the current node in the list, insert it after the current node and exit loop.
So
",0,22138103
22137842,"
Simple, the copy constructor has no body defined in your DoubleLinkedList. This is often done to prevent it being used. As you can see below the copy constructor has no body, that's why the linker can not find it.
The reason you need to copy constructor is that the vector template uses it. You could prevent this by storing pointer to the DoubleLinkedList instead of the objects.
",0,22137798
22120373,"
here is error:
it should be:
UPDATE: remove second p1++; and p1-=n-1;
",1,22120345
22110137,"
Selection sort basically finds the smallest element in the remainder of the list and swaps it with the end of the sorted list, conceptually moving from left to right until you reach the end of the list.  After the first pass of the outer loop, the first element of the list has the lowest value.  Wikipedia has some excellent animations of selection sort in action.
You need a pointer to track the node with the lowest value starting at holder.
Then if the current node, temp, is less than min, update min to point to temp.  After the inner for loop you just need to swap min and holder if they aren't the same so the smallest element in the remainder of the list is now at the end of the sorted list.
",0,22110014
22097958,"
It sometimes helps to look at / think about the code: (taken from Wikipedia)
Based on the above, it should be easy to see that we only count an iteration when we're actually doing a comparison.
So it would be 4 iterations.

As a technicality, you could also talk about iterations in terms of the repeat ... until loop, which would give you quite different results.
And the 'steps' can certainly be split up into a lot smaller parts.
For ambiguities similar to the above, we tend to stick to big-O notation, which really just gives us a rate of growth of an algorithm's running time.
",1,22097528
22097756,"
IMHO, at the point of time when no steps were performed yet, the step count = 0. After performing one step, the step count = 1. I truly can't fanthom how you got to a point that performing 4 steps is to be considered five..
Anyways, remember that it's usually analyzed as O(f(n)) where term not-related-to-N like +-constant i.e. +-1 or +-100 are simply dropped off.
",2,22097528
22097690,"
You have performed 4 iterations. This is why number of iterations is 4.
",2,22097528
22095438,"
You specify an array of 9 elements, and yet you have 10 elements in the initialiser and in your outer loop:
And here you iterate up to index 10, which is the 11th element (index 0 is the first):
To fix, change to the following:
",1,22095328
22095375,"
for(j=0;j<=10;j++) will give you undefined behaviour since you're accessing outside the array bounds with your subsequent array[j].
int array[9]={5,2,7,4,7,6,9,8,1,3}; is also unbalanced, you need int array[10] since you have 10 elements in your initialiser list. Better still, let the compiler do the work for you and write int array[]. This is why 3 is currently omitted from your output (notwithstanding the undefined behaviour).
",4,22095328
22095383,"
array[9]; i < 10; j <= 10. array index out of bounds. undefined behaviour.
i and j should be checked like i < 9 and j < 9
And you have 10 elements in that array.
",2,22095328
22095406,"
Firstly, any code should be added using the code button so that it is formatted properly and easy to read. 
Secondly, you're array is too small. It's size is 9 but you have 10 items. 
",0,22095328
22089568,"
the problem is the way you rewrite merged records:
here is rewritten version:
I am not sure if this makes your program work as intended, but it should fix your segfault.
",1,22089002
22089300,"
r2=0x0) at CensusDataSorts.cpp:27, i.e. you have a null pointer.
Also change comparison to:
and
Otherwise it does not make sense. You cannot have <= for it to be logically correct. In fact I have myself got sorting crashes due to improper comparisons.
",0,22089002
22087535,"
You want this:
",6,22087515
22087953,"
std::sort works with iterators or pointers, so your options are:
With the &users[n] form, it's slightly easier to specify a sub-range within the elements.
Iterators provide a bit more abstraction - with the right iterator, you could sort a container that didn't store its data contiguously in memory the way the Standard requires std::vectors to.  If you start off using iterators, then should you change to use such a container later you won't even need to correct the sorting line, and it won't misbehave at run-time if you forget.  So, it's best to use iterators with the Standard algorithms and take a similar approach with your own code.
",0,22087515
22084733,"
Sometimes the key to horrible C++ error messages is to look at what it's trying to convert to what. Here it's trying first to convert a node to a node*. That means it's looking for a pointer but you're not giving it one.
So stop de-referencing temp.
",0,22084614
22083656,"
It looks like you are just storing values in the array, not pointers.
Changing the notation so that your existing loop to more conventional array addressing we would have something like this which may be more readable. 
If you want to use pointer notation, you can substitute arry[i][j] with *(*(arry+i)+j) but this is the same thing.  Are you wishing to achieve something extra via the pointer notation?
",0,22083202
22084637,"
There are several problems in your code.  

First, in the function quick_select(), you are comparing pivotIndex with n directly. Since the left isn't always 0,  you should compare n with the length of left part which is equal to pivotIndex - left + 1.
When n > length, you just callquick_select(a, pivotIndex + 1, right, n) recursively, at this time, it means the N-th element of the whole vector lies in the right part of it, it's the (N - (pivotIndex - left + 1) )-th element of the right part of the vector. The code should be quick_select(a, pivotIndex + 1, right, n - (pivotIndex - left + 1) )(n is ONE-based).
It seems you're using Hoare's partitioning algorithm and implement it incorrectly. Even if it works, when HOARE-PARTITION terminates, it returns a value j such that A[p...j] ≤ A[j+1...r], but we want A[p...j-1] ≤ A[j] ≤ A[j+1...r] in the quick_select(). So I use the rand_partition() based on Lomuto's partitioning algorithm I wrote on another post

Here is the fixed quick_select() which returns the N-th(note that n is ONE-based) smallest element of the vector:
and this is the rand_partition():
Call srand() first to initialize random number generator so that you can get random-like numbers when calling rand().
Driver program to test above functions:
",2,22080055
22063974,"
There are several problems with your code, see comments below:
",2,22063767
22061065,"
There are three methods that do the merging :-
Suppose you are merging m lists with n elements each
Algorithm 1 :-
Merge lists two at a time. Use merge sort like merge routine to merge as the lists are sorted. This is very simple to implement without any libraries. But takes time O(m^2*n) which is small enough if m is not large.
Algorithm 2:-
This is an improvement over 1. where we always merge list which are the smallest two in the remaining list. Use a priority queue to do that and select smallest two list and merge them and add new list to queue. Do this till only 1 list is left which would be your answer. This technique is used in huffman coding and produces optimal merge pattern. This takes O(m*n*logm). Moreover for similar sized lists it can be made parallel as we can select a pair of list and merge in parallel. Assuming you have m processors then the algorithm can ideally run in O(n*logm) instead of O(m*n*logm)
Algorithm 3:-
This is  most efficient algorithm where you maintain a priority queue for first elements of all lists and extract min to get new element also maintain index of the list min element belongs to so that you can add the next element from that list. This take O(s*logm) where s is total elements in all lists.
",11,22055495
22057372,"
Assumptions
The following method works with any container like array, vector, list etc. I'm assuming that we are working with lists.
Let's assume that we have m sorted lists which we want to merge. 
Let n denotes the total number of elements in all lists.
Idea
The first element in the resulting list has to be the smallest element in the set of all heads of the lists. 
The idea is quite simple. Just select the smallest head and move it from the original list to the result. You want to repeat that routine while there is at least one non empty list. The crucial thing here is to select the smallest head fast.
If m is small
A linear scan through the heads is O(m) resulting in O(m * n) total time which is fine if m is a small constant.
If m is not so small
Then we can do better by using a priority queue, for example a heap. The invariant here is that the smallest element in the heap is always the smallest element from current heads.
Finding the minimum element is a heap is O(1), deleting the minimum is O(log m) if there are m elements in the heap, and inserting an element into the heap is also O(log m).
In summary, for each of n elements, we insert it into the heap once and delete it from there also once. The total complexity with a heap is O(n log m) which is significantly faster that O(n * m) if m is not a small constant.
Summary
Which method is faster depends on how many lists we want to merge. If m is small pick the linear scan, in the other case implement it with a priority queue. Sometimes it's hard to judge if the m is small or not and in that case some experiments will be helpful.
",5,22055495
22056132,"
I assume that without libraries to the merger. Otherwise, you have to write an own linked list (this may be forward, or normal list). Rest the same. Easy example (for two lists):
Result:

1 2 3 4 5 6 7 8 9 9 10

Attention! You must compile with the flag -std=c++11 (or other to c++11). For example:

g++ -std=c++11 -Wall -pedantic -Wextra -O2 d.cpp -o program.out

The complexity: Θ(n)
Memory: Θ(n)
It's not hard to see, that each element is evaluated exactly once in O(1), we have n elements, so it's Θ(n).
Memory complexity is obvious. It is worth mentioning that if the two lists are no longer needed, it can be done without additional allocations (const memory).
The algorithm itself has been described so many times that it is not point to write once more.
In main problem we have lots of sequences, but the idea is the same. Here you have enriched example:
The complexity: Θ(n log k)
Memory: Θ(n)
Pop and insert operations are in O(log k), we perform them n times, so it's O(n log k).
Memory is still obvious, we have always k elements in priority_queue, and O(n) in out sequence.
",1,22055495
22055989,"
The code for this could be similar to a pointer and count based merge sort, starting by creating a ""source"" array of pointers and counts for each sequence, and allocating a second ""destination"" array to merge the ""source"" array of pointers and counts into. Each pass of this algorithm merges pairs of pointers and counts based on the sequences from the ""source"" array into the ""destination"" array, reducing the number of entries in the array by about 1/2. Then pointers to the ""source"" and ""destination"" arrays are swapped, and the merge process repeated until an array of pointers and counts only has a single entry.
",0,22055495
22055566,"
The C++ standard library contains std::merge
http://en.cppreference.com/w/cpp/algorithm/merge
",-1,22055495
22039303,"
Following may help: https://ideone.com/OjIlz4
",1,22037270
22038836,"
The best for your problem (especially with the amount of 30000+ records) would be to implement an AVL tree (a self balancing binary). I'd suggest you read something on wikipedia or some other site on how they work (especially the AVL tree). To give you an idea how to implement i did a random google search : C implementation of an AVL tree
",1,22037270
22021950,"
Subtracting one iterator from another should yield an integer. The STL's random access iterators yield a value of type ptrdiff_t when subtracted. It's good practice to use this type when implementing iterators in general. However, in practice, if you want to use, say, int, that's usually fine too.
Subtracting an integer from an iterator yields another iterator.
",3,22021886
22019694,"
In void checkIfNumberIsMoreThenThreeTimes(int arr[], int n), you have
and
So the first argument to mergeSortP is of type int*.
However, you only have a function
so the linker complains because it can't find it. Maybe you meant to call
instead?
",0,22019522
22020446,"
Following may help: https://ideone.com/oiAzTh
",0,22019522
22018623,"
About question 1: I think it should work if you reverse all comparison signs that involve dereferenced iterators, i.e., replace
by
(one might also replace the name 'min' by 'max' then to avoid confusion), and
by
These are the comparisons that compare the actual data.
About question 2: usually, an 'end' iterator refers to the position behind the last actual item that you want to sort. Standard algorithms (such as yours) will never dereference this iterator, so no overflow will occur.
",3,22018163
22018360,"
The iterators pointing to an end() are one past the last element, so that you'd usually loop through them like:
Your iterator implementation thus stops one before that last and is the culprit.
It might be a good idea not to test everything at once, i.e. a custom algorithm with custom iterators. You can use a stl container to test the algorithm and an stl algorithm to test your container.
",1,22018163
22008206,"
Maybe you can use a priority queue. After each calculation for a row, put the value into the queue. If the size of the queue is 11, then remove the smallest value from the queue. When all rows are processed just remove the 10 values in the queue.
",0,22004959
21998153,"
There are several problems. Some of them are:

The vector is passed by value, not by reference, so you're modifying the local copy.
You're accessing out-of-bounds data: inputVector[VECSIZE + 1] does't exist.
Use inputVector.size() instead of using the VECSIZE macro. Ideally, use the begin(), end() and iterators.
There's no need for VECSIZE at all. Simply append to the vector in the reading loop:

""It's been far too long since I've done any work with pointers in a language"" It's C++, you can do a lot without ever touching a pointer directly :)

",5,21998054
21998102,"
You are passing the vector to your function by value:
Which means you are sorting a copy of the vector, not the actual vector.  You need to change your function signature to
Another problem you have is that you are invoking Undefined Behavior:
the size of your array, and you are not swapping the items you are comparing.
I think what you wanted to do is:
Notice the problems this fixes:
",1,21998054
21999120,"
Each time you put the highest element at the end, so there's no need to compare to the end of the array each time:
",0,21998054
21979421,"
EDIT: Changed to use the 10 lowest elements rather than the highest elements as the question now makes clear which is required
You can use a std::vector of 10 elements as a max heap, in which the elements are partially sorted such that the first element always contains the maximum value. Note that the following is all untested, but hopefully it should get you started.
",4,21979117
21979169,"
Yes. What you want is a priority queue or heap, defined so as to remove the lowest value. You just need to do such a remove if the size after the insertion is greater than 10. You should be able to do this with STL classes.
",1,21979117
21979689,"
Just use std::set to do that, since in std::set all values are sorted from min to max.
",1,21979117
21979287,"
I think MaxHeap will work for this problem.
Repeat the same steps until the whole file is parsed.
",0,21979117
21978650,"
First, declare a functor:
Then, use it in your std::sort invoke:
That's it. C++11 is not required, it just makes such things much much easier since you can do all this in a lambda rather than a functor.
I leave it to you to ensure all vectors in the data collection have at least one element to avoid invoking UB (I assume they do, otherwise your logic for comparison may need to get a little more complicated.
",4,21978557
21955184,"
I can not tell you what your bug is but I will tell you how to find it. Writing a brute force solution for small number of points is very easy-simply compute the distance between any two pairs and find the minimal of those distances. For small n this solution is good enough. Now generate random points(say up to 20) with relatively small coordinates(say up to 100) and compare the answers of your solution and the brute force. Keep on doing it until the answers of your solution and the brute force differs. When I tried this approach I found the cases where I was wrong really fast and the first moment I could not find a wrong test in 20 seconds, it turned out I have fixed my solution.
I solved a very similar problem about one week ago and I was able to fix my solution with exactly the approach I describe. Also I have done this during a running competition and I believe this is the correct approach to problems that may have many edge cases.
By the way the classical solution to this problem is using divide and conquer and this is the approach I implemented. 
EDIT: actually after a little thought I think I can give an example that your solution you fail. Your logic is wrong - it may be the case that you need second to last x(or even further). Try this set of points: (1, 1), (2,100), (3,2)
",1,21954843
21933815,"
This is the correct approach and you have a very simple problem - the number of inversions for n = 105 may overflow integer. Think of how you can fix that. 
",0,21933717
29875826,"
The Error is input pairs of men and women will not given as sorted based on Male Chef Mi.
Before running merge sort you need to sort the pair  based on Mi < Male number> because male should be standing in an increasing order.
so your array fm should be array of pairs  and then sort this according to Mi.
And then all the operation in merge-sort will be based on second element of fm (fm.second)
Solution
",0,21933717
21920150,"
If you have a container IDArray with all the int indices in it, you can then do:
",1,21920051
21914034,"
If you change the line:
with (you also need to include <limits> and <iomanip>):
You'll see that the output is:
So considering approximations the vector has been correctly sorted.
PS you could use a custom comparator in the std::sort() call and a custom binary predicate in the std::unique call.
",2,21913177
32232207,"
As @juanchopanza mentioned in a comment, it is strongly recommended that you use std::sort over qsort in C++. The std::sort algorithm correctly calls assignment operators and is type-safe, while qsort does not. For example, if you try using qsort to sort an array of std::strings, you'll get undefined behavior.
That said, if you absolutely must use qsort this way, the problem you're running into is the ""invisible this"" pointer. In C++, member functions are fundamentally different than free functions because in order to call a member function, you need to provide a receiver object. In the code you've written above, you're getting an error because qsort expects a free function that can be called with two arguments, but you've given it a member function that wants two arguments, which effectively really needs three arguments - a receiver object and two pointers.
To fix this, you have a few options. One option would be to mark the function static, indicating that it is a free function scoped inside your class rather than a member function. Another option would be to use lambdas to define the comparison function, since C++ lambdas without capture lists are free functions. I'd actually recommend that second option over the first unless you need the comparison function in multiple places, since it more clearly indicates that you just need the function as a one-off.
",1,21894665
21888700,"
This problem is actually NP-complete; it is a form of the ""Multiple Choice Knapsack Problem"" (MCKP).
A simple approach which may work out for you is to generate combinations from the top 1 letter in each slot, then the top 2 letters in each slot, then the top 3, etc., and stop once two iterations in a row produce the same top 20 scores. This isn't guaranteed to be any more efficient than a brute force search, but it's simple to implement and will work well for the ""general"" case.
",2,21871536
21872852,"
First of all, you need to sort your candidates. It takes O(nlgn) time.

Secondly, depending on how many best scores you need, you choose the top n number of characters to do the permutation.
n is the number of candidates you choose. m is the number of best scores you need. For example, if you need 20 best scores, you only do set of 7 characters. Probably the problem you face is that you do the permutation with all candidates while it is a waste to do it with some very low candidates. 

Third step is get all the permutations you need, then sort it and print.
",2,21871536
21872244,"
for examples of perm code rosetta code has some great examples in many languages this is in c++. Once you get your permutations code working you can make a return biggestscore function and maybe use a map to map words to scores. 
In your main program you can do something like this:
How you code your return biggest score is up to you, but I suggest using a map object,
that way you can check for the score of any arbitrary letter in constant time like so:
",0,21871536
21843204,"
The comparison function must follow a strict-weak-ordering. 
For example, If I am the sort function, I give you two armor_set pointers, ask you ""which one comes first?"" and you return a true/false value denoting which value comes first. I then give you the same two armor_set pointers but this time, change the order of items.  I ask you the same question ""which comes first?"".  You then return the same true/false value. Guess what -- you lose. 
That in a nutshell is a violation of the strict weak ordering. There is no way a < b, and at the same time b < a. Looking at your somewhat complex comparison function, my guess is that you're violating this rule.  
If you're using Visual Studio, the debug runtime does this exact check for ordering violations like this.  The comparison function is called twice, the first time with A,B order, and the second time with B,A order.  The return values for each call are compared, and an assert() will occur if there is a violation.
",10,21842749
21842939,"
The Compare operation (lambada) is the problem. The operator in sort should make sure the defined order is strict weak order. i.e
You function seems miss it. For example:
When you call compare(lhr, rhs), it may return true or false depends on other value. While you call compare(rhs, lhs), note the order is different, it will always return true. Both compare(a,b) and compare(b,a) return true is not allowed, which violates the property of strict weak order. 
",2,21842749
21860882,"
The specific failure is a missing
which should be the second or third test. 
",1,21842749
21814799,"
Typo in last while. You may increase your warning level to let your compiler show you your typo (warning: statement has no effect [-Wunused-value]).
should be
",2,21814706
21814827,"
As pointed out by WhozCraig's comment, you're not assigning any value to mergedArray[19] because you left out the assignment part of the statement.  
Since you haven't assigned a value, it's printing out whatever value happens to be at that memory address from previous usage.  If you run your program (as it's currently written) several times, you'll see that the number there might change.  Also, if you'd printed out the values in mergedArray before assigning anything, you'd see more such meaningless (to you in the current application) numbers.
",1,21814706
21798594,"
There are several faults in the code you post on codepad, I'll point out in the program comments. Since you didn't give us the definitions of Popular, Symphony and Opera, I'll have my own. For convenience, I put all the code in one file.
Here's the output:
",0,21795132
21796054,"
Firstly, update your question to show your real code for merge, merge_sort and CD. I'll be referring to the actual code posted in the comments.
Your problem likely stems from you sorting the titles, as opposed to sorting based on the titles. Everywhere in your code where you are assigning the title of a CD to another, you are going wrong. You compare the titles, but you relocate and reorder the objects themselves (or in your case, the pointers to the objects themselves.)
Anyway, to fix this problem you just replace any code like this:
with this:
For example, instead of
you should have written
By the way, memory allocation and deallocation is not something you do as an afterthought, to see whether it works or not! Even mediocre programmer treat memory with care; the good ones deal with memory with outright love and respect.
",0,21795132
21787405,"
You're right, you need a combination. Here's what I would do:
Insert an object:
The idea here is that the objects are actually in a map but a vector which can be accessed by index holds iterators to the objects in the map. The key thing is that neither container is modified unless both are. You could write a class that wraps these 2 containers together such that you can't modify one without modifying the other, or you could just make sure you never make that mistake.
Access the elements by index from indexedObjects and by key from sortedObjects. If you need to add/remove elements from middle indices use a list instead of a vector, so you can add/remove from the middle of the container. If you don't have a separate key, use a set, not a map. If you have duplicate keys/objects use a multiset or multimap.
",0,21787014
21781665,"
There's a faster way to do your step 2. Actually, you combine it with step 1.
Right now you keep all the results, sort them, and pick the top N to put in the output buffer. What you could do instead is create a priority queue that holds N items, and just keep the top N found so far. In pseudocode, it looks something like this:
Look into the STL std::priority_queue.
If the number of items requested (n) is much smaller than the length of list2, that will save you a lot of time.
As somebody else pointed out, it might be reasonable to remove items from list2 (or somehow flag them) when they match, so that they won't be matched again. Unless of course you want and expect duplicate matches.
",1,21780199
21778249,"
You can easily do this by using two iterators:
Live example
Note: in case you're not using C++11 and thus calling size() might present a significant overhead, you can replace it with this (and of course replace all usage of auto with explicit types):
",2,21777941
21778246,"
You can use standard algorithm std::adjacent_find to find a pair of elements for which first < second and then swap them.
For example
The output is
Or if you want to process all such situations when first < second then you can use the following code
The output is
",1,21777941
21778367,"
This gives the desired result and it switches the comparison for ""good"" elements, exactly as you asked:
Executing results with:
",1,21777941
21779243,"
In case you don't have C++11 support, simple C++03 solution using 2 iterators could be:
Then (based on your example) if you do:
then for the:
there will be following comparisons: A < B? (no) C < D? (yes, swaps) E < F? (yes, swaps too) yielding the output:
",1,21777941
21779749,"
If all you want to do is a pairwise traversal and swap elements if the first one is less than the second then you can e.g. use std::adjacent_find like this:
This will cause the list of numbers 3 2 1 2 1 3 2 to be arranged as:
But, this is not the same as your expected result 3 2 2 1 3 1 2 and I don't undestand why you do not  want to swap the last pair 1 2 like the others?
If what you want is an erratic pattern for sorting then there can be no simple solution. Instead you must use special handling of individual elements.
",1,21777941
21775219,"
The two versions that don't work are making copies of the vectors, and sorting these, leaving your outer vector unchanged. You can use references instead:
and
",10,21775166
37093319,"
Here you have a complete description and implementation. The gap is defined as whatever value that you will not use. If you were using pointers, NULL is a good option.

In general cases you must create an auxiliary array to the one that has the original data. In this case:
Here you have library sort pseudocode:
",1,22701839
22701386,"
Look at using std::algorithms to handle sorting. 
",1,22701341
22701579,"
In this code:
you have an error. Number n is size of your array, to maximum array index is n-1. In this code, on last comparison, you are comparing tab[n-1] with tab[n].
Try chaning it to:
",0,22701341
22722774,"
Try it this way:
This code was
If I'm not wrong 'cause I can't test it by now, it should be: 'cause it would be printing at 1st place tab[0-1] i.e (tab[-1]) that we all know, it doesn't exists.
That should work
",0,22701341
22688941,"
if you use C++11, you can create a tuple  and sort it.
You can define a custom comparison, like in this example:
http://www.hongliangjie.com/2011/10/10/sortin-tuples-in-c/
",0,22688669
22674438,"
Consider using a graphing package such as gnuplot. You would have to use it to plot, say as bar graphs, the array values your program is trying to sort.
",1,22674319
22640054,"
I think that should work:
",0,22639681
22640023,"
Arrays a and x are right next to each others in stack. Seeing how you have duplicate value 87 in output, it seems your sort functions access memory outside the array you give to them. This is buffer overrun, a type of Undefined Behaviour. With that, your code could do anything because you have corrupted variable values (or worse, corrupted addresses/pointers).
Double check how you access arrays. Remember that C array indexes for your arrays of length 8 are 0..7!
",0,22639681
22620240,"
The correct statement is:
The function takes two iterators, the beginning and end of the range to sort. A pointer is a random-access iterator, so it can be used by a function that expects one. In this case, v + 2000 points past the end of the array and correctly stands for the end of the range.
",1,22620230
22620316,"
You have two possibilities:
Or
The first approach only works with arrays, the latter works with std::vector, std::array and lot's of other containers.
",1,22620230
22563784,"
It seems you've swapped the arguments of compare. Think of a.compare(b) < 0 as equivalent to a < b. Then you'll see you're doing:
You probably meant if (theWord < Head) instead, so the real code would be:
Of course, since you're only using the result of each compare() once, you could use the operator < directly instead:
",1,22563560
22563757,"
just use std::set.
with std::list (linked list + duplicates allowed):
note: there's also std::multiset within <set>, which also allows duplicates.
",1,22563560
22523839,"
Essentially you need to learn about bitwise operators.
What you need to know for radix sort is that 2^n is 1 << n and that in conjuction with bitwise and & you can query if the the nth bit is set by x & (1 << n) != 0.
",0,22522267
22522025,"
This is how you call the method [1].. 
10 is the number of elements...
",1,22521822
22525364,"
This is a radix sort that sorts an array by a decimal digit. The sort is done from least significant digit to most significant digit. This means a series of calls with exp = 1, 10, 100, 1000, 10000, ... .
Here is an example of a radix sort that sorts an array of 64 bit unsigned integers by the bytes in the integers, from least significant to most significant. In this example, the temporary array is passed as a parameter to RadixSort():
}
",0,22521822
22505710,"
Your consideration is wrong. The value of r does not change, since it is given as value to the Quicksort function(not a reference).
You handle the ranges with p,q such that p is the first index in the range and q the first index not in the range.
Thus, your calls were wrong:
Here is the complete example. I used std::swap to change elements and
ans std::vector instead of an array.
Live example: ideone
",13,22504837
39423785,"
This is a template based solution. However, it works only for arrays of elements for now. If anyone has an improvement to make it generic for both arrays and STL containers, please do so.
",1,22504837
29246093,"
A much easier and clean implementation, also gives you number of minimum SWAPS in for QuickSort:
",0,22504837
36330852,"
Since I see various answers, you could try this:
I have it in Quicksort (C++).
",0,22504837
22500998,"
Have a look at std::sort. That function allows you to sort a collection using a predicate that you may specify yourself. In the example code below I create a vector of pairs. The cmp function compares two of these pairs by calculating the ratio for each and returning true if a's ratio is greater than b's.
So effectively you need to specify a function (or a function object, or lambda or whatever) that takes two arguments of your collections element-type and compares them. If a should come before b, then the function should return true, and if not then it should return false. That function is the third argument for std::sort
",8,22500861
22501167,"
In C++11:
If you don't know the [](...){...} syntax, it is a lambda-expression from c++11.
Note that comparing multiplies the way I done it has a better precision that dividing (because integer division takes place), but can lead to overflow.
",3,22500861
22483981,"
You can sort not exactly data, but only indexes to other arrays and custom comparator. After sort, you will have array of sorted indexes and for O(n) you can permute all arrays. 
",0,22483360
22473822,"
What about this?
",1,22473190
22467214,"
Change the code snippet the following way
",1,22466992
22463534,"
Recommendation:  create a card class and use std::vector.
This will reduce the complexity (and defects) of your program.
Arrays are difficult to use, so use std::vector.
Since a card contains both a suit and a number, let us proceed in that manner:  
Given the above definition, one can make decks and player's hands as containers of Card:  
The remaining code on how to use the card is left to the OP.  
Edit 1:  Base 52 math
Assigning a random suit and value to the cards can be thought of as selecting a random number between 0 and 51 (or 1 and 52).  The trick is to convert the number into suit number and value number.  
There are 13 cards in a suit, so card number / 13 will produce the suit number:
Also, using std::bitset may help in determining which random numbers have already been generated.  
",2,22463081
22463584,"
Your situation requires a different approach than using strings to capture the suits and cards.
Your sorting order for the suits, ""Hearts"" > ""Diamonds"" > ""Spades"" >
""Clubs"" is easy to implement using numbers but require unnecessary complication
when using strings.
Similarly for the cards.
My suggestion is to create enums that represent the suits and cards. Store those enums
for all computations. When it's time for printing messages, have a function that returns a string given a card.
You can also shuffle your cards using std::shuffle
",1,22463081
22460276,"
Unlike build-in types like int, float etc, you have to define the compare function for struct reg, i.e. rules that you want the elements to follow when sorting. Like this:
And then, you can pass this function to sort the vector:
",4,22460245
22460309,"
You either have to overload the comparison operator (less than, afair) or provide a custom comparison function.
",0,22460245
22460378,"
You need to tell std::sort what makes one instance of the struct ""less than"" another instance of the struct.  
In other words, if I give you two instances of those structs filled with data, and ask you ""which one is placed before the other?"", what is your answer?  The rules you used to come with that answer is what you need to code and give to the 3 argument version of std::sort.
",0,22460245
22436725,"
In code B the assignment from list to final is in the wrong direction. Try this instead:
",6,22436676
22429120,"
I think you have something like  
So , use sort(omitKey1.begin(),omitKey1.end(),compare);
and in compare use : return structure1.question < structure2.question
Also , this just sorts the vector , not the heap , so i may not have answer for sorting heap .  
Meanwhile look at http://www.cplusplus.com/reference/algorithm/sort_heap/ 
@user3093536   this should help .
",1,22429000
22432701,"
Use cout<< to target the problem
After read the wiki of Strand Sort, we know there is two parts of this algorithm.

Take out a relatively sorted list
Merge it with the result list

So you need to find which part is wrong, just add
before if(resC > 0) { we will see step1 is right or wrong.
Add 
In the bottom of the while(arrC > 0) {} loop to check step2.
Get:
As we can see step1 is always right but the merge step is wrong.
So we will focus the code in if(resC > 0) {} block.
Read the code carefully
If you read your code carefully you will find in for(int j = 0; j < resC - 1; i++) { the i++ is nonsense.
And the merge step has many bugs, you need to rethink about it.
The fixed code of step 2:
",1,22424522
22422351,"
Here is the problem:
The inside loop should looks like that:
In this computation we need index of last element, and n is the number of elements of 0 indexed array, so:
",0,22422203
22418339,"
Doing it the way you describe is reasonable.  And defining the comparison function inline in the header itself is a good idea if you care about performance (rather than defining it in the .cpp file). 
Personally I have a different preference than you.  I would declare this reasonable default comparison function at namespace scope (i.e. right below the class), because as written it does not need privileged access to class members.  And I would declare it as operator <.  I don't think there is anything to be ashamed about in terms of making one function ""special"" when it seems to be a reasonable default ordering.
",1,22418080
22415686,"
Easiest way just put them in std::vector<House>
",0,22415667
22430432,"
",0,22415667
22415361,"
I would suggest using struct i/o a bunch of arrays and std::sort (assuming you are allowed to do that).
",2,22414005
22414688,"
I don't see why your code inside the if (i > middle) block and its else block are so complicated. All you have to do is copy the remaining elements into aux, and then from aux back to arr:
This may or may not be less (or more) efficient than your solution, but at least it works :)
By the way, there is a cute trick to implementing merge sort where you don't have to worry about exhausting one range before the other. You copy the left range to aux in ascending order, and the right range in descending order. Then you start merging from both ends, and when the indexes meet, both ranges are exhausted:
This solution appears to produce the wrong output, but only because there is a bug inside main:
You are printing aux, when in fact you should be printing arr:
",0,22413728
22411873,"
Generally speaking, your heapify function doesn't seem to take a minimum of both left and right branches into consideration. Let me show you an ideal, working implementation (object-oriented, so you might want to pass the heap as a parameter). You can find the exact pseudocode all over the internet, so I'm not really presenting anything unique.
where
As you can see, an algorithm first checks which one of left and right children have lower value. That value is swapped with current value. That is everything there is to it.
",2,22411642
22409961,"
You just need to keep the condition ( j >= 0 ) and to change your starting point in your loop over i, you should start from 1 not from 2.
",3,22409714
22390110,"
std::sort does not guarantee that the order of ""equal"" elements remains unchanged. For that you want std::stable_sort. ""Equal"" in this context means two elements a and b for which 
",3,22390034
22390457,"
Try the following code
The output is
Your predicate will look the following way
",1,22390034
37756873,"
It's Called stable_sort that means if 2nd value is same then it will follow same sorting as input like 16 3  is before 20 3 in input. so in result 16 3 will be before 20  3 . in c++ code you should be add stable_sort() instead of sort(). Here is my accepted code :
",0,22390034
22373484,"
You print out addresses of array element here
 std::cout << &values[i] << ""\n"";
You should use 
 std::cout << values[i] << ""\n"";
to print elements
Your sorting functions are also wrong
}
inline void selectionsort(int values[], int size)
",1,22372793
22373436,"
There's much to do here, let's start with your output:
will give you the address of values[i]. As you never change the address, just the values you get the same output all the time.
Then let's take a look at your selection sort: It isn't a real selection sort algorithm. I think you mixed up bubblesort and parts of selection sort here. Take a look at a selection sort from wikipedia and you will see that there are a few parts missing like

keeping track of the minimum index of your current sub array (mandatory for selection sort!)
wrong swap implementation (should rely on the minimum index)

",0,22372793
22372985,"
There are several things to correct here:

Replace
void bubblesort(int values[], int size);
with
bubblesort(values, ArraySize);
Your output routine is actually returning adresses instead of values because you dereference it twice if you write &values[i]: - values[i] already dereferences the value.
std::cout << values[i] << ""\n"";
Furtheron you might want to check again on your sorting algorithm. Bubblesort seems to work as it stands but in selection sort there is still something fishy. Vladimirs answer will help out.
Reference for Bubblesort in C

",0,22372793
22368825,"
Just write 
in the other source files that you want to call that function (before you call it).
Note that if you are not using header files, then you have to manually take care that if you change the return type or parameter list in one file, you make the same change in all files.
A few other things:
You might want to consider moving your return statement to the end of the function,instead of returning the instant you make the first swap. Or even better, have the functions return void - the caller already knows values because he just called the function, so it achieves nothing to return it again.
cout << &values[i]<< ""\n""; outputs the address of each value, I guess you wanted to output the values instead.
int* array_p[] = values[]; and the line following it are syntax errors, I think you meant: int *array_p = values; bubblesort(array_p, ArraySize);
",1,22368764
22367967,"
The result of an assignment is the left operand, so the condition 
is using sorted as the condition after it's assigned a new value. The warning is there to give you a notice that using assignment as condition is sometimes not what you expected. You can use 
to silence the warning.
",6,22367895
22367973,"
It's one of the quirks of C and C++ that they allow an assignment in the middle of a statement. Usually it's an error (= instead of ==) so a good compiler will warn you about it.
The value of such an expression is the same as the assigned value.
In this case it's a very tricky optimization; if the value was false it's reset to true and the loop continues, if it was true then it becomes false and the loop termination condition is met. I would never use this in code that anybody was expected to maintain.
",3,22367895
22368009,"
An explanation for the code. Basically, if sorted ever is true before the condition the loop will stop.

1st loop: sorted is true
Within the second for loop, it basically checks if the array is sorted. If it isn't sorted -> false and the loop continues. If it is, sorted-> true and execution stops. 

",0,22367895
22368010,"
The comparision normally is as follows:
Of course, this does not make any sense. But instead, you have the following:
By doing this, you just negate the condition for sorting, meaning that the array, which is unsorted, is assumed to be sorted. Then, if you traverse the complete array without making any swap, the left side of the assignment is taken as a condition (which in this case is true).
",0,22367895
22356121,"
I managed to resolve this by definig this:
Then hen sorting say:
openList.sort(MyClassComparator());
",0,22355518
22356151,"
std::list is looking for 
while you provide 
change signature to 
if you want to use in-class default operator. Or, your solution would work too (note that it has proper signature with const).
",0,22355518
22356687,"
Browsing the online sources for libstdc++ and libc++, one can see that both libraries use the full gamut of the well-known sorting algorithms from an intro-sort main loop:
For std::sort, there is a helper routine for insertion_sort (an O(N^2) algorithm but with a good scaling constant to make it competitive for small sequences), plus some special casing for sub-sequences of 0, 1, 2, and 3 elements. 
For std::partial_sort, both libraries use a version of heap_sort (O(N log N) in general), because that method has a nice invariant that it keeps a sorted subsequence (it typically has a larger scaling constant to make it more expensive for full sorting).
For std::nth_element, there is a helper routine for selection_sort (again an O(N^2) algorithm with a good sclaing constant to make it competitive for small sequences). For regular sorting insertion_sort usually dominates selection_sort, but for nth_element the invariant of having the smallest elements perfectly matches the behavior of selection_sort.
",17,22339240
22444975,"
The question is, how can STL say std::sort worst case is O(N log(N)), even though it is in essence a QuickSort. STL's sort is IntroSort. IntroSort is in essence a QuickSort, the difference introduced change the worst case complexity.

QuickSort worst case  is O(N^2)
What ever partitioning you choose, there exist a sequence that QuickSort will run on O(N^2). The partitioning you choose only decreases the probability of the worst case to occur. (Random Pivot Selection , Median-Of-Three, etc.)
EDIT: Thanks to @maxim1000 s correction. Quicksort with pivot selection algorithm Median of Medians has O(N log(N)) worst case complexity, but due to the overhead it introduces it isn't used in practice. It shows how good selection algorithm, can change the worst-case complexity through pivot selection, theoretically.

What does IntroSort do?
IntroSort limits the branching of QuickSort. This is the most important point, that limit is 2 * (log N). When limit is reached, IntroSort can use any sorting algorithm that has worst case complexity of O(N log(N)). 
Branching stops when we have O(log N) subproblems. We can solve every subproblem O(n log n). (Lower case n stands for the subproblem sizes).
Sum of (n log n) is our worst case complexity, now. 
For the worst case of QuickSort; assume we have an already sorted array, and we select always the first element in this array as the pivot. In every iteration we get rid of only the first element. If we went this way until the end, it would be O(N^2) obviously. With IntroSort we stop QuickSort, when we reach a depth log(N), then we use HeapSort for the remaining unsorted array. 
Sum them up;
Until branching stops, N + (N - 1) + ... + (N - log(N)) operations done. Instead of using gauss to sum up, we can simply say N + (N - 1) + ... + (N - log(N)) < N log(N).
The HeapSort Part is (N - log(N)) log(N - log(N)) < N log(N)
Overall complexity < 2 N log(N). 
Since the constants can be omitted, the worst case complexity of IntroSort is O(N log(N)).

Added Info: GCC STL implementation source code is here. Sort function is at line 5461.
Correction: *Microsoft .NET* sort Implementation is IntroSort since 2012. Related information is here.
",21,22339240
22337207,"
off the cuff code:
I think this is more elegant and I suspect that it might be a tad more efficient.
Disclaimer: code not touched by compiler's hands, logic not checked by execution…

Update: checking the code, hey set iterators don't support subtraction. so possibly efficiency of this is not so good. but it looks better (more elegant), i think! :-)
Test code:
",2,22336890
22339001,"
A little analysis of two implementations: with sorted vector (initial) and a set.
Initial variant with sorted vector should be faster than usage of the set.
In big-O terms these decisions are equal. In initialization phase we need only once sort the vector and build the set. The complexity of std::sort is O(n logn) worst case since C++11, insertion into std::set is the same O(n logn) (standard 2011 23.2.4). (As a rule set is implemented as a Red-Black Tree.) 
On the second step of search, lower_bound is O(logn) and the same is set::find.
But in the terms of constants search in sorted vector (lower_bound) should be faster than set::find as it uses continues memory which is good to hit the processor caches. For instance this analysis shows twice more faster and also use 3 times less memory.
One can measure on the concrete data and hardware (really the results will be quite interesting).
So if we do not need make insertions into the sorted vector, its usage is preferable. 
",1,22336890
22337290,"
If you're going for efficiency, and have only a small number of different values that can easily be mapped to small integers (like letters), take a look at http://en.wikipedia.org/wiki/Counting_sort.
There are plenty of implementation examples out there. See: http://www.codeproject.com/Tips/290197/Cplusplus-Count-Sort-Implementation
for one.
",0,22336890
22326955,"

use struct node *next, instead of node *next. Same applies to *list and *current
some compilers does not accept void main(), try using int main()
put all function implementation outside main()
declare *current and *list as global variables (outside main())
C++ is case sensitive, cList is different from clist. fix cList implementation
not an error, but use -> operator: head->num = 0;
there is no field d1 in structure node (function cList and iIOrder). Use field num.
to nullify a pointer use NULL instead of 0
cList function is void, but you are returning a pointer, change return value
in iANode function you are using a lot of undeclared variables. You probably want to use *list, *current and *record.

There is a bunch of analythic errors, but you asked for syntax errors. Maybe you will find more errors later, try to fix theses first.
",1,22326143
22333153,"
You declared function sortID as a non-static member function of class studentData
But you call it as a non-member function
Of course the compiler does not know how this name is declared because you declared name 
Moreover the function defined after main with name sortID differs from the member function because its first parameter has type studentData s[] while the early declared function has the first parameter of type studentData
",0,22319441
22319896,"
Thank you guys for all your help!
I just used the #include < algorithmn  > 
So I just added this between the studentData and main()
and included
std::sort(myClass, myClass + 10, compare_student_by_id());
in the main.
",0,22319441
22318438,"
For i=0, you find the largest element (of all elements, except the last one, since dec starts off at 2, not 1) and put it in the 0th position.
Then, for i=1, you find the largest element (again of all elements, except the last one, which includes the first) and put it in the 1st position.
And so on.
You can't sort like that - sure, the largest element will end up at the end (which, based on your comment to the other answer, isn't what you want), but there's nothing ensuring that any of the other elements are actually sorted.
If you want to have it sorted from largest to smallest, in your inner loop, you need to stop when you get to i, so you're only picking the largest element of the remaining elements.
This is very similar to selection sort, so you could look at that for further information, or optimizations (like keeping track of the maximum and just swapping at the end, rather than swapping at each bigger element we find).
",0,22317835
22318193,"
Why don't you change the while loop into a for loop? For example:
Also, did your order of operations in the while loop mess up? I suppose it should be jk[0] + 1 - dec or jk[0] - dec + 1?
",0,22317835
22309281,"
If Process_MyObj is indeed affecting the keys of all the elements in A, I don't think there is much you can do. If it only modified some of the keys, you could write code to update individual elements in the heap.
As your code is now I don't see what you gain from building a heap. I would just do a linear scan to find the minimal element, swap it with the last one, and then pop the last element.
",2,22308946
22309037,"
You could try sorting the vector and picking the elements in order, instead of using a heap.
It will not improve the big-o complexity, but it could possibly improve the constant factor.
",0,22308946
22658005,"
How much of the time is in Process_MyObj, and how much in the heap operations --
50 / 50 %, 80 / 20 % ?
This is important, becase you want to balance the two.
Consider the following general setup:
Too much time updating the list means not enough time doing real work.
So first measure the ratio Process / Heap time.
A cheap way to do this is to make a second run with
Process_MyObj and compare done twice, e.g.

make_heap runs in linear time --
see how-can-stdmake-heap-be-implemented-while-making-at-most-3n-comparisons --
so speedup there will be tough.
If values are constant, a heap of
64-bit <32 value, 32 index> would be more cache-efficient than pointers.
whats-new-in-purely-functional-data-structures-since-okasaki
on cstheory.stack lists dozens of papers, mostly theoretical,
but one or two might be relevant to your problem.
Real speedups are almost always problem-specific, not general.
Can you tell us more about the real problem ?

Added: If most pops are small, and pushes big,
try putting a small cacheheap in front of the big sorted list. Pseudocode:
This could be effective if cacheheap stays in the real cpu cache; ymmv.
(You might be able to cheat, and leave bigsortedlist inaccurate instead of sorting it every time.)
",0,22308946
22309089,"
The simplest fix would be to separating out the testTo counter, which makes us not have to worry about complicated code to work with the end of the array - we can happily generate out of bounds indices, then simply ignore them by checking if we've gone out of bounds.
I also thought I'd simplify your code a little.
This is what I came up with:
Live demo.

The end of the array poses quite a bit more of a problem when trying to convert the data back.
Would it be possible to just pad the last pairs of blocks with some unused value (say 0)? So we'd get:
Which would give us an output of:
Which would be much easier to convert back.
Alternatively, if you're stuck with your structure, or feel like braving the code anyway:
When dealing with the last pairs of blocks, you could base what you need to do on the number of elements remaining in the array. Take note of the fact that we have 4 elements (6,9,7,8) in our last pairs of blocks, now also note that the data is in the form firstBlock secondBlock firstBlock firstBlock - we alternate between the blocks once, then run out of elements in the second block, so just pick from the first block. More generally, the number of times we alternate (and thus the number of items in the second block) is elementsRemaining - blockSize, which is 4-3=1 in this case.
",1,22308451
22308764,"
This example is quick and dirty but should give you the idea.
I used a structure because all the elements are public by default with C++
I imagine Qt has convenience functions to do some of this work.
cppreference std::sort
// compiling with cygwin
$ g++ -o sort sort.cpp 
// running the example
$ ./sort.exe
Before sorting
name, number:   Tom 32
name, number:   Jack 31
name, number:   Tom 29
name, number:   Jill 22
After sorting
name, number:   Jack 31
name, number:   Jill 22
name, number:   Tom 32
name, number:   Tom 29
",1,22308164
22298448,"
Realistically
Based on how filesystems and operating systems are implemented, I'd say that a solution to the question as posed is impossible.
May I suggest you need a SQL database...
Aside
If you were talking about sorted binary records where the size of a record exactly matched the size of a sector on disk, it might theoretically be possible to avoid rewriting data on disk other than file meta-data if you had a hypothetical filesystem that let you insert 'sectors' into the middle of a file. 
In theory, anyway, as if such a strange file system existed  (scroll down to 'REL' file type -- never thought I'd be thinking about this again!) ...
",1,22298065
22299289,"
This is the solution you didnt want, what you want is impossible without using  SQL..  but here goes the  temporary files way....
It loads  everything into memory and performs some processing and then writes all items back  into the file again.
",-1,22298065
22295206,"
In this code
There is no point in having this statement if(i >= 10) break, because the look exists when the exit criteria is met, i.e. i<10.
The problem is here:
You only loop once through the array. The simplest sorting algorithm, bubble sort, requires a double loop:
Notice that this is not necessary:
You could use your data struct.
",3,22295095
22295229,"
The fastest way to force it work - to add for(int j=0; j<10; j++) just above sort for. 
",0,22295095
22295224,"
You can using qsort http://www.cplusplus.com/reference/cstdlib/qsort/ for sorting array of structures, and when you not need writing your own sorting code.
",-1,22295095
22287307,"
You can create a comparator
Or you can overload the operator < in your class
Note that if you overload the operator <, then you don't need to add the third parameter in the sort function.
",2,22287246
22287309,"
comp will be a function that will return a bool to indicate the comparison in two parameters.  In your case, it should look like:
and your call will be: sort ( d.begin(), d.end(), compare );
",0,22287246
22286165,"
Quicksort has a truly dreadful worst-case performance, as you have discovered here. It is calling itself at a stack depth of 5000. This Wikipedia article has a good discussion on the subject. In particular, it mentions tail recursion as a solution to your stack overflow problem.
Briefly, this means that instead of the last call to quicksortLastElementPivot, followed immediately by a return, you just loop back to the start of the function. This has the same effect, but the tail recursion doesn't increase the stack size. For this to work, you have to make sure that the smaller of the two partitions is sorted first, using traditional recursion, and the larger partition is sorted by tail recursion. Something like this (not tested!):
",2,22285951
22286238,"
C++ standard does not define the stack-size of an executable program.
This limit is typically defined in the make file or the linker-command file of your project.
Depending on your IDE, you might also find it within your project settings (under linker-configuration).
The answer given by TonyK is doing quite a good job in explaining the stack usage of quick-sort under the worst-case scenario (which is exactly the case in your code, where arr is sorted in reversed order).
",0,22285951
53579321,"
",0,22285951
22282068,"
You may not use std::sort with sequential containers such as std::list or std::forward_list because they have no random access iterator that is required by the standard algorithm std::sort. By this reason the both containers have their own member functions sort.
In you case the code will look the following way:
Take into account that you need to include header <string> otherwise your program will not be compiled with other compilers.
",9,22281962
22281975,"
std::sort requires random access iterators, which std::list does not have. But you can use std::list::sort instead.
where I have made the parameters of the predicate const references, since there is no need to copy them, and doing so might incur some unnecessary overhead.
",7,22281962
22277745,"
The binary_function is a base class for your sorting function:
http://www.cplusplus.com/reference/functional/binary_function/
The syntax:
indicates that your structure is a derivative of the template instantiation of binary_function. The "":"" denotes the inheritance.
Moreover, the structure works as a functor type in C++ - the operator() is overridden and the sort function will use it for comparison. This usage of functors can be replaced by anonymous functions in C++11.
",0,22277711
22277372,"
Usually, merge sorting with only n extra space uses an auxiliary array passed into the merge() and mergesort() functions. Then, instead of making a new helper array every time, you just use the same indices in the helper array as you're using in the current merge() call - that way, all of your merge() calls can do their thing without stepping on each other's toes.
Since your professor won't let you pass in any extra parameters, you're going to have to do something a little hacky to be able to use an auxiliary array - we'll use as much space on the end of the array we get passed in as we do for the array itself. Note that this requires you pass in an array twice as long as normal, half-filled with garbage (we just need the space) - and it also requires a little extra work to make sure you know where the helper array starts. 
I'm going to try to avoid giving you exact code since this is homework - but the idea I used (I just got this working on my computer) was to keep a global variable called helper that was a pointer to the ""end"" of the array (or the beginning of your auxiliary array). Then, when you get into your mergesort() call, check if it's initialized - if not, point it to the beginning of the auxiliary array. Other than that your code can stay basically the same - but instead of creating a new array helper[] at the start of every merge function, just use the global one.
If anyone has a solution that doesn't involve using globals I'm all ears - but within the limitations, this works.
",1,22276668
23192710,"
Here are the problems I can find:

Don't include sortBS.h from within UList.h. UList does not require sortBS to exist (it'd work fine without it), so it shouldn't be included as such. Plus since that file is being included before you define what UList actually is, you get errors saying sortBS doesn't know what UList is.
sortBS declares a variable named List then doesn't use it, and tries using a variable named ""items"" which does not exist. Rename one of those to match the other one.
The last part of sortBS can be simplified to this:
if (items[index] > items[index+1]) std::swap(items[index], items[index+1]);

",0,23191850
23193153,"
First there is no need for sortBS(), because you just declare sort() as the friend of class UList.
In you class UList, please use these codes:
But in the function of sort, there is bug: you can't access items directly, please do vector<T> items(List.items);
if you just want use friend void sort (UList<T>&);,
you should put the define code of function sort inside class UList, just like this:
",0,23191850
23188890,"
Use std::sort, preferably with a lambda, for example.
",0,23188763
23188049,"
It is not clear why the function is called as find_oldest. 
Nevertheless you could use standard algorithm std::sort with a compare function that can be a lambda expression. For example
The other way instead of using the lambda expression is either declare operator > for structure employees or a functional object.
In my opinion it is better to define a functional object. In this case for any kind of sorting for example by first names or by last name you could use a separate functional object. For example
",2,23187954
23188027,"
Write a custom comparison functor/function/operator and pass it to std::sort():
",0,23187954
23177008,"
The first thing that hits me in the eye is the following:
I'm not saying that segmentation fault is caused by this, I'm just saying that this piece of code is fishy.
",1,23176910
23165927,"
Here's the culprit:
Suppose you start with a vector of half a million entries. That initial call to mergeSort is going to call mergeSort on a vector of half a million entries, but only have it sort the first 250,000 elements. (Then it will repeat on the next half.) The next call to mergeSort is going to receive that full 500,000 element array and call mergeSort to use sort the first and then second 125,000 elements of the array. And so on. Each time along the way, mergeSort will be receiving that vector of half a million entries, but only sorting a subset. Eventually you'll be calling merge, where a temporary array of half a million elements will be allocated and initialized on each every call.
The result is n2*log(n) behavior. That's not exponential behavior, but still it's not good.
I see three different solutions:

Allocate that temporary b once and pass it as an argument to mergeSort and merge.
Allocate a temporary array in merge that is of size end-start+1. Now you'll have to use offsets to deal with the fact that b[0] corresponds to array[start].
Merge in place. You don't need a temporary here. However, this is nontrivial and will make the algorithm an O(N*(log(N))^2) algorithm. 

",7,23165780
23165920,"
It seems that the relocation of the vectors are taking much of the time. Adding to vectors are not O(1) operations. Try to change the vector to a basic C type array, and you will notice the difference. Also, what I see from the values, it is no way exponential. A higher polynomial maybe.
",2,23165780
23159789,"
There's a classic sorting algorithm that runs in O(n) time called the counting sort. More precisely, it runs in O(n+k) time and uses O(k) space, where k is the number of possible keys.
Here, you have only 3 possible keys, true maybe, and false, so k=3. Because this is a constant, it is eliminated in big-O notation, so you get O(n) running time and O(1) space.
",8,23159743
23159812,"
For 1.:
implement a kind-of counting sort: go through your table counting only 'false' elements. Then write a counted number of false elements to your array and fill the rest of the array with true values.
For 2.: same as for 1., but this time count both false and maybe. Then fill your array just like in 1.
",2,23159743
23159849,"
The question is phrased somewhat like homework, but in the real world, std::partition is the right tool for the job.
There's also stable_partition which is slower but preserves ordering, and partition_copy which is O(N) and stable but takes extra space by making a copy.
For the second task, just call partition twice, once to separate false from maybe and true  and another time to separate maybe from true. The total cost is still O(N).
",2,23159743
23159836,"
Loop through the array and count the number of true values. That is all you need to do. The number of false values is the array_size - #true. This is essentially the same information as the sorted array.
If, for some reason, you need it unpacked (e.g. you need a bitmap for drawing purposes), just memset #false in the array to false, and memset the rest of the array to true (or, vice versa).
",0,23159743
44854287,"
From the start, find the first ˋtrueˋ element. From then end, find the first ˋfalseˋ element. Swap them and repeat for remaining elements until both iterators are equals. O(n) for data with 2 states.
For 3 states, I would do someting similar but use extra 2 extra iterators to remember from where I got ˋmaybeˋ.
I am not sure if it would also works with 4 items. It might be greater than O(n) since some items migh be exanged twice!
",0,23159743
23147078,"
It would probably be easier to visualize and implement if you have separate functions for arrange and swap.
Then the arrange functions will just be bubble sorts.  But you also lose scope when calling swap so they don't actually do anything.  It would be easier to just swap them within the Arrange functions.
",0,23146908
23137537,"
This:
should be this:
because you want to pass the sorting functor, not a system object. And you are forgetting a semicolon at the end of the sort statement too.
You can also simply do:
Not to mention that you can pass the systems by constant reference in your function, since you don't need to modify them. And it's better for you to make the operator() const as well:
",2,23137487
23122002,"
Your code won't compile in its current state since you reference 'size' and 'array' variables that do not exist, but here's what a bubble sort looks like:
",0,23121845
23121990,"
The logic for the bubble sort would be the same, except you would be using an array of pointers. Only the if statement needs to change, so that it compares using the values in the structures that the array pointers point to.
",1,23121845
23120666,"
If list[p] == list[r] then pivot is not assigned any value from the array and stays with its default value of zero. And if all items of the array are greater than zero, or all are less than zero, then one of the while loops runs p or r out of array's bounds.
",0,23120229
23120409,"
Think about this: what happens if every element in your array is the same value?
You have too many if else if statements when trying to figure out the pivot, and you didn't account for the possibility that list[p], list[r] and/or middle have the same value. I don't know if that's the root of your problem, but it's certainly a problem.
",0,23120229
23118769,"
In arrayListType<elemType>::partition(int p, int r) you access list[r]. When partition gets called the first time, r equals listSize(), which is one past the last element.
",0,23117800
23115329,"
The function object you pass to std::partial_sort needs to be either a callable object, or a function pointer. To make a function pointer you nedd to use the address-of operator &, just like when you make a pointer out of any other variable:
Also, I hope your function is marked as static? You can't use non-static member functions as ordinary function pointers. The reason is that all non-static member functions have a hidden first arguments that is the this pointer inside the function. So either make sure the function is static or use e.g. std::bind:
",1,23115138
23104225,"
remove this

flights[idx]++;

at the last line of printing loop.
P.S. Here's some code to simplify yours
",2,23103775
23104506,"
This line that you do while printing:
will modify every pointer, almost certainly making each and every one invalid to dereference.
You should remove it. (It looks like a line left over from older code.)
It would also be a good idea to separate sorting from printing, as nobody expects an output function to modify the data it's printing.
And unless you have a very good reason, you shouldn't be working with pointers to flights, anyway.
",0,23103775
23093271,"
The comparison has to be a binary functor that can compare all elements of the list. The member function CMail::comp does not satisfy that. Try a non-member. This can be implemented in terms of your member CMail::comp:
and then
Alternatively, use a lambda:
",5,23093188
23093289,"
Change your comp function to static.  You are trying to access it with no object instantiated.
",0,23093188
23093332,"
The non-member function used as a comparison has to take two arguments and return bool
In C++11 you can use lambda function. Here is example which calls a member function CMail::comp:
",0,23093188
23090823,"
Recursively splitting a list into sub-lists for sorting is inefficient. HP / Microsoft STL std::list::sort uses an array of n pointers to nodes, where array[i] is a list of size 2^i (except array[n-1] can be larger), plus a temp pointer to a node. The nodes are ""merged"" into the array one at a time. One all nodes are merged, the array is then merged to create a sorted list. 
You could also implement a more conventional bottom up sort using 4 pointers to nodes (2 ""source"", 2 ""destination"" poitners) and a count for sub-list size (1,2,4,8, ..., until >= size of list)
Ancient example C code. The array is static, but if this code is converted into a class, then the array would be a class member. Note the comment about NODE.next and LIST.first which was used to simplify appending to an empty list. Some STL code uses a similar method, but you could just add the code to check for empty list handling without the assumptions about next and first being the first members of a structure (which means they have the same address as the structure).
",0,23090198
23090511,"
The first thing you need to look at is what the high level description of your solution is. It looks like you want to do merge sort, and for that the steps are:

split the input into two (roughly equivalent size) lists
independently sort both 
merge the results together

You mention that you want to have sort be a member function so just make it:
For the implementation, you first need to split the list into two, without assuming that you know the correct size, you can split in half by creating a new list (local) and moving every other node from this node to the other list. At this point you have the two lists that you can recursively sort and then you would call merge
In the same way, you can implement merge as a member function that takes the other list:
Note a couple of changes in the interface. The first is that if you want to do a in-place operation, there is no point on returning a copy of the list, you can return nothing (the caller already has the object) or you could return a reference to this list.
",0,23090198
23085880,"
You can use type_index for this. You constructing one from a type_info object that's returned from typeid operator. It's a class with overloaded relational operators with well defined ordering, so that it is useful as a key type in associative containers and alike.
Here's an example:
The output is:
",9,23085715
23085832,"
You specify the comparison function. For more details on that, see for example Sorting an STL vector on two values.
Inside the comparison function you can write whatever you want. It can compare whatever properties of your objects. In particular, it can compare one specific value obtained via a virtual function, such as getType(), which may return 1 in Der1, 2 in Der2 and 3 in Der 3.
",0,23085715
23085860,"
You could implement a virtual function, say prio which returns the priority (an int) among the types; prio would be suitably implemented in the derived classes. Then implement a comparator which would evaluate prio on two instances of Base to compare them.
",0,23085715
23085922,"
These are just possibilities, there is not one true answer to this.
Sorting?
The main problem of sorting is finding a key upon which to sort. This is ""phase 1"", if you want. Phase 2 is using a generic sorting from the standard library and is often easier than phase 1.
Keying
One possibility is to use typeid / type_info.
Instances of type_info define operator == and operator !=, as well as a hash_code member function.
Sorting
Use a generic sort algorithm from the standard algorithm. As the key for sorting you could use e.g. the value returned from the hash_code function.
",0,23085715
23061817,"
Like this:
You have to specify the template parameter Compare (which is 2nd for set). When constructing a map, you need to give the comparison function object to the constructor of map.
",2,23061733
23039739,"
Quite a lot wrong. Fixed it here:
Output:
",3,23039663
23039708,"
is supposed to return a T, but you are useing an int array to catch it:

To work out, you can change this method to (you don't need to return it, i.e. removing the return line):
and call it like:
",2,23039663
23039716,"
The return type of sortArray is T but what you return is data of type T[]. You should change to the following prototype:
",1,23039663
23039729,"
You are doing bubble sort.
You need to fix the method signature as follows:
T * sortArray(T * data)
   {
In the main(), you need to fix the calls:
   int * sorted = sortArray(arr);
This should fix the errors. Basically, you are sending in a pointer to an array, and you want the method to return a pointer to a sorted array.
",1,23039663
23039369,"
You either need to know the number of elements in the array, passed as a separate parameter or have a pointer to one past the last element.
or
and you would call them
",1,23039352
23039375,"
In c there is essentially no difference between an ""array"" and a ""pointer to the first object in the array"". Arrays are referred to using their base pointer, that is, pointer to first object.
Technically precise explanation at Array base pointer and its address are same. Why?
So, just sort the array as you would anywhere else. Got an example sort or sample code in mind or is that sufficient?
",0,23039352
23039383,"
Sort it exactly as you would sort it before you passed it in. If your sort() function requires a length, then pass the length as an additional parameter. 
",0,23039352
23039382,"
The best would be if you could start using std::array from C++11 on:
http://en.cppreference.com/w/cpp/container/array
This way, you would also have the size known and accessible by the corresponding size method. You could also consider other std container types rather than raw array. In general, it is better to avoid raw arrays as much as possible.
Failing that, you would need to know the size of the array either through function parameter, or other means like class member variable if it is happening inside a class, and so on.
Then, you could use different type of sorting algorithms based on your complexity desire; let it be quick sort, bubble sort, heap sort, stable sort, etc... it depends on what kind of data, the array represents, etc.
One sorting algorithm is to use std::sort. Therefore, you would be writing something like this:
or
",0,23039352
23040622,"
The slides you've found are great! But where did those queues come from in your code?
Anyway, here you are (live example):
which you can use like that
where generate() is included in the live example and generates the strings given in your question.
I am not trying to explain how this works here, I assume you can figure out since you are working on the problem. But a few comments are in order.

We are neither sorting the input sequence in-place, nor returning a sorted copy; we are just returning a sequence of positions of input elements in the sorted sequence.
We are processing strings from right to left.
The complexity is O(lw) where l is the input length (number of input strings) and w is the maximum input width (max. length of all input strings). So this algorithm makes sense if the string width does not vary too much.
The first template parameter R of radix_sort() is the number of possible values for each digit (letter) in the input. E.g. R = 128 means that possible values are 0..127. This should be fine for your input. I haven't tried to do anything clever with respect to ASCII codes, but you can customize function bin() for that.
In the output of bin(), value 0 is reserved to mean ""we are past the end of this string"". Such strings are placed before others that are still continuing.
I have tried to give self-explanatory names to variables and functions, and use standard library calls for common tasks where possible.
The code is generic, e.g. it can sort any random access container containing random access containers, not just vectors of strings.
I am using C++11 features here and there for convenience, but nothing is really necessary: one could easily do the same just with C++03.

",5,23038622
27241643,"
Very similar to iavr, but sorting in place (benchmarked against iavr's solution with g++ -O3 and takes about 2020ms compared to iavr's 1780ms), enjoying a regular interface and resuable code. The problem with Iavr's implementation is that its logic only works with containers of strings, and is not easily extensible to other types. Obviously his specialized version is more efficient, but it might be worth it to sacrifice some performance for regularity.
You can find the rest of the code at radix sort implementation
General Radix sort:
Counting sort to sort on each digit (in place):
Extract value of digit:
",0,23038622
23031454,"
You are basically asking this question. As the top answer states:

Yes, that's [the iteration order is] guaranteed. Moreover, *begin() gives you the smallest and
  *rbegin() the largest element, as determined by the comparison operator, and two key values a and b for which the expression
  !compare(a,b) && !compare(b,a) is true are considered equal. The
  default comparison function is std::less.

",1,23017379
23008728,"
Your comparison operator does not implement a strict weak ordering, which is a requirement for std::sort. A simple way to implement this is with a lexicographical comparison. This is made easy with std::tie:
You can also roll out your own in the absence of std::tie. The idea is that you have to handle the case where both ranks are the same.
",5,23008678
23008748,"
Typically when you compare things with two items you do it like this:
Edit... I didn't think of the actual resulting order... I guess you want to order first by Suit and then by Rank... so I've just reverted the order in my original post.
",3,23008678
22977999,"
In your arraySort() method, you should take note of the fact that for instance if maxSub=10, then for the part where you write
you might end up performing
Since C++ does not perform bound checking on arrays, your code, although buggy, might end up compiling successfully, and may (or may not) produce the correct result. Thus you need to change the loop condition to
Besides, your arraySort() is sorting in the Descending order, and your binSearch() has been implemented for an array sorted in ascending order. You can change either of the methods as per your requirement.
Hope this helps.
",1,22977818
22977906,"
Your sorting algorithm seems faulty to me. If you are trying bubble sort, sorting implementation should be like this.
",0,22977818
22952337,"
You aren't clearing out lstRay on each iteration. This means when you loop around again, each lstRay is getting longer and longer, so your list is growing exponentially.
However, I am surprised that it gets that far - it looks like your count function will clear the list.
",0,22951734
22953217,"
The infinite loop is inside count(). The loop on temp never terminates, because temp never gets below zero.
The radix_sort function has a problem too. listRay[tmp] is not initialised. 
",0,22951734
22950955,"

Yes, the order will be the same. std::map uses order of keys to store the data (in C++11 there is unordered_map, which ignores order), so when you iterate over it smaller goes first.
For such small dataset an array (or vector, or list) will be much faster than a map.

[EDIT: Except in the case where the map has fewer elements (benchmarked). Depending on the number of elements present, the program may iterate over the map much faster than the array.]
",2,22950811
22950865,"
You're using a map to store linear indices as keys. Just use a vector or an array. You shouldn't be concerned about the order a map stores items, it's always going to do it in the most efficient way possible, and you shouldn't have to assume anything about that.
You can also insert to the map like this:
Or like this:
",2,22950811
22947037,"
When you are keeping your vector list sorted while inserting elements one by one , you are basically performing an insertion sort, that theoretically runs O(n^2) in worst case. The average case is also quadratic, which makes insertion sort impractical for sorting large arrays.
With your input of ~30000 , it will be better to take all inputs and then sort it with a faster sorting algorithm.
EDIT: 
As @Veritas pointed out, We can use faster algorithm to search the position for the element (like binary search). So the whole process will take O(nlg(n)) time. 
Though , It may also be pointed that here inserting the elements is also a factor to be taken into account. The worst case for inserting elements takes O(n^2)  that is still the overall running time if we want to keep the array sorted.
Sorting after input is still by far the better method rather than keeping it sorted after each iteration.
",6,22946772
22947003,"
Keeping the vector sorted during insertion would result in quadratic performance since on average you'll have to shift down approximately half the vector for each item inserted. Sorting once at the end would be n log(n), rather faster.
Depending on your needs it's also possible that set or map may be more appropriate.
",2,22946772
22946412,"
",1,22945769
22945959,"
I would say use a linked list. Create a NODE for every element such that each node has the following
Put each of this node in an array so that you have array of nodes.
Once you have that you can sort the array using the data member of each node.
Since the row and col part of the node doesn't change you will be able to preserve the location of each element in the matrix using that.
",0,22945769
22941024,"
C++'s std::sort requires that the iterators being sorted implement ValueSwappable.

Type T is ValueSwappable if

Type T satisfies the Iterator requirements
For any dereferencable object x of type T (that is, any value other than the end iterator), *x satisfies the Swappable requirements.


And to be swappable, you basically need this to work:
Additionally, std::sort requires the following expressions to be valid (MoveConstructible  and MoveAssignable:

Definitions:

t is a modifiable lvalue of type T.
rv is an rvalue expression of type T. 

Requirements:

t = rv;
T u = rv;
T(rv);


Your compiler appears to be broken...
The code you have presented does meet these requirements. So I'm not sure why your compiler is refusing this code. Your PersonImmutable does implement the requirements of std::swap because of the operator= overload.
Your immutable object shouldn't meet this requirements though (because it's immutable)...
That being said, your operator= overload will cause the compiler to crash, because you're returning a stack variable by reference.
An operator= overload should almost always return *this by reference. Which requires mutating the object. So it doesn't make much sense in an immutable object.
Do you really need to sort these objects?
If you have to sort them, there are some options.

You can sort a vector of pointers.
You can sort a std::list of immutable objects.
There's other options too..

The minimal(ish) testcase for this code...
A valid compiler should accept the following code as valid. It sounds like yours does not.
",5,22940961
22926179,"
Your sort calls are using SortByCityName and SortByCityCode, but those are member functions not free-standing functions. The sort call doesn't call those as member functions on an object instance, so the member functions don't match the signature and it can't find them. You can fix this in two different ways: you can either take them out of the class altogether, or you can make them static members and use the class specifier e.g.
P.S. One trick I like to use in these situations is to have a single functor class that can sort by either criteria depending on a parameter.
",2,22925963
22923900,"
Ok, now we're getting somewhere.
The very first version (before your edit) did decrement the incoming edge count incorrectly.
Now there is another issue: In each iteration, you repeatedly take nodes that have already been taken (node #1 is a good example) because they still have zero count (number of incoming edges). By decrementing their ancestors again and again, some of the counts will drop below zero (such as for node #2).
You have to somehow mark the nodes that have already been used and do not use them again and again in each cycle. This can either be achieved a) by setting some flag for the node, b) using a set of used nodes, c) by removing the node from the list, or (probably the simpliest) d) by setting their edge count to a negative number (for instance, -1) after putting them into the output queue.
After your second edit, the algorithm as such should work (it works for me after some minor tweeks). However, the usage of adjList is pretty strange -- how do you exactly include multiple edges for one node into a map?
",1,22920925
22916838,"
When using bubble sort, you need to keep in mind in which directions your ""bubbles"" move. You first have to pick the biggest/smallest element from all the array and move it to the end at position n-1. Then pick the next one and move it to to position n.
See here for an even better implementation.
",4,22916676
22917220,"
The problem with your code is that you try to bubble stuff down, but loop upward. If you want to bubble stuff down, you need to loop downward so an element that needs to go down goes down as far as it needs to. Otherwise, with every iteration of i you only know that an element may be bubbled down one space.
Similarly, if you bubble things upwards, you also need to loop upwards.
If you want to see what happens, here's your code with some output statements so you can follow what's going on:
If you run this, you can see that for entries with higher index, there aren't enough iterations left to bubble them down all the way to where they need to go.
Also, here's code with your bubbling-down fixed (i.e. sorting in reverse order):
",6,22916676
22917007,"
It is a logic problem:
You should change the a[j+1] for a[i]
",0,22916676
22917014,"
You are comparing and swapping wrong numbers, look for differences here:
",0,22916676
22902841,"

Is there a way to print the contents of this map in alphabetical order, but case insensitive?

Yes. 

You will have to create a custom compare functor that compares two strings in a case insensitive manner.

Use the case insensitive compare functor to create the map.

If you don't want to store your map ordered in a case insensitive manner, create a copy of the original map using cicompare just before printing and print the new map.


",3,22902719
22952216,"
As stated in the accepted answer, you want to use a map with a custom comparison function. The trick is getting the proper comparison. You don't want a totally case-insensitive comparison or ""And"" and ""and"" would be equal, allowing only one of them in the map. Your sample data doesn't cover all cases; for example what would be the order of ""An"", ""And"", ""AN"", ""AND""? The following comparison function orders them ""AN"", ""An"", ""AND"", ""And"" - shorter strings are always less than longer strings of the same characters, and the first character that has different case is a tie-breaker with upper-case before lower-case.
I struggled with what to call this; it's not a case-insensitive comparison because it differentiates between inputs with different case. I finally decided it should be called a case-aware comparison.
",3,22902719
22902906,"
You can store the data in a vector. You can store the data as a structure or pair in the vector. If you use a pair then,
Then you can call the std::sort in it.
The compareFunction is,
and then you can print the vector which should give you the desired result.
",0,22902719
22950998,"
I think the usual way to do this is to create an index of iterators to the elements to be displayed:
and sort the iterators according to the display criteria:
remembering to dereference the iterators for display:
(See it all live at Coliru).
I've used boost::algorithm::ilexicographical_compare, Boost's case-insensitive locale-dependent string comparison, to save some typing.
",0,22902719
22921737,"
The problem at hand:

Calculate the scalar triple product of 3 3-dimensional vertices, being each component of each vector represented as binary32 float.
Being able to tell if a result of that calculation is greater than other result of that calculation.

So far so good, but if we directly apply the formulae to the vectors, some bits may be lost in the operations and we will be unable to discern two results. As @rcgldr pointed out, sorting is not the problem, the precision is.
One solution to floating point roundoff problems is to increase the number of bits, that is, use double. You said you have no double, so let's do it ourselves: perform the whole calculation in an array of unsigned char as long as we need.
Okay, okay, practical considerations: 

The input is made of normalized vectors, so the length is no greater than one, that implies no component is greater than one
The exponent of a binary32 float ranges from -127 (zero, denormals) to 127 (or 128 for infinity), but all components will have exponent from -127 to 0 (or else they would be greater than one).
The maximum precision of the input is 24 bits.
Scalar triple product involves an vector product and an scalar product. In the vector product (which will happen first) there is subtraction of results of multiplication, and in the scalar product there is a sum of results of multiplication.

Considerations 2 and 3 tells us that the whole family of input components can be fit in an fixed-point format of size 127 bits for offsetting plus 24 bits for the mantissa, that's 19 bytes. Let's make it 24.
To be able to fully represent all possible sums and subtractions, one extra bit suffices (in the advent of carryover), but to fully represent all possible multiplication results, we need double the number of bits, so it resolutes that doubling the size is enough to represent the vector multiplication, and tripling it will make it enough for the next multiplication in the scalar product.
Here is a draft of class that loads a float to that very huge fixed point format, keeping the sign as a bool flag (there is a helper function rollArrayRight() that I'll post separately, but hopefully it's name explains it):
When the class is constructed with the number 1.0f, for example, the array r have something like 00 00 00 00 80 00, notice that it is loaded to the lower part of it, the multiplications will ~roll~ the number accordingly  to the upper bytes, and we can then recover our float.
To make it useful, we need to implement the equivalent to sum and multiplication, very straight-forward, as long as we remember we can only sum arrays that have been multiplied the same number of times (as in Triple product) or else theirs magnitude would not match.

One example where such class would make a difference:
Consider the following 3 vectors:
And the following function that calculates the triple product: (hope I've got it right haha)
The result for fTripleProduct(a,b,c); is 0.1336331
If we change the last digit of the fisrt component of a from 0 to 6, making it 0.0097905766 (which have a different hexadecimal representation) and call the function again, the result is the same, but we know it should be greater.
Now consider we have implemented the multiplication, sum, and subtraction for the imSoHuge class and have a function to calculate the triple product using it
If we call that function for the two above versions of the vectors, the results in the array differ:
And they differ after the precision of a binary32 float indeed, meaning that if we cast that array back to float, it will be the same float, but if we compare the arrays, we can tell which one is greater.

The put that reasoning to the test, I've made a full working example, that you can compile and run right away with -O3 -Wall -std=c++11 in GCC, or equivalent on another compiler and will output:
The source code is here (working fine on Ideone):
Source Code on IDEONE C++11 code
If you have not migrated to C++11, the code compiles and run in C++98 if you define the exact-width types uint8_t, uint16_t, uint32_t, int32_t yourself.

How to use it?
Simple call the function tripleProduct with your inputs and compare the results using the provided overload comparators operators, you can also cast the class imSoHuge to float (after the calculation of triple product) using the provided overload cast operator.
You can provide an array of that class and comparators to any sorting algorithm.

Conclusions and considerations:
Notice that a float multiplication is now performed as a multiplication of two 70+ bytes long array, that means hundreds of time more clock cycles, plus the sums, comparisons etc, this shall be thousands of time slower, but hey, it's exact. 
The whole design of the algorithm is to work with normalized vectors (there is some room here, as I don't know the precision or your normalization procedure), but it will all overflow and be meaningless with most 'greater-than-one' vectors.
You can easily cap the array of the result to as many bytes you wish, if keeping all that array in memory is too much. Very few cases will produce results diverging after ~12bytes
I haven't stress-tested everything, like denormals, and corner cases, there is some comments in the code to the critical points.
and of course:
You can easily improve everything, I was just willing to share the reasoning =)

Source code again
Main reference:
Single-precision floating-point format (Wikipedia)
",3,22899563
22901187,"
The general algorithm is:
",9,22897053
22897428,"
There are only 6 possible permutations, so you could just write a bunch of nested conditions to get all the possibilities. See, e.g., here. On the other hand, something simple but more general like insertion sort is efficient for small arrays. Insertion sort is also  used as an optimization for sorting smaller arrays in quicksort. So you'd expect it to be used in std::sort.
Indeed, I just debugged into std::sort and that uses insertion sort for smaller arrays on my implementation (VC++2012). If the size of the array was known to be 3 at compile time it is a fair bet that the generated code would be fairly optimal. I would therefore stick with std::sort unless there is a very strong reason to optimize.
",3,22897053
22897639,"
In case I didn't use std::sort, I would use:
",1,22897053
22888339,"
Sending an pointer to a memory location would work only if your processes would work on the same physical machine, and that is not a case in distributed processing with MPI, where every process receives a copy of a data that has been sent to it. You should treat every process as it would run on separate machine, therefore it could directly not access any other machines memory.
If you want to process data using shared memory and threads, take a look on OpenMP API.
",1,22887853
22888305,"
You seem to think that MPI processes share memory: they don't. The child process can't modify the parent's array directly, because they have completely separate memory spaces (which could, in fact, reside on physically separate computers).
",1,22887853
22880672,"
Twice you have <= nSize, it should be < nSize.  In C++, if an array has size N, the valid indices are 0 through N-1.
",0,22880561
22880696,"
The for-loop condition is incorrect - should be < nSize rather than <= nSize. This explains why an additional random element is printed.
",0,22880561
27263641,"
declares the array on the stack.  There's a limit on stack size. It varies by OS and configuration but it could easily be less than 12 MB, the amount you're requesting (assuming 32-bit ints). Try allocating your array on the heap instead using a std::vector.
It's impossible for the compiler to warn you about this problem because stack size is set by the OS when it loads a program.  You could re-configure your OS to use a tiny stack by default and a program that worked before would suddenly start overflowing.
If you're interested in learning more about how the OS detects your stack overflow, look up virtual memory, MMUs and Guard Pages.
",3,22866585
22870257,"
Not sure if this is the issue, but your merge sort seems buggy.
Use unsigned integers instead of signed.
",1,22866585
27163568,"
",0,22866585
22850555,"
If the vector you are sorting is made up of pointers LatticeLocation*, then the sort you get is kind of meaningless: you are just sorting pointers (i.e. you are sorting objects based on the particular ""random"" location they occupy in memory), without considering the semantics of your LatticeLocation class.
You may want to provide an ad hoc custom sorting criteria, using e.g. a lambda as the third parameter to std::sort():
",3,22850323
22850407,"
It simply compares pointers LatticeLocation* according to operator <. In fact this code has undefined behaviour if pointers in the vector do not point to elements of some array because you may not compare pointers that do not point to elements of the same array.
For example in the C Standard there is written clear enough

In all other cases, the behavior is undefined

In the C++ Standard the operator is defined the following way

3 Comparing pointers to objects is defined as follows: — If two
  pointers point to different elements of the same array, or to
  subobjects thereof, the pointer to the element with the higher
  subscript compares greater. — If one pointer points to an element of
  an array, or to a subobject thereof, and another pointer points one
  past the last element of the array, the latter pointer compares
  greater. — If two pointers point to different non-static data members
  of the same object, or to subobjects of such members, recursively, the
  pointer to the later declared member compares greater provided the two
  members have the same access control (Clause 11) and provided their
  class is not a union.

In other cases of using pointers the operator is undefined.
",-1,22850323
22814249,"
This is quite a weird task, but it can be done.
I would say - push_back the CR[j] value to the InputVector[j], then write a custom 'less' function which compares last elements and pop_back the CR[j] values. Something like that:
But it seems you should really reconsider how you store your data - the fact that you need such logic is a warning bell.
",1,22813652
22815097,"
I think a new class or using pair would be better but if you really want to do it
This works in the small test I made, but I think it could be dangerous. 
",1,22813652
22817986,"
In the comments under your question you clarify that you'd prefer to keep the two arrays separate rather than combining them, and also that you'd like to sort CR as well as InputVector. In that case the simplest approach is to create a temporary array that zips the two arrays into one, use std::sort, then unzip back into the original two arrays.
The zipping and unzipping should not slow things down too much: these are O(n) whereas sorting is O(n log n). Moreover, assuming the bulk of your data is contained in the nested vector<int>s in  InputVector, this data can be moved to and from the temporary array using vector::swap, which as the name suggests, swaps around the underlying data rather than copying it.
",1,22813652
22814366,"
You could, but it would be prohibitively expensive. You would have to do sequential searches on CR for each member of InputVector, to get its relative sort value. It's not impossible, but very inefficient.
To make it more efficient make CR a map, or a hash-table.
",-1,22813652
236199,"
friol's approach is good when coupled with yours. First, build a vector consisting of the numbers 1…n, along with the elements from the vector dictating the sorting order:
Now you can sort this array using a custom sorter:
Now you've captured the order of rearrangement inside order (more precisely, in the first component of the items). You can now use this ordering to sort your other vectors. There's probably a very clever in-place variant running in the same time, but until someone else comes up with it, here's one variant that isn't in-place. It uses order as a look-up table for the new index of each element.
",29,22807502
238095,"
Put your values in a Boost Multi-Index container then iterate over to read the values in the order you want. You can even copy them to another vector if you want to.
",8,22807502
342940,"
Now you can use the ""indices"" vector to index into ""Values"" vector.
",8,22807502
236193,"
Only one rough solution comes to my mind: create a vector that is the sum of all other vectors (a vector of structures, like {3,Third,...},{1,First,...}) then sort this vector by the first field, and then split the structures again.
Probably there is a better solution inside Boost or using the standard library.
",4,22807502
4265862,"
You can probably define a custom ""facade"" iterator that does what you need here. It would store iterators to all your vectors or alternatively derive the iterators for all but the first vector from the offset of the first. The tricky part is what that iterator dereferences to: think of something like boost::tuple and make clever use of boost::tie. (If you wanna extend on this idea, you can build these iterator types recursively using templates but you probably never want to write down the type of that - so you either need c++0x auto or a wrapper function for sort that takes ranges)
",3,22807502
238075,"
I think what you really need (but correct me if I'm wrong) is a way to access elements of a container in some order.
Rather than rearranging my original collection, I would borrow a concept from Database design:  keep an index, ordered by a certain criterion.  This index is an extra indirection that offers great flexibility.
This way it is possible to generate multiple indices according to different members of a class.
",2,22807502
8584552,"
ltjax's answer is a great approach - which is actually implemented in boost's zip_iterator http://www.boost.org/doc/libs/1_43_0/libs/iterator/doc/zip_iterator.html
It packages together into a tuple whatever iterators you provide it. 
You can then create your own comparison function for a sort based on any combination of iterator values in your tuple. For this question, it would just be the first iterator in your tuple.
A nice feature of this approach is that it allows you to keep the memory of each individual vector contiguous (if you're using vectors and that's what you want). You also don't need to store a separate index vector of ints.
",1,22807502
26533002,"
A slightly more compact variant of xtofl's answer for if you are just looking to iterate through all your vectors based on the  of a single keys vector. Create a permutation vector and use this to index into your other vectors.
",1,22807502
27423416,"
This would have been an addendum to Konrad's answer as it an approach for a in-place variant of applying the sort order to a vector. Anyhow since the edit won't go through I will put it here
Here is a in-place variant with a slightly higher time complexity that is due to a primitive operation of checking a boolean. The additional space complexity is of a vector which can be a space efficient compiler dependent implementation. The complexity of a vector can be eliminated if the given order itself can be modified.
Here is a in-place variant with a slightly higher time complexity that is due to a primitive operation of checking a boolean. The additional space complexity is of a vector which can be a space efficient compiler dependent implementation. The complexity of a vector can be eliminated if the given order itself can be modified. This is a example of what the algorithm is doing. 
If the order is   3 0 4 1 2, the movement of the elements as indicated by the position indices would be 3--->0; 0--->1; 1--->3; 2--->4; 4--->2.
",1,22807502
35901428,"
Here is a relatively simple implementation using index mapping between the ordered and unordered names that will be used to match the ages to the ordered names:
For the sake of completeness, here are the functions populate() and print():
and:
And finally, main() becomes:
",0,22807502
44987027,"
",0,22807502
46370413,"
So many asked this question and nobody came up with a satisfactory answer. Here is a std::sort helper that enables to sort two vectors simultaneously, taking into account the values of only one vector. This solution is based on a custom RadomIt (random iterator), and operates directly on the original vector data, without temporary copies, structure rearrangement or additional indices:
C++, Sort One Vector Based On Another One
",-2,22807502
22799047,"
The easiest way would be overloading your own custom sort operator and using std::sort in #include <algorithm>:
Using it:
",0,22798958
22797018,"
I think this:
Or i messed up with your question.
",0,22796976
22776417,"
In order to sort some int number, you have several way that you can try some of which you want.
One way is when you read data in first loop, put data in right position in array in this way that use another loop and shift new data until arrive to smaller number. Then put new data in front of that. If you find equal number you can ignore new data and use break and get new data.
I think this way is best, but you have other way like:
sort all number using an algorithm like  bubble sort  or  Quick sort  then with a loop delete all duplicate numbers.
}
",0,22776180
22756839,"
There're a few issues with your code:
...should be...
Then:
...needs...
This is required to ensure strict weak ordering, which is a requirement of std::sort's and means that when a < b, !(b < a).
Similarly:
...needs...
Your string comparisons would be much cleaner if you used std::strings.  If you do stick with ASCIIZ data, it would be better to use e.g. sizeof typeSpecial instead of 50 etc..  You can improve performance and code concision by doing less comparisons and trusting strncmp to handle empty strings appropriately (which it will):
",3,22756671
22732660,"
I'm wondering why you need to do 
I have my suspicious on that part.
",1,22732590
23643430,"
then:
which seems much cleaner no?
At the cost of one std::string move, basically.
",3,23643196
23644138,"
I just discovered that the problem with the 3rd lambda was that I was not correctly comparing the elements correctly for equivalence and lexicographical comparison.  The correct approach is outlined in bullet 3) for tuple comparison where it indicates that I should use the following approach.

3) (bool)(std::get<0>(lhs) < std::get<0>(rhs)) ||
  (!(bool)(std::get<0>(rhs) < std::get<0>(lhs)) && lhstail < rhstail),
  where lhstail is lhs without its first element, and rhstail is rhs
  without its first element. For two empty tuples, returns false.

The fixed up lambda comparator for sorting firsty sorts according to the filename() temporary and then uses the efficient std::tie for the other elements in the tuple
Doing so made the first set of results identical to the 3rd - not incredibly efficient for the filename() temporary but at least I don't take the std::make_tuple hit for all elements in my struct.  The updated live example is here
",1,23643196
23640414,"
Nobody knows what this magic number 30 means in your function
and even the function itself does not know what this magic number 30 means.
If you are using standard container std::vector then it has member function size that can always report how many elements there are in the container.
In any case if you will use size() instead of 30 the code is invalid because the inner loop will access the element with the position equal to size()
for( i = toSort[pos + 1]; i < toSort[30]; ++i)
I think there should be
This condition
is also invalid because you are comparing different entities.
The function could be defined the following way
",1,23640310
23640404,"
if you have to do it in this specific way then consider using NUM_ITEMS as a range check inside your sorting function instead of taking 0 to 29.
You are accessing element 30 here directly although the vector only has 5 elements. Be sure to check for pos + 1 as this may result in errors later on.
",0,23640310
23629186,"
I assume in line
in delete_number_2() the last part of the for loop should be
",1,23628935
23600709,"
Your my_list is const. The sort() member function modifies the list in place, and cannot do that with a constant list. (Note that the return type of sort() is void.)
You should be able to:
",2,23600681
23600867,"
The reason is that your are trying to cast a const myList to a non-const type.
BTW, '#import' is not a standard C/C++ preprocessor statement.
",0,23600681
23580822,"
The operator< is overloaded for pair<int,int> so you can sort a vector of pairs just like any other vector. If you need descending order, you have two options - either sort and then call std::reverse to reverse the result or provide predicate for the sorting. 
You can also make use of std::greater:
",1,23580788
23580861,"
use this,
then pass this functor as a third parameter to sort function.
",0,23580788
23580028,"
Sort on a list can be done in O(n*log(n)) using merge sort. However there is a bigger problem - binary search can not be applied on the list precisely because of the lack of random access. 
Still please note that a list can be implemented in many different ways, including using an array as backing and in that case you will also have random access(this is not the case with std::list, though). 
The best solution to the problem is to use a std::vector and perform binary search on it(after you sort it). This way you know there is random access operator.
EDIT: as it seems the values in your container can change interactively, pre-sorting and then performing a binary search is not an option. It is so because after you insert a new value, you will have to sort the elements again. More complex version of list like skip list support that, but otherwise set should be faster by far. 
",3,23579972
23580260,"
Yes the interviewer is wrong.
Yes you should continue interviewing until you find a better firm :-)
",0,23579972
23579820,"
Your operator is likely wrong.
Try this:
",0,23579759
23547727,"
std::merge should do the trick, since S1 and S2 are sorted:
// instead of V.begin() -- thanks for the correction.
",7,23547440
23547644,"
I believe you can simplify your code by using std::copy():
",1,23547440
23547884,"
The sets are already sorted, so it does seem wasteful to re-sort it all again at the end.
How about something like this (left a couple of TODOs as an excercise for the reader!):
",1,23547440
23547692,"
You can use std::merge(): http://en.cppreference.com/w/cpp/algorithm/merge
Its implementation is similar to yours.
",0,23547440
23546659,"
You have a local definition of the array in your getdata() function:
It stays local there and has nothing to do with the array you declared in main:
You have to write your function such it takes these as parameters:
and in main call
UPDATE: 
The condition in the inner for loop of your sort() function also looks pretty wrong, you probably meant j there not i:
",1,23546422
23546681,"
Always use std::vector if you have no definite advantage by using an array (and, in C++11, use std::array if s is known by compile time).
",0,23546422
23540481,"
You cannot update the priority like that. The priority_queue assumes that objects do not suddenly change their value / order. To update a value in the priority_queue you need to remove it from the queue, change it and then insert it again.
",3,23540353
23542657,"
This feature is currently under consideration. Please see the issue report  on the project page for more details.
",0,23540336
23529834,"

You can do without the repeated this-> 99% of the time
You can just invoke operators, instead of invoking them as functions
You can just use std::sort from <algorithm>

Imagining some of the code you didn't show:
DISCLAIMER This seems a very non-c++ way to design classes. Algorithms and containers are traditionally separated, for good reason. The exception being that member functions sometimes perform operations in more optimal ways (e.g. std::set<>::find instead of std::find)
",1,23529732
23531428,"
It should be std::sort(aptr, aptr + arraySize);.  Also you should check arraySize > 0 before doing this, if you're intending to catch errors like that instead of having undefined behaviour.
begin and end aren't magic; they rely on the object either being an array (not a pointer), or the object implementing functions .begin() and .end() that return iterators.
You could even define those functions yourself, e.g. SimpleVector<T>::begin() { return aptr; } etc. , but maybe this is not a good idea as it bypasses your bounds-checking. You'd have to actually write an iterator class instead of returning a pointer, which is more trouble than you're ready for :)
NB. Everywhere you write this->operator[](foo), it would be clearer to write (*this)[foo]
",0,23529732
23507476,"
You should be using delete [] Left and delete [] Right to match the new [] calls.
Also you call to mergeSort(Right,mid); should be mergeSort(Right,mid2); but I don't think that would cause a crash, just a non-sorted item when n was odd.
",1,23507367
23522964,"
With uint16_t, you're going to get a lot of duplicates in such a large array: 195 occurrences of each of 0 though 65535, in expectation. Without a three-way (""fat"") partition, or at least one that returns the middle of the repeated occurrences of the pivot value in the subarray it's processing, that causes quicksort to go quadratic. (Try a pencil-and-paper execution of a naive quicksort on an array of only zeros to see the effect.)
",6,23501734
23496080,"
It looks like a stack overflow.
Try not to use automatic variables for such large objects:
",3,23496023
23496383,"
Your array is a local variable, so it is created on the stack. There is usually a limit on stack size. On Linux, it can usually be viewed and modified by ulimit command. (On Windows, a stack limit for a C++ executable is determined at compile time, and it can be altered by compiler options or pragmas.)
One instance of your pair is 8+4=12 bytes in size. The default stack limit is usually 8 mebibytes. Perhaps 12 bytes are padded to 16 bytes due to alignment settings of your compiler. So, 219 * 16 = 223 bytes, which is the very same 8 mebibytes.
",3,23496023
23491766,"


You are sorting data, not pairs. That said, your new approach is still undefined behaviour, and thus not guaranteed to work1. You are essentially trying to fit a square peg into a round hole. If you want to use std::sort, present valid data – which means copying in your case, or writing a custom iterator which treats an array as a collection of consecutive pairs.

1 That’s a humungous understatement. – Do not do this.
",1,23491645
23492286,"
Exchanging your array of two int for a std::pair<int,int> did the trick for me (live at ideone):
An alternative would be encapsulating the array of two int inside a struct. The problem in your code is that std::sort need an array of comparable (you fixed it with your compare function) and copy-or-move-assignable items (arrays are neither)
Maybe even better (less changes to your code) would be using std::array:
",-1,23491645
23483841,"
Instead of computing the next gap value by doing gap /= 2 you should be iterating over the Ciura sequence and using each value in turn as the gap. So instead of doing:
Try something like:
",0,23483640
23455352,"
Works fine for:

gcc: http://rextester.com/IRO3912
clang: http://rextester.com/FKW33178
vc++: http://rextester.com/GNTFT92594

Compilers versions: http://rextester.com/
Bost versions:

1.55.0 for vc++
1.54.0 for clang
1.54.0 for gcc

",1,23455253
23453943,"
From the comment it seems the problem was a missing assignment of SignalDB in the assignment operator. This missing assignment would easily explain why neither sorting algorithm would actually sort the values: there is some random value there which keeps changing for the values.
Incidentally it also explains why std::sort() crashes while std::merge_sort() doesn't although there is certainly no guarantee that std::merge_sort() won't crash: the sorting criteria has to be a Strict Weak Order and the values being sorted have to be copyable. If these constraints don't hold, the behavior of either algorithm is undefined. The copyable constraint states that the copy of a value can't be distinguished from the original and can be used entirely interchangeably. If the value being compared on isn't really copied that isn't is the case.
The difference in crashing vs. non-crashing is based on how the sorting is actually implemented. Note that neither sort is guaranteed to crash as the behavior is undefined in either case. However, std::stable_sort() uses an algorithm which is more likely to just produce wrong results than to crash. To minimize the operations done in an inner loop of std::sort() a sentinel is used at the beginning of the sequence: in a strategic fashion it is made sure that a small enough element ends up in the right location of the sequence. This way the inner loop only needs to compare the values rather than also verifying if the value is still in the range: due to the sentinel a search used in the inner loop it will never try to move off the sequence. However, if that smallest element gets a more or less random value being ordered on it may turn out not to be the smallest element at all and the ""sentinel"" isn't really one, having the search wander off into looking at fields it isn't meant to look at.
For a more detailed explanation you might want to watch the last two videos of Stepanov's lectures on Efficient Programming with Components (although the lectures are kind of extremely slow, I think there is actually value in watching all of them). I think the specific issue is discussed in the second to last video but I don't recall exactly. The discussion is focused on the ordering not being a strict weak order but the effect is the same if the copy isn't really a copy.
",0,23453036
23438428,"
The fourth customer is going to be in myVector[3]. A vector of size n goes from 0 to n-1.
Note that *i == myVector[i-myVector.begin()] and *myVector.begin() == myVector[0], so you are effectively calculating the index of the customer, with that equation.
",0,23438331
23427163,"
It's obvious why the ordering is incorrect. Your operator < is wrong, it should return true as soon as one element is less than the other.
As for the data corruption, it's because you violated the ""rule of three"" - you have a custom destructor but not a copy constructor or assignment operator. sort makes copies of elements that it sorts, and when the destructor hits it deletes the pointer it was holding. This results in undefined behavior.
Edit: the reason the code works with a fixed array but not a pointer is that the default copy constructor and assignment operators will make a full copy - when the original gets destroyed, it doesn't mess up the copies or invalidate their memory.
Your ""fix"" may appear to work, but now you've got a memory leak. Nobody is ever going to delete those pointers.
One other point about operator <, it should never return true with A=B; if(A<B) but yours does.
",2,23426955
23401153,"
One way to approach this is to keep both the input string and the original ordinal position together in an object.  Then sort based on solely the string portion of the object and then emit both strings and original ordinal position for each object.  
For example for your class you could have this:
Then all you need is to create and push the objects and to define a comparison operation for use with std::sort.  See this reference for details and an example of how to do that part.
Here's one way to do that:
When compiled (as C++11), from this input file which I called fruit.txt:
Using the file ./sorted fruit.txt gives this result:
",1,23400964
23401158,"
I'm not sure that I understand what you exactly want. But I guess you need to know the chronological position for every element in the sorted vector.
If your question is that, the answer is too easy. you can just make a new int victor that has the same length of your victor (10 for example) and contain list of numbers from 1 to the 10. When you sort your victor you have to make changes on your victor. Now just do the same changes on the numbers victor, so you can know the time of each element.
example:
big, car, app
  1,  2,   3
when you sort them they will be like that:
app, big, car
 3,   1,   2
but in this way u cant use this function to sort u must write it by yourself.
",3,23400964
23401878,"
If your compiler supports lambda functions, you can use one for the compare:
",0,23400964
23403593,"
If your compiler doesn't support lambda functions, you can sort a vector of iterators to a vector of strings:
",0,23400964
23391134,"
Look the following piece of code:
",3,23390882
23391150,"
The question is really why you want to sort this after it became a vector of strings and not before that. 
The simplest way to sort a vector of strings holding ints might be to convert it to ints, sort that and then convert back to strings into the first vector... which in your case could be more efficient if you did not convert to strings in the first place.
Regarding the suggestion to convert to int on the fly inside the comparator, that is going to be expensive. Comparing int is trivial compared with the process of conversion from string to int. Sorting is O(N log N) (expected) number of comparisons, if you convert on the fly you will be doing O(N log N) conversions, if you convert once you will do O(N) conversions and O(N log N) trivial int compares.
You can also handcraft an algorithm to do the comparison. If you can assume that all values are positive and there are no leading zeros, a number, represented as a string, is larger than any other number represented as a string with a shorter length. You could use that to build a comparisson function:
If there can be leading zeros, it is simple to find how many leading zeroes and adjust the size accordingly inside the comparator. If the numbers can be negative you can further extend the comparator to detect the sign and then apply something similar to the comparisson above.
",2,23390882
23394005,"
Can you use a standard map instead?
You could also write a variant of 40two's example.  Instead of stoi, you can just make your own predicate to compare the characters.  If lhs has fewer digits than rhs, lhs must be a smaller number (assuming no floating point); if same number of digits than compare the strings (i.e., what David Rodriguez showed you in his answer).  I didn't notice that he had already suggested that when I wrote my answer.  The only additional thing that I am adding is really the suggestion of using another container (i.e., std::map).
",0,23390882
23363698,"
Declare sortByIndex static, because you cannot pass non-static member function to std::sort.
",3,23363588
23354364,"
A few problems to look at

You don't initialize size before using it, so your pq memory could be any size at all.
You are using 1-based access to your arrays, so make sure you allocate one more than you need.
while(!back==0) will work, but it is doing boolean logic on an int, then comparing the result with an int. while(back!=0) is a lot easier to read and will produce fewer compiler warnings.

Edit: also your bubbleDown function has an infinite loop when neither if test is triggered.
",0,23353961
23333502,"
You are assigning a string to an int. Make the type of minValue as string. Then it should work.
",1,23333220
32263961,"
c++ and stl makes selection sort much simpler and elegant (strings or integer whatever)
incase you are not using c++14, simply change the auto to the vector iterator.
",0,23333220
53422990,"
This might help:
",0,23333220
23330856,"
std::sort and std::unique both need to compare items to do their jobs. They have somewhat different requirements though: std::unique compares for equality and std::sort compares for ordering. One obvious possibility for your case would be code on this general order:
[Note: these would be member functions of your Vertex class.]
It's possible to implement the required functionality in other ways, especially if (for example) you might want to sort objects based on one field sometimes, and by another field at other times (e.g., sort by number and sort by name, in the case of your Vertex class).
You can do that by passing a third parameter to sort and/or unique to tell it what to use to do the comparison. At least in current C++, if I'm going to do this, I generally use a lambda expression to specify the comparison:
This puts the comparison code right next to the sort, so it's easy to see how you're doing the sorting. You can use a separate function or function object instead, but doing so means you need to be careful with the name to ensure it describes the sort order:
",0,23330736
23330826,"

The compiler has no idea which Vertex is placed before another Vertex when it needs to be sorted.  You need to tell the compiler this information.  Therefore use the 3 argument std::sort() function, or write an overloaded operator < for your Vertex class.
The compiler has no idea what makes a Vertex equal to another Vertex.  You need to tell the compiler this information.  Therefore use the 3 argument std::unique() function, or write an overloaded operator == for your Vertex class.
Pass objects such as vector by reference, not by value:
void removeDup(vector<Graph::Vertex>& v)

Note the &.
",0,23330736
23330840,"
Two recognize unique objects, you need to be able to test for equality (after all, how else would you recognize to objects that are the same).
Assume two objects a and b. The canonical way to test for equality is a == b. If you operate on ints the compiler knows how to deal with this expression (e.g. emit a CMP instruction).
However, since you defined Vertex yourself, the compiler must be told how to consider two Verteces to be equal. The easiest way to define arithmetic operators is like this:
Just a heads up: When defining == you may wish to also define != to be consistent. You also may wish to define all the <, <=, >, >= so that comparision is possible...
",0,23330736
23330862,"
The compiler does not know how to compare one vertex object with another when it tries to sort. you can do it by overloading < operator in your Vertex class. This operator will be used to compare tow vertices and place one before another. and you need to overload operator == to be used in unique, since it will use operator == to check if one vertex is equal to another and hence find duplicates.
",0,23330736
23313728,"
After successfully opening the file, you need to add a loop doing:
Regarding sorting, I believe you are expected to move the nodes in the list (instead of copying values between the nodes - the way its done in array) to make the list sorted.
",0,23313548
23305814,"
stable_sort doesn't know how to sort your struct because there is no comparison operator defined for it. You either need to make points a class and override the < operator, or provide stable_sort with a comparison function, eg.
",3,23305726
23305786,"
Well, how do you want to order your points? How do you know if a point should come before another point when sorted? Do you order by x coordinate, or what? You need to tell the compiler this!
In other words, you need to provide an operator<.
",1,23305726
23304423,"
You will want to make sure c is big enough, or grows:
Alternatively:
See it Live On Coliru
",3,23304400
23284237,"
while(!fin.eof() is a blunder. What happens after the last value has been read, but before eof() occurs?  (answer: You'll get the last entry copied twice). Fix it by going:
Also, you should be displaying and sorting with position as the counter, not array_size.
Maybe your sortBubble function has a bug, or maybe it is just taking a long time to run. What happens if you try with 100 numbers? Can you post the code for it?
",1,23284197
23281029,"
Sometimes forward declarations are necessary. You can make do with just the forward declaration of UList if you put operator<< and sort above the definition of UList. I'm not sure why sort is in a different header file anyway. If you wish to keep your code organized the way it is, the forward declarations are necessary.
",0,23280716
23263616,"
In Propertiestab there is a Sort property. Set it's value to False.
Edit:

As @The Forest And The Trees already mentioned, you could achieve same result from code:

listBox.ModifyStyle(LBS_SORT);
",8,23263506
23261119,"
Since you've made a fair fist of the first two parts of the question, viz implementing the stats and the bubble sort, here is some help with the third:

Move the sorting and stats into 1 or 2 classes. I've been lazy and implemented just one, although more correctly, the concerns of sorting and determining the basic stats could be separated into 2 classes (SRP of SOLID).
Move your data into fields of the class, and expose these as properties via get / set methods.
Expose functionality such as sorting as methods
In general, use the STL template classes for storing collections, such as vector
As per the suggested Wiki article, there are optimisations for the bubble sort.

Other minor points

Initialize your aggregates (sum, avg, min, max) as soon as possible, not in a branch in a loop.
Try not to hard code constants, such as the size of the array, and especially don't repeat the constant in more than one place - this makes the code fragile to change. With the vector, the size is an inherent property of the collection.
The average can't be an int


",1,23259677
23240230,"
Well, you didn't overload the operator= for Dynamic, so the compiler implicitly defines one which would do bitwise copy. stable_sort() in your library calls the operator=, so tab in two Dynamic objects points to the same address, as a result, double delete on destruction. Overloading the operator= would resolve the problem:
",0,23238958
23238678,"
You are passing a copy of the vector to bricksort. Try changing the function signature to: void bricksort(vector <int> &a) to pass a reference instead.
",6,23238663
23238711,"
Try passing a reference of vector<int> to the function instead:
",3,23238663
23235823,"
This should work fine.
Note: don't forget to
",3,23235752
23220661,"
If std::sort is implemented as Quick sort, there is the case, that you compare the current element to the pivot element. I don't have my Sedgewick Algorithms at hand, but I think avoiding this comparison does not speed the algorithm up (or the comparison does no harm to the algorithms complexity). I can look the exact quote up, if you like.
",1,23220119
23217984,"
See this duplicate , you basically iterate the map and use std::partial_sort on the values.
",0,23217562
23217679,"
You basically need to implement some top-k filtering algorithm using the comparator
Choosing the top k out of a list efficiently is covered in the thread Store the largest 5000 numbers from a stream of numbers:
The basic idea is to create a min heap which always stored the top k elements encountered so far. When you are done, the heap contains the top K elements in the stream.
An alternative is using selection algorithm to find the 10th biggest element, and produce all the elements greater than it (a bit more work if there are duplicates).
",1,23217562
23215351,"
Having the data in a binary tree sorted by data is just like having it in an array with no specific order with respect to queries based on count. Thus you can not do anything better than linear for a single query. If you plan to perform the query multiple times it may be worth it to have an alternative structure ordered by counter. If all you need to support is query for top 10 a binary heap will do just great. If you plan to only perform a few queries you can not improve the performance too much. 
",1,23214830
23229397,"
The reason why you are observing all 0's is that you are generating a large number of random numbers, i.e., 32 << 20 = 33554432, between 0 and RAND_MAX, you are orderning them, but you are displaying only 32 of them. 
As mentioned by Robert Crovella, on a Windows machine (the OP is working on Windows), RAND_MAX = 2^15-1 = 32767. Accordingly, you are generating 33554432 integers between 0 and 32767, which means that you will have a large number of 0's in the original array and so all 0's in the first 32 numbers of the sorted array.
I have personally verifyed that this occurs for both, Windows 32 and 64 bit machines, that is, on both Windows 32 and 64 bit systems RAND_MAX = 32767.
Again, as pointed out by Robert, this effect will show on Linux 32 bit machines, but not on Linux 64 bit machines, for which RAND_MAX = 2^31-1 since, for that case, RAND_MAX is much larger than 32 << 20.
As suggested by Robert, one may change the instruction
to
to avoid the all 0's show.
",2,23211509
23210206,"
There are 2 main ideas I can see for percentage sorted:

Simply the number of elements out of place.
Once should be able to get an estimated % sorted by sorting it, then iterating through it, and, keeping each element the same with the desired percentage as probability, otherwise swapping it with a random remaining element (so, if we want 30% sorted, we'll keep an element the same with 30% probability, and swap it with 70%).
If an exact number is needed, one could use the above result and (intelligently) swap random elements until the desired percentage is obtained.
The number of inversions.

An inversion is a pair of places of a sequence where the elements on these places are out of their natural order.

One idea is to first sort it, then to swap random elements that get us closer to the desired percentage sorted, until we get there.
Only swapping elements that get us closer to the desired result is difficult (at least doing so efficiently).

A very brute force approach would be to count the change in the number of inversions that each pair of swaps would cause, and then pick a random one that gets us closer to our target.
Another idea is to just generate random pairs and count the number of inversions until we find one that gets us closer.
A third option is to pick a random element. If it's larger than half the elements, try to move it left (ideally increasing the number of inversions). If it's smaller, try to move it right. In trying to move it left/right, we can look for a smaller / larger element (respectively) to swap it with and count the change in inversions (we only need to consider the elements between the swapped elements when counting the change in inversions).

At first we could probably just randomly swap elements as we're likely to tend to more inversions.
If the percentage is above 50%, we could also start with a reversed array, i.e. 100% unsorted.

",1,23209769
23210704,"
There's a one-to-one correspondence that maps permutations to {0} x {0, 1} x {0, 1, 2} x ... x {0, 1, ... n - 1}, where the jth element of the tuple in the codomain is the number of inversions involving elements at positions j and i < j. In this light, the problem is sampling a random element of the codomain that sums to the desired number of inversions.
Here's an instance of Gibbs sampling for this problem. Initialize a tuple summing to the desired number of permutations. Repeatedly select two distinct indices and randomize uniformly among all possibilities with the same sum. Stop when you're tired of waiting (the distribution converges on uniform but never gets there; maybe tomorrow I will figure out a Propp--Wilson style technique for exact samples).
In Python (untested):
One could also get exact samples by dynamic programming and conditional probability, but the running time for 500 looks slightly prohibitive from here.
",0,23209769
23202152,"
You would basically need a two-d vector of integeres in here, and then you could use std::sort on it with a custom comparator.
You could also write the last line simple just like this:
The reason for that is the operator< already exitsts for comparing vectors.

Operations <, >, <= and >= behave as if using algorithm lexicographical_compare, which compares the elements sequentially using operator< reflexively, stopping at the first mismatch.

Disclaimer: it is completely untested and only proof of concept code.
",2,23202063
23202334,"
An easy way to define a proper comparison function is to use a compare function that return either negative, zero or positive. E.g. std::string::compare is one such.
Another way is to use std::lexicographic_compare.
E.g.,
",2,23202063
23197180,"
If your assignment allows you to use standard algorithms, then it's simply
followed by a loop to print them.
If the object of the exercise is to write your own sorting algorithm, then you should research them yourself.
",0,23197139
23197746,"
Firstly, you should run your for (int i = 0; i < 10; i++) instead of for (int i = 0; i <= 10; i++), because the array has 0-9 indexes, rather than 0-10. Secondly, the syntax for cin foo[] is cin >> foo[i]; in this case.
For the sort, you could look into std::sort, or you could look into some sorts yourself, I would recommend starting with bubble sort, selection sort or insertion sort, as they are the easiest ones to implement.
",0,23197139
24386004,"
std::sort uses a sort with O(n*log(n)) complexity. It can be for example (an optimized version of) quicksort. It selects a pivot, moves the smaller elements before the pivot, the bigger elements after the pivot and repeats it recursively on the first and second half.
That also mean that std::sort is allowed to (and to be fast it needs to) move the elements of the vector multiple times during the sort. The comparison function will see them at their current location.
The odd out-of-vector addresses show that std::sort moves elements during sorting to the stack as well. To be specific: (g++ 4.8.2) for example __unguarded_linear_insert in bits/std_algo.h moves its argument to the stack.

The original positions of the elements are lost during the sort. You have to use std::pair or some other method to store the original positions if you want to use them.

From Angew's answer: Also an important note that your comparator is not consistent. This is undefined behaviour and can give segfaults with different input.
",5,24385827
24386029,"
First off, you have undefined behaviour because the predicate you're passing to std::sort is not internally consistent - it's possible it will report a < b and b < a at the same time.
Even without that, the purpose of std::sort is to sort the range - exchange elements within it so that they're in the correct order (according to the predicate). So of course the elements will move around the range.
",4,24385827
24386156,"
It prints out different adresses, because some of the elements are stored in temporary variables, on the stack, while others being moved.
The ""smaller"" memory addresses usually correspond to values in the file's images (function addresses, global variables, etc.) while the highers are usually heap or stack allocated addresses. 0x7fff******** is usually on the stack in 64 bit programs, but it's just from my personal experience in debugging, and not set in stone.
",3,24385827
24341650,"
Construct simply digital tree (Trie) 
Memory will be much less than input data, because many words will be have common prefix. While adding data to tree u mark (incrementation)  last child as end of word. If u add all words then u doing a  DFS  (with priority as u want sorting ex a->z ) and you output data to file. Time-complexity is exactly the same as memory size. It is hard to say about how is complexity because it depends on strings (many short strings better complexity) but it is still much better than input data O(n*k) where n-count of strings; k-the average length of string. Im sorry for my English.
PS. For solve problem with memorysize u can part file to smallest parts, sorting them with my method, and if u will be have for ex (1000 files) u will be remember in each first word  (like queues) and next u will be output right word and input next in very short time. 
",3,24340521
24340714,"
You usually sort huge external data by chunking it into smaller pieces, operating on them and eventually merging them back. When choosing the sorting algorithm you usually take a look at your requirements:

If you need a time-complexity guarantee that is also stable you can go for a mergesort (O(nlogn) guaranteed) although it requires an additional O(n) space.
If severely memory-bound you might want to try Smoothsort (constant memory, time O(nlogn))

Otherwise you might want to take a look at the research stuff in the gpgpu accelerators field like GPUTeraSort.
Google servers usually have this sort of problems.
",5,24340521
24358393,"
I suggest you use the Unix ""sort"" command that can easily handle such files.
See How could the UNIX sort command sort a very large file? .
Before disk drives even existed, people wrote programs to sort lists that were far too large to hold in main memory.
Such programs are known as external sorting algorithms.
My understanding is that the Unix ""sort"" command uses the merge sort algorithm.
Perhaps the simplest version of the external sorting merge sort algorithm works like this (quoting from Wikipedia: merge sort):
Name four tape drives as A, B, C, D, with the original data on A:

Merge pairs of records from A; writing two-record sublists alternately to C and D.
Merge two-record sublists from C and D into four-record sublists; writing these alternately to A and B.
Merge four-record sublists from A and B into eight-record sublists; writing these alternately to C and D
Repeat until you have one list containing all the data, sorted --- in log2(n) passes.

Practical implementations typically have many tweaks:

Almost every practical implementation takes advantage of available RAM by reading many items into RAM at once, using some in-RAM sorting algorithm, rather than reading only one item at a time.
some implementations are able to sort lists even when some or every item in the list is too large to hold in the available RAM.
polyphase merge sort
As suggested by Kaslai, rather than only 4 intermediate files, it is usually quicker to use 26 or more intermediate files. However, as the external sorting article points out, if you divide up the data into too many intermediate files, the program spends a lot of time waiting for disk seeks; too many intermediate files make it run slower.
As Kaslai commented, using larger RAM buffers for each intermediate file can significantly decrease the sort time -- doubling the size of each buffer halves the number of seeks. Ideally each buffer should be sized so the seek time is a relatively small part of the total time to fill that buffer. Then the number of intermediate files should be picked so the total size of all those RAM buffers put together comes close to but does not exceed available RAM. (If you have very short seek times, as with a SSD, the optimal arrangement ends up with many small buffers and many intermediate files. If you have very long seek times, as with tape drives, the optimal arrangement ends up with a few large buffers and few intermediate files. Rotating disk drives are intermediate).
etc. -- See the Knuth book ""The Art of Computer Programming, Vol. 3: Sorting and Searching"" for details.

",1,24340521
24351556,"
Use as much memory as you can and chunk your data. Read one chunk at a time into memory.
Step 1) Sort entries inside chunks 
For each chunk:

Use IntroSort to sort your chunk. But to avoid copying your strings around and having to deal with variable sized strings and memory allocations (at this point it will be interesting and relevant if you actually have fixed or max size strings or not), preallocate a standard std array or other fitting container with pointers to your strings that point to a memory region inside the current data chunk. => So your IntroSort swaps the pointers to your strings, instead of swapping actual strings. 
Loop over each entry in your sort-array and write the resulting (ordered) strings back to a corresponding sorted strings file for this chunk

Step 2) Merge all strings from sorted chunks into resulting sorted strings file

Allocate a ""sliding"" window memory region for all sorted strings files at once. To give an example: If you have 4 sorted strings files, allocate 4 * 256MB (or whatever fits, the larger the less (sequential) disk IO reads required).
Fill each window by reading the strings into it (so, read as much strings at once as your window can store).
Use MergeSort to compare any of your chunks, using a comparator to your window (e.g. stringInsideHunkA = getStringFromWindow(1, pointerToCurrentWindow1String) - pointerToCurrentWindow1String is a reference that the function advances to the next string). Note that if the string pointer to your window is beyond the window size (or the last record didn't fit to the window read the next memory region of that chunk into the window.
Use mapped IO (or buffered writer) and write the resulting strings into a giant sorted strings final

I think this could be an IO efficient way. But I've never implemented such thing.
However, in regards to your file size and yet unknown to me ""non-functional"" requirements, I suggest you to also consider benchmarking a batch-import using LevelDB [1]. It's actually very fast, minimizes disk IO, and even compresses your resulting strings file to about half the size without impact on speed. 
[1] http://leveldb.googlecode.com/svn/trunk/doc/benchmark.html
",0,24340521
24352215,"
Here is a general algorithm that will be able to do what you want with just a few gigs of memory. You could get away with much less, but the more you have, the less disk overhead you have to deal with. This assumes that all of the strings are in a single file, however could be applied to a multiple file setup.
1: Create some files to store loosely sorted strings in. For terabytes of data, you'd probably want 676 of them. One for strings starting in ""aa"", one for ""ab"", and so on until you get to ""zy"" and ""zz"".
2: For each file you created, create a corresponding buffer in memory. A std::vector<std::string> perhaps.
3: Determine a buffer size that you want to work with. This should not exceed much beyond 1/2 of your available physical memory.
4: Load as many strings as you can into this buffer. 
5: Truncate the file so that the strings in your buffer are no longer on disk. This step can be delayed for later or omitted entirely if you have the disk space to work with or the data is too sensitive to lose in the case of process failure. If truncating, make sure you load your strings from the end of the file, so that the truncation is almost a NOP.
6: Iterate over the strings and store them in their corresponding buffer.
7: Flush all of the buffers to their corresponding files. Clear all the buffers.
8: Go to step 4 and repeat until you have exhausted your source of strings.
9: Read each file to memory and sort it with whatever algorithm you fancy. On the off chance you end up with a file that is larger than your available physical memory, use a similar process from above to split it into smaller files.
10: Overwrite the unsorted file with this new sorted file, or append it to a monolithic file.
If you keep the individual files rather than a monolithic file, you can make insertions and deletions relatively quickly. You would only have to load in, insert, and sort the value into a single file that can be read entirely into memory. Now and then you might have to split a file into smaller files, however this merely amounts to looking around the middle of the file for a good place to split it and then just moving everything after that point to another file.
Good luck with your project.
",-1,24340521
24309390,"
Answer (imho): use a different datastructure. What you are trying to do is setup a multimap. Oh hey look:
http://www.cplusplus.com/reference/map/multimap/
stl::multimap - how do i get groups of data?
It'll be faster for large numbers of elements. And is actually a map rather than a vector of vector of double.
Either that, or skip the sorting all together, and count by key using std::map, std::unordered_map, or (if you know the number of keys and/or the keys are offset by 1 with no breaks) std::vector.
To expand, sorting your list to get means will be slow. Sorting (using std::sort) is O(nlogn), and will be O(nlogn) every time you compute this mean. And it is an unessisary step: your stuff is grouped by key reguardless of order. std::map and std::multimap will ""sort as you go"" which will be just a little faster than sorting every time, but you won't have to sort the whole thing to get the list. Then you can just iterate the multimap to get the mean, O(n) each mean calculation. (It is still O(nlg(n)) to add all the elements to the multimap)
But if you know the key output is going to be 1,2,3...n-1,n, than sorting is a complete waste of time. Just make a counter for each key (since you know what the keys can be) and add to the key while iterating the array.
BUT WAIT THERE IS MORE
If the keys are actually setup the way you are thinking, than the best way from the get go is to forget the table structure, and make build it like this:
Count is now constant time for each row. Mean for each row is O(n). Getting a list is constant time for each row. EVERYBODY WINS.
",2,24309171
24309297,"
You need to create a comparator function comparing vector<double>:
Then you can use std::sort on your structure with the new comparator function:
If you are using c++11 features you can also utilize lambda functions here:
",2,24309171
24309240,"
You need to write your own comparator functor to pass into your vector declaration:
",1,24309171
24309281,"
Have you tried just this?:
That should work as std::vector has operator< which provides lexicographical sorting, which is (a little more specific than) what you want.
",0,24309171
24304121,"
Change this statement
to
However it would be better to use standard algorithm std::sort  declared in header <algorithm>. For example
Or you could use std::stable_sort
Also consider the posiibility to compare objects of type Entry as objects of type std::pair. In this case objects with equal sth will be sorted according to id. For example
",3,24303917
24304719,"
Ok, I'm making my comment as an answer.
First, looking on the documentation of qsort.
First parameter ptr - pointer to the array to sort.
So if you really want to use qsort with a vector (it's very strange, std::sort is there) the answer to your question is the answer to question ""How to conver a vector to a raw array?"".
You need to use a small hack - &entries[0] - pointer to first element of a vector. It's works, because elements in a vector, regarding to the standard, have contiguous memory location and this is the same as with raw array.
In new standard there is data() function member for the vector. You can use this member-function
",3,24303917
24304057,"
You're passing in &entries to qsort it should be:
",2,24303917
24304038,"
A) use std::sort() with entries.begin() and entries.end()  -> faster
OR 
B) use qsort() with  &entries.front() instead of &entries -> slower
",1,24303917
24295345,"
Problem solved! I was checking some code from: 
https://groups.google.com/forum/#!msg/thrust-users/GqufHKoaizc/qx9cv-6xCg4J
and I noticed that they were copy the values of the tiled_range into another vector, after copying this new vector and put it in the sort_by_keys, it was sorting the keys and values perfectly. I still do not understand why by putting the iterator of the tiled_range as input for the sort_by_keys it was causing such mess above...
Here is the code:
",2,24293538
24290755,"
f.begin()+1 is out of bounds and that is the reason for the segmentation fault.
Use f.begin() for the beginning of the array.And that will be safe to use.
",1,24290711
24290871,"
std::sort expects the [begin, end) to be a valid range such that if you keep incrementing begin you would eventually reach the end. In your case, begin()+1 is past the end(), so std::sort has no way of knowing that it is looking past the end of the range.
std::sort takes iterators, not pointers. It is because of this that it is unable to run a begin < end check: this would fail if you passed rbegin() and rend() for the two iterators.
If you would like to sort a portion of the std::vector that excludes the initial element, you need to make sure that the container is not empty. Otherwise, begin()+1 would produce an invalid iterator.
Note: although technically the undefined behavior takes place when you do begin()+1 on an empty container, the crash in your case is nearly certainly coming from a dereference inside std::sort. Also note that if you have a C++11-compliant compiler, using std::next(v.begin(), 1) is preferable to v.begin() + 1.
",3,24290711
24290895,"
Increment on input iterators has a precondition that the iterator must be dereferenceable. With an empty vector, v.begin() is not dereferenceable so attempting to do v.begin() + 1 (which in turn is defined in terms of increment) is undefined behavior.
Moreover, std::sort(begin, end) requires [begin, end) to be a valid range, and the standard says  that (§24.2.1 [iterator.requirements.general]/p7)

Range [i,j) is valid if and only if j is reachable from i. The result of the application of functions in the library to invalid ranges is undefined.

For most random access iterators (the only type of iterators for which < and > are defined), if a > b then a is not reachable from b, and so [a, b) does not denote the empty range - it doesn't denote a valid range at all.
",2,24290711
24286884,"
Consider the values
Here,
However,
Thus your comparator does not impose a strict weak ordering, and behavior is undefined if you use it with std::sort or in any other role where a strict weak ordering is required.
A comparator that is strict weak and is a refinement of your comparator would be:
",6,24286209
24263489,"
Just use the std::sort algorithm. The only subtlety is that it sorts in descending order, so you need to change the sorting criteria. Two ways to do this spring to mind.
Use a custom comparison functor, e.g. std::greater:
Use reverse iterators:
The former version makes the intent clearer, whereas the latter may require some head scratching and documentation reading. But the result is the same for both.
Here's a working example:
Output:
",6,24263472
36040008,"
The biggest problem here is that your operator< is wrong. You're sorting descending not ascending, so all your other code won't work right. So first you need to fix operator< to return sequenceNumber < rhs.sequenceNumber;.
Next you need to decide if your function removes elements smaller than the one requested (from the comment) or smaller than/equal to (actual code).
Then for bonus points you can use lower_bound to find the end element to iterator over, instead of getting begin and erasing it over and over again.
",0,24260713
24236922,"
If the number of elements you are inserting is lower than the table size, that is, there are no collisions, depending on you hash function, the position calculated by his function my be related to the value itself and thus for this set of elements you have an ordered map.
For example, consider the hash function to be x mod 10. You insert 3 elements: 1,4,5. 
Their hashes will be: 1,4,5 and that will be their positions in the table.
However, if you insert another element colliding with the previous inserted data the order will change. In the example, if you insert 11: 11 mod 10 = 1, suppose the collision is solved looking for the first free position in the table, the resulting order will be: 1,11,4,5
",2,24236866
24236911,"
From the documentation: http://www.cplusplus.com/reference/unordered_map/unordered_map/

Internally, the elements in the unordered_map are not sorted in any particular order with respect to either their key or mapped values, but organized into buckets depending on their hash values to allow for fast access to individual elements directly by their key values (with a constant average time complexity on average).

Since the organization of elements relies on hash values, the order of iteration isn't necessarily affected by the order in which the elements are added.  In other words, the fact that elements read from the map aren't sorted is expected behavior.
Java offers a very handy container called a LinkedHashMap, that persevers insertion order when iterating over the collection.  Unfortunately, C++ standard libraries don't offer a built-in container for this.  The most promising thing I've seen so far is the boost::multi_index_container, but it doesn't seem trivial to setup and use.  Feel free to explore the documentation here: http://www.boost.org/doc/libs/1_42_0/libs/multi_index/doc/index.html
",2,24236866
24232092,"
It looks like myFunction in your example is member class function. It has to be static then to be a right predicate to the std::sort algorithm. Alternatively you can make this function a free outstanding function.
Or you can make a functor
and pass an instance of this to the algorithm:
",0,24232047
24284584,"
Besides @bits_international answer you can also do it like that in C++11
I hope it helped.
",0,24232047
24219564,"
I did not look through all your code but it will be enough to point out that function sort_count is invalid. Its parameter is adjusted to int * So the calculation of len_arr has no sense
In fact the shown statement is equivalent to
You should either define the function as a template function that has a parameter of type of a reference to an array or as a non-template function having two parameters. The second parameter will specify the size of the array.
The same is valid for function merge_count_inverse
The calculations of len_left and len_right have no sense because left and right are not arrays. They are pointers int *
",0,24219475
24199633,"
To answer to your first question, yes, that's pretty much how it works. One can note that this approach can be extended into a multi-level hierarchical structure. But practical implementations usually stick to two-level structure, exactly as shown in your picture.
For your second question, if you  are taking about std::sort, then std::sort works without any knowledge about the mechanics of the actual container. If works on a range of random-access iterators. Since std::deque's iterators are random-access iterators, std::sort can be applied to std::deque. And one can actually argue that random access to elements of such data structure is rather efficient. It is not as efficient as random access in a vector, but it is still pretty efficient to make sense in the context of std::sort.
You cannot use std::sort with std::list because std::list's iterators are not random access iterators. If you wish, you can implement your own trivial (slow) version of random-access iterator for std::list. You will be able to apply std::sort to a range of such iterators and thus sort an std::list with std::sort. But for obvious reasons it will be prohibitively inefficient. 
In case of std::deque random access iterators are more than adequately efficient.
I'm not prepared to answer the third question. In fact I wouldn't be surprised to find out that these sizes are chosen empirically, based on a bunch of experiments. And, of course, there's probably no ""one size fits all"" solution.
",12,24199421
24174426,"
What can use std::find_if, if you need a custom predicate.
To define a Predicate ala C++03 :
If you can use C++11, you can simply use a lambda :
EDIT:
Now that you show Element I see that you already overloaded operator== in Author, so you could also do :
",0,24174103
24154515,"
Your virtual method seem to be fine. There was a bug in in sorting code. See the fixed code with some extra 'cout' below
",1,24154339
24154470,"
Yes, SortChild publicly inherits from AbstractSort : the sort() method is overridden and correctly called in your example.
As for the sort algorithm, you have a small typo :
Live example of your working code here.
Output:

calling derived method
1 2 4 5 6 8 9

",1,24154339
24154525,"
one small mistake takes you a long way
",1,24154339
24129695,"
You forgot to initialize and increase (or set) the value of n.
Use
or
I don't know how much you understand about sorting algorithms but this might be valuable: http://sorting.at/
",0,24129571
24129715,"
Once n initialized to arr.size(), it works : (https://ideone.com/aNCwN6).
",0,24129571
24129320,"
There are several issues in countRepeats(): 
(1) as already mentionned in other answers, there is an error in the way parameters are passed.  There is no way to calculate the size of the array in the function whether you use int* or int[].   So best pass arguments to this function as you do in quSort() by giving not only the array address but also a start and an end counter.  
(2) your programme will crash if the user would asks for a target of 0 :  your while(biSResult != -1) would loop for ever.  
(3) this function sorts again and again the array. This seems to be pretty bad for performance.  Why don't you make use of the fact that the array is already sorted ?  You could start counting from the found index .  Just think that you'd have to count before and after this position, because you're not sure that iTarget is the very first occurence.  This could look like:  
By the way, I've tested it and it works.  You just have to adapt the prototype and call it in your main function with 
",0,24127814
24127914,"
The first parameter of function countRepeats declared as
that is it has type int *
So 
is equivalent to
If for example sizeof( int * ) is equal to 4 and sizeof( int ) also is equal to 4 then the expression will be equal to 1. That is the value of the expression does not depend on how many elements the array that was passed to the function as argument has.
You should pass the size of the array explicitly as an argument of the function. So th function should be declared as
Or you could declare the first parameter of the function as a reference to array.
",0,24127814
24128153,"
You can't calculate the size of an array inside a function that received a pointer to the array. This is because the value of sizeof(input) inside your counting function is just going to return the size of a pointer to an int. So sizeof(input)/sizeof(*input) will always be 1.
If you instead calculate the size of the array and store it as an int in main, then pass that to your counting function it should work. So changing your counting function call to:
cout << ""\nWith "" << countRepeats(test,target,sizeof(test)/sizeof(*test)) << "" repeats"";
And your countRepeats declaration to:
int countRepeats(int input[], int target, int size);
Then inside your countRepeats definition, everywhere you had (sizeof(input)/sizeof(*input)) you can just say size:
But you should really just use std::vector instead. Could have had std::vector<int> test (1000); and since your countRepeats changes your array through calls to quSort you can pass the vector as a reference (just as efficient as passing a pointer, allows changes to affect the original): int countRepeats(std::vector<int>&, int target); and you can always find its size by test.size()
",0,24127814
24120117,"
In your compare function, you need to use two parameters: it should compare these objects with each other. Also, that's independent of any vector (it operates on elements of your vector), so you shouldn't name the arguments like that to avoid confusion.
So the function could look like this:
Additionally, it's a good choice (but not always required) to add const to parameteres passed by reference in order to indicate that the function body doesn't modify them:
But then it's necessary to put const at the end of the signature of the function Car::getBrand() in order to indicate that that function won't modify the object it operates on. This is called const-correctness. As mentioned before, that process is not always required (like when using std::sort) but it's a good style to have const-correctness.
Or you can use a lambda if your compiler supports it (you need to enable C++11 support):

Note that if you're going to compare cars always by name, it makes sense to implement an operator< for your class. When doing that, you don't need to specify a compare function in the call to std::sort, as those objects are then simply compared like a < b instead of yourFunction(a, b).
",5,24120062
24120122,"
use this sortByName
",1,24120062
24120189,"
You have to pass two Car Objects in sortByName method to compare two Objects as :
Check this link for more detail
",1,24120062
24095126,"
This occurs because insertion sort does not perform any copying on an already sorted list. So if you sorted the list first with selection sort, you see 0 copies because of this effect. Doing it individually will actually do the sorting like you want.
Recall the complexity of insertion sort is O(n) on a sorted list (best case).
",2,24094970
24075189,"
Sorry, you can't specify more than one sort order for a multimap.
The order of any elements that compare equally for the multimap compare function are not configurable.
The closest you might get is:


Create a CBucket based on a std::map that sorts its elements by the comp2 comparator.
Create a std::map<key, CBucket, comp1>

retrieve the correct bucket from then select the right data.

However, before going down a path like that you might want to ask why you need this kind of access and why you aren't just using comp2 as the multimap's compare function.  If you explain a bit more about the problem you are solving, there might be a more appropriate data structure that you could choose.
",2,24074085
24072279,"
Elements in a vector need to be MoveAssignable or CopyAssignable. A pair<const string, block*> is neither due to the const string. Change that to string and your code compiles.
Also change your comparator so that the argument types are const&
Live demo

The second part about the arguments needing to be const& is actually not a requirement. From §25.1/9

The BinaryPredicate parameter is used whenever an algorithm expects a function object that when applied to the result of dereferencing two corresponding iterators or to dereferencing an iterator and type T when T is part of the signature returns a value testable as true. In other words, if an algorithm takes BinaryPredicate binary_pred as its argument and first1 and first2 as its iterator arguments, it should work correctly in the construct binary_pred(*first1, *first2) contextually converted to bool (Clause 4). BinaryPredicate always takes the first iterator’s value_type as its first argument, that is, in those cases when T value is part of the signature, it should work correctly in the construct binary_pred(*first1, value) contextually converted to bool (Clause 4). binary_pred shall not apply any non-constant function through the dereferenced iterators.

So the standard never mentions that the functor's argument types must be const&, but libstdc++ seems to be passing temporaries to the functor and the code doesn't compile unless you add the const& (looks like this has been fixed in gcc-4.9).
On the other hand, both libc++ and VS2013 handle the case where the arguments are not const& correctly.
",2,24072180
24072309,"
In addition to the change suggested by @Praetorian, you should add some const in vectorCompare::operator().
Here's the documentation on the requirements of comp from
 http://www.cplusplus.com/reference/algorithm/sort/.
comp

Binary function that accepts two elements in the range as arguments, and returns a value convertible to bool. The value returned indicates whether the element passed as first argument is considered to go before the second in the specific strict weak ordering it defines.
The function shall not modify any of its arguments.
This can either be a function pointer or a function object.

Some compilers force the argument types to be const& or an object passed by value. Others work with a reference.
",0,24072180
24070670,"
One-parameter sort is not yet available in C++. It will be enabled by concepts, but that was postponed from C++14 as well.
For now, you have to write:
",3,24070520
24070663,"
sort() expects the beginning and end of the range on which it is supposed to work. For example, sort(temps.begin(), temps.end());
The temps.begin() and temps.end() are correspondingly the begin and end iterator that define that range.
",1,24070520
24051684,"
To use a member function as a comparison function, it must be declared static.
",2,24051656
24048654,"
The first thing is that calling the algorithm with a comparator that does not comply with the requirements is undefined behavior and anything goes...
But other than that, I assume that you are interested in knowing what type of implementation might end up accessing out of bounds if the comparator is bad. Should the implementation not check the bounds before accessing the elements in the first place? i.e. before calling the comparator
The answer is performance, and this is just one of the possible things that could lead to this type of issues. There are different implementations of sorting algorithms, but more often than not, std::sort is built on top of a variant of quicksort that will degenerate on a different sorting algorithm like mergesort to avoid the quicksort worst case performance.
The implementation of quicksort selects a pivot and then partitions the input around the pivot, then independently sorts both sides. There are different strategies for selection of the pivot, but a common one is the median of three: the algorithm gets the values of the first, last and middle element, selects the median of the three and uses that as the pivot value. 
Conceptually partition walks from the left until it finds an element that is not smaller than the pivot, it then walks from the right trying to find an element that is smaller than the pivot. If the two cursors meet, partition completed. If the out of place elements are found, the values are swapped and the process continues in the range determined by both cursors. The loop walking from the left to find the element to swap would look like:
While in general partition cannot assume that the value of pivot will be in the range, quicksort knows that it is, after all it selected the pivot out of the elements in the range. A common optimization in this case is to swap the value of the median to be in the last element of the loop. This guarantees that value(pos) < pivot will be true before pos == end (worst case: pos == end - 1). The implication here is that we can drop the check for the end of the range and we can use a unchecked_partition (pick your choice of name) with a simpler faster condition:
All perfectly good, except that < is spelled comparator(value(pos), pivot). Now if the comparator is incorrectly implemented you might end up with comparator(pivot,pivot) == true and the cursor will run out of bounds.
Note that this is just one example of optimization of the algorithm that can remove bounds check for performance: assuming a valid order, it is impossible to walk out of the array in the above loop if quicksort set the pivot to the last element before calling this modified partition.
Back to the question:

Should the implementation not check the bounds before accessing the elements in the first place? i.e. before calling the comparator

No, not if it removed bounds checking by proving that it won't walk out of the array, but that prove is built on the premise that the comparator is valid.
",14,24048022
24048166,"
std::sort does indeed require that the given comparator establishes a strict weak ordering, otherwise the sorting doesn't really make much sense.
As for it accessing out of range, the link you posted is to a bug report, i.e. it isn't supposed to actually do this. Compilers like any other software can and will have bugs. As noted by Adam this particular bug report got rejected since it isn't really a bug.
What exactly happens when you don't have strict weak ordering isn't defined by the standard, it doesn't make sense to do that and is therefore left out by the standard. Therefore it is undefined by omission. Undefined means that anything can happen, even accessing out of range.
As for avoiding ""pitfalls"" just be aware of the requirements of the algorithms and functions you use. For C++ there is a nice reference site that I usually use: cppreference
Which on the page of std::sort says:

comp  -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns ​true if the first argument is less than (i.e. is ordered before) the second.

With a link to the description of Compare
",1,24048022
23987219,"
You can't, because std::sort requires random access iterators, and std::list provides only bidirectional iterators. Use std::list::sort instead.
",6,23987196
23987261,"
You may not use standard algorithm std::sort with container std::list because the algorithm uses random access iterators while container std::list has only a bidirectional iterator.
However std::list (and std::forward_list) has its own methods sort
For example
The output is
",2,23987196
23963931,"
It depends how you are grabbing the file info. If you are just enumerating the container, you will need to store all of the file info stuff into a structure of some kind and then sort the result.
If however you at some point have all the file names and get properties for them, ideally you will want to just sort that list (again storing the whole thing and sorting).
There is an overload of std::sort that takes a comparison function, which you can use to allow you to manually compare two items.
",1,23963894
23963939,"
Yes, to sort the results you'll (pretty much) need to store the intermediate data into some sort of container before you sort.
If you're always (or at least by default) going to sort on one particular field, you can specify operator< to do the comparison based on that field. If you want to support sorting on various other fields, you can specify comparison functors for each field or (preferred if your compiler supports it) use a lambda expression to specify the comparison.
",1,23963894
23960251,"
I'd treat it as a degenerate case of parallel sample sort.  (Parallel code for sample sort can be found here.)   Let N be the number of items.  The degenerate sample sort will require Θ(N) temporary space, has Θ(N) work, and Θ(P+ lg N) span (critical path).  The last two values are important for analysis, since speedup is limited to work/span.
I'm assuming the input is a random-access sequence.  The steps are:

Allocate a temporary array big enough to hold a copy of the input sequence.
Divide the input into K blocks.  K is a tuning parameter.  For a system with P hardware threads, K=max(4*P,L) might be good, where L is a constant for avoiding ridiculously small blocks.  The ""4*P"" allows some load balancing.
Move each block to its corresponding position in the temporary array and partition it using std::partition.  Blocks can be processed in parallel.  Remember the offset of the ""middle""  for each block.  You might want to consider writing a custom routine that both moves (in the C++11 sense) and partitions a block.
Compute the offset to where each part of a block should go in the final result.  The offsets for the first part of each block can be done using an exclusive prefix sum over the offsets of the middles from step 3.  The offsets for the second part of each block can be computed similarly by using the offset of each middle relative to the end of its block.  The running sums in the latter case become offsets from the end of the final output sequence.  Unless you're dealing with more than 100 hardware threads, I recommend using a serial exclusive scan.
Move the two parts of each block from the temporary array back to the appropriate places in the original sequence.  Copying each block can be done in parallel.

There is a way to embed the scan of step 4 into steps 3 and 5, so that the span can be reduced to Θ(lg N), but I doubt it's worth the additional complexity.
If using tbb::parallel_for loops to parallelize steps 3 and 5, consider using affinity_partitioner to help threads in step 5 pick up what they left in cache from step 3.
Note that partitioning requires only Θ(N) work for Θ(N) memory loads and stores.  Memory bandwidth could easily become the limiting resource for speedup.
",3,23923413
23935832,"
Why not to parallel something similar to std::partition_copy instead? The reasons are:

for std::partition, in-place swaps as in Adam's solution require logarithmic complexity due to recursive merge of the results.
you'll pay memory for parallelism anyway when using the threads and tasks.
if the objects are heavy, it is more reasonable to swap (shared) pointers anyway
if the results can be stored concurrently then threads can work independently.

It's pretty straight-forward to apply a parallel_for (for random-access iterators) or tbb::parallel_for_each (for non-random-access iterators) to start processing the input range. each task can store the 'true' and 'false' results independently. There are lots of ways to store the results, some from the top of my head:

using tbb::parallel_reduce (only for random-access iterators), store the results locally to the task body and move-append them in join() from another task
use tbb::concurrent_vector's method grow_by() to copy local results in a bunch or just push() each result separately on arrival.
cache thread-local results in tbb::combinable TLS container and combine them later

The exact semantics of std::partition_copy can be achieved by copy from the temporary storage from above or 

(only for random-access output iterators) use atomic<size_t> cursors to synchronize where to store the results (assuming there is enough space)

",2,23923413
23923656,"
Your approach should be correct, but why not follow the regular divide-and-conquer (or parallel_for) method? For two threads:

split the array in two. Turn your [start, end) into [start, middle), [middle, end).
run std::partition on both ranges in parallel.
merge the partitioned results. This can be done with a parallel_for.

This should make better use of the cache.
",0,23923413
23923729,"

It seems to me like this should parallelize nicely, any thoughts before I try it?

Well... maybe a few:

There's no real reason to create more tasks than you have cores. Since your algorithm is recursive, you also need to keep track not to create additional threads, after you reach your limit, cause it'll just be a needless effort.
Keep in mind that splitting and merging the arrays costs you processing power, so set the split size in a way, which won't actually slow your calculations down. Splitting a 10-element array can be tempting, but wont get you where you want to be. Since the complexity of std::partition is linear, it's fairly easy to overestimate the speed of the task.

Since you asked and gave an algorithm, I hope you actually need parallelization here. If so - there's nothing much to add, the algorithm itself looks really fine :)
",0,23923413
23921490,"
It's not really possible to create an arrangement of items that will cause all or even most Quicksort implementations to exhibit worst-case behavior. And in fact, depending on how the sort is implemented, a worst-case array on one run might be just fine on a subsequent run. That could happen if the implementation used a median-of-random-three to pick the pivot, and used a different seed each time the routine were called.
The C qsort function, and the sort library functions from many other libraries, are vulnerable to a ""Quicksort killer"" algorithm, though, that uses the information provided in the comparison callback to create a worst case scenario on the fly. It's surprisingly not difficult to do. See, for example, A Killer Adversary for Quicksort.
",3,23919017
23920006,"
Unfortunately, there is no generic answer, because it depends on how the ""median of three"" part is implemented, and also how the ""partition"" step is implemented.  Many are easily put into the worst case by giving them a large number of elements that are all identical.  But for the more interesting case, the general concept is like this.
You start with numbers 1....N, and an ""unknown array of the same size.  You don't know yet which numbers go in which index.
The worst case for a quicksort is when the pivot picked is as close to one end as possible, so you want the biggest (or smallest) three elements in the three that will be considered for the median.  Usually, (but not always!) the first, middle, and last elements.
Now we know that after the partition step, the array will probably look like this, depending on how partition is implemented:
And then it will recurse on the [18-R] subsection.  (It may or may not additionally recurse on the [20] subsection, but there's nothing more we can do there.  And so we repeat the pattern, sticking the next two biggest elements in the end and middle of what's left:
So after the partition it will look like:
Then we keep processing on the next subsection:
Note that as we are filling in the ""biggest"" elements, we're replacing the array locations (letters) with the numbers.  When we're done, we'll know which number goes in each array location.  Thus far I have this:
Unfortunately, as I've mentioned, it depends quite a bit on how the pivot is picked and how the partition is implemented.  There probably exists a simple pattern you could fill in, but I haven't any idea what it would be.  You'll also notice I've been always placing the median of the top three on the far left, as that makes most partition implementations act more similar, but realistically, if you know how the partition works, it's probably better to put the median of the top three in one of the other two possible locations, just to give it one more swap to do.
",4,23919017
23901756,"
You haven't shown any code, and you are ambiguous about which container you are using, but you probably want something like this:
",0,23901488
23884857,"
Your current approach is to sort either the x or y values, and this is not the proper ordering for drawing the contour.
One approach could the following

Caculate the center of mass of the detected object
Place a polar coordinate system at the center of mass
Calculate direction to all points
Sort points by the direction coordinates

It will better than your current sorting, but might not be perfect.
A more involved approach is to determine the shortest path going through all the detected points. If the points are spread evenly around the contour this approach will locate the contour. The search term for this approach is the travelling salesman problem.
",0,23884668
23893453,"
I think you searching for Concave Hull algorithm.
See here:
http://ubicomp.algoritmi.uminho.pt/local/concavehull.html
Java implementation: here
",0,23884668
23876733,"
I have finally fixed it, i forgot to increment the iterator before inserting the element
adding:
",0,23873764
23868638,"
I think the solution depends on the size of input file. 
What I would do is to check the size of the file first, if it's smaller than certain size, for example, 1GB (providing 1GB is a small amount of memory on your machine), then I'll read the whole file, store the content in memory, merge sort them, then write to the new file.
Otherwise, I'll have to divide the original file to K temp files less than 1GB, merge sort each of them, then do a K way merge sort between the files, and finally concats the K files together. Basically you need to divide and conquer in two levels, first the files on disc, then the contents in memory.
",0,23868286
23871659,"

If you are using any reasonable OS (anything with an X in it or BSD) and have enough memory rely on 'sort'. If you hit the limit on file size, use 'split' and then the --merge option of sort to merge the already sorted files.
If you really need to write code for an external sort you can save yourself a lot of trouble by starting with a thorough reading of Knuth's TAOCP Vol III, Chp 5 on external sorting.

",0,23868286
23846840,"
",2,23846320
23846688,"
You can use something like this :
",0,23846320
23845939,"
You can use std::sort to sort the array, you can use std::begin and std::end to obtain iterators to the start and end to pass to sort, and you can use std::tuple to provide the comparison function.
There is no particularly relevant difference between std::vector and a raw array for this task.
Example code:
",5,23845876
23854358,"
It's difficult to answer your question because it is a complex system which you haven't fully explained here and which you should also reduce to something simpler before posting. Chances are that you would find a fix yourself on the way. Anyway, I'll do some guessing...
Now, the first thing I'd fix is the sorting algorithm. Without analysing it in depth whether it works correctly in all cases or not, I'd throw it out and use std::sort(), which is both efficient and very unlikely to contain errors.
While replacing it, you need to think about the ordering between two rendered objects carefully: The question is when exactly does one object need to be drawn before the other? You are using the distance of the center point to the camera. I'm not sure if you are sorting 2D objects or 3D objects, but in both cases it's easy to come up with examples where this doesn't work! For example, a large square that doesn't directly face the camera could cover up a smaller one, even if the smaller square's center is closer. Another problem is when two objects intersect. Similarly for 3D objects, if they have different sizes or intersect then your algorithm doesn't work. If your objects all have the same size and they can't intersect, you should be fine though.
Still, and here I suspect one problem, it could be that a surface of an object and a surface of the cube grid have exactly the same position. One approach is that you shrink the objects slightly or enlarge the outside grid, so that the order is always clear. This would also work around an issue that you suffer from floating point rounding errors. Due to these, two objects that don't have an order mathematically could end up in different positions depending on the circumstances. This can manifest as them flickering between visible to covered depending on the camera angle.
One last thing: I'm assuming you want to solve this yourself for educational reasons, right? Otherwise, it would be a plain waste of time with existing rendering toolkits in place that would even offload all the computations to the graphics hardware.
",1,23845782
23832778,"
Since the rest 95 elements are not assigned, they are by default (0,0). So you need to sort the first 5 elements only.
",3,23832671
23832735,"
The sorting of a vector<pair<int, int> > works just the way you use it. However you have another problem. This code - vector<pair<int,int> >a(100); creates a vector of size 100 and fills it with pairs of (0,0). Thus when you sort it the first 5 elements are (0,0).
",3,23832671
23832725,"
Your vector is of size 100, but you only populated 5 elements. The rest will all be (0, 0), which your compare() correctly puts at the front.
",2,23832671
23817006,"
Since operator< is defined for std::pair and it is based on std::pair::first and then std::pair::second (lexicographical), so your code is working as the standard. To sort it based on the second part of the std::pair you can try this:
",6,23816797
23818295,"
There is one ""obvious"" ordering of product types induced by the respective orderings of the components, and that is lexicographical order:
This is the ordering used by operator< of std::pair. In your example, since all the first components are distinct, the ordering happens to be equal to the ordering of the first component. It gets more interesting if you have multiple occurences of the same value in the first component, in which the second component is used to break ties.

How to make it do so for some class of mine as pair first? 

You just have to define operator< for your type. But keep in mind that the second component will be considered if necessary and you might not want that overhead.

Is there a way to sort by second using std::sort?

Yes, just use a custom comparator functor. You can always do that if you don't want to use the default operator< for sorting.
",5,23816797
23810986,"
i=0 is going to happen right before the increment in the for loop runs, so the effect of the statement will be that i==1 in the next loop. The easiest way to get your intended behavior is to just break from the for-loop after you swap the elements (don't worry, it'll only break the for-loop, not the while-loop). You should also just set change=false at the top of the while-loop, rather than setting it whenever you don't swap elements.
",1,23810881
23811051,"
Use this code instead for sorting (still untested):
Here, instead of a normal array, std::array is used. Next, a custom comparison lambda-function is defined and passed to std::sort.
I don't know whether it does exactly the same as your code, but at least will sort your classes according to the entry kopejais.

EDIT: Here is a version of your code which should work faster than the one in the accepted answer:
The reason is that you are not repeatedly looping over already ordered parts of the array, which is done by using break after the swap.
",0,23810881
23799425,"
You want to sort first by nVal, but if elements have the same nVal, sort by the strings.
A simple to understand alternative to juanchopanza's answer that supports pre-C++11 compilers is:
",0,23799182
23799227,"
Just sort according to both criteria in one pass. You can achieve this by implementing a lexicographical comparison, using nVal first, followed by strVal, and strName:
When used with sorting algorithms such as std::sort or std::stable_sort, this will result in a sorting based on nVal first, then strVal, then strName. The use of std::tie is just a means to simplify the implementation of the lexicographical comparison, but you can do it by hand (this is both tedious and error-prone.)
Note If you want to maintain the original ordering of elements considered to be equivalent according to the comparison criteria, use std::stable_sort. Otherwise, use std::sort.
",8,23799182
23796144,"
Your main mistake is in the design of this loop:
Consider what happens if the left range is 3, 4 and the right range is 1, 2.

In the first iteration it will add both of the right elements to your output.
In the second iteration it will reset iterR and so again.

You are left with an output of 1, 2, 3, 1, 2, 4.
If you manage to properly keep the state about which element of the right vector has been processed, your problem about the leftover elements will disappear by itself.
A few further hints:
::std::merge will probably work better.
You are passing vectors by value all the time.
Your code only works for vector<int>, which is an unnecessary restriction in C++. Templates make for sunny days.
",3,23796090
23763944,"
If your compiler supports C++11, You could do something like:
Note, for the above example to work you have either to define your member functions getX and getY as consts or remove the const qualifiers from the input arguments of the lambdas.
If your compiler doesn't support C++11 then you can define comparables like below:
and call sort like below:
",5,23763856
23748522,"
You don't need your own comparator. The default will work out of the box because there is already an operator< for std::vector which performs a lexicographical comparison.
",4,23747824
23747844,"
I found the problem; I had these rows:
which when I read them from file and pushed them back to my vector, they turned into:
so, I was expecting that the third row comes before the first and the second one. 
",1,23747824
23738450,"
You can define the operator in the class and sort will use it.
To compare using a different criteria use another comparer for the priority queue.
And use it like this:
",2,23738058
23878687,"
As Tejas says, using cin and cout is not recommended in problems of optimization, as they are slower in comparison to scanf and printf. Extending his answer, you need to note that you use the STL sort that is slower than STL qsort. having this in mind, I tried your code with qsort and i got AC:
The int function compare is needed for the usage of qsort.
More info: 
http://www.cplusplus.com/reference/cstdlib/qsort/
http://www.cplusplus.com/reference/algorithm/sort/
",1,23721343
23735598,"
If you use cout<<arr[i]<<endl; it will give TLE instead of WA. So it means it has something to do with new line.
However if you want to get your answer accepted, you have to use printf and scanf instead of cin, cout. It is always suggested in such contests to use scanf and printf for reading large inputs.
I tried the following code and it was accepted
",0,23721343
23699940,"
you could overload your own sort function
",3,23699685
23699743,"
The std::sort algorithm is somehow container independent (it requires iterator to meet the requirements of ValueSwappable and RandomAccessIterator) so you can use it like:
Unfortunately std::list does not satisfy RandomAccessIterator, though.

If you have a template function that accepts any container type, you can provide specializations to it. Alternatively, with type traits you can provide more general template ""overloads"":
Live demo
",1,23699685
23700258,"
You could use type traits and tag dispatching see code below:
Output:

3 4 7 8 9  
9 8 7 4 3

",0,23699685
23701792,"
Since you indicated in the comments that you have planar coordinates, here is a solution that uses them (in pseudo-code). Basically, you sort the adjacent vertices a of each vertex v in ascending order of the atan2 of the vector from the vertex to the adjacent vertex (a - v).
Calling this function for each vertex of the graph will run in O(V * log(V)), where V is the number of vertices, assuming the adjacency lists can be obtained in O(1). This is because each edge is examined exactly once (for directed graph) or twice (for undirected graph) and the number of edges in a planar graph is O(V).
",2,23696072
23692154,"
At a glance..
That looks like it should be either:
or:
But also that partition method looks very questionable.  Even if it successfully finds the median I doubt it's worth the effort.  The point of quicksort is to sort with as few comparisons as possible, so looping through each entire subarray to find the median kind of defeats that purpose, and is overkill.  I would suggest picking three items: first, middle, last, and just using the median of those.
",0,23691886
23680639,"
In C++03, elements in a std::vector have to be copy-assignable and copy-constructible in c++. A pair with a const member does not meet that requirement and is thus invalid. The compiler is right to recject it.
In C++11, elements in a std::vector have to be move-assignable and move-constructible. A pair with a const member cannot be moved and will thus result in invalid code.
",6,23663233
23663410,"
I've decided to utilize const_cast, override=, and swap to make sorting work:
",0,23663233
23663380,"
The problem is that the const semantic is very rough and working with for example a non-const array of const objects or a const array of non-const objects just doesn't fit this schema.
A possible workaround would be to just keep the data in a non-const array and use pointer cast tricks to provide the interface. In other words when you are passed a pair<const int, int> p just use pair<int, int>& ncp(*((pair<int, int>*)&p)); instead. When returning objects to the users you can do the same.
Formally IIRC this is not guaranteed to work, but in implementations I know is ok and the optimizer should be smart enough to generate no code for this change of point of view. One problem could be strict aliasing assumption optimization (that btw creates problems to a lot of low level code), and in that case may be using a union can solve the issue (still remaining of course non correct for the standard).
EDIT
Actually thinking a bit more about it seems to me that such a ""map"" would have more problems that just iterator invalidation. For example a pattern that I use (and I bet others use also) relies on the fact that iterator may be invalidated, but the value themselves are never moved around... for example after doing
I can be sure that the returned reference will remain valid even if other elements are added or removed from the map. Note that no iterator is used.
Keeping the elements in a vector and moving them around on element insertion (or at first access after an insertion) is going to break this use too.
",-1,23662478
40206872,"
There is no native support for sorting matrices as of today. There are two long-pending feature requests relevant to this functionality:

Bug 231 - STL compatible iterators
Bug 299 - Sort function for matrices and vectors returning indices as well

As suggested by @NicolasM in the comments, currently, the most elegant solution is to provide custom iterators yourself, e.g.:
",1,25341918
25343263,"
What I tried to say is something like this.   
I used insertion sort because it's easy to implement.
",0,25341918
25331604,"
First option: cluster() and sort_within()
The handwritten double loop by @MadScienceDreams can be written as a cluster() algorithm of O(N * K) complexity with N elements and K clusters. It repeatedly calls std::partition (using C++14 style with generic lambdas, easily adaptable to C++1, or even C++98 style by writing your own function objects):
which you call on your input vector<std::pair> as
The next algorithm to write is sort_within which takes two predicates: an equality and a comparison function object, and repeatedly calls std::find_if_not to find the end of the current range, followed by std::sort to sort within that range:
On an already clustered input, you can call it as:
Live Example that shows it for some real data using std::pair<int, int>.
Second option: user-defined comparison
Even if there is no operator< defined on A, you might define it yourself. Here, there are two broad options. First, if A is hashable, you can define
and write std::sort(begin(v), end(v)) directly. You will have O(N log N) calls to std::hash if you don't want to cache all the unique hash values in a separate storage.
Second, if A is not hashable, but does have data member getters x(), y() and z(), that uniquely determine equality on A: you can do
Again you can write std::sort(begin(v), end(v)) directly.
",3,25326089
25327495,"
if you can come up with a function that assigns to each unique element a unique number, then you can build secondary array with this unique numbers and then sort secondary array and with it primary for example by merge sort.  
But in this case you need function that assigns to each unique element a unique number i.e.  hash-function without collisions. I think this should not be a problem.
And asymptotic of this solution if hash-function have O(1), then building secondary array is O(N) and sorting it with primary is O(NlogN). And summary O(N + NlogN) = O(N logN).
And the bad side of this solution is that it requires double memory.
In conclusion the main sense of this solution is quickly translate your elements to elements which you can quickly compare.
",3,25326089
25326775,"
An in place algorithm is 
There is probably a more elegant way to write the loop, but this is O(n*m), where n is the number of elements and m is the number of keys. So if m is much smaller than n (with a best case being that all the keys are the same), this can be approximated by O(n). Worst case, the number of key ~= n, so this is O(n^2). I have no idea what you expect for the number of keys, so I can't really do the average case, but it is most likely O(n^2) for the average case as well.
For a small number of keys, this may work faster than unordered multimap, but you'll have to measure to find out.
Note: the order of clusters is completely random.
Edit: (much more efficient in the partially-clustered case, doesn't change complexity)
Edit 2: At /u/MrPisarik's comment, removed redundant i check in inner loop.
",2,25326089
25331459,"
I'm surprised no one has suggested the use of std::partition yet.  It makes the solution nice, elegant, and generic:
Example here.
",2,25326089
39370903,"
I have actually studied this extensively in my paper. https://arxiv.org/ftp/arxiv/papers/1505/1505.00558.pdf
The short answer is, NO. Dual Pivot doesn't perform as well when compared to a high end version of quicksort when swapping large elements. Look at figures 22 and 23.
",1,25314224
27053474,"
I think that there is 3 reasons why QUICKSORTYAROSLAVSKIY() of the paper is not fast.

It is difficult to get a good pivot. Often 2 pivots are too near or too far.
There is too many swap. For example, swapping in the line 12 is a partial array sliding.
The insertion sort implemented is not practical. The Knuth algorithm of the paper might be written to teach. I don't like a partial array sliding.

A merit of QUICKSORTYAROSLAVSKIY() is that 2 pivots are excluded from partitioning.
I devised an algorithm to make quicksort faster. Because, swapping is a redundant method and a pivot should be chosen in various elements while N is big. More..
",0,25314224
27069050,"
If your goal is to reduce the number of swaps, you should fall back to sorting pointers. Something like this:
This is guaranteed to do precisely data.size() copy constructions. You can't do better.
",0,25314224
25298091,"
Here's another minimal example of how it can be done:
This will work with an arbitrary level of nested std::vectors.
Live example
Edit:
See the updated code (changed return statement inside the lambda). Previous version did not work correctly with negative numbers.
",3,25297252
25297498,"
The function you wrote the signature of can be implemented with a simple call to std::max_element.
Then you can overload this function with a template accepting any nested vector, which first recursively applies the function to each element of the vector before computing the maximum value of them.
The following code implements this idea. The second parameter int dimension is not required, since the number of dimensions is given by the type of the first parameter.
If you want both min and max elements simultaneously, you could use something like std::minmax_element for the base case, but the recursive call gets way more complicated then.
Live demo: http://ideone.com/kW0ewz
",5,25297252
25297999,"
Be aware that templated functions can derive their argument types.  You don't need to specify the types to call the methods; and you can have them drive their call parameters for you (same isn't true for template structures).  You can exploit that.
Here's another solution:
The usage is the same regardless of how many nested vectors you have:
...the STL approach is more focused on giving you the maximum T in a container of T; if we're nesting T's, we have to recurse twice to get the root element's out (one to tell us which T has the max value, and again to extract it).  The approach here is simple bottom up recursion (each find_max gives you the largest value of that level structure, and we just trickle out).
",3,25297252
32036707,"
I had the same problem every once in a while and here is my solution: https://github.com/nlohmann/fifo_map. It's a header-only C++11 solution and can be used as drop-in replacement for a std::map.
Example
Note how the fifo_map's elements are always printed in the order of the insertion.
",2,25272478
25273029,"
A map and any standard associative container is already sorted and it cannot be sorted differently.
If you would like to maintain several element orders in one container, e.g. sorted by some key (map) and in order of insertion (list), you can do that with boost::multi_index, it is very well documented.
",1,25272478
25220238,"
It can easily be done with an vector of std::pairs:
Then you can just output toSort[i].second for all elements of the vector. Note that std::pair overloads operator< on a sensible way which is why you do not need to provide a custom compare function. This is just as efficient as a stable sort, and elements of the same value will keep their original order.
",3,25220174
25220206,"
You can sort an array of pairs(value, initial index).
",1,25220174
25220296,"
Decades ago I produced a revised qsort() to:
1. take a swap function parameter (in addition to the compare function parameter)
2. modified both parameter function parameters to take indexes (of the array) rather than pointers
With these modifications, it is easy to handle an array of indexes which, when the sort is done, is exactly the result you want:
",1,25220174
25221375,"
You could make a seperate array of indices as you suggest. Initialize it to b[] = {0, 1, 2, 3, 4}. Then sort it. Except define your sort order as comparing the values of whatever is indexed. For instance comparing elements i and j would consist of a[b[i]] < a[b[j]]. When it's all done, b is ""sorted"" and a is unmodified. So you're only sorting one array, not two. You can do this by calling any standard sort algorithm and passing in your own compare function that does the ""right thing"" in your case, it can be a function-object if you need to hide a pointer to a in it.
For instance here is a simple implementation using lambdas in C++11:
After the call:
b[] = {0, 3, 2, 1, 4} and a is unmodified.
",0,25220174
25220455,"
A simpler fix would be implementing the compare method as a static method so no object instances is needed to use the method.
BaseObj class:
",0,25217590
25218122,"
Your sample code has some issues (incomplete, possible slicing, not const correct) and does not show any polymorphism.
In C++11 you might do:
",1,25217590
25234569,"
One approach that occurs to me is to do a parallel binary search, taking each value from the global index vector, and seeing if it has a match in the key vector.  If it has a match in the key vector, then place the corresponding value in the result.  If it does not have a match in the key vector, then place 0 in the result.
So for each position in:
see if there is a matching index in:
We'll use a parallel binary search to do that, and to return the corresponding index (of the matching value in indy).
If we do find a match, then at the position in question in the result, we will place the value corresponding to indy[matching_index], ie. dny[matching_index].  Otherwise put zero in the result.
In the case of thrust, I was able to reduce this to two thrust calls. 
The first is a thrust::lower_bound operation, which is effectively a vectorized/parallel binary search.  Just as in the CUDA case, we use the binary search to take each element of the global vector (ind) and see if there is a match in the key vector (e.g. indx), returning the index of the matching location in the key vector (lower bound).  
The second call is a somewhat complicated use of thrust::for_each.  We create a special functor (extend_functor) for the for_each operation, which is initialized with a pointer to the start of the key vector (e.g. indx), and its length, as well as a pointer to the values vector (e.g. dnx). The extend_functor then takes a 3-tuple of the global vector, the lower-bound vector, and the result vector values, and performs the remaining steps.  If the lower-bound value is within the length of the key vector, then check if the lower bound produces a match between key and global vectors.  If it does, place the corresponding value into the result vector, otherwise place zero in the result vector.
The follow code implements this using CUDA, and also with thrust.
",1,25217333
25204547,"
This copies the structs each time, including the vectors. Vectors are slower to copy than normal arrays. You should use this instead.
If you are using C++11, you can replace the vector with std::array as the size is constant.
",7,25204479
25204551,"
sort copy your values every time and std::vector preallocate a bunch of memory. The amount of copy time is bigger
",0,25204479
25204697,"
In addition to take parameters as const ref you could use a functor for comparison. That is often faster because functors are more easy to inline.
",0,25204479
25204597,"
Did you try storing pointers instead of the whole struct in your vector?
",-3,25204479
25186865,"
The reason the first vector is printing 000 is probably because you initialize the vector with 1000 initial values, which probably default to 0. I am not 100% sure of this, but the reason the second sort works is because the largest numbers are placed first. In the case of the first, there are 997 0s before your 1,2,3. What I would suggest is (if your n is 3), initialize the vectors with just 3 and do your test. 
Also, IDK why you are initializing your vector to have 1000 elements of type A immediately, but you can also attempt to test your program and the sort function by not initializing the vector with any elements and utilizing the push_back method on it instead to insert your variables. 
Your syntax is otherwise perfectly alright, there should be no issue with the sort.
",3,25186706
25156753,"
The problem is that objects of your class Event cannot be assigned because of const double time member. Since the member is const it cannot be modified, so you cannot use sort on a container with Event objects, because sorting requires assignment. 
Either remove const or rethink what you try to do. BTW you are confusing assignment operator (operator=, this is what sort requires) with equality operator (operator==`).
",2,25156606
25156761,"
To reorder the objects inside the vector the object has to be copyable (or moveable). You have to define an operator= (which is an assignment) that is of the form:
So your implementation of operator= is wrong. You are comparing the two objects but this is not what operator= (assignment!) is supposed to do. It has to assign one object (its content) to another object and return a reference to the object assigned to. 
Keep in mind that you should provide a copy constructor as well if you implement an assignment operator.
",2,25156606
51014330,"
This is the correct implementation of the custom assignment operator for the question:
Also, change the declaration of the assignment operator as well:
",1,25156606
25131178,"
Binary operators like < and polymorphic class hierarchies don't work together well.
Even if you declare operator< virtual in Item, and override it in Seed, the other argument is an Item regardless. The overridden comparison operator can use Seed properties of this object, but only Item properties of the other object, because it is not known whether the other object is a Seed or not.
This makes defining a virtual < that works like it should (antisymmetric, and in concert with > and ==, and not violating LSP) virtually impossible. 
This is true in any language, nothing specific to C++ or vectors here. Some languages offer multiple dispatch that ostensibly solves the problem. However, multiple dispatch is a closed-world solution (requires advance knowledge of all classes in the hierarchy), while normal OO is open-world. If you can live with a closed-world solution, you can do multiple dispatch in C++ too. 
The best course of action is to have a non-virtual < that need not be overridden at all.
",0,25130180
25131236,"
AFAIK there is a way to access parent class protected members by using member pointers (this probably is a hole in the type system)
However unless it is really very necessary, it is not recommended. I would recommend that you redesign your architecture so that you can avoid that.
",0,25130180
25128292,"
A C-String--what you have an array of--is really just an array of characters, which you can look at as either char c[] or char *c. Since you have an array of c-strings, your parameter will either have to be char **c or char *c[], so your function would be:
",3,25128244
25128287,"
Since you're passing in an array of Strings (char[]), It should be
",1,25128244
25128270,"
Your function must take char **arr as a parametr.
Why? Because, char * is only one string (pointer to first character of it). If you want to pass array of ints to function, you use int *arg argument. If you want array of strings, you use char **arg.
",0,25128244
25128458,"
First of all the array shall be defined as
because it is an array of pointers that point to string literals (the first characters of string literals). String literals may not be changed.
That do not make the error as you did you could define the function the following way
In this case you may call it as
",0,25128244
25120277,"
Your logic isn't really correct for an insertion sort. In fact, what you have right now is much closer to a bubble sort (though it's obviously not quite right for that either).
For an insertion sort, the logic goes something like this (assuming 0-based indexing):
So the basic idea here is that for each element, we search backwards through the array to find the right place to put that element. As we do so, we shift elements upwards by one spot, so when we got to the right spot, we have a place to put it.
Note, in particular, that this doesn't contain any swap-like code anywhere. We don't normally plan on swapping adjacent elements as you've done. It can/will happen when/if an element happens to be out of place by exactly one position, but it's pretty much incidental when it does.
",0,25119728
25100372,"
The problem is that you are inheriting from vector to avoid writing your own operator<, but you are storing the data in a member vector.  The inherited operator< has no idea about the member vector, and since you never add anything to the inherited vector all of your objects compare as the same since all empty vectors are the same.
Inheriting from a standard container will work, but it isn't always the best idea since they do not have a virtual destructor.  For this assignment it should be okay, but you should do some research so you are aware of the issues in the future.
Here's an example that demonstrates the issue with your current code as well as showing two alternatives using inheritance and a member vector.  I'd recommend the member vector since it avoids the issues of inheriting from a standard container and the operator< is just one line, but it's up to you.
",2,25099809
25095193,"
I think your mean is:

Get string from input
Separate input to Integer numbers
Save them into Array

If this is your mean, try this code:
",1,25094475
25095080,"
Try:
",1,25094475
25095296,"
Use stringstream:
live demo
Note: You need to include following headers: <string>, <sstream>, <vector>
",0,25094475
25086034,"
I would suggest checking out what Joachim linked to and http://www.cplusplus.com/reference/algorithm/sort/. When calling sort you must provide it an iterator to start at and an iterator to end at, with an optional third argument that can be your comparison operator.
Below is an example that I made from your code;
As for the signed/unsigned error, ints are signed meaning that they can be negative, so they can be −32,768 to 32,767, where as uints are unsigned meaning that they can be 0 to 65,535.
The code can still work but beware that if word.size() is larger than 32767 and i is an int then i will never grow to be larger than word.size(). i will simply wrap around to -32768 when incremented past 32767. I would suggest using uint as the type of i.
",1,25085780
25116380,"
The STL way would be to use a map, but just for the sake of the puzzle lets try without copies. 
All you need is to somehow ""connect"" the two vectors  
A nice way would be to sort a vector of indices according to the ""major"" vector and then rearrange your vectors according to those indices. 
Demo
Ofcourse the only advantage of something like this is that for huge vectors you could do step (3) in parallel. Also this solution scales to arbitrary number of ""related"" vector sorting. 
You only pay for the index sorting, while the subsequent rearrangement only takes linear time.
",3,25085015
25087131,"
Perhaps not the most useful, but there's a duplicate of this question that seems to have a solution from Anthony Williams. 
Sorting zipped (locked) containers in C++ using boost or the STL
Here's the full example which seems to work (note I just put it together... I didn't write this.):
",1,25085015
25086006,"
If you are are able to use Boost then you could join the iterators of the two vectors into a single joined range that you can then sort and get the unique entries from.
See http://www.boost.org/doc/libs/1_55_0/libs/range/doc/html/range/reference/utilities/join.html for further information.
Example:
",-1,25085015
25074365,"
Instead of 10 loops on a single array, use 10 arrays (even 10 arrays of 10,000 won't be an issue for memory usage). Populate the 10 arrays with random numbers, then call mergesort() 10 times to sort each of the 10 arrays. This will help a bit. However, even this may not be enough. I did some testing with much larger arrays:
Time to sort 4,194,304 64 bit elements of psuedo random data:
64 bit mode, Windows XP64, Visual Studio 2005 compiler. Intel i7 2600K 3.4ghz, DP67BG motherboard, 4GB ram
You could use more arrays, but if the number of arrays is large, then the calling overhead becomes a factor. Radix sort is linear in time O(n), while merge sort is O(n log2(n)). You could test larger arrays, then use the formulas to estimate times for small arrays.
For a higher precision timer, you can get a cpu cycle count using the X86 rdtsc instruction (assembly) or an intrinsic if your compiler supports it. Since it's a cycle count, it's unaffected if the cpu has an automatic overclocking mode, such as Intel's turbo boost.
",0,25074085
25067459,"
""Efficient"" is a relative term. But if you do not wish to have any extra memory usage, then using a virtual function or type_index are the only options I can think of.
On the other hand perhaps this could be solved in an entirely different way if we knew more about the problem context. One potential alternative would be to store different objects in entirely different containers, indexed by an unordered_map.
",0,25064649
25000790,"
There is no need to do a full sort. The key insight here is that a ranking can only change by +1 or -1 when it is accessed. I would do the following...
Keep the element in a container of your choice, e.g.
Maintain a linked list of element rankings, something like this:
The rankingInstance has a pointer to an elementInstance and the value of the current rank and current number of accesses.  On access, you:

access the element in the map
get its current rank, and access count
update the count
using the current rank, access the linked list
check the neighbors
swap position in list if necessary
if swapping occurred, go back and update the two elements whose rank changed

",1,25000418
25001286,"
It may seem so simple, but my suggestion is to use Bubble Sort on your list. Since, Bubble Sort compares and switches only the adjacent elements, which is your case, simply one up or one down move in the ranking. Your vector may keep the 'Rank' as key, 'ContentHash' as value in a vector. A map containing 'Content' or 'Content Reference' will also needed. I hope this very simple approach gives some insights about your problem.
",0,25000418
24987748,"
Tailor your compare function so it compares the 2nd element in string vectors.
std::sort() then calls cmp() whenever a comparison for sorting is required.
If the 3rd parameter of std::sort() is omitted, it calls operator< for comparison, which compares vectors lexicographically. 
",5,24987731
24987788,"
This can be a solution!
Edit
I would like to mention an alternative way in case of you don't know that(Remember, std::sort is about 670% faster than std::qsort due to the fact of inline. So this isn't better than above) :
",1,24987731
24962330,"
Strictly speaking, 
should work. The only requirement for compareWords is that it should not modify the arguments.
Here's some info from http://en.cppreference.com/w/cpp/algorithm/stable_sort

The signature of the comparison function should be equivalent to the following:


The signature does not need to have const &, but the function object must not modify the objects passed to it.

However, some compilers take that requirement to mean that the arguments should be either const & or simply objects.
",1,24962218
24962299,"
It's to help you ensure that you don't modify the arguments to the comparator.
If you were to modify the elements being sorted during the sort operation then the comparator might return inconsistent results, which would break the sorting algorithm - with potentially unlimited ill effects (""undefined behavior"").
",1,24962218
24962316,"
By saying string & s1 as a parameter without the const implies that you will be changing the underlying value back in the calling function.  However, that value is the return value of a function -- it's not stored anywhere, it can't be changed.   
(OK, due to some compiler magic it is stored somewhere, but that location is not accessible to the calling function, so you are still implying you want to do something that you can't do)
",1,24962218
24962481,"
According to the C++ Standard 

It is assumed that comp will not apply any non-constant function
  through the dereferenced iterator.

So to provide this restriction objects of dereferenced iterators are considered as const references.
",0,24962218
24957420,"
in your function you have:
where ""I am awesome"" is a const char*. During the sorting you are trying to mutate that, which is as far as I'm aware undefined behaviour.
instead allocate a char* first and fill it with the desired string.
Or better yet since you are working in C++ try using std::string which takes care of most of the stringhandling.
Ps: In the future please try identifying which section of the code is relevant and post that snippet instead of a link. Further, more detailed information on when it crashes (line number for example) can help yourself and others in finding the issue.
",4,24957282
24958082,"
void bsort : what you did => for(int b = 0;b >=  (length-1);b++) 
what you need to did => for(int b = 0;b <  length;b++)
void sort : it works fine at my pc.
void xselect : void xselect(string items,int count){
    for(int i=0;i<count-1;i++)
    {
          char c = items[i];
          for(int a = i+1;a < count;a++)
          {
              if(c > items[a])
              {
                   cout<<c<<items[a]<<endl;
                   c ^= items[a];
                   items[a] ^= c;
                   c ^= items[a];
                   items[i]=c;
                   cout<<c<<items[a]<<endl;
              }
          }
    }
          cout<<items;
    }
",1,24957282
24847250,"
You can have a comparison object that has a flag indicating which member to sort on.
",7,24847210
24847336,"
Here's something that does a lexicographical comparison using arbitrarily many members of any class. Needs C++14 for variadic templates and compile-time integer sequences. You can implement compile-time integer sequences yourself if you have C++11.
You use it like:
Demo.
",2,24847210
24841091,"
Edited your code to calculate time for first 2 cases in seconds:
",0,24840205
24840454,"
this should help.
",1,24840205
24825442,"
Boost MultiIndex let you maintain a collection of element order by multiple key element, in your case you could use the two interesting data (id and order of size) as he key used to sort the multiindex and the data structure allow inplace replacement of elements (even changing keys, if keys are changed the replacement performances is O(log N) and no O(1) as in other data).
",2,24825125
24817309,"
O(N*log(N)) complexity doesn't imply that the container is iterated in order, nor that the changes to it are only made in scan order. To use sequential iterators would come at a O(N) memory cost to store all of those iterators.
",4,24817274
24817663,"
Algorithm complexity doesn't say it all. Actually in C++ (from a formal point of view) it doesn't say anything because you cannot grow N to infinity (size_t isn't an arbitrary precision number) thus every sort algorithm written in C++ is (formally) also O(1).
From a practical point of view std::sort is the grandson of qsort and it's implemented most probably as a variation of quicksort.
Using merge sort for arrays would require an extra storage proportional to the size of the array (the link to next element) while merge sort for lists doesn't require any extra space because you can reuse the link already present in the node (that it's going to be destroyed by sorting anyway).
The idea of programming without knowing what kind of container you're dealing with is mostly an illusion, thus having two different explicit ways to sort efficiently two different types of containers is not considered bad per se.
It's indeed annoying that std::sort doesn't contain a specialization also for list iterators (I'm not a template metaprogramming guru but it would seem quite straightforward to do).
",0,24817274
24812898,"
You can store each row in an std::pair<char, int>, put those in an std::vector<std::pair<char, int>>, and use the std::sort function to give you the required sorting. You don't have to write any classes or algorithms of your own.
This can be generalised to more columns by using std::tuple (or std::tr1::tuple or boost::tuple if you are stuck with an old implementation of C++). tuples have lexicographical comparisons that work in the same way as those of pair. If you need a different ordering, you can pass your own comparison function as a 3rd argument to std::sort.
",4,24812847
24813021,"
Here is an example
The output is
instead of std::pair you can use std::tuple for multiple columns. For example
The output is
If you have to sort an array of structures with different data members then you can build a tuple from these data members and use it in a predicate of std::sort.
",0,24812847
24764451,"
The dynamic toposort algorithm (untested).
Start with a topologically sorted sequence of vertices.

If a vertex with no edges is added, insert it anywhere in the sequence.
If an edge or a vertex is removed, do nothing.
If a forward edge (from lower-sorted to higher-sorted vertex) is added, do nothing.
If a new backward edge A→B is added, move B directly after A. Mark outgoing edges of B as new. Repeat points 3 and 4 as necessary. (If several vertices can be moved, start with the lowest-sorted one; if a vertex to be moved has several new incoming edges, choose one from the highest-sorted vertex). If you encounter the same vertex twice in this process, report a cycle.

The algorithm by itself doesn't detect cycles, but you may limit cycle search to the subset of vertices that were moved.
",1,24748744
30930330,"
There is indeed work on dynamic toposort.
Pearce & Kelly http://homepages.ecs.vuw.ac.nz/~djp/dts.html have an algorithm that they claim is both simple and practically efficient. They also provide a C++ implementation. By way of introduction, they discuss even simpler variants. 
Here is some of the later work on this problem, in chronological order. Later methods tend to be more complicated than earlier ones. Even if not, the later papers may assume that you have already read the earlier ones. You apparently started with the last paper on this list, which might have been jumping into the deep end.

http://www.cs.princeton.edu/~sssix/papers/dto-icalp08.pdf
http://dl.acm.org/citation.cfm?ID=1496890
http://dl.acm.org/citation.cfm?ID=2071382
http://arxiv.org/pdf/1310.8381.pdf (which you mention in your question)

",1,24748744
24735282,"
It is not possible to pass a pointer to a non-static member function to std::sort: the function needs to be able to call the comparison function without an object reference, which is not something you can do with a member function.
For situations like yours you need to pass a function object, which has an operator () taking two objects being compared:
",3,24735219
24735348,"
A non static member function require an object to be called.
In your case you may use a lambda function as the following:
or change your class to rename myComparisonFunction to operator () and pass your obj functor directly (std::sort(P.begin(), P.end(), obj)).
",4,24735219
24734161,"
Be careful though as this is not a stable sort and will not preserve the order of lines that have the same second element. Use std::stable_sort if you want this. The usage is identical.
",1,24734059
24718043,"
To summarize the comments above in an answer. If you are loading strings to be compared on the fly and do not need them to be in a specific order, then std::unordered_set is by far the fastest.
unordered_set is a hash set and will punch your string through a hash function and find if it is already in the set in constant time O(1).
If you need to retain the order of the elements then it becomes a question what is faster of retaining a vector and doing a linear search though it, or whether it is still worth to build the hash set.
Code:
For comparison:
If you use std::vector you will need O(n) time building the vector and then O(n) time finding an element.
If you use std::unordered_set you will still need O(n) time to build the vector, but afterwards you can find an element in constant time O(1).
",4,24717934
24715683,"
The problem with the swapping is that you use the traditional way to do:  
However, if you write:  
The default copy constructor, just copies member by member, so just copies your pointer.  So at the end, your temp and your will try to delete twice the same object pointed to. 
Remark on assignment initializer :
For a type T, a statement in form T a = b; is an initializer.
The ISO standard C++ in section 12.6.1 point 1 explains ""a single assignment-expression can be specified as an initializer using the = form of initialization. Either direct-initialization semantics or copy-initialization semantics apply;"" 
",0,24715190
24709035,"
The solution I chose was to make a new empty vector, then iterate over the Json array, inserting each element into the vector. Then I std::sort()ed the vector using the sort_json_array() from the question above (except I changed it to take const references as suggested by Jarod42). Thanks for the help folks!
",0,24706247
24701301,"
You are storing pointers in your vector, not objects. std::sort does not dereference the pointers but compares the actual pointer values. (Technically, this does not have a guaranteed behaviour, because < is used directly on the pointers.)
Solution 1: Store the objects directly in the vector:
Solution 2: Specify a custom comparison functor for std::sort:
",1,24700991
24701184,"
Because you are storing a vector of pointers to Animal you are not giving chance for the operator<() of your class to work. The sort function uses the operator<() for the type of what is in the vector - in this case a pointer to Animal, not an instance of Animal.
Therefore the array is sorted based on operator<() for pointers which as 0x499602D2 says will result in the array of pointers being sorted in ascending address.
If you want it to work this way, either define a custom comparator or use vector<Animal> instead of vector<Animal*>
",1,24700991
24701196,"
Take into account that you don't have a vector with Animals. 
In your code, there is a vector of pointers to Animals. 
Change 
for
And tell us if is working now. 
",0,24700991
24701421,"
I'm assuming it's polymorphism you want to achieve which is the reason why you're using Animal*s instead of stack-allocated Animal objects. Since you are using pointers as the value type of the vector, std::sort()s use of operator<() resolves to the built-in overload which will simply compare the addresses of the pointers instead of your custom operator.
Conveniently, std::sort() takes a predicate as an optional third parameter. You can pass a callable entity to be invoked as the comparator:
If lambda expressions are not supported by your compiler, you can use a function or a class instance with an overloaded operator() instead.
",0,24700991
24673829,"
One call to std::sort should be enough, with a custom comparator function. Something like
Note that it's untested.
",0,24673511
24673954,"
If I have understood the task correctly, you want the numbers to first be grouped by their first characters, and then sorted within those groups.
This appears to do the job:
It first checks the first characters of the strings. If the first characters are the same, it performs numerical sorting.
",0,24673511
24663548,"
You could add a comparator as a type, like the example below:
LIVE DEMO
",5,24663303
24650627,"
Algorithmic building blocks
We begin by assembling the algorithmic building blocks from the Standard Library:

the iterator tools such as non-member std::begin() / std::end() as well as with std::next() are only available as of C++11 and beyond. For C++98, one needs to write these himself. There are substitutes from Boost.Range in boost::begin() / boost::end(), and from Boost.Utility in boost::next(). 
the std::is_sorted algorithm is only available for C++11 and beyond. For C++98, this can be implemented in terms of std::adjacent_find and a hand-written function object. Boost.Algorithm also provides a boost::algorithm::is_sorted as a substitute.
the std::is_heap algorithm is only available for C++11 and beyond.

Syntactical goodies
C++14 provides transparent comparators of the form std::less<> that act polymorphically on their arguments. This avoids having to provide an iterator's type. This can be used in combination with C++11's default function template arguments to create a single overload for sorting algorithms that take < as comparison and those that have a user-defined comparison function object.
In C++11, one can define a reusable template alias to extract an iterator's value type which adds minor clutter to the sort algorithms' signatures:
In C++98, one needs to write two overloads and use the verbose typename xxx<yyy>::type syntax

Another syntactical nicety is that C++14 facilitates wrapping user-defined comparators through polymorphic lambdas (with auto parameters that are deduced like function template arguments).     
C++11 only has monomorphic lambdas, that require the use of the above template alias value_type_t. 
In C++98, one either needs to write a standalone function object or resort to the verbose std::bind1st / std::bind2nd / std::not1 type of syntax. 
Boost.Bind improves this with boost::bind and _1 / _2 placeholder syntax.
C++11 and beyond also have std::find_if_not, whereas C++98 needs std::find_if with a std::not1 around a function object.

C++ Style
There is no generally acceptable C++14 style yet. For better or for worse, I closely follow Scott Meyers's draft Effective Modern C++ and Herb Sutter's revamped GotW. I use the following style recommendations:

Herb Sutter's ""Almost Always Auto"" and Scott Meyers's ""Prefer auto to specific type declarations"" recommendation, for which the brevity is unsurpassed, although its clarity is sometimes disputed.
Scott Meyers's ""Distinguish () and {} when creating objects"" and consistently choose braced-initialization {} instead of the good old parenthesized initialization () (in order to side-step all most-vexing-parse issues in generic code).
Scott Meyers's ""Prefer alias declarations to typedefs"". For templates this is a must anyway, and using it everywhere instead of typedef saves time and adds consistency.
I use a for (auto it = first; it != last; ++it) pattern in some places, in order to allow for loop invariant checking for already sorted sub-ranges. In production code, the use of while (first != last) and a ++first somewhere inside the loop might be slightly better.

Selection sort
Selection sort does not adapt to the data in any way, so its runtime is always O(N²). However, selection sort has the property of minimizing the number of swaps. In applications where the cost of swapping items is high, selection sort very well may be the algorithm of choice.
To implement it using the Standard Library, repeatedly use std::min_element to find the remaining minimum element, and iter_swap to swap it into place:
Note that selection_sort has the already processed range [first, it) sorted as its loop invariant. The minimal requirements are forward iterators, compared to std::sort's random access iterators.
Details omitted:

selection sort can be optimized with an early test if (std::distance(first, last) <= 1) return; (or for forward / bidirectional iterators: if (first == last || std::next(first) == last) return;).
for bidirectional iterators, the above test can be combined with a loop over the interval [first, std::prev(last)), because the last element is guaranteed to be the minimal remaining element and doesn't require a swap.

Insertion sort
Although it is one of the elementary sorting algorithms with O(N²) worst-case time, insertion sort is the algorithm of choice either when the data is nearly sorted (because it is adaptive) or when the problem size is small (because it has low overhead). For these reasons, and because it is also stable, insertion sort is often used as the recursive base case (when the problem size is small) for higher overhead divide-and-conquer sorting algorithms, such as merge sort or quick sort.
To implement insertion_sort with the Standard Library, repeatedly use std::upper_bound to find the location where the current element needs to go, and use std::rotate to shift the remaining elements upward in the input range:
Note that insertion_sort has the already processed range [first, it) sorted as its loop invariant. Insertion sort also works with forward iterators.
Details omitted:

insertion sort can be optimized with an early test if (std::distance(first, last) <= 1) return; (or for forward / bidirectional iterators: if (first == last || std::next(first) == last) return;) and a loop over the interval [std::next(first), last), because the first element is guaranteed to be in place and doesn't require a rotate.
for bidirectional iterators, the binary search to find the insertion point can be replaced with a reverse linear search using the Standard Library's std::find_if_not algorithm. 

Four Live Examples (C++14, C++11, C++98 and Boost, C++98) for the fragment below:

For random inputs this gives O(N²) comparisons, but this improves to O(N) comparisons for almost sorted inputs. The binary search always uses O(N log N) comparisons. 
For small input ranges, the better memory locality (cache, prefetching) of a linear search might also dominate a binary search (one should test this, of course).

Quick sort
When carefully implemented, quick sort is robust and has O(N log N) expected complexity, but with O(N²) worst-case complexity that can be triggered with adversarially chosen input data. When a stable sort is not needed, quick sort is an excellent general-purpose sort. 
Even for the simplest versions, quick sort is quite a bit more complicated to implement using the Standard Library than the other classic sorting algorithms. The approach below uses a few iterator utilities to locate the middle element of the input range [first, last) as the pivot, then use two calls to std::partition (which are O(N)) to three-way partition the input range into segments of elements that are smaller than, equal to, and larger than the selected pivot, respectively. Finally the two outer segments with elements smaller than and larger than the pivot are recursively sorted:
However, quick sort is rather tricky to get correct and efficient, as each of the above steps has to be carefully checked and optimized for production level code. In particular, for O(N log N) complexity, the pivot has to result into a balanced partition of the input data, which cannot be guaranteed in general for an O(1) pivot, but which can be guaranteed if one sets the pivot as the O(N) median of the input range.
Details omitted:

the above implementation is particularly vulnerable to special inputs, e.g. it has O(N^2) complexity for the ""organ pipe"" input 1, 2, 3, ..., N/2, ... 3, 2, 1 (because the middle is always larger than all other elements).
median-of-3 pivot selection from randomly chosen elements from the input range guards against almost sorted inputs for which the complexity would otherwise deteriorate to O(N^2).
3-way partitioning (separating elements smaller than, equal to and larger than the pivot) as shown by the two calls to std::partition is not the most efficient O(N) algorithm to achieve this result. 
for random access iterators, a guaranteed O(N log N) complexity can be achieved through median pivot selection using std::nth_element(first, middle, last), followed by recursive calls to quick_sort(first, middle, cmp) and quick_sort(middle, last, cmp). 
this guarantee comes at a cost, however, because the constant factor of the O(N) complexity of std::nth_element can be more expensive than that of the O(1) complexity of a median-of-3 pivot followed by an O(N) call to std::partition (which is a cache-friendly single forward pass over the data).

Merge sort
If using O(N) extra space is of no concern, then merge sort is an excellent choice: it is the only stable O(N log N) sorting algorithm. 
It is simple to implement using Standard algorithms: use a few iterator utilities to locate the middle of the input range [first, last) and combine two recursively sorted segments with a std::inplace_merge:
Merge sort requires bidirectional iterators, the bottleneck being the std::inplace_merge. Note that when sorting linked lists, merge sort requires only O(log N) extra space (for recursion). The latter algorithm is implemented by std::list<T>::sort in the Standard Library. 
Heap sort
Heap sort is simple to implement, performs an O(N log N) in-place sort, but is not stable.
The first loop, O(N) ""heapify"" phase, puts the array into heap order. The second loop, the O(N log N) ""sortdown"" phase, repeatedly extracts the maximum and restores heap order. The Standard Library makes this extremely straightforward:
In case you consider it ""cheating"" to use std::make_heap and std::sort_heap, you can go one level deeper and write those functions yourself in terms of std::push_heap and std::pop_heap, respectively:
The Standard Library specifies both push_heap and pop_heap as complexity O(log N). Note however that the outer loop over the range [first, last) results in O(N log N) complexity for make_heap, whereas std::make_heap has only O(N) complexity. For the overall O(N log N) complexity of heap_sort it doesn't matter.
Details omitted: O(N) implementation of make_heap
Testing
Here are four Live Examples (C++14, C++11, C++98 and Boost, C++98) testing all five algorithms on a variety of inputs (not meant to be exhaustive or rigorous). Just note the huge differences in the LOC: C++11/C++14 need around 130 LOC, C++98 and Boost 190 (+50%) and C++98 more than 270 (+100%).
",364,24650626
37105668,"
Another small and rather elegant one originally found on code review. I thought it was worth sharing.
Counting sort
While it is rather specialized, counting sort is a simple integer sorting algorithm and can often be really fast provided the values of the integers to sort are not too far apart. It's probably ideal if one ever needs to sort a collection of one million integers known to be between 0 and 100 for example.
To implement a very simple counting sort that works with both signed and unsigned integers, one needs to find the smallest and greatest elements in the collection to sort; their difference will tell the size of the array of counts to allocate.  Then, a second pass through the collection is done to count the number of occurrences of every element. Finally, we write back the required number of every integer back to the original collection.
While it is only useful when the range of the integers to sort is known to be small (generally not larger than the size of the collection to sort), making counting sort more generic would make it slower for its best cases. If the range is not known to be small, another algorithm such a radix sort, ska_sort or spreadsort can be used instead.
Details omitted:

We could have passed the bounds of the range of values accepted by the algorithm as parameters to totally get rid of the first std::minmax_element pass through the collection. This will make the algorithm even faster when a usefully-small range limit is known by other means.  (It doesn't have to be exact; passing a constant 0 to 100 is still much better than an extra pass over a million elements to find out that the true bounds are 1 to 95.  Even 0 to 1000 would be worth it; the extra elements are written once with zero and read once).
Growing counts on the fly is another way to avoid a separate first pass.  Doubling the counts size each time it has to grow gives amortized O(1) time per sorted element (see hash table insertion cost analysis for the proof that exponential grown is the key).    Growing at the end for a new max is easy with std::vector::resize to add new zeroed elements. 
Changing min on the fly and inserting new zeroed elements at the front can be done with std::copy_backward after growing the vector.  Then std::fill to zero the new elements.
The counts increment loop is a histogram.  If the data is likely to be highly repetitive, and the number of bins is small, it can be worth unrolling over multiple arrays to reduce the serializing data dependency bottleneck of store/reload to the same bin.  This means more counts to zero at the start, and more to loop over at the end, but should be worth it on most CPUs for our example of millions of 0 to 100 numbers, especially if the input might already be (partially) sorted and have long runs of the same number.
In the algorithm above, we use a min == max check to return early when every element has the same value (in which case the collection is sorted). It is actually possible to instead fully check whether the collection is already sorted while finding the extreme values of a collection with no additional time wasted (if the first pass is still memory bottlenecked with the extra work of updating min and max). However such an algorithm does not exist in the standard library and writing one would be more tedious than writing the rest of counting sort itself. It is left as an exercise for the reader.
Since the algorithm only works with integer values, static assertions could be used to prevent users from making obvious type mistakes. In some contexts, a substitution failure with std::enable_if_t might be preferred. 
While modern C++ is cool, future C++ could be even cooler: structured bindings and some parts of the Ranges TS would make the algorithm even cleaner.

",14,24650626
24639735,"
The original thrust example you linked performed a row-sum on an underlying data set that had row-major storage.  Your question is essentially how to do the same thing when the underlying storage is column-major.
We can use essentially the same method, but we must use permutation iterators to convert the underlying column-major storage to row-major storage ""on the fly"".
For this, we can borrow the functor I described here.
Here is a fully worked example:
Note that I have also changed the linear_index_to_row_index functor to give me a row index suitably organized for underlying column-major storage (the previous functor returned the index when the underlying storage was assumed to be row-major).  This only involved changing the division operation to a modulo operation and pass R instead of C to initialize the functor, so note the subtle difference.
",3,24632649
24603200,"
Maybe you could use one of the containers, e.g. vector.
you could push_back all the moves into this vector until home is reached.
The size of this vector will be the number of moves.
You can setup a counter array[400] for counting the number of moves into same coordinates.
",0,24602666
24601274,"
So. It's totally not clear why you are hurting yourself with this complicated data structure. You've got a key with two parts. So let's make the key to your std::map a std::pair<T1, T2>.
If we do that, the code becomes incredibly simple.
Source Code:
Output:
Further issues:
There is one discrepancy between my output and the desired output, but I think it's an error in what you expect.
Your current output expects: 
But I'm assuming that the keys should all be sorted properly, which is what my output does.
",2,24601122
24601172,"
I don't see anything in your problem description that calls for a multimap.  Just use std::map instead.
Also, get rid of y_z.  Every time you use it, it appears that you should be using x_y_z[x].
",0,24601122
24584984,"
In ListCompare::operator() you need to take the parameters as const references.
",2,24584946
24561841,"
No, this is not possible. Given an arbitrary array of elements, you must look at each element at least once to definitively state that you have found the minimum element. This means that the necessary time complexity is Ω(n) (see here for more information on Big Omega notation), meaning* that any algorithm that finds the minimum element will take at least c * n operations, where c is constant (in this case, c >= 1).
In other words, if an algorithm took less than n operations, then there must be at least one element in the array that the algorithm did not pass over. Since we have no information about this element (the array is arbitrary), we cannot say that this element is not smaller than the element the algorithm declared to be minimum. So the algorithm is incorrect.
* Note that this is not the formal meaning of Big-Omega notation, but it gets the point across. You can read about the formal definition here.
",19,24561829
24539476,"
I'm interpreting your question as to swap the two adjacent entries of an array based on index. If this is wrong, then please clarify your question with an example for which this is not correct.
",2,24539374
24539417,"
I think the simplest way is to use std::swap with the element with the given index and the element that preceds it. 
For the first element you can use 
Here is an example
The output is
If you do not want to rotate the vector then you can sibstitute the if statement for the following
",0,24539374
24528562,"
If you want to perform a lexicographical sorting by Y coordinate and then X coordinate, you just have to provide a suitable comparison function that really implements a strict weak ordering using. For example
You can also implement the lexicographical comparison manually, but this is quite error-prone.
",7,24528285
24526605,"
As others have said, std::remove_if is the best solution.  If
you're doing this for pedagogical reasons (which I suspect is
the case, given these particular predicates): you're on the
right track.  The only issue is that client_list.erase
invalidates the iterator.  But since it returns an iterator to
the element immediately after the element it erased, you can use
something like: 
And you don't want to call erase after the loop.  The iterator
designates the end, where there is no element to be erased.
",1,24523099
24523612,"
The typical way to go is to use a temporary vector:
This is similar to what Chris suggested in a comment, although that solution would first move elements to the end of the vector and then truncate them from there. I'm not sure if that doesn't change the order on the way, just check the documentation. Depending on what you want, either could do the work though.

If you used a different container like list<> that did not invalidate all iterators in erase(), you could do this:
Note that if you call erase(), you invalidate that iterator still, hence the iterator is first incremented and erase() is called with the former value using the postfix increment.
",0,24523099
24523557,"
I also agree with chris, to using std::remove_if:
But if you want to reinvent the wheel:
",0,24523099
24504934,"
Your algorithm compares the first element of the array with all the subsequent, so when you use:
you swap the first element with the ith element every time the ith element is greater than the first. So at the end of the first pass you have the greatest element in the first position. if you use the < operator, you get the smallest in front.
Then the second pass should compare the second element of the array with all the subsequent and so on, that's why i needs to start iterating from j + 1.
As you saw it is not straightforward to read and understand the code, moreover the algorithm itself is very poor (it looks like a selection sort with some extra swaps). You do not necessarily need to use a std::vector but you really should learn the standard library.
This is the C++11 way to do it:
Compact, clear and extremely fast.
",1,24503920
24441437,"
You're looking for an unordered_multimap. It is an unordered associative container that'll place the key-value pairs into buckets depending on the hash value of the key (int in the following example).
Output:
Live demo

In the comment below you clarified that you receive a vector<MyStr> input, and the container type cannot be changed. In that case, use std::equal_range to find all the elements containing a particular key.
Output:
Live demo

To iterate over each unique key, the easiest way is to use std::unique_copy to create a new container that holds only elements that have unique keys. Then iterate over this container and use equal_range on each key.
Live demo
If the elements are expensive to copy, and you'd rather avoid having to create a new container holding unique elements, you could create your own output iterator that mimics std::back_insert_iterator. Its operator= implementation will take a MyStr const& argument, but push_back only the key from the argument into the unique key container, which would be vector<int> in that case.
Another approach (that I'm not certain will work) that you can use to avoid modifying the input range, and avoid copying the elements to a new range, is to create vector<MyStr *>, where each element points to the corresponding element in the original range. Then repeat all the steps above, except, instead of passing vector::iterators to the algorithms, use boost::indirect_iterator. This iterator will apply an extra level of dereferencing to the pointers in your container, and the algorithms should then work as if they were operating on vector<MyStr> instead.
",2,24441333
25992496,"
The idiomatic way to do that is copy_if (or remove_if) and it's indeed O(n) on an unsorted vector.
The second solution needs to sort the vector, which almost always will make the complexity worse; typical sorting algorithms work in O(n log n) (getting somewhat closer to n^2 in worst cases), and the range-knowing ones work in O(n) anyway.

The rather short and intuitive explanation is that, in any given point of traversal, because you don't know anything about the elements up front, you can't skip them and that remains until you check all of them.
",3,25992439
25988599,"
You should use a struct:
If you don't like that, you could do ""proxy sorting"" by sorting your ID vector first using the names as the proxy for ordering.  In either of these solutions you will need to implement your own predicate for sorting by the name field.
",2,25988374
26893547,"
Try this, it works in my case:
I suspect your model is not sorting because you have to set the target role by setting setSortRole(int role) and appling void QSortFilterProxyModel::sort(int column, Qt::SortOrder order = Qt::AscendingOrder) [virtual].
I hope this solve your problem.
",0,25979982
25974122,"
The answer can be found by considering how to find the absolute lowest sum, and how to find the 2nd lowest sum and so on.
As you only need 20 sums at most, you only need the lowest 20 values from each array at most. I would recommend using std::partial_sort for this.
The rest should be able to be accomplished with a priority_queue in which each element contains the current sum and the indicies of the arrays for this sum.  Simply take each index of indicies and increase it by one, calculate the new sum and add that to the priority queue.  The top most item of the queue should always be the one of the lowest sum.  Remove the lowest sum, generate the next possibilities, and then repeat until you have enough answers.
Assuming that the number of answers needed is much less than Big O should be predominately be the efficiency of partial_sort (N + k*log(k)) * number of arrays
Here's some basic code to demonstrate the idea.  There's very likely ways of improving on this.  For example, I'm sure that with some work, you could avoid adding the same set of indicies multiple times, and there by eliminate the need for the do-while pop.
",3,25973655
25971731,"
Here smallest isn't actually selected yet, put it outside the loop:
",2,25971534
25965737,"
std::sort is a function template. A separate sort instance will be created for each type and comparison operator during compilation. And because for each sort instantiation  the type and the comparator is known at compile time, this allows inlining the comparator function and therefore avoiding the cost of a function call.
",8,25965661
25966357,"
There is no theoretical reason why sort need be faster than qsort.  Some compilers will even inline the function pointer passed to functions 'like' qsort: I believe I have seen gcc or clang do this (not to qsort), and even do so where the function definition was in a different cpp file.
The important part is that sort gets passed the function object as a type as well as an instance.  A different function for each such type is generated: templates are factories for functions.  At the point where it is called, the exact function called is really easy to determine for each such function instance, so inlining is trivial.
Doing the same with a function pointer is possible, but requires inlining from the point where qsort is invoked, and tracking the immutability of the function pointer carefully, and knowing which function it was to start with.  This is far more fragile than the above mechanism in practice.
Similar issues appear with element stride (clearly static when sorting an array, harder to deal with when using qsort) and the like.
",3,25965661
25965758,"
Calling a function via a pointer has two overheads: the pointer dereferencing and a function call overhead. This is a runtime process.
Template instantiation is done by compiler. Pointer dereferencing is eliminated as there is no pointer obviously. Function call overhead is optimised out by a compiler by inlining the call.
",1,25965661
25956140,"
Your problem is in the selection of min:
Throughout this loop, min doesn't change, so the if statement is meaningless. You probably mean to check cardArray[j] against the current minimum:
",0,25956077
25954206,"

My problem is that Pop() takes O(N). Is there a way to make it faster, using the is-prev and is-next predicates?

You need to provide a way to get to the actual modular integer representation of the key, say Integer(x). Then Push and Pop can both be performed in constant time.
If you have the integers and the modulus M, use an array of doubly-linked lists (std::list<T> queues[M]), implement Push(x) as queues[Integer(x)].push_back(x) and Pop as
If M is large and you expect most of the queues to be empty most of the time, then you can use a std::unordered_map<size_t, std::list<T>> to get the same complexity but save space.
An std::deque can also be used; that provides only amortized constant-time for both operations, but may well be a lot faster in practice.
",1,25951665
25952021,"
In C++ your type does not need to have operator< defined to be sorted or to be used in an associative container. The containers and algorithms can take predicates that perform the comparison. For example, to sort a vector using is_pred as the predicate (assuming that it is already a function object or a plain function):
If not, you can write your own functor adapter or a lambda:
The requirements here are that the relationship is-prev has to be a strict weak order.
",0,25951665
25931955,"
",2,25931686
25937793,"
In your code you always do the first half (array, p, q - 1) first. That can lead to stack overflow. Instead always do the smallest of the two subarrays first and force tail recursion.
Doing it this way, one can prove that the maximum number of recursive calls on the stack is log_{2}(n).
",1,25928653
32215998,"
As many of the commenters mentioned, this looks like a great job for an external sorting algorithm, a sorting algorithm that's designed for the case where you can't fit all of the objects to sort into memory at one time. Many sorting algorithms can be adapted for this setting, such as quicksort, bucket sort, and mergesort. If you want a relatively simple option, consider using a k-way external mergesort: split the data apart into a number of ranges such that each range fits into memory, sort each range in memory, and write the results back to disk. Then, do a k-way merge on those ranges: open each file for reading, read one large block of each file at a time, and use a normal k-way merge operation on those blocks. Any time you exhaust all the elements in a block, just read another block out of the file.
",0,25907219
25878100,"
Your call to sort is correct, but your initialization of the array isn't. You're writing
That last statement, arr[x];, has no effect. What you're interpreting as an address being printed is instead a garbage value that just coincidentally happens to be in the first spot in the array.
I think you meant to write
Once you do that, everything should start working.
Even better, try writing this:
Going forward, make sure you crank your compiler's warning level up to maximum. I'm pretty sure that most compilers would detect that your statement had no effect, which would have keyed you into the root cause of the problem.
Hope this helps!
",1,25878040
25855781,"
The predicate for std::sort is going to be called with arguments of type vector::value_type, and not the vectors themselves. Change the lambda expression to 
The const& is not necessary, but you probably want to avoid making unnecessary copies of the multimaps each time the predicate is called. You may also want to check the result of multimap::find before deferencing the result.
And instead of calling vector::resize each time to add a new multimap, you can call
which will default construct a new multimap.
",2,25855702
25836700,"
",0,25836574
25825605,"
A zip file that includes several sort code examples with timing and results from my system. (The hybrid sort, hsort.cpp consumes a huge amount of memory and is not recommended.). Some of the examples, like msortv.cpp, are converted C programs, that use pointers instead of iterators to sort a vector.
rsortv.zip
",0,25823234
25823309,"
You can start by comparing with std STL sorting algorithm. Also, you can compare with sorted containers, e.g. std::set. It may also be interesting to compare with other languages/OSes - I compared sorting an STL vector on Linux using STL sort to similar code on Windows using .NET and C#, C++ was about twice as fast for a randomized vector.
",1,25823234
12195098,"
O(N) is possible using Deque data structure. It holds pairs (Value; Index). 
",23,25819946
12194206,"
it's called RMQ(range minimum query). Actually i once wrote an article about that(with c++ code). See http://attiix.com/2011/08/22/4-ways-to-solve-%C2%B11-rmq/
or you may prefer the wikipedia, Range Minimum Query
after the preparation, you can get the max number of any given range in O(1)
",6,25819946
49600737,"
There is a sub-field in image processing called Mathematical Morphology. The operation you are implementing is a core concept in this field, called dilation. Obviously, this operation has been studied extensively and we know how to implement it very efficiently.
The most efficient algorithm for this problem was proposed in 1992 and 1993, independently by van Herk, and Gil and Werman. This algorithm needs exactly 3 comparisons per sample, independently of the size of T.
Some years later, Gil and Kimmel further refined the algorithm to need only 2.5 comparisons per sample. Though the increased complexity of the method might offset the fewer comparisons (I find that more complex code runs more slowly). I have never implemented this variant.
The HGW algorithm, as it's called, needs two intermediate buffers of the same size as the input. For ridiculously large inputs (billions of samples), you could split up the data into chunks and process it chunk-wise.
In sort, you walk through the data forward, computing the cumulative max over chunks of size T. You do the same walking backward. Each of these require one comparison per sample. Finally, the result is the maximum over one value in each of these two temporary arrays. For data locality, you can do the two passes over the input at the same time.
I guess you could even do a running version, where the temporary arrays are of length 2*T, but that would be more complex to implement.

van Herk, ""A fast algorithm for local minimum and maximum filters on rectangular and octagonal kernels"", Pattern Recognition Letters 13(7):517-521, 1992 (doi)
Gil, Werman, ""Computing 2-D min, median, and max filters"", IEEE Transactions on Pattern Analysis and Machine Intelligence 15(5):504-507 , 1993 (doi)
Gil, Kimmel, ""Efficient dilation, erosion, opening, and closing algorithms"", IEEE Transactions on Pattern Analysis and Machine Intelligence 24(12):1606-1617, 2002 (doi)

(Note: cross-posted from this related question on Code Review.)
",2,25819946
25800672,"
Like Cody said, you'll have to store both values.  As @HgMs indicated you could you a class, or a struct, which is a class with only public data members.  Here's an example:
You can then iterate over the array and look at the number of pancakes each person has eaten using the '.' to access the property.
EDIT: A bubble sort would work fine.
",2,25800268
25787116,"
On each iteration of the outer loop(over eff_size) you should re-set maxpos to 0. Otherwise you have the chance that maxpos goes out of the effective portion being sorted(this happens if the maximum element is last in the effective portion i.e. if maxpos==effsize).
",4,25787039
25759540,"
Following may help, the removal is done by copying value over the previous one:
Live example
",1,25757507
25737702,"
As a nested type, CompareDistanceToGoal has access to all members of MainClass; there's no need to declare it a friend. (Although this is a moderately recent change to the language; a compiler that doesn't implement C++11 might need a friend declaration, friend CompareDistanceToGoal;, to match modern behaviour).
However, since these members are non-static, you can't do anything with those members unless you provide a MainClass object. Perhaps you want to make them static; or perhaps you want to ""capture"" an object:
",3,25737242
25737808,"
It's a bit hard to know what you're trying to do, but this seems to have as much chance of being what you want as anything else... note that MainClass stores a fixedpoint then provides a functor (no need for a nested class) which is then used by sort.  In the code below, it sorts the vector so elements closest to the MainClass fixedpoint are earlier in the vector.  See it running at ideone.com.
",1,25737242
25737272,"
you can capture value manually
and use it

or if C++11 is available, use lambda to capture value
",-1,25737242
25725079,"
Until you've seen the profiler output, to know where the
slowdown is, you can't be sure, but there are a number of points
which seem likely to cause a slowdown to me.  The two most
important are:

your function creates two new strings at each call.  That can
be very expensive, and
you use the two operand form of std::tolower; this function
must extract the ctype facet each time it is called (and you
construct a new temporary instance of the locale each time you
invoke lowercomp. 

My own preference is to use a functional object for the
comparison.  With some compilers, it's faster, but in this case,
it's also a lot cleaner:
Beyond this, there are several other points which might improve
performance:

If you're sure of the lifetime of the locale you're using
(and you usually can be), drop the myLocale member in the
class; copying the locale will be the most expensive part of
copying instances of this class (and the call to
lexicographical_compare will copy it at least once).
If you don't need the localization features, consider using
the tolower function in <cctype>, rather than the one in
<locale>.  This will avoid the need of any data members at all
in the comparison.
Finally, although I'm not sure it's worth it for something as
small as 10K items, you might consider making vectors with the
canonical forms of the strings (already lower cased, etc.),
sorting those using just < on the strings, and then reordering
the original vectors according to that.

Also, I'm very suspicious of the `new
boost::timer::auto_cpu_timer'.  Do you really need dynamic
allocation here?  Off hand, I suspect a local variable would be
more appropriate.
",4,25724250
25724378,"
You can definitely make it much faster.  The solution is to avoid allocating memory, and instead compare the strings case-insensitively by converting one character at a time using tolower() while doing the comparison.  There should be no construction of class objects in the comparison function.  Something like this:
Let us know how fast that is.  :)
",4,25724250
25724539,"
Your implementation strikes me as extraordinarily inefficient.  I see several problems.
You are performing a tolower on both strings within the sort comparator.  Since this comparator will be called on the order of n log n times, you are going to be tolowering two strings about 40K times (?) each.
I would not want to compare strings at all.  Not only is a string comparison orders of magnitude less efficient than other methods (for example integral comparison), it's also error-prone and requires that you scrub the data -- another source of inefficiency.
If however you must compare strings, scrub them before you perform the sort.  That includes tolowering them.  Ideally, scrub the data upon element construction.  Barring that, you could even scrub it just before you call sort.  Whatever you do, don't scrub it within the comparator.
",0,25724250
25722781,"
As stated in the comments, you cannot sort a unordered_map in place because its value_type is std::pair<const Key, T> (note the const!) for an unordered_map<Key,T>. This means that you cannot swap elements in the map, so you cannot sort it. You will need to copy the data into another data-structure like a vector, then you can use some ""home-grown""  version of std::nth_element on it:
You should implement your nth_element with linear complexity on average. (If the number of input values happens to be even, you need to use the mean of both middle-values.)
",2,25722374
25722616,"
An unordered map does not have order(as its name implies) and thus finding the median in an unordered map does not make sense. If you need to find the median - use a auxiliary array and perform some implementation of nth_element algorithm in it. This step would be with linear complexity.
",2,25722374
25628519,"
You'll primarily need a comparator for your sort routine to sort on:
",3,25628422
25628502,"
There's actually an easy way to implement this in stl. There's a sort method that takes a comparator:
So you can do this:
",1,25628422
25628489,"
It's about sorting based on multiple keys. I suggest you study some efficient sorting algorithm, say Quick Sort, then change the comparator to adapt the multiple keys.
For any sorting algorithm that is based on comparing, the easiest way to adapt multiple key sorting is to change the comparing criteria, from a single value to multiple values.
If you are not even allowed to use STL, i.e. you are not allowed to use sort in , here is a post you can start with: Sorting an array using multiple sort criteria (QuickSort)
If you are allowed, just write a comparing function which supports the multiple key comparison and plug it in the sort function. You can check this C++ reference for more details.
An illustration (it's just an illustration to point out how you can plug in the compare function):
",1,25628422
25682635,"
The answer wants a design, so I'll focus on the design of your sorting library, than an implementation
Your sort algorithm can use your custom comparator objects with a member operator() implemented for comparison between two elements. 
Your comparator can be a Linked List of comparators and can call the next comparator if the current one gives a tie. You'll have to ensure that there is always a true and false return though. Or implement something that can create a stable_sort if nothing else.
So the first comparator is number of characters and the second comparator is lexicographical..
This idea is then general enough so that if your requirement changes tomorrow. This can then be reused.
This is on the lines of Chain of Responsibility Pattern. You can templat-ize the comparator after you've got the gist.
Ex: 
",1,25628422
25614485,"
I think the problem is really more subtle that one expected. In you O(N^2) solution you are making no allocation, the algorithm work in place, search the biggest and swap with the current position. This is OK.
But in the priority_queue version O(N log N) (the priority_queue in the internal have a std::vector by default to storage the state). This vector when you push_back element by element sometimes it need to grow (and it does) but this is time you are no losing in the O(N^2) version. If you make the following little change in the initialization of the priority_queue: 
priority_queue<int> pq(a.begin(), a.end()); instead of the for loop
The time of the O(N log N) beat the O(N^2) as it should by a fair amount. In the proposed change there is still allocation in the priority_queue version, but is only one time (you are saving a lot of allocation for big vector sizes, and allocation is one of the important time consuming operation) and maybe the initialization (in O(N) could take advantage of the complete state of the priority_queue, don't know if the STL really does this).
Sample Code (for compile and run):
In my PC (Core 2 Duo 6300) the output obtained is:
",2,25613533
25613679,"

the 3rd column is larger than the second for the array sizes considered.

The ""Big O"" notation only tells you how the time grows with the input size.
Your times are (or should be)
But it is entirely possible that C is much larger than A, leading to a higher execution time for the linearithmic code when N is small enough.
What makes linearithmicity interesting is that if your input grew from 9600 to 19200 (doubling), your execution time should approximately quadruple, going to about eight seconds, for the quadratic algorithm, while the linearithmic algorithm should little more than double its execution time.
So the execution time ratio would go from 2:8 to 8:16, i.e. the quadratic algorithm is now only twice as fast.
Double again the size of the input and 8:16 becomes 32:32; the two algorithms are equally fast when confronted with an input of around 40,000.
When tackling an input size of 80,000, the ratio is reversed: four times 32 is 128, while twice 32 is only 64. 128:64 means that the linearithmic algorithm is now twice as fast as the other.
You should run tests with very different sizes, maybe N, 2*N and 4*N, in order to get a better estimate of your A, B, C and D constants.
What this all boils down to is, do not blindly rely on the Big O classification. Use it if you expect your input to grow large; but for small inputs, it may well be that a less scalable algorithm turns out to be more efficient.
For example  you see that for small input sizes, the faster algorithm is the one running in exponential time, which is hundreds of times faster than the logarithmic one. But as soon as the input size grows past nine, the exponential algorithm's running time skyrockets, while the other doesn't.
You might even decide to implement both versions of an algorithm, and use the one or the other depending on input size. There are some recursive algorithms that do exactly this, and switch to iterative implementations for the last iterations. In the pictured case, you could implement the best algorithm for each size range; but the best compromise is go with two algorithms only, the quadratic one until N=15, and switch to logarithmic afterwards.
I found here a reference to Introsort, which 

is a sorting algorithm that initially uses Quicksort, but switches to
  Heapsort when the recursion depth exceeds a level based on the
  logarithm of the number of elements being sorted, and uses Insertion
  sort for small cases because of its good locality of reference, i.e.
  when the data most likely resides in memory and easily referenced.

In the above case, the Insertion sort exploits memory locality, which means that its B constant is very small; a recursive algorithm is likely to incur higher costs, and have a significant value of C. So for small datasets, more compact algorithms do well even if their Big O classification is poorer.
",12,25613533
25613776,"
You have a O (N^2) algorithm running 4 times faster than a O (N log N) algorithm. Or at least you think you do. 
The obvious thing to do would be to verify your assumption. There's not much that you can conclude from sizes 9600, 9800 and 10000. Try sizes 1000, 2000, 4000, 8000, 16000, 32000. Does the first algorithm increase the time by a factor 4 each time as it should? Does the second algorithm increase the time by a factor slightly larger than 2 each time as it should? 
If yes, then the O (N^2) and O (N log N) look right but the second one has massive constant factors. If no, then your assumption about the execution speeds are wrong, and you start investigating why. O (N log N) taking 4 times longer than O (N * N) at N = 10,000 would be highly unusual and looks very suspicious. 
",2,25613533
25613782,"
Visual studio must have an extreme overhead, for non optimized / debug-level std:: code, in particular the priority queue class. Check out @msandifords comment. 
I tested your program with g++, first no optimizations.
Notice my vector times are close to yours. The priority queue times on the other hand are magnitudes smaller. This would suggest a debug-friendly and really slow implementation of the priority queue, and as such contribute in a huge part to the constant mentioned by hot-licks on the comments. 
Then with -O3, full optimization (Close to your Release mode).
Now to see if this is reasonable you can use the simple formula for the complexity. 
Calculate for N = 10000
A perfectly cromulent result, consistent with O(N²) and a good implementation. 
The same can of course be made for the O(NlogN) part.
",2,25613533
25605256,"
You probably meant 
which actually returns the number of elements in the std::vector container.
Here the problem is that the vector s1 is initialized as empty, so that you cannot change the i-th value (because it does not exist). Give the std::vector directly the correct size.
",2,25605186
25605224,"
Here's one problem:
That gives you the size of the vector<int> class; not the number of elements in this vector object. You want:
Here's another problem:
s1 is empty, so s1[i] is not valid. Instead, you must either:

initialise the vector with the correct size, vector<int> s1(size);, or
use push_back to grow the vector, s1.push_back(stoi(sequence(i));

If you're using push_back, you might like to do s1.reserve(size) first to avoid unnecessary memory allocations.
",1,25605186
25607583,"
One elegant solution would be:
As you can see, this solution relies on std::sort. The two first parameters are the begin and end iterators of the vector. This third parameter must be a comparator used to determine the sort order (ascending or descending). Here I used a lambda function, but it could be a functor.
Here you compare the left hand-side operand (aka lhs) with the right hand-side operand (aka rhs).
Instead of a lambda expression, you could have used a functor, which is basically a class that implements:
Depending on how big your vector is going to be, you might want to avoid copying the input vector and instead directly sort this vector in-place (remove the const-ness of 'sequence' and apply std::sort to it).
",0,25605186
25616676,"
The simplest thing is to keep 2 collections, the vector and the set (or unordered_set). This will consume more memory but will use the set to check for duplicates (in O(log N) time) and the vector to maintain order.
The set can also alternatively contain the position in the vector of the item and have as a predicate v[i] < v[j]. Slightly complicated as you'd need to store a reference/pointer to your vector in the special predicate. However it can be done and will use potentially less memory as you only have one collection of strings and the other is of ints. In addition it acts as an index, being able to quickly locate where a particular item is.
",6,25602882
25603462,"
You're attempting to change a fundamental design implementation. Instead you should probably rethink your own design and not try to go against the grain of the standard library.
My solution would be to use a std::vector<std::string> and depending on what your program aims to do either:

Check for a duplicate before pushing onto the vector

or

Create a function to return a new vector of the unique names

Either of these implementations will retain the insert order and you'll be able to handle duplicates on your own terms.
Here is the second version:
Yields:
",1,25602882
25603146,"
First question: No. As per cplusplus.com: 

Sets are containers that store unique elements following a specific order.

Second question: you would need to have 2 points of data to do that. The first would be your actual string, the second would be a sort of 'insertion index', so you can store the order of insertion.
So basically, you could do it if you put std::pair in your std::set and basically increment the number you put in the std::pair. However, once you do that, it means each std::pair will be unique, meaning the use of 'std::set' is gone.
The above already sounds way too complicated, so why not go with a more suitable container?
You could for example use an std::vector and remove doubles upon insertion.
If that's too slow (O(N) insertion), you could have an std::vector for the in-order storage, and keep an std::set next to it to be able to quickly check uniqueness.
",0,25602882
25603189,"
From your example, it seems that the equal values follow each other.
If this is the case, there is no need for sophistication: you can start filling a new array and copy the elements one by one unless they are the same as the previous. This is a simple O(N) process.
",0,25602882
25603837,"
Instead of std::set use std::unique
",0,25602882
25604848,"
After reading all comments and answers, I think the most direct way to answer my own question is to use std::vector and std::unique. 
Point to note is:

I have a list of names that is small. Should not be more than 2000 names.
Each name appears in a cluster. If Mary appears 2 times, it will not appear any more in the rest of of the list.
I only need to get a set of unique names, but keep the initial ordering. 
After getting that unique set, I do not need to do any more operation (insert/remove/etc) to the set.

So here is my coding:
And so the output will be (what I want):
That is it. Thanks for those contributing. Feel free to comment, especially about the efficiency.
",0,25602882
25594134,"
I would probably do something like:
Edit based on edited question: 
Given that your a vector is substantially larger than your b vector, there's a second question I'd consider: do you need a to remain sorted after this is complete?
If rearranging elements in a is allowed, then you can improve speed substantially: instead of doing a remove/erase to remove the items from the middle of a, you can swap the item to be removed with the last element of a, then erase it from the end (which has constant complexity). This makes the removals constant, so the overall complexity is O(N log M) (where N = b.size() and M = a.size()).
If you do have to maintain order, you can still improve speed somewhat: instead of removing elements from a, then immediately erasing the removed element, do an std::remove_if to find all the elements of a that need to be removed, then once (when that's done) do one erase to remove all those elements.
As it stands right now, you're using a separate call to remove for each element of a that you remove. All the elements of a after each removal point are copied (or moved, if applicable) for each remove. That means if you remove 10 elements from a, you're copying (on average) half of a 10 times over. By using a single remove_if instead, you're copying each element of a only once.
Unfortunately, remove_if doesn't give you a good way to take advantage of the ordering in b. You can use a binary search, which helps some, but not as much as you'd like.
If you don't mind writing your own loop, you can take full advantage of the fact that both a and b are sorted, something like this:
If you wanted to make this maximally generic, you'd probably want to change it to only use post-increment on the iterators, allow the user to pass a comparison operator instead of using < directly, etc. These are left as the dreaded ""exercise for the reader"".
It's probably worth noting that this is basically the same algorithm as set_difference normally uses, just with minor adjustment to operate in-place. This does cause a substantial change in the interface though: since it can (and does) create duplicate elements in the collection, it can be applied to a sorted sequence (vector, deque, hash, etc.) but not to an associative container ([unordered_][multi_](set|map)).
Since this traverses a and b exactly once each, it's clearly O(N + M), but since we're starting with the idea that M(=b.size()) is small, it's effectively O(N)
Note: the test code uses C++11 features heavily (e.g., to initialize the two vectors) but I believe the algorithm implementation itself should be fine in C++98/03.
",17,25594036
25594104,"
Rather than removing elements, just add items to a new vector. Assuming your inputs are 'original' (A) and 'toRemove' (B), just create iterators for both original and toRemove: 
If the next item in original matches the next item in toRemove, drop it. Otherwise, copy it to the result. 
If it's greater than the next item in toRemove, go to the next item in toRemove and run the comparison again.
This way, you're only iterating over each list once, and not constantly copying array values around during a 'remove' operation.
This solution will run in O(A+B), which is faster than your current (and proposed) solution.
For comparison purposes: 
Your existing solution which is roughly O(A*A*B) (A for remove, A for non-optimized search, B for iterating over B).
Your edit suggests doing a binary search to remove the elements; this will only improve your original solution to O(logA*A*B) (A for remove, logA for optimized search, B for iterating over B).
",0,25594036
25597901,"
Built in functions in the vector header are faster. For example,

vector  vect;

and after adding all the elements, you could use

sort(vect.begin(),vect.end());

That would sort the list in ascending order. For descending, you might have to perform 

reverse(vect.begin,vect.end());

on the Sorted List.
",-1,25594036
25566052,"
You have a simple bug in the swapping part of your code:
Like others already noted, the code could be much cleaner, which would also help to avoid such errors (they would be easier to spot at least).

how do I make sure that if they have the same surname then the precedence of their firsnames should be used to determine their order? –  Jdons

In this case, i suggest to use a helper function for determining the order of two nodes:
(This is not the most efficient way and one could use operator< instead, but I wanted to keep things simple)
Usage in your original code:
",2,25565309
25565669,"
First of all I would make the code more readable by using more descriptive variables.
Secondly I would use STL functions and containers to solve this bubble sort algorithm. 
Assuming you have to use your own implementation, I would suggest to review the string::operator>(...) function that you are using here. You can post it here if you want so we can review it.
Hope this helps.
Carles.
",-2,25565309
25564305,"
I can't reproduce what you observe.
Here is a cleaned version of your code which seems to work fine (gcc and clang).
",3,25549048
25539646,"
Here are two failed test cases.
In the first, your code makes no swaps, because K >= N. In the second, your code swaps 5 and 4 when it should spend its third swap on 3 and 2.
EDIT: the new version is still too greedy. The correct output for
is
.
",0,25539423
25532368,"
The problem here is that in C++ (as in C) you have to define all your variables in compile time, i.e. when you write your code. And in your example you have text file with arbitrary count of lines, so you dont really know about it's content when you write code. This is why you cannot have very own variable for every line of your file.
So, if you need to store information about every line of your file, you can do this. First, you define format in which your information (i.e. string with name + integer) will be stored. This is the place where you most likely will need struct or something like that. struct and class are the way to agregate diffirent variables in one structure (essentially, they are more than just that, but that's not the point at the moment). If you wrote smth like
that means that you just defined data type called Data, that have fields ""name"" and ""ratio"". So you can use it like this:
After this, you need some entity that can let you to store many of this Data entries. For example, you could use arrays. Imagine you will use static array here:
Problem here, as you can see, is that you cannot know line count of your textfile when you write code. So you can you dynamic arrays with this code:
This will work, provided you somehow managed to know count of lines if your file before actual work is done, which is not the point usually.
Also raw dynamic arrays are not really nice to use because of that new/delete function pair you have to worry about. So, here in action come classes called containers from Standart Template Library. This classes provides you way to just insert data in it, and operate with this data in many ways. This is the classes ""map"", ""unordered_map"", ""multimap"", ""vector"" and others from former answers. Easiest of them to understand is vector, and you can read about it here. Others (say'd, map) should fit better to your task.
Finally, to sort array (or container) of such data, you can use functions called algorithms from Standart Template Library. They provide generic way to operate on data in the way you need.
You can read more here.
Not sure I need to say more here, explore links, continue your studies, good luck!
",5,25529927
25530555,"
There is probably a more clever way to do this but since you're a beginner here's what I suggest:
Use a std::multimap<int, std::string> to serve as a lookup table for a name (stored as a std::string) given the int note. You want a std::multimap instead of a std::map in case some names have the same int value. Separately, store all the numbers in a std::vector<int> and call std::sort() to sort the std::vector<int>. Now they're sorted, and you can use std::multimap::find() to look up the name(s) associated with each int value.
",2,25529927
25529947,"
Use std::unordered_map<string, int>.
//Usage:
",0,25529927
25530605,"
//To check it out:
",0,25529927
25530125,"
std::sort requires that the element type be MoveConstructible.
The requirements for MoveConstructible state that the expression T u = rv; must be valid. However, this expression performs copy initialization and requires that there is a non-explicit copy or move constructor.
In this case, the copy constructor is explicit, and declaring it means that there is no implicitly-declared move constructor. Therefore, the expression is invalid, and the class A is not MoveConstructible.
",12,25529772
25529766,"
You array is initially sorted, at least generate it in reversed order to make your tests meaningful (or you could use some random generators, too) :
Then, your logic is flawed: you can't stop a bubble sort half the way (a bubble sort does not guarantee you that the previously moved elements won't be moved again, that's why it needs N^2 iterations), instead, you need to make it iterates over n/2 elements instead of n.
Something like :
",0,25529379
25518535,"
Let's see compilation errors (next time add it in a question!):
Here compiler informs your, that it is hard to decide, which implementation of partial_sort must be called. There are two possible options, so compiler can't be sure, which one is right. You need to avoid such uncertainty. In this case you can rename wrong declaration (i.e. remove all lines from 'template //class' to '//Function prototype').
And this is just warning. Here you declared variable num, but never use it. It is better to remove such lines from a code to simplify it.
",0,25518466
25516727,"
The best way to do this would be to create a list that contains both sets of information you want to sort and feed in a custom sorting function.
For instance:
In the general case, it's always better to manage one list of a complex datatype, than to try to separately manage two or more lists of simple datatypes, especially when they're mutable.
",0,25516540
25516917,"
Some more improve way:
First some notes:

It's recommended to storage category name and items together, for clarity, easy of read code, etc...
It's better use std::vector instead of std::list (see Bjarne Stroustrup opinion)
The code load the file with the format specified in your question, storage in the vector the info pair.
Use std::sort function to sort only by items number (the categories with the same items would be in any order, if you would like to sort for category name the categories with the same items change the lambda body to return std::tie(left.items, left.name) > std::tie(right.items, right.name);.
Added a version with info split, in one collection items and index (to correlate items with name) info, and in the other names info.

Code:
Output obtained:
",0,25516540
25518064,"
Lists do not support random access iterators, so this is going to be a problem, since a list can't be permuted based on a vector (or array) of indices without doing a lot of list traversal back and forth to emulate random access iteration. NetVipeC's solution was to use vectors instead of lists to get around this problem. If using vectors, then you could generate a vector (or array) of indices to the vector to be sorted, then sort the vector indices using a custom compare operator. You could then copy the vectors according to the vector of sorted indices. It's also possible to reorder a vector in place according to the indices, but that algorithm also sorts the vector of indices, so you're stuck making a copy of the sorted indices (to sort the second vector), or copying each vector in sorted index order.
If you really want to use lists, you could implement your own std::list::sort, that would perform the same operations on both lists. The Microsoft version of std::list::sort uses an array of lists where the number of nodes in array[i] = 2^i, and it merges nodes one at a time into the array, then when all nodes are processed, it merges the lists in the array to produce a sorted list. You'd need two arrays, one for each list to be sorted. I can post example C code for this type of list sort if you want.
",0,25516540
25506213,"
To get the intersection of two sorted ranges, std::set_intersection can be used:
This looks a lot cleaner than your solution which is too confusing to check for correctness.
It also has optimal complexity.
The standard library algorithm set_intersection may be implemented in any way that uses 

at most 2·(N1+N2-1) comparisons, where N1 = std::distance(first1, last1) and N2 = std::distance(first2, last2).

first1 etc. are the iterators defining the input ranges. You can check out the actual implementation in the source code of your standard-library if it is open source (like libstd++ or libc++).
",3,25505868
25509185,"
This assumes you know the number of containers you are intersecting:
To complete simply implement:
The first is easy (use indexes trick, compare pairwise, check that you returned true if the tuples are empty).
The second is similar.  It should be easier if you compare std::get<i>(its) == std::get<i+1>(its) I think rather than compare all to zero.  A special case for empty might be required.
advance_all is even easier.
The last is the tricky one.  The requirements are that you advance at least one iterator, and you do not advance the one that dereferences the most, and you advance iterators at most once, and you advance the most you can up to efficiency.
I suppose the easiest method is to find the greatest element, the advance everything less than that by 1.
If you don't know the number of containers you are intersecting, the above can be refactored to use dynamic storage for the iteration.  This will look similar to your own solution, except with the details factored out into sub functions.
",1,25505868
25496850,"
The error in your bubble sort is in your comparisons after the swaps.
After comparing b < hold, and swapping, your hold contains the previous number value thus you are comparing using the wrong number.
In your case, there is no point using hold for comparison, instead just compare b < a, c < b and so on.
",0,25496721
25495468,"
A simple bubble sort implementation. That you can use to sort instead of using 
std::sort. Although this is slower this algorithm is O(n^2)
NOTE: THIS DOES NO ERROR CHECKING THIS IS ASSUMING PERFECT INPUT
",-1,25495380
25495510,"
Perhaps you're confused about the end parameter to sort. It's not the last element of the sequence, it's one past the last element. Therefore you're trying to sort elements 3, 4, and 5, which are already sorted - you won't see any change.
",4,25495380
25487197,"
You don't have to call std::sort, what you need can be done in linear time (provided the indices are from 1 to N and not repeating)
But of course for this solution you need the additional new_vec vector.
If the indices are arbitrary and/or you don't want to allocate another vector, you have to use a different data structure:
",3,25486870
25487018,"
Maybe there is a better solution, but personally I would use the fact that items in a std::map are automatically sorted by key. This gives the following possibility (untested!)
",1,25486870
25487892,"
[Not sure this fits your usecase, but putting the elements into a map  will store the elements sorted by key by default.]
Coming to your precise solution if creation of the new vector is the issue you can avoid this using a simple swap trick (like selection sort)
",0,25486870
25492408,"
The generic form of this is known as ""reorder according to"", which is a variation of cycle sort. Unlike your example, the index vector needs to have the values 0 through size-1, instead of {4,3,2,1,5} it would need to be {3,2,1,0,4} (or else you have to adjust the example code below). The reordering is done by rotating groups of elements according to the ""cycles"" in the index vector or array. (In my adjusted example there are 3 ""cycles"", 1st cycle: index[0] = 3, index[3] = 0. 2nd cycle: index[1] = 2, index[2] = 1. 3rd cycle index[4] = 4). The index vector or array is also sorted in the process. A copy of the original index vector or array can be saved if you want to keep the original index vector or array. Example code for reordering vA according to vI in template form:
Simple still would be to copy vA to another vector vB according to vI:
",0,25486870
25482898,"
try this:
So, you will move linear over your vector and count all numbers there exist. As result you will receive how many 1 you had, how many 2 you had and etc, i.e. it will be as sorted.
UPD: as KillianDS wrote, I mean counting sort. It's the fast one.
",1,25482808
25483562,"
Well since the answer was basically given, example code. There's no need to copy data from the original array; it can be generated from the data in the histogram, called a variant algorithm in the wiki counting sort variant section:
",1,25482808
25482921,"
May be they wanted to hear about radix sort. 
",0,25482808
25482952,"
It seems counting sort is the most suitable algorithm for this problem, it's O(n), stable, and easy to implement. http://en.wikipedia.org/wiki/Counting_sort
",0,25482808
25476064,"
It seems, you are looking for std::min_element() to locate the shorted element and std::rotate() to move elements within the std::vector<vec2>.
",3,25475947
25476066,"
Use std::min_element to find the element with the shortest distance (that is, a min with a custom comparer), and use std::rotate to perform an in-place rotation.
Something like :
",3,25475947
25451697,"
Because you use if (word[i] > word[i + 1]) you must stop your loop one prior to the end... and you need count or i (not both); that is
or you could use
",1,25451470
25451708,"
I would do that way:
Demo
If you want to implement yourself a O(n²) sort algorithm, you may do:
or a resursive one:
",0,25451470
25420212,"
Use std::stable_sort (to preserve your insertion order) with a custom comparer :
",5,25419965
25375685,"
Use std::sort (or std::stable_sort if you want to preserve the order of elements) with a comparison function:
where caseInsensitiveComparison is the case-insensitive comparison function, a binary function returning whether the first argument string should go before the second in the dictionary. As pointed out by earlier comments, look at this question about how to implement case-insensitive comparisons.
",0,25375490
25374495,"
First, problem #2 can be reduced to problem #1. Replace each string with a string consisting of the first letter and the last letter, separated by space; e.g. AEIOU becomes A U. Then it's clear that solving problem #1 on these new strings will also give the solution to problem #2 on original strings.
Second, this is a problem of finding a Hamiltonian path in a directed graph. The graph in question consists of the input strings as vertices, with an edge drawn between every pair of vertices of the form X Y and Y Z.
The problem, as stated, is underspecified: it's not clear what is considered the right answer when the graph doesn't contain a Hamiltonian path. Your example has Pamela Luisa followed by Pedro Luis, which doesn't satisfy the requirement. One possible interpretation is that of finding a minimum path cover.
",2,25373351
25373527,"
There is probably a better approach than this, but I would start by going through all of the words and assigning them numbers 0 to n.
Then each line can be represented as an ordered pair of numbers.
Then if there are k lines, create a (k x k) matrix of bools.
In each spot put true if the second word in the pair for that column matches the first word in the pair for that row, and false otherwise.
At that point you should be able to implement a simple backtracking search to find some sequence of lines (x_0, x_1,...) such that matrix[x_i][x_{i+1}] = true for all i.
Hope that helps.
If you can solve the first problem, the second should be very similar.
",0,25373351
25356221,"
I took a look at your code, and the majority of it is correct from my testing. I don't want to do your coursework for you but maybe a couple of hints in the right direction will help.
For your original question about the segfault that you got, PaulMcKenzie, Jim Lewis, and Tahlil are right, merge_sort() needs a base condition (base case) to check whether or not the recursion should continue, so it doesn't run forever and/or until your computer runs out of memory (which is what is happening in your case). In general, any recursive function should have a base case.
Also, you should take a look at your merge function as well. It has all the parts of a correct merge function, but some parts of it run a bit earlier/more often than you want them too. I don't want to give too much away since it's for class, but if you fix the segfault problem and are still getting strange answers, take a look at it.
",0,25355884
25343884,"
Here:
Or:
Then just sort it with std::sort as you’re doing.
",4,25343863
25343909,"
This invalidates it. Scrap the iterator, and just use push_back.
Alternatively, insert returns a valid iterator to the object that was just inserted, so you could also do this:
But that's unnecessarily complicated if you are just inserting at the end of the vector. Here's an option which replaces your entire loop, if you're a fan of one-liners:
",3,25343863
25343951,"
Try the following
",1,25343863
26708620,"
You should declare and define Time::gethours() as constant member function.
To sort vector<Result*>, you need to

Change Result::operator<() to take const Result& rather than Result& as parameter
Define a comparison function for Result* which looks like static bool cmpResultPtr(const Result* lhs, const Result* rhs) { return *lhs < *rhs; }
Call sort(results.begin(), results.end(), cmpResultPtr);

The function cmpResultPtr() could be defined in the .cpp file, before the definition of Race::sortResults().
",3,26708513
26708702,"
You declare operator< to be const but Time::getHours, which it calls, doesn't have the same declaration. To the compiler, this means getHours could change the value of the time member which violates the constness of operator<.
",1,26708513
26697523,"
The comparison function taken by std::sort() can be a function object holding suitable information. For example:
",3,26697405
26697496,"
You need to create a functor as your comparator. A common way to make a functor is using a struct with the call operator overloaded:
If you compiler supports C++11 you can simplify the std::sort() parameters:
Wikipedia has a good example of how to address this issue: Function Object:C/C++
",3,26697405
26695746,"
You have several appoaches that you could take:

Store the keys as integers after converting QString to an integer.
You can use the compare class for std::map as per the example:
You can try to use specialize this template function that QMap uses for the comparison.

main.cpp
main.pro
Build and Run
Output
",1,26680592
26712718,"
First, you probably don't want std::list, but std::vector.
Then use std::lower_bound to find where to insert, and if the
resulting vector contains more than the number of elements
you're interested in, std::vector<>::pop_back to get rid of
the extra one.
",5,26675908
26676026,"
Thanks for you comments. As my post does not state a single well defined question, but it was rather demonstrating my ignorance of how to solve my problem ;), I want to post my conclusions and a working example...
First of all, thanks for clarifying, that ""std::list is the container to use when it comes to sorting""
is not true. As pointed out e.g. by James Kanze, std::vector does the job as well. Second, I really do not have to ""sort"" the vector if I just ""insert"" new values at the right place. Further, there was no objection towards my idea of how to get the indices also sorted and here is my solution:
",0,26675908
29105646,"
Sorting is a bad idea.
Instead use a std::vector<int> buffer(count); to store a std::make_heap.
Then do:
which takes a heap in the form of a vector (an empty vector is a heap), and adds an element, then pops any elements more than the heap limit.
This will work for any T that has an operator<.  There are custom comparator versions of push_heap and pop_heap as well.
",0,26675908
26823749,"
so after looking it over I found a compiling error. The ""printDatabase"" definition and declaration do not match up. The declaration states the function as taking const parameters but the definition does not. 
However once that is fixed there is the error at runtime. The issue is here
student1 is being index at NUM_GRADES, which is the length of the student1 array. However since array indexing starts at 0 the last index would be NUM_GRADES - 1. So writing out of bounds of the array is taking place here. Although I believe looking at the code the behavior sought after is to index with i
",0,26643575
26638090,"
If you are using C++11 - then use :


#include <chrono>
#include <iostream>

int main ()
{
  using namespace std::chrono;

  time_t start = system_clock::to_time_t(system_clock::now());

  for (auto i = 0; i < 100000000; ++i)
  ;

  time_t difference = system_clock::to_time_t(system_clock::now()) - start;

  std::cout << ""Difference in seconds: "" << difference;

  return 0;
}



For nanoseconds use the same system_clock::now() or other clocks if presented and std::chrono::nanosecods type. Conversion between time types is made using std::chrono::duration_cast.
",0,26638033
26638230,"
Try to write it like this:
I think it takes you less than 1 second so if you have e.g. endTime - startingTime = 500 and divide it by 1000 result is 0.5 but since it is converted to int result is 0. (double) prevent conversion and show you 0.5 or something similar.
",0,26638033
26638424,"
Not very professional but works
",0,26636770
26637303,"
The usual way to do this is by using loops.
For example, to traverse an array, printing every element, we could use a loop like:
All of the problems you mention, except sorting, can be done using a simple loop like the one above.  You'll have to do your own bookkeeping in order to solve the problems, but it shouldn't be too difficult.
As for sorting, that's a more challenging problem.  You might start with the wikipedia article to see how that is handled.  You probably want to try implementing selection sort.
",1,26636770
26637286,"
You can use bitset sort since the range of values of the array is limited to 1-100, and there is no repetition you can have a bitset array of 100 ints where each index specifies can be a 0 (that number isn't in the array) or a 1 (the number is in the array).  For example the array [1, 5, 3] can be represented by the bitset array [1, 0, 1, 0, 1].  
pseudo code:
",1,26636770
26638082,"
Well, I have not checked this code and I'm sure it has some errors in it, but hopefully this will at least give you some ideas and a good base to go off of:
I'm a C-programmer so this is a rather C-style answer.
Some additional information that might be helpful can be found at:

http://www.sanfoundry.com/c-program-sort-array-ascending-order/
http://www.programmingsimplified.com/c/source-code/c-program-bubble-sort
http://en.wikipedia.org/wiki/Sorting_algorithm

The Wikipedia page (last link) might seem a little overwhelming, but there is a lot of great content on it.
I hope this will be of some help to you. Again, I'm not sure if the code I included will work properly. It's merely meant to convey the general idea.
",0,26636770
26613655,"
That's not how you use std::sort! Replace:
with:
",0,26613538
26614089,"
",0,26613538
26598318,"
Change your test value to hold correct expressions:
and
",2,26598263
26598324,"
Your static variable is probably not being set to 0 when you expect it to. Make it a global variable. 
Also, why are you doing the work when you make the recursive calls instead of when the call is made? It would be so much easier to do it one time instead of two.
",0,26598263
26587273,"
(Since you already have the data at the print point, I interpreted the question as: I don't know how to convert the array in order to pass it to the function)
Except that std::array is a contiguous memory storage and that you might use a uberhack like the following (not guaranteed to work):
I would feel a lot safer if you used a conversion loop that guarantees data consistency:
Output:
Live Example
",0,26587100
26575599,"
I am an idiot (fact!)
Qt already provided all I needed, it was just a stupid mistake on my side. Two things, really:
I wanna thank you for your kind and fast answers, but the problem existed between chair and keyboard this time.
",2,26574923
26575134,"
According to the QSortFilterProxyModel documentation, you can provide your own implementation of lessThan(). http://doc.qt.io/qt-5/qsortfilterproxymodel.html#lessThan
If for some reason that doesn't work as expected, you can always sort the dates as strings if you format those dates using ISO8601 (YYYY-MM-DD). This is how I typically choose to store (and later sort) dates when dealing with databases.
",1,26574923
26575128,"
I think that you should use Custom Sort/Filter Model. You should ""teach"" class how to compare it. Take a look of this example: http://doc.qt.io/qt-5/qtwidgets-itemviews-customsortfiltermodel-example.html
I think that the most useful code for you, you can find here:
QDateTime already has overloaded operator <.
",1,26574923
26569817,"

Make a pair vector that contains both A & B.

Create your custom comparator to sort the pair vector.

Sort the pair vector.

All sorted A's can be accessed using order[i].first.

",3,26569801
26569897,"
One option is to store your array of ""scores"" in a std::map<MyObject, int> scores instead. Now you can create a comparator
Now you simply do
Unfortunately, this requires that either scores is a global variable or scores and compare are packaged into the same class.
Perhaps a better approach is to use a lambda:
This allows you to declare scores as a local variable and capture it in the lambda.
One drawback to this solution is that, in order to use the MyObject class as a key for std::map, you must implement operator<() for the class (or a comparator to pass to the std::map constructor). Fortunately, you can write this as a global function and don't have to change the class itself. However, this requires comparing the objects directly in some way.
",3,26569801
26560410,"
In your call to printf() you use a format specifier of %d which means signed integer. The actual value passed is an unsigned integer and the correct format specifier for that is %u. Fix the printf() call and test again.
Here is a reference for printf() and its formatting options.
",0,26559556
26545393,"
I think the vector plus heap is like what you are looking for.
The insertion is fast. But each time before you want to access item which is not the biggest, you have to sort the heap, since the heap only give you the biggest. And after that and before new insertion you have to call make_heap to make the vector a heap again.
",1,26544610
26546506,"
No, such structure does not exist in standard library. I don't think it exists in boost either, but looking at Boost.MultiIndex wouldn't hurt.
Otherwise such structure is conceptually simple—some kind of balanced search tree (a-b or red-black probably) that additionally needs to maintain number of children in it's nodes (which probably makes a-b tree with higher a and b more suitable than 2-3 or red-black. But there does not seem to be anything to help you implement it.
",0,26544610
26546398,"
You have to make it yourself.
Create a wrapper around a std::vector. Add methods as required that delegate to the vector, for insert methods, call std::upper_bound to find where to do the insertion.
",0,26544610
26526163,"
First of all, QtAlgorithms is mostly deprecated and you should not use it. Please use std::sort instead as recommended by the Qt documentation.
Otherwise, you will need to implement the actual comparison functionality as you seem to be working with custom types. Naturally, the generic algorithm cannot know how to compare to custom items like that. That is what the error is trying to indicate.
Then, you will either need to pass that function to the sorting algorithm as the third argument, or name it operator<. I prefer being explicit, especially since then you can restrict your comparison to the class where it is tied to anyway.
Therefore, I would write something like this:
main.cpp
main.pro
Build and Run
Please refer to the documentation for details.
",6,26526095
26526188,"
To perform sorting you generally need some ordering of the elements to be sorted. You cannot sort a list if you don't have a mechanism that tells what element comes before another element.
qSort (and most other sorting algorithms) use the operator < to compare elements. You do not specify such a  operator.
How should the compiler (or anyone) know if one Saving should be placed before another Saving object?
is Saving {""Test"", ""foo"", 1.2} before Saving {""bar"", ""baz"", 1000000}?
Implement the operator < acording to your sortin rules:
This is what you compiler is telling you:

error: invalid operands to binary expression ('const modelHeuristic::Saving' and 'const modelHeuristic::Saving') return (t1 < t2);

It cannot compare two Savings using <
",3,26526095
26496384,"
You have good idea, but it needs amendments. You should find begin and end of interval in O(lg n) time using binary search. If n is length of array and q is number of questions [a, b] you have O(n+q*n) time, with binary search it's O((n + q) lg n) (n lg n from sorting array).
The advantage of this solution is simplicity, because C++ have std::lower_bound and std::upper_bound. And you can use std::distance. It's just a few lines of code.
If q is equal to n, this algorithm has O(n lg n) complexity. Could be better? Not at all. Why? Because the problem is equivalent to sorting. As is well known, it is impossible to obtain a better computational complexity. (Sorting by means of comparison.)
",2,26496219
26496374,"
There's a simple O(ninput*mintervals) algorithm:
For ease of implementation, we use half-open intervals. Convert yours as needed.

Convert your intervals to half-open intervals (Always prefer half-open intervals)
Save all limits in an array.
For all elements in the input

For all elements in the limits-array

Increment the count if the input is smaller than the limit


Go through your intervals and get the answers by subtracting the counts for the corresponding limits.

For a slight performance-boost, sort the limits-array in step 2.
",1,26496219
26496642,"
Create a std::map of your numbers to their index in the sorted array.
From your example map[-999999] = 0, map[-3] = 1, ... map[999999] = 7.
To find an interval, find the lowest number higher than or equal to the min (using map.lower_bound()), and find the first number higher than the max (using map.upper_bound()).
You can now subtract the lower index from the upper index to find the number of elements in that range in O(log n).
",1,26496219
26498464,"
O((n+m)lg m), where n is the integer count, m is the number of intervals, and x is the average number of intervals each interval overlaps with.
",1,26496219
26479038,"
The mistake is here:
Instead of J >= 1 it should be j > l (the letter l).
",1,26478139
26477002,"
Remembering that a struct and a class are pretty much identical, add a member to the class.
",3,26476926
26476994,"
You basically have a function object already, all you have to do is add a constructor to your struct that takes in the parameter(s) you need and store them in member variables to be used by operator().
",1,26476926
26471456,"
A O(n) working code for the above problem.. But as others pointed out in the comments.. You end up with an array that is using less space then allocated to it..
",1,26471037
26471773,"
Nested loops give you O(n2) complexity, and non-obvious code.
Better use std::remove_if:
Disclaimer: code untouched by compiler's hands.
",1,26471037
26471464,"
Try this code. You should not decrease number at each step. Also, the second loop should start at i and stop at the end of array:
",0,26471037
26471991,"
Here's a more compact and idiomatic (that's how I view it anyway) way to remove items from an array:
Just for comparison, here's a version using std::vector:
",0,26471037
26472488,"
As an alternative, if you want to keep your items, but denote what will be at some later time, ""removed"", the algorithm that can be used is stable_partition:
Output:
You will see that 2,3,1 are on the left of partition p, and 4,5 are on the right of the partition p.  So the ""removed"" items start at where p points to.  The std::partition ensures the elements are still in their relative order when done.
",0,26471037
45667943,"
I created my own example, hope this helps people as a reference:
",0,26471037
26448694,"
Just to point out that your proposed solution does not take into account that two counts of word can have the same value, therefore two words would be mapped to the same key and override the last one.
What you could do instead is make a class of a word with member variables the word as string and the count as int, and implement the < operator to allow sorting of the objects by the std::sort method. Refer to http://www.cplusplus.com/reference/algorithm/sort/.
",0,26448614
26444333,"
Where you now have 
you can have
The point of std::bind is to return an object that when invoked, calls the bound function, optionally with altered arguments. You can use it to change argument order, add optional parameters, or set parameters to specific fixed values.
",12,26444216
26444294,"
Since std::sort takes an instance of the comparison functor, you can use arguments to your functor's constructor determine its behaviour. For example,
",6,26444216
26444468,"
There follows an example that includes a function call with a bound extra parameter and a lambda expression that captures the extra parameter by value:
#include <iostream>// for std::cout
#include <vector>// for std::vector
#include <functional> // for std::bind
#include <algorithm> // for std::sort

bool ltMod(int i, int j, int iMod) {
    return (i % iMod) < (j % iMod); 
}

int main() {
    std::vector<int> v = {3,2,5,1,4};
    int iMod = 4;

    std::cout << ""\nExample for the usage of std::bind: "";
    // _1 and _2 stand for the two arguments of the relation iMod is the bound parameter
    std::sort(v.begin(),v.end(),std::bind(ltMod,std::placeholders::_1,std::placeholders::_2,iMod));

    for( auto i : v )   std::cout << i << ',';

    iMod = 3;

    std::cout << ""\nExample for lambda: "";
    // lambdas are unnamed inplace functions
    // iMod is captured by value. You can use the value within the function.
    std::sort(v.begin(),v.end(),[iMod](int i, int j){ return ltMod(i,j,iMod); });
    for( auto i : v )   std::cout << i << ',';

    return 0;
}
/**
     Local Variables:
     compile-command: ""g++ -std=c++11 test.cc -o a.exe""
     End:
*/

",1,26444216
26444486,"
Thought that I would answer my own question in order to summarize the responses I've gotten. So from what I gather, I basically have two options.
The first would be to write a lambda function to handle my one-time case.
The second, more reusable option would be to create a functor to handle sort situations like these.
So think that pretty much sums up my options?
",0,26444216
26437916,"
It's strange you are allowed to use STL algorithms but not data structures. I'm not clear from your question what you are having difficulty with. Sorting the structs or constructing them? In any case here is a simple way to create and sort the structs. As your sort function doesn't require any state, it doesn't need to be a functor. It can just be a normal function.
To improve this further I would use a vector, add stream operators to the struct and use a constructor.
",1,26437819
26388454,"
You need to replace int k = right by int k = left in function merge. I think expected output for this array is 27. Various implementations of merge sort had been discussed here implementing merge sort in C++
",3,26383540
26371727,"
conversion from vector to array is done this way
vector vInts;
...fill the vector
int * intArr=vInts[0]
so you don't need to modify your code too much
",0,26371682
26372055,"
I believe there is not enough code to make an accurate prediction on where the error may be, but I think the problem is that the sorting algorithms is doing something like A++ with you pointers to access the next member. 
Because arrays store the pointer to the next array inside the object and not on adjacent cells of memory, your algorithms are cycling through stuff they shouldn't.
If this is the case, the solution to your problem is to use an iterator instead of a pointer.
",0,26371682
26368389,"
Given the array {1,3,5,7,9} and pos = 2, you can do the following:
",2,26368099
26368505,"
LIVE DEMO
",0,26368099
29187206,"
/Comments: I believe that this assignment is from myprogramminglab. The only thing that you need to fix is change from 50 to 5, myprogramminglab just inputs 5 entries instead of 50 as it says/
",2,26333251
26338779,"
The number of inputs to your program is only guaranteed to be <= 50, indeed in the test data, there are only 6 entries and in your sample input there are only 3.
Your problem lies in that you are currently expecting 50 entries every time you run the program, and when cin >> variable fails, no data is written.
From your sample input, all the data is input on one line.  This means we can use the method described in this answer to handle the input.
Your input loop now looks like this:
We now read in the entire line in one go, and then use the stream operator >> to read it.
Functionally, this is very similar to your original code, however, unlike cin there is an end to the stream.
iss >> variable will return false when it reaches the end of the data, which breaks us out of the loop.  At this point, the count variable will have a value equal to the number of student data-sets input.
We can now use count in the rest of the loops (instead of 50).
Full code:
I've got a running version of this at ideone for you: http://ideone.com/Y9jOkt
I have however done a few further enhancements that are in this version:
removed using namespace std see here for why
used a std::vector instead of a bare array, will adapt to the number of inputs instead of being at a fixed size.
Created a locat current_student object to read the data into, keeps the intent clear and works well with std::vector.  Can be done with the bare array too.
I'd also like to point out that your sort is, not right.
This input:
should provide this output:
but instead comes out like this:
You are doing a bubble sort (I guess that was your intention), but only doing one pass.
I could answer it here, but as a seperate issue, you should probably ask this in another question.
",0,26333251
26322327,"
Okay upon more further study of the code I think I've figured it out. 
So looking at the part of the code that is sorting, the way that it works is actually pretty simple.  startScan is an int increments until it becomes equal to the size of the vector in the for loop.  In this case it is vName. minIndex will hold the smallest index number which at the time of initialization will be equal to the starScan.  Finally minValue is a string (in this case because we have a vector of strings) that acts as a temporary container for the element at vName[scanStart].  In the second for loop index will be incremented through the vector and will test if the element vName[index] is smaller than the temproray container i talked about earlier.  If it is than the new temp will be vName[index] after that is done it will exit the inner loop and update and move on to the next smallest value in vName.  Understanding this it's easy to make it so that the sorting happens with 2 other vectors.  All one has to do is create containers for those vectors like the ones i have here minValueA and minValueB.  They will simply be changing as vName changes.  That way everything stays in the order in which vName is ordered.  I hope that helps someone!
",1,26320422
26281532,"
Mark your methods as const:
This way you'll be able to call them on const objects, which is what d1 and d2 are.
All methods that logically don't need to modify the object should be marked const.
",3,26281497
26210016,"
Your partition algorithm is about twice as much code as it needs to be. You seem to be always choosing the last element in the sequence for your pivot, and although not advisable, it will work for academic demonstration.
Your Crash
You're defining two pIndex values, only one of which is actually deterministic. You also declare two pivot variables, but that does NOT cause your crash (the first one is never used). It should be cleaned up none-the-less, but the death knell in your code is duplicate pIndex
Changing int pIndex=start; to simply be pIndex=start; will solve your crash, but your partition method still needs... help.

The ""Sweep"" Partition Method
The ""sweep"" method of partitioning is generally done like this for a pivot value that is assumed to be right-tailed, and you would be hard pressed to get this simpler (invoking std::partition not withstanding):
The above algorithm includes only the necessities needed for a partition: the sequence iterator (a pointer in your case), and the sequence length. Everything else is deterministic based on those two items. A quick sample program of how this works follows, with a purposely placed 5 for the pivot value:
Output

How To Invoke From  QuickSort
Invoking a partition in quicksort sets up the pivot location, which becomes the ""end"" iteration point of the bottom segment, and the one-BEFORE iteration point of the top segment. It is critical the pivot location returned from an invoke of Partition() should NOT be included in either subsequence when recursing. 
Yeah, pointer arithmetic rocks, don't you think?

Putting It All Together
The program below incorporates both the Partition and QuickSort :
Output
I hope it helps.
",3,26209528
26209583,"
In this part:
You are defining two pivots, and two pIndex's. You are not using the pivot at all, and with the last swap you are using the uninitialized pIndex. This should work:
",1,26209528
26210064,"
I'm also something of a C++ newbie, but I find myself curious about what happens when start >= end. It looks as though your Partition function will still return a pIndex value, but I don't see where you define it anywhere. If (as I suspect) it returns whatever value happens to reside in memory, then you'll very likely end up referencing some undefined memory locations when you use A[pIndex]
",1,26209528
26201180,"
Under the assumption that each white space is exactly one blank character, and there is no plenking/klemping, you can count via std::count. Reading in the lines can be done via std::getline.
If you need the amount of words in each sentence later on, save an std::pair<std::string, std::size_t> to save both the line and the word count - alter the loop body to this:
",0,26201009
26202727,"
I'd write something like:
The returned vector contains the information you need: count of words and the words themselves (with punctuation which you can remove easily).
To read all lines you do:
",0,26201009
26176220,"
Why not use std::sort as defined in <algorithm>?  See here.  You can also define a custom comparator. 
Sample usage is as follows
stable_sort also exists, if you need it.
The custom comparator can be useful if fitness is not a straight < operator (eg involving some simulation).  Then you can do something like this
In addition, perhaps you do not need to sort the whole array.  If for example, only 20 out of 100 genes survive the timestep, you only want the first 20 values.  In this case std::partial_sort is your friend.  More info here.
",9,26176049
26176446,"
EDIT As noted in the comments, the below code actually mimics std::rotate, which is of course preferred above my hand-rolled code in all cases.

You can accomplish this with K swaps where K is the distance between the elements:
Live demo here. Note I used std::string, but the algorithm remains the same for std::vector. The same can be done with iterators, so you can generalize to containers that don't have operator[].
",1,26176001
26176078,"
It's not possible to do this ""efficiently"" with std::vector<>, because it is stored in contiguous memory and you must therefore move everything between the old and new locations by one element.  So it's linear time in the length of the vector (or at least the distance moved).
The naive solution would be to insert() then erase(), but that requires moving everything after the rightmost location you modified, twice!  So instead you can do it ""by hand"", by copying b through d one position to the right (e.g. with std::copy(), then overwriting b.  At least then you avoid shifting anything outside the modified range.  It looks like you may be able to make std::rotate() do this, as @WhozCraig mentioned in a comment.
",6,26176001
26176518,"
I'd try with std::rotate first and only try other manual stuff (or a container other than vector) if that turns out not be efficient enough:
Live demo.
",3,26176001
26175078,"
For #3, you don't need a count. The code should also include checks for head == NULL, p1 == NULL before attempting to check p1->link, and it should check for p1->link == NULL before attempting to check p1->link->link. After adding these checks, to eliminate the count, just advance p1 two at a time: p1 = p1->link->link, while advancing p2 one at a time: p2 = p2->link. Once you reach the end of the list with p1->link or p1->link->link, then consider p2 to be a pointer to the last node of the first half of the list, and follow the given instructions on how to split the list.
For #4, the approach of recursively splitting the list into sub-lists is generically known as a divide and conquer algorithm (wiki link). This approach is used for top down merge sort, and although there are other approaches which are better suited (faster) to implementing merge sort with linked lists, I get the sense that the instructor probably wants you to follow the given hints.
",0,26174475
26167747,"
This is your problem:
It should be this:
",2,26167558
26167699,"
works fine, just replace 
with:
",3,26167558
26154789,"
Not sure if this is all of your problem, but this is one issue:
You are copying randomNum to tempList from 0 to highIdx, but you only ever access tempList from lowIdx to highIdx.
That means that all the items you copied from 0 to lowIdx are wasted copies.
Solution: Only copy what you need.
",2,26154721
26157231,"
You might want to consider a bottom up merge sort. Example template code. a[] is the array to be sorted, b[] is a temp array with the same size as a[]. The sorted data may end up in either a[] or b[]. This can be modified to always end up with the data in a[] by doing a pass count check at the start and optionally skipping the swap in place if there will be an even number of passes.
",0,26154721
26151374,"
Read one character at a time and inspect it.  Have a variable that maintains the number currently being read, and a flag telling you if you are in the middle of processing a number.
If the current character is a digit then multiple the current number by 10 and add the digit to the number (and set the ""processing a number"" flag).
If the current character isn't a digit and you were in the middle of processing a number, you have reached the end of the number and should add it to your output.
Here is a simple such implementation:
(See a live demo.)
Now you can do something like this to read all integers from standard input:
This will work equally well with an std::ifstream.
You might consider making the function a template where the argument specifies the numeric type to use -- this will allow you to (for example) switch to long long int without altering the function, if you know the file is going to contain large numbers that don't fit inside of an int.
",3,26151288
26133223,"
You have this call:
In the process of executing that code, you do:
It is certainly possible that sortedArray gets the same address as the just deleted inputIntArray.
",3,26133197
26130922,"
Why not use the file extension as part of the file name in order to ensure separate files for different file types?
A bit like this:
So your file names might be something like this:
NOTES:
A file extension can be extracted from the line like this:
When a file has more than one ending it is usually the last that applies. For example a file with extension .tar.gz is a file that was creates as a tar but was later gzipped. So it is a now a gzip gz. So I would trust the last extension. It is likely the true format of the file that was converted from the previous extension's format.
",0,26130593
26130920,"

That depends how you read your strings, assuming you have a string per line it could be something like this:
Note that C++ does not support string compares with switch statements. To make things easier however, you could split the extension using std::string::find() together with std::string::substr() so you can just compare the extensions straight away. 
That's what the default is for :)
With the above compare statement you could do that easily, just make sure you have the compound extensions before the separate ones.
awk or perl spring to mind, or just some basic shell scripting in general. Something like this would probably do the trick:


",0,26130593
26127298,"
you should print numbers in a loop, and also your loop condition seems wrong. this would work:
and if you want to show them sorted, you have to use sort() first.
",2,26127096
26093800,"
You are trying to initialize and sort the array in the same loop.
-First initialize the array:
-Then sort the array: (Below sorting method is insertion sort, if you want to speed the process you can use counting sort since the array only contains numbers.)
}
",0,26093669
26084867,"
This question has a C++-Tag.
struct, std::vector and std::sort are readable/simple and fast.
",9,26084642
26084788,"
Yes, there are faster ways than your method.  Specifically, you're using Insertion Sort for your sorting algorithm.  A faster algorithm is Mergesort or Quicksort.
Faster still would be to use a 2D array, then supply the library sort method with a custom compare function.  This would make your code easier to read and take advantage of the optimizations within sort().
",2,26084642
26080526,"
It looks like you have an unnecessary break in your insert loop:
What this does is if the first item is greater than the item being inserted you will end up not inserting anything. If not, the item should be inserted at the list head (assuming your insert code works).
From the indentation I would assume you actually wanted to do:
You could omit the { } on the if statement but it is more explicit and less error prone if you include them.
",0,26080342
26082384,"
The most common error in binary searching is forgetting the both sides of a split are not necessarily the same length. I.e. when you calculate this:
and then use middle as the comparative element, you need to remember that the size of the remaining partition is not always (last-first)/2. Due to integer division there may well be one more element on one side of the partition than the other.
For example, the simple sequence of 8 elements in order:
Initially we have a sequence that is 8 elements long. we'll choose 8/2, i.e 4, as the mid-point, which gives us this (remember our indexing is zero-based):
Ok. unless the element we're looking for is 5, we are either going up, or down. But what is the difference (besides the obvious)? Well if what we want is greater than 5, then this is where we'll be looking
i.e. a three element sequence remains. However, if we need to move to the low side (the value is less than 5) then we'll have the following left to conquer:
i.e. a four element sequence remains. 
To consistently make sure you don't skip elements, accurately maintain the following: 

The base index, which only adjusts when moving to a higher partition split.
The current sequence length, adjusted with each partition.
The mid-point calculation within the current sequence.

This is one way to do all of the above. 
Best of luck.
",1,26079707
26073245,"
You are doing this:
The sort function will swap elements in an array to make it sort. But it can only swap simple types including pointers, but not an array. For example this will fail and not copy 21 bytes:
Instead you have to use a pointer allocate memory for it. 
Now s[i] is just a pointer and can be swapped with other entries in the array.
",0,26072936
26073367,"
ok, I think sort((char**)s,(char**)(&s[n-k+1]),cmp); is what you want to do. It's can compile But it can not function as you expected. you should know bool cmp( char a[21],char b[21]) is exactly equal to bool cmp( char* a,char* b). and the string compare expect \0 ended
",0,26072936
26049447,"
The C++ way to do this is to use a std::set, since a std::set doesn't store duplicates.
Output:
Note that even though duplicate entries are attempted to be placed in the set, only one entry exists.  To limit the number of items to 6:
Output:
",1,26048850
26025944,"
Working example. Improving efficiency is left as an exercise for the reader (hint: look at std::find calls).
",1,26025234
26039272,"
You only need to augment your comparison function with the following rules:

if the first value exists in the vector to sort with respect to, but the second value does not exist in it, then first < second
if the second value exists but the first does not, then second < first
if both values exist, compare their index values within that vector

If none of those conditions are true, the existing comparison logic would run.
",0,26025234
26006901,"
The line with the problem is: for (!done && index <= j; index++;) { in the for loop the first block is initialization, the second stop condition and the third is increment, in you case you are putting stop condition as initialization and increment as stop condition, changed by for (; !done && index <= j; index++) {. Please take always good look before posting in SO. Any compiler (and I mean ANY) would catch this error with a error message good enough for you to figure out the problem. In GCC 4.9.1 was:
Compile always with all warnings enable (-Wall in GCC and Clang, select at least level 4 in Visual C++), the compiler would help you to fix a lot (valid code that are bugs).
",3,26006831
27244550,"
Looking at some reference documentation, you will find that std::partial_sort requires 3 iterators, not 2: start, middle and end. It will re-arrange the range so that the range [start, middle) is sorted, and contains the smallest elements from the range [start, end).
Depending on what exactly you're trying to achieve, you need to provide an appropriate 3rd iterator. If you're trying to find the 10 smallest elements, just do this:
",4,27244491
27239073,"
is almost ALWAYS wrong, 
Why is iostream::eof inside a loop condition considered wrong?
as you end up reading the end of file. Use instead 
In your case, you can just declare x as a std::vector, like
read the content into the vector, then use 
Nothing more simple. 
And for a complete C++ standard library solution, you can use iterators and sorting algorithms, like
You can easily map the code above to a function. I have no idea what you mean by a sorting parameter. If you need to be able to sort ascending/descending, you may use std::less or std::greater (need to  #include <functional>), as a third parameter for std::sort, like
or write your own comparator functor/lambda function.
",1,27238791
27239104,"
My C++ is rusty and I am without a compiler, I will update this if any errors are encountered. 
There are some differences to your code.

It uses std::vector instead of an array. It is dynamic and has some pleasant functionality like dynamic length, a size counter and sorting.
I split it into four blocks of code, opening, storing, unsorted and sorting.

So what it does

As it were before, it tries to load data.txt, if it fails it exists.
It reads data, storing it in our temp variable tmp to then push it into our vector x. It then proceeds to close the file and print the number of values x.size().
It prints the unsorted vector, as it were in your code.
It finally utilizes std::sort(begin, end, function) to sort the vector.

",0,27238791
27230386,"
You can change the compare to compare two elements of arr0 and if the same, then compare two elements of arr1 and if still the same, compare two elements of arr2. You might consider changing the name of Y to T (for temp), and then using X, Y, Z as the pivot points for arr0, arr1, and arr2.
Quick sort isn't stable, so you can't use multiple sort passes from least significant to most signifcant. You could use std::stable_sort() (normally implemented as a merge sort), and again use a custom compare that compares arr0, arr1, and arr2 if needed, or sort the data 3 times, by arr2 first, then arr1, then arr0.
",1,27229680
27198333,"
Your merge function has a memory leak, and a very big one:
The memory is never deallocated.  If you're coming from a language such as Java or C#, you see that C++ works differently.  There is no automatic garbage collection, and using new[] in C++ requires you use delete[] at some point, else you get a memory leak.
But a better solution would be to replace those lines with this:
You should always think vector first over using new[]/delete[] to avoid these types of memory errors.  
Once you make those changes, the program will complete, but takes a while (at least it did with Visual Studio 2013 in debug mode).
In release mode, the time took for 10000000 was 3,300 ms.
Edit:  For an experiment, I used the following code to see what would happen if the vector was moved out of the function, and just reused:
So I made the vectors global.  The amount of time it took was closer to 2,000 ms, so approximately 1,000 ms faster.  The advantage is the usage of resize to resize the vectors as opposed to redeclaring them, or using new[]/delete[] multiple times.
",0,27198308
27198182,"
This is because cin >> choice reads part of the current input line for the choice entered by the user. The first getline() call reads the remaining part of the input line immediately following the choice entered by the user. You need to ignore the rest of the input line after the choice.
You will also need to add #include <limits> to the beginning of your code in order to pull in numerical_limits.
",2,27198161
27198251,"
It looks as though you are defining some sort of char array for the user response.  I would tend to make that a non-zero integer type with an exception if the choice is neither 1 nor 2.  There are also some shortcuts for output formatting that reduces lines of code.  Also, you would want to include the standard string class to accept the string.  Maybe try something like the following:
",0,27198161
27198140,"
There are two issues in your sort() routine - you're only sorting from mid to high (instead of low to high), leaving things half-unsorted. Once that's fixed, you need to stop j when it moves below low, not 0, since we're not always working from the start of the array. 
Finally, mid is no longer needed in that function.
And later, in split(), adjust the call:
Working example: https://ideone.com/B1UtSK
",0,27197796
27191859,"
Calling the below code with 
Should illustrate the problem 
So the program will forever call divide(A, 0) until you run out of memory.
To stop this eternal recursion you need a correct stop condition
You could also check for incorrect values of n, which is 0, negative and larger than length of A.

Lets say you have A[]= {1,2,3} so you call 
Now in the else part of the program you need to split up A in to parts, N/2 elements and the rest.
in our example this gives n/2 = 3/2 = 1 so
divide(A, 1);
and starting in the element just after the n/2'th element
the first element is at A[0], so the remaining start at A[1] and contains n-(n/2)=3-(3/2)=3-1=2 elements.
And now the first if, it looks like a bubble-sort, but fails as it address an element beyond the end of the array.
A[i+1] is beyond the end of the array for i=1 and n=2, n=2 => 2 elements at address A[0] and A[1] so A[i+1]=A[2] which is not part of the array A with length 2.
solves that and also takes care of the case with n=1, which means the array contains only one element, which by definition is already sorted.
Now if the algorithm was called divide-sort you would be finished, but you still are missing the merge part.
",1,27191321
27194126,"
You're still missing a merge. Merging is going to need a second temp array, I'll call it T and assume it's passed from main: 
",1,27191321
27194489,"
It might be simpler to assume that a partition 0 or 1 element is already sorted. Thus, it is enough to put as stop condition
",1,27191321
27153600,"
If you really want to put them into an array, just assign into the next index each time:
Or just getline directly into the array:
Although for this exact thing we have vector, which obviates the need for the count and doesn't have a cap:
",0,27153504
27157288,"
In addition to Barry's answer 
You can also use commandline execution and change the input stream for example after the creation of .exe file (after compilation/build) if the name of the file is ""program1.exe""
and the text file is ""input.txt"" (in the same directory) input can be given to file via a this text file by changing the input stream 
Open commandline in the same directory and write 
the original program depending on your needs can be like 
And the input.txt would be like 

52 14 24 23 45

Similarly you can change the output stream and save the output to a different file say output.txt by writing in commandline
",0,27153504
27176800,"
You can construct the vector directly from a istream_iterator (#include <iterator>), such as:
The double () in (std::istream_iterator<std::string>(myfile)) are needed to avoid the most vexing parse. In C++11 can simply use brace-initialization and write
",0,27153504
27135496,"
The problem is you can't have more than one variadic in each template.
How would you know where one starts and the other ends?
",0,27132190
27137986,"
Ok, I changed the function signature from my opening post.  And now it is working.
I still wonder how it would be done with the original signature in my opening post though, because that signature follows in the spirit of std::merge (using only iterators), and generalizes the output container with an output iterator.
",0,27132190
27121191,"
First off, you are mixing up arrays and vectors.  I would review this page for how to declare, initialize, and use vectors.  You are creating a std::vector in main, yet passing a std::string[] to bubbleSort.  These are not the same type.  If you want to use std::string[], then you need to declare such an array in main, instead of using std::vector and std::vector.push_back()
While you can use the syntax that you have, I find it's a little hard to understand exactly what it is doing, so I recommend manually filling it with push_back(), until you understand vectors more.  As such, if using a vector, main would look something like:
Keep in mind that vectors are not passed by reference, so if you do any swapping in bubbleSort, those changes will NOT be reflected in main.  Learning about pass by reference is left as an exercise to the reader, but your bubbleSort function signature will look something like void bubbleSort(std::vector<std::string> &v).  Keep in mind that if you're already going to be using std functionality, it's not really worth it to use your own sorting algorithm (except for just learning), since there is already std::sort.
The other way to do this is to use a regular old array, using your own sorting algorithm, main will be something along the lines of:
Keep in mind that you CANNOT get the length of a dynamically allocated array with a .size() function, so you need to pass the length.  As such, the function signature for bubbleSort would look something like: void bubbleSort(string *args, int len)
",1,27120466
27121271,"
You need to first convert the input command line arguments to std::string and then you have to push back to the arrays. Once you did it will works as expected. 
Also if you want to use std::vector v(argv, argv + argc); then please refer the following links
parsing argc and argv in c++
http://www.boost.org/doc/libs/1_41_0/doc/html/program_options.html
",1,27120466
27119242,"
Your error is here:
Which should be:
You were using the wrong array, and you were passing result (which was never initialized) instead of number_used. 
",0,27118981
27117798,"
You made a copy when getLuckyNumbersList() returns since you weren't returning a reference.
Change into the following instead.
",3,27117766
27109243,"
One error is your bubble sort implementation.  It should be making multiple passes through the data, since bubble sort has O(n*n) complexity, where n is the number of items to be sorted.  
In other words, you need to execute the while loop in bubbleSort until you've detected that the data is sorted.  That can be done either by using a boolean flag that is only set when a swap occurs and then testing that flag, or just make n passes through the data. 
",1,27108601
27100318,"
Think of the way balancing works for AVL trees. It works best if the ""middle values"" come first. With a sorted input, you will need a lot of re-balancing, thus pre-sorting will probably do more harm than good.
For example, consider the following AVL tree holding the values 1-6:
If the input order is 4, 2, 5, 1, 3, 6, you'll never need to balance the tree.  In contrast, for a sorted input 1, 2, 3, 4, 5, 6, you'll need many re-balancing operations:

UPDATE The original question was whether sorting data before inserting into an AVL tree would improve performance.  Now the OP edited the question, shifting towards his specific problem.

but what is the best way to efficiently insert when a word is already in the tree somewhere? How can I make sure that I find it?  Is that where my sorting can come in?

The whole point of an AVL tree is to efficiently find data, so I don't understand the question.  It should be obvious how to traverse the binary search tree to find a value.  Why would you want to sort data for that?
Please note that binary search trees are a good data structure to store keys, but it can also manage arbitrary data associated with these keys.  In your case, you want to store a count along with your keys.  Therefore, you don't need a tree of words/strings, but a tree of pairs (string, integer) that represent the word and its count.  For the tree order, just consider the string key, i.e. the word.
For each word to insert, look it up in the tree.  If it already exists, update the word count.  Otherwise, insert a new pair with a word count of one.
A final note: The C++ standard library comes with a map type that is usually (always?) implemented using a balancing tree (AVL or red-black).  You'll save yourself a lot of work and bug-fixing by just using this implementation.  Since C++11 there is also un unordered_map, usually (always?) implemented using a hash table.
",4,27100192
27101469,"
I'll convert my comment into an answer.
If the set of strings is pre-defined, that is you are not going to add more strings to it after the initial load, then the fastest is probably not to use AVL tree (or any other tree) at all. 
Just load the strings into std::vector, sort it (O(N*logN), remove uniques (std::uniq, O(N)) and then for lookup use std::lower_bound (O(logN)). 
Having the same complexity as AVL tree, most likely in practice it will be faster, because of increased cache-friendlyness.
",3,27100192
27100444,"
This following might not be any faster in the real world. 
When inserting your sorted vector into the AVL tree, insert it like it is a tree itself. First insert the middle then recursively the middle of the left part and middle of the right part, and so on. If all the values in the vector are spread uniformly then you won't have to rebalance your tree.( in theory. )
Better still, you can construct your own tree out of the sorted vector( if you control the internal memory ) or just use binary search on it in the first place.
The only way to get a objective answer is to test and measure.
",2,27100192
27100767,"
1-Insertion in AVL tree is O(Log n). Sorting is O(nLogN), So sorting before insertions will decrease performance. 
2-For counting purpose, you can use a hash table to find the number of occurrences of every word. Loop through all the words, update the count for every word in the hash table, then insert the words in the AVL tree using the hash table to check if the word was inserted or not and if not to insert it with its associated count.  
",2,27100192
27101557,"
""but what is the best way to efficiently insert when a word is already in the tree somewhere? How can I make sure that I find it? Is that where my sorting can come in?""
why wouldn't you use a map when: key = word, value = word index
that way you will gain access whenever the word exists and you will have the index to manipulate it
",1,27100192
27090090,"
isPointsVisitStartPrior is a member function, this cannot be used directly in sort. You have to either use a global function or a function-object.
If you have access to C++ 11 features, you can use a lambda:
You can also make a functor object with an operator(), something like
",1,27090026
27090564,"
isPointsVisitStartPrior(int, int) is a member function. A such, while it looks like it takes two arguments, it really implicitly takes three: it also needs a BeeHive* on which to operate (the this pointer).
What you need to do is ""bind"" the BeeHive* to the call:
That will save off this as the first argument in the call to the three-argument function, and forward the next two arguments you call it with into the next two slots.
This is logically equivalent to:
Though with the lambda, the compiler may be able to inline the call for you. 
",1,27090026
27086567,"
I cleaned up the code, and I also added a bottom up version that uses an array of starting indexes (see below). I changed high in MergeSort() to end, so the call is now MergeSort(0, SIZE). i = MergeSort() returns the index of the smallest value in a[], then i = link[i] is the 2nd element, i = link[i] is the 3rd element, until i = -1. Instead of using insertion sort, MergeSort() directly sorts groups of size==1 or size==2 and initializes link[]. 
MergeLists() uses head for the start of a list (the old code uses link[0]), and -1 for the end of a list (the old code uses 0). This allows sorting of a[0] to a[n-1] (the old code was sorting a[1] to a[n], with a[0] unused).
If a[] ={5,4,8,7}, then MergeSort() returns a 1, and link[] = {3,0,-1,2}, link[1] = 0, link[0] = 3, link[3] = 2, link[2] = -1, so the order is a[1], a[0], a[3], a[2].
This is an example that is non-recursive. It uses an array of starting indexes S[]. N[] is the same a link[] above, and MergeLists() is the same as before. S[0] points to lists of size 1, S[1] points to lists of size 2, S[2] points to lists of size 4, ... S[i] points to lists of size 2^i (2 to the power i). S[31] points to a list of unlimited size. Elements are merged into the array one at a time, then the array lists are merged to form a single list.
",2,27086267
27052926,"
Let's make a sort/permute iterator, so that we can just say:
See it Live On Coliru, printing
Based on the idea here, I've implemented this:
Now the factory function is simply:
Note I've been a little lazy by using boost/tuples/tuple_comparison.hpp for the sorting. This could pose a problem with stable sort when multiple key values share the same value. However, in this case it's hard to define what is ""stable"" sort anyways, so I didn't think it important for now.
FULL LISTING
Live On Coliru
",5,27049072
27051525,"
Just for comparison, this is how much code the split iterator approach requires:
It is kind of rough around the edges, maybe I'm just bad at overloading the comparisons, but the amount of differences needed to support different implementations of std::sort makes me think the hackish solution might actually be more portable. But the sorting is much nicer:
And of course it gives the correct result.
",4,27049072
27050651,"
Inspired by a comment by Mark Ransom, this is a horrible hack, and an example of how not to do it. I only wrote it for amusement and because I was wondering how complicated would it get. This is not an answer to my question, I will not use this. I just wanted to share a bizarre idea. Please, do not downvote.
Actually, ignoring multithreading, I believe this could be done:
And sorting as:
This is obviously very appalling, trivial to abuse in horrible ways, but arguably much shorter than the pair of iterators and probably similar in performance. And it actually works.
Note that swap() could be implemented inside ValueVectorSingleton and the one injected in the std namespace would just call it. That would avoid having to make vv and kv public. Also, the addresses of a and b could further be checked to make sure they are inside kv and not some other vector. Also, this is limited to sorting by values of only one vector (can't sort by corresponding values in both vectors at the same time). And the template parameters could be simply KeyType and ValueType, this was written in a hurry.
",2,27049072
27051673,"
Here is a solution I once used to sort an array together with an array of indices (--maybe it is from somewhere over here?):
Usage:
Afterwards, the integers in vector indices are permuted such that they correspond to increasing values in the vector values. It is easy to extend this from less-comparison to general comparison functions.
Next, in order to sort also the values, you can do another
using the same comparison function. This is the solution for the lazy ones. Of course, you can alternatively also use the sorted indices according to
DEMO

EDIT: I just realized that the above sorts into the opposite direction than the one you were asking for.
",2,27049072
27039129,"
You've never compare first element of your array with anything - for (i = 1; i < NoOfCalculations - j; i++) should be for (i = 0; i < NoOfCalculations - j; i++)
",1,27039015
27116599,"
The issue is for (i = 1; i < NoOfCalculations - j; i++) You are starting at position 1, start at position 0 and it fixes the problem. for (i = 0; i < NoOfCalculations - j; i++)
",0,27039015
27039106,"
Bzzzt. You allocate a zero-element array, and then don't reallocate it. I bet if you entered a large enough number for your number of calculations, your program would crash.
Really, you want to be using std::vector, an extremely useful datastructure, the use of which is a bit outside of the scope of this answer. Basically, you can do stuff like this:
You can use the returned vector almost exactly as if it were an array:
Often, in a C++ application, the explicit use of pointers is a sign that you're not using the standard library, and as a result making life much, much harder for yourself.
Oh, and also:
You never look at NoOfCalculations[0] or NoOfCalculations[i - 1], so you never touch the first element.
",-1,27039015
27041590,"
",-1,27039015
27028428,"
",1,27028209
27028645,"
How about, not using std::is_sorted:
Live On Coliru
Printing random, sorted, sequences of 10 integers like
",0,27028209
27009167,"
The easiest way to iterate over a (so-called) 2D array is to use two nested loops:
",0,27006266
27009844,"
If you want to find minimum in particular column, then you don't need nested loop... But if you want to find minimum from whole array, then you need nested loops.
And In your code... All you wanna do is selecting one element from array and swap it with the minimum value element of array.
But you are not changing the COL index of array in if statement. That means you are finding minimum element in just one column.
",0,27006266
27005093,"
In this case, your number of exchanges is proportional to your number of comparisons. Also, your loc > 0 is what I'd consider an ""incidental operation"" as stated in that excerpt. So, assuming comparisons and movements are constant time operations (which they are for integers), you'll get the same trends in your data by simply incrementing your counter once each loop iteration.
",1,27004457
26986817,"
I'm for an insertion sort based one too, but I find @Beta's answer a bit confusing, so I worked on my own, written as Pseudocode.
We'll name the three stacks source, temp and result. And their top items as*source, *temp and *result respectively.
We'll try to keep the result stack always sorted with the biggest items at the bottom and smallest at the top.
",1,26986117
26986216,"
I would suggest using stack 1 and 2 together as a traversable list, then apply a bubble sort using stack 3 as temporary holding.
",3,26986117
26986353,"
I would do an insertion sort. Stack 1 is the original, unsorted numbers, stack 2 is in ascending order (the last-inserted element is the largest), stack 3 is in descending order, and the smallest element in stack 3 (which is on top) is larger than the largest element in stack 2 (which is also on top).
This method, like @AMADANONinc.'s, requires no memory of state or other variables, and I think it's faster.
Call the top elements of 1, 2 and 3 ""A"", ""B"" and ""C"", respectively.
EDIT: I've rewritten the algorithm, and I think it's now rigorous. Try these rules in order, and when you move an element, go back to the beginning.

If stack 1 and stack 3 are both empty, then we're done.
If stack 1 is empty (but 3 is not) then move C to stack 2.
If B is larger than A, move B to stack 3.
If C is smaller than A, move C to stack 2.
(Since none of the previous rules applies) move A to stack 2 or stack 3.

For instance, suppose stack 1 starts out as {22,44,11,55,33} (33 is on top). By rule 5, move 33 to 2. By rule 5, move 55 to 2. By rule 3, move 55 to 3. By rule 3, move 33 to 3. By rule 5, move 11 to 2. By rule 4, move 33 to 2. By rule 5, move 44 to 3. By rule 3, move 33 to 3. By rule 5, move 22 to 2. By rule 2, move 33, 44 and 55 to 2. By rule 1, halt.
",1,26986117
37273723,"
The fastest method for a 3 stack sort is a polyphase merge sort. With only 5 numbers and the fact that 5 is a polyphase friendly Fibonacci number helps. Assume the stacks are A, B, C, and that the 5 numbers are initially on A. For this example the numbers start off in reverse order. In the diagram below, the front (first element) of the stack is on the left. Vertical bars represent run boundaries. The comments refer to the next step to be performed. The comment merge means to merge 1 run from two stacks onto third stack.
Total number of moves (pop/push) = 14.
A generic polyphase merge sort for 3 stacks is somewhat complicated. First moving elements from A to B and C (C if number of elements is not a Fibonacci number), then determining if the first merge is ascending or descending (they alternate after that), and keeping track of run size changes. If anyone is interested, I can post example code.
",0,26986117
26977326,"
Extend your two criteria to a lexicographic comparison:
",5,26977273
26977454,"
Using the above combined Sort function (Modified the sort as you want alphabetical first and the int value later.), you can call sort something like this:
Assuming you had a vector of pages
",1,26977273
28163583,"
Your problem in last lines. I corrected them:
In the beginning of the function you have two nodes n1 and n2 with pointers to other elements n1p, n1n, n2p, n2n.
In the first part with temp variable you swap pointers of n1 and n2 nodes. So you come to situation like this.
And you problem was that you incorrectly change pointers for n1p, n1n, n2p and n2n.
Take a look in example with sinplified class Node and corrcted swap function.
",0,26964127
26963139,"
To corroborate Neil Kirk's claim, we can take a look at the boost/range/algorithm/sort.hpp header. And range::sort is in fact implemented in terms of std::sort.
So there's no point in doing this. The page for range::sort also lists the complexity which mirrors the complexity for std::sort:
Source: boost

O(N log(N)) comparisons (both average and worst-case), where N is
  distance(rng).

Source: cppreference

O(N·log(N)), where N = std::distance(first, last) comparisons on
  average.  (until C++11)
O(N·log(N)), where N = std::distance(first, last) comparisons.    (since
  C++11)

",4,26962990
26952673,"
You're doing the swap in every iteration of the inner loop. With selection sort, the goal is to loop though the remainder of the array to find the minimum, then swap. You should only swap at most once per iteration of the outer loop.
Instead try this:
",1,26952652
26948708,"
For ""top 3"", that's perfectly reasonable. For ""top k"" with a larger (but fixed) value for k, you might want to try using a priority queue.
",7,26948596
26949734,"
You can find any number of maximum elements in an array the following way
The output is
",2,26948596
26942252,"
In swapUp, you have a handful of problems.  The clause that addresses if(partner == head) will never be called, because you've already returned if target == head.
swapUp isn't setting the reverse prev and next pointers of both values being swapped, only the next of the target and the prev of the following node.  Both the prev and next need to swapped to maintain your doubly-linked list.
",1,26942170
26921810,"
Since you are comparing current row with next row you should use for(i = 0; i < board->rows-1; i++)
Then in your complex if statement, get rid of && i <= board->rows. That should have been a less-than anyway, not less-than-or-equals. You're going out of bounds and getting garbage in your array. 
",2,26921691
26921929,"
You are checking the row beyond the maximum number of rows.
(board->boardDim[i + 1][j] != None && i + 1 <= board->rows)
That memory is not guaranteed to be 0.  If it is not 0, your function will swap it in.  If it is not human readable, printf won't print anything for it thereby shifting the | to the left.  
",2,26921691
26921178,"
update - you need to advance headX or headY during the merge sort. Also the empty lists checks can be simplfied. This example seems to work:
",1,26920105
26904046,"
",0,26903341
26903465,"
Your merge function ignores its parameters low, mid, high and uses the global variables l, h, m which are set to zero when the program starts and never set non-zero.  Thus, it sorts (or might conceivably sort) an empty array and leaves the rest of the data unsorted.  (Just one more reason to distrust global variables.)
I've not verified whether there are other problems (there probably are).  But starting by paying attention to your function parameters would help.
If your compiler was not warning you about unused parameters, you either haven't got your warnings turned up high enough or you need a better compiler.
",0,26903341
26899137,"
Following the suggestion of PaulMcKenzie's comment: forget all of your code and use a std::list. Its storage type -- a doubly linked list -- is basically what your class is trying to achieve. Then simply use std::sort.
If that isn't sufficient for you, use your own custom class and pack it in a list, then use std::sort with a custom predicate:
",0,26898946
26877775,"
As you can see, this ignores the sign.
If B starts off at 0, then decrementing rolls under to a number whose digits are all 9.
And here is subtraction by an assumed positive integer, ignoring the bignum's sign.:
When N > B, the result underflows as before, to give (10^size) - (N-B)
Here is full subtraction:
Addition is very similar, but opposite:
o  a's digit is added to b's instead of subtracted
o  ""borrow"" is ""carry"" and is subtracted instead of added
o  checking for < 0 becomes checking for > 9
o  and 10 is subtracted from an overflowed digit, not added  
",0,26877139
26882426,"
If you have to keep using your existing data structure, which is essentially a std::tuple of three std::vectors, using boost::zip_iterator would seem to be the way to go. A zip_iterator treats three iterators (two to indices and one to a value) as a single tuple, and you can use a custom comparison function object to sort your data in-place. Alas, boost::zip_iterator can't be used with std::sort, as explained in this Q&A, because it can't be written into.
This means that you would have to write your own zip_iterator class that can be used with std::sort. Note that it is not a trivial exercise, see this Q&A and/or this paper.
It is a lot easier to sort a std::vector of a std::tuple. My attempt below uses a std::tuple of two indices and a value, and stores those entries into a std::vector. For the sorting, I use a C++14 generic lambda that forwards the two indices into a smaller tuple and compares those lexicographically (i.e. first on row-index, then on column-index) using the library operator< of std::tuple.
Live Example.
If your application can use this transformed data layout (and there maybe cache-performance reasons why it can't), then the above code will do the sorting as you want it.
NOTE: as @Casey mentions, you can also use std::tie instead of std::forward_as_tuple, but that can bite you when you change sparse_entry into a full-fledged user-defined class with getters returning by-value. 
",1,26876155
26876799,"
It is unfortunately quite difficult to convince std::sort, or any of the standard library, to work with striped data. It is designed to assume that data can be copied via a single =, moved via one move or swapped via one swap.
Your best bet is to use boost::iterator_facade to write a custom iterator class which wraps the data, and hides the striped data format from std::sort. I've wanted to do something similar in the past but my workspace does not allow us to use boost. EDIT: when your facade is dereferenced, it will probably need to create some sort of proxy object that can be assigned/moved/swapped and will do the right thing to each of the stripe arrays. It's not trivial.
The next best bet is to make an array of ints from zero to N, each one representing an index into your striped data array. Write a custom functor to std::sort which sorts this array to match your criteria. It's obviously far from ideal when you have such a large data set.
",3,26876155
26859794,"
I won't comment on your specific situation, but yes, there are plenty of instances in the ""real"" world, on ""today's"" hardware, where it makes sense to use linked lists.
One example: implementations of malloc and free (i.e. dynamic memory allocators) typically keep track of blocks of available memory using linked lists. A few extra bytes are included within each memory block for a linked-list pointer. This way, the free blocks themselves can be linked together, without allocating any extra memory elsewhere to keep track of them (as would be required by a vector).
This means that the allocator only requires a constant amount of memory for its own internal recordkeeping. Otherwise your dynamic allocator would itself need to use a dynamic allocator to grow its free lists (actually ""free vectors"").
The Linux kernel (and probably other OS kernels) uses linked lists for a lot of things. I guess that if it used vectors, that could lead to undesirable latency spikes when it had to grow the vectors (which would be very bad if it happened while holding some important lock, or while masking interrupts, etc).
",3,26859564
26853762,"
I'd rather use a do while loop: 
",1,26853625
26853742,"
The idea is to increase rank counter when meet different value in qt array. 
",2,26853625
26854139,"
Use std::sort to sort the array -- you won't get anywhere until the array is sorted.  
Here is another solution using a map.   This is more ""lazy"" in that there is no real ""check if number already seen"" logic involved.  Just add numbers to a map, and print out the results in a loop.  
If there are no memory constraints (you will need to create a map of the numbers, of course), and/or you need the array to remain stable (not sorted), then this could be an alternative.
The map already sorts, so that's taken care of.  Then the map is set up to count the number of times each number shows up, so that's taken care of.  The only thing left is to write a loop that just goes through the map and prints the information.
See it here: http://ideone.com/q08SeX
",2,26853625
26846171,"
std::sort requires a predicate that compares elements. That predicate must establish strict weak ordering, one important property of which is if pred(a, b) returns true, pred(b, a) must return false. Your lambda does not satisfy this property. 
",3,26846120
26845040,"
Specify your custom comparer. In C++14 it can be done very concisely:
",3,26844983
26845038,"
The std::sort() function accepts a comparison function object as a parameter:
A working comparison function for the second member of pair would be:
",2,26844983
26845049,"
By default it would sort on the basis of first element much as your program is doing. However you could pass third argument to sort as your-defined comparator to do what-ever you want to do...
You can have your own comparator for sorting on right element:-
",2,26844983
26835714,"
I believe you are asking how to write a single container class that can be used for multiple different data types?
Based on my understanding of the problem, what you should use is a STL vector.  The STL container classes are all templated so that they can be used for any data type.  I suggest using the vector class since it will sort much faster than a linked list, and you have not specified any particular reason for needing a linked list.  Nonetheless, you could use the STL list class if needed.  In any case, you should very rarely need to write your own containers, especially for a trivial use case like this.
You can use the STL sort algorithm (http://www.cplusplus.com/reference/algorithm/sort/) to sort containers that support random access iterators, such as the vector.
Example:
",0,26835520
26836446,"
You could create a base node class that only has a next pointer and a corresponding link class (head pointer, tail pointer, optionally a count) , and create a set of list functions (peekfirst, popfront, pushback, ...) that operate with that base node class. Then you could add inherited classes that would include data. To use the generic list functions with the inherited classes, you would cast the inherited classes to the base class.
",0,26835520
26831367,"

I am doing a function to compare if two vectors of strings are permutations of each other

You are indeed doing this, and it works correctly.
But your example input makes it obvious that you actually want something else: you actually want to compare if two strings are permutations of each other, not two vectors of strings.
Here’s the issue: not in the code but in the specification.
",3,26831055
26827214,"
just comment these lines.
and 
And you are good to go.    
And yes emplace_back appends the new element at the end of container. and you don't need that here.
Link: http://ideone.com/o92WE6 
",0,26826954
26827003,"
You can declare the comparison function as a class and overload () operator on it to give an easy implementation
",-1,26826954
26742651,"
You never test to see if curr->link is null or not. Which causes a fault when you check its data memeber.
",0,26742509
26735235,"
There is in fact an error in your selection sort implementation: you are swapping elements too early and too often.
Only after you have performed a full sweep over the whole remaining array and therefore have determined the global minimum (I keep that term in order to be consistent with the variable name and the comments in the code, although in fact you are looking for the maximum) you should perform a single swap of the first element of the remaining array with the minimum element.
The corrected code (only the main loop of the sorting function shown) should look like this:
",0,26727416
26728170,"
There is a bug in the j loop limit. For example, if the list has 10 elements, n is 9, n-1 is 8, and the largest value of j is 7. The loop can exchange elements 7 and 8 of a 10 element list. It cannot exchange the last pair, elements 8 and 9.
As suggested by a comment, it would be better and simpler to use a library sort that is already tested and working. Rather than adjust the renderListID fields as you go along, you could do them all in a single pass through the list at the end. If you do it after popping the NULL elements, you would not need to test for NULL in that loop.
",1,26721111
26719846,"
Just use the build-in sort that returns the position that the element was in previously.
Haven't actually tested this, because I was too lazy to install octave, I just read the docs.
",1,26717810
26720286,"
I solved the problem with the following code, I developed this code based on the algorithm in the following webpage. But the answer of PeterT looks better to me. 
http://www.learncpp.com/cpp-tutorial/64-sorting-an-array-using-selection-sort/ 
",0,26717810
28075565,"
In print and getInput your variable i is not initialized to 0
You should initialize your i to 0
Same for the print method.
Also, you should initialize your array size with a cont var. For more details
",1,28075505
28075885,"
This is your function, in which you have not initialize the value of i.
Initialize i =0;
Make it:
",0,28075505
28060693,"
I wrote a little test program to see if I could reproduce your issue, and it works fine for me. I wonder if maybe the garbage is being introduced some other way, perhaps when you're printing the contents of the vector. Here's my test code:
Output:
Let me know what you're doing differently than I am, to see if we can figure out what might be causing the problem.
Edit: Ok, here's a modified program that uses the incorrect comparison operator and guarantees many duplicates:
It works for me, example output:
Edit: Aha! I ran the modified version of the test program MANY times, and eventually got a segfault in PairComp::operator(), as called from std::sort(). Here's the complete backtrace from gdb (warning: verbose C++ backtrace follows):
I also ran the modified program many times but with the correct (<) comparison operator, and it never segfaulted. So I think we've identified the problem: the incorrect comparison operator.
I guess the general lesson here is that when you violate a requirement on which a blind (trusting) algorithm depends, all bets are off. It could introduce garbage data, it could segfault, or it could give you the correct result. You've gotta be careful.
This was a fun problem to work on, +1 for the question. :)
",1,28060435
28060745,"
Your comparator function is incorrect. It calculates less-than-or-equals. A comparator must strictly calculate less-than. If your vector contains multiple elements with the same value, this could cause errors.
I do not know if that is the source of your garbage but it is the first thing I would fix. Let me know in a comment if that does not help. 
Additionally, as stated in the comments, the multiplication in the comparator is totally unnecessary.
",2,28060435
28057121,"
Your partition algorithm step is wrong. For example, let's say we start with:
We go into the while loop, which will first move i up the first element greater than 3 (the 8), and j down to the first element less than or equal to 3 (the last 2):
At this point, no swap occurs, and we consider our partition done. This is wrong: we needed to have swapped the 2 and the 3. Regardless of why it ends up infinitely looping somewhere, this implementation has no hope of yielding the correct answer.
",0,28056984
28037008,"
That's because cur is a reference in add_ordered_i and you have cur = cur->next which also modify l.
I made a few changes and it works for me.
",1,28036735
28023662,"
One way is to dump the queue into an array or vector by using dequeue, use std::sort and then rebuild the queue from scratch by using your enqueue function. This is clean and avoids messing up with pointers. This is also optimal because running time is dominated by time it takes to sort.
Something like:
Where cmp compares nodes by time.
",1,28023571
28023779,"
Find the node with the smallest time field, remove it from the list and make it the head of a new list. Then continue to do this, appending the nodes to the new list, in a loop while the original list is not empty. When the original list is empty, take the new (sorted) list and make it the new queue.
It might not be especially efficient, but should work fine.
",0,28023571
28013809,"
You don't create a RandomAccessRange.
You have ranges. And it should be possible to get the random-access iterators from that using the default methods (std::begin(r), boost::begin(r), or r.begin(), also cbegin)
Now regardless of how you got the range, you can either use
or use Boost's range version:
As you can see, boost::sort is merely syntactic sugar for doing exactly the same
A full sample: Note the subtleties of what sorting predicate is used (see std::less<> there)
Live On Coliru
",5,28012668
27996012,"
Since each name is apparently associated with a mark, you normally want to create a struct that contains one name and its associated mark.
Then we create an array of those:
Then we sort those items:
Note the last little bit that specifies how to do the sorting, based on the mark field of each foo.
From there we might (for example) want to print the marks out in order by the mark value:
",2,27995949
27995987,"
Make an array (vector would be better as shown below) of pairs by using std::pair from STL. Then sort the array of pairs. Here is an example (try it live):
Note: this example uses C++11. To compile this code with g++ you need to use -std=c++11 flag. 
",0,27995949
27984984,"
compare is not a function, it's a function template that can be used generate functions, such as compare<int> and compare<long>
So to pass a function to sort you need to name a specialization of the function template:
Alternatively, create a function object and pass that:
This function object has a member function template that can compare any types (like your compare) but you don't need to refer to a specific specialization when passing it to sort, you pass a temporary of type Compare and inside the sort algorithm the compiler will select the right specialization of the function template.
",6,27984859
27984936,"
You need to specify which specialization you want:
Live on Coliru
",8,27984859
27981607,"
There is one version of std::sort that accepts a ""comparator"", so only thing you need to do is to define a comparator that compares strings by their length.
Then you can use this comparator to sort your word array:
In C++11 you can even use lambda to make it one-liner:
",1,27981349
27981563,"
You can use std::sort:
",1,27981349
27959534,"
Calculate the sum of the array let it be S and let the repeated element be x.  The repeated element can be determined by taking the difference between S and the sum of the array without the repeated element: x=S- (1000*(1001))/2.
",4,27959397
27971525,"
Let's say, the x was replaced by y. The summation method tells that
Of course you can't deduce two variables from a single equation; you need another. Calculate the sum of squares:
Now recall that sum of squares is n*(n+1)*(2*n + 1)/6
",1,27959397
27964105,"
The sum of 1...1000 = 1001 * 500, and is therefore zero modulo 1001. Thus, finding the sum of the array modulo 1001 will give you the repeated element.
",0,27959397
27964638,"
1000 is not that large. In addition to what other people have said, you could use a count array. For each number x you update the count count[x] = count[x] + 1 and check if this number is equal to 2.
",0,27959397
27949469,"
You would use a comparator object. Here's an example using a lambda.
",4,27949394
27949476,"
See the reference.
You can write a comparison function - basically anything that can be called with two arguments of the element type of your list, and this call returns value convertible to bool. Such ""anything"" can be a lambda, function object, or simply just a function:
",3,27949394
27949508,"
you need this implementation of sort:
then pass inside a compare function like:
then call it:
",1,27949394
27949471,"
http://www.cplusplus.com/reference/list/list/sort/
You should write your own comparer, example and usage in the link ;) 
here is the code example as promised
(thanks for the constructive criticism)
",0,27949394
27949466,"
Yes, and all you have to do is implement a comparator class, or overload the comparison Klasse::operator< operators. For reference on the sort method, see this.
",-1,27949394
27949416,"
You can try this:
",2,27949379
27949488,"
In general, a for loop like: for (a; b; c) d is nearly equivalent to code like:
There are a few minor differences, but for the kind of thing you're dealing with, they're probably irrelevant.
",2,27949379
27949448,"
You can replace either of the for loops with equivalent while loop.
OR if you choose to convert outer loop, then
",0,27949379
27947520,"
Instead of cout, use a filestream that writes to a file.
",0,27947460
27947797,"
Here is the complete code:
I have defined function to write to file:
This function taken in the array and array size, and then separates successive elements with a , if the element is not the last element.
In main(), i have called it just like your display() function like so:
",0,27947460
27934556,"
Create a single vector that contains pointers to the elements in the other vectors, and then sort that vector (using a dereferencing comparitor of course)
Hmm, I wonder if something like this is already in the standard library?
See it working here: http://coliru.stacked-crooked.com/a/8ed0015a7535b236
",0,27934541
27884957,"
Your loop condition doesn't make any sense. str is not convertible to bool. You should instead structure it like this:
Otherwise, your code works fine. If you want to avoid keeping a counter variable, you can use s.end() instead of s.begin() + count. And finally, you don't need to provide a custom comparator, it already uses operator< by default.
",4,27884935
27865400,"
You have out of bound access with
where only i < v_eded.size(), not i + 2
",1,27865362
27866629,"
this should more or less do it:
",1,27865362
27876786,"
I just edited my code and I used simple *select sort* algorithm.
Thanks.
",0,27865362
27809293,"
You could use std::sort or bubble sort algorithm(link how it works). Algorithm checks is current number in loop bigger from next one. If it is change those numbers in array. At the end you get the biggest number on the end of array and smallest at beggining of array.
",2,27809130
27809201,"
Something like this:  
",1,27809130
27808404,"
Here's my $0.05 implementation to elaborate on my comment:

store all chapters inside a collection keyed by unique (section,chapter number):
As you can see I chose an interval set for storing the page ranges. This makes it easier to do the merging regardless of input order.
So let's do that. I fill the table in ""random"" order:
That's all!
Now we can print the modules by section/chapter simply like this:
Prints:

Now that we created the required order, let's add some unpredictability (which is subtly different from chaos).
Bam. We have a shuffled view of references to the module table entries. But! Random is not the goal. 
So we find adjacent pairs from matching sections and try to remove those by rotating them away. It's possible, of course, that there will be nothing left to swap with (from another section) in which case we leave the duplicate(s) in the trailing position:

Of course, print the resulting selection:


A version that prints some diagnostic/trace information can be seen here:
Live On Coliru

Full Listing
Live On Coliru
",2,27801992
27804414,"
Your problem could be reduced to a well-known algorithm for random shuffling if you could somehow eliminate your second requirement of consecutive placement of files with the same ID.
You can fix this by shuffling groups of files instead of individual files (of course a group may consist of a single file).

Make a data structure that represents a file group with a specific type and ID, and a set of pages
Combine your list of files into groups
Run a random shuffle on a collection of groups
Expand the results back into a list of individual files

Here is how this group structure might look:
Your sample data would look like this:
Now the pages of related files would remain together, no matter what way you shuffle the groups.
",1,27801992
27780588,"
You are implementing a sorting network and have used an odd-even sorting algorithm.
This needs O(n) iteration before the output is fully sorted.
However more efficient algorithms exist like the bitonic sort. This only need O(log² n) iterations. The shader will become more complicated as the other value will change depending on the iteration number.
You can simplify it by using another texture where the other index will be encoded and whether to take the minimum or the maximum.
",4,27780124
27720486,"
std::sort() requires a boolean, binary predicate which yields a strict weak order. Your predicate clearly isn't boolean. Interpreting 1 as false and -1 as true should yield a strict weak order, though.
",1,27720429
27712336,"
Your comparison functions are both broken. Neither implements the necessary strict weak ordering that std::stable_sort requires. Specifically, 

Irreflexivity: f(x, x) must be false.
Antisymmetry : f(x, y) implies !f(y, x)

Your functions fail on both accounts.
You probably want this instead:
",6,27712197
27712249,"
You could simply write a DecreasingBThenA
Live Example that produces your desired output.
If you have N elements in your Data, and you want to be able to do arbitrary sortings, then indeed all you need is DecreasingA through DecreasingN comparisons (each returning a.X > b.X for data member X), and you then do multiple passes using std::sort in the reverse order of the criteria that you want it sorted. So BThenA requires first sorting on A then on B. This is the same way as you would sort data in Excel on various columns simultaneously using the column-wise sort button.
",2,27712197
27712326,"
DecreasingA does not provide a strict weak ordering as required by the sorting algorithms and thus any particular behavior is not guaranteed.
",1,27712197
27680586,"
In general, you should use containers available in the standard libraries, which provide efficient sorting methods where applicable.
That said, if you want to do it for learning purposes - as you probably ""should at least once"" - then it is not too difficult to implement.
That's a funny for loop, personally I'd prefer:
Note also that you (unnecessarily, of course) assign head to current twice - immediately before the for loop, and in the initialisation of it.
A simple scheme (but not at all efficient!) might be to just swap 'out of order' elements as you iterate through the list, until no swaps were necessary:
This assumes a data field is the only other in the node - since it doesn't actually swap the nodes, just the data. (Doing the former is not really any more difficult - but without seeing your node type declaration I'd be making up names and risk confusing the issue.)
",2,27680268
27680390,"
I don't see any declarations for current, head, and temp, but I assume they are pointers to node. Have you decided on a sort algorithm? Does the sort algorithm need to be efficient or is something with the performance of a bubble sort ok? With logic similar to a bubble sort, you can repeatedly move the node with the largest value to the end of the list. Or to save a bit of time, you could remove the node with the largest value from the original list and insert it into the front of a new list that would end up in sorted order. More efficient algorithms use logic based on merge sort.
To remove or swap nodes, using a pointer to pointer can avoid special handling for the first node of a list (the one pointed to by pList in this example):
",0,27680268
27677975,"
In addition to timbre's answer (int array[size];), there is a problem with the following block 
Line array[i] = array[m] overwrites array[i] in a wrong way. It should be array[m + 1] = array[m].
That block could be a little bit improved in terms of readability;
",0,27677783
27677827,"
Here you declared an array with size-1, thus the legal index is [0, size-2], not [0, size-1].
As you are expecting an array with size elements, just declare as int array[size];.
",1,27677783
27678378,"
you can try . simple change.use  array[size] not use array[size-1] because array indexing is array[0,1,2,3,----size-1] for array[size] and
for insertion sort use array [m+1] = array[m] replace of array[i]=array[m] because when you use array[i], in loop i fixed but m change. so it's dismiss insertion sort technique.
hope it is okk.
",0,27677783
27697463,"
A possibility could be to define your rows as structs {a,b,c}, compare the 'a' fields and then use the compiler's struct assignment feature to swap the structs (in effect swapping the rows).
Does this help?
",1,27674617
27674849,"
You should wrap each entry in a structure with three fields and define a comparison that is based on the value of the first field:
After that you can just use the standard sort function
If instead the array is already given as int data[][3] things are more annoying, I'd probably go for manually inlining a shell-metzener sort:
It's a decent sort algorithm for the general case and it's just three lines of code.
",1,27674617
27675435,"
The variable heads used for sorting and would use corresponding index to access the data. For example, in the above dataset first 5 elements are considered simplicity.
Before Sorting:
After sorting data in heads would look like this:
Actual token data remains the same:
",0,27674617
27675368,"
I spent a day trying to build a structure. Unfortunately my c++ knowledge - experience is not up to the task. I could not get anything to compile. So I went the old Fortran way and got this code to work and accomplish what I need. 
Code bloat? Most likely from the headers. Run time? Loops through the whole long data stream more than twice. Oh well, it works but if I could make a structure work I'd change it, or at least do a benchmark.
So this is not really the answer I wanted.
",0,27674617
27618528,"
There is nothing in the standard library which would support your use case directly. You could use Boost.MultiIndexContainer for this purpose, though. Something like this:
(Code assuming correct headers and using namespace directives for brevity).
The idea is to create a container with two indices, one which will guarantee the ordering based on B and the other which will guarantee uniqueness based on A. decltype() in the code can of course be replaced by the actual types of A and B which you know, but I don't.
The order of the indices matters slightly, since for convenience, the container itself offers the same interface as its first index. You can always access any index by using container.get(), though.
The code is not intended as a copy&paste solution, but as a starting point. You can add customisations, index tags etc. Refer to Boost documentation for details.
",4,27618207
27618286,"
Is there a container like std::set, which can be defined with two different predicates, one for sorting and one for uniqueness
std::set defines whether particular element is unique OR not in terms of the sorting criteria you provide to it( by default it uses less<>) . There's no need to explicitly pass another criteria for checking equality of elements.
With that said, however, you can use a predicate with algorithms to check for equality of elements of std::set.
",1,27618207
27608680,"
If the list is sorted in ascending order, then for the comparison function you're using each node has greater or equal value to the previous one. I.e. the values are never decreasing. Just iterate through the nodes and check that.
Note: the condition you have shown,
does not check anything reasonable: it checks whether a value is less than or equal to that value plus 1.
One idea for a more reasonable condition is to compare nodePtr->value to the previous node's value. To do that easily, you need to have stored the previous node's value (or a pointer to the previous node) in the previous iteration. In some variable.
",1,27608656
27609618,"
Maybe this will work...
",2,27608656
27509323,"
Here is a working example based on your comparator.
Ouput
How is your code different from this?
",1,27504538
27455327,"
This swap is wrong:
You change student_database[i] but then reassign it to its previous value. You're supposed to update student_database[i + 1].
Better to use std::swap() anyway:
",1,27455249
27455606,"
When using the fstream data type it's crucial to specify the type of file access. There's a number of ways to go about it in your code but the simplest to me seems to be:
",0,27455018
27438979,"
Find the position of the element to replace, and find the position of where the element you are inserting should be, once it is inserted (use lower_bound for both these cases). Then replace the element, and rotate.
",2,27438798
27442371,"
Slightly improved Benjamin Lindeley's solution:
",0,27438798
27415048,"
You just need to do the swapping outside the inner loop. 
Get this part 
out of the inner loop. 
Your code should look like this: 
Here's a very clear explanation of Selection Sort with images and steps: http://www.algolist.net/Algorithms/Sorting/Selection_sort
",2,27414727
27414976,"
There is nothing wrong with the concept of what you've done, all I'd be looking at is the placement of that third last closing brace }.
Do you really want to be swapping inside the inner loop when the whole intent of the inner loop is to find the element you want to swap with? By definition, you can't have found it until the loop is finished.

Try figure that out for yourself but, if you can't for some reason, see below:
",1,27414727
27414797,"
ALL sort routines need a temporary copy of the values being swapped. SWAPPED. Think about the need for this. The first thing that stands out is that I do not see swapping anywhere. You are smashing your values resulting in duplication of them. Where did you get this design from?
",0,27414727
27414854,"
2000 > 100, you might find bucketsort -> counting sort a suitable method to solve your current problem. 
edit: in english: you have an array of 100 integers that keep a count of what numbers are in the input
As others have mentioned, your sort isn't even swapping values properly.
",0,27414727
27404596,"
You might have problems with your algorithm but what stands out is a very bad memory handling bug.
When you say:
You allocate memory for  single int and initialize it with the value of sizeLeft. That's clearly not what you want. If you want to allocate memory for an array of int you should say:
Note the square brackets instead of parentheses.
You also don't release the memory before the function returns so you leak memory every time it's called. To free the memory you'll need to do:
Having said that, this is C++ and there are better ways to have a dynamic array such as std::vector.
",3,27404091
27372523,"
Note: You didn't include your error messages, so the following answer is more or less based on view compiling:
sortF(), not sortF

error: expected primary-expression before ‘)’ token
    std::sort(open.begin(), open.end(), sortF);
                                             ^

You need an instance of sortF, not the type struct sortF. Either use sortF() to create a temporary object, or use a function instead of a functor:
Tile* vs const Tile&
You use std::sort on a std::vector<Tile*>, but your comparing function uses const Tile& as parameter. Either use std::vector<Tile> or correct the type in your function:
",2,27372385
27372516,"
Since the elements of the std::vector of type Tile*, the function that compares two items of the std::vector must take two Tile*s.
",1,27372385
27372652,"
You definitely must change references to pointers in the comparer function. You didn't tell where exactly you got the error about comparison between pointer and integer, but I believe it happened on this line:
std::remove() takes a value type of the container, not an index. What you wanted to do is probably
That said, this operation as well as sorting take quite a bit of time, and as Javi V commented, using heap structure is preferable here.
",0,27372385
27349812,"
On first glance, it looks like you're leaving Book objects in the same position in the array, and just swapping the titles or authors (depending on the sort function) and leaving the remaining member the same.
You should be swapping the objects themselves e.g.:
Same for sorting by title.
",0,27349713
27347785,"
time() only has second resolution. Your sort probably finishes fast enough for you to not see it tick.  If you want to time it, you'll need to use a clock with more precision. 
If you have access to C++11, the easiest would be:
Pre-C++11, you can use this:
",2,27347739
27348014,"
The first issue is that you calculate the time by making a difference between finish and start time: 

time_t is generally expressed in seconds.  
And portable programs should not use the value returned by time() directly, but always rely on calls to other elements of the standard library to translate them to portable types (such as localtime, gmtime or difftime). 
With difftime() you'd get a double value expressed in seconds, but using the precision available to the specific library implementation you use (which may be below the second).  

A better approach would be to use C++11 <chrono> : 
However, there's then a second issue: although this is portable and precise, you are bound to the limits of clock resolution of your operating system.   
On windows for example, this clock resolution is of 15 ms.  Anything below 15 ms might appear as a duration of 0. 
The easiest way to improve your time measurement, especially in the case of benchmarks, could be to increase the number of iterations your measure.  Instead of performing the measured code once, measure the time for thousands of successive iterations, and compute the average time per iteration.    
A less portable approach would be to use native OS high resolution timers, to circumvent library implementation limitations:  

For windows, you could use QueryPerformanceCounter as explained in this blog.   
For linux you could use clock_gettime() as explained in this SO question. 

",0,27347739
27328055,"
This line is a problem:
It does assignment, not comparison.  Its true/false comes from the value of b[0].
That is the first if in Movie::CompareByName(Movie m)
",2,27328029
27328401,"
You're likely accessing an out-of-bound index i here:
Also, MovieList::BubbleSort can be simplified to just:
More problematic parts of your code:
Given how you've implemented those comparision functions, your usage above is incorrect. You're creating an empty Movie movie; variable and you're comparing that against your movies[i]. That's a big reason why your sort isn't working. What you really want is to compare adjacent items in your movies list. Something like:
",0,27328029
27308377,"
You don't initialize X before you use it to index the array. And then you never
increment X after reading data into the array, so all your input numbers are
being stored in the same location. Each one wipes out the memory of the
one that was read before it.
The only reason it appears that you are able to print the original array
correctly is that you print each value you read immediately after you read it,
before you wipe it out by storing the next value in that location.
If you had separate functions to load the array and print the array,
the print loop would occur after the input loop finished and you would see just
how bad your input was.
You might consider this as a question for https://codereview.stackexchange.com/.
A major part of the reason for this error is your programming style, which
frankly needs a lot of work. (Nothing to be ashamed of, you're new at this
and you haven't learned the ropes yet.)
The separation of functions (input vs. output) that I mentioned in the previous
paragraph is one of the aspects of programming style.
Likewise the uninitialized variable, which would be much less likely if
you used a preferable style of loop control logic.
",0,27308294
27307558,"
A priority queue allows setting a custom comparator which you can use to your advantage, by comparing the counts (map values) your queue can be sorted by value (map can also use a comparator but it only works on the keys):
",0,27307022
27307305,"
You can create a new map container  as follow
and insert pair from the already existing map to this. The new map will sort itself as you want.
Here the code snippet.I didn't compile.
",0,27307022
27298306,"
If you don't need, there is no need to return, you can have return type as void
",6,27298269
27298337,"
There is no need to return anything. You have passed the vector by reference using & so it is already being modified in memory.
Use void and you don't need to return a value
",1,27298269
27311803,"
For this particular case, where the container will have ~2 elements, it doesn't matter one tiny bit. The time spent enumerating files and deleting them will be orders of magnitude slower than your choice of algorithm and data structure. Just put the file names in a std::vector, use std::sort (which will sort your log file names so that the earliest comes first), then delete the N-2 first items. Job done.
But for some general advice:
These days the general advice seems to be that std::vector is better than std::list even for many things std::list seems like it would be good for, due mostly to the fact that it's contiguous storage which is more cache-friendly.
It's possible to construct benchmarks that'll show std::list is faster, but you won't go far wrong if you pick std::vector for everything!
If you need to maintain a container over time and always need to be able to remove the smallest/largest element, std::priority_queue can be a good idea.
If you need to find the N smallest/largest items in a container, std::partial_sort is an algorithm for doing that; it'll be faster than a full std::sort because it doesn't waste effort sorting the elements you don't care about.
But as with all general performance questions like this, the only correct answer has to be ""try it and see"" I'm afraid!
Edit: I originally suggested boost::circular_buffer since that's what the problem sounded like, but it's clear now that it's not a good suggestion as ordering needs to be created by sorting, not by insertion order.
",3,27298218
27298396,"
None really here gets it, the guy needs to compare the name of 2 files , not data structure lessons
use the  string::compare  to compare the files, yes it will compare those numbers in the end of your logfiles too so don't worry about that
here is how it works
oh and about the data structure selection, you don't need to care about efficiency, or performance issues 
I mean you are just indexing 2 files by name a simple and humble array will do the trick
here an a example on how to do it
additional notes :
You can you use a circular array of 2 positions, that would require no sorting on the files, but you mentioned something about restarting your application , so I guess that's not a optimal solution for you,
(if you want an circular array/buffer example just tell me)
Data structures don't come with buildin sorting functions , at least most of them , so you just have to make one of your self
",0,27298218
27301120,"
Actually I have used Boost for sorting the files in the last modified manner:
where fs = boost::filesystem
And because I have used a list of strings, I have not changed the whole code, but added the list::sort(compareAccessTime) when initialising the list. I need that only at the start of the application, because then I add at the end and delete from begin.
",0,27298218
27369336,"
User error.  The some (complex) code written by a 3rd party was manipulating the SQLite output under certain circumstances.
",0,27288333
27272230,"
Rewrite your loop as:
Live code here
Why does it workYour loops make all pairs of 2 numbers and add the difference to rev. So in a sorted array, bth item is subtracted (n-1-b) times and added b times. Hence the number 2 * b - n + 1

There can be 1 micro optimization that possibly is not needed:
",4,27271880
27271975,"
In place of the if statement, use
rev += std::abs(stren[pos]-stren[c]);
abs returns the positive difference between two integers. This will be much quicker than an if test and ensuing branching. The (long long) cast is also unnecessary although the compiler will probably optimise that out.
There are other optimisations you could make, but this one should do it. If your abs function is poorly implemented on your system, you could always make use of this fast version for computing the absolute value of i:
(i + (i >> 31)) ^ (i >> 31) for a 32 bit int.
This has no branching at all and would beat even an inline ternary! (But you should use int32_t as your data type; if you have 64 bit int then you'll need to adjust my formula.) But we are in the realms of micro-optimisation here.
",4,27271880
27271991,"
This should give you a speed increase, might be enough. 
",2,27271880
27272208,"
An interesting approach might be to collapse down the strengths from an array - if that distribution is pretty small.
So:
This way, we can reduce the number of things we have to sum:
If the strengths tend to be repeated a lot, this could save a lot of cycles. 
",1,27271880
39423246,"
What exactly we are doing in this problem is: For all combinations of pairs of elements, we are adding up the absolute values of the differences between the elements of the pair. i.e. Consider the sample input
3 10 3 5
Ans (Take only absolute values) = (3-10) + (3-3) + (3-5) + (10-3) + (10-5) + (3-5) = 7 + 0 + 2 + 7 + 5 + 2 = 23
Notice that I have fixed 3, iterated through the remaining elements, found the differences and added them to Ans, then fixed 10, iterated through the remaining elements and so on till the last element
Unfortunately, N(N-1)/2 iterations are required for the above procedure, which wouldn't be ok for the time limit.
Could we better it?
Let's sort the array and repeat this procedure. After sorting, the sample input is now 3 3 5 10
Let's start by fixing the greatest element, 10 and iterating through the array like how we did before (of course, the time complexity is the same)
Ans = (10-3) + (10-3) + (10-5) + (5-3) + (5-3) + (3-3) = 7 + 7 + 5 + 2 + 2 = 23
We could rearrange the above as
Ans = (10)(3)-(3+3+5) + 5(2) - (3+3) + 3(1) - (3)
Notice a pattern? Let's generalize it.
Suppose we have an array of strengths arr[N] of size N indexed from 0
Ans = (arr[N-1])(N-1) - (arr[0] + arr[1] + ... + arr[N-2]) + (arr[N-2])(N-2) - (arr[0] + arr[1] + arr[N-3]) + (arr[N-3])(N-3) - (arr[0] + arr[1] + arr[N-4]) + ... and so on
Right. So let's put this new idea to work. We'll introduce a 'sum' variable. Some basic DP to the rescue.
For i=0 to N-1
sum = sum + arr[i]
Ans = Ans + (arr[i+1]*(i+1)-sum)
That's it, you just have to sort the array and iterate only once through it. Excluding the sorting part, it's down to N iterations from N(N-1)/2, I suppose that's called O(N) time EDIT: That is O(N log N) time overall
Hope it helped!
",1,27271880
27322695,"
It seems to be Quicksort, as the function name suggests; however there apparently is no recursive call to sort the parts after pivoting. I suggest moving the output out of the function quickSort and add recursive calls to parts of the array after the poivoting and rearrangement.
",2,27271481
27271508,"
The answer lies in the Wikipedia article linked in this post.
",-3,27271481
27269888,"
std::pair<U,V> doesn't provide any ordering functionality by itself. If you don't want to write any additional code on your own (like conditional std::swap), then the closest you can get is to  use std::minmax instead of std::make_pair:
By default, std::minmax will use less-than operator (<) to determine the order of elements. It can be customized arbitrarily:
",2,27268850
27268553,"
Arrays decays to pointers, so your comparison S[j].name>S[j+1].name is comparing pointers and not the strings.
If you want to compare string you need to use either std::string instead of character arrays, or use strcmp.
",2,27268453
27264039,"
First, read up on insertion sort.
The innermost loop performs part of an insertion sort, inserting the element into the (presumably) sorted subarray ""to the left"" of the starting point, but considering only the elements a multiple of interval away. The second loop (for(i=...) performs the other half of the insertion sort, advancing through the array; when this loop is finished, the entire array is sorted, but only in the sense that there are no elements out of order separated by a multiple of interval. That is, there are no i and k such that array[i] > array[i+k*interval].
The outermost loop iterates through smaller and smaller intervals, until it does a ""full"" insertion sort of the whole array.
I suppose the idea of starting with large intervals is to speed up the whole sort by allowing elements that are very big or very small to ""leapfrog"" large sections of the array rather than creep through every position; how well this works is not immediately obvious...
",0,27263540
27261590,"
The problem is that in that inner loop you start at 0 even though you know that all elements in [0, i] are false. So I think you can do this:
Note that while the above looks like it has 2 loops each element is examined only once so the runtime is O(n) as opposed to your original solution which is O(n^2).
",1,27261404
27248519,"
partial_sort is efficient and easy to provide because it is basically a quicksort where recursions that aren't necessary for the desired range are skipped. There is no equivalent efficient partial stable sort algorithm; stable_sort is usually implemented as a merge sort, and merge sort's recursion works the wrong way.
If you want a partial sort to be stable, you need to associate position information with each element. If you have a modifiable zip range you can do that by zipping together the elements and a iota vector, but modifiable zip ranges are actually impossible to build within the current iterator concepts, so it's easier to do indirect sorting via iterators and rely on the iterators' ordering. In other words, you can do this:
Now your base vector is still unsorted, but the vector of iterators is sorted the way you want.
",5,27247828
27246140,"
You can easily do this with std::sort.  You'll need to supply a custom comparator but thats not a problem.
Its much easier if you use std::array to define your 2 dimensional array though as follows:
You can then sort it as follows:
Doing the same with a C-style array is still possible but would require an implementation of a custom iterator that advances a whole ""row"" at a time as a standard iterator (ie a pointer) would treat the 2D array as if it was 1D.
Here is a full example using C++ arrays:
",3,27246045
27246116,"
You can sort them once by the first item, and them sort them again using the second column. This is similar to the way radix sort would work.
",0,27246045
28565709,"
The problem is that phoneDirectory::getData returns a copy of the data member, so each iterator ""belongs to"" a different vector.
You need it to return the actual member, not a copy of it.
",1,28565458
28565820,"
You have 
Problems with that function:

a.getData() returns a copy of the private data by value. Hence, p and q are iterators on different vectors. Comparing them leads to undefined behavior. You are not comparing p with q but you are comparing p with getData().end(), which is essentially the same thing.
Since the return value is a copy of the member data of a, these are temporary objects. The objects get destructed after the execution of the lines. p and q are the equivalent of dangling pointers.
The argument to the function is an object. After the above errors are fixed, you'll end of sorting a copy of the argument used to call the function. In the calling function, you still won't notice any difference.

The function sortByCode suffers from the same errors.
How to fix the problems

Change the argument type of the function to a reference.
With that change, you will notice any changes to the object in the calling function.
Change the return value of phoneDirectory::getData() to a reference.


That will not only fix all the errors but it will also sort the contents a and not a copy of the contents of a.
",0,28565458
28556773,"
Yes, it is. And it's kind of easy. Maybe, you've heard about function strcmp(char* ptr1, char* ptr2).
It compares string char-by-char, and returns:

0 - if strings are equal
<0  the first character that does not match has a lower value in ptr1 than in ptr2 
>0  the first character that does not match has a greater value in ptr1 than in ptr2

So you need to replace this array[count] > array[count + 1] with thisstrcmp(array[count],array[count+1])>0. And it's supposed, that your  array is char* array[]. If not, it won't work correctly at all.
",0,28555343
28548904,"
This will vary from standard library implementation to standard library implementation (and may vary based on other factors) but in general terms:

std::nth_element is allowed to rearrange the input container as it sees fit, provided that the nth_element is in position n, and the container is partitioned at position n.
For small containers, it is usually faster to do a full insertion-sort than a quickselect, even though that is not scalable.

Since standard library authors will usually opt for the fastest solution, most nth_element implementations (and, for that matter, sort implementations) use customized algorithms for small inputs (or for small segments at the bottom of the recursion), which may sort the container more aggressively than seems necessary. For vectors of scalar values, insertion sort is extremely fast, since it takes maximum advantage of the cache. With streaming extensions, it is possible to speed it up even more by doing parallel compares.
By the way, you can save a tiny amount of calculation by only computing the threshold iterator once, which might be more readable:
",5,28548703
28530972,"
Binary operators can only be declared with two arguments if they are non-member functions. The use of the scope resolution operator :: in OrderedList<mytype>::operator+ says that operator+ is a member function of OrderedList<mytype> but if that is so it cannot take two arguments. The first argument is implicitly a pointer to the current object, the second is the right hand argument.
If the function was declared as a friend in OrderedList<type> then it is a non-member function, you can define it as:
That is, without the scope resolution operator.
If it was declared as a member function (taking the righthand side only), then you define it as:
Where the left hand argument is implicitly this.
",3,28530911
28531000,"
Your current operator+ is taking 3 arguments. Two explicit and 1 implicit (this). So this is not a valid operator+. The 0 or 1 argument the compiler is telling you about is the fact that you are writing a member function, so a part from this you should either:

take 0 additional arguments (and have unary operator+, as in int x = +a)
take 1 additional arguments (and have binary operator+, as in int x = a + b)

What you want is probably the second. So you can do either of the following:

replace all occurrences of a in the body with (*this)
move that operator out of the class and effectively declare a free function (recommended)

",2,28530911
28526291,"
You return the mid position for the pivot, but after partitioning it could have been moved elsewhere.
The usual solution for this is to move the pivot to the front, do the partitioning and finially put the pivot to its right place.
",1,28525869
28526416,"
Taking @CommuSoft's example 

20  6 15  3  8

In the first step, 20 and 8 will be swapped, giving 

8  6 15  3  20

with low=1 and high=3.
In the next step, high stays at 3 and low goes up to 3 as well. Since low == high nothing will be swapped, which leaves you with a value lower than the pivot in the upper range.
To fix this compare 
This allows the pivot to be moved as well and avoids a half partitioned range.
Which leaves the final issue, returning mid as the partitioning point. Since the pivot value might be moved too, you must return the real partitioning point, which is low 
",0,28525869
28533017,"
Your partition function is incorrect. There are two primary methods for partitioning a sequence during quicksort: the squeeze and the sweep. The former of these is the one you're attempting and has a high likelihood of fewer swaps than the latter method at the price of a more complicated algorithm.

The Sweep
I'll show you what the simpler sweep method looks like first, as it is honestly the simplest to understand. In general, the algorithm does the following:

Exit early if the sequence length is less than two. There is nothing to partition for a sequence of length-one.
Choose a pivot value in the sequence. Choosing a pivot value that reduces the chances of a O(N^2) degenerate condition is the holy-grail of quicksort partitioning, and I'll not cover it here, but there are plenty of writs on the subject available online.
Swap the pivot value with the last value in the sequence.
Walk the sequence with two index values; the reader index and the writer index. as you march up the sequence any reader-indexed value that is ""less than"" the pivot value is swapped into the lower sequence at the writer-index, and the writer index is incremented.
When finished, the writer index is the point where the pivot value is swapped into final position and the partition is complete. The resulting partition point returned is the writer index position.

This algorithm is actually easier to understand with code:
Note it is entirely conceivable values larger than the pivot value may well be swapped multiple times as the lower partition is filled during the march. Eventually it all settles out, but these additional swaps are ideally avoided. That is the purpose of the squeeze method, shown next.

The Squeeze
While the sweep has its advantages (most notable being simplicity), minimizing swaps is not among them. Ideally you only perform a swap when you have determined two values are out of place on opposite sides of the eventual landing home of the pivot value. To do this requires you perform a low-to-high sweep simultaneously with a high-to-low sweep, and as soon as each finds an element in the incorrect location, swap those. Eventually the low index and high index meet, and upon doing so you've found the pivot final resting place.
There a several things going on here that may seem odd. Note the boolean logic for the second inner-while loop that reduces high. I could have written (A[high] >= A[len-1]) but I wanted to drive home a common mistake. It is critical the condition which reduces high be logically inverse to that which promotes low. If low is promoted because its element is strictly less than the pivot value as we have it here, then high can only be reduced if its element is  not (strictly less than the pivot value). The is no doubt we have it right when shown as coded above, and I simply cannot do justice to the number of times that specific requirement is glossed over and resulted in mysteriously broken partitioning algorithms.

Sample partitions with QuickSort
Either of the above will work. A few slight modifications to the functions to produce output when a swap happens and sorting a randomly shuffled array of values demonstrates the swap-count reduction. The following implements both algorithms in two partition functions, appropriately labeled sweep and squeeze. They are both turned loose on identical random sequences, then again on fully-sorted sequences to demonstrate the swap-count differences.
Output (random)
Best of luck.
",1,28523641
28523681,"
It seems that you're returning the value of the pivot instead of its position in the partition function.
",0,28523641
28523762,"
Here is is an implementation using a partition index:
I could not figure out what was wrong with your code. In the middle of debugging i noticed that you edited the code in the question. Hope the above code helps you in root causing the issue.
",0,28523641
28522987,"
As @ConnorHollis already pointed out in the comment, you are allocating a new OrderedList instance inside the +-operator. Apart from this not working because of different types and being dangerous because returning a reference generally indicates that the caller does not need to care about ownership, it's also very unexpected. The +-operator should always return a new object, that is returned copy constructed.
",1,28522653
28522988,"
Your method definition looks like this.
However the plus operator usually returns a new instance of the class type so it should likely be:
Without the reference as you can see.
Now you have a pointer to a new OrderedList but you don't need to allocate it! You can just create an instance of it and return it via a copy constructor or assignment operator. So I would change the new list instantiation to look like this:
Then it will likely compile.
I decided to make you a simple demo! http://ideone.com/bFiv1W
Hopefully that explains it a little better.
",1,28522653
28521070,"
If you are using libstdc++ (g++'s standard) as your standard library implementation, you can rely on its built in ""Parallel Mode"".
To use it, you need to compile with -fopenmp and have _GLIBCXX_PARALLEL defined during compilation. Here you can find more information on the usage as well as a list of the algorithms that gcc will consider for parallization.
Be aware of the following warning from the usage site:

Note that the _GLIBCXX_PARALLEL define may change the sizes and behavior of standard class templates such as std::search, and therefore one can only link code compiled with parallel mode and code compiled without parallel mode if no instantiation of a container is passed between the two translation units. Parallel mode functionality has distinct linkage, and cannot be confused with normal mode symbols.

Each individual parallel algorithm can also be called explicitly. You only need to compile with -fopenmp (and not the _GLIBCXX_PARALLEL flag), and include the parallel/numeric or parallel/algorithm depending on the function listed in this subsection of the documentation. Be aware that the parallel algorithms are in the __gnu_parallel namespace.
",11,28520720
28513139,"

...giving priority first to the X dimention, then Y, then Z

Use std::sort with std::tie, something like following 
DEMO
",2,28513049
28513135,"
You could use an std::tuple<double, double, double> to represent a point. The comparison for std::tuple works lexicographically, the way you want it to. Alternatively, you could provide a custom sort function to your vector of points. Something like this:
Also, as this question shows, you can achieve some sort of a named-tuple-with-lexicographic-sorting by using std::tuples lexicographic sort and std::tie.
",3,28513049
28513145,"
You can use the std::sort() to easily sort according to your specific conditions by making your own comparator function.
Assuming you have stored a single 3D point in a struct point, and the points in a std::vector<points> (A std::tuple might be more useful.), try out this code.
Example:
",2,28513049
28520868,"
",0,28512021
28517772,"
The beauty of the skiplist is that it sorts the data items and also offers o(log n) insert and delete time complexity. To make it more understandable, imagine your linked list had short cuts or anchors such that you don't have to traverse the whole list to find the position to insert an item. You just follow the anchors, thus it is a double-linked list with quick access anchors. 
As for implementation, if you don't intend to use the skip-list for multi-threaded access, then it becomes trivial to implement. There is no reason to combine a skip-list with a double-linked list, but you can implement a skiplist as a double-linked list
Look at
http://www.sanfoundry.com/cpp-program-implement-skip-list/
",1,28511881
28702455,"
I hope this helps you.
",1,28511881
28506642,"
One thing that looks odd is the line:
This does not always return an element between left and right.
Perhaps try instead:
The current code might result in a pivot value that doesn't reduce the length of the array, and therefore you end up with an infinite recursion that eventually crashes when all the stack space is used up.
",2,28506415
28499612,"
Boolean type has an advantage here. You can simply count number of trues.
In which case sort function should look like:
Note that this is a descending order (true goes first).
",5,28499469
28667512,"
This code sorted different data types except for Boolean – I doubt it. Have you tried to sort array of int, say int arr[4] = {4, 4, 4, 4}...?
Your code has a flaw in handling partitions: when the N-items subarray to be partitioned consists of equal items, the second internal loop in partition() terminates with header==p and you get partitions of N and ZERO items. That causes an infinite recursion and leads to a crash due to the stack overflow.
You need to skip sorting the pivot item—after partitioning it is in its final position and doesn't need to be touched anymore:
",0,28499469
28494307,"
You have forgot to initialize the int variables i, j, k to 0 (zero) in the function definition for merge(...).
After Edit:
Hope it helps!
",0,28493728
28491649,"
std::sort takes a pair of iterators.
You could define your own helper function that takes one argument.
You probably want to create your own namespace for the helper function.
",2,28491584
28469598,"
Basically, what you want to do is:

First sort by size of the first vector in the pair<>.
Then lexicographically  sort the vectors.

You have to write your own comparator function for this.
Code: 
",6,28469335
28446643,"
When I mockup a players class and run your code it works fine. The error must belong somewhere else.
However your code could be tightened up considerably, by checking for equality and return the result of the comparison:
Consider as well that strings are usually listed in reverse sort order(alphabetical).  Therefore the less than operator(<) would work better:
",1,28445063
28435268,"
You can use a C++11 lambda as well apart from using static/out-of-class functions or use the method suggested by P0W. 
The lambda takes care of the order in which to sort.
",2,28434944
28435138,"
std::sort can't use points_cmp because it doesn't have this pointer, as you are trying to pass a pointer to a member function, so
If your compiler support C++11, you can use :
Or else make function static or a free function out of class
",2,28434944
28435291,"
In case of Code1 c++14 alows to do even better:
",2,28434944
28435934,"
You can consider a lambda to sort the vector<Point> in a custom way; the customized sorting order can be specified in the body of the lambda (note that lambdas are available starting from C++11):
Note also that in the lambda you must use the [this] capture syntax, since you are calling the dist() non-static member function inside the body of the lambda.

In addition, if your Point class is not cheap to copy, consider passing it using const& (to avoid useless ""deep copies""):
",1,28434944
28426540,"
That's my solution based on yours. First of all sizeof(array) returns the size of pointer. Second I return the index of the smallest item, not it's value, then I swap it with the first element in list. And then I call the sorting for the list starting with another element (the left parameter), because I know that the list up to left-1 is already sorted.
",2,28426147
28427681,"
A fully recursive solution:
To sort an array, find the smallest element and swap it to the first position. Then sort the rest of the array, until there is a single element left.
To find the smallest element in an array, take the smallest of -the first element and -the smallest element in the rest of the array, until there is a single element left.
Call Sort with (Array, 0, N).
",0,28426147
28424549,"
use ptr[] instead of *ptr[] because,
ptr is pointer and if used with [] then it returns element at that location like array does.
",1,28424462
28424536,"
error is in *ptr[count]
this is wrong syntax for a pointer dereferencing.
Do ptr[count]
or *(ptr + count)
",0,28424462
28424545,"
Here's the compilation errors removed version.
",0,28424462
28424555,"
read also: C++ Using pointers for selection sort function
for more examples: http://www.codemiles.com/c-examples/c-selection-sort-t2916.html
*ptr[count] doesn't mean anything
ptr - pointer
*ptr - value - dereferenced
",0,28424462
28424714,"
This is the correct structure
You must not use * while using the pointer notation of an array, the use of pointer name without '*' itslef refers to the 0 index of pointer array 
",0,28424462
28408845,"
the solution is to rewrite your code to use the stl, I don't understand why people write C code in C++.
You need a vector of User
You now have the same functionality in a much nicer and clean way
",5,28408240
28408617,"
Easy , direct method cause binary searching is too mainstream. Just need a few lines:
Let me know if this is the answer you were looking for
",1,28408240
28408900,"
Binary search will be of limited interest, as you will need to insert anyway and this will remain a time consuming operation (O(N)). So your first idea of a linear search followed by insertion is good enough; you can combine in a single backward loop. (This is a step of StraightInsertionSort.)
The truly efficient ways to handle dynamic sorted lists are by maintaining a balanced tree or using a hash table.
",1,28408240
28408794,"
Reinventing the wheel is fine if you want to learn how to code binary search, otherwise reusing is better.
std::lower_bound performs a binary search on a sorted range [first, last), returning an iterator to the searched element x if already present; otherwise the iterator would be pointing to the first element greater than x. Since standard containers' exposing an insert would insert before the iterator, this iterator can be used as-is. Here's a simple example.

12
12

",1,28408240
28408704,"
You can do binary search like this way.. Here You can assume that if val is string type then compare using string comparison function and int AR[] is set of string or You can map them to integer. As the array is sorted , I think binary search will give you the best performance.
",0,28408240
28409844,"
From what I can see, you're using a C array to store your entries, which means a big penalty in performance with huge number of entries whenever you try to insert an new entry because you may need to move a lot of entries in the array.
If you plan to keep a C array and not using some stl ordered containers (mostly thinking about std::map though), you may try to split your C array into two arrays. One will be a first array containing your key and an index to an element of the second array. You still need to sort the first array but its element is only two words (one for key, one for index) instead of a big block including key and some values) and should be faster. When inserting an item, you allocate at the end of the second array and take the index to insert it as a pair with key inside the first array. If you plan to remove an element dynamically, you can be a little smarter but your question appears not to cover it. 
But even so, it might be still too slow, so you should indeed consider std::map or some algorithms like binary tree using AVL, Red Black tree, Splay tree, etc. where you do not need to move element physically. 
",0,28408240
41622639,"
If you're sorting a sorted list with only a few new out of place trailing items then you should take advantage of the rare case in which insertion sort actually works efficiently. Implementing insertion sort on a sorted list with only a few trailing out of place values can sort in O(n) time. You're just inserting your few out of place values into place, while quick sort is picking a pivot and going through the entire quick sort process. Also, if you're not incorporating some type of efficient pivot selection process into your quick sort, and going with some ""average of first 3 items"" approach on an already sorted list you're going to be sorting in O(n^2) time.
",0,28408240
28408516,"
It will probably give you the index you need to add...I hope it can help.It assumes you do not need to add when its already in.
",-1,28408240
28403196,"
I suggest putting the three arrays into an array of struct and sorting the array of struct.
and
You can sort an array of csr_data using any of the three member variables. When they are sorted, all elements of csr_data will be rearranged regardless of which member you use to sort the data by.
",0,28403078
28383443,"
It's a sort of bubble algorithm.
",0,28383375
28383682,"
It will most probably be a bubble sort algorithm. ( need the code of SwapNums(int *Num1,int *Num2); to be certain).
",0,28383375
28384556,"
It is a selection sort that performs a swap at each intermediate solve, rather than waiting until the end of an iteration to perform the swap.

Aside from complexity and space, sorting algorithms often have various characteristics which can be used for identity.  When identifying the type of an algorithm, it may be helpful to provide additional output during each step of the algorithm, then use this output to define traits.  For instance, here is a example based on the original algorithm that provides output at each step:
#include <array>
#include <iostream>
#include <utility>

void print(std::array<int, 5>& array)
{
  for(int i: array)
    std::cout << i << "" "";
  std::cout << std::endl;
}

int main()
{
  std::array<int, 5> seq = {5, 1, 4, 2, 8};
  std::cout << ""Start: "";
  print(seq);

  for (std::size_t i=0; i < seq.size(); ++i)
  {
    for (std::size_t j=i+1; j < seq.size(); ++j)
    {
      std::cout << ""index: "" << i << "","" << j << ""; ""
                << ""element: "" << seq[i] << "","" << seq[j] << ""; "";

      if (seq[i] > seq[j])
        std::swap(seq[i], seq[j]);

      print(seq);
    }
    std::cout << ""-- next iteration --"" << std::endl;
  }
  std::cout << ""End: "";
  print(seq);
}

And its output:
Start: 5 1 4 2 8 
index: 0,1; element: 5,1; 1 5 4 2 8 
index: 0,2; element: 1,4; 1 5 4 2 8 
index: 0,3; element: 1,2; 1 5 4 2 8 
index: 0,4; element: 1,8; 1 5 4 2 8 
-- next iteration --
index: 1,2; element: 5,4; 1 4 5 2 8 
index: 1,3; element: 4,2; 1 2 5 4 8 
index: 1,4; element: 2,8; 1 2 5 4 8 
-- next iteration --
index: 2,3; element: 5,4; 1 2 4 5 8 
index: 2,4; element: 4,8; 1 2 4 5 8 
-- next iteration --
index: 3,4; element: 5,8; 1 2 4 5 8 
-- next iteration --
-- next iteration --
End: 1 2 4 5 8 

Just examining the code itself, there are a few traits that can be identified:

Complexity is O(n^2)
No additional space is allocated, so space complexity is O(1)
The algorithm does not use branched recursive, so it is not a divide and conquer algorithm.
It is a comparison sort.

And when the output is examined:

The ordered list is built from left to right.
Start: 5 1 4 2 8
End of 1st iteration: 1 5 4 2 8
End of 2nd iteration: 1 2 5 4 8
End of 3rd iteration: 1 2 4 5 8
End of 4th iteration: 1 2 4 5 8

The indexes being compared are not always adjacent.  In the first iteration, index 0 and 3 are compared.
The elements being compared always include the currently known smallest unsorted element.  In the first iteration, 5 and 1 get compared, then 1 gets compared to all of the other elements.

With all of this traits, the algorithm most closely resembles a selection sort.  The sort pages on wikipedia often do a fairly good job at characterizing and illustrating the algorithms, but it can also be very helpful to consult an algorithm book.
",0,28383375
28381763,"
I wouldn't use a map for this at all. You should probably figure out what information you actually need for each element of the data, and create whatever data types you need to support that. E.g.
You can then parse in your data, and create a std::vector<State>. Sort  the vector and data as appropriate using std::sort (you can use lambdas, or create comparison functions or functors if necessary).
",0,28378765
28378240,"
You are not putting the number in the correct final array position, check how now first is used to mark the position where next element should be put in final array:
Also I removed the unused second variable
",0,28378109
28378198,"
The indexer for the final array should be independently increased from the indexer (i) for the numbers array. In other words:
The other issue with your code is a typo in the if statement within section //Numbers greater than 0. I'll let you figure that one for yourself :)
",0,28378109
28378256,"
You're getting strange numbers on output because your code doesn't completely fill the array (it prints out the contents that were already on those memory positions).
Without giving out the code (you're almost there):

You should iterate your for loops (all three of them) through the whole array size (0 to 20), remember that during these loops you're trying to check values, so you need to go through all of them.
Assign to your final array based on your counters (first, second), and not based on i. Again, i is just used to loop through the arrays. This causes your arrays to have holes right here. You're only assigning values to final when you enter the if statements, and only in their respective positions (i).
Your if statement for numbers greater than zero is incorrect, it check for equals.
Initialize first and second with 0, not 1.

That should do it. As a side note, you don't really need two separate counters, first and second. You could use just one, incrementing it in your first loop, and then continue incrementing it in your second loop and so on.
",0,28378109
28363990,"
Just use std::sort with a function object (a lambda here) that compares the first element of each pair (and which uses the operator< from std::vector)
Live Example using C++14. 
You can adapt it to C++98 by writing the range-based for loop using iterators / indices, and by writing a separate function object that you pass to std::sort. Oh, and you would also have to use the awkward push_back initialization instead of the more convenient initalizer-lists from C++11 and beyond.
",2,28363778
28359267,"
You might meant to swap a[i] with a[i+1] while you actually swapped a[size+1]
",1,28359167
28359271,"
These lines are wrong:
You need:
",1,28359167
28355119,"
Sorry, I didn't bother incorporating the solution into your existing code, but this definitely works:
",1,28353961
28352630,"
This block is not right.
You have not initialized data and yet you are using the values of its members in the for loop.
What you need is something along the lines of the following logic:
",1,28352389
28352409,"
Here is a little helper that makes sorting by some derived value easy:
You call order_by( function ) and it returns a function object that takes values, and orders them by whatever the function returns.
So order_by( function ) returns a function object that takes two things, and tells you if the left one is ""less"" than the right one according to the order that function tells you.
This is useful because C++'s standard library can be passed ordering function objects and use them for a whole bunch of reasons.
This helper makes writing upGPA pretty short:
order_by( [](classSchedule const& s){return s.currentGPA;} ) is where the magic happens.
I'll unroll it.  A simpler way to write it is:
but I like my way.
order_by takes a function of one argument, and builds an ordering (a replacement for <).
It takes a function of type A->B (read it as ""elements of type A to elements of type B"") such that B is ordered (supports <), and produces a function of type (A,A)->bool that is an ordering on As.  It does this by taking each argument, mapping it through the A->B map, then comparing the Bs.
So order_by is of type (A->B) -> (A,A) -> bool that returns an ordering based off of the A->B function.
I find this projection -- of a type to an order -- is quite useful.  In this case, it may be overkill.

An easy implementation of downGPA -- sort up, then reverse:
you could instead use reverse iterators, or use a negated order-by, or whatever.  But the above is simple and less bug prone.
The function upGPA and downGPA shouldn't outputToConsole.  Do that in a different step.  Printing is a different problem than reordering in upward or downward order.
The above uses C++11.  With gcc or clang, you may need to pass in a flag to enable support.
If you lack C++11, this will work:
then:
should work.
or even easier:
which does the same thing. (I removed order_by here).
",0,28352007
28352452,"
You have couple issues with your sorting functions:

Your loop condition is counter < end and you use [counter+1] as array index, you will go out of array boundary on the first iteration, suggestion change condition to counter < end -1
Code if (schedule[counter].classNumber == 000) is dangerous and is not clear why you need it. Probably to avoid previous error

Coolprit seems to be this code:
When you sort in descending order that record goes to the end and it works fine. But when you sort in ascending that record is in begining and you interrupt your loop. If you wantto skip records with GPA -1 replace break with continue in that code.
",1,28352007
12553314,"
In terms of (asymptotic) time complexity - they are both the same.
""Recursive is slower then iterative"" - the rational behind this statement is because of the overhead of the recursive stack (saving and restoring the environment between calls). 
However -these are constant number of ops, while not changing the number of ""iterations"".
Both recursive and iterative quicksort are O(nlogn) average case and O(n^2) worst case.

EDIT:
just for the fun of it I ran a benchmark with the (java) code attached to the post , and then I ran wilcoxon statistic test, to check what is the probability that the running times are indeed distinct
The results are conclusive (P_VALUE=2.6e-34, that means that the probability they are the same is 2.6*10^-34 - very not probable). But the answer is not what you expected.
The average of the iterative solution was 408.86 ms while of recursive was 236.81 ms
(Note - I used Integer and not int as argument to recursiveQsort() - otherwise the recursive would have achieved much better, because it doesn't have to box a lot of integers, which is also time consuming - I did it because the iterative solution has no choice but doing so.
Thus - your assumption is not true, the recursive solution is faster (for my machine and java for the very least) then the iterative one with P_VALUE=2.6e-34.
",24,28342182
12553297,"
Recursion is NOT always slower than iteration. Quicksort is perfect example of it. The only way to do this in iterate way is create stack structure. So in other way do the same that the compiler do if we use recursion, and propably you will do this worse than compiler. Also there  will be more jumps if you don't use recursion (to pop and push values to stack).
",9,28342182
28290022,"
Here's an example of how to parse some complex numbers then sort them using the C++ Standard Library.  If you want to as a learning exercise, you can replace one part at a time - e.g. introduce your own type instead of std::complex, read some other input format (rather than parenthesised comma-separated numbers sans a trailing ""i""), and/or use your own sort.
Output:
Note: I've just used a std::istringstream so the input can be hard-coded in the program for easy testing: just change to while (std::cin >> c) if you want to read from standard input (keyboard by default).
You can see the code running here
",1,28289847
28270224,"
Your code is subject to undefined behavior. You don't return anything from getFromFileToArray and yet you are using:
If you add the following line to getFromFileToArray just before the end of the function, your program might work.
",4,28270141
28270539,"
There are a few problems:
Minor issues that don't cause your crash:

srand(time(NULL)) should be used only once, usually when the program starts.
rand()%1-30 is always -30.
ProcessTheArraysorts the array size times. This seems unnecessary.

Major issues that may cause your crash:

You don't return a value from getFromFileToArray. Your compiler should have warned you about this.
You never initialise the status field.
You got the spelling of ""strcpy"" wrong in quite a few places.

",1,28270141
30249477,"
Okay, first things first: A DAG is a Directed Acyclic Graph. 

A graph is a data structure that has nodes which are connected in
some way. For instance, a map is a graph, where the intersections are
the nodes and the roads are the edges.
A directed graph is a graph with some sort of direction on the edges;
for instance, many roads are undirected (please stay on the correct
side of the road), but some are one-way.
An acyclic graph is a graph without any cycles; that means that once
you leave a node, you can't get back to it.

You can't sort a cyclic graph; which part of the cycle would come first? But you can sort an acyclic graph, and the result is a 'topological sort.' As you pointed out (maybe accidentally) in your second example, multiple topological sortings may be valid for the same graph.
In order to handle the dependencies in your problem, you will have to use a graph. However, since you know that it will be that it will be acyclic, you can write your own, very concise graph class.
You would store all the nodes in a single array, graph, and the nodes keep a list of the nodes that come after them in out_neighbors (this is called an ""adjacency list"" format).
Now how do you sort them? Well, you want them sorted so that nodes do not depend on nodes that come later. First, you want to find all the nodes that have no incoming edges (i.e., don't depend on anything).
Next, you are going to use these to find other nodes.
At the end of this, topsort will be a list of the node pointers in a sorted topological order. However, all of your incoming edges have been removed from the graph, as well (this can easily be rebuilt using the outgoing edges).

Some suggestions: 
First, your Tasks are already like the simple structure I described here, except that they only have one parent and child pointer; why not have a list of parents (incoming) and children (outgoing)? Then you can sort the Task objects themselves.
Second, once it is sorted topologically, you can run things in threads; so long as all of my incoming edges have been compiled, I'm free to go, too.
",1,28263062
28255076,"
First, your comparison function needs to be able to access the private member text of myclass.
You could either make text public or add
in the class definition.
Second, your comparison function is wrong. It takes pointers to the members of the array to be sorted. You should write it like this:
",0,28254857
28255184,"
Right now, your code looks like a warped version of C code, with just enough C++ ""sprinkled"" in to keep it from working with a C compiler. At least IMO, this gives pretty much the worst of both worlds--it removes most of the best features of C, and the best features of C++. If you're going to write C++, write C++, not warped C.
To create and sort a collection of objects in C++, you should probably write the code more like this:
At least in my opinion, this is quite a bit simpler and easier to understand. It doesn't leak memory. If (for example) we added another item to the collection of items, we wouldn't have to rewrite other code to accommodate that.
Probably more importantly than any of the above, at least for me this leads to faster, easier, more bug-free development. Just for example, the code above was bug-free (worked correctly) the first time it compiled. Other than fixing a couple of obvious typos (e.g., I'd mis-typed operator as opertor) it compiled and ran exactly as I originally typed it in. As a slight bonus, it probably runs faster than the C-like version. With only 4 items, the difference in speed won't be noticeable, but if you had (for example) thousands of items, std::sort would almost certainly be substantially faster than qsort (two to three times as fast is fairly common).
",1,28254857
28254959,"
Your comparison function is wrong. It receives a pointer to each array element, which is a pointer to myclass, not the text.You also shouldn't cast the function pointer when calling qsort, you should cast the arguments in the comparison function.
",0,28254857
28254740,"
You could store each number as a string, but also pre-compute its digit-sum and keep both in a pair<int,string>, then put them into a vector<pair<int,string> and sort it. No need for a custom comparator, the one for std::pair does exactly what you want.
",2,28254456
28254746,"
Just pass a suitable comparison function (or functor, e.g. a lambda would be natural) to std::sort.
",2,28254456
28255646,"
Since you want to compare on sum of digits first and then lexicographically to break ties, it will be convenient to convert your input numbers to strings.
From there you can define a custom comparator to achieve the desired behavior:
Output:
",1,28254456
28247782,"
Here is a pair of merge sort examples, somewhat optimized, and perhaps a bit more than what would be expected from a student.
The top example is a top down merge sort. a[] is the array to be sorted, b[] is a temp array the same size as a[]. Copying data is avoided via a pair of recursive functions that alternate the direction of the merge depending on the level of recursion.
The bottom example is a bottom up merge sort. Note the sorted array can end up in either a[] or b[]. This can be avoided by calculating the number of passes and if the number of passes is odd, swap in place for the first pass.
Both sort examples use two arrays and merge using indexes. The main difference is top down uses recursion to repeatedly split pairs of indexes until the indexes represent a run size of 1, where it then starts the actual merge process, while bottom up skips this step and just starts off with a run size of 1 and starts merging immediately. Most of the time is spent merging, so the extra overhead of recursively generating indexes is small compared to the total time it takes to sort.
top down merge sort
bottom up merge sort
",1,28244634
28236852,"
Check this code :-
The code is copied from here
",1,28235622
28229061,"
You have a struct count and then you also have using namespace std;. Did you realize there is a std::count?
Try not to use
Also, change struct count to struct Count.
Coming to the issue of the sorting function, you can implement it using std::sort.
That should go a lot faster than what you have (N.logN vs N^2).
",1,28228933
28220255,"
Recursion is calling of a function from itself . For one to understand recursivity he must first understand recursivity !
What you are actually asking is basically how to QuickSort works and how it finds it's pivot  ! 
Take a look over this book :
http://en.wikipedia.org/wiki/Introduction_to_Algorithms
It's considered one of the best to explain things like quicksort .
",0,28220152
28220507,"
I am not sure what the exact concern is, but it might help if you think of QuickSort in a very high level view. 
Quicksort works by selecting an element as the pivot and reordering the elements in the sequence into two subsequences, of smaller and larger values, separated by the pivot. At this point the pivot is in place and you only need to sort both sequences independently. 
The heavy work is done by partition that goes over the sequence separating the original sequence into the two subsequences and yielding the final location of the pivot.  Note that after partition completes, the pivot is in it's final location, it need not be moved.
In your case the pivot is selected as the first element, so you would have:
At this point you quicksort the subsequences [ smaller... ] and [ larger... ].
Note that this is not like mergesort, in mergesort you have a fixed split point, you sort both subsequences independently and then build the overall solution by merging the results. In quicksort you pick an element move it to the right location separating the universe into smaller/larger values that form the two subsequences, the split point is determined by the value of the pivot and the relative values of all other elements.
",0,28220152
28213538,"

Write a test with 10 elements in the sequence
Run it under valgrind --tool=massif
...
Profit

There are tons of sorting algorithms and containers implementations around, many (if not most) container implementations allocate/deallocate memory on each insert/erase operation, so you really need to go all the way down to finest details and pick the right combination if dynamic allocation is a problem.
",1,28213415
28213826,"
std::sort: The comparison object expected by it has to return ​true if the first argument is less than (i.e. is ordered before) the second. 
strcmp, the function you provided has another return convention:

Negative value if lhs is less than rhs.
​0​ if lhs is equal to rhs.
Positive value if lhs is greater than rhs.

(here lhs and rhs reffer to left hand operator and right hand operator)
So you have to create your own wrapper function around strcmp.
If you could use c++11 and if you could use c++ for real (i.e. std::string and std::vector) you can use other cool tricks like lambdas.

The classic solution:
The lambda solution:
The real C++ solution
",1,28213100
28213818,"
I've got it working. Like @bolov and @Svalorzen said, I had to write a bool function that returns true or false, instead of -1, 0, 1, like strcmp() does. Here it is, if anyone needs it in the future:
Thanks for your help.
",0,28213100
28204744,"
You just need to define operator less for your structures,
and use std::sort, see example:
http://en.wikipedia.org/wiki/Sort_%28C%2B%2B%29
",1,28204614
28204764,"
After you created a pair of  for the data set, you can use std::map as container and insert the pairs into it. If you want to sort according to frequency define std:map as follows
std::map myMap;
myMap.insert(std::make_pair(frequency,word));
std::map is internally using a binary tree so you will get a sorted data when you retrieve it.
",0,28204614
28182994,"
std::sort does not have a built-in function for sorting complex numbers, so you have to write your own comparator function and pass it as an argument in sort() as
The myWay function is defined as
So, your whole code should look like
",3,28182887
28183074,"
Mathematically speaking, there is no ordering defined for complex numbers, which is why there is no operator< defined for complex. You can try inventing your own ordering function (such as ordering them lexicographically) but that requires writing your own comparator function:
and then calling sort like this:
sort(v.begin(), v.end(), complex_comparator<double>);
However, I'm not quite sure what you're trying to achieve because there is no sense in saying that one complex number is ""bigger"" than another.
",6,28182887
28162290,"
At least normally, it's a tree sort. That is, the items are inserted into a balanced binary search tree (usually a red-black tree), and that tree is traversed in order.
",1,28162267
28162311,"
std::set and std::map are usually implemented using self-balancing binary search trees, usually red-black trees because they tend to be the fastest in practice. For detailed information about these data structures, you might want to consult a textbook such as Introduction to Algorithms by Cormen et al. or Algorithms by Sedgewick.
",1,28162267
28162300,"
The C++ standard doesn't enforce any kind of sorting algorithm for std::set or std::map. So their implementations might differ among different platforms.
With that said, they are commonly implemented as a red-black tree, which is  a self-balancing binary search tree. They don't sort their contents, they maintain the order of their contents as new items are inserted. Inserting a single item to them is usually O(logn).
",1,28162267
28121532,"
The problem is in this part of your code:
And for sorting issue, we should create a temp array to store the temparary sorting result.
Here is a program that works. Similar to yours.
",0,28120943
28114293,"
Because ranges in stl are always defined as half-open ranges from the fist element iterator to to the ""one-past-the-end""-iterator. With C++11 you can use:
",6,28114126
28114247,"

Format for sort in STL in c++ is,

No, it's not. You are supposed to provide an iterator for the first element, and a one-past-the-end iterator, as you've discovered.
The Standard Library in general uses semi-open intervals to describe ranges through iterators. Otherwise it would be impossible for empty ranges to be expressed:
",2,28114126
28104272,"
You can't change the sort order of an existing map.
Illustrating one way to create an index into the map in the form of a sorted vector...

Also, if I flip the map, as some posts suggest...

Not a good idea: just ""flipping"" key and value won't help without also changing the sort comparitor, you'd need a multimap if set sizes could be repeated, and slower and more wasteful of memory than building an index as above (unless you can throw away the original mymap once the re-ordered multimap is constructed).
",1,28103788
28104464,"
You just want to output the map in some weird sorted order.
You should not want to modify the order of keys inside a std::map (that does not make any sense, since the fixed order -i.e. the key compare function - is the second template parameter of std::map).
So get the std::vector of keys from the std::map:
then sort (using std::stable_sort to keep keys of same size in original order) it according to your criteria
and at last display your map using 
",0,28103788
29159556,"
The main issue in the merge step occurs in the case when one sublist is exhausted first. The remainder of the other list is appended to the end of the merge list but none of the prev pointers are being maintained. At the bottom of mergeList(), it should look like this:
Also, there asymmetry in the main while loop that seems like a mistake
Lastly, there are a few places where an single element list isn't being handled properly, e.g. addToFront().
Hope that helps!
",0,29159099
29161795,"
Sort the tree view by click a column.

Set the view can be sorted by click the ""header"".

Connect the header signal to a slot made by you.

In the slot, call the sort() virtual function of the model. sort() virtual function is a virtual function of QAbstractItemModel, and one should override it.

Override the sort() function as your model should do. 
emit dataChanged(QModelIndex(), QModelIndex()); from a model to update the whole tree view. 

",1,29158968
29158141,"
You would probably be better off flattening the matrix to 1 dimension and using a step variable to determine where each row would start. Then sorting is easy.
",0,29157436
29135812,"
Moving the values from vec back to data, you need to iterate through all the 10 buckets, but instead you're only iterating through 8 of them:
This should be:
",1,29135668
29133091,"
This takes a type T and a map M:T->U and uses the ordering on U to provide an ordering on T.
this takes a tuple tup and reties its elements in a different order.
will sort foo via element 3, then element 2, then element 1.
The next thing you want to be able to do is to project each sub element into its own sorting domain.  Still not what you want, but closer.
To solve this, I'd work on piping and making a variardic order_by.
Piping lets you get, then project to a new space.
now order_by can take a collection of projections, and it projects one at a time, picking the first to use.
Now we want to pipe operations together, so the get projection can be followed by a length projection (for example).
and we are almost there!  Replace your Length with:
A slightly different approach would be to chain multiple full orderings together, instead of chaining order_by projections onto each other.
If you really want your specific syntax, work can be done to extract the I and the F and pair them up and build an ordering function call.
None of the above is compiled or tested, but the design should work.
I find the projecting your data into an already defined domain with a well defined < is usually more pleasing than writing a custom comparison operator.
The above uses a handful of C++14 features, mostly _t aliases.  Replace std::blah_t< args > with typename std::blah< args >::type if you lack that alias, or write your own _t alias like template<class...Ts> using blah_t=typename std::blah<Ts...>::type;.  There is also some code that is much improved by the C++14 std::result_of, with the improvement #if 0'd out currently.
The strangest order mapping is reversed_sort_t, which maps T->reversed_sort_t::helper<T>, where helper<T> is a type that supports nothing except reference-semantics default copy and reverses the application of <.  An older version of this solution negated, but negation of -128 doesn't produce +128 when restricted to char.
",1,29131785
29133584,"
I think I got it!
Testing the output:
Output:
First the 3rd component is arranged in reverse alphabetical order.  Then among these 4 tuples ending in u, the string component is arranged from shortest to longest.  There are still three ties, so among these the int component is arranged from least to greatest.  I hope those reading before understand my question now.
I will study Yakk's solution now to see if his method is really different or not.
Update:  I just want to add that I found a more general way to write the above (tested to give the exact same output), using:
",0,29131785
29131430,"
You could define a comparisor operator like this
And after that, instancing it and using it
",0,29131226
29132927,"
!!!Warning std::sort is not expected to be a stable sorting algorithm.
Use std::stable_sort which is most of the times implemented as merge sort. 
",0,29131226
29115234,"
With pre-sorted arrays, the simplest method should be something like
Or if you're using std::arrays
",4,29115047
29117277,"
Merging two pre-sorted arrays require only O(N) time and O(N) extra space where N = n + m. Here n and m are number of elements in each array. 
In above case, if the two arrays are unsorted initially, you have to sort them in O(nlogn) and O(mlogm) time respectively. Then merging them require another O(N) time resulting in total O(max(m, n) log max(m, n)) time asymptotically. 
On the other side, if you join the two array and apply any first sorting algorithm like quicksort (C++'s sort(..)) the time complexity will be O(NlogN) and with O(N) extra space.
So it terms of time complexity, I think you should use merging method of merge sort as your two arrays are sorted initially.
",1,29115047
29117210,"
Not using classes, i.e. pure C:
",0,29115047
29101113,"
a and b arrays are 3 members long, but in merge you use actual values as indexes
",0,29100997
29073946,"
Basically, you want to create a partition:
As for the subsidiary questions:

I had to remove the ""const"" part in the code to make it compile.

That's because your GetActive() method should be const:
See Meaning of ""const"" last in a C++ method declaration?

how can I use this to delete every single object (and pointer to object) that is no longer needed?

You could use smart pointers (such as std::shared_ptr) and no longer care about delete. Thus you could use the Erase–remove idiom as follow:
Related question: What is a smart pointer and when should I use one?
If you don't want to use smart pointers, you could use the returned iterator which point to the first element of the second group (i.e. the non active ones) and iterate until the end of the array:
Note that I'm not calling erase inside the loop since it invalidates iterators.
And of course, this last solution is more complex than using smart pointers.
",9,29073863
29058444,"
Put the data in a vector of vectors, and use std::sort:
Demo.
std::vector comparison is lexicographic, it works regardless of the number of items in it.
",4,29058392
29058531,"

If you want to sort the array, taking column 1 as main index, column 2 as secondary, etc, AND GET THE FINAL RESULT.
An custom sort function will do the work.

If you want to sort the array, specifying which column to sort, AND GET ONE RESULT EACH TIME.
Create a sort object each time you want to sort.


Usage:
",0,29058392
29053786,"
The first sort, sorts the columns of each row (I assume you each row starts with the element 0 or that each row has 0 as one of it's elements). Then you replace the first element of each row with an incrementing number. The lambda function in the second sort is comparing vectors starting with the first column instead of starting with the second column.
I created an example that more closely matches your description. It sorts a vector of iterators to the ""rows"" of a 2d vector (vector of vectors without the first column being an index). The columns of the 2d vector are sorted first, then the vector of iterators to the ""rows"" is sorted without actually sorting the rows of the 2d vector (the 2d vector could be sorted directly if this was wanted).
C version:
",0,29051563
29055379,"
You have a bug in your partition() function (I take it that it's Hoare partition algorithm implementation). You just need to remove this code:
after swapping values.
Here is the corrected partition() function code:
Even with this bug fixed, you should create a good unit test for your quicksort implementation, because there may be some other subtle bugs (it's very hard to write bug-less implementation of partition() from scratch). Check for edge cases, corner cases and boundary cases in your unit test.
",2,29050798
29053436,"
I'm not sure how much this would help but when you get your pivot of
you are doing (0+9) / 2 which is 4. But the thing is, the middle should be 5 if the size of the array is 10.
",-1,29050798
29040698,"
This can easily be found out from the documentation:

Complexity
At most std::distance(first1, last1) + std::distance(first2, last2) - 1 comparisons.

So No. 1 it is. (Yes it assumes that the standard committee got the complexity right, but that is not a stretch.)
Option 4 is obviously false because n + m - 1 grows slower than n*m, so we already have a better estimate.
Option 3 is false with this counterexample:
needs at least two comparisons. Option 2 counterexample:
would need 3 comparisons:
",2,29040650
29040741,"
Assuming m < n, at least m comparisons and at most n+m-1 comparisons (worst case). So assuming all elements of the smallest list come first, the minimum number of comparisons is min (n, m). Assuming that by simplest you mean best case, then answer 3 is the correct answer. Answer 1 is correct for the worst case.
",2,29040650
29003799,"
600000 array size is too much memory on stack.Instead use a global array.
",0,29003559
29003807,"
As far as I know, an array with a run-time size is a C99 feature and only provided as extension in some C++ compilers. Switch this to a std::vector<int> a(N); and the code should work.
BTW:

Sorting this is not the fastest way to find the N-th smallest number.
Please consider Chris' comment, that your question lacks the necessary information. Also, indent and clean up your code, I don't think that it's necessary to run a loop.
You can also retrieve input from IOStreams, no need to use scanf(): while (cin >> N) { /*use n*/ }.

",0,29003559
29003707,"
sort() need some function has return bool type and it accept your int function because it can assume if it return 0 it is false else it is true. You shoudl just give it it is true or not then let sort() fucntion to do its job. For example, if u change your fun fucntion as i show above, then sort() give you output in ascending order in an absolute manner.
Actualy i advice you, mostly use lambdas for these sort function , actually if you put them in auto vars then you can call them more easily.Like that,
PS(sorry for language, it's not my mother tongue.)
",1,29003342
29003405,"
Easiest to use...
...and ditch fun altogether.
If you really want a reusable function (instead of the ""lambda"" above), have a look at the cppreference example here - specifically customLess.
",3,29003342
28998834,"
Just use std::sort:
...
produces
",0,28993556
28994754,"
If I am understanding your question correctly, I think you are saying that you want to determine all TopBottomThing's that have either a top that matches some other entry, or a bottom that matches some other entry.  Then you want to sort those TopBottomThing's by the min(top, bottom).
This is the algorithm that I would use to do such a thing.  Create a std::map that stores a mapping from type T (from the definition of TopBottomThing) to size_t.  Iterate through your input, and for each TopBottomThing, add the top, as well as the bottom (but only if distinct from the top) items to the map.  When adding a new entry, initialize the value to zero.  Otherwise, increment the existing value.
The next step is to create two vectors: one to hold those TopBottomThing's that match something, and one for those that don't.  Iterate through the list of TopBottomThing's a second time, and select max(map[top], map[bottom]) from the map.  If that max value is at least 1, then the result matches at least one of the other entries, so add it to the match vector.  Otherwise, add it to the non-match vector.  After that, sort the match vector, then append the non-match vector, and return that result.  The code is as follows:
Running this code generates the following output:
",1,28993556
28992144,"
If performance is not of significant concern, just use the same idea as Bubble sort. 
Compare last column element between each pair of rows, and if not in order swap the rows. This can be done with a loop and a temporary variable.
Since you are using C++, you can use std::array if your matrix has fixed size rows and columns. i.e.
Here is a working example which uses std::swap to do the swapping of rows. The sorting routine is essentially the bubble sort.
",0,28991630
28992965,"
Maybe this is your answer:
",0,28991630
28958384,"
This is just a quick explaination how you can do it.
",0,28957833
28958168,"
You're reusing the index i in the inner loop causing the outer loop to misbehave. Change it to another variable such as j and change the relevant uses of this variable.
",0,28957833
28958399,"
A custom comparator and std::sort should be sufficient for what you're trying to do. The important part of the comparator is to ensure it follows a strict weak ordering. One of the properties of that ordering is this:

Given a and b, if (!(a < b || b < a)) is true, then a and b must be equivalent.

Constructing a custom comparator as a functor is straight-forward, and is a good place to store your alphabet. To avoid string scanning even with sorted logN efficiency a custom alphabet table holding the numeric sort-order equivalence can be used. This will be very fast, shining especially well for large string comparisons as each char lookup is constant time.
Example of a custom comparator follows:
Output
How it works
The comparator object is constructed from the custom alphabet to initialize a table indexes by all possible char values using their alphabet position as their ""value"" in the table. All non-alphabet chars hold a value of INT_MAX giving them the ""weakest"" possible order value, and treating them all as equivalent. 
Once that is complete the comparator will be handed off to the sort algorithm. When two strings are compared they are walked until a non-matching value is encountered or one/both of the strings reach termination. At that point either the string finished at the same time, the left ""finished"" first, or the right finished first. We know all chars up to that point are equal. Therefore, if the left side finished before the right, only then is the left truly ""less-than"" the right. if they are the same OR the right side finished first (matters not which), the left side cannot be less. Therefore we can simply return whether the right side reach its end as the final answer.
This specific comparator ignores all non-alphabet characters, so any alphabet character will be less than any non-alphabet character, and all non-alphabet characters are treated as equals. If that isn't sufficient for your needs some tweaking may be needed.
Finally, the preparation time for the comparator is a fixed fill-cost plus O(n) for the length of the alphabet. If you're using the same alphabet for many sort operations preparing a comparator ahead of time and just sending it down to std::sort may be warranted. Again, may need some tweaking for your needs.
Regardless, Best of luck.
",2,28957606
28957648,"
Here's a way to custom your sort comparison operator
",1,28957606
28949888,"
Asymptotically there is no difference:

Inserting in ordered collection N times is O(N log N).
Sorting unordered collection of N elements is O(N log N).

So best way to select fastest solution is to implement both and check on real data.
I think storing events in container such as std::vector and sorting them at the end would be faster, because fast adding along with frame preparation will not invalidate CPU caches, that may occur during ""long"" and non-trivial O(log N) insert into std::priority_queue or std::map.
Also storing events in simple container (std::vector) and processing them when needed (sorting etc) looks more logical to me.
",2,28949538
28949967,"
Keeping the queue prioritized all the time needs Θ(n log n) time. Making the heap needs Θ(n) time. Later, both methods need the same time, Θ(n log n), to extract the elements one by one in sorted order. So make_heap is clearly a better choice. But since both methods, when they are needed, are equivalent to sorting your input, quicksort is a better choice.
",1,28949538
28949664,"
std::map<priority, event> might be a tradeoff: do the insert based on priority. std::map's insert is or order n log(n) and keeps it prioritised at all times.
At the time when the events are needed, no processing is needed, just iteration.
",0,28949538
28937208,"
What your are doing has complexity O(nk^2) where n is the size of each array. You merge two lists at a time. Why ? you merge first two lists it takes 2n operations also the size of the first two combined is 2n. Now you merge this with the third, the  array size becomes 3n and 3n operations are done, so total number of operations are 2n+3n+....kn ( arithmetic progression ) which is O(nk^2). Instead take a priority queue ( min heap ) insert first elements of all k lists. Now each time take the smallest element from priority queue ( put this in your new list ), remove it from the priority queue and insert the next element of the list to which this element belonged. As all elements are inserted and deleted from priority queue once and in total there are nk elements the complexity is O(nklog(k)). ( Time to delete / insert ) priority queue is O(log(number_of_elements_in_queue)). And in  the queue at maximum there are k elements at any time. 
For a more detailed explanation plus a code have a look here : Merging k sorted lists. I assume this would be enough to get AC on leetcode :).
",4,28935642
28939026,"
Your problem is that you are doing unbalanced merges. If each list has n elements to start with and merge(a,b) means you merge lists of length a and b (which takes time O(a+b)), then the operations you are doing are
and so you're paying a lot of cost iterating over the long list so many times; with k elements you're doing about (1/2) k^2 n work.
You could look for a specialized imbalance merging algorithm, but a much easier approach would be to just reorganize your work to merge lists of similar size. If you started with k lists each of n elements, then you would do
Each step takes nk time, and there are lg(k) steps, for a total cost of nk lg(k).
If k isn't a power of 2 or the lists are not all the same length, there are lots of things you can do to try and minimize the overall amount of work, but a very simple way is to make lists a deque instead of a vector, and for each merge you pop two lists of the back and push the result in the front instead of the back. Another simple optimization on this is to first sort the lists by length.

The other answer is likely better when k is not too large. When k is rather large you're probably better off with a hybrid algorithm: you pick an appropriate m and you organize the total work as I've described, but rather than merging 2 lists at a time, you merge m lists at a time.
My first two guesses at an appropriate m are ceil(sqrt(k)) and the largest value for which the other answer's algorithm is efficient for an m-way merge.
(if for some strange reason m is still very large, then you do the m-way merge with the hybrid algorithm)

Why do I make the predictions above? The other answer only makes one pass through the data, so as long as your CPU can efficiently maintain a priority queue of length k as well as read from k lists at the same time, it is surely better than my algorithm which makes many passes through the data.
But when k gets too large, you run into problems:

Your TLB might not have enough entries to read from k lists at a time
Your cache might not be big enough to store a cache line or two from all of k of the lists as well as fit a priority queue

cache misses and especially TLB misses will degrade performance. The hybrid algorithm reorganizes the work so that you keep the benefit of my algorithmic approach (balanced merges) while nearly all of the work is done with the efficient m-way merge from the other answer.
",1,28935642
28921889,"
At some point during an ordinary implementation of most sorting algorithms, you'd have something like this:
It is often convenient to ""outsource"" the job of comparing the elements to a separate function (I'm assuming for simplicity that the elements being sorted are integers):
Combined with inheritance, you could define isSmaller() in a base class, and for each sorting algorithm you'd like to implement (quick sort, merge sort, insertion sort...), you'd create a new subclass. However, each subclass should call isSmaller() rather than using < to determine which elements should come before which. Then, you can add your ""count the number of comparisions"" code (which, as you say, would consist of simply incrementing a counter) to isSmaller().
(The point of the task is to make you realize that inheritance can free you from having to duplicate the counting code in every sorting algorithm implementation. Also, when using function pointers or function objects, the idea of ""outsourcing"" the comparison can also be used to make a ""configurable"" sorting class where the user of the class can decide how comparisons are to be performed, in order to e.g. sort numbers descendingly, or to sort a list of persons based on their names, etc.)
",4,28921843
28902618,"
There's no standard comparator that does what you want. Provide your own comparator which gives the order you want:
and use the third (optional) template parameter to specify this rather than std::less
You can shorten (and arguably obfuscate) this slightly by comparing modified pairs:
",4,28902219
28899976,"
The first thing to note is that every number you form with all the elements of the vector has the same number of digits. That's why we can use lexicographical sorting on strings. 
So what we could do in a naive way is to list all posibile concatenations and select the largest from it.
The string comparison used for sorting makes use of the above noted fact for the special case of 2 elements in the vector. So we could modify the naive implementation to first search for the largest to elements using this comparator, concatenate them and then repeat with a vector whose size has been decreased by 1 (the newly concatenated element is also contained in the new vector). But then again, we would choose that newly concatenated element and the remaining largest element for going on. if we would not choose that newly concatenated element, than we wouldn't have picked the 2 largest elements of the vector in the first place. So we pick out the elements one by one in decreasing order. That's why the sort is applied first.
",0,28899727
42040203,"
You have to take greates of all possible combinations of array members.
e.g. 3303459, 9534303, 9353430, 93534303, ....
so, at first you have to sort them, after combine in one string.
for sorting you can't just compare 3 with 30, you have to compare merged value of them 303 with 330, 
if you will check only members like 30 with 3, you'll have 303, but actually in this comparison you should have 330, because 330 > 303, that is why should compare s1 + s2 with s2 + s1,
about while loop, possible suck test case [0, 0, 0, 0], for this case will be generated such string ""0000"", but it's not normal number, we have to remove all 0 started from left except last one, to get normal number ""0""
",0,28899727
28869716,"
There are couple of reasons I can think right off.

You have hard coded comparisons. This helps in pipe-lining multiple instructions, which makes it highly efficient. But imagine coding it for N=1000. You'll have to write 1000*1000 comparisons.
std::sort does O(nlogn) comparisons. But this Big O notations holds for large N as the constant of notation can be large. So you can't judge the efficient by running on range of 8 values. 

",1,28869451
28847393,"
There are a lot of ways to approach this problem.

If you have only several thousands of vertexes, it can be very fast to just iterate over all of them.
If you are just clicking on a vertex (or other object) in one of the views, then you can render the scene into another buffer using a different ""color"" for each object in the scene.  To figure out which object you clicked on, you just have to read the color from that pixel.
In other circumstances, you can store the vertex data in a spatial index such as an octree.

Remember: Blender is open-source, so you can just read the source code if you want to find out how Blender does it.
",1,28847233
28850846,"
The order in which entries are returned by the server is not specified by the LDAP protocol and data model, and thus is implementation dependent.
Most LDAP directory servers I know would return the entries in their order of creation, but it's not always the case.
LDAP client toolkits support client side sorting. But you can also request Server side sorting with an LDAP Control, if the server supports it.
",0,28846594
28845644,"
@JonathanPotter was right. ""You're not setting ptr->prev when you link a new node in."" that is the problem. 
this code works fine for me. see the modification, added some part for setting prev node. code may be little messy but you may understand the logic and write a better code. 
",1,28842946
28836558,"

Your comparator is incorrect. The documentation for the std::priority_queue states that it should provide a strict weak ordering(that is, it should event1->getTimestamp() > event2->getTimestamp(), not >=).
To make it stable, you can just store the line number inside the Event and compare it if event1->getTimestamp() == event2->getTimestamp().

Something like this:
",7,28836251
28831157,"
Here is a way you could complete your current code. It tries to sort from the most special to the most general case: exact match, match-plus-stuff, everything else.
I assumed that something like ""Mountaineer"" alone would be type 2 and not type 3, you could add a +"" "" in the comparisons if you don't want that.
",2,28830817
28825963,"
You're not going wrong. The server doesn't support the feature.
",1,28825323
28813905,"
First, scan through the sequence to find the first element that's smaller than the preceding one (either a loop, or C++11's std::is_sorted_until). This is the start of the unsorted portion. Use std::sort on the remainder, then merge the two halves with std::inplace_merge.
This should be more efficient than sorting the whole sequence indiscriminately, as long as the presorted sequence at the front is significantly larger than the unsorted part.
",1,28812746
28812863,"
Using the sorted vector would likely result in more comparisons (just to find a matching item).
What you seem to be looking for is a self-ordering container.
You could use a set (and remove/re-insert on modification).
Alternatively you could use Boost Multi Index which affords a bit more convenience (e.g. use a struct instead of the pair)
",0,28812746
28813895,"
I have no idea if this could be faster than sorting the whole unsorted ""new"" vector. It will depend on the data. 
But this will create a sorted copy of a new vector based on the order of an old vector:
You will then need to ""finish"" sorting this vector. I don't know how much quicker (if at all) this will be than sorting it from scratch.
Live demo.
",0,28812746
28816446,"
Well you can create new vector with the order of the old and then use algorithms that has good complexity for (nearly) sorted inputs for the restoration of order.
Below I put an example of how it works, with Mark's function as restore_order:
This works in O(n) up to the point of restore then. Then the trick is to use good function for it. A nice candidate will have good complexity for nearly sorted inputs. I used function that Mark Ransom posted, which works, but still isn't perfect.
It could get outperformed by bubble sort inspired method. Something like, iterate over each element, if the order between current and next element is wrong recursively swap current and next. However there is a bet on how much the order changes - if the order doesn't vary much you will stay close to O(2n), if does - you will go up to O(n^2). 
I think the best would be an implementation of natural merge sort. That has best case (sorted input) O(n), and worst O(n log n).
",0,28812746
28798877,"
I do not understand what your program tries to do. But take into account that class std::string has relational operators. So there is no need to compare each character individually.
I would write the program the following way:) You may change the program such a way that it would ask the user to enter three strings.
The output is
Or you can use a straightforward approach
",2,28798696
28798881,"
Try this:  
It meets the requirement of having a for loop.  
Edit 1:  Using std::sort
If you don't need a for loop:  
",2,28798696
28799652,"
you can also (and more preferably) use a for loop nested within a for loop as such:
",0,28798696
28829485,"
Try this (it's the code from Thomas Matthews, with a simple Bubble Sort)
",0,28798696
28781789,"
From your program it seems you want to sort objects of S classes. In that case your vector should be like this : std::vector<S>. 
Your cmp is a non-static member function of class S and hence std::sort cannot work with it. (Think about how will you use the function).
You can either overload < operator for your class or pass a stand-alone/static member function or you can use C++11 lambda expression.
Thus your class becomes:
However if you want to merely sort vector containing int in descending order, just call std::sort with a C++11 lambda that returns lhs > rhs.
",4,28781714
28781799,"
Your S::cmp() takes S, but S::ia's value type is int.
",1,28781714
28761803,"
It turns out it's a very simple problem, but not very obvious to spot (and the error message doesn't do a very good job in helping out either): 
Remove the const declaration on run() - voilá.
",19,28761802
28762298,"
The compiler refers to swap because std::sort internally uses function swap. However as member function run is declared as constant function 
then the object of the class itself is considered as a constant object and hence data member list also is a constant object
So the compiler tries to call swap with parameters that are constant references or even are not references and can not find such a function. 
",7,28761802
28777999,"
Your algorithm isn't merge sort. It tries to be, but it isn't.
As I understand it, what is supposed to happen is that the inner loop steps over subsequences and merges them, while the outer loop controls the inner loop's sequence length, starting with 1 and doubling on every iteration until there are just two subsequences and they get merged.
But that's not what your algorithm is doing. The outer loop's condition is broken, so the outer loop will run exactly once. And the inner loop doesn't take roughly-equal subsequences in pairs. Instead, the right subsequence is exactly one element (mid is inner, right is inner+1) and the left subsequence is always everything used so far (left is outer-1, and outer is constant 1). So the algorithm will repeatedly merge the already-sorted left subsequence with a single-element right subsequence. 
This means that in effect, your algorithm is insertion sort, except that you don't insert in place, but instead copy the sorted sequence to a buffer, inserting the new element at the right moment, then copy the result back. So it's a very inefficient insertion sort.
",2,28761551
28770602,"
Below is a link to somewhat optimized examples of top down and bottom up merge sort. The bottom up merge sort is a bit faster because it skips the recursive sequence used to repeated generate sub-pairs of indexes until a sub-pair represents a run of size 1. Most of the time is spent merging, so bottom up isn't that much faster. The first pass of the bottom up merge pass could be optimized by swapping pairs in place rather than copying them. The bottom up merge sort ends up with the sorted data in either the temp or original array. If the original array is wanted, then a pass count can be calculated and if the count is odd, then the first pass swaps in place.
Both versions can sort 4 million 64 bit unsigned integers in less than a second on my system (Intel Core i7 2600k 3.4ghz).
merge_sort using vectors works well with less than 9 inputs
For a vector or array of integers, a counting / radix sort would be faster still.
",0,28761551
28765447,"
I've finally figured it out.
In pseudocode:
After rethinking how the iterative merge sort is supposed to work and looking at a couple implementations, in the merge method, all I needed was to check if the middle and right indexes passed in were greater than or equal to the vector size (that way we handle any values that could out of bounds), then merge as usual. Also, looking at this helped greatly understand it; also this. Just to be sure that it works as well as a recursive Merge Sort, I did timings on both and both (recursive and iterative) implementations produced identical times for 500,1000,5000, and 10K values to sort (in some cases the iterative solution produced a faster time).
",0,28761551
28762494,"
You may partition first (std::partition), then sort each 'cluster' (std::sort).
Following may help:
Live example
The lambda may be replaced by this functor in C++03:
and the code become:
",1,28757286
28764237,"
I've deleted my first answer because the results wasn't correct.
Ok so your first problem is clearly problem specification.
What you want and what needs to happen is very very unclear tbh.
So here is my understanding of your problem:
You have a collection of data defined by the following data structure:
The problem is to sort A according to the following priorities:

Sort according to ""cluster"" (see definition below)
The first list (recordType.first.first) is sorted firstly by size and then lexicographically
The second list (recordType.first.second) is sorted firstly by size and then lexicographically
Lastly the second value of recordType is used (recordType.second) ?

""clusters"" are defined by specific collections of the values in recordType.first.second.
So for this example cluster 1: ((101,102),(108,109),(101,102,110),(108,109,110),(111,112,120)) 
and cluster 2:  ((51),(51,54),(40,54,59))
Ok now that the definition is better sorting this becomes fairly easy by just writing the correct sorting function.
How fast you will sort will mainly depend on how fast you can determine cluster number. For this purpose I've used an unordered_map for near constant time look-ups. (My hash function assumes the values in the second list is smaller than 256 and you won't have 2 many of them, for practical applications you will probably need a much better hash function)
Here is the program:
In terms of speed this will be close to O(n. log(n))
However with very large arrays all the lexicographical_compare functions might slow things down a little.
It would be interesting to see if doing a linear O(n) partition or sort of only the clusters will be faster, my suspicion is that it won't really help.
However what might help slightly is to pre-compute the cluster numbers but this require you to modify the data structure.
Lastly from my search it shows that GCC 4.6 does support rvalues so I'm assuming the swapping inside the search will be efficient and not result in a ton of memcpy's.
I've tested this and it seems to spit out the correct results.
(I'm using Visual Studio 2013)
",1,28757286
28751141,"
Let's say bottom is 0, and top is 1 because you called mergesort(a, 0, 1). Then mid = (0+1)/2 = 0. Then mid-1 = -1. Then you are calling mergesort(a, 0, -1) and mergesort(a, 0, 1) (notice...this is the call we started with). The first call will return because it doesn't match the bottom < top condition but the second one is an infinite recursion.
If you'll notice, this problem applies to all calls of the form mergesort(a, n, n + 1), and because mergesort is a divide and conquer type algorithm, you'll be making these kinds of calls quite frequently.
",3,28750882
28727084,"
Another update, converted to template for array type. Tmp array is now passed as a parameter. The copy steps were eliminated and a helper function added to return the buffer that the sorted data ends up in. Tested with 4 million 64 bit unsigned integers, it works but it's slow. Fastest time achieved with numberOfBits = 4. numberOfBits no longer has to exactly divide the number of bits per element.
To explain why MSD first is slow I'll use a card sorter analogy. Imagine you have 1,000 cards, each with 3 digits, 000 to 999, in random order. Normally you run through the sorter with the 3rd digit, ending up with 100 cards in each of the bins, bin 0 holds the cards with a ""0"", ... bin 9 holds the cards with a ""9"". You then concatenate the cards from bin 0 to bin 9, and run them through the sorter again using the 2nd digit, and again using the 1st digit, resulting in a sorted set of cards. That's 3 runs with 1000 cards on each run, so a total of 3000 cards went through the sorter.
Now start with the randomly ordered cards again, and sort by the 1st digit. You can't concatenate the the sets, because cards with higher 1st digits but lower 2nd digits end up out of order. So now you have to do 10 runs with 100 cards each. This results in 100 sets of 10 cards each, which you run again through the sorter, resulting in 1000 sets of 1 card each, and the cards are now sorted. So the number of cards run through the sorter is still 3,000, same as above, but you had to do 111 runs (1 with 1000 card set, 10 with 100 card sets, 100 with 10 card sets).
",1,28726933
28688488,"
You already have the exact code you need for displayPtrArray! The for loop defined in reset should do it. 
Looking at the expected output, the array gets displayed every time there's a change to it. For bubble sort, the array changes when you do your swap (at the end of the if statement), so you want to add your call to displayPtrArray in the line after swap = true.
For selection sort, the array changes at the end of your outer for loop, so you should add the call to displayPtrArray in the line after array[startScan] = minValue;.
For insertion sort, the array changes at every iteration of the inner for loop and also in the last line of the outer for loop, so you'll probably have to call displayPtrArray in both of those places.
Note: just in case you aren't familiar with the syntax, you call the function like this: displayPtrArray(array, size); where array is the name of your array variable (the name is array in bubble and selection sorts; it's a in insertion sort) and size is the size of the array (named consistently in all three of your sorting functions).
",0,28688043
28688212,"
Actually, viewing the process of the sorting is rather simple. You just have to output during the sorting process. You don't need to call another function for that. Try something like this
",0,28688043
28667052,"
uncletall has the right idea--putting the strings into a struct--but there's no need to abandon <algorithm> for nasty legacy C code.
The only magic here is defining an operator< for the new struct that sorts by the first string, and orders empty strings to the end instead of the start. Since you say the array isn't always full (IMHO you really should be using std::vector here), it would be better if you kept track of how many elements were in the array and used it to generate the end iterator.
",1,28666158
28666919,"
I would suggest you use a struct for your data:
This should give you enough to come up with your own solution
",0,28666158
28658362,"
If your algorithm follows that sketched in the comment by MDo, then the search for the correct place could be made with fewer comparisons (by using larger steps than merely one element and reducing the step size as you home in). However, when using a linked list, this won't make your code much faster, since the traversal of the list still needs to visit each single element until you find the correct place (on average half of all elements so far). This will produce the same number of cache misses (which is the efficiency killer) as your simpler algorithm. Hence, keeping a linked list sorted while adding random elements cannot be done efficiently.
What can be done efficiently is to keep the list in heap order, while adding random elements (at a cost of O(log N) each). Finally, after adding all elements, it is straightforward to quickly obtain a sorted order from a heap order. 
In fact, the heap-sort algorithm works this way: first arrange a random order into heap order and then obtain a sorted order (somewhat less efficient than quicksort on average). 
",1,28658237
28658880,"
This algorithm is, in fact, insertion sort (with a small optimization, beeing the lookup of the last sorted element).
It can be implemented to consume less memory. There is some memory that you use to maintain the list - pointer to next element, pointer to tail etc.
You don't really need that, as a simple array would offer same functionality, but consume less memory.
@Walter allready mentioned heap, but there are also other modern sorting algorithms like Block sort which are both in-place AND stable.
",1,28658237
28656740,"
You try to sorting the list several times, for each element separately. A more common solution to you problem is to compare elements pairwise by the particular ordering you want. Writing your own sorting functions is unnecessary when STL can do the job for you much more efficiently. You can sort the structures using std::sort and a lambda function (if your compiler supports C++11)
If your compiler doesn't support C++11, you can override Shipment's operator < in a similar fashion.
",0,28655386
28650530,"
Your code is not the same as the one from this article, as you wrote in your comment. The key difference is in the merging function. 
If you carefully examine your code, you will notice that  there are parts of your code that might alter the data array, without saving it's current state; for example:
Try it out on an array with some 4 elements, e.g. 5,6,4,2 and you will notice some of the original array members will not appear in the output array.
You didn't provide the information about your developing environment, but most of them have debuggers built in. Play around with debugger and you will eventually solve your problem. Or re-read the article and code the algorithm again. 
Best of luck.
(Also, in the future, try to be a bit more specific with question title and try to provide some additional information about the problem, like some examples. People here want to help, but not everyone has enough time to read the question, compile, or debug your code. If you're more specific, someone might know the answer just by reading your question, and with no further investigation )
",1,28644886
28641135,"
The problem is that you are computing the number of entries in temp incorrectly: your code thinks it is right_high + 1, but the correct formula is right_high - left_low + 1.
For example, when a call gives you indexes 10, 15, 16, 26, your code tries to merge 27 values, while it should be merging only 17 (i.e. indexes 10 through 26, inclusive).
This makes no difference when left_low is zero, so your test case runs fine. But as soon as left_low becomes nonzero, e.g. when the right half of the array is being sorted, your code ""overshoots"" both arrays, placing garbage values into tmp and writing over values in the array a as well.
Also the assignments in the last for loop need to be at offset left_low as well:
",16,28641085
28616329,"
bson_compare and bson_equal check if two content buffers are equal (not only values @ two buffers (or memory locations)). It uses memcmp internally to compare two objects. Hence, x==y does not imply that memcmp(x,y)==0.
",0,28615635
28662027,"
Two methods:
(1) It is easy to do this in Python. Write a python function. And call this python function from C++ program.
(2) Using bson_iter_t to iterate each key-value pair in bson_t and do comparison recursively. 
The second method seems more complex. But I decided to use it. Now, I already finished part of the method. 
",0,28615635
28612969,"
You call randomQuickSort with rightIndex=size, which is one bigger than the index of the last element in the array.  Then, passing this to hoarePartition, you initialize j to rightIndex+1, and then (in the second inner while loop) access array[j].
",2,28612871
28612974,"
You are accessing size+1 in your hoarePartition function.  Which is 2 elements out of range for your array, resulting in a index out of range exception.
",2,28612871
28611796,"
Since you're in C++ land anyway, why not use it to the full. First, indeed, move the NaN's and then sort. I've taken out 'noise' from your code and produced this, it compiles and runs (edit: on gcc-4.4.3). The main difference is that the NaN's are at the beginning but they're easily skipped since you will get a pointer to the start of non-NaN's.
",3,28611339
28611455,"
Do a linear scan, find the NaNs, and move them to the end - by swapping.
Then sort the rest.
You can also fix your comparator, and check for NaN there.
For the actual check see: Checking if a double (or float) is NaN in C++
",2,28611339
28611655,"
you can use isnan() in cmath to check for NaNs. So, you can just change your comparison line from:
to:
just a reminder, you need to have:
at the top of your code.
",1,28611339
32257432,"
When analyzing the time complexity of an algorithm, I actually find it helpful to not look at the code and to instead think about the core idea driving the algorithm. If you know conceptually what the algorithm is doing, it's often easier to figure out the time complexity by just thinking through what the algorithm is going to do and then deriving the time complexity from there.
Let's apply that approach here. So how exactly does selection sort work? Well, it starts off by finding the minimum value in the last n elements and swapping it to position 0, then finding the minimum value in the last n - 1 elements and swapping it to position 1, then finding the minimum value in the last n - 2 elements and swapping it to position 2, etc.
The ""hard part"" of the algorithm is figuring out which of the last n - k elements is the smallest. Selection sort does this by iterating over those elements and comparing each against the element that currently is known to be the smallest. That requires n - k - 1 comparisons.
Let's see how many comparisons that is. On the first iteration, we need to make n - 1 comparisons. On the second iteration, we make n - 2 comparisons. On the third, we make n - 3 comparisons. Summing up the number of comparisons gives us a good way of measuring the total work:

(n - 1) + (n - 2) + (n - 3) + ... + 3 + 2 + 1 = n(n - 1) / 2

This is a famous summation - it's worth committing it to memory - and tells us how many comparisons are required. The number of comparisons made is a great proxy for the total amount of work done. Since there are n(n - 1) / 2 = n2 / 2 - n / 2 = Θ(n2) comparisons made, the time complexity of selection sort is Θ(n2).
",0,28599936
29499393,"
As the second value is sorted, you can perform a binary search. (If it weren't sorted, you could just use std::find_if which is linear)
To perform binary search you need to use std::lower_bound which is tricky. You need to provide a functor to tell it how your vector is sorted, in this case by the second value. If it finds the value, it returns an iterator to it. If it doesn't find the value, it either returns an iterator to another value or the end iterator. The if statement checks for end iterator first as it is invalid to dereference the end iterator.
This won't work if your vector isn't sorted by the second value. You may want to assert that it is sorted first, to avoid accidents.
The functor provided to std::lower_bound only needs the key type for the second parameter (when searching, the first pair value doesn't form the key). But to assert it is sorted, both parameters must be the type stored in the vector.
Here is an example using std::find_if which is a linear search but doesn't care if the vector is sorted.
",1,29498879
29497186,"
First things first - this is not a minimum compilable example. If you could publish something we can compile (say here : http://www.tutorialspoint.com/compile_cpp11_online.php) it would help a lot.
Having said that, your comparison function should take arguments by const reference. In addition, in order to sort in descending order you'd need to change the logic of the predicate as follows:
edit:
Have a look at this link - this code compiles and you can use it as a reference.
http://goo.gl/kUVP5r
",1,29497070
29496184,"
If you add some excessive Print calls in your code, you'll see your problem. You sort the size-2 lists correctly, but in the top-level one, after:
list_head will be the list [100]->||| and right_head will be the list [37]->|||. You're actually merging and sorting correctly, it's just that those pointers don't change, so you start with:
And end up with:
And similarly for the other list. So as far as you're concerned at that point, you're just merging two lists of size one, which you do correctly - that's how you end up with just 37 and 100. 
That should point you in the right direction.
",1,29495662
29492889,"
You have an off-by-one error: when you reach the last element and i is one less than size, arrat[i+1] is referencing an element past the end of the array.
Since changing check to false is a ""one way street"", you can simplify your function by returning false as soon as you detect a wrong order; return true when you reach the end of the function.
You can also move the ascending/descending check inside the loop to make the code even more uniform:
",3,29492788
29493342,"
The value you pass to the function is named asc while the parameter for it is dec. Check again if you actually do what you want.
",2,29492788
29492880,"
You're accessing beyond the boundary of the array, change the loop to 
So when you get to size - 2 you compare the last two elements and you're done.
Also you can return immediately after finding an exception instead of completing the iteration.
",1,29492788
29484333,"
add a virtual method to MediaInfo to provide rank information. eg:
then you can sort by obj->rank() and other information;
",5,29484277
29484839,"
While I have seen it discouraged, another (technically) valid way to sort would be the use of typeid. Quick example:
That being said, a virtual method as mentioned in the other answer is probably a better way to implement it.
More information on the pitfalls of typeid can be found here.
",1,29484277
29484823,"
Since C++98 there is an operator called typeid, you can use that.
Example:    
Output:
int
You can take any data type not just built-in.
",1,29484277
29483248,"
You are passing an argument to your first thread, array, and then immediately overwriting the contents of that struct with the arguments to the second thread.  Both threads will therefore see the arguments for the second thread.
What you should do is have two separate arguments.  For example make array an array of 2 structs and pass &array[0] to the first thread and &array[1] to the second thread.
Also, it is dangerous to declare array in the scope of the for loop.  Once the for loop ends, that variable is out of scope and your threads may read into a dead variable.  You should declare array at the function level so that it remains alive for the threads to access it.
",2,29483130
29480165,"
getPrice() in defined to return a double:
Now, in the following statements you get ERROR C2106 since you're trying to make an assignment a number (vs. a variable):
",0,29480075
29480167,"
Try using std::swap (on the car objects) where you get the error (you need the move assignment and constructor to be defined).
The standard library implemented it for you - now go use it.
PS: You are getting the error because your getter function returns a value rather than a reference (to which you could assign a value).
If you don't want to use the Standard Library you could let the getter method return a reference or you could use a setter function on the left side of the =.
",0,29480075
29480195,"
Problem:
Given the class implementation, you cannot set the price using getPrice() since it is just a getter not a setter. Therefore the lines:
are expected to give error about the left hand side of the equation.
Solution:
You need a setter. Something like:
Sample Implementation:
Try adding the following method to your class:
Then call this method to update prices as follows (replace your two lines with those):
Additional:
Although this will solve your current issue on error messages, you still need to revise your sorting algorithm. 

Do you want to sort the cars or just prices? FYI: Swapping the prices will not affect the other data!
What kind of sorting algorithm are you trying to implement? Insertion Sort or Selection sort? Please recall that they are O(nxn). You may use library sort (i.e., std::sort) which is ""quick sort"" and has O(nxlogn) time complexity so much faster for large data. You may refer to:

http://www.cplusplus.com/reference/algorithm/sort/?kw=sort
EDIT ON SORTING:
For sorting the cars in increasing order of prices you could do the following:
First, include the following for using the library sort:
Second, add a less than (<) operator overload to your car class based on price. (Edit: As n0rd suggested instead of operator overloading you may define a custom comparator for more generic approach. There is an example how to do in the above link.) 
You final class will look like:
Finally in your sort function just call:
Therefore your final sort function will be the following (Yes that short!):
Just replace this function with your sort function and it should sort the cars based on their price in increasing order.
Hope that helps!
",0,29480075
29469248,"
This problem is equivalent to the longest increasing subsequence of your string: Clearly it is optimal to leave a maximum number of letters unchanged, and those have to form an increasing subsequence. The other direction works similarly.
While LIS can be solved in O(n log n) on general sequences, you don't even need that because you have an easier special case at hand with a small alphabet size a = 26. You can use dynamic programming to solve the problem in O(n · a):
Let f(i, j) be the optimal solution for the prefix s[0..(i-1)] that ends with letter j. We have the recurrence
Where [k != j] is 1 if k != j and 0 otherwise. By computing each row of the table sequentially (with increasing j), you can compute the minimum in O(1).
The final solution is MIN(j = 0..25, f(n, j)). You can construct the corresponding string by recursively following the DP states that lead to the optimal solution:
Output:
",7,29468187
50279347,"
",0,29468187
29464238,"
Your function takes a pointer (start) and a length (implicit end).
Figure it out?
Hint: there is no mandate that you have to pass a pointer to the start of the array!
",0,29464170
29460283,"
I'm no expert on the topic, but the wikipedia page seems to be a good starting point
http://en.wikipedia.org/wiki/Merge_sort
It contains a section on natural merge sort with an example. 
About binary merge sort:

A variant named binary merge sort uses a binary insertion sort to sort
  groups of 32 elements, followed by a final sort using merge sort. It
  combines the speed of insertion sort on small data sets with the speed
  of merge sort on large data sets

And insertion sort may be read about here: http://en.wikipedia.org/wiki/Insertion_sort
which contains a selection on binary insertion sorting.
About the variables. The wikipedia example of 'bottom up merge sort' (of which natural merge sort is a variant) has this signature:
where A is the array to be sorted, n its length. B is a work array, and if a read the algoritm right it needs be of length n too. Anyway, it can be created in the beginning of the algoritm and deleted in the end.
",2,29460179
29448988,"

tolower works on a single character, not a string. Check out How to convert std::string to lower case?
You are trying to assign a Book to a string (and vice versa). Change the type of temp.

",1,29448933
29449090,"
I take it you're new to C++, first, as Carl Norum mentioned, tolower() works on char's, not strings.
Second, Carl is right about temp being a string (it should be a book), but, there is another large problem, you are copying the ""Book"" class if you plan on doing it this way.  Depending on the size of the class, this could be computationally difficult.  If you must ""sort"" an array multiple times, I would suggest having an array of pointers to speed up the swap function.
Lastly, bubble sort is terrible, don't use it.  If you need a set that is always sorted, use a binary search tree or hash.  If you must sort an array, the ""default"" option is Quicksort, which has a plethora of sources online, so I'm not going to post a how to of it.
",0,29448933
29448776,"
First, note that, if you start at any arbitrary element k, and repeatedly apply the permutation P to obtain a chain like (k → P(k) → P(P(k)) → P(P(P(k))) → ...), you will (since the total number of elements in the permutation P is finite, and a permutation never maps two inputs to the same output) eventually end up back at k.  The cycle of elements (k →P(k) → P(P(k)) → ... → k) is called the orbit of k under P, and every element of the permutation belongs to exactly one such cycle.
Now, let's see what the inner loop of your algorithm does to the cycle containing the element i.
If P(i ) = i, i.e. if this element is already where it belongs, then the inner loop just does nothing and the outer loop moves on to the next element.  If P(i ) ≠ i, however, the inner loop sets t = P(i ), and then modifies the permutation P to swap P(i ) and P(t ).
After the swap, the new value of P(t ) is the old value of P(i ), i.e. t.  Thus, the element t is now correctly sorted, while P(i ) now contains the old value of P(t ) = P(P(i )), i.e. the (former) next element in the cycle.  If this is i, then there are no more elements left in the cycle, and the inner loop ends; otherwise, the cycle containing i has shrunk by one element, and the inner loop repeats.
Thus, at the end of the inner loop, all the elements that used to be part of the same cycle as i (including i itself) have been moved to their correct locations, and thus removed from the cycle, while the rest of the permutation has not been changed.
Since the outer loop iterates over every element in the permutation, it is also guaranteed to visit every cycle at least once.  Of course, we're modifying the permutation in the inner loop, but that's all right, since the inner loop can never create new cycles (of more than one element); it can only break up existing ones.
Thus, the first time each cycle in the original permutation gets visited by the outer loop, the inner loop sorts and breaks up that cycle; on subsequent visits to the same original cycle, that cycle has already been sorted, and so the inner loop simply does nothing.
This observation should also allow you to bound the number of times the inner loop can be executed, and thus to determine the time complexity of the algorithm.
",1,29444411
29442038,"
The best solution might be to change your 
to this which does the job and really can't be made any simpler.
",0,29441787
29441886,"
See this line:
Second faulty line:
It should be:
By the time the code exits of the inner loop, size has a value of one beyond the array size.
My advice: Use an IDE and the debugger to follow up code execution and examine variables. Also, my first hint should have gotten you looking at incorrect indexes. C++ does not care to check array bounds by default.  You usually get garbage when getting out of bounds or following a incorrect pointer. You can remedy the first problem by selecting a compiler option to check for array bounds. That will slow down your application during development time but can be removed once everything works correctly.
",0,29441787
29436440,"
If this is a homework then i think you are expected to implement some algorithm instead of using complicated data structure which will do sorting 'automagically'.
Here is the clue: if element we are searching for does not exist in the vector, then binary search algorithm will stop right at the position where the new element belongs.
Java implementation of binarySearch does exactly this - it returns insertion point - a special value which can be converted into position in the array where new element should be inserted still maintaining the propery of 'sorted'.
In C++ you would have to implement it yourself. Something like this: Binary search to find the range in which the number lies .
May be try reimplementing Java behaviour with std::lower_bound().
",0,29436017
29436676,"
You need to use a sorted data structure like std::map (binary search tree). This would keep your data sorted and insertions/queries would be of time complexity O(log n). 
See std::map for supported operations.
Vector may not be efficient since you want to make insertions and reallocations can get very expensive depending on the size of your data.
",0,29436017
29431720,"
You need to add some handling of the case where the elements you want to swap is just after each other.
Look at A->B->C and swap(B, C)
So the result is A->C->C-> .... and B is lost.
EDIT:
After comment from OP
You have to identify the special cases one by one. Let us call the elements to swap for A and B.
Normal case (where A and B are safe away from each other and not at the start):
Now you'll have to consider the special cases (and handle them first).
Case 1 : A == B
Just return
Case 2 : prevA == NULL
In this case you need to
instead of 
Case 3 : prevB == NULL
Similar to case 2
Case 4 : nextA == B
case 5 : nextA == B and prevA == NULL
Case 6: ....
and so on.
Continue to identify all the special cases and you'll end up with code that works.
I could provide the code for you but I guess you'll learn more by working through it yourself. 
",0,29431208
29434758,"
In your Swap method I made two changes.  First is I made the arguments just a pointer instead of a double pointer.  This is because you can lose track on an element if you are not careful.  The second is I moved the 'tmp' variable a few lines lower because the lines that swap the previous node's next could make before->next different.
So Swap is now:
And so your SortTest would be:
For your main function to test this I used:
Hope that helps!
",0,29431208
29424505,"
What you need is a custom Entry comparison operator. E.g.
And then just sort it using custom comparison. The list will be sorted at first by numbers (the num member) and then alphabetically using the letter member.
",5,29424431
29425394,"
this exploits tuple's lexographic sort to order your entry.  tie makes a tuple of references.
It requires writing make_tie, but once you have that, you get == < for free, and you can use it for a few other functions too -- serialization, printing, swap, etc.
make_tie is C++14 -- for C++11 you need to add a ->decltype(std::tie(e.num,e.letter)) between the ) and { of make_tie.
",4,29424431
29418744,"
You need to compare single objects, not vectors:
This requires getToken to be const
",2,29418595
29418726,"
You don't need to compare vectors of token, you need to compare token:
and of course what the other answer already said, getToken needs to be marked as const:
",1,29418595
29418739,"
As Borgleader mentioned you can simplify your predicate a bit, even though it's not the problem here. You actually need to compare Tokens.
The problem you're having is that the a and b parameter of your predicate are constant so you cannot call a function member on them that might mutate them.
To fix that you have to mark the getter of your class as constant:
BTW, you can also use lambda instead a creating a function. In C++14 you can write:
",1,29418595
29409075,"
The way to do this is by sorting them after associating the order of P with the order of F, i.e. the first element in P sticks with the first element in F and so on. To do this you can use the make_pair command.
This will create a vector consisting of pairs of elements of F and P. After this, you need to sort the array. Calling the simple sort function is defined for pairs in the manner that the first elements are compared first, followed by the second one. So, to sort the vector X, the command would be
After this, you need to put back the values from the sorted vector X into F and P. To do this:
",0,29409020
29409210,"
It's not trivial to sort by key using STL. Sorting with std::sort require single iterator for begin and end, so you have to write some wrapper that will handle both vectors as single iterator.
In general:

moving iterator (operator++ and operator--) should move 2 underlying iterators,
comparison should compare only by the keys
you have to handle element swapping in 2 underlying iterators

Take a look at Sorting two arrays simultaneously. It's detailed description how to solve your problem.
Alternatively, maybe you can consider using map< int, vector<int> > instead of two vectors?
",0,29409020
29404467,"
Another untested solution.  
If I missed a case, I'm sure someone will point it out, but here goes:
Basically, the condition says this:
1) If one of the strings are empty, then return s1 < s2
2) If both strings start with the same character type, just return s1 < s2
3) If the first string starts with an alpha, or if the second string is not an alphanumeric, then the strings are in order and return true, else return false.  The trick here is to realize that step 2) eliminated all combinations of both strings being of the same type, so our check at the step 3) stage becomes simplified.
Live example: http://ideone.com/jxxhIY
Edit:
If you are checking for case-insensitive strings, then you need to change the code, and add the case-insensitive check.  I won't add the code, since there are multiple ways, both with their respective advantages and disadvantages, of doing a case-insensitive compare.  
Again, the myCaseInsensitiveComp is a stub that you should fill in with a function that accomplishes this goal.  For a link, see this:
Case insensitive string comparison in C++
",2,29403929
29404101,"
You can specify your own function that compares values for the sort to use.
Using myfunction you can specify the order you want. Here is more information about sort:
http://www.cplusplus.com/reference/algorithm/sort/
",2,29403929
29404279,"
Anyway, you need implement your own comparison logic for it, and use it with sort.
(1) You can give a comparison function object to sort, and implement your own comparison(less than) logic in it, such as:
and then:
Reference: http://en.cppreference.com/w/cpp/algorithm/sort
(2) You can implement your own char_traits<char> to make a special string which uses the special comparison logic. Such as:
And then:
Reference: http://en.cppreference.com/w/cpp/string/char_traits
",1,29403929
29404323,"
Disclaimer: Untested code.
Here's an implementation of a compare function that should work. The crux of the solution is to re-encode into an array the values corresponding to the characters whose order you want to be changed in the compare function.
",1,29403929
29360696,"
",0,29360629
29360992,"
You are getting this error because you write an extra { on line 27, which will mess up all those { } matching. 
Delete that you will pass the compile. 
Hope this helps.
",0,29360629
29350835,"
Depends on what ar is. If it's a sequence container, the reverse iterators are your friends:
Otherwise, yeah, std::greater<int> seems appropriate for the task...
As for which of your two examples is ""better"", well, they are functionally equivalent and the former uses a standard library feature that is tested and does the job for you. I see no contest, frankly.
",4,29350811
29363360,"
Thanks, murison. Your idea worked.
I set up a value ""EMPTY_ROW"" for Qt::UserRole for the items of empty row. After that I reimplemented lessThan() method in QSortFilterProxyModel:
So this row always appears in the bottom of the table after sorting. 
Also it's nescesary not to forget to clear Qt::UserRole when this empty row is filled with data.
",2,29350352
29328411,"
This code uses the fact that the portion of the array from zero, inclusive, to i, exclusive, is already sorted. That's why it can run  binarySearch for the insertion location of a[i], rather than searching for it linearly.
This clever trick does not change the asymptotic complexity of the algorithm, because the part where elements from loc to i are moved remains linear. In the worst case (which happens when the array is sorted in reverse) each of the N insertion steps will make i moves, for a total of N(N-1)/2 moves.
The only improvement that this algorithm has over the classic insertion sort is the number of comparisons. If comparisons of objects being sorted are computationally expensive, this algorithm can significantly reduce the constant factor.
",2,29328288
29327583,"
Yes it's possible. You just have to make sure that the string ""My song"" compares less than any other string.
By the way, your original idea was a fine one. But what you were doing was a partition. There's an algorithm in the standard library for that too.
",7,29327541
29324685,"
The core reason is no doubt timsort -- http://en.wikipedia.org/wiki/Timsort -- first conceived by Tim Peters for Python though now also in some Java VMs (for non-primitives only).
It's a truly amazing algorithm and you can find a C++ implementation at https://github.com/swenson/sort for example.
Lesson to retain: the proper architecture and algorithms can let you run circles around supposedly-faster languages if the latter are using less-perfect A & As!-)  So, if you have really big problems to solve, deal with determining perfect architecture and algorithms first -- the language and optimizations within it are inevitably lower-priority issues.
",-3,29324660
29323063,"
You can restructure your code so that, instead of two vectors of integers, it uses a vector of S, where S is a structure containing two integers. Then you can define a specific operator< to be used by the sort function.
This has the advantage that the strict coupling between the two sets of data is clearly stated in the way they are stored.
",2,29322981
29323264,"
One possible approach is to use a different data structure. As there is no genuine need to keep the structs ordered, there is only need to detect if the struct with the same key exits, so the costs of maintaining order in a balanced tree (for instance by using std::map) are excessive. A more suitable data structure would be a hash table. C++11 provides such in the standard library under obscure name std::unordered_map (http://en.cppreference.com/w/cpp/container/unordered_map).
If you insist on using an array, a possible approach might be to combine these algorithms:

Bloom filter (http://en.wikipedia.org/wiki/Bloom_filter)
Partial sort (http://en.cppreference.com/w/cpp/algorithm/partial_sort)
Binary search

Maintain two ranges in the array -- first goes a range that is already sorted, then goes a range that is not yet. When you insert a struct, first check with the bloom filter if a matching struct might already exist. If the bloom filter gives a negative answer, then just insert the struct at the end of the array. After that the sorted range does not change, the unsorted range grows by one.
If the bloom filter gives a positive answer, then apply partial sort algorithm to make the entire array sorted and then use binary search to check if such an object actually exists. If so, replace this element. After that the sorted range is the entire array, and the unsorted range is empty.
If the binary search has shown that the bloom filter was wrong, and the matching struct is not there, then you just put the new struct at the end of the array. After that the sorted range is entire array minus one, and the unsorted range is the last element in the array.
",0,29322524
29322615,"
Take a look at Red Black Trees: http://en.wikipedia.org/wiki/Red%E2%80%93black_tree
They will ensure the data is always sorted, and it has a complexity of O ( log n ) for inserts.
A binary heap will not suffice, as a binary heap does not have guaranteed sort order, your only guarantee is that the top element is either min or max.
",1,29322524
29323395,"
Each time you insert an element, binary search to find if it exists. If it doesn't exist, the binary search will give you the index at which you can insert it.
",0,29322524
29381419,"
You could use std::set, which does not allow duplicate elements and places elements in sorted position. This assumes that you are storing the key and value in a struct, and not separately. In order for the sorting to work properly, you will need to define a comparison function for the structs.
",0,29322524
29322552,"
Given that E is quite a big structure, you should have a vector<E*>, so that swapping elements is as fast as swapping a single integer. Then you can use either sort or stable_sort from the standard header <algorithm> (see http://www.cplusplus.com/reference/algorithm/).
with:
At the end delete the elements this way:
You don't need to delete the vector itself, because it has automatic storage duration, and it will be destroyed at scope exit.
",2,29322506
29322634,"
",1,29322506
29289636,"
Since you can't use anything but vector, here's how your AddPerson function should look:
You'll need to define a destructor as well because you're using dynamic memory:
",0,29288965
29289269,"
Instead of using sorted vectors, try using a std::map:
The drawbacks of using a vector:

If you insert a person anywhere other than the end of the list, everything already in the vector has to ""bubble down"", being copied to its new position in the list.
As the vector grows, it will periodically need to be reallocated and the entire set of existing elements copied to the new underlying array.

The benefits of using a map:

The impact of adding new elements to the list is minimal
The interface for adding and looking up elements is more convenient and readable than finding things up in a sorted vector.

",1,29288965
29289213,"
You could do this (example in Python)
",1,29288110
29292035,"
Use a variation of bottom up merge sort called natural merge sort. The idea here is to find runs of ordered data, then repeatedly merge those runs back and forth between two files (all sequential I/O) until there's only a single run left. If the sort doesn't have to be stable (preserve the order of equal elements), then you can consider a run boundary to occur whenever a pair of sequential elements are out of order. This eliminates some housekeeping. If the sort needs to be stable, then you need to keep track of run boundaries on the initial pass that finds the runs, this could be an array of counts (the size of each run). Hopefully this array would fit in memory. After each merge pass, the number of counts in the array is cut in half, and once there's only a single count, the sort is done.
Wiki article (no sample code given though): natural bottom up merge sort .
If all the out of order elements consist of somewhat isolated records, you could separate the out of order elements into a third file, only copying in order records from the first file to the second file. Then you sort the third file with any method you want (bottom up merge sort is probably still best if the third file is large), then merge the second and third files to create a sorted file.
If you have multiple hard drives, keep the files on separate drives. If doing this on a SSD drive, it won't matter. If using a single hard drive, reading or writing a large number of records at a time, like 10MB to 100MB per read or write, will greatly reduce the seek overhead during the sort process.
",1,29288110
29296906,"
Your code is good if you want to check whether one particular number is a hamming number. When you want to build a list of hamming numbers, it is inefficient.
You can use a bottom-up approach: Start with 1 and then recursively multiply that with 2, 3, and 5 to get all hamming numbers up to a certain limit. You have to take care of duplicates, because you can get to 6 by way of 2·3 and 3·2. A set can take care of that.
The code below will generate all hamming numbers that fit into a 32-bit unsigned int. It fills a set by ""spreading"" to all hamming numbers. Then it constructs a sorted vector from the set, which you can use to find a hamming number at a certain index:
This code is faster than your linear method even if you end up creating more hamming numbers than you need.
You don't even need a set if you make sure that you don't construct a number twice. Every hamming number can be written as h = 2^n2 + 3^n3 + 5^n5, so if you find a means to iterate through these uniquely, you're done:
The strange break syntax for the loops is required, because we have to check the size before the overflow. If umax*5 were guananteed not to overflow, these conditions could be written in the condition part of the loop.
The code examples in the link Koshinae posted use similar strategies, but I'm surprised how lengthy some of them are.
",1,29286845
29286506,"
It is, but in general I would encourage just using a proper functor or a lambda:
Using a lambda:
Alternatively using std::mem_fn:
Alternatively using a functor:
Note:
if the types being sorted were anything more complicated than an int you would definitely want to pass them by const& to prevent copying
",6,29286439
29292508,"
As mentioned by Mgetz, a functor can be used. Example of functor:
",2,29286439
29271429,"
You can use bubble sort. So change the sorting function-
There is also an error in your pop() function :(
",0,29269522
29271506,"
Your sorting algorithm is incorrect. 
That aside, since you are using C++, why not just use the built-in sorting function?
",0,29269522
29271923,"
I agree with Akash Jain's solution. Unless there is some restriction against using the built-in sort function , you should go for std::sort with a custom comparator (based on a predicate ) for your Employee class.
Also, why not use std::stack  . That way you can use the built-in pop() method to remove the topmost element.
",0,29269522
29262438,"
The reason you couldn't use sizeof(arr) is that an array becomes a pointer when passed to a function.  So, inside the function when you called 'sizeof(arr)' it was equivalent to 'sizeof(int*)' and that is why you got the error you did.
See this other SO question for an explanation (almost verbatim what I wrote).
",1,29262210
29299110,"
Assuming a unit tile size, the coordinates of the intersections are found at x = i and y = j respectively, for increasing indexes.
Using the parametric line equation x = X + t U, y = Y + t V, the intersections occur at t = (i - X) / U and t = (j - Y) / V, which we rewrite U V t = V (i - X), U V t = U (j - Y), for convenience.
These two sequences are naturally sorted, they follow two arithmetic progressions of common differences V and U and initial indexes i = Ceil(X), j = Ceil(Y). Then what you need to do is a merge of the two sequences.
The second coordinate of an intersection is found from the relevant value of T.
",1,29257490
29248114,"
This code will read data from a txt file and print it to screen. You may refer to cppreference.com to see how all the components work.
Make sure you include the appropriate headers. The reference will tell you that as well.
",0,29247840
29248870,"
I think you can store your data in a New class, and save this data in a vecotr at first. Like this:
",0,29247840
29244484,"
Here is how to call std::sort with your data:
This assumes that compare is a free function that takes two Card const*.  We define card_less to be another free function that uses compare to tell you if the lhs is less than the rhs.
",2,29244216
29244452,"
I think your sort operation is assuming a.x<10, and it is not the case in your example.
Try:
This will sort on the Y axis first (top to bottom), and in the case both are exactly equal, will fall back to sort on the X axis (left to right).
",2,29244129
29239314,"
Here is a simple O(n log n) solution which uses events and sweep line:

There are two types of events: a start of an interval and the end of an interval. 
We can sort all events by their coordinate(if two events have the same coordinate, the one that corresponds to a start of an interval should go earlier. If they are of the same type, they can go in any order).
Now we can iterate over the sorted array of the intervals and add +1 to a counter when we see a start of an interval and -1 when we see an end. The maximum value of the counter is the answer.
Why is it correct? At any moment, the value of the counter is the number of intervals that start before the current position and end after it. That's exactly what we need to maximize.

The time complexity is O(n log n)(we just sort the array of events and then make one linear pass over it).
",2,29238601
29232808,"
You may use this comparator method:
and then simply do
",2,29232738
29233786,"
You can also use this method:
compiled with -std=c++0x.
",0,29232738
29229236,"
You are returning a pointer to local array, which gets destroyed immediately after - this is undefined behavior. You should either allocate it using new or use std::vector (which is preferred).
Also, int result[sizeFirst + sizeSecond]; is not valid C++ because the standard doesn't allow variable sized arrays (but int* result = new int[sizeFirst + sizeSecond]; is valid).
",1,29229120
29223387,"
You could try using a lambda if using C++11 or newer (also, I don't know what your Employee class looks like, so I made a trivial one). Also, check here for online execution: http://cpp.sh/6574i
",2,29223287
29223350,"
You can provide a lambda to std::sort:
That said, in real life last names are not necessarily unique, and when they compare equal it's a good idea to fall back on first name, and if that's also equal some other field like an employee id:
",1,29223287
29212315,"
A high level description of your quickSort routine is:

Take as input a copy of the original vector and the endpoints of a range
Do stuff with the copy
Discard the copy

which isn't particularly useful. Change the input argument to vector<double>& so that you're doing stuff with a reference to the original vector rather than a copy.
",5,29212269
29208093,"
some_compare_function won't be ""confused"". Its first parameter is always an element of sortedIndex, and the second parameter is a value to compare to, that is 10 in your example. So in C++11 you can implement it like this:
",2,29207824
29190626,"
This is a snippet from a test harness that deals and scores 5 card hands.  Perhaps it will help you do what you're trying to do.
",1,29190542
29190565,"
You're probably going to have to roll your own functions to sort through the cards yourself.
Prepare each function to find the required cards for a hand, starting from a Royal Flush down to a pair. Then, iterator through each function one by one until a matching hand is found.
You're also going to want to store the suit in order to be able to detect flushes.
",-1,29190542
29178413,"
What doesn't make sense after half the contents? If we consider an array with 4 elements then 
The solution assumes you index the array from 1 (which is not the norm in programming btw). If you want to have it for a 0 indexed array then the solution for a[i] is
where n is still the number of elements in the array (i.e. with the previous example the value of n would still be 4 but the max value of i would be 3).
Note that this definition means that if there are an odd number of elements to the array then the corresponding element to the mid-point element is itself.
",0,29178237
29175110,"

invalid operands to binary expression
  ('std::__1::__list_iterator' and 'int')
  __sort3<_Compare>(__first, __first+1, __j, __comp);

Alright, that third line of code is somwhere in std::sort.  The only operator there is +.  So the expression with the error is __first+1 where __first is a list<process>::iterator.  List iterators do not have a iterator+int overload, because they are bidirectional iterators, but NOT random access.  
You cannot call std::sort on a std::list.  Use a std::vector instead, or another container with random access iterators.
",2,29175025
29173853,"
After discarding a few mental ideas, I thought of a simple one:
This is clearly a two-pass algorithm, so O(n).  Easy.
StilesCrisis reminds me that this is an implementation of the counting sort.
",5,29173767
29163529,"
Works fine for me. I understand that it's not your exact code, but still.
",0,29163265
29948303,"
One of the error lines seems very helpful:
If you pass an argument that doesn't match the expected type for a function, then C++ will try to find any conversion from the passed type into the expected type.  The conversion include 1-argument constructors and cast operators.  See http://www.cplusplus.com/doc/tutorial/typecasting/
This particular error is indicating that the passed argument cannot be converted to an int.
",0,29940010
29937246,"
1) Which is the quickest sorting algorithm?
Since 2011 Two-Pivot-Quicksort (Yaroslavski) is fastest and 10 % faster than quicksort. It is in the java library. It should use insertion sort for small sublists. 
2) Is there an in-built function for sorting?
No, but most libraries contain fast sorting functions
3) What is this thing called time complexity?
It is a rough measure for the estimated time needed to perform the algorithm. Quicksort (and 2-Pivot-Quicksort) need O(n ln n) which means that for an unsorted list of lenght n (n=300) you need some multiple of n*ln(n) steps (300*ln300~1711) to complete the sort.
The factor is not specified and implicitly contained in the notation O() (google for Big-Oh!)
",0,29937003
29934685,"
Ok Buddy, from this reference: http://www.cplusplus.com/reference/algorithm/sort/
you can see that the comp parameter does the following:

Binary function that accepts two elements in the range as arguments,
  and returns a value convertible to bool. The value returned indicates
  whether the element passed as first argument is considered to go
  before the second in the specific strict weak ordering it defines. The
  function shall not modify any of its arguments. This can either be a
  function pointer or a function object.

So all you have to do is 
",0,29934483
29934614,"
you can, you need to make up your mind as to how you are going to compare the strings. I suggest you use alphabetical order of words from left to right. you can't implement logic if you don't know what logic you want to implement :). 
",0,29934483
29934651,"
You can do following,
It will return a integer value and based on that you can decide. More info here
",0,29934483
29934665,"
Just compare it if you are using C++ string 
C++ String Relational Operators


bool compareBySchoolName(Student s1, Student s2) { 
  return s1.schoolName < s2.schoolName || (s1.schoolName == s2.schoolName && s1.ID < s2.ID);
}



",0,29934483
29934668,"
different language have different comparator function.When you use comparator function, it will be get return int value. So You use < or > in return satement and get true or false.
In C++, You can do this like:
",0,29934483
29909742,"
Linked lists can be sorted in O(n log n) using Mergesort.
Interestingly, since linked lists already have the appropriate structure, sorting a linked list with Mergesort only requires O(1) extra space.
The fact that this requires a specialized algorithm specifically tuned for the list structure is also the reason sort is a member function of the list, rather than a separate function.

As for how it works - all you need is the merge operation. The merge operation takes two lists. You look at the heads of both lists, and remove the smallest head and append it to your result list. You keep doing this until all heads have been merged into the big list - done.
Here's a sample merge operation in C++:
",19,29909701
29909916,"
Example code of a bottom up merge sort using an array of pointers to lists where array[i] points to a list of size 2^i (except last pointer points to a list of unlimited size). This is how the HP / Microsoft standard template library implements std::list::sort. 
Another but slower way to merge sort a list is similar to a 4 tape sort (all sequential access). The initial list is split into two lists. Each list is considered to be a stream of runs, where the initial run size is 1. In this example, counters are used to keep track of run boundaries so it's a bit more complicated and slower than the array of pointers method. Runs from two input lists are merged, alternating between two output lists. After each merge pass, the run size is doubled, the direction of the merge is changed so what were output lists become input lists and vice versa. The sort is done when all runs end up on just one of the output lists. If stability is not required, then run boundaries could be defined as any node followed by an out of order node, and this would take advantage of natural ordering with the original list.
",4,29909701
29909727,"
Mergesort is O(nlogn) for linked lists. I don't know what the default sort function is for C++, but I suspect its mergesort.
",2,29909701
29911615,"
I don't have the standard here, but CPPReference states that the complexity of sort is Nlog(N) comparisons. This means that even quick sort would be a standard conforming implementation as it would be Nlog(N) comparisons (but not Nlog(N) time).
",2,29909701
29918055,"
You start with an unsorted list of unknown length. Say the elements are numbered 0, 1, 2, 3...
In the first pass, you created two linked lists, each consisting of pairs of numbers in sorted order. List 0 starts with elements 0 and 1 in sorted order. List 1 starts with elements 2 and 3 in sorted order. Elements 4 and 5 are added to List 0 in sorted order, 6 and 7 are added to List 1 and so on. Obviously care must be taken not to overshoot the end of the original list. 
In the second pass, you merge these two lists to created two linked lists, each consisting of sets of 4 numbers in sorted order. Each time you combine two elements from List 0 and two elements from List 1. The next smallest element is obviously every time the one at the front of the list. 
In the second pass, you merge these lists into two linked lists, each consisting of sets of 8 sorted numbers, then 16, then 32 and so on, until the resulting list would contain n or more numbers. If n = 2^k then there are k = log2 (n) passes, so this takes O (n log n). 
",0,29909701
29909666,"
First load all the file in memory, then use std::sort
You can do something like this:
",-2,29909599
29909609,"
As jxh says, your transform line fails because you are making iterators to separate string objects. Why not try making the transform a separate routine?
If you want to be fancy you can define it inside the sort routine as a lambda function. Or you can just make it a separate routine defined separately.
Then when you do your comparison, do something like
",1,29909219
29909274,"
This line of code attempts to convert the string for the VIN into lowercase text, but fails:
Each call to getVIN() results in a separate string instance. Since the iterators are not from the same string instance, the failure is the result.
You don't show how you populate your carList, but one possible way to fix this is to save the VIN in lowercase at the time you save the VIN in the carList.
",4,29909219
29907237,"
You can do std::sort(carList.begin(),carList.end(),vehicleCompare) where vehicleCompare is a comparison function that you define. See sort documentation. Then, to uppercase you can use std::toupper, as shown in this guide.
So the comparison operator(*) will be:
Useful reading about string comparison operator. 
By the way, your string getVIN() method should be const, that is you should change its declaration to string getVIN() const.
If you want to keep your sorting function, the point is that in any case you'll have to define a proper comparison operator, as the one shown here.

To specifically answer to your second question, temp could be auto in C++11, or simply std::string. Then the way you are trying to assign your VIN value is wrong. Given the interface you have given, it should be:
Although it still might get nasty when you start to have more than one member variable to copy: you should instead build a copy constructor and change your code to:
The copy constructor will be:
And, at that point, you'll also want a constructor from string, and an empty constructor.

(*) Note that this comparison method wouldn't be the most efficient, as it makes uppercase the whole string while the first few characters are normally sufficient to decide their order. So a more efficient way would be to uppercase one character at the time and compare it before deciding if to uppercase another character.
",2,29907135
29907244,"
Answer to question 1: You can make a simple function that converts a std::string to upper.  
",1,29907135
29907648,"
First, your Vehicle::getVIN() method should be marked as const, to implement proper const-correctness:
Then, note that you don't need to reinvent the wheel and reimplement a sorting algorithm from scratch in production code in C++ (unless this is a learning exercise/homework about writing sorting code).
You can simply use the standard std::sort() algorithm implemented in the STL, and customize the comparison criteria using a convenient C++11 lambda, e.g.:
Your code in the lambda could be something like this: 
Instead of calling stricmp(), you can use boost::to_upper(), or some other method among the ones showed e.g. in this thread on StackOverflow:

Case insensitive string comparison in C++

",1,29907135
30260912,"
I got the answer.The correct solution is posted below.
",0,29898223
29886800,"
std::sort also uses some comparison sort algorithm. And different algorithms have different usages. Best example: Bead sort. This algorithm has a pretty good runtime complexity. But it can only be used for unsigned integers. Every algorithm has its own flaws and strengthes.
",4,29886650
29896300,"
No doubt quick sort sort()and merge sort stable_sort() are the fastest but there are factors such as whether given order of the elements in container is random,nearly sorted, reversed or it contains duplicate values.
Combine these factors with one more factor that is number of elements to be sorted gives you the idea why we might need different sorting algos. 
Sorting algos are invented one after the other and every newly discovered sorting algo was required to be faster than previous one to get accepted. 
To get the mist clear on algos' runtime you can refer to:
http://www.sorting-algorithms.com/

I hope that helped. Comment for further clarification. 
",1,29886650
29889305,"
The built in algorithm library isn't enough to sort data. It needs a backbone, which is the algorithm(Merge/Bubble/Heap) and code. 
",-1,29886650
29880494,"
Your original template function contains two types:
You're trying to specialize it with only one type. Hence the error. I don't exactly understand how you're using Sel here. I'm assuming you really meant to pass that in as an argument:
In which case, the simpler thing to do is to just provide an overload for SuchString:
The overload will be preferred to the template.
If what you need is really a static method on Sel, then you'll need to simply switch the ordering of the template types:
That way, stringSort<SomeSel>(foo) will call the SuchString& overload if foo is an lvalue of type SuchString, and the T& version otherwise. 
",2,29880438
29878322,"
std::stable_sort is the answer
If you have your own comparison function vecIdSort do this
",3,29878302
29881342,"
I used a lambda function and it worked.
",-2,29878302
29873711,"
I am not sure what you mean by red squiggly line, but my guess is, your IDE highlights a certain part of your code indicating that it may not be correct. Based on your question, my best guess is, your erroneous line is
and possibly because a1 is not a container. This reasoning is seconding on your reference to the terminology C-Style array. 
C-style array is a non standard-library implementation of a homogeneous collection of elements which are contiguous in memory.
Such arrays are not objects in the pure terminology of Object Oriented, and do not have methods (member functions in C++) and properties ( data members in C++).
Naturally, you may not be able to perform method call to fetch the start and end iterators, indicating the begin and end of the array.
Fortunately there are couple of way outs

If You are using C++11 and beyond, you can leverage the free standing functions std::begin and std::end instead of invoking member functions

If the size of the array is know, you can add to the array to get the end of the array. 
or even better


",2,29873668
29859878,"
First off:

make sure to include all necessary header files, e.g. stdlib.h for your used rand() function.
get rid of all unused variables, like average, median and size.
declare your bubbleSort function outside of main function, and add additional checkup code to prevent sort if list has not more than one element.

The sort problem is related to this code snippet of yours:

Simply remove -1

To fix your sort problem, and for better output, use following code:
Hope this helps ;)
",0,29859334
29859500,"
",0,29859334
29859355,"

If you are planning to define function void bubbleSort(vector & data) later you need to declare it before calling it.\
void bubbleSort(vector<int> & data);
  int main()
  {
            // Here your code
             bubbleSort(data);
            //Here your code 
  }
You need to define variables only just before you need it. And if you declare and  never use it, you will get unused variable warnings. So better you can comment all these variables. You can un-comment whenever you need.
//double average=0.0;
//int median = 0;
You should call your function bubbleSort() from  main() as follows:

You are not using the iterator indexes properly to sort the elements of vector. If you change your function bubbleSort as follows it will work

//Sorting
void bubbleSort(vector<int> & data)
{
             int size = data.size();
            for (int k = 1; k < size; k++)
            {
                for (int i = 0; i<size -1 ; i++)
                {
                    if (data[i] > data[k])
                    {
                        int temp = data[i];
                        data[i] = data[k];
                        data[k] = temp;
                    }
                    //cout<<""Sorted vector: ""<< data[i]<<endl;
                } 
            }
} 
complete program for your reference:
",0,29859334
29857019,"
You are seeing strange behavior due to the following problems:

You haven't initialized the array arrayList.
You are sorting the entire array instead of sorting only up to the number of entries the user entered.
You are using the entire array to search.

By changing
to
and
to
you will be able solve your problems.
You can use initialize the array using:
That won't change how your program works once you fix the use of sortArray and binarySearch.
",1,29856546
29855778,"
Why not iterate through the map itself? That will guarantee you retrieve it in the same order as the map itself because it is the order of the map itself:
Ideone example.
",4,29855526
29855840,"
A std::map sorts its entries by key, using std::less (or a custom comparator if you specify one as a template parameter).  If you want to put the entries in a std::vector into the same order that they'd be in a map, just use std::sort on it.
",0,29855526
29856029,"
I'm not sure about what you wanted to do but here is my advice:
First of all it would be better to write your own small class (or struct if you want) as the container of the variables, something like this:
And then you should write a container with the desired helper functions.
",0,29855526
29835857,"
First sort by ID number using std::sort and then sort by grade using std::stable_sort. This way the array will be sorted by grade and among students with the same grade it will be sorted by ID.
Another maybe simpler way (but much less cool) is to just implement a comparison function that first checks grade and then ID:
",3,29835839
29830362,"
ricis comment works fine as a solution. There is an alternate approach one might take that can be generalized to the std::sort and other algorithms, and that is to make a counting comparer. 
Something along the lines of
Now you need to change the signature of your function to add the comparer as a last argument. Like 
And the same change to the partition function. The comparisons are then made by
Calling the sort
You need to make sure you have a reference to your comparer in the template argument. 
Makes sure comp is not copied.
After the sort you find the number of comparisons in comp.count.
regarding your comment on counts
Your quicksort's  behaviour is extensively discussed on the wikipedia page. It is expected that a sorted array behaves badly, while random elements behaves well.
Regarding the cleverness in the partition function

The first for statement isn't really counting anything so thats just a while(true) in disguise. It will end by a break statement.
Find the first large element to swap: The while (a[++i] < v); statement takes advantage of the fact that the pivot `v or a[r]' element is the rightmost element. So the pivot element acts like a guard here. 
Find the first small element to swap: The while (v < a[--j]) if (j == l) break;  does not have the guarantee of the pivot. Instead it checks for the leftmost limit. 
The final check is just to see if the partition is done. If so break out of the infinite loop and finally
swap(a[i], a[r]);, arrange the pivot element to its correct position.

",0,29829963
29829033,"
This should be enough:
As mentioned in the comments, swapping is not a comparison. Also, you only increased counter when a[i]<=pivot was true, but even if it's false you still made a comparison.
On a side-note, however, the number of swaps obviously does affect performance, and is something that is also often considered when comparing sorting algorithms.
",1,29828174
29814487,"
I think you access the array of songs which has no element inside (empty string).
May I ask what is the purpose of this line?
if you are trying to find the total number of songs, then replace that line with this line:
I tried with your code and it works. Your program successfully sorts the songs name as you described.
Your program crashes when it substr(4) an empty string because not all the string in the songs array  is filled. Some of your albums only contain 11 songs.
",0,29814231
29812824,"
You are getting the unexpected output since you are changing only the length field while sorting.
What you should do is swap the entire object. Use
",2,29812448
29808423,"
Your main problem here is that you are trying to use an assignment operator on two fixed sized arrays, which isn't legal.  Consider the following code:
This gives the same error you are getting.  On the lines you mentioned, you are doing the same thing with char[15] arrays.
To fix your problems, you either need to allocate your char array dynamically/work with the pointers, or a simpler solution would be to just change your char[][] array to a string[] array.
That being said, there are a lot of things you can clean up here:

You have a few variables declared globally that can just be defined in main or lower
You can declare loop counters inside the for loop instead of beforehand, as you do in the sortNames function
In sortNames you are declaring a few variables twice

",3,29807737
29808562,"
I'll add a few things to dwcanilla's answer.
You will want to change your function prototypes and headers to something more like this:
What this means is that the function accepts a reference to an array of c-strings; that is, when you work with the array within the function you are modifying the actual array you passed and not just a copy. Also I think you'd be fine just passing the integer by value for getNames.
Second, global variables are generally a bad idea. Since you can pass the array reference directly to your functions you may want to declare nameArr and your other global variables inside main instead.
Third, in getNames you won't be able to use cin to assign your c-strings directly. 
EDIT: This is a better way -- 
getting console input for Cstrings
Finally, the < operator doesn't work on c-strings the way you're using it in your sort function. Use strcmp() instead (and be sure to include the cstring header):
",0,29807737
29782364,"
What you've written isn't a classic bubble-sort algorithm.  Bubble-sort iterates through the entire array each time, swapping elements with their immediate successor, doing this over-and-over until no more swaps occur.
In the traditional implementation, there are no ""nested for-loops.""  There's one for-loop nested in a while or repeat-until structure.
The algorithm is called ""bubble"" because the lowest value ""bubbles up"" to the top ... with roughly the speed of a bubble trapped in very viscous oil.
(Compare with, say, the Shell sort, which is a slight-seeming alteration to Bubble that makes a tremendous difference.  And to the quintessential and definitive Quicksort.)
",1,29781750
29781839,"
Mathias pointed me in the correct direction. I had forgotten to initialize the variable 'val'. When I corrected that, it works perfectly.
As for everybody saying that this is not a classic bubble sort, I have seen this exact form on multiple sites and on slides from my prof., what is wrong with this way of writing it?
I'm trying this now instead, and it's completely failing on me (sigh):
",1,29781750
29762415,"
You may want to use some mix of std::sort() (which uses quicksort algorithm) and mergesort and apply multithreading here. 
For example, having some amount of cores in CPU, it might be reasoble to split the data, sort each part by std::sort on the cores simultaneously, and then merge them just as a mergesort merges sorted arrays.
Regards
",1,29761307
29739176,"
Try this:
DEMO
",2,29738758
29738835,"
Your comparison function is not correct, as it doesn't implement strict weak ordering as required by sorting. It should be written as:
which basically says, if x.isFirstSearch and y.isFirstSearch are not equal, then return x.isFirstSearch because if x.isFirstSearch is true (which means the other is false). then x must come before y, Or if x.isFirstSearch is false (which means other is true), x must come after y. The same reasoning for else block as well.
Read more about strict weak ordering:
What is meaning of strict weak ordering in layman's term?
Note that std::tuple implements strict weak ordering, so you could just write this:
That does the same work.
Hope that helps.
",2,29738758
29739414,"
It's arguably a little cryptic - as it utilises implicit conversions from bool to 0 or 1 - but just for the fun of listing another alternative:
This is basically giving weightings to the fields, and summing those to get a weighting for the object: they're negative to get true values earlier in the ordering, and isPopular has double the ""weight"" of isFirstSearch so it is the ""primary"" sort field.  This happens to avoid branching too, so may perform differently (likely better) than if / else or ? / :-using alternatives, though that's not likely to matter often.
",1,29738758
29732077,"
To sort you can use std::sort() and to find the minimum std::min_element().
In both cases you will have either to implement the operator< or to create a comparison function.
Example of operator<
Usage of std::min_element():
Usage of std::sort():
You will have to include: #include <algorithm>
",7,29731906
29732145,"
http://en.cppreference.com/w/cpp/algorithm/sort
The standard way to sort anything is to use std::sort() with an comparison function passed to it.
If comparing between objects is something you'll be doing often, it might be a good idea to implement the operator< in your class. That way, you don't need a comparison function.
",1,29731906
29732106,"

""Is there a standard method of sorting or filtering an array of objects based on their data members or member functions?""

There's a number of functions available from the c++ standard Algorithm library. Namely

std::min_element
std::sort
std::remove_if
std::find_if

to realize the functionality you mentioned (Examples of usage are given in the reference pages).
You'll have to provide appropriate comparator functions/classes that operate on your structure members. These can even be lambda functions, if you want to write them on the fly.
",0,29731906
29712351,"
You're actually swapping the elements back and forth. You need to make sure that when you're Bubble Sorting you're only comparing an element with a later element. That is:
Note that we can take advantage of standard utilities to make this code a lot easier to understand. The line I wrote as //same as before... what you're doing there is just swapping names[i] and names[j], which we can spell:
That's just easier to understand and less error-prone. 
",2,29712274
29712979,"
You got the bubble sort wrong. try this :
",0,29712274
29689189,"

Among simple average-case Θ(n2) algorithms, selection sort almost always outperforms bubble sort.

Source: Wikipedia
",1,29689108
29689512,"
I hinted at this already in comments, but here's some updated code for you that counts both comparisons and exchanges/swaps, and illustrates that for some random input the number of exchanges/swaps is where selection sort outperforms bubble sort.
Output:
You can observe / copy / fork-and-edit / run the code online here.
",0,29689108
29688698,"
You can use this link to try different combinations:
http://www.sorting-algorithms.com/
You will see that:
1.) Arbitrary unsorted array: Insertion Sort, Merge
2.) Reverse sorted array: Insertion/Merge, Bubble not far behind
3.) Already sorted array: All are equal
",1,29688667
29676310,"
If you have a vector of your class object
And the variable to sort by is
Then you can
",4,29676147
29676323,"
You just need to either implement an operator< for the class, or provide a comparison function for the std::sort:
If you are using c++11, you can also provide a lambda as a comparison function:
",2,29676147
29651579,"
This does not do what you think it does. It will always compare left[0] with right[0], because you declare i and j inside the for loop, so they will be reset to 0 on each iteration.
To make them retain their values, declare them outside the loop:
",4,29651363
29652547,"
If your intent is to use variables i and j in the loop only then try to restrict the scope of i and j to the loop by doing following.
",0,29651363
29634066,"
Change
to
and then use it as follows
You could also make use of templates so your code is more generic
",1,29633807
29663282,"
You're going about this fairly wrong.
Let's assume that we know the maximum value for each member of the pair. If you don't know this, then you need to figure it out. I'm going to assume that it is 100.
Then all we need to do is iterate over the set, and insert them into the new array. There's no faster way to go about this.
",0,29631040
29663333,"
First, prefer std::sort to qsort with c++ std containers.
Secondly, you cannot sort a std::set a posteriori. std::set is sorted.
You can however specify a custom sorting for the std::set at instanciation using a 2nd template parameter.
Refer to the specs.
What you could do, if you need to sort the data after the fact, is use a std::vector instead. There is an algorithm that will cull the duplicate value.
This proposed solution assumes M is some global variable.
If M isn't a global variable, you could do something like that :
then in main :
EDIT :
If you must use a std::set then you should define the custom ordering when you declare it, like so :
Be careful though : in a set you cannot add 2 items that compare equal. So if your int ** 2D array has several values that are equal, you won't be able to have several pairs corresponding to indexes of equal value in the set.
",0,29631040
29631061,"
It is because your operator< depends a lot of the data order. If we run you're algorithm with your data, it's the expected output.
The first comparaison is between Data(1,1,2) and Data(2,3,4). According to your operator<, Data(2,3,4) is the lower so the temp order is [Data(2,3,4), Data(1,1,2)]
Then, Data(3,1,2) comes and is compared against the lowest value of the current sorted list, so Data(2,3,4). Again, according to your operator<, Data(3,1,2) is lower so no need to compare against the other values in the list and the new temp ordered list is [Data(3,1,2),Data(2,3,4), Data(1,1,2)].
Then it's the same for each other value, they are each time only compared to the first value in the list since they are lower (according to operator<) and so put in front of the sorted list.
If you change your init list order with:
you'll have the expected output since there will be more comparaison involved.
But the fact that the result depend on the init order show there is clearly a flaw in your operator< function.
",1,29628737
29627311,"
You can think of this as a bin packing problem.  This problem is an NP-complete and as such there is no known efficient way to locate a solution in the first place.  One way you can solve this is to start off with the biggest piece in the top left corner (0,0).  Then with the 2 remaining pieces do the same thing.  There is nice example of this process at Code inComplete.  It deals with packing CSS sprites but should be easily modified for this solution in C++.
",2,29626520
29618705,"
I added .c_str() function and it worked. I changed:
to
",0,29618627
29618225,"
There are (at least) two bugs. This:
should be this:
and this:
should be this:
In general, you ought to learn to step through the code, at least by putting diagnostic output statements here and there. Once you have the hang of that you can move up to a good debugger.
",1,29616881
29618020,"
Suggestion 1: 
Instead of that line:
If you need a dynamic size array use:
Then once you are done with it 
Edit: As Neil suggested using std::vector is may be more useful than arrays in such situations (if you are allowed to use it).
",0,29616881
49125776,"
Your code has 3 bugs, Also you can reduce your code length too if required.
Live Code
",0,29616881
49127796,"
The standard library already implements a function that merges correctly: std::inplace_merge. Implementation adapted from this more general post
",0,29616881
29606946,"
Your fun function does not provide strict weak ordering. If i and  j are equal, it will return true. So you are not following the rules. Your implementation of the standard library responds by throwing an exception.
",4,29606847
29606896,"

How can I modify this function to make the program run normally?

Assuming you want to sort in ascending order. Just use operator <.
Alternatively you could just use the comparator provided by the standard.

See the link in the comments or the answer provided by @DanielDaranas to understand why your original function doesn't work.
",2,29606847
29597800,"
Just move the cout before the for loop
And call the sort function outside the loop
",1,29597787
29599043,"
I don't believe your sort functors are correct.
A sort functor must give a consistent ordering.  Let's just consider this one:
Suppose I have two UV quantites like this:
This functor will return true no matter which order I present UV1 and UV2.  Your other functors are similarly defective. 
In thrust speak, these are not valid StrictWeakOrdering functors.  If we wish to order UV1 and UV2, we must provide a functor which (consistently) returns true for one presentation order and false for the other presentation order. (The only exception to this is if the two presented quantities are truly equal, then the functor should always return just one answer, either true or false, consistently, regardless of presentation order.  However the UV1 and UV2 presented here are not ""equal"" for the purposes of your desired ordering, i.e. grouping of identical structs.)
The following simple test seems to work for me:
In case it's not clear, there is nothing particularly specific to the usage of thrust and functors here; the fundamental logic used to order these items needs to be correct for a valid sort.  Even if you wrote a simple serial bubble-sort, it would have to use similar logic.  The logic presented in your functors cannot be used to provide a sensible ordering.
If there are other problems with your approach, I can't say, as you have not provided a proper MCVE, which is expected for questions like this.
",2,29597224
29588505,"
When you are using std::vector like an array, you are misusing them. There is no point in passing the size ""on a side"" of the vector, because vectors keep their own size.
You should pass your vector by reference, use its size() member function instead of a count(), and use push_back() to add values to it. The signatures of your functions should be as follows:
Use v.push_back(next) instead of v[index]=next inside fill_array implementation.
",0,29588430
29588524,"
In your fill_array function, you aren't adding the values that have been input to the vector v correctly. You should change v[index] = next to v.push_back(next).
",0,29588430
29589626,"
You can either change 
by
Or you can keep it like v[index]=next; and allocate the memory when you declare your vector.
When you go the push_back way and you know the number of element your vector will eventually have, it is a good thing to call reserve before starting filling the vector. So you want to do:
reserve will set the capacity or your vector (capacity is always >= to your vector size). When capacity is == to the size, a call to push_back (or any function that insert elements) will need to reallocate the memory and then you get some performance hit. Using reserve will prevent that.
Also, there is no point in having your own swap function. The standard library has already a swap function. Instead of
You can do
",0,29588430
29585481,"
Update: implemented a solution that involves a vector of iterators into a set that has index into the vector (for uniqueness) + necessary data to compute the score, with comparator sorting by the score.
Seems to work well, maybe there is a more elegant solution out there?
",0,29583513
29557531,"
I may be wrong but your compareFunction:
Is supposed to return 1, 0 or -1 and it return true or false...
",3,29556856
29557525,"
You shouldn't be using qsort in C++ without a very good reason. Try
This will compare using <, so there's no need to provide a comparator if your type overrides that operator.
If you really want to use qsort for some reason, then beware that it only works for trivially copyable types, and needs a different form of comparator, returning a negative, zero or positive value to indicate respectively less than, equal or greater than. You'd need something like
",1,29556856
29548536,"
You could just roll your own:
If KeyFunc is too expensive, you'll have to create a separate vector with the values. 
We can even hack together a class that will allow us to still use std::sort:
Or, if that's too hacky, here's my original solution, which requires us to write our own sort
Although now we have to reimplement quicksort:
Which, given a simple example:
",3,29548505
29548800,"
If the key type is not terribly huge (if it is, measure I'd say), you can just save an
instead of your ""normal"" value vector. You can then compute and safe the keys exactly once and then simply use std::sort.
Another, but intrusive method would be providing the key as a member and then caching it. This would have the advantage that you do not need to mess with the pairs every time you access your vector.
",2,29548505
29547942,"
You aren't actually overriding the sort function, so MergeSort is still an abstract class:
These sorts have different signatures, so they are different functions.
To solve this, you either need to change your MergeSort::sort method to not take in a low and high argument, or to add a low and high argument to your other sort methods.
",3,29547850
29550091,"
You can't get a virtual class MergeSort because function's sort has a different numbers of parameters 
",1,29547850
29547948,"
Sort::sort needs to be overridden. In order to override a virtual function, you need to declare a function with the same name in a derived class that has the same parameter types. If you add extra parameters, you're not overriding the virtual function in the base class anymore. So MergeSort is still an abstract class as it has not overridden the pure virtual function in Sort.
You'll have to declare MergeSort::sort like this:
and then have it delegate to another function (which should probably be private) that takes low and high as parameters.
",0,29547850
29545669,"
sizeof(int*) may not equal sizeof(int). Whether it does or not, you meant to write sizeof(int). You may be moving too much data and stomping over some random memory.
Oh and just for fun here's a suboptimal (but so little code!) insertion sort:
",3,29545636
29504422,"
I assume you have a struct like:
Now you need to make sure you can handle the case where two person have the same last name. In that case you want to look at the first name.
}
Then just call sort on your list of Student
",1,29504233
29504374,"
Use string comparison function instead of the less than sign you used here:
Also here's a similar stackoverflow question (partially) 

Is string::compare reliable to determine alphabetical order?

",0,29504233
29521825,"
When you cannot dump the contents of your tree into a vector and sort the vector on different fields, I suppose you could try the following:
step 1: find, report, and keep a copy of the smallest element based on the new sort field.  (search the entire tree)
step 2 (and subsequent): find, report, and keep copy of the smallest element that is also larger than the previous smallest element. (search entire tree)
Not terribly efficient, but I think you should be able to make this work.
Good luck.
",1,29502970
29502315,"
Yes, the pointers will still point to the same instance. But that may not be what you actually want. When you call std::sort on a vector, it does not change the location of instances (that's not even a thing you can do in C++). It swaps their values with each other. This is probably better explained with a simplified example. Take this struct:
Now, lets say I make a vector of these, with decreasing x values, and each one having a pointer to the one that comes after it (and the last having a pointer to the first):
Now, if I sort this vector, it is essentially going to reverse. But the instances themselves don't change their location. Instead, their values change such that the first one has the lowest x value, and it increases from there. Now, the pointer member changes along with the x value.
So take, for example, vec[0], which had an x value of 4, and a pointer to vec[1] (which has an x value of 3). After the sort, those values will end up in the last element, vec[4]. So vec[4] will have an x value of 4, and a pointer to vec[1] (which, after the sort, has an x value of 1).
So, before the sort, the element with the x value 4, had a pointer to the element with an x value of 3. After the sort, the element with the x value of 4 has a pointer to the element with the x value of 1. I doubt this is what you wanted.
Since you are interested in the identity of the instances, not just their values, you should probably be using something like std::vector<std::unique_ptr<dockPose>>. For my Foo example, I could do something like this:
Note that when you do this, you need to use a different comparison function. One which compares the dereferenced pointers, rather than the pointers themselves.
",3,29501801
29501836,"
std::sort will just move the objects around in the vector, but the pointers themselves will still point to the same memory location they pointed initially. 
",0,29501801
29501846,"
Sorting will not change the values of those pointers. Pointers are simply variables holding memory addresses, sorting a vector will not change any of the member variable data of the objects in the vector.
",0,29501801
29502048,"
If you have a vector of DockPose objects you are treating them as values, in which case it's a bad idea to keep pointers to them. I suspect you actually want them to be entities (two entities are distinct even if they have identical values).
In which case you should instead have a vector of pointers to the entities; sorting the vector of pointers will then not invalidate your DP pointers.
",0,29501801
29502664,"
keeping pointers to objects in a vector is not a good idea. Even a simple push_back() could make all of your pointers invalid, if you happen to cause a resize. 
If you want to keep pointers to objects in a container you would be better to use a std::list
",0,29501801
30369562,"
No. The documentation does not specify such behavior, and with a few minutes of experimentation, it was pretty easy to find a test case where the dupes weren't contiguous on ideone:
Output:
If the dupes were contiguous, that output would have been 2.
",1,30369272
30369553,"
I have just tried several not-so-simple examples, and on the third got non-contiguous output.
Program
with gcc 4.8.1 under Linux, with std=c++11, gives me output
while the n-th element is 3.
So no, the elements are not always contiguous.
I also think that even a simpler way, with no thinking of a good test case, was just generating long random arrays with many duplicate elements and checking whether it holds. I think it will break on the first or second attempt.
",1,30369272
30363338,"
I can think of two advantages:
1) Other pointers might exist, pointing to nodes in this list. If you rearrange the list, these pointers will still point to the same values they pointed to before the sorting; if you swap values, they won't. (Which one of these two is better depends on the details of your design, but there are designs in which it is better if they remain pointing to the same values.)
2) It doesn't matter much for a list of mere ints, but eventually you might be sorting a list of more complex things, so that swapping values is very expensive or even impossible.
",4,30363271
30363810,"
As answered by Beta, it's better to rearrange the nodes (via the next pointers) than it is to swap node data.
If actually using a bubble sort or any sort that ""swaps"" nodes via the pointers, swap the next (or head) pointers to the two nodes to be swapped first, then swap those two nodes next pointers. This handles both the adjacent node case where 3 pointers are rotated, and the normal case where 2 pairs of pointers are swapped.
Another simple option is to create an new empty list (node * pNew = NULL;) for the sorted list. Remove a node from the original list one at a time and insert that node into the sorted list in order, or scan the original list for the largest node, remove that node and prepend the sorted list with that node.
If the list is large and speed is important, than bottom up merge sorts are much faster.
",1,30363271
30333473,"
Use std::greater as third parameter of std::sort
FYI..when you use std::sort without third parameter, third parameter is defaulted with std::less.
",5,30333262
30333389,"
You can use reverse iterators rbegin and rend, example:
output: 6 5 4 3 2 1 
Or you may use a lambda as the third argument to sort:

If you don't have a compiler that supports C++11 or C++14, you can create your own compare function and pass it as third argument to sort:
Output: 6 5 4 3 2 1
",2,30333262
30349373,"
use 
    sort( arr[index] , arr[index] + 12, std::greater()); 
insted of 
For ascending sort;
For descending sort,
for more, refer http://www.cplusplus.com/reference/algorithm/sort/ 
",1,30333262
30333649,"
sort can only sort ascending... but you get to choose what ascending means.
If you tell sort that x, y is in ascending order if and only if x > y, then the sorted sequence will be in ascending order according to operator >, which is the same thing as descending order according to operator <.
You could write your own custom functor to do this or use a lambda, but the standard library already has a functor for this purpose:
In C++14, you should use std::greater<> instead of std::greater<int>.
",0,30333262
30298968,"
If using cin helps, then probably %llu is wrong flag for given pointer. Check documentation for your compiler and see what long long means for it and check printf/scanf doc of your library.
",0,30298590
30302965,"
There is all sorts of possible explanations.   Most likely is a compiler (or library or runtime) in which scanf() doesn't properly support the %llu format with long long unsigned types.
long long types were not formally part of C before the 1999 standard, and not part of C++ before (from memory) the 2011 standard.  A consequence is that, depending on age of your compiler, support varies from non-existent to partial (what you are seeing) to complete.
Practically, because of how C++ stream functions (operator>>() etc) are organised, it is arguably easier to change the C++ streaming to support a new type (like long long unsigned) than it is to change C I/O.   C++ streams, by design, are more modular  (operator>>() is a function overloaded for each type, so it is easier to add support for new types without breaking existing code that handles existing types).   C I/O functions (like scanf()) are specified in a way that allows more monolithic implementations - which means that, to add support of new types and format specifiers, it is necessary to change/debug/verify/validate more existing code.    That means it can reasonably take more effort - and therefore time - to change C I/O than C++ I/O.   Naturally, YMMV in this argument - depending on skill of the library developer.   But, in practice, it is a fair bet that an implementation of standard C++ streams is more modular - and therefore easier to maintain - by various measures than the C I/O functions.
Also, although you didn't ask, the construct unsigned long long int arr[n] where n is a variable is invalid C++.    You are better off using a standard container, like std::vector.
",0,30298590
30300076,"
What probably happens is that %llu is wrong for your compiler.
For example, if you compile your program with g++ in MinGW using the -Wall flag in order to get all the warnings, you get this:
So the compiler will ignore the extra l and scan the input as %lu.
If you are compiling on a 32bit system, a long integer will most probably be 32bits long, i.e. 4 bytes.
So the number scanned will occupy 4 bytes in your memory and since the arr[n] array is a long long array, i.e. each element is 64bits - 8 bytes, only the first 4 bytes of each element will be written by scanf.
Assuming you are on a little endian system, these 4 bytes will be the least significant part of the long long element. The most significant part will not be written and will probably contain garbage.
The sort algorithm though, will use the full 8 bytes of each element for the sorting and so will sort the array using the garbage in the most significant part of each element.
Since you are using code blocks on a Windows 32bit system, try replacing all occurrences of ""%llu"" with ""%I64u"".
",0,30298590
30295427,"
If your array name is arr and size is n.
Search the largest number as follows:
Finally, max is the largest number.
To add up the array:
",0,30295141
30293635,"
It looks like you're unintentionally incrementing i within the loop.  Don't use ++i, use i+1 instead.  Also change your loop termination condition to just i < Array.size() instead of i < Array.size() - 1
",1,30293504
30293224,"
You want to ""link"" them from the very beginning:
That way, the sort is easy:
Otherwise, you'd have to make an array of indices:
And sort that:
And then print according to indices:
",0,30293206
30293397,"
As far as combining the two arrays into one you can do something like this:
",0,30293206
30267573,"
If the goal is to sort indices from a given array, the following code using C++ 11, std::sort and lambdas should do the job:
C++11 example
Live Example:  http://ideone.com/EsOFKt
Note that all we did was to build an index array sorted, and compared the original double vector using the two indices passed to the lambda.  
Note that allocating memory in the beginning for the indices isn't necessary, as a std::vector<long> would be the usual way to do this.  However I tried to mimic your original code requirements of returning a pointer to dynamically allocated memory.

C++ 0x, 98 example
If you are using a pre-C++ 11 compiler, you can change the code to this:
Live Example: http://ideone.com/nhMwSs

C example
Since this question was also tagged as C, here is a C implementation:
Live Example: http://ideone.com/8SZH1m
",2,30266659
30250800,"
Reading from file:
Find word with same first and last letter
Note this does not handle words with capitalized letters. It would not find ""Mom"". It will likely crash over empty words. Both have trivial fixes.
Assign word to array
This assumes you want to advance the index after inserting into the array. Please note the program will behave poorly if the array is overfilled. If you are allowed to by the assignment, please consider using a std::vector.
Sorting the array
This assumes you are allowed to use std::sort. Again, if possible use a std::vector in place of the array. index is assumed to be the value of index from the adding example above after all of the adding has been done. If you are NOT allowed to use std::sort ask another question. It's a lengthy topic.
",0,30249919
30244030,"
When you are trying to sort a vector containing ShapeTwoD*s, the compare function must work with ShapeTwoD* too, not ShapeTwoD& or ShapeTwoD const&.
Change
to
Change compareDescend similarly.
",2,30243763
30224707,"
Lot of minor errors.
Public section.
In C++ public is followed by ':' to mark a section. Also you need to include the string definition. Which lives in the std:: namespace.
C++ is a very pedantic on types.
You need to specify the types of all parameters:
unknown names:
Statements are terminated by ';'
Once you have those fixed it compiles. But I would take the fixed version to code review for a more detailed break down.
When all complete main looks like this:
",7,30224338
30224751,"
Your class is not declared correctly. For instance, you cannot omit data types from the constructor's parameters.
You are also not reading the file correctly.
Try something more like this:
",4,30224338
30224608,"
Your syntax for access modifiers is incorrect (you're using Java style rather than C++). In C++ you would declare this fully public class like this:
If you really do want to make all the data public, you could also use a struct instead of a class, since the members of structs are public by default.
",3,30224338
30224661,"
First of all your variable declaration in class is wrong.Then in the constructor,you are not telling the data types.See this
Then you are missing a semicolon.
",2,30224338
30217827,"
It might be faster to use std::inplace_merge instead of std::sort. If there is additional memory available it has linear complexity otherwise it falls back to NlogN.
",6,30217383
30217523,"
To elaborate on Mat's comment your code could look like this using std::merge:
",6,30217383
30217859,"
If you need this kind of merge, why not make one yourself?
Sample usage:
Output:
Live sample: link.
",1,30217383
30238403,"
So after looking through all the standard algorithms I can confirm that, there is no alternative to insert and sort. As I was searching the standard algorithms I did note that all the copying algorithms use input iterators and output iterators the only time an input-output iterators are used is when a single range is being operated on. (For example sort uses input-output iterators but any copy uses input iterators and an output iterator.)
I'd like to give an illustration of my point. So lets make an example of what an insertion merge algorithm with an input-output iterator would look like:
Two things should be noted about this func algorithm:

It doesn't respect last1 it is assumed that sufficient space is allocated beyond last1 to also contain all the elements in the input range
func's input-output range cannot be called with a back_inserter like any other output only range in a standard algorithm

Because of this even func cannot be a ""one step algorithm"". It must be called like this:
Note that Blastfurnace's answer takes advantage of the knowledge that it is merging two sorted ranges, and as such is of equivalent speed to func:
The only actual ""one step algorithm"" is to roll this Blastfurnace's answer into a function that you could call by passing in the containers to be merged.
",0,30217383
30189265,"
Sort the array in pairs based on the indexes: for any comparison and reordering operation you do in the reference array, move the corresponding indexes in the other array as such as well.
",0,30189164
30189438,"
You could simply use a temp array and fill it in your idx's order with your data's data
",0,30189164
30189499,"
IMHO the simplest and fastest way is to use a temporary array of same size, save data to it, and then reset data with proper indexes.
",0,30189164
30189495,"
Do you mean in-place rearrangment?
",0,30189164
30201121,"
The following code is not the fastest.
Nevertheless, space complexity is O(1).
data[] is rearranged as below.
Where, { } is temp.
idx[] is rearranged to (0, 1, 2, 3, 4) at last.
",0,30189164
30187741,"
Actually, a char array is numeric:
",4,30187648
30187468,"
In order to make the std::list::sort work all you would need to do is overload the < operator of your class. 
In your case this would look something like this
You also could call the overload of sort wich takes a comp function as argument. See here.
",1,30187234
30187354,"
just advice, if the only thing you want to sort is surname, you could try to add this Nodes by the order of surname at the first place, then you don't need to sort it again, because it's made by sorting
",0,30187234
30187668,"
use std::map< string, Man >,   insert each element of your list into this map with surname as key, object of Man as value.   Elements of MAp are sorted based on key, so just iterate through the map to get the objects in the sorted order. 
",0,30187234
30187765,"

You must to create std::vector or std::deque of your items.
Use std::sort.

Example:
",0,30187234
30188454,"
To sort the list you can build a new list from the existing list by inserting elements in the order in the new list from the existing list.
Here is a simplified example. Of course you need to add some more functions as for example a function that will delete all nodes of the list.
The program output is
Instead of the function std::tie you may compare simply surnames of two nodes.
Take into acccount that it would be better to split your structure into two parts. For example
",0,30187234
30180034,"
To do the merge sort you are going to have to break up the list. For example always splitting on head and tail is pointless. It would always be splitting on the whole list, not the increasingly smaller portions of the list. So your split would have to look something like this:
I recommend changing the variable names fast and finger to something more descriptive.
Merge and mergeSort will require similar modification.
Edited the post to do things the C++ way. Sorry about that.
",0,30177795
30177976,"
STOP USING GLOBAL VARIABLES!
Remove ALL variables declarations which appear before your functions.
Rely solely on data that were passed to the functions as their parameters.
EDIT
Here is (possibly minimal) modification of your original code, which does not use extern variables (except the parameterless mergeSort(), which is supposed to be the only public method, if you implement the code in some sortableList class).
The code also doesn't use last pointer nor prev links as they are not needed in mergeSort and can be easily reconstructed after sorting (easily means here 'in O(n) time' with a single pass along the sorted list).
EDIT 2
Your merge routine seems too long and overcomplicated. See the shorter version below. Isn't it more redable?
You might also get rid of the first if, if you create a temporary node variable (but that is sometimes not allowed, say if node class is too complicated or its construction would cause some unwanted side effects):
And this is how to restore prev links once the forward-linked list is sorted:
",-1,30177795
30168632,"
You need to define an operator< for example
This will define the less-than operator to sort two Tag instances. As written in the above example, this will sort by preferring left_tag, then right_tag.
",4,30168553
30168359,"
Your partition can take a comparison functor, something like:
",2,30168157
30168346,"
Add an other argument to your function that would specify if you need a ascending or descending call, a boolean ascending can do that, and calculate the loop condition like this :
",0,30168157
30166754,"
Raw arrays are not move assignable, which is a requirement for std::sort:

Type requirements
  - The type of dereferenced RandomIt must meet the requirements of MoveAssignable and MoveConstructible. 

In order to sort, you'll just need a container whose elements are MoveAssignable. Like std::array:
",1,30164746
30159064,"
You have a logical error here and when there is no exchanged needed, you are actually exchanging with wrong information (losing the minName).
try this:
Or you have to carry the minName:
",0,30158009
30155515,"
This makes use of a GCC extension called variable length arrays. These are allocated on the stack. The stack is merely a few MiBs large, so you get an overflow.
Use vector.
",0,30155488
30155508,"
There are 2 issues with your code: 

Standard C++ does not support variable size arrays cin n; long long int a[n];
You probably run out of stack memory (10^7) elements.

Best thing to do is to use a std::vector<long long int> instead,
",2,30155488
30154169,"
Last time I used std::sort, you could pass a comparison function to std::sort.  Thus if you wanted a descending sort, you pass a descending comparison function.  If you wanted to sort by even number of pancakes, you could write a function that did that.  
The function is easy to write:  
Sorting is invoked by:
",1,30153971
30148000,"
",4,30147982
30148016,"
Creating newfile for every loop iteration overwrites the content of the file, by default.
Either open newfile before the last loop, or open it in append mode within the loop.
",2,30147982
30148010,"
It's because you are creating a new file in each iteration of your loop! 
    ofstream newfile(""newfile.txt"");
should be written before the loop.
",1,30147982
30148023,"
",1,30147982
30148033,"
Here is my complete code that worked, thanks Xiaotian Pei for your help.
",0,30147982
30147288,"
Since your list is a vector of string, pushing single chars into it wouldn't work: you should either make it a vector of chars, or read strings:
Note that list[99-i] is rather suspicious: it will work only if the list has exactly 99 elements, and only if you change i-- for i++. Otherwise, you would get undefined behavior either on accessing elements past the end of the vector, or accessing elements at negative indexes.
If you would like to print the list from the back, use list[list.size()-1-i] instead, and use i++ instead of i--, because otherwise the loop would not stop.
",6,30147264
30147454,"
Well, the error is correct. It helps, though, to read all of it!
The class vector<string> has a function push_back(const string&).
It does not have a function push_back(char).
I don't know why you're extracting individual chars but storing whole strings; don't do that.
",2,30147264
30147300,"
Because you are trying to put in char into a string vector.
Change input to string.
",0,30147264
30115668,"
The solution is pretty simple:
",2,30115620
30113510,"
I think the solution to your problem lies in the comment by @Praetorian:

You probably want myfile << random_integer << '\n';. Otherwise stoi will throw out_of_range, which is probably the cause of the crash.

I have a few generic suggestions regarding your function.

Separate your function into two 
-- one for writing to the file
-- one for reading from the file and populating a BST.
Don't use hard coded names of files or global variables in the functions. Make them arguments to the function.
Always check for the status of IO operations. Deal with failures.
Seed the random number generator in main or a driver function. If you call the function that generates random numbers multiple times, you won't need to seed the random generator again.

Withe functions divided into two, you can test one function at a time. If there is a problem in one function, you can debug the problem and fix it before working on the other function.
",4,30113067
30113514,"
Change
to:
On a sidenote, if you need data only during the lifetime of the program, you might want to use a buffer or even add the numbers directly into your binary search tree.
",0,30113067
30085738,"
Not sure why you're using std::partial_sort here - it's meant for sorting only part of the input. Try std::stable_sort instead: it will sort the input, but will not affect the order of elements that compare equal. This gives you what you want since your input map is already sorted by increasing alphabetical key:
Alternatively, you could alter your comparison function to compare both the value and the key, and use a plain std::sort:
",3,30085669
30067734,"
You can sort the scores by using the std sort() function by giving it an iterator to the beginning of the array as the first parameter and an iterator to the end of the array as the second parameter. More on sort.
Then, you can iterate through your sorted average scores and give a score based on a decrementing basis. For example, your highest score will be given rank 1. Go to the next score. Check if the score is the same as the previous. If it is, give the same rank, otherwise, increment your rank and then assign it. 
Your ranking function is a bit convoluted.  I suggest you separate this into three parts. Get the averages, sort, then rank. I'd use vectors to facilitate things further. I hope this helps :)
",1,30067474
30067863,"
You say that you have done everything up to the last part, assigning grades (""Any average of 90 or more is an 'A',..."").
I advise you to isolate this part of the problem. Write a function that takes a score and returns a letter. Once that's working perfectly, you can add that function to your code and fill in the grade field of each student.
The signature of the function should be something like this (until/unless you make it a member function or something):
Is that enough to work with?
",0,30067474
30067483,"
It seems to be a tag sort:

For example, the popular recursive quicksort algorithm provides quite reasonable performance with adequate RAM, but due to the recursive way that it copies portions of the array it becomes much less practical when the array does not fit in RAM, because it may cause a number of slow copy or move operations to and from disk. In that scenario, another algorithm may be preferable even if it requires more total comparisons.
One way to work around this problem, which works well when complex records (such as in a relational database) are being sorted by a relatively small key field, is to create an index into the array and then sort the index, rather than the entire array. (A sorted version of the entire array can then be produced with one pass, reading from the index, but often even that is unnecessary, as having the sorted index is adequate.) Because the index is much smaller than the entire array, it may fit easily in memory where the entire array would not, effectively eliminating the disk-swapping problem. This procedure is sometimes called ""tag sort"".

As described above, tag sort can be used to sort a large array of data that cannot fit into memory. However even when it can fit in memory, it still requires less memory read-write operations for arrays of large objects, as illustrated by your solution, because entire objects are not being copied each time.
Implementation detail: while your implementation sorts just the indices, and refers back to the original array of objects via the index when doing comparisons, another way of implementing it is to store index/sort key pairs in the sort buffer, using the sort keys for comparisons. This means that you can do the sort without having the entire array of objects in memory at once.
One example of a tag sort is the LINQ to Objects sorting algorithm in .NET:

The sort is somewhat flexible in that it lets you supply a comparison delegate. It does not, however, let you supply a swap delegate. That’s okay in many cases. However, if you’re sorting large structures (value types), or if you want to do an indirect sort (often referred to as a tag sort), a swap delegate is a very useful thing to have. The LINQ to Objects sorting algorithm, for example uses a tag sort internally. You can verify that by examining the source, which is available in the .NET Reference Source. Letting you pass a swap delegate would make the thing much more flexible.

",5,30067359
30067571,"
I wouldn't exactly call that an algorithm so much as an indirection.
The reason you're doing fewer swaps of the larger objects is because you have the sorted indices (the final result, implying no redundant intermediary swaps). If you counted the number of index swaps in addition to object swaps, then you'd get more swaps total with your index sorting.
Nevertheless, you're not necessarily bound by algorithmic complexity all the time. Spending the expensive sorting time swapping cheap little indices around saves more time than it costs.
So you have a higher number of total swaps with the index sort, but the bulk of them are cheaper and you're doing far fewer of the expensive swaps of the original object.
The reason it's faster is because your original objects are larger than indices but perhaps inappropriate for a move constructor (not necessarily storing dynamically-allocated data).
At this level, the cost of the swap is going to be bound more by the structure size of the elements you're sorting, and this will be practical efficiency rather than theoretical algorithmic complexity. And if you get into the hardware details, that's going to boil down to things like more fitting in a cache line.
With sorting, the amount of computation done over the same data set is substantial. We're doing at optimal O(NLogN) compares and swaps, often more in practice. So when you use indices, you make both the swapping and comparison potentially cheaper (in your case, just the swapping since you're still using a comparator predicate to compare the original objects).
Put another way, std::sort is O(NLogN). Your index sort is O(N+NLogN). Yet you're making the bigger NLogN work much cheaper using indices and an indirection.
In your updated test case, you're using a very pathological case of enormous objects. So your index sorting is going to pay off big time there. More commonly, you don't have objects of type T where sizeof(T) spans 100 kilobytes. Typically if an object stores data of such size, it's going to store a pointer to it elsewhere and a move constructor to simply shallow copy the pointers (making it about as cheap to swap as an int). So most of the time you won't necessarily get such a big pay off sorting things indirectly this way, but if you do have enormous objects like that, this kind of index or pointer sort will be a great optimization.
Edit: This requires more testing for sure. But it makes me think, what if std::sort could, at compile time, check the object size, and (depending on some size threshold) choose either the existing quicksort implemenation or this IndexSort implementation.
I think that's not a bad idea. At least making it available might be a nice start. Yet I would suggest against the automatic approach. The reason I think it might be better to leave that to the side as a potential optimization the developer can opt into when appropriate is because there are sometimes cases where memory is more valuable than processing. The indices are going to seem trivial if you create like 1 kilobyte objects, but there are a lot of iffy scenarios, borderline cases, where you might be dealing with something more like 32-64 bytes (ex: a list of 32-byte, 4-component double-precision mathematical vectors). In those borderline cases, this index sort method may still be faster, but the extra temporary memory usage of 2 extra indices per element may actually become a factor (and may occasional cause a slowdown at runtime depending on the physical state of the environment). Consider that attempt to specialize cases with vector<bool> -- it often creates more harm than good. At the time it seemed like a great idea to treat vector<bool> as a bitset, now it often gets in the way. So I'd suggest leaving it to the side and letting people opt into it, but having it available might be a welcome addition.
",4,30067359
30058455,"
Your Big O is almost certainly n^2.  Time should be on the Y axis, as it is a function of n operations. 

As you can see in the graph, there is a well defined, almost perfect fit to n^2.
",5,30058241
30058333,"
It tells that complexity is almost definitely O(N^2) (because it works too long). According to this you can make some suggestions about the sorting algorithm itself - for example this could be the bubble sort.
",1,30058241
30055432,"
Since your inner class has only one field and it has a getter (you might want to make this getter const const float& getScore() const ) you can simply change Out::in declaration to public and get rid of the problem. But if it is an extract and there are more logic after Out::in that you want to hide from public access then you can define your comparator as a friend function like this:
",1,30055097
30053633,"
std::list::sort has an overload that takes a custom comparator, as does std::sort for more suitable containers. So you can use that for sorting:
I'm not sure exactly what you mean by ""combine char arrays"", but you can iterate over the sorted list with std::for_each, std::transform, or a simple for loop in order to do something with each object in turn.
",1,30053503
30053729,"
You can provide your own comparator to the sort function or implement operator< for your object class. You can find more information here. Be aware to use std::list::sort rather then std::sort.
",0,30053503
30042106,"
You probably want to call
",2,30042069
30042193,"
// insertionSort(&a[i], SIZE); Here you haven't declared i in funciton main(), only in your for loop. And the call to insertionSort is outside of your loop.
Passing (&a)[0] and a mean the same thing.
",2,30042069
30038801,"
I don't understand your ordering needs but at the very least you should be using std::swap() instead of all your manual swaps, like:
It will make your code much shorter, easier to read, and more importantly fix any mistakes in your manual swaps. It is far too easy to get an index wrong and far to hard to spot it.
",1,30036724
30030166,"
The loop:
calculates the initial value of h. This value must be smaller than the range it will be used in:
Everytime this condition passes, h gets updated to 3 * h + 1, which means that even though h is smaller than (r-l), the updated value might be larger. To prevent this, we could check if the next value of h would surpass the largest index:
This will make sure h is smaller than range of the array.
For example: say we have an array of size 42, which means indices go from 0 to 41. Using the condition as described above:
This means our initial h is 40, because h is only marginally smaller than the range of the array, very little work will be done, the algorithm will only check the following:

Does array[40] needs to be swapped with array[0] ?
Does array[41] needs to be swapped with array[1] ?

This is a bit useless, the first iteration only performs two checks. A smaller initial value of h means more work will get done in the first iteration.
Using: 
ensures the initial value of h to be sufficiently small to allow the first iteration to do useful work. As an extra advantage, it also looks cleaner than the previous condition.
You could replace 9 by any value greater than 3. Why greater than 3? To ensure (h * 3) + 1 <= (r - l) is still true!
But do remember to not make the initial h too small: Shell Sort is based on Insertion Sort, which only performs well on small or nearly sorted arrays. Personally, I would not exceed h <= (r - l) / 15. 
",1,30029787
30021730,"
Just follow the steps exactly as written:
",0,30021646
30004124,"
Your function should look more like:
That would be a array of pointers to string, which you can strcmp like you done in
which is als so buggy at the mark.
use
at the moment you try to compare single characters.
",0,30004078
30004095,"
strcmp() expects it's arguments to be of const char *, but in your code, En[i] and En[i+1] are of type char.

if you want to comapre chars, use == operator.
if you want to compare strings, pass the address using &En[i] and &En[i+1]

That said, 
is wrong. Please verify your logic.
",0,30004078
30004103,"
Use En[i] !=  En[i + 1] to compare characters. strcmp takes char * arguments but En[i] and En[i + 1] are char.
",0,30004078
30004109,"
strcmp() requires strings as arguments for comparison, not chars. So, instead of this line:
You can directly compare the two chars as if(En[i]==En[i+1]) or if(En[i]!=En[i+1]) as per your requirements.
",0,30004078
30004110,"
Array of words is supposed to be a two dimensional array of characters: char **En. The comparison should work then.
",0,30004078
30003045,"
The input lParam1 and lParam2 are not the string of the sub-item but as the documentation says they are the data associated with the item:

The lParam1 parameter is the 32-bit value associated with the first
  item being compared; and the lParam2 parameter is the value associated
  with the second item. These are the values that were specified in the
  lParam member of the items' LVITEM structure when they were inserted
  into the list.

You can find a complete ListView sorting example here but the basics of it are as follows:
",2,30002458
30002179,"
Just plain comp is not the function you intend to give to sort.  Member functions should be qualified with the class name:  evalengine::comp.
Hope you thought about making comp a static function - otherwise you'll need to do that, too.
Actually, you may not need this comp, since the standard library contains just this function: std::less.  A more C++ish way to sort the vector would be:
It's a very good idea to learn what's available in the standard library!
",1,30002124
29998395,"

http://www.cplusplus.com/reference/ctime/time/
function  time
Get current time Get the current calendar time as a value of type
  time_t.
The function returns this value, and if the argument is not a null
  pointer, it also sets this value to the object pointed by timer.
The value returned generally(NOT always, by user3528438) represents the number of seconds since
  00:00 hours, Jan 1, 1970 UTC (i.e., the current unix timestamp).
  Although libraries may use a different representation of time:
  Portable programs should not use the value returned by this function
  directly, but always rely on calls to other elements of the standard
  library to translate them to portable types (such as localtime, gmtime
  or difftime).


",0,29998322
29997921,"
Consider the following correct implementation of a selection sort and compare it to yours:
",0,29997580
29997861,"
Given an array of n elements, a selection sort performs n swaps. 

You're performing far more swaps than that.
You also have an unexpectedly early call to return.

Let's look at a proper implementation of the sort:
Which outputs:
",0,29997580
29985906,"
Works just fine:
",0,29982108
29982146,"
Your vocabulary vector contains pointers to Entrys, not Entrys themselves. Change your comparator to the following:
bool intcomp(const Entry *lhs, const Entry *rhs){
    return lhs->count < rhs->count;
}

",3,29982108
29985699,"
To sort vector content using custom criteria, you can use a C++11 lambda:
Compilable source code sample follows (live here on Ideone):
Output:


",0,29982108
29980072,"
After the second loop, count[0] should be zero, and the third loop is missing a -97. This example fixes the problem using count of size 27 instead of 26. The first loop in this example uses -96, so count[0] = 0, count[1] = # instances of 'a's, count[2] = # instances of 'b's, ... . count[26] = # instances of 'z's but it's only used in the first loop. It's not needed, but it's simpler to put a count of 'z's there rather than adding an if statement to avoid storing a count at count[26].
If the size of count[] is to be 26, the first loop needs to be modified:
or the first two loops are modified:
",0,29978088
29965020,"
For counting sort, you first count how many students exist by school (first pass on array). Then you deduce the index of first student per school. And finally you store the students in right place in target array (second pass on array)
Counting sort is not an in-place sort, so you should pass another array to the function to get sorted values back.
That way sorted countains pointers to Student sorted by school.
References : Wikipedia
",1,29963642
29957329,"
selectionSort() method has variable 'n' that is completely a random value that happens to be on the stack at that location. You haven't initialized it!
You have a nested loop, which is O(n^2). Say n is 1982734 or some such arbitrarily large number. You are simply looping over 1982734 * 1982734 times. EVENTUALLY it will complete. Why don't you print the value of 'n' inside selectionSort(). Just initialize it with the size of the vector.
As others commented this whole work is in progress.
",1,29957076
29956688,"
Here's one problem: if (playerNames[i] != ""-""){ will never execute the true branch because you're performing a pointer comparison, not a value comparison (C++ is not like Javascript or C#). You're comparing the memory address of a string in playerNames with the address of the literal string ""-"".
Also a few other points:

Don't use C-style casts in C++. Use the C++ casting operators (static_cast, dynamic_cast or reinterpret_cast instead as needed).
As you're using C++, use the STL's string types instead of C-style strings, as they have built-in comparison features.
playerNames has 30 elements but sorted has 29 elements. Why is there a difference?
sorted has function scope lifetime. Once sort returns any pointer to sorted is invalid and the data will likely be overwritten by a subsequent function call or stack allocation.
Your code doesn't actually perform any sorting, it simply iterates through the list twice resulting in, what seems to me, are meaningless comparisons.

",1,29956655
31033356,"
The quicksort algorithm looks like this:
We have a special partition that is 3-way, so let's say it returns the equal range for whatever pivot it picks and we just need to go below and above that:
Now, consider the very worst case. We have an array that looks like [0,1,2,3,4,5,6,6,6,6...] and our pivot selection algorithm is as dumb as possible: it picks the pivots in strictly increasing order. In this case, the first recursive call ((1) above) will always do nothing because there will be nothing smaller than the pivot. So we're only ever dealing with one single recursive call - of size N - 1. 
Each recursive call reduces the problem size by one, until the 7th recursive call (which will pick the 6 pivot) - that one completes the sort. This is the key step in only having 7 distinct keys - you only need at most 7 calls. Each of those 7 calls iterates the entire array... that's O(7N) == O(N). More generally, if there are only k distinct keys, you can say that the worst case is O(kN) from the same argument. 
",2,31032889
30991606,"
The only error that I see is this>current_generation_.end() instead that ->.
In addition you should consider declaring your compare fuction as accepting two const FPGA* instead that just FPGA*. This will force you to declare fitness() as const int fitness() const but it makes sense to have it const.
Mind that since you are using C++11 you can directly use a lambda:
You also have the choice to overload operator< directly:
This could be useful if it doesn't make sense to have other criteria to compare two FPGA instances since you add some semantics to the object itself.
",3,30991553
30974605,"
Here is a method you could use, hope you find it intuitive

Read the data and put it into a unsorted vector with objects (classes) that represents the real world data.
Parse the user input to decide the column and sort order
Use a simple sorting algorithm such as selection sort to add the data to a sorted vector.
iterate over the sorted vector and output the result.

",1,30974335
30978881,"

My question is, How should I approach this problem? What is the best
  data structure should I use?

You should use several data structure but if you use a vector to store the input list (and if it is quite big), you'd better to use reserve method so that you'll avoid to reallocate the vector many times.
Another interesting point is to apply repeatedly the ordering criteria in the reverse order so that you'll have the output ordered following the multiple criteria in an easy way.
If you worth about performance you should use a more complex approach.
",0,30974335
30964120,"
The error is quite clear: ctypes doesn't know how to convert a python list into a int * to be passed to your function. In fact a python integer is not a simple int and a list is not just an array.
There are limitations on what ctypes can do. Converting a generic python list to an array of ints is not something that can be done automatically.
This is explained here:

None, integers, bytes objects and (unicode) strings are the only
  native Python objects that can directly be used as parameters in these
  function calls. None is passed as a C NULL pointer, bytes objects and
  strings are passed as pointer to the memory block that contains their
  data (char * or wchar_t *). Python integers are passed as the
  platforms default C int type, their value is masked to fit into the C
  type.

If you want to pass an integer array you should read about arrays. Instead of creating a list you have to create an array of ints using the ctypes data types and pass that in instead.
Note that you must do the conversion from python. It doesn't matter what C++ code you write. The alternative way is to use the Python C/API instead of ctypes to only write C code.

A simple example would be:
",2,30963913
30960301,"
You're trying to use QComboBox's internal model as source model for proxy. This is not going to work because QComboBox owns its internal model and when you call QComboBox::setModel, previous model is deleted (despite you reset its parent). You need to create a separate source model. Conveniently, you can use one source model for both comboboxes if cities list is the same.
Using QSortFilterProxyModel for sorting is easy, but it's surprisingly hard to exclude one specific string with it. You can subclass QSortFilterProxyModel::filterAcceptsRow and implement the behavior you want. I decided to use a bit of black magic instead (see this answer).
Private class fields:
Source:
Tested in Qt 5.3.
",2,30957002
49591025,"
You were nearly there!
",1,30957002
30903260,"
As @JaredHoberock pointed out, probably the key issue is that you are trying to compile a .cpp file.  You need to rename that file to .cu and also make sure it is being compiled by nvcc.
After you fix that, you will probably run into another issue. This is not correct and will not compile:
The first parameter here is the start of the range to sort, the second parameter is the end of the range.  Your first parameter identifies the start of the range as being on the host, and the end of the range as being on the device.  That will trigger a compile error.
Change it to:
and your code compiles and runs successfully for me.
In your above example, this line is completely useless.  It is not needed to sort the data, and you are overwriting the result anyway here:
(marking CW as the key issue was pointed out by Jared Hoberock)
",4,30903109
30898589,"
You can make a map between their choice and a functor to sort by, for example
Then you can use it by asking the user to input the sort criteria key, and then you can lookup the correct lambda to sort by using std::stable_sort. For the combinations of sort criteria, e.g. ""ps"", you can loop over each sort key and std::stable_sort consecutively in reverse order.
The output would be (working demo)
To sort from highest to lowest, just switch all the < to > in the lambda functions.
",2,30898367
30898610,"
I'd use a simple parser that reads a character, applies an std::stable_sort with the character's associated comparison predicate and proceeds to the next character.
The stable_sort part is really important. This means that if you sort the items by star count first, then by parking space, the order of star count will remain.
",3,30898367
30879560,"
You have City, about which you have information, and concept State, about which you have little more than the name and the knowledge that it contains Cities.
Your City structure seems sound to me.
State can be something along the lines of
This is a ordered mapping of a string (which will be the name of each state) to a list of cities. The list of cities for a state can be accessed states[""name of state""] just like you would an array,except you get to use the state name instead of a number.
At the end of this function all of the cities have been assigned to objects. Each city object has been placed into lists organized by state.
Finding the number of states is easy: states.size().
Finding the number of cities in Vilniaus: states[""Vilniaus""].size()
Summing the population of Vilniaus:
Smallest number of people is similar:
Getting a list of states is a bit tricky because the map stores std::pair and std::pair groups the state name and the City:
",1,30877767
30879963,"
It often helps to look at what you have and what you want:
You have a list of entries, each representing a city with some associated information. This can be - as you have done - packed pretty well into a structure:
You want a list of states with some information that must be computed from your input. So you could try to put that into a structure, too:
But, there is an additional requirement: Uniqueness. You don't want more than one instance of the above structure with the same name. So in fact for each name (of a state) there is exactly one associated ""pack"" of information. This is a pretty common pattern, so there is a solution for it: std::map
You map each name of a state to its associated information:
This is the representation of ""what I want"". Next you need to convert the ""what I have"" to ""what I want"". Since your input is a list, without any dependencies between its elements, you can simply iterate over it, extracting
the information you need:
Finally, you can print your results by iterating over the map.
You may ask why I'm not storing the cities of a state for each state: In cases like this, I try to follow YAGNI. Storing them would add complexity: because it's not the representation I intend to present as solution, I would need another step to transform that intermediate representation into the final one.
Unless, of course, you actually need the list of cities in each state.
So, to sum up: Look at what you have, look what you want, including possibly rather hidden requirements (such as uniqueness in this case). Search whether there is a partial solution to your requirements (std::set provides uniqueness but no additional information, std::map provides both). Extend that to actually fit your problem.
Full example code.
",0,30877767
30869853,"
Change member string* strArray; to std::pair<std::string, int> strArray;, change allocation strArray = new std::pair<std::string, int>[v]; and make the following changes in your myFunc
In this code we couple or pair the number (vec[i]) that generated the string and sort the array. Now using std::transform, the number is copied back to the vec
From comment
If you don't understand lambda function, you can also write a function elsewhere and pass it as fourth argument in std::transform
",3,30869342
30868803,"
These are two different cases, which should have different results. I suppose that b is ""less"" then a in first case, and ""greater"" in the other case, but your code returns false for both cases. See @Jonathan's answer on how to fix this.

But also note a that your approach (considering all y's that differ by less than  offset equal) has a major flaw: it will not generate a strict total order. Assume you have offset=3 and three points A(x=0,y=0), B(x=-2,y=2) and C(x=-4,y=4). 
You will have A and B falling within offset by y coordinate so you will compare A.x and B.x and get A<B. Similarly you get B<C, but A and C do not fall within offset distance, so you get A>C, that is A<B<C<A, which should never be. (Tweak the coordinates if I get your ordering wrong). Therefore you first need to reconsider your ordering concept.

If (as you specify in the edit) you want to divide into horizontal stripes, and sort points within a stripe by x, then you should not check whether the ys differ by no more than offset, because two points can have their ys differ by less then offset, but still be located in different stripes. I would suggest to explicitly calculate the stripe number and compare them, something like
",1,30868414
30856821,"
You problem originates in this line:
You are trying to allocate ~250000 ints on the stack (on most 32 bit platforms it will take ~1MB of memory). Your thread's stack may not be able to do this.
By the way, you should not do this - creating arrays of size known at runtime should be done via heap memory allocation:
and at the end of the function:
The best solution, however, would be to use std::vector:
",2,30856660
30841474,"
Your radixSort function violates the Compare requirements, namely irreflexivity (that is, radixOrder(x, x) must return false but it returns true because the execution goes to the first if branch).
So you get a classic example of undefined behavior here. I believe that piece of code should be rewritten somehow like
Though, I would solve the problem just by sorting the input numbers as strings in reverse order.
",3,30840491
492410,"
No, you can't.  The compiler doesn't know what the pointer is pointing to.  There are tricks, like ending the array with a known out-of-band value and then counting the size up until that value, but that's not using sizeof.  
Another trick is the one mentioned by Zan, which is to stash the size somewhere.  For example, if you're dynamically allocating the array, allocate a block one int bigger than the one you need, stash the size in the first int, and return ptr+1 as the pointer to the array.  When you need the size, decrement the pointer and peek at the stashed value.  Just remember to free the whole block starting from the beginning, and not just the array.
",232,30838684
492428,"
The answer is, ""No.""
What C programmers do is store the size of the array somewhere.  It can be part of a structure, or the programmer can cheat a bit and malloc() more memory than requested in order to store a length value before the start of the array.
",73,30838684
492538,"
For dynamic arrays (malloc or C++ new) you need to store the size of the array as mentioned by others or perhaps build an array manager structure which handles add, remove, count, etc. Unfortunately C doesn't do this nearly as well as C++ since you basically have to build it for each different array type you are storing which is cumbersome if you have multiple types of arrays that you need to manage.
For static arrays, such as the one in your example, there is a common macro used to get the size, but it is not recommended as it does not check if the parameter is really a static array. The macro is used in real code though, e.g. in the Linux kernel headers although it may be slightly different than the one below:
You can google for reasons to be wary of macros like this. Be careful.
If possible, the C++ stdlib such as vector which is much safer and easier to use.
",40,30838684
10227468,"
There is a clean solution with C++ templates, without using sizeof(). The following getSize() function returns the size of any static array:
Here is an example with a foo_t structure:
Output:
",17,30838684
5655614,"
For this specific example, yes, there is, IF you use typedefs (see below). Of course, if you do it this way, you're just as well off to use SIZEOF_DAYS, since you know what the pointer is pointing to. 
If you have a (void *) pointer, as is returned by malloc()  or the like, then, no, there is no way to determine what data structure the pointer is pointing to and thus, no way to determine its size.
Output:
",5,30838684
38577201,"
There is no magic solution. C is not a reflective language. Objects don't automatically know what they are.
But you have many choices:

Obviously, add a parameter
Wrap the call in a macro and automatically add a parameter
Use a more complex object. Define a structure which contains the dynamic array and also the size of the array. Then, pass the address of the structure.

",4,30838684
15908407,"
As all the correct answers have stated, you cannot get this information from the decayed pointer value of the array alone. If the decayed pointer is the argument received by the function, then the size of the originating array has to be provided in some other way for the function to come to know that size.
Here's a suggestion different from what has been provided thus far,that will work: Pass a pointer to the array instead. This suggestion is similar to the C++ style suggestions, except that C does not support templates or references:
But, this suggestion is kind of silly for your problem, since the function is defined to know exactly the size of the array that is passed in (hence, there is little need to use sizeof at all on the array). What it does do, though, is offer some type safety. It will prohibit you from passing in an array of an unwanted size.
If the function is supposed to be able to operate on any size of array, then you will have to provide the size to the function as additional information.
",3,30838684
32951430,"
My solution to this problem is to save the length of the array into a struct Array as a meta-information about the array.
But you have to care about set the right length of the array you want to store, because the is no way to check this length, like our friends massively explained.
",2,30838684
38290946,"
Size of days[] is 20 which is no of elements * size of it's data type.
While the size of pointer is 4 no matter what it is pointing to.
Because a pointer points to other element by storing it's address. 
",2,30838684
36009878,"
No, you can't use sizeof(ptr) to find the size of array ptr is pointing to.
Though allocating extra memory(more than the size of array) will be helpful if you want  to store the length in extra space.
",1,30838684
50987176,"
You can do something like this:
",1,30838684
22320121,"
array_size is passing to the size variable:
Usage is:
",0,30838684
42734883,"

hi in strings there is a '\0' character at the end so one can get the size
of a string with functions like strlen the problem with an integer array for example is that u can't use any value as an end value so one possible solution is to address the array and use as an end value the NULL pointer
/* http://stackoverflow.com/questions/492384/how-to-find-the-sizeof-a-pointer-pointing-to-an-array */
#include <stdio.h>
/* the following function will produce the warning:
 * ‘sizeof’ on array function parameter ‘a’ will
 * return size of ‘int *’ [-Wsizeof-array-argument]
 */
void foo( int a[] )
{
    printf( ""%lu\n"", sizeof a );
}
/* so we have to implement something else one possible
 * idea is to use the NULL pointer as a control value
 * the same way '\0' is used in strings but this way
 * the pointer passed to a function should address pointers
 * so the actual implementation of an array type will
 * be a pointer to pointer
 */
typedef char * type_t; /* line 18 */
typedef type_t ** array_t;
/*
 *    -- --
 *   -**-**-
 *   -$$$$$-
 *    -999-
 *     -^-
 *      -
 */
int main( void )
{
    array_t initialize( int, ... );
    /* initialize an array with four values ""foo"", ""bar"", ""baz"", ""foobar""
     * if one wants to use integers rather than strings than in the typedef
     * declaration at line 18 the char * type should be changed with int
     * and in the format used for printing the array values 
     * at line 45 and 51 ""%s"" should be changed with ""%i""
     */
    array_t array = initialize( 4, ""foo"", ""bar"", ""baz"", ""foobar"" );

    int size( array_t );
    /* print array size */
    printf( ""size %i:\n"", size( array ));

    void aprint( char *, array_t );
    /* print array values */
    aprint( ""%s\n"", array ); /* line 45 */

    type_t getval( array_t, int );
    /* print an indexed value */
    int i = 2;
    type_t val = getval( array, i );
    printf( ""%i: %s\n"", i, val ); /* line 51 */

    void delete( array_t );
    /* free some space */
    delete( array );

    return 0;
}
/* the output of the program should be:
 * size 4:
 * foo
 * bar
 * baz
 * foobar
 * 2: baz
 */
#include <stdarg.h>
#include <stdlib.h>
array_t initialize( int n, ... )
{
    /* here we store the array values */
    type_t *v = (type_t *) malloc( sizeof( type_t ) * n );
    va_list ap;
    va_start( ap, n );
    int j;
    for ( j = 0; j < n; j++ )
        v[j] = va_arg( ap, type_t );
    va_end( ap );
    /* the actual array will hold the addresses of those
     * values plus a NULL pointer
     */
    array_t a = (array_t) malloc( sizeof( type_t *) * ( n + 1 ));
    a[n] = NULL;
    for ( j = 0; j < n; j++ )
        a[j] = v + j;
    return a;
}
int size( array_t a )
{
    int n = 0;
    while ( *a++ != NULL )
        n++;
    return n;
}
void aprint( char *fmt, array_t a )
{
    while ( *a != NULL )
        printf( fmt, **a++ );   
}
type_t getval( array_t a, int i )
{
    return *a[i];
}
void delete( array_t a )
{
    free( *a );
    free( a );
}
/* край */

",-1,30838684
30837090,"
If you look at your inserstion sort
As you already put count =1 because as for exits on exit condition of for loop. 
for same reason then it also make sense that when while loop cancels the count++ inside will not get executed but there was a comparison made. 
but you do a count+=2. why 2?
it makes sense because you added 2 as you do 2 comparisons in while loop 

i>-1
A[i] > key

but then you need to increase counter by 2 inside while loop as everytime while is correct 2 comparisons are made. 
same way you can check other algorithms also.
still for a better approach I will suggest you read some starting chapter in any book about analysis of algorithm. They usually explains about how to estimate running time of algorithm which will help you understand how to analyse better.
",0,30836966
30829332,"
use qsort version
",1,30828795
30829099,"
c-array is not assignable, and so doesn't satisfy std::sort requirements.
As suggested, in C++11, you may use std::array instead:
Live Demo
",2,30828795
30823694,"
Here you set
then you check if
It appears you are trying to implement a selection sort. A good snippet can be found here.
Furhtermore:

I don't see the need for declaring loc outside the for-loop. say for(int loc....
There is an abundance of sorting algorithms on wikipedia and you can use std::sort.
In the second line you shadow index with the same variable in the
for-loop.
I don't know how you store books, but if you would use std::vector you don't have to pass counter every time. You can just use books.size().

",0,30823023
30822609,"
Works as designed ?
Following your code in a schema, shows that it works as designed:   
Here the schema (sorry for the childish aspect ;-) ): 

So the list is in fact fine.  The problem is that ElemList certainly contains a pointer to the head of the list .  And this pointer still points to the old first and now second element.  So the list is then no longer consitent.  
How to fix it ?
One way out, would be to make move_element_left() a member function of ElemList.  In this case you could take care of the special case where e->left becomes null, in which case you need to update ElemList's pointer to the first element.  
",1,30822164
30822347,"
See Bubble-sorting doubly linked list 
I assume your Elem class does also contain data, so move the data or - if it's a simple data pointer - swap the pointers: C++ Swapping Pointers.
If that's not possible I would - from a ""Don't Repeat Yourself"" point of view - reuse those simple linked list functions you most probably already have:
",1,30822164
30822561,"
Below is the updated code. You need to change the head pointer if the left pointer points to head of double linked list.   
",0,30822164
30797373,"
I don't think you can do it with vectors like that. You need to couple ids with marks somehow, e.g using map, vector of pairs or like this:
Or you could write your own sort:
",1,30797011
39478467,"
",1,30797011
30797109,"
Two things are needed:

Since sortByMarks is a member of Example you need to tell the compiler the correct scope or the function will not be found:

Then there is a problem because sortByMarks is a normal member function, and normal member functions expects a hidden first argument, which is a pointer to the instance the member function is being called on, and that becomes the this pointer inside the function. You can solve this by making the member function static:


There is also a third problem, and that is that the std::sort function won't actually, you know, sort anything. The way you're calling it, you are telling it to sort an array of size zero.

To be honest I don't think you thought things through completely with your problem. I'm guessing what you really want are several objects, each containing a single mark, and then sort the vector of objects containing the mark.
Something like
",0,30797011
30774842,"
Just use a std::multimap, with the key type either an integer timestamp (the fastest way) or as you suggested a time string if the default string sort keeps the timestamp order (this is slower)
or
Insert with:
",3,30773596
30774883,"
An std::set keeps its element sorted according to its Comparator.
Edit : you need to provide a strictly-less-than, deterministic Comparator (forgot the mathematical term). If multiple identical timestamps are a possibility, you need to disambiguate with another property (an id, for example).
",2,30773596
30775212,"
To synchronize the sorting of the MFC control with your internal data structure, you could try a virtual list: The key is using the LVS_OWNERDATA style. The list will then not store the item data by itself but call back into your code to get the information needed to display an item. This is where you can jump into your custom sorted container and retrieve the information.
The article 'Using virtual lists' on codeproject appears to be pretty comprehensive.
Next, sorting itself. You can try a custom type that contains the text to display as well as the criterion to sort by in numeric format, e.g.:
For performance reasons it may be useful to insert multiple items into a vector and then sort it once before you give control back to the OS. You'll have to test whether this actually works better than directly inserting into a sorted container though.
Anyway, to easily switch between container types, you can specify a sort functor that can be used as sort predicate (could probably be done more elegant with C++11 lambdas):
Use it like this:
",1,30773596
30755329,"
Problems in your code:

Your while loop. You don't make any breaking condition in the loop. 

Solution: Use you own preferred  breaking condition. Something like:

Calling bubbleSort with an uninitialized array in a for loop (!).

Solution:
Put the bubbleSort method calling outside of for loop,
Following is the 'proof' of bubbleSort() method implementation which actually works perfectly: 
And the output is:

-1023

Cheers!
",1,30755011
30692852,"
Got the following example in STXXL:Sorter Section which addresses the same problem.
Code:
",0,30691824
30686762,"
C-style arrays don't provide any member functions, as these are primitive types (hence the compiler error). 
For such an array you can use sizeof(a) to determine it's actual size within the same scope of it's declaration though.
As soon it's decayed to a pointer, you cannot determine the actual size from it.

As yours are most probably used to represent C-style NUL terminated strings, and you  probably want to use their actual size from the input, you can also use 

I'd recommend rather to use
instead.
",1,30686712
30680795,"
There are couple of things gone wrong in the implementation of your logic. I have indicated them clearly below:
",-1,30680576
30680837,"
First of all you should be correctly set for the size of the array.
Now , after this you have copies the both arrays in locally defined arrays. Until this, it is correct .
Now the main part is merging of the two arrays which you are doing in the for loop. You are just comparing the ith element of first sub array with jth element of the second, but what you are missing here is that there may be a time when you have updated all  the values of the first( or second) sub array in the main array but still some elements are remaining int the second ( first) one.
For example, take these two subarrays
in this case you should break from the loop as soon as you have traversed either of the array completely and copy the rest of the elements of the other array in the same order.
       Also in the for loop you increasing k two times in a loop , one in the for statement and another while updating a value, Check that too.
Hope this may solve the problem.
",0,30680576
30679004,"
As others noted, std::string has overloaded operator < and > to do the job of doing a lexicographical comparison.  
However, if your goal is to do an alphabetic sort, then you need to rewrite your template class.  But then things get very messy using the code you have already written, so a different approach can be taken.
If you are allowed to leverage using std::list, then writing a template linked list class that stores items in a custom order can be done using a wrapper class. 
First, we need to have the template take not only a type, but a comparison function to tell the linked list the criteria on how to insert an item into the list.  
Without explaining too much more, here is the code:
So what did we do?  We created a template class that takes two parameters, a type and a comparison function.  
Note that the comparison defaults to the std::greater for the type T.  So for example, if it T is an int, then std::greater<int> will do the comparison of two integers to see if the first item is greater than the second.  The example above shows that the template is instantiated the same way using a single parameter if the type's operator > is adequate (which for int, it is).
However, we want for our purposes to sort std::string alphabetically (or case insensitive).  To do that, we give as a template argument our custom function that takes two strings and compares them alphabetically (heads up to this SO question: Case insensitive string comparison in C++)
Now, the insert function uses iterators and just searches, using our comparison function, for the spot to insert the item.  When found, it just calls the list::insert function, which does all the work.
This is not the best example in the world, by no means.  But you should be able to get the idea.
Here is a live example: http://coliru.stacked-crooked.com/a/ecb2e7957eb4fea8
",1,30678046
30634078,"
The problem is that you did not provide any space in which the merged information should be placed. You provided an uninitialized pointer c for the sorted parameter, which gets dereferenced inside the function, causing undefined behavior.
To fix this, pass an array with sufficient capacity to hold elements of the merged array:
",7,30634048
30626366,"
Use std::list::sort. std::sort requires random-access iterators and you've given it bidirectional iterators. The other option would be to use a container like std::vector that has random-access iterators.
",3,30626300
30623634,"
In OnInitDialog you should do this:
AddString returns the index where the item has been inserted (which can be anywhere if the list is sorted). m_List.SetItemData (index ,(100 + i)) sets the data for the item you just have inserted.
",0,30619459
30656556,"
we can set structure data to list box.
I tried above code in my app..
",0,30619459
30614265,"
use sort with -kn flag
",0,30614099
30614293,"
You can sort the file with the sort utility:
You can sort the lines according to one or several keys which you specify with -k or --key. The value refers to columns numbers, starting with 1. Usually, the columns are separated by white space, but with -t you can specify a custom field separator.
",0,30614099
30614749,"
sort -t':' -k3 inputfile
-t specifies field seperator, and -k3 means that lines will be sorted upon a key consisting of fields from the third one to the last
",0,30614099
30610537,"
The problem is quite simple in your function: you aren't modifying the array but only a copy of it:
If you want to avoid the issue, you need to give a pointer to your function instead.
However, the C++ way is to use the STL instead so you should make your array that way: std::vector<std::vector<std::vector<int> > > (you can use the same initialization after)
That way in your function you would only need to pass a reference to this:
You can also use typedef to make the variable name easier to read: 
typedef std::vector<std::vector<std::vector<int> > > vector3D
And one last thing, you don't need your exchange function, std::swap does the same thing.
",1,30610443
30607121,"
Quick sort and bubble sort are general purpose algorithms. As such the do not make any assumption on the data to be sorted. However, whenever we have additional information on the data we can use this to get something different (I do not say better/faster or anything like this because it is really hard to be better than something as simple and powerful as quick/bubble sort and it really depends on the specific situation what you need).
If there is only a limited number of elements to be sorted (only 10 different digits) one could use something like this:
Note that this has complexity O(N). Further, this always works when set of possible elements has a finite size (not only for digits but not for floats). Unfortunately it is only practical for really small sizes.
Sometimes it is not sufficient to just count the elements. They might have some identity beside the value that has to be sorted. However, the above can be modified easily to work also in this case (needs quite some copies but still O(n)). 
Actually I have no idea how your problem could be solved by using bitshift operations. However, I just wanted to point out that there is always a way not to use a general purpose algorithm when your data has nice properties (and sometimes it can be even more efficient).
",1,30606370
30607792,"
Here is a solution - Implement bubble sort with loops and bitwise operations.
Notice that the comparison and swap happens without any branching and arithmetic operations. There are only comparison and bitwise operations done.
",1,30606370
30609440,"
How about this one?
",-1,30606370
30603201,"
While the data to be sorted could be moved into the sort function, doing so creates a function that's pretty much useless--since it only ever sorts one set of data, it's equivalent to return {1, 2, 3, 4 5, 6, 7, 8};
Your insertion sort is also a bit of a mess. Pseudo-code for an insertion sort normally looks something like this:
",1,30602938
30603105,"
I would suggest that you do not do this.  A function is supposed to be a reusable piece of code.  If you hardcode the array into the function then that function could only ever sort the array that is in the function and you would have to edit the array in the function to sort something different.  By passing the array to the function now you have the ability to pass any array to the function and it will get sorted.  You could even call the function multiple times with different arrays in the same program and they will be sorted.
I will also mention that if you move the array to be in the sort function then it won't be in main() and you won't be able to print out the array in main() as you have it now. 
",0,30602938
30601937,"
You just need to specify a predicate:
This code sorts the vectors by smallest to largest.
",5,30601837
30567421,"
",2,30567298
30549311,"
cplusplus.com is notoriously bad... looking at cppreference.com's description here

This function attempts to allocate a temporary buffer equal in size to the sequence to be sorted, typically by calling std::get_temporary_buffer. If the allocation fails, the less efficient algorithm is chosen.

get_temporary_buffer is:
So, while it will technically be underfined behaviour to specialise it for your own class in the std namespace, you're presumably not doing this for production code and in practice it's extremely likely to work reliably and would let you intercept the memory request and return failure.
",6,30549096
30549597,"
I looked over your functions and tried running it, but I'm missing the rest of your program. However, I think I know what's going wrong in your code by the error you gave me in your original post.

ERROR: Access violation reading location 0x00000000

This kind of error usually means your trying to access a memory address which was never reserved(allocated) in it's respective scope. Since you're trying to read the memory location with the hexadecimal value 0x00000000 which is a 32-bit binary value of all zeros, it's most likely that you're trying to deference a NULL pointer which is undefined behavior. And that this pointer is pointing to a 32-bit data-type which my guess is an integer.
One way to prevent this is to create a conditional statement to test if the pointer is NULL.
This would explain why your algorithm works but fails when you try to read out the values.
For future questions, try to narrow out the problem and recreate it in a smaller program so myself and others on this site can more easily assist you. In this case, it might be difficult to do so if you don't understand where the problem is in the first place.

DEBUGING TIPS: Using breakpoints and the call stack window can help you find where your program is assigning NULL pointers where you don't want them.",0,30548065
30548158,"
Counting sort would be the right choice if you know that your range is so limited. If the range is [0,m) the most efficient way to do so it have a vector in which the index represent the element and the value the count. For example:
Note that the count at i is lazily initialized but you can resize once if you know m.
If you are sorting objects by some field and they are all distinct, you can modify the above as:
Now the main difference is that your space requirements grow substantially because you need to store the vectors of pointers. The space complexity went from O(m) to O(n). Time complexity is the same. Note that the algorithm is stable. The code above assumes that to_sort is in scope during the life cycle of count_sorted. If your Ts implement move semantics you can store the object themselves and move them in. If you need count_sorted to outlive to_sort you will need to do so or make copies.
If you have a range of type [-l, m), the substance does not change much, but your index now represents the value i + l and you need to know l beforehand.
Finally, it should be trivial to simulate an iteration through the sorted array by iterating through the counts array taking into account the value of the count. If you want stl like iterators you might need a custom data structure that encapsulates that behavior.
Note: in the previous version of this answer I mentioned multiset as a way to use a data structure to count sort. This would be efficient in some java implementations (I believe the Guava implementation would be efficient) but not in C++ where the keys in the RB tree are just repeated many times.
",1,30547452
30548929,"
You say ""in-place"", I therefore assume that you don't want to use O(n) extra memory.
First, count the number of objects with each value (as in Gionvanni's and ronaldo's answers). You still need to get the objects into the right locations in-place. I think the following works, but I haven't implemented or tested it:
Create a cumulative sum from your counts, so that you know what index each object needs to go to. For example, if the counts are 1: 3, 2: 5, 3: 7, then the cumulative sums are 1: 0, 2: 3, 3: 8, 4: 15, meaning that the first object with value 1 in the final array will be at index 0, the first object with value 2 will be at index 3, and so on.
The basic idea now is to go through the vector, starting from the beginning. Get the element's processor index, and look up the corresponding cumulative sum. This is where you want it to be. If it's already in that location, move on to the next element of the vector and increment the cumulative sum (so that the next object with that value goes in the next position along). If it's not already in the right location, swap it with the correct location, increment the cumulative sum, and then continue the process for the element you swapped into this position in the vector.
There's a potential problem when you reach the start of a block of elements that have already been moved into place. You can solve that by remembering the original cumulative sums, ""noticing"" when you reach one, and jump ahead to the current cumulative sum for that value, so that you don't revisit any elements that you've already swapped into place. There might be a cleverer way to deal with this, but I don't know it.
Finally, compare the performance (and correctness!) of your code against std::sort. This has better time complexity than std::sort, but that doesn't mean it's necessarily faster for your actual data.
",0,30547452
54797201,"
You definitely want to use counting sort. But not the one you're thinking of. Its main selling point is that its time complexity is O(N+X) where X is the maximum value you allow the sorting of.
Regular old counting sort (as seen on some other answers) can only sort integers, or has to be implemented with a multiset or some other data structure (becoming O(Nlog(N))). But a more general version of counting sort can be used to sort (in place) anything that can provide an integer key, which is perfectly suited to your use case.
The algorithm is somewhat different though, and it's also known as American Flag Sort. Just like regular counting sort, it starts off by calculating the counts.
After that, it builds a prefix sums array of the counts. This is so that we can know how many elements should be placed behind a particular item, thus allowing us to index into the right place in constant time.
since we know the correct final position of the items, we can just swap them into place. And doing just that would work if there weren't any repetitions but, since it's almost certain that there will be repetitions, we have to be more careful.
First: when we put something into its place we have to increment the value in the prefix sum so that the next element with same value doesn't remove the previous element from its place.
Second: either

keep track of how many elements of each value we have already put into place so that we dont keep moving elements of values that have already reached their place, this requires a second copy of the counts array (prior to calculating the prefix sum), as well as a ""move count"" array.
keep a copy of the prefix sums shifted over by one so that we stop moving elements once the stored position of the latest element
reaches the first position of the next value.

Even though the first approach is somewhat more intuitive, I chose the second method (because it's faster and uses less memory).
Usage:
This can be further generalized to become MSD Radix Sort, 
here's a talk by Malte Skarupke about it: https://www.youtube.com/watch?v=zqs87a_7zxw
Here's a neat visualization of the algorithm: https://www.youtube.com/watch?v=k1XkZ5ANO64
",0,30547452
30548714,"
The answer given by Giovanni Botta is perfect, and Counting Sort is definitely the way to go. However, I personally prefer not to go resizing the vector progressively, but I'd rather do it this way (assuming your range is [0-1000]):
It is essentially the same, but no need to be constantly managing the size of the counts vector. Depending on your memory constraints, you could use one solution or the other.
",-1,30547452
30549190,"
For variety, map is convenient for doing the actual sort, although it won't be the most efficient:
",-1,30547452
30537081,"
I would use std::tie or make_tuple with rvalue:
Your case is not correct with
where it misses b < a condition.
before the == condition.
",4,30536997
30537329,"
The problem with your code is that for this condition:
You do not correctly handle the opposite condition. That is, the above line only tests if (a.second.second < b.second.second). If it's true, you return true from the function, which is correct. But if it's false, you then go on to check the lower priority conditions, ignoring the possible case that b.second.second could be less than a.second.second.
Also, a slight modification of Jarod42's std::tie method:
What std::tie does is make a std::tuple of references to its arguments. And operator< is overloaded for std::tuple to do a lexicographical comparison on its elements from the first to the last.
",2,30536997
30496107,"
use srand?
then 
",1,30496083
30484912,"

Please note i'm adding additional variable ""flag"" which helps to increase    the efficiency of your program because the loop will break when your elements are done sorting but in your program the loop might be doing some extra iteration.    

",2,30482922
30484911,"
I fixed the typos that others mentioned and added system(""pause""). Worked fine for me on VS 2010. Haven't got access to VS 2012 to test it. Here's your code:
Hope it works fine for you too.
",0,30482922
30485070,"
Concerning your bubble sort implementation:

your scanf_s in the first for loop always reads the number into the first position of the array.
your printf in the last for loop expects an integer but you supply an address.

To prevent the console from disappearing, you could replace getchar() by system(""pause""), although this is not portable.
Correcting these things, the bubble sort works for me:
",0,30482922
30463661,"
Instead of adding sorted values to a std::set, you could push the strings to a std::vector or std::deque (Note: Do not use the std::deque of msvc (2013) - is is not better than a std::list).  
A std::set should have a good performance finding the proper insertion point, if it is respecting the hint 'at end'. However, std::set is allocating nodes for each element individually.
Having a sequence of data, you can perform a binary search (std::lower_bound) on that data. 
See also:

Binary Search:
Where can I get a ""useful"" C++ binary search algorithm?
MSVC deque:
profiling: deque is 23% of my runtime

Note:
Having C++11 you might consider vector::reserve(huge_amount) and vector::shrink_to fit()
",3,30463198
30463656,"
My guess is to use vector, because the contiguous storage is good for performance, reserve an expected amount of entries beforehand, take advantage of move semantics and sort the vector at the end of the file only:
(You can also check the file size in a preprocessing phase to get a better hint instead of a fixed one)
Because of moving, the buf must be reset to an empty state.

Unless otherwise specified, all standard library functions that accept
  rvalue reference parameters (such as std::vector::push_back) are
  guaranteed to leave the moved-from argument in valid but unspecified
  state. That is, only the functions without preconditions, such as the
  assignment operator, may be used on the object after it was moved into
  a standard library container (cppreference)

",3,30463198
30463127,"
Do you really need the nth element, or do you need an element ""near"" the middle?
There are faster ways to get an element ""near"" the middle.  One example goes roughly like:
The result should be something that is roughly in the middle.  A real nth element algorithm might use something like the above, and then clean it up afterwards to find the actual nth element.
At n=5, you get the middle.
At n=25, you get the middle of the short sequence middles.  This is going to be greater than all of the lesser of each short sequence, or at least the 9th element and no more than the 16th element, or 36% away from edge.
At n=125, you get the rough middle of each short sequence middle.  This is at least the 9th middle, so there are 8*3+2=26 elements less than your rough middle, or 20.8% away from edge.
At n=625, you get the rough middle of each short sequence middle.  This is at least the 26th middle, so there are 77 elements less than your rough middle, or 12% away from the edge.
At n=5^k, you get the rough middle of the 5^(k-1) rough middles.  If the rough middle of a 5^k sequence is r(k), then r(k+1) = r(k)*3-1 ~ 3^k.
3^k grows slower than 5^k in O-notation.
is a very rough estimate of the lower bound of where the rough_middle of a sequence of n elements ends up.
In theory, it may take as many as approx n^0.33 iterations of reductions to reach a single element, which isn't really that good.  (the number of bits in n^0.68 is ~0.68 times the number of bits in n.  If we shave that much off each rough middle, we need to repeat it very roughly n^0.33 times number of bits in n to consume all the bits -- more, because as we subtract from the n, the next n gets a slightly smaller value subtracted from it).
The way that the nth element solutions I've seen solve this is by doing a partition and repair at each level: instead of recursing into rough_middle, you recurse into middle.  The real middle of the medians is then guaranteed to be pretty close to the actual middle of your sequence, and you can ""find the real middle"" relatively quickly (in O-notation) from this.
Possibly we can optimize this process by doing a more accurate rough_middle iterations when there are more elements, but never forcing it to be the actual middle?  The bigger the end n is, the closer to the middle we need the recursive calls to be to the middle for the end result to be reasonably close to the middle.
But in practice, the probability that your sequence is a really bad one that actually takes n^0.33 steps to partition down to nothing might be really low.  Sort of like the quicksort problem: median of 3 elements is usually good enough.

A quick stats analysis.
You pick 5 elements at random, and pick the middle one.  
The median index of a set of 2m+1 random sample of a uniform distribution follows the beta distribution with parameters of roughly (m+1, m+1), with maybe some scaling factors for non-[0,1] intervals.
The mean of the median is clearly 1/2.  The variance is:
Figuring out the next step is beyond my stats.  I'll cheat.
If we imagine that taking the median index element from a bunch of items with mean 0.5 and variance 0.32 is as good as averaging their index...
Let n now be the number of elements in our original set.
Then the sum of the indexes of medians of the short sequences has an average of n times n/5*0.5 = 0.1 * n^2.  The variance of the sum of the indexes of the medians of the short sequences is n times n/5*0.32 = 0.064 * n^2.
If we then divide the value by n/5 we get:
So mean of n/2 and variance of 1.6.
Oh, if that was true, that would be awesome.  Variance that doesn't grow with the size of n means that as n gets large, the average index of the medians of the short sequences gets ridiculously tightly distributed.  I guess it makes some sense.  Sadly, we aren't quite doing that -- we want the distribution of the pseudo-median of the medians of the short sequences.  Which is almost certainly worse.

Implementation detail.  We can with logarithmic number of memory overhead do an in-place rough median.  (we might even be able to do it without the memory overhead!)
We maintain a vector of 5 indexes with a ""nothing here"" placeholder.
Each is a successive layer.
At each element, we advance the bottom index.  If it is full, we grab the median, and insert it on the next level up, and clear the bottom layer.
At the end, we complete.
which sketches out how it could work on random access containers.
",6,30460921
30461000,"
If you have more lookups than insertions into the vector you could consider using a data structure which sorts on insertion -- such as std::set -- and then use std::advance() to get the n'th element in sorted order.
",2,30460921
30446198,"
I reworked your sorting code some to make it more efficient
Left and right move from the end of the array instead of from the middle. This way the left and right part of the array will be sorted and only pivot need to move around. It is based on this video if you want to see how it works.
",0,30445016
30431944,"
One way to do it would be to create a vector of (end, start) pairs (in this order - explanation below), sort it, then split the pairs of the sorted output:
Note the line with the (*) comment. STL pairs' order is lexicographic, which we exploit here (sorting pairs will sort by the firsts for free).
",0,30431822
30433280,"
You can pass a functor to std::sort or provide operator < for your data:
or simply
and later:
",0,30431822
30426529,"
You have to suply custom comparator.
This should work :) Live demo here

Be advised, look into reference before asking questions. There is an example with custom comparator there.
",1,30426507
30426544,"
If your compiler supports C++ 14 then you can write simply
or
Otherwise you should write
or
If your compiler does not support the current C++ Standard then you can define simply a function
and call the algorithm like
",1,30426507
30424465,"
You need to somehow 'connect' student name with his/her score. A very easy and straightforward way is to create a struct, i.e.
Next you need to define a Compare function (look here for an example: http://www.cplusplus.com/reference/algorithm/sort/) so that you can use std:sort to sort a vector of Students. Your Compare function could like like this:
",1,30424329
30424674,"
To keep the spirit of what you are doing, you can make a vector of pairs, here is a code example:
",0,30424329
30419514,"
When you check to see if userAnswer is equal to answers you always start back at 0. So you are checking student 1's answers every time. You could try:
",3,30419428
30419471,"
You initialize score to 0, but then you don't reset it for every student. You should do this:
By the way, your questions variable is a float, I think you want an int.
",3,30419428
30418420,"
std::sort can do this just fine. You just have to write the comparison function appropriately.
With that, you just do:
As far as optimizing goes, one possibility is to implement the comparison in a separate class:
This often assists the compiler in being able to generate inline code for the comparison, eliminating a function call in the inner-most loop of the sort.
",1,30418364
30418383,"
you can provide a custom comparison, and pass it to std::sort as the third argument.  
or you can provide operator< for bvp.
if you use C++11, you can even try lambda
",2,30418364
30418417,"
Use a custom comparator like
std::tie creates a tuple of references, and the operator< sorts tuples in lexicographic order, so the net effect is to sort by b first, then by v, then by p. 
",1,30418364
30409083,"
std::sort is generic sort that allows you to provide a custom sorting criterion.
e.g., for some container of points, lines, etc, l:
",1,30408937
30409041,"
The better way to do this is to create separate comparator classes for each of the respective sort orders that will work generically for all of the respective types which can be passed to the built-in std::sort algorithm.
",0,30408937
30409116,"
Why roll your own sorting function? Try something like this instead:
",0,30408937
30403401,"
The reason you are getting this error is that you are calling a getX() function and trying to set it equal to a value. You need to have or call a setX() function and pass your value through it. You can only get a value with a get function.
",1,30403352
30403454,"
As @NendoTaka correctly explained, you are trying to assign to a rvalue. If you want to use the same function for both a getter/setter, then make it return a reference
although now the name will be a tad confusing, as most people expect the getter to return an non-mutable object.
",1,30403352
30403469,"
What does getX() return?  It must not be an assignable value because that is what the compiler is complaining about.  If it returns a reference of the X value, you can assign to it, but if it is const or returns a copy you can't assign to it.
",0,30403352
12399290,"
Using C++11 lambdas
Now you can use the returned index vector in iterations such as
Obviously, you can also choose to supply your own original index vector, sort function, comparator, or automatically reorder v in the sort_indexes function using an extra vector.
",230,31883417
1577627,"
You could sort std::pair instead of just ints - first int is original data, second int is original index. Then supply a comparator that only sorts on the first int. Example:
Sort the new problem instance using a comparator like:
The result of std::sort on v_prime, using that comparator, should be:
You can peel out the indices by walking the vector, grabbing .second from each std::pair.
",81,31883417
11715359,"
I wrote generic version of index sort.
Usage is the same as that of std::sort except for an index container to receive sorted indexes.
testing:
you should get 2 1 0 3.
for the compilers without c++0x support, replace the lamba expression as a class template:
and rewrite std::sort as
",11,31883417
43488246,"
Now a contains both both our values and their respective indices in the sorted.
a[i].first = value at i'th.
a[i].second = idx in initial array.
",8,31883417
18683662,"
I came across this question, and figured out sorting the iterators directly would be a way to sort the values and keep track of indices; There is no need to define an extra container of pairs of ( value, index ) which is helpful when the values are large objects; The iterators provides the access to both the value and the index:
as for the usage example:
now, for example, the 5th smallest element in the sorted vector would have value **idx[ 5 ] and its index in the original vector would be distance( A.begin( ), *idx[ 5 ] ) or simply *idx[ 5 ] - A.begin( ).
",6,31883417
40183830,"
Its easier than it seems to be.
Suppose Given vector is 
Create A new vector
Sort V and while sorting instead of comparing elements of V , compare corresponding elements of A
",5,31883417
24327593,"
Make a std::pair in function then sort pair : 
generic version : 
ideone
",2,31883417
43922758,"
Beautiful solution by @Lukasz Wiklendt! Although in my case I needed something more generic so I modified it a bit:
Example: Find indices sorting a vector of strings by length, except for the first element which is a dummy.
prints:
",2,31883417
1577545,"
Are the items in the vector unique? If so, copy the vector, sort one of the copies with STL Sort then you can find which index each item had in the original vector.
If the vector is supposed to handle duplicate items, I think youre better of implementing your own sort routine.
",1,31883417
31883640,"
There is another way to solve this, using a map:
This will eradicate non-unique elements though. If that's not acceptable, use a multimap:
In order to output the indices, iterate over the map or multimap:
",1,31883417
35228068,"
Well, my solution uses residue technique. We can place the values under sorting in the upper 2 bytes and the indices of the elements - in the lower 2 bytes:
Then sort the array myints as usual:
After that you can access the elements' indices via residuum. The following code prints the indices of the values sorted in the ascending order:
Of course, this technique works only for the relatively small values in the original array myints (i.e. those which can fit into upper 2 bytes of int). But it has additional benefit of distinguishing identical values of myints: their indices will be printed in the right order.
",1,31883417
36728897,"
For this type of question
Store the orignal array data into a new data and then binary search the first element of the sorted array into the duplicated array and that indice should be stored into a vector or array.
Here binarysearch is a function which takes the array,size of array,searching item and would return the position of the searched item
",1,31883417
1577490,"
If it's possible, you can build the position array using find function, and then sort the array.
Or maybe you can use a map where the key would be the element, and the values a list of its position in the upcoming arrays (A, B and C)
It depends on later uses of those arrays.
",1,31883417
51939088,"
There are many ways. A rather simple solution is to use a 2D vector.
Here is the output:
",0,31883417
52650007,"
Consider using std::multimap as suggested by @Ulrich Eckhardt. Just that the code could be made even simpler.
Given
To sort in the mean time of insertion
To retrieve values and original indices
The reason to prefer a std::multimap to a std::map is to allow equal values in original vectors. Also please note that, unlike for std::map, operator[] is not defined for std::multimap.
",0,31883417
31759580,"
Your implementation looks very close to the pseudocode on Wikipedia (with j in partition(..) in your code being called i in the Wikipedia article and i in your code having the name storeIndex) 
But there are two differences, one of which at least causes the algorithm to fail on your example:
should be
the Wikipedia article says for i from lo to hi−1, inclusive hence the <= instead of <.
Another difference is that in your code you have
while the Wikipedia article has
so < instead of <= .
",2,31759368
31759608,"
Please change your for loop from:
to
or
The reason being the array must be handled right from lo to hi(inclusive).
But, in your attempt it was taking only 

{lo, low+1, ..., hi-1}

into account instead of 

{lo, low+1, ..., hi-1, hi}

",1,31759368
31738315,"
This is pretty basic file processing. It sounds like you just need to hash the blocks on address and then print the map values that have more than one block.  In languages like perl this is simple:
Of course you'll need a machine with enough RAM to hold the data.  32Gb ought to do nicely.  If you don't have that, a trickier 2-pass algorithm will do with much less.
",0,31737023
31722006,"
This part of the program
where it is not clear what variable n means
Should look the following way
The last statement can bewriten also like
provided that header <iterator> will be included
You may set also the range like [1, k + 1 ) but from your post it is not clear why the frist element of the vector should not be filled.
It seems that you get an unexpected result due to setting invalid upper bound of the range.
",1,31721793
31721896,"
You probably provide wrong end iterator to sort, as you can see last two entries from your input are the same as in output - sort simply does not include them in sorting.
std::sort will sort pairs, first by first element - and if both are equal it will compare second.
",0,31721793
31716283,"
First create the array of integer indices; here it is for 1D array:
Then create the comparison object. Here is a ballpark of that in C++99 lingo; for C++11 you can shortcut that by using a lambda:
The sort the index array using that functor:
Finally, use the sorted index array to order the values array.
",2,31716057
31716093,"
Yes. To sort row by row, you have to set the appropriate starting and ending point in the sort function.To keep the index part, you can first create pairs of the array elements and index using the make_pair command. After executing the above code, you can reconstruct the index array.
You will need to do something like this (I haven't tried it out though):
Remember to add the index as the second element in the pair, because the default comparision operator for pairs checks the first element, followed by the second element.
",0,31716057
40074113,"
Here's a C++ implementation of QuickSort using recursion:
",2,31720408
40074604,"
Here is a short version that uses std::nth_element():
It can be called with any random access iterator, e.g.,
Note: it is probably a little bit more costly that a standard quick sort, but it is interesting because the sorting criterion can be changed between the levels. This feature can be used for instance to organize multidimensional points data along a space filling curve (Hilbert sort), as done in the CGAL library [1]. Note: std::nth_element() is bugged in gcc 4.8.1 [2], but it is fixed in more recent versions.
[1] http://doc.cgal.org/latest/Spatial_sorting/index.html
[2] https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58800
",1,31720408
31677784,"
Look at std::sort, you can specify a compare function (or functor) to std::sort.
Therefore, you can write up a function that does compare two ""pas"" objects in the way you want.
",0,31677738
31669904,"
Why? Do you know that there won't be more than 100 elements in both files, combined? Probably not, right?
So you better use a data structure that can dynamically adapt it's size, like a std::vector. But, since you also seem to want to remove duplicates, a std::set is the better choice. This gives you another bonus: The elements of a std::set are sorted.
This way, your problem reduces to:
With your input and this code I get:
Use what the standard library provides you!

Concerning your code:
You don't look, whether the current element (at index) is actually smaller than the current minimum!
(Of course, there's also std::min_element.)
Oh, and:
Don't hard code requirements that you do not have. You don't need file streams here, just streams, so istream and ostream are better choices.
And also:
Consider the file containing a text string hello. Then your stream will fail, but you continue to read input. Better test directly on the input operation:
",0,31668820
31667405,"

It would be impractical to manually sort the underlying vector after
  each addition/removal for the list. It would only be reasonable to do
  this if it were somehow possible to force vector::push_back() to
  automatically insert elements such that insertions preseve the sorting
  of the list.

What you're talking about here is an ordered insert.  There are functions in <algorithm> that allow you do do this.  Rather than using std::vector::push_back you would use std::vector::insert, and call std::lower_bound which does a binary search for the first element not less than than a given value.
This makes every insertion O(logN) but if you are doing fewer than N insertions between your periodic checks, it ought to be an improvement.
The zipping operation might look something like this:
",2,31666913
31666944,"
Can you create a hash value for your list items? If so, just compute the hash and check the hash table for the other list. This is quick, does not require sorting, and prevents your ""every possible combination"" problem. If your're using C++ and the STL you could use a map container to hold each list.

Create a hash for each item in L1, and use map to map it associate it with your list item.
Create a similar map for L2, and as each L2 has is created check to see if it's in the L1 map.
When a new element is added to L2, calculate its hash value and check to see if it's in the L1 hash map (using map.find() if using STL maps). If not then carry out your Handle_New_Element() function. 
When an element is subtracted from the L2 list and it's hash is not in the L1 hash map then carry out your Handle_Missing_Element() function. 

",3,31666913
31667503,"
A container that automatically sorts itself on inserts is std::set. Insertions will be O(log n), and comparing the two sets will be O(n). Since all your elements are unique you don't need std::multiset.
",3,31666913
31667201,"
For each element of both arrays maintain number of times it is met in the opposite array. You can store these numbers in separate arrays with same indexing, or in the structs you use.
When an element x is inserted into L2, you have to check it for equality with all the elements of L1. On each equality with y, increment counters of both elements x and y.
When an element x is removed from L2, you have to again compare it with all the elements of L1. On each equality with y from L1, decrement counter of y. Counter of x does not matter, since it is removed.
When you want to find non-duplicate elements, you can simply iterate over both arrays. The elements with zero counters are the ones you need.
In total, you need O(|L1|) additional operations per insert and remove, and O(|L1| + |L2|) operations per duplication search. The latter can be reduced to the number of sought-for non-duplicate elements, if you additionally maintain lists of all elements with zero counter.
EDIT: Ooops, it seems that each counter is always either 0 or 1 because of uniqueness in each list.
EDIT2: As Thane Plummer has written, you can additionally use hash table. If you create a hash table for L1, then you can do all the comparisons in insert and remove in O(1). BTW since your L1 is constant, you can even create a perfect hash table for it to make things faster.
",2,31666913
31665813,"
I would suggest you store all of the data in a struct and store the struct in a vector and then you can write custom compare functions for how you want to sort the data.
Output:
Live Example
",1,31665677
31665735,"
The map always sort the pair automatically. Maybe you should use unordered_map for your question, it won't sort the pairs. So you want to sort by the value, you can store the pairs in ordered_map, and then sort them by yourself. It will have more high efficiency for your question. The details click here, answer what you want. I hope this can help you.
",0,31665677
31648111,"
std::sort takes two iterators, it's working for native arrays as well. All you need is to tell it how to compare two radius:
",5,31647826
31912776,"
When using sort(), you can either provide a comparison function as third parameter, or you can define the < (less than) operator for the struct:
Then you can simply call:
By defining the less-than operator, your struct can also be put intoset.
",1,31647826
31648010,"
You can use qsort() function.
",0,31647826
31647985,"
The qsort function does what you want. You can also use std::sort in C++
Importantly, check out this article about some details on floating point comparison.
Here's how to do it with std::sort:
",0,31647826
31648007,"

",0,31647826
31648404,"
Besides the answers already provided, 
in your structure definition, you can override the '<' operator too - 
and This should make the sorting function work just fine.
I am assuming that you won't be needing a different comparison function
on radius structure.
",0,31647826
31644606,"
Change vector<int> result; to vector<int> result = numbers;.
Replace all vector<string> to vector<int> and remove quote marks around numbers when you push_back them
",1,31644586
31644844,"
In your fix function, you are sorting result which is an empty vector.  This leads you to the other problem that you have a fundamental type mismatch requiring conversion.
If you want the result to be a vector<int>, you must to convert the strings to integers first.  Try this:
Read more here if you don't understand the above code:

std::transform
std::back_inserter
Lambda expression
strtol

Note that this solution uses features added in C++11.
",0,31644586
31644763,"
Problems, problems everywhere
Problem 1.


 vector<int> fix(vector<string> numbers)
 {
           vector<int> result;  <--- what is this?
           sort( result.begin(), result.end() );  <-- sort what? 
           return result;
  }



Problem 2.


 vector<int> fix(vector<string> numbers)

 {
       // You wanna make vector<string> become vector<int> directly? nope
       // You have to convert yourself
       // or use something like result.push_back(atoi(numbers[i].c_str()))
           vector<int> result;  
           sort( result.begin(), result.end() );
           return result;
  }



Problem 3.


void print(vector<int> vec)
 {
    cout<< ""------PRINT---------""<< endl;
   // I seldom see people use iterator on vector<>... but it's ok
    for (vector<int>::const_iterator it=vec.begin(); it!=vec.end(); ++it) 
    cout << *it << "" "";
    
   // Missing cout << endl; alert
    cout << ""------ END ------"" << endl;
 }



To conclude, working version:


#include <vector>
#include <iostream>
#include <algorithm>

using namespace std;

void print(vector<int> vec)
 {
    cout<< ""------PRINT---------""<< endl;
    for (vector<int>::const_iterator it=vec.begin(); it!=vec.end(); ++it) 
    cout << *it << "" "";
	
    cout << endl << ""------ END ------"" << endl;
 }
  vector<int> fix(vector<string> numbers)
 {
           vector<int> result; 
           for(int i=0, l =numbers.size(); i<l; i++) result.push_back(atoi(numbers[i].c_str()));
           sort( result.begin(), result.end() );
           return result;
  }

 int main() 
{

vector<string> test;

test.push_back(""5462"");
test.push_back(""5451"");
test.push_back(""7854"");
test.push_back(""221"");


print(fix(test));

return 0;
}



",-1,31644586
31640724,"
If it's a global variable, then it's most likely only limited by the amount of memory your process can use [in other words, how much memory your machine has, and that the OS lets the process have, whichever is lower]. 
If it's a local variable inside a function (and the ""bad access"" seen in your error message indicates that this is case, but it's not clear from your code samples), since std::array takes space on the stack, the limit is whatever your stack-size is. If you want a LOCAL variable to hold a lot of items, use std::vector, which will dynamically allocate, and then becomes limited by the amount of memory in your machine [as per above]. 
There are many other ways to solve this problem, but std::vector<double> A1(ARRAY_SIZE); is the simplest version, and it will only require one single call to new double[ARRAY_SIZE]; which is likely to not be noticeable in your overall run time if you fill and sort the contents of 1 million entries.
",4,31640611
31640728,"
For std::array it is the same as for ordinary C arrays, so look here.
",4,31640611
31634861,"
Write a function to classify a single point, i.e. determine into which region it belongs. As a simple example that you can expand:
Then, iterate over the points and put them into respective containers:
This way you iterate once over all points, doing a classification (that should be possible to do in constant time in your case) for every point, which is the minimum work required.
",0,31634459
31528051,"
If you are getting your objects in the reverse order, than you should switch the comparison signal:
However, it seems that you don't understand heaps properly. Heaps do not keep sorted objects, but rather only partially sorted. Notice that they will still pop objects in order, but you need to actually pop them, just iterating the heap will not do it.
Notice in the following picture that the array is not sorted at all. However, the heap does possess an important property when rendered as a tree: every node is smaller than all of its descendants. That's what partially sorted means. The objects are not sorted, but they are related to each other in a way which can be efficiently sorted.

To get your elements back sorted you need to pop them.
Edit: BTW, you should use std::pop_heap, not std::vector::pop_back. For reasons that should be clear after the previous explanation
",2,31527738
31517780,"
When you want to count something, the direct approach is just count what you are counting.  So far as I can tell, you want to count the number of times the following line is executed:
So all you need to do is put ++count; before that line.  If you want to do less computation and/or understand more, think through how many times it is executed:
Edit:  I really wasn't thinking when I wrote the stuff below the ---.  It is just wrong.  So directly counting matches your original method of computing the count.  I tested your code and now believe you are computing the correct count.  Try desk checking a small example, and explain why you believe the giant count is wrong.
I could not access your data file, so I can't confirm or deny your program computes the right count for that file.

That loop would execute its body at most (right-left-2) times.  Since you know right>left at that point, it is safe to say exactly (rather than ""at most"") right-left-2.
",1,31517645
31569442,"
I think your count is computed correctly.  But the global count is so inappropriate, I think that must be corrected.  You could eliminate that variable entirely by changing from:
to 
or make count local, changing to:  
",0,31517645
33471818,"
I feel that, here instead try using ""right - left"". Since ""right-left+1"" is what actually the length of the sub array, this will give the M-1 that you are seeking for. Hope this helps! 
",0,31517645
31522849,"
It does not make sense to apply std::sort on a std::map, because a map is always sorted, by definition. That definition is part of the concrete type instantiated by the template. std::map has a third, ""hidden"" type parameter for the comparison function used to order keys, which defaults to std::less for the key type. See http://en.cppreference.com/w/cpp/container/map.
In your case, you can use std::locale as the comparison type, and pass std::locale(""en-US"") (or whatever fits your system) to the constructor.
Here is an example. It uses C++11, but you can easily use the same solution in C++03.
Output:

Of course, you must be aware of the fact that std::locale is highly implementation-dependent. You may be better off with Boost.Locale.
Another problem is that this solution may look confusing, because a std::locale is not exactly something many programmers would associate with a comparison function. It's almost a bit too clever.
Hence a possibly more readable alternative:
",1,31498002
31493995,"
std::sort expects that its first two arguments are random-access iterators to the beginning and and of the sequence to be sorted.  You appear to be calling methods on a type name, which is a syntax error.  (If begin and end were static methods on the type player, the correct syntax would be player::begin()).  You should replace player.begin() and player.end() with something that returns iterators into a sequence; maybe something like std::begin(player_data) and std::end(player_data)?
Also, std::sort expects a comparator object, rather than a pointer to something.  Taking the address of a type, as your example does, clearly won't work, but since every one of your objects is a comparator, you could just use player_data[0].
So a call to std::sort that might work for you would be
",0,31493848
31491259,"
It is declared in Line 83, and probably defined it elsewhere.
You have redefined it in Line 422
",1,31491106
31483771,"
You actually don't need to do comparison-based sorting.
Construct a digraph with a directed edge for each inequality, and run Topological Sorting. This will run in linear time.
The boost graph library has this implemented.
",2,31483643
31483085,"
The task is to sort which keeping track of indexes. Using ""sort"" provided by C++ STL algorithm will be better than creating your own wheel. One possible solution is here: C++ sorting and keeping track of indexes.
To take fully advantage of C++11 lambda in QT, enter 

CONFIG += c++11

in your .pro file.
There are several tricks in quick sort that can slow your code down. A better implementation of quick sort can refer to ""Column 11: Sorting"" in book ""Programming Peals, Second Edition"".
",1,31481023
31475034,"
Just create a list of pairs of corresponding elements, and then sort the list by the first element of the pair.
",2,31474703
31489662,"
It is not a part of the standard if std::sort should try to perform as few as possible comparisons for small sizes. Different implementations may do that but this will depend on the library you are using.
",2,31471951
31472034,"
Looking at the code of std::sort in STL of MSVC++2013, it uses insertion sorting for 7 items.
Some comments suggested to use sorting networks. Sorting networks for small number of items (up to 32) can be generated here. Particularly, for sorting 7 items without parallelism the fastest algorithm seems this . According to the experiments here, the fastest SWAP macro implementation is:
The sorting-network code for 7 items would be:
",2,31471951
31472033,"
Algorithm is dependent on implementation. Usually quicksort algorithm is used, that's O(n log n).
",0,31471951
31418264,"
I think you might be a little confused on how if statements work in C++. If you want multiple conditions that all have to be true in order to execute the code, you need to use &&, not a comma. Commas do something different, they execute several statements but only use the last one for evaluation. Read this article, particularly the sections titled ""Logical Operators"" and ""Comma Operator"".
In summary, for every one of those if statements replace the comma with &&. That, however, does not address the fact that your sorting algorithm is not very scalable, since you've hardcoded every possible scenario. Look up some real sorting algorithms.
",2,31418132
31419104,"
you are using comma like Jordan said, and arrays start with index 0 in C++. Then if you declare an array with size of 3, its first value will be array[0] and its final one is array[2] 
for sorting try this:
",0,31418132
31419334,"
you should replace , with && in your conditional statements.
i.e.,
Notice that there are many ways to sort like: Quicksort, ‎Merge sort, Insertion sort, ‎Heapsort and bubble sort. You can find samples of them in c++ for practice.
Also there is a built-in library sort().
",0,31418132
31412470,"
Lets first start of by making the code a little more readable.  A little bit of whitespace never hurt anybody.

what's going on with the variables ""t"" and ""cnt"" (both integers) and the array ""p"" (an array of integers)

So t is being set to either u + x or u + x >> 1 depending on what q & 1 is.  Then inside the loop we are dividing t by whatever the value of sieve at the index of t is.  We are also assign that value to the p array at the position of ++cnt.  ++cnt is using the pre increment operator to increase the value of cnt by 1 and then using that value for the index of p.

Then there's the sort function, in which I completely gave up because I couldn't find any documentation on what it does

For this I am assuming they are using the std::sort() function.  When dealing with arrays the name of the array is treated as a pointer to the first element of the array.  So when we see sort(p+1,p+cnt+1); you can translate it to sort(one from the begining of the array, cnt + 1 elements from the begining of the array);.  So this is going to sort all of the elements in the array from one from the begining of the array to one less than cnt + 1 elements from the begining of the array.
",2,31411995
31412519,"
Are you trying to learn Nim as you said, or trying to learn C?  Both things you asked about are pretty basic c:
++cnt has the side effect (cnt=cnt+1) combined with the value that cnt ends up with.  That value is used as the index.  The side effect is a side effect.
p+1 and p+cnt are each pointers.  The name of an array is treated as a constant pointer to the first element of that array in most uses within C.  A pointer plus an integer is another pointer, pointing that number of elements past the original.
",0,31411995
31407163,"
I think you misunderstood the problem. 'eliminate those numbers that are repeating' means you have to print the number once and eliminate subsequent occurrence(s) of that number. For ex. 
Here, sorted tab[] becomes '1 1 1 1 5', then expected output is '1', but your program gives nothing! 
I hope this helps :)
",0,31405649
31375451,"
I would use std::multiset, since it can handle duplicates and maintains sorted order automatically. I would insert the numbers one by one, maintaining an iterator pointing to the median (stepping forward or backward depending on whether the new element is greater or less than the median).
Note that if this gets too large to hold comfortably in memory, you can pack a lot of the highest and lowest elements into files; it's unlikely that the median will ever move that far, and if it does you can unpack and repack.
",2,31375283
31373622,"
TempFile::sort_descending() is marked const, while you're trying to modify the _years member via std::sort.
Removing the const specifier from the function's signature or making _years a mutable will solve this problem.
",5,31373583
31370445,"
Something like following (in C++11), sort the matrix rows based on a specific column
Also notice, this code changes the original matrix rather than returning a new matrix.
non C++11 version:
",4,31370380
31368258,"
Sorting a polygon with n vertices
Assuming a coordinate system with x pointing right and y pointing up*, one way would be to have something like this:
That is, sorting the vertices from top to bottom, and then selecting the ones that are above the center in the range [begin, middle). The remaining [middle, end) are the ones on the bottom. At this point you can just stable sort the first ones from left to right and the second ones from right to left.
So considering a polygon like:

and feeding the algorithm the vector of points:

(1, 1) (6, 1) (9, 6) (3, 6)

You would receive:

(3, 6) (9, 6) (6, 1) (1, 1)

Live demo
This would of course also work with other polygons like:

feeded as:

(9, 8) (3, 6) (2, 3) (6, 8) (6, 1) (10, 4)

would yield:

(3, 6) (6, 8) (9, 8) (10, 4) (6, 1) (2, 3)

Live demo
* you can of course adapt it differenty if needed :)
Note: pictures have been takes from Wolfram|Alpha

Calculating the center of a polygon of n vertices
Assuming that we use the same notion of ""center"" as you have, you can calculate the center accumulating all points and dividing them by the number of points:
This makes it possible to define a sort_vertices function that only takes a begin and end iterator:

Sorting m polygons
Given this definition for sorting any number of vertices, we can use a simple algorithm that will iterate over groups of n vertices (n would be 4 in your case) and performs this transformation:
Live demo

Towards more idiomatic C++
Notice that I've made your code a little bit more like idiomatic C++ :P by changing the following:

Using snake_case for names
Using templates and iterators
Using the <algorithm> header
Using the <numeric> header

",2,31360142
31389107,"
You should add const to get_ranking method.
Which is part of C++ const-correctness. It means that the method does not change internal state of the object (except mutable fields which are rather rarely used) it is called by and allows to call this method by const objects.
",0,31349384
31350485,"
Alright, so I did a fair amount of reading and learned a bit. 
After resolving my const correctness by changing int get_ranking(); to int get_ranking()const it turned out my SortByRank() still wasn't working. This was because it was a non-static member of Database requiring a this pointer. Simply changing it to: static bool SortByRank(); or defining SortByRank() outside of the Database class solves the issue. 
",0,31349384
31323251,"
The predicate needs to work with the key type of the map. 
Change
to 
In the implementation of the function, you can extract the strWord member of the objects wp1 and wp2 and follow your logic.
",0,31323065
31314862,"
All elements in your vector<string> numsString end up having the same value 0 converted into string:
And, in your comp function, you are not checking if the numbers are equal. Add that as well at the top of the function:
",6,31314462
31305231,"
The function has undefined behaviour because there is used uninitialized variable lowest_number
Take into account that variable lowest_number_index is also uninitialized.
",5,31305191
31282740,"
I would use a 3-dimensional array. To use your example:
The ""above"" relationship is simply a matter of index arithmetic: [ia, ja, ka] is above [ia+1, ja, ka], [ia+1, ja+1, ka] and [ia+1, ja, ka+1].
",1,31282393
31260338,"
This code is wrong:
When you write B[i], it assumes that B is at least of size i+1. Since the maximum value of i (which you used an index to B) is A.size()-1. The assumption in your code is that B is at least of size A.size().  This assumption is wrong — the fact is that B is of size 0. 
Unfortunately operator[] of std::vector doesn't check for out of range index. If you use at(), the code will throw std::out_of_range exception:
Now this would throw std::out_of_range exception.
Anyway, one simple fix could be this:
However, I'd suggest this solution:
I'd also suggest you read more about std::vector, especially the following functions:

size()
capacity()
resize()
reserve()
push_back()
operator[]
at()
emplace_back()
and all the constructors.

Also, learn to naming your variables properly and be consistent with it.
Hope that helps.
",2,31260054
31261643,"
do you pefer to use vector and pair?
each pair has ""first"" and ""second"", put ""first""=value to sort,""second""=original index, create a pair for each element and put them into vector to sort:
output
",2,31260054
31260608,"
Normally what is done is the opposite... i.e. given an array x of elements compute an array of integers ix so that x[ix[i]] appears to be sorted under a certain criteria.
This allows representing the container with different orderings without actually having to move/copy the elements.
With C++11 this can easily be done using lambdas:
This ix index array is what you are asking for (i.e. the ""old"" position of an element: ix[i] is where the i-th element of the sorted list was in the original array) and there is no need to modify the input array.
",1,31260054
31260106,"
You are trying to sort a list of custom objects, answerd here: 
SO Link
Once you list the list of VnI objects you can then access there old index's through the I member that I presume is the index.
",-1,31260054
31259544,"
To populate vector of strings
To sort lexicographically
To sort numerically
cmpr is a custom comparator defined to compare numerical part of strings.
To get the numerical part of string, use
An example in C++11
See http://ideone.com/1Wcnvq demo
",1,31259481
31259552,"
Read the names from the file to std::vector<string>.
Now, 
The comparator should take 2 strings as arguments and compare the number part of the strings.
",0,31259481
31260907,"
I would use boost::MultiIndex for this. –  drescherjm
",1,31247881
31236440,"
You ought to have tested these functions as you wrote them. The problem is here:
You correctly gave sortByArea const pointer arguments, but neglected to make getArea a const function. The compiler is telling you that you are commanding that the code perform an operation that might change the shapes, after you forbade that they be changed.
",2,31236375
31198905,"
You said ""For example I need it to sort arrays each containing 3 integers by their 3rd int,"" and that you won't know which index (which column) is significant until run time.
If you are able to use C++11, it can be this simple:
If you are restricted to C++98, you can do the same thing, but instead of a lambda, you must write a functor that takes the column as a constructor parameter:
Finally, if you want a multi-column sort, the functor would look like this, where cols is an ordered list of columns to sort on:
",5,31197681
31197911,"
You can use a custom comparator constructed with the information about your custom sort order. You do it sort of like this.
",1,31197681
31197921,"
Write a functor that takes arguments to determine how to sort. Here's a simple example that takes an argument to switch between ascending and descending order:
Of course, you could have as many parameters to the constructor as you want (or multiple constructors) and make the logic as complicated as you want, though it'll be called a lot, so making it really complicated would probably not be a good idea.
An example of calling it:
(Also, this example is a little contrived, since if what you want is to reverse the ordering, you can simply use rbegin() and rend() in place of begin() and end() respectively.)
",1,31197681
31197779,"
Here I describe the C rtl qsort, but it is almost certainly almost the same as the c++ variant:
The sort function takes as a parameter a ""comparison function"".  Each time the comparison function is called it is passed two parameters which are pointers to the two elements to compare.
After coercing the type of the parameters, you can then compare anything you want.  For example, if the elements contain some struct with an integer array and you want to compare the nth items in them where the program's first parameter tells which column, something like this will work:
",-1,31197681
31195821,"
range based for loop are used only for sequencing each element in an array or vector for customization loops used traditional for loop
",1,31195644
31199643,"
Insted of using a vector, just use a std::list, Its much simpler and faster than manually doing it,
And then to order the list its as easy as:
To sort the list alphabetically, and not case specific;
",1,31195644
31199968,"
Alternatively, define an iterator based Bubble Sort like
To apply on your vector
",1,31195644
31175189,"
std::sort() has a second form that takes a compare functor as a third parameter. This lets you control the ordering of the sort without having to write the sort algorithm yourself.
The function you provide is given two objects, and must return true if the first object should be ordered before the second (""less than"") and false otherwise.
E.g.:
(Of course, it's up to you to work out the logic you need to get the sort ordered how you want it.)
",2,31175160
31152574,"
There's no need to add lexicographical_compare, that's already how vectors are compared.
Depending on your exact use case you're looking for std::lower_bound or std::upper_bound, std::binary_search or std::equal_range- all of these operate on sorted vectors.
A complete example with your data and c++11 is below. It constructs your vector, sorts it (showing the order you mention), then finds a single value in the vector.
",7,31152544
31152845,"
As I said in comments create a function:
",0,31152544
31146182,"
I agree with @Slava on not using a map for this purpose.
My suggestion is to use a simple vector and sort it according to different rules. Something like this:
where 
Then you can quickly get access to objects n the vector via std::lower_bound and, when needed, re-sort the vector according to e.g. mysort<1>
",1,31145587
31145994,"
Though technically it is possible to sort std::map based on value rather than the key, I would strongly not recommend that, as it would lead to buggy and very difficult to support code. Key for std::map is not mutable and it follows std::map design, if you use comparator on value and modify it, you will get unpredictable behaviour. You may use std::set instead:
Group inside GroupList will still be immutable, so to modify an element you will have to remove and reinsert modified copy. If that not what you want you probably can store Group in std::vector or std::list etc and build an external index - what is actually done in boost::multi_index under the hood.
",0,31145587
31127117,"
Expanding on my earlier answer, and in case you're really looking for something more advanced, here's what comes to mind using Boost MultiIndex containers:
Live On Coliru
Prints
",1,31122812
31126961,"
Whenever I see a datastructure, I imagine to have a definition for it handy:
Now you can trivially define the array:
Since it's a simple aggregate with value semantics, you can just define an order and sort it:
Demo
Adding a streaming operator<< and we get a full working demo:
Live On Coliru
Prints
",4,31122812
31062696,"
Use std::tie, something like this:
will sort according to Name first, if Name is equal then according to Score, when both Name and Score are equal then according to Date.
Sorting is simply done by:
Which, by default, uses operator< on the contained objects of type Account.

Update: I misunderstood your question. In your case you need separated comparators, e.g.
and sort the vector with

With lambdas, you could also use
directly, simply switching < and > for ascending/descending. No need for other helpers or operators in the class/struct itself.
",4,31062669
31057236,"
You are going out of bounds here when i == size - 1:
Change it to
",3,31057182
31057389,"
In the outer loop you are accessing out of bound memory area.
Try this:
",0,31057182
31039590,"
It would be better to use a map:
It sorts based on the key (in this case an int) and by default sorts how you want.
Edit:
You could also use what you've already got, like this:
",3,31039569
31039662,"
You can create a map as follows if you have C++11 compiler:
In c++098
",0,31039569
31037464,"
I wouldn't use multimap.  I'd use a map<int, set<string>>.  The reason is you need both your keys and values sorted.  A multimap is only going to sort the keys.  By using a map of sets, the map will sort by keys and the set will sort by values (assuming you give it the right comparator).
",2,31037204
31037483,"
If you want to sort key-value pairs by both the key and the value, then you don't want a multimap, which doesn't provide any way to sort on values with the same key. You want a set of pairs, with a custom comparison function that sorts them in the order you want. Something like this (warning, code written off the top of my head, not tested):
",1,31037204
32833791,"
It's a simple off by one error.
Array indexes go from 0 to n-1, not to n.
",3,32637980
32638663,"
This is the part of the code that is breaking your merge, think about what would happen if you have two lists with 1 more element in them then they should, see: 
That means that they could look something like this for 2 values 
the questionmark will be some number but you have no way of knowing what, if you then run the comparison inside the loop a few times you will get to lets say i = 2, j == 0 for simplicity, now you try to do the comparison:
and that's the same as
meaning you have a undefined behavior, and what gets even worse is that you might go to i = 3 and start looking at random memory.
So in conclusion, (infinity?) in some smart way.
",2,32637980
32638425,"
In the C++ merge function, the right half of L[] starts with mid + 1, so the second populate loop should be:
In the provided algorithm, indices go from 1 to n, so the first populate loop is TMP1[i] ← L[lowerBound + i - 1]. With C++, indices go from 0 to n-1, so the C++ first populate loop: tmp1[i] = L[lowerBound + i]; is correct, but the second loop needs to be changed to tmp2[j] = L[mid + j + 1]; .
",1,32637980
32639576,"
Sorry for forgetting to reply for nearly two weeks :/
It was a few off by one errors, but I tracked them down and got it working.
Thanks to everyone who helped.
Changed
to
Changed
to
Changed
to
",1,32637980
32639360,"
Issue 1: Sentinels
infinity being commented out is one of the issues. 
It is used as a sentinel, so when you reach the last position of tmp1 (or tmp2), it'll ensure that you copy all the other elements from the other array, tmp2 (or tmp1). You can represent inf here using std::numeric_limits<T>::max().
@Petter made a good description of why this issue happens.
Issue 2: Initialization
Your other issue seems to be in the initialization, before merging your arrays:
The pseudo-code is indexing from 1, while it should start from 0.
Issue 3: Indexing
As pointed out by @MarkRansom, the indexing range should be from 0 to size1, instead of size1 + 1.
",0,32637980
32634322,"
If you have some class Point and the point you want to sort against is 
Also assume that points is defined as 
and you had some function dist that took 2 Point and returned the distance (e.g. Euclidean distance) like
Then you can use std::sort with a lambda function
Edit
If you do not have C++11 access, you need to define a functor
Then you can sort in a similar way
",6,32634239
32634372,"
You don't need a different sorting algorithm. std::sort works perfectly fine with user-provided orders. 
The only problem here seems to be your definition. It still is easy, use a lambda : [X] (Point A, Point B) { return distance(A,X) < distance(B,X); } 
",1,32634239
32634456,"
you could just use the method you're talking about with two points from the vector (including your external point inside the vector) and then make sure to pop_front/erase when you're done.
",0,32634239
32634588,"
Using a function object:
",0,32634239
32604001,"
There's already an operator< defined for pairs in the std namespace, and that's the one that's found by the version of std::sort that you are using. Your overload is never found. Use a named predicate instead:
Also, the predicate should be callable with constant values, so either take the arguments by value or by const reference.
Note that sort lives in the std namespace. By contrast, when you use the < expression in main, your own overload in the global namespace is indeed found.
",11,32603876
32604206,"
It seems you use a C++11 compiler, correct and make it easier using lambda functions. Something like
",1,32603876
32599510,"
Usage
",0,32599509
32587540,"
std::random_shuffle usually works as follows:

So we can see two sources of inefficiency here:

Random number generators are often quite slow.
Each swap uses a totally random element from the vector. When the data size is large, the whole vector does not fit into CPU cache, so each such access has to wait until the data is read from RAM.

Speaking of point 2, sorting algorithms like quicksort are much more cache-friendly: most of their memory accesses hit cache.
",4,32586825
32587395,"
First, std::sort is not required to use an unqualified swap. It's not a customization point, and you cannot rely on your own user-defined swap being found through ADL. But even it would, sort can also use std::rotate, which can do swap but also memmove. This would not be counted by your implementation. 
Second, the Standard Library only specifies asymptotic complexity, which is O(N) for std::shuffle and O(N log N) for std::sort. So you should measure for different values of N (e.g. powers of 2 from 65K to 65M amounts of elements) and measure the scaling behavior. For small N, the constant of proportionality of sort could be much smaller than the one for shuffle since it has to call a potentially expensive random generator.
Update: it indeed appears that constant factors and/or cache-effects are the culprit (as pointed out by @stgatilov). See this DEMO where I run std::sort on the data after std::shuffle has been called. Runtime for sort is about half of that of shuffle, with 5x more swaps.
",1,32586825
32575689,"
I would suggest using std::sort, the standard algorithm for sorting, which is often implemented with a Quicksort. It is very fast, and also supports custom comparison. Here's some code to get you started:
I'm sorry if that code is a little hard to read, but it does the trick.
This of course would work with C-style arrays too, just replace data.begin() with data and data.end() with data + size.
",0,32575518
32575649,"
Alright, so I looked at it a bit. Let's start with conventions. 
Can be shortened to:
Which looks better and is more readable. It would also be nice to have a few more comments, but that's something everyone needs to get better at, no matter how good they are.
So it seems that your code does correctly sort the array into even and odd halves. That's all you need to do yourself as long as you know where they end because sorting them largest to smallest is something that std::sort can do for you.
Edit: It was pointed out to me that my previous example is not exactly the same, as with the second one i can only be used in the loop. For your purposes, they work the same.
",0,32575518
32576029,"
You can just reorder it
",0,32575518
32556007,"
I would use std::sort. You will need your own data structure to package the int and the std::string together.
Side note: Try to avoid using namespace std;. It is bad practice
",1,32555972
32518192,"
There is two problems with the code.
A) You are creating a stack allocated array that might be large. Once the stacksize overflows the next page might be anything from unmapped to random heap memory.
B) The other weird thing I noticed is that you initialize an RNG with every call of partition (can also be expensive) which wastes stack space for every partition point.
",3,32517580
32517797,"
You have two different problems, that should really warrant two different questions. I will however answer one for you.
Oh, and in the future please don't have links to code, what if that link goes dead? Then your question will be useless.

The problem with the crash is that just about all compilers place local variables (including arrays) on the stack, and the stack is limited. On Windows, for example, the default stack for a process is only a single megabyte.
With two such arrays, each of a 1000000 entries each, you will have eight megabytes (which happens to be the default stack-size for Linux processes), plus of course space for the function call stack frames and all the other local variables and arguments etc. This is beyond (or way beyond) the available stack, and you will have undefined behavior and a probable crash.
",2,32517580
32517981,"
Microsoft's std::sort uses introsort. Wiki link:
http://en.wikipedia.org/wiki/Introsort
Introsort switches from quicksort to heapsort if the nesting reaches some limit, primarily for performance reasons, since an indicator that quicksort is going to be slow is excessive nesting, but it also has the side benefit of preventing excessive nesting from running a thread out of stack space.
",0,32517580
32515829,"
As mentioned in my comment, you CANNOT dynamically grow the size of C-style arrays (use std::vector if you are willing to achieve that)
In your case, you need to give the final size (sum of size of array1 and array2) of the final array at the time of creation, i.e.,
finalarray = new int[*size1ptr + *size2ptr];
",2,32515622
32506138,"
You should use std::stable_sort. 
In your specific case, you could tweak the lambda to compare a with b when val[a] == val[b] but that would make your intention obscure to any future future developers that might stumble upon this code.
",7,32505975
32506207,"
When val[a] == val[b], return the smaller of the two indexes.
",1,32505975
32505916,"
Pointers in C are integers like any others, and can be compared with the usual operations.
So you can do things like:
I'm not going to solve your homework for you, but I hope this helps.
",1,32505595
32503974,"
Error: Array consist scoreNUMS elements, the first one is testScores[0] - first index is zero. And last index is scoreNUMS-1
You must write 
PS: You can use next prototype:
UPD: passing an array to a function is performed by passing a pointer to the first element of the array. (Your array does not copied when you pass it to function)
And run function by this way: sortArray(testScores, scoreNUMS);
",0,32503596
32488857,"
Its hard to understand what you want to achieve, but take a look at this function:
Those are the basic usage of custom compare function in std::sort.
It looks wrong:
You dont have to pass these two variables manually. The usage should be:
Moreover you are missing the const& in your compare function.
",1,32488613
32488858,"
Change the function signature to take const&.
and then use it as:
Having said that, I noticed that sortPair does not have a return statement before the end of the function. That leads to undefined behavior. Make sure you add
or 
I couldn't tell which is appropriate in your function.
",0,32488613
32485908,"
Since an array is a contiguous block of memory, you can use pointers to access array members much the same as with an index:
The compiler automatically calculates the offset based on the size of the data:  sizeof(int).
So for your project, if you are given a pointer to the first and last elements of the array, You can split the array in the middle:
Then you can keep doing this recursively
",0,32485423
32491147,"
Merge sort use sequential access for input from each of two runs (part of an array) and output to a single run (part of the output array). You can use local pointers that you advance by 1 instead of indexing from base pointers. So the main merge process would look something like this:
The question doesn't mention if the goal is to implement a top down (use recursion to fill stack with pointers to runs until run size == 1, then start merging and returning) or a bottom up merge sort (skip the recursion step, initialized run size to 1, merge pairs of runs across array until all pairs merged, then run size *= 2, and repeat until run size >= array size).
The wiki article shows simple examples of both top down and bottom up merge sort.
http://en.wikipedia.org/wiki/Merge_sort
",0,32485423
32468455,"
Ask and you shall receive.  Here you go.  
Case 1: Specialized function object - functor.
Case 2: Overloading operator < in structure.
Usage:
Overloading the operator< allows functions to compare instances of your structure naturally:
The functor allows you to pass a comparison algorithm to ordering functions like std::sort:  
Note:  See std::sort for exact syntax. 
BTW, what are the rules for when one variable has a number of zero and the other doesn't? 
",1,32468305
32468484,"
Basically your structure is so trivial that you could replace it with a std::pair.
Then you could just use std::sort in the ordinary way and due to the std::pair lexicographical compare, you'll get you're desired effect, simple and without defining a custom comparator (example below):
LIVE DEMO
",-1,32468305
32464880,"
Don't call the sort function after each input. Just call it when all input is ready.
Something like:
",0,32464704
32466031,"
Looked at it again, and used an alternative:
Input:
Output:
",0,32464704
32462823,"
If you define your ""hand"" as an array:
Then you always have 7 cards. Sure you could add a ""sentinel"" Card value or something, but really there's always 7 cards. You can't remove or append to a raw array. On the other hand, if you used a dynamic container instead:
Now, you can have a variable-sized hand and add and remove cards as you see fit. And your discard function becomes easy:
Although with Go Fish, it probably makes more sense to discard a card by value:
",1,32462586
32462880,"
There are 52 cards in a standard deck and an unsigned char can represent more than 52 distinct values.
Assign zero as a 'no card' value and use values 1 - 52 to represent the cards. Instead of removing cards from the array and then rearranging it, simply overwrite the value to be erased with zero.
When adding a card to the array, iterate until you find an index where the value is zero.
",0,32462586
32464180,"
ok so I figured it out 
",0,32462586
32462744,"
Even though this is probably homework assignment, you should really use built-in methods in objects such as std::vector or std::list. If you really want to use arrays, you can delete an element by moving all elements to the left that are after the element you want to delete. It would look something like this:
",-1,32462586
32448059,"
If I understand the problem statement, I think you're looking for something along these lines :
The piece that you're code was missing, I think, was that once you find a new maximum, you have to put it back in the array before placing the new maximum in theArray[0] storage location (see theArray[j-1] = theArray[0] after the compare).  Additionally, the inner loop wants to run one less each time since the last element will be the current max value so you don't want to revisit those array elements.  (See for(int j = 1 ; j <= size + 1 - i ; j++))
For completeness, here's the main driver I used to (lightly) test this :
",1,32447396
32378634,"
Your algorithm has a complexity of O(NxM), where N is the size of result and M is the size of param.
If what you are comparing here:
supports the less operator you can sort params before the first loop. And instead of going through all its elements, just do a binary search. The complexity will be then O(Nxlog(M)).
",1,32378450
32379037,"
If there are ready params for comparison

if (results.first().params... == params[i].params...)

in each result, you can store 6 params in a hash table and search through a hash table each iteration of

while(!results.isEmpty())

which gives O(N) complexity
but actually real performance depends on hash function. Sometimes O( N log M ) may be better; it depends on operations time.
So it's better to check performance in practice after optimization.
Additional note: current complexity is O(N) anyway because number of params (6 params) is a constant. 
",0,32378450
32348111,"
In string, ""4"" is actually bigger than ""35"". If you want to compare as a numbers, you should convert string to int. Then you find your desired answer. 
You can do that by simply change if condition statement if( atoi(v[i].c_str()) > atoi(v[j].c_str()) ) in bubblesort function
So, the final code is:
Output:
",2,32347455
32347625,"
You should notice that although 33 is a bigger int then 4, if you compare strings it isn't the case. StrING compare checks the first char against the first char and if there is an equality it moves on to check next char. So if comparing 4 with 33 you get that 33 is lesser because 3 is lesser then 4.
Solution: use atoi to change the string to int and then check who is bigger
",0,32347455
32348048,"
Basically what's going wrong is that strings do a lexicographical compare by default.  Easiest fix is just to change your vector-of-strings into a vector-of-int and filling that vector with an int-converted-from-string (assuming that that conversion succeeds).  How to convert a string to an int is something else to search the web or SO for.
",0,32347455
32344940,"

Assume the final result should be ascending. Run your algorithm once.
Check whether the output is really ascending. If yes, we are done; if no, go to 3.
Roll back to original input, assume the final result should be descending, run your algorithm once.
Check whether the output is really descending. If yes, we are done; if no, the input is illegal.

",0,32344904
32341178,"
If you want to display the even numbers from the array integers you can use a simple for loop and if statement:
",1,32341043
32341164,"
Your approach is all wrong, you can't detect even numbers by searching a list, you need a mathematical test for evenness. Write a function called is_even which tests one number and returns true if it is even and false if it is not. Then you can use that function, very simply, like this
Now you just need to write the is_even function.
",0,32341043
32341206,"
And avoid taking input to char what if user enters a number with more than one digit 
",0,32341043
32365423,"
",0,32341043
32339309,"
With the current algorithms you'd need to ""zip"" the two ranges into a common view of elements from both ranges ordered according to the key of the first range. Creating a corresponding random access iterator is mostly straight forward except for the somewhat unfortunate constraint that operator*() is supposed to yield a reference to the respective elements.
I think Boost has a zip-range providing the corresponding functionality.
",0,32339133
32302148,"
One approach that you could take, is to sort the numbers first, before deciding how many duplicates there are.  That way, it will be easier to avoid printing results for the same number more than once, and you also won't have to loop through the entire array for each number.
prints:
",1,32301810
32302416,"
I would use map or unordered_map to, well..., map the integer to the number of it's occurrences. It makes things quite simple, as it basically takes care of the duplicates for you.
Since it's an assignment I am leaving figuring out the c++ shenaningans to you and http://cppreference.com. Keywords are map, map::iterator and maybe associative container which map in an example of.
I do understand that it might be harder to understand than plain implementation of some algorithm, but this is probably close to optimal solution in modern c++, and putting effort into understanding how and why it works should prove beneficial. One should notice how much less of code had to be written, and no algorithm had to be invented. Less implementation time, less place to make mistakes, less testing.
",1,32301810
32305581,"
Search your array. For every integer, either record it, or increment your count of it. Repeat process till done, then print it.
How? you say? One approach would be to use parallel arrays to store the unique integers found, and another to store the count of integers. Then print the unique integers and their counts.
Code example of simple search algorithm:
Output would be something like:
In the above, I used vectors for simplicity, but if you must do so with c-style arrays, one approach would be to create all three vectors the same size, and keep one integer counter for number of indices used in the valueArray and countArray; they should share, since they're related 1 to 1. And you will need to pass it to the findRepeats function as well.
Having arrays of the same size will ensure that your values and counts will fit in your array; this would happen if every number entered was unique.
",0,32301810
32259284,"
maxValue and tempName should not be pointers. Really, you only got this working by pure chance, because dereferencing unitialized pointers is constituted ""undefined behavior."" Try this:
",0,32259135
32230176,"
I don't want to rewrite everything for you, but you're on the right track. Here are some recommendations:

For starters, you are going to run into problems trying to iterate through rh. What I would recommend is getting the front element, storing it somewhere (i.e. ""int to_insert = rh.front()""), then deleting that element with pop_front()
In your for loops, you declare one of your iterators as lh.end() and then try to dereference it. lh.end() will give you an iterator off-the-end of the list, not the last element in the list, so dereferencing it will give you segfault errors.
Since there's no list method to get an iterator to the last element, you can change your algorithm slightly to start inserting from the beginning of lh instead of the end. If you must start from the end, use reverse iterators instead: http://www.cplusplus.com/reference/list/list/rbegin/

Read up a little bit on selection sort. This is a similar sort of algorithm as what you are trying to do: https://en.wikipedia.org/wiki/Selection_sort
Also, on a personal note, you might find it easier to use the ""auto"" keyword when declaring iterators, as such:
",0,32229534
32239411,"
Twice the original question states that rh has the unsorted numbers, but then the example comments reverse this, showing lh with the unsorted numbers. Here is example code that does what is described, but is different than the example text and example code. Perhaps the original poster can explain what the actual goal is by stating how the below code differs from what the code is supposed to do. Note that list.insert() can be used on an empty list.
",0,32229534
32235015,"
EDIT: I've significantly revised this answer based on the comments.
There are two cases in which you might want to use counting sort. First, you may have an array of actual numbers that you want to sort, and the goal is to sort those numbers. Second, you may have an array of values to sort, each of which is sorted according to some key that's a number in a fixed range.
In the first case - where you're purely sorting numbers - there's no reason why you need to convert the histogram into a cumulative histogram. Since numbers are just numbers, you can sort the array not by rearranging the initial values into sorted order, but just by generating a new list of numbers based on a frequency histogram. For example, here's how you might do that:
Notice that the numbers that are added to the result vector aren't read from the input, but are instead generated just by using the loop counter.
In the second case - where you have elements to sort and each element has a key - it's not possible to use the above approach because you can't regenerate the elements just by counting. Instead, you're going to need to do something more clever that actually involves rearranging the elements from the input sequence.
This is where the frequency histogram idea comes in. The basic idea is the following - we want to determine, for each element in the input array, the index at which that element should end up in the sorted array. Let's imagine that we start by getting the frequency histogram H for the input array. This histogram has the property that H[i] tells us how many different elements there are with key i. Now, suppose we make a cumulative frequency histogram C where C[i] = C[0] + C[1] + ... + C[i]. In this case, C[i] tells us how many elements in the input array have key less than or equal to it.
Imagine that you have just the input array and the cumulative frequency histogram. What could you do with it? Well, suppose that you have some element A[i] from the original array. Based on the cumulative frequency histogram, we know that there are C[i] elements in the array whose key is less than or equal to A[i]. Therefore, if we wanted to reorder the input array so that everything was in sorted order, we could put element A[i] at position C[key(A[i])] - 1, since there are C[key(A[i])] - 1 elements less than or equal to it. Assuming that there are no duplicated values in the array, iterating across the array A and repositioning everything according to this formula would correctly put the array in sorted order.
Things are a bit more complicated if we have duplicates. Suppose there are two elements A[i] and A[j] where key(A[i]) = key(A[j]). In that case, we can't put both elements at position C[key(A[i])] - 1, since they'd collide. However, we could do the following. We'll put one of the elements at position C[key(A[i])] - 1, then destructively modify the C array by subtracting 1 from C[key(A[i])]. Then, when we see element A[j], we'll put it at position C[key(A[j])] - 1, which is an empty slot. Intuitively, the whole idea of having a cumulative frequency histogram is to be able to instantly know where to position objects by storing how many objects will come before any particular item with a given key. Every time we see an item with some key, we want to indicate that for any future item with the same key, there will be one fewer item coming before it.
So why scan backwards? We could just as easily have done a forward scan, but the advantage of a backwards scan is that it sorts elements stably. That is, if you have multiple elements with the same key, they'll all appear in the same relative order in the output sequence as they would in the input sequence.
Here's some code showing off how you can use this:
The loop is a bit weird due to counting down with unsigned values. This question details how to handle that properly.
",3,32223517
32177922,"

You can sort the matrix directly calling sort, no need for sortIdx before that.
You can conveniently take a submatrix (e.g. a single row) using Range.
You should specify a name when saving something with FileStorage.

The following example should clarify this:
Since you mentioned that you need to dump data for debugging, please refer to this question.
In short, you'll find Image Watch Visual Studio extension very useful.
",1,32175146
32173153,"
(Following up on the suggestion of HelloWorld to look into sorting networks.) 
It seems that a 29-comparison/swap network is the fastest way to do a 10-input sort. I used the network discovered by Waksman in 1969 for this example in Javascript, which should translate directly into C, as it's just a list of if statements, comparisons and swaps.


function sortNet10(data) {	// ten-input sorting network by Waksman, 1969
    var swap;
    if (data[0] > data[5]) { swap = data[0]; data[0] = data[5]; data[5] = swap; }
    if (data[1] > data[6]) { swap = data[1]; data[1] = data[6]; data[6] = swap; }
    if (data[2] > data[7]) { swap = data[2]; data[2] = data[7]; data[7] = swap; }
    if (data[3] > data[8]) { swap = data[3]; data[3] = data[8]; data[8] = swap; }
    if (data[4] > data[9]) { swap = data[4]; data[4] = data[9]; data[9] = swap; }
    if (data[0] > data[3]) { swap = data[0]; data[0] = data[3]; data[3] = swap; }
    if (data[5] > data[8]) { swap = data[5]; data[5] = data[8]; data[8] = swap; }
    if (data[1] > data[4]) { swap = data[1]; data[1] = data[4]; data[4] = swap; }
    if (data[6] > data[9]) { swap = data[6]; data[6] = data[9]; data[9] = swap; }
    if (data[0] > data[2]) { swap = data[0]; data[0] = data[2]; data[2] = swap; }
    if (data[3] > data[6]) { swap = data[3]; data[3] = data[6]; data[6] = swap; }
    if (data[7] > data[9]) { swap = data[7]; data[7] = data[9]; data[9] = swap; }
    if (data[0] > data[1]) { swap = data[0]; data[0] = data[1]; data[1] = swap; }
    if (data[2] > data[4]) { swap = data[2]; data[2] = data[4]; data[4] = swap; }
    if (data[5] > data[7]) { swap = data[5]; data[5] = data[7]; data[7] = swap; }
    if (data[8] > data[9]) { swap = data[8]; data[8] = data[9]; data[9] = swap; }
    if (data[1] > data[2]) { swap = data[1]; data[1] = data[2]; data[2] = swap; }
    if (data[3] > data[5]) { swap = data[3]; data[3] = data[5]; data[5] = swap; }
    if (data[4] > data[6]) { swap = data[4]; data[4] = data[6]; data[6] = swap; }
    if (data[7] > data[8]) { swap = data[7]; data[7] = data[8]; data[8] = swap; }
    if (data[1] > data[3]) { swap = data[1]; data[1] = data[3]; data[3] = swap; }
    if (data[4] > data[7]) { swap = data[4]; data[4] = data[7]; data[7] = swap; }
    if (data[2] > data[5]) { swap = data[2]; data[2] = data[5]; data[5] = swap; }
    if (data[6] > data[8]) { swap = data[6]; data[6] = data[8]; data[8] = swap; }
    if (data[2] > data[3]) { swap = data[2]; data[2] = data[3]; data[3] = swap; }
    if (data[4] > data[5]) { swap = data[4]; data[4] = data[5]; data[5] = swap; }
    if (data[6] > data[7]) { swap = data[6]; data[6] = data[7]; data[7] = swap; }
    if (data[3] > data[4]) { swap = data[3]; data[3] = data[4]; data[4] = swap; }
    if (data[5] > data[6]) { swap = data[5]; data[5] = data[6]; data[6] = swap; }
    return(data);
}

alert(sortNet10([5,7,1,8,4,3,6,9,2,0]));



Here's a graphical representation of the network, divided into independent phases.

To take advantage of parallel processing, the 5-4-3-4-4-4-3-2 grouping can be changed into a 4-4-4-4-4-4-3-2 grouping.
 
",209,32172144
32172160,"
When you deal with this fixed size take a look at Sorting Networks. These algorithms have a fixed runtime and are independent to their input. For your use-case you don't have such overhead that some sorting algorithms have.
Bitonic sort is an implementation of such network. This one works best with len(n) <= 32 on a CPU. On bigger inputs you could think of moving to a GPU.
https://en.wikipedia.org/wiki/Sorting_network
Btw, a good page to compare sorting algorithms is this one here (though its missing the bitonic sort.
http://www.sorting-algorithms.com
",87,32172144
32173433,"
Use a sorting network that has comparisons in groups of 4, so you can do it in SIMD registers.  A pair of packed min/max instructions implements a packed comparator function.  Sorry I don't have time right now to look for a page I remember seeing about this, but hopefully searching on SIMD or SSE sorting networks will turn something up.
x86 SSE does have packed-32bit-integer min and max instructions for vectors of four 32bit ints.  AVX2 (Haswell and later) have the same but for 256b vectors of 8 ints.  There are also efficient shuffle instructions.
If you have a lot of independent small sorts, it might be possible to do 4 or 8 sorts in parallel using vectors.  Esp. if you're choosing elements randomly (so the data to be sorted won't be contiguous in memory anyway), you can avoid shuffles and simply compare in the order you need.  10 registers to hold all the data from 4 (AVX2: 8) lists of 10 ints still leaves 6 regs for scratch space.
Vector sorting networks are less efficient if you also need to sort associated data.  In that case, the most efficient way seems to be to use a packed-compare to get a mask of which elements changed, and use that mask to blend vectors of (references to) associated data.
",33,32172144
32183266,"
What about an unrolled, branch-less selection sort?
http://coliru.stacked-crooked.com/a/71e18bc4f7fa18c6
The only relevant lines are the first two #define.
It uses two lists and entirely recheck the first one for ten times which would be a badly implemented selection sort, however it avoids branches and variable length loops, which may compensate with modern processors and such a small data set.

Benchmark
I benchmarked against the sorting network, and my code seems to be slower. However I tried to remove the unrolling and the copy. Running this code:
I am consistently getting better result for the branch-less selection sort compared to the sorting network.
",25,32172144
32266695,"
The question doesn't say that this is some kind of a web-based application.  The one thing that caught my eye was:

I'm sampling a data set of billions of elements and every time I need to pick 10 numbers out of it (simplified) and sort them (and make conclusions from the sorted 10 element list).

As a software and hardware engineer this absolutely screams ""FPGA"" to me.  I don't know what kind of conclusions you need to draw from the sorted set of numbers or where the data comes from but I know it would be almost trivial to process somewhere between one hundred million and a billion of these ""sort-and-analyze"" operations per second.  I've done FPGA-assisted DNA sequencing work in the past.  It is nearly impossible to beat the massive processing power of FPGA's when the problem is well suited for that type of a solution.
At some level the only limiting factor becomes how quickly you can shovel data into an FPGA and how quickly you can get it out.
As a point of reference, I designed a high performance real-time image processor that received 32 bit RGB image data at a rate of about 300 million pixels per second.  The data streamed through FIR filters, matrix multipliers, lookup tables, spatial edge detection blocks and a number of other operations before coming out the other end.  All of this on a relatively small Xilinx Virtex2 FPGA with internal clocking spanning from about 33MHz to, if I remember correctly, 400MHz.  Oh, yes, it also had a DDR2 controller implementation and ran two banks of DDR2 memory.
An FPGA can output a sort of ten 32 bit number on every clock transition while operating at hundreds of MHz.  There would be short delay at the start of the operation as the data fills the processing pipeline/s.  After that you should be able to get one result per clock.  Or more if the processing can be parallelized through replicating the sort-and-analyze pipeline.  The solution, in principle, is almost trivial.
The point is:  If the application isn't PC-bound and the data stream and processing is ""compatible"" with an FPGA solution (either stand-alone or as a co-processor card in the machine) there is no way you are going to be able to beat the attainable level of performance with software written in any language, regardless of the algorithm.
EDIT:
Just ran quick search and found a paper that might be of use to you.  It looks like it dates back to 2012.  You can do a LOT better in performance today (and  even back then).  Here it is:
Sorting Networks on FPGAs
",20,32172144
36209307,"
I recently wrote a little class that uses the Bose-Nelson algorithm to generate a sorting network on compile time. 
It can be used to create a very fast sort for 10 numbers.    
Note that instead of an if (compare) swap statement, we explicitly code out ternary operators for min and max. This is to help nudge the compiler into using branchless code.
Benchmarks
The following benchmarks are compiled with clang -O3 and ran on my mid-2012 macbook air.
Sorting random data
Comparing it with DarioP's code, here are the number of milliseconds taken to sort 1 million 32-bit int arrays of size 10:  
Hardcoded Sort Net 10         : 88.774 ms
Templated Bose-Nelson sort 10 : 27.815 ms
Using this templated approach, we can also generate sorting networks upon compile time for other number of elements. 
Time (in milliseconds) to sort 1 million arrays of various sizes.
The number of milliseconds for arrays of size 2, 4, 8 are 1.943, 8.655, 20.246 respectively.

Credits to Glenn Teitelbaum for the unrolled insertion sort.
Here are the average clocks per sort for small arrays of 6 elements. The benchmark code and examples can be found at this question:
Fastest sort of fixed length 6 int array 
It performs as fast as the fastest example in the question for 6 elements. 
Performance for sorting sorted data
Often, the input arrays may be already sorted or mostly sorted.
In such cases, insertion sort can be better choice.

You may want to choose an appropriate sorting algorithm depending on the data.
The code used for the benchmarks can be found here.
",8,32172144
32195665,"
Although a network sort has good odds of being fast on small arrays, sometimes you can't beat insertion sort if properly optimized. For example batch insert with 2 elements:
",5,32172144
37425193,"
You can fully unroll insertion sort
To make that easier, recursive templates can be used with no function overhead.  Since it already is a template, int can be a template parameter as well.  This also makes coding array sizes other than 10 trivial to create.
Note that to sort int x[10] the call is insert_sort<int, 9>::sort(x); since the class uses the index of the last item.   This could be wrapped, but that would be more code to read through. 
In my testing this was faster than the sorting network examples.
",3,32172144
44401952,"
For reasons similar to those that I described here, the following sorting functions, sort6_iterator() and sort10_iterator_local(), should perform well, where the sorting network was taken from here:
To call this function I passed it a std::vector iterator. 
",0,32172144
37950043,"
An insertion sort requires on average 29,6 comparisons to sort 10 inputs with a best case of 9 and a worst of 45 (given input that is in reverse order).
A {9,6,1} shellsort will require on average 25.5 comparisons to sort 10 inputs. Best case is 14 comparisons, worst is 34 and sorting a reversed input requires 22.
So using shellsort instead of insertion sort reduces the average case by 14%. Although the best case is increased by 56% the worst case is reduced by 24% which is significant in applications where keeping the worst case performance in check is important. The reverse case is reduced by 51%.
Since you seem to be familiar with insertion sort you can implement the algorithm as a sorting network for {9,6} and then tack on the insertion sort ({1}) after that:
",0,32172144
32168582,"
Edit1:
Here, we have 10 mybuckets vector each of them will hold input number(s) based on their Kth least significant digit in decimal. Where k will be vary from 1 to N(max number of digits in the given input).
What above code does is it extracts Kth least significant digit from the input and put's into the respective bucket in each iteration. After processing all numbers we take out these numbers from mybuckets and put back into the input array and start the process with (K+1)th least significant digit. We keep on doing this until there is no more least significant digit left in the given input numbers.
Note: This process will run for maximum number of digits time in the given input number(s)
As we have the maximum number of digits is 2 so this run for 2 iterations.
Check Radix sort in descending order for working code.
Edit2/3:
You can use any data structure only thing we have to care is that insertion in the respective bucket and retrieval from the bucket. Here we need to follow a strict rule for insertion and deletion in the bucket otherwise, you may get o/p in random order.
Others way to implement this.

Linked List 
  a) 2 Dimensional linked list 
  b) Array of 1 Dimensional linked list
Array 
  a) Array of dynamic size 1-D array
  b) 2-D dynamic array here (we have to deal with re-sizing of array) c) Use maxm size array ( 1-D or 2-D) 
  d) array from standard library
map from STL or implement your own Use [0-9] as key and value as
 a ) linked list 
 b ) vector or array pointer ( you may have to deal with insertion ) 
Hashing using bucket concept ( where key will be integer[0-9] and you have to map multiple values to same hash key )
Queue ( 2-d Queue or 1-D Queue )

e.t.c.
",0,32168184
32167721,"
What you're doing here is a counting sort and not a bucket sort. 
Now, to sort the elements in descending order, Change the 3rd for loop as follows:
",0,32167578
32167694,"
std::reverse(data, data + n) at the end,
or iterate bucket in descending order. (j = x - 1 to 0)
",0,32167578
32160005,"
",4,32159898
32160018,"
If your compiler does not support auto in lambda expressions then you have to specify the type of the vector elements explicitly for example using a typedef.
",1,32159898
32160023,"
I think you can use this link as a reference:


Use lambda and define what should be '>' when you get two objects from your vector.
",1,32159898
32153898,"
You can use the standard sorting algorithm, std::sort
The default (lexicographical) ordering will achieve exactly what you want.
",5,32153624
32154007,"
I may be missing something but I think a straight sort will work. Its a bit like binary numbers except with '(' and ')' instead of 1s and 0s.
Example Output:
",1,32153624
32152461,"
Using a std::unordered_set will be O(n).
",4,32152383
32155639,"
You can also try using std::nth_element: It partially sorts the range [first, n-th, last) such that all entries in the interval [first, n-th) are <= n-th, and all elements in the interval (n-th, last) are >= than n-th. It has linear complexity (O(n)), and will find the n-th element in a sequence. It's not suited to find a specific number, though, so maybe it's not exactly what you need. But it's worth to keep it in mind :-)
",0,32152383
32154342,"
If you know the maximum integer number, and it is reasonably small, you cann allocate a large vector and use that to count the frequency of each integer. Then, iterate over the vector and find all with frequency one:
In the worst case, this needs two iterations over arrays of the size of the input array, so the complexity is O(n).
This is essentially the idea behind Bucketsort or Radix.
",-1,32152383
32151389,"
For the series 1 4 3 2 6 5, you first swap 4 and 3 (one swap), then 4 and 2 (two swaps), then 6 and 5 (three swaps). That leaves you with the array like 1 3 2 4 5 6, so it's till not sorted completely, you will have another swap to get the 2 in its correct place, leading to four swaps (if the code works as it should).
",2,32151365
32151485,"
Removed previous answer.
You program does work correct; it should be 4. For this to work, I took of the unsigned long long and simply made it to int. Add the following code right after the swap variable becomes incremented and you will see exactly each swap occur.
Results:
Old array: 1 4 3 2 6 5 
Swap count 1: 
3 is swapped with 4; 
1 3 4 2 6 5 
Swap count 2: 
2 is swapped with 4; 
1 3 2 4 6 5 
Swap count 3: 
5 is swapped with 6; 
1 3 2 4 5 6 
Swap count 4: 
2 is swapped with 3; 
1 2 3 4 5 6 
Swaps: 4
New array: 1 2 3 4 5 6
I suggest next time you have a problem with something not working out right, you need to use cout statements in specific parts to make sure what the program is doing is being done right.
",0,32151365
32133232,"
To avoid duplicates you need to change your binary search range from [0,n] to [x+1,n]. Also once you find that a sum exists break out of the loop.
",1,32131820
32132124,"
If you don't want to return duplicate values don't keep searching from the beginning of the list.
Example:

Start your loop at the first item (1)
Now do your binary search on the rest of the items ({2,3,4,5})


Doing this will return the value 4

Second time around, the loop starts at 2


Binary search is done on {3,4,5}

etc

A problem arises in the case that you have duplicate items, so the list 
This will yield 2 results even with the method I've shown, if this is acceptable to you ignore the next part of this answer, otherwise you can eliminate this by using std::set.
When you get the list, you put it in a set. The set will automatically eliminate duplicates for you and then you can continue with the method I've shown above.
Note: std::set is implemented internally as a binary search tree, so you can also get rid of your quicksort and binary search implementations because std::set does both
",1,32131820
32109136,"
I recently came up with a solution for this based on this algorithm:
This is a slightly modified version for your data structure:
Output:
Please let me know if you find any bugs (not very well tested yet).
Added from the comments:

For efficiency, in production code, if the node type (string, in this
  example) can be imbued with a flag to mark the node as seen/sorted,
  then the calls to std::find can be replaced with setting the
  seen/sorted values for flag. Of course, in this example, Galik
  couldn't do that, which is why std::find is used, instead. - @Dess

",1,32108734
32109800,"
as you described in the question, each key in the map is a dependent node, and the value at that key is a list of nodes on which the dependent depends, or dependency.
So, the actual dependencies would something be like (say, dataset of the form 'from -> to'):

B -> A
C -> A
D -> A
F -> B
B -> C
F -> C
C -> D

The idea is to first find the starting point. A starting point would never be on ‘to’ side of an entry. Once we find the starting point, we can simply traverse the given set to print itinerary in order. Following are the steps.

Create a set of given pair of entries in the form shown above (Call this dataset). Every entry of 'dataset' is of the form ""from->to"".
Find the starting point of itinerary.

Create a reverse set. Let the reverse be 'reverseMap'. Entries of 'reverseMap' are of the form ""to->from"". Following is 'reverseMap' for above example.

Traverse 'dataset'.  For every key of dataset, check if it is there on the left hand side of the expression in the 'reverseMap'.  If a key is not present, then we found the starting point. In the above example, ""F"" is starting point.
Start from above found starting point and traverse the 'dataset' to print itinerary considering the following rule.

When we encounter a node which is present at multiple 'from' positions in the dataset, then check the frequency of all of its 'to' counterparts in the reverseMap on the left hand side of the expression and choose the one with the minimum frequency.

For example, when we start with ""F"" as the starting node, then we have two options in dataset to move forward with namely, ""F -> B"" and ""F -> C"". So, we check the frequencies of both ""C"" and ""B"" in the reverseMap in the left hand side of the expression, which turn out to be 2 and 1 respectively. So, we move forward with B's entry (F -> B), and discard the other entry (F -> C). This entry will never be required in future.


I hope this helps. Share with me, if you find any bugs, or have something to add to this.
",1,32108734
14297197,"
Comparing std::string -s like that will work. However you are comparing string literals. To do the comparison you want either initialize a std::string with them or use strcmp:
This is the c++ style solution to that.
Or alternatively:
EDIT(thanks to Konrad Rudolph's comment): in fact in the first version only one of the operands should be converted explicitly so:
Will again work as expected.
",21,32074445
14297432,"
You are comparing ""primitive"" strings, which are of type char const *.
The following is essentially equivalent to your example:
This is comparing the pointers (the memory addresses of the strings), not the contents.
@izomorphius has suggested some good solutions.
",2,32074445
32070849,"
I have written this code
As a result 
BUT you wanted the opposite result,just change WayToSort function,probably you can use .operator to separate two parts.
",-1,32069852
32058753,"
Assuming your goal is to sort an existing container, sort has a Compare comp argument that allows your to change its default behavior. To use it, you define a functor (a class that overrides operator()) that knows how you want your pointers to be compared. In this case, you want to define one that compares the common_data_1 that the pointed-to objects have.
Then, call sort on your list:
",0,32058631
32058908,"
I like @IanPudney's answer, though I typically use a lambda:
Replace common_data_1 with whatever data member or function you want to use to sort.
",0,32058631
32050689,"
You can create a boost::compute::buffer(cl_mem m);
It will take the buffer ownership by default (incrementing the ref). So you can just call clReleaseMemObject() on it after passing it. (Or if you are in C++, just let the destructor for cl::Buffer get rid of the reference).
But the real problem is that both contexts should be the same. So you need to set the context of boost to the same context you are using outside of boost. By using boost::compute::context(cl_context c);
Again, the ref counter will get incremented automatically, so you can keep using the conetext in the same way, and calling the same clReleaseContext().
After you have that done, you can just call normal boost functions to perform the sorting, etc..
",2,32034484
32026364,"
That's a fun one. I first tried to code the IMO correct approach, using a custom iterator that just skips elements that satisfy the predicate. This turned out to be quite challenging, at least writing that on a mobile phone as I'm doing it.
Basically, this should lead to code similar to what you can find in Eric Niebler's ranges v3.
But there's also the simpler, direct approach that you're trying to use above. The problem of your non working solution is, that it's changing the values the (rest of the sorted) iterators point to when assigning in that last for loop. This issue can be avoided by having a copy, like in my code:
Live example here. Forgot to fork before modifying, sorry.
(Instead of using copies at last for types that are using heap allocated data move should probably be used. Though I'm not sure whether you can assign to a moved from object.)
Using a ... rather weird ... wrapper class instead of the std::reference_wrapper makes it possible to achieve the filtered sorting without having to use a vector with (copied or moved) elements of the value type:
Upon construction this class stores a pointer to it's argument, which is also modified when the copy assignment operator is used. But when an instance is copy constructed, then a heap allocated copy of the referenced (by the other) value is made. This way, it's possible to swap two referenced values with code similar to
This was necessary because std::sort doesn't seem to use swap (found through ADL or std::swap) but code equivalent to the one above.
Now it's possible to sort a filtered ""view"" by filling a vector with (not copy constructed) instances of the weird wrapper class and sorting that vector. As the output in the example is showing, there's at most one heap allocated copy of a value type. Not counting the needed size for the pointers inside of the wrapper, this class enables filtered sorting with constant space overhead:
Finally, while this works quite well, I probably wouldn't use this in production code. I was especially surprised that std::sort wasn't using my own swap implementation, which led to this adventurous copy constructor.

You cannot generalise your code to work for sets and maps: Those are sorted by design, and they need that fixed order to function properly. And the unordered variants are, well, unordered and thus cannot maintain an order. But you can always (as long as you don't modify the container) use std::reference_wrappers inside of a vector to provide a sorted ""view"" of your data.
",1,32020784
32022870,"
Based on Beta's idea to sort using iterators, though I'm not sure what the time-complexity is.  It also does not work with all containers, e.g. std::set, std::map.
Error for set and map is ""Assignment of read-only location"".
Anyone know how to generalize this to work with sets and maps?
Update:  So I suggest for set, maps, etc..., simply remove those elements that satisfy pred and the create a new set/map/... with Compare as their key_compare type.  Like below.  But it is only for set.  How to generalize it to other containers that have key_compare types?
The test:
",0,32020784
31993023,"
At this point:
the size of a[] is unknown. It's an int *, for all intents and purposes. You need to calculate the known length of the array, and pass it in, e.g.
called as:
",2,31992939
31993243,"
When applied to an int[], sizeof(array[0]) becomes sizeof(int), but sizeof(array) becomes sizeof(int*) (which is the same as sizeof(int[])). Array length does not exist: you need to store it separately.
You should use the std::vector<> container and the std::sort function from the standard library.
By the way, the BubbleSort function, even if it had a valid value of len (say, as another function parameter), is wrong. Try sorting {4,3,2,1}: you need two nested loops.
",1,31992939
31993666,"
This function, and similar ones from your example:
are exactly equivalent to having defined them as:
You're just taking a pointer. You cannot determine the size of an array from just a pointer - there's insufficient information there. The C approach would be to additionally pass in the size everywhere:
But in C++, we can do one better by actually deducing the array size:
Though even better would be to use a std::vector, which will make pretty much everything easier to deal with:
",0,31992939
31991380,"
Your comparator isn't quite right, since you want it to return true if either the first check succeeds OR the first are equal and the second check succeeds. You only want to check the seconds if the firsts are equal. So something like this:
This can be simplified using the fact that tuples are lexicographically comparable:
",6,31991165
31991252,"
This is possible with a bit of tweaking to your predicate:
Live demo
",0,31991165
31991368,"
Your use of && doesn't really make sense.  It goes on to evaluate the second element if left.first > right.first, but really you want that to only happen if left.first == right.first.
This should work:
",0,31991165
31991377,"
You have to distinguish more cases:
",0,31991165
31991414,"
I think your predicate is wrong ?
If I understand correctly, you want precedence on the first element, and only in case of equality on the second element?
so maybe something like:
",0,31991165
31991578,"
Here you are
The program output is
",0,31991165
31991509,"
You want A to be before B if

A first is less than B first, or
If A first and B first are equal and B second is less than A second

In code that is
But this is suboptimal, from a programming point of view: Now you need an additional operator== implemented.
But since a value can only be less, equal or greater than another, you can rewrite that to
",0,31991165
32100400,"
I believe what I have to do is subclass the QSortFilterProxyModel and overload lessThan to do something like return sourceModel()->data(left).value<foo>() < sourceModel()->data(right).value<foo>();
",1,31975894
31939212,"

Is there a way around or is this the way it is?

I fear that this is the way it is. If you want to sort a vector, which is in principle an array, then you have to assign to elements when exchanging them.
At least that is what i thought, actually you can cheat a bit. Wrap your objects into an union:
You can then implement the (copy) assignment operator to first destruct the current object and then (copy) construct a new object from the provided inplace of the old object.
You also need to provide constructors and destructors, and of course this only works with C++11 and beyond due to limitations concerning the union members in previous language standards.
This seems to work quite nice: Live demo.
But still, I think you should first revisit some design choices, e.g. if the constant id really needs to be part of your objects 
",1,31937006
31938330,"

Is there a way around or is this the way it is?

So you want to update / swap the entire data of an object (including it's identity) and to keep the identity constant; the two are in conflict, because constant means ""doesn't change"" (and swap means ""change these instances"").
You have stumbled here on the two (competing) definitions of const-ness: conceptual const-ness (what the data says/means is the same) and binary const-ness (the bytes representing the data do not change). (The first definition is what lead to the introduction of mutable in the language: the ability to keep conceptual constness while breaking binary const-ness).
Your data here is conceptually constant (the interface to the data should be const) but not binary constant (you can swap values, so your bits may go away to another instance).
The canonical idea for this is to keep the data non-const internally, and provide only const public/protected access for client code.
You say:

However, I dislike the idea of the objects not having constant ids just for the requirement of rearranging their order within a vector.

Just because the identity is conceptually constant (exposed API is/should be constant), you have no actual hard requirement to keep the data constant (and should have no preference towards it, based on the API).
",0,31937006
31944153,"
One reasonably simple solution is to build a vector v of iterators into your lists, and sort that. Then, the ith element of v points to the elements in the lists that should occupy the ith position in the sorted lists, which you can rebuild. Performance might not be optimal, due to the use of the auxiliary containers, but it's easy to understand.
",2,31936576
31936704,"
The perfect STL-way to do it is to fill vector with std::pair and create custom comparator which compares only first element in pair. Then you will have sorted vector of pairs.
",2,31936576
31938505,"
The proper way to do it is to create an iterator class with something like std::pair<T1 &, T2 &> as it's value_type. It probably should contain an iterator on each sequence that is to be sorted, and properly propagate operations to them.
In fact, that's exactly what boost::zip_iterator does. I recommend using this with an appropriate comparator; or at least using boost::zip_iterator as an example of how it should work.
",2,31936576
31937324,"
OK, done. But it looks like (not too dirty) hack: in T tmp(std::move(lhs)); lhs = std::move(rhs); rhs = std::move(tmp); chain of std::swap implementation I make std::sort algorithm to perform only middle operation (both other are no-op):
I am sure modification for static_assert(std::is_const< first >{}); is evident (just change typename first::iterator to typename first::const_iterator and do std::swap(pfirst, p.pfirst); instead of std::iter_swap(pfirst, p.pfirst);).
",0,31936576
31930114,"
Because of rounding of double, slopeTo is inherently unstable.  So slopeCompare is unstable so sort using it is at best unstable and possible worse than unstable.
You can get much better results by comparing slopes by cross multiplying, rather than dividing.  But for large values that still isn't perfect.
Edit: On first look I missed the more serious bug:
That returns true for a==b when it needs to return false.
",4,31930044
31930107,"
Your comparison operator is invalid for std::stable_sort because it does not implement strict weak ordering.
With this logic, if 2 points a and b are the same, a<b will return true and b<a will also return true.
A valid comparison with strict weak ordering would be
",2,31930044
31930121,"
In your operator < for
You need
Personally I'd put some more parentheses in too. Also you could save some typing by defining operator >(a, b) as !(b < a).
",2,31930044
31905602,"
Vectors store and own data, they are not views into it.  A vector does not have a ""subvector"", as there are no other objects that own the vector's data.
You can copy data from your vector to another vector, but calling that a ""subvector"" is misleading.
The easiest solution is to rewrite your function to work with iterator start and finish instead of a container.  You can take your existing interface, and have it call the two-iterator version, to maintain the API.
The harder solution is to write an array_view<T> class that stores two T* and behaves like a range with the interface you want, including an implicit cast-from-vector.  Replace your const vector<int>&B and similarly C with a properly written array_view<int const> B, as well as your A, and (assuming no other errors in your code) you are done.
here is an array_view I have written.  here is one under the process of being added to std.
",2,31905522
31905613,"
The error you get here is that you are trying to bind a reference, but you are using the syntax for initializing a vector.
The correct way to obtain a sub-vector is
note the missing &. This, however, will make a copy of the given range, which is undesirable.
As advised in the comment above, change you function parameters to be the vector and a couple of indices, or (perhaps better) to be a couple of iterators.
",2,31905522
31906956,"
For this type of recursive functions, using a helper function would be more appropriate as illustrated below:
Then, you can call:
which will print 4 as expected.
",0,31905522
33178317,"
Do you really need to write your own quick sort?  If you don't the you could use std::sort with a custom compare functor.
",4,33178125
33165015,"
In your comparison you can change to the following in order to sort by length first, and if lengths are equal, sort alphabetically:
",2,33164936
33165075,"
You need to define a lessthan function which returns the correct comparison.
this can be used by std::sort, or made into an operator for your requirements
",1,33164936
33161685,"
omp parallel needs to see the loop it is going to parallelize.  The way you've declared it, omp will parallelize a single section of code which does not give any benefit.
Check your docs on omp parallel usage.
To do a for loop you need to use omp parallel for with the for statement following.  The way you have it now it will run your timsort on every core you have.
",1,33161666
33161801,"
think openMP is not smart enough as you think...
 if you want to do a parallel for gfx::timsort you can't do it from outside...
 you should add this code in function gfx::timsort
Beside, shared is a key word to instruct a variable you don't want it be edit paralleled
",0,33161666
33159620,"
You mixed up index and largest in maxHeapify function. In second ""if"" expression you should compare right_child with largest, not with index, because you need to pick a vertex with maximum value out of three vertices: index, left_child and right_child.
This is a corrected line of code will look like that:
",1,33159437
33157449,"
Your QuickSort implementation is pretty vanilla.  It does use random pivot selection, which ensures that there are no ""killer"" inputs that cause performance degredation, so that's better than the absolute basic QuickSort.
There are a number of optimizations that might be used, among them:

It is typical for ""Quick Sort"" to in fact be implemented as a hybrid sort that falls back to (say) Insertion Sort for partitions smaller than some fixed threshold.  Once you get to small partitions, the overhead of Quick Sort tends to overcome its asymptotic complexity advantages.
Maximum recursion depth can be minimized and function call overhead can be reduced by switching to a hybrid recursive / iterative approach, wherein upon each partitioning, the smaller sub-array is sorted recursively, but the code just loops to sort the larger one.
When partitioning, you can reduce the number of swaps performed by finding pairs of elements for which a swap puts both in the correct sub-partition, and swapping those, instead of alternating between swapping into one sub-partition and swapping into the other.
It would probably help to come up with a way to reuse the same random number source throughout the sort, instead of instantiating a new one upon every partitioning.

",3,33156994
33155465,"
In,
You are sorting layers by pointer values, not the contents of the objects.
You can create a custom functor/function that will do the right thing for sorting the objects by the values of the objects the pointers point to.
and use it in the call to sort:
",1,33155216
33146318,"
Simple, just extend your swap function with a piece of code that will check whether the location of the element to be swapped is adjacent to the location of 0:
An improvement would be to separate the check condition and inform the user in case when the element is not adjacent to 0.
",1,33145489
33145882,"
Rough Algorithm
1) create a function find location, it will return a structure Point that has x, y integer fields, it will find the x, y location of any piece based on the pieces value, i.e. lets say 0 is entered, if it is located in the top left corner (0,0), a point (0, 0) will be returned
2) create a function that takes in 2 points, the location of the '0' and the location of the piece we wish to swap lets call it S, if S.x = 0.x and 0.y - 1 = S.y or S.y - 0.y + 1 then you know that said piece is directly above or below the 0, now of course you have ot add a few conditions for boundaries so as we dont check outside the grid. Have this function return an int 1 if the piece S is located above/below/beside, 0 if not.
3) if 1 is returned your allowed to do the flip, if 0 is returned find another piece
",0,33145489
33145551,"
should be 
",1,33145419
33141522,"
Your two functions are big and clunky as is. Sometimes that's difficult to avoid, but combining them into one is not a good idea.
Instead try to figure out which logic is common to them and put that into individual functions that you can use from the get… and display… functions.
Also you should have a look at continue and break to break out of loops. Despite popular belief goto is a viable option to break out of multiple loop levels and can be used to simplify your code and make it shorter and easier to comprehend.
",1,33141336
33141575,"
There is some commonality and some big differences between those two functions. Which means that making one function to do both things is definitely not the right thing to do. 
Breaking out the COMMON functionality, and leave the overall logic in the functions as is. For example, writing a function that identify the rare digits in an integer would help your code, because you need that information in two different places, and you have loops to calculate that in both places.
",1,33141336
33143022,"
This isn't really an answer, because you shouldn't combine those functions.
Instead, you should factor the program differently.
This is my suggestion:
There are three places where you break a number down into separate digits, so this is clearly a job for a separate function.
It's easier to do this with strings, as we're not interested in what the digits are, only whether they're unique.
and if we store the data in a structure, we can carry the number of rare digits along with the number itself.
This way, we only need to compute the number once.
For sorting, a custom comparison operator is useful:
Everything else we need is provided by the standard library:
",0,33141336
33131349,"
You can use operators and functors:
So that you dont have to write down same operator content in every sort operation in your code.
with reference:
http://en.cppreference.com/w/cpp/algorithm/sort
and
C++ Functors - and their uses
",1,33131111
33132915,"
Alternatively, use the default sorting comparison: std::less<Edge>
E.g.:
Now
is already sorted
",1,33131111
33115721,"
You are stopping your merge loop to early. It currently stops when i is out of range or j is out of range, this leaves some values not copied into W, leading to uninitialized values in your output.
A simple way to fix this, is to copy the rest of the values after your main loop is finished. If the loop finished because i was out of range, you want to copy the rest of j, similarly if the loop finished because j was out of range, you want to copy the rest of i.
You can achieve this by adding loops after the main loop to ensure both i and j reach the end of their range:
put this before the final for loop that copies W into A.
Another alternative is to change the loop so that the condition is an || which will mean it will continue while either number is in range. You then have to test that a number is in range before you use it. There are a number of ways to do this, one simple way is to test it first:
",1,33115443
33117525,"
Alternate version that uses a flag (mtoa) to keep track of which direction to merge based on the level of recursion, to avoid copying of data. It also only checks for index out of range after incrementing an index in TopDownMerge(); I'm not sure if this make a significant performance difference.
",1,33115443
33095360,"
You can create a map with the digits 0 1 2 ... 9 as the key, and a pair of pointer to/index of integer containing the digit and number of occurrences of the digit in the integer as the value of the key-value pair. 
Start iterating on the integer list, extracting the digits and their number of occurrences from each integer. You can do that by either using the modulo operator, or using string functions (after converting the integer to string).
Now, for each integer, access the map of digits for all the digits in the integer, and if the value is uninitialised, update the value with the pointer/index to this integer and the number of occurrences of the digit in this integer. If the map entry is already populated, that means that it's not an ""unusual"" digit. So you can mark that map entry with a marker that conveys that this particular digit is not ""unusual"" and hence no need to update this entry.
After iterating over the entire integer list in this manner, you can iterate the map to find out which digits are unusual. You can also access the containing integer from the pointer/index in the value portion of the map's key-value pair. You can sort these entries easily using any sorting algorithm (since the number of values to be sorted is very small, no need to worry about time complexity, pick the easiest one) on the number of occurrences value. 
",1,33094887
33083283,"
So you want to generate an ""array"" that has N unique random numbers and they must be in a sorted order?  This sounds like a perfect use for a std::set.  When inserting elements into a set they are sorted for us automatically and a set can only contain unique elements so it takes care of checking if the random number has already been generated.
Then you can convert the set to something else like a std::vector or std::array if you don't want to keep it as a set.
",2,33081856
33082510,"
Here is a method to generate an ordered random sequence. This uses Knuth's algorithm S and taken from the book Programming Pearls.
This requires a function that returns a random double in the range [0,1). I included my_rand() as an example. I've also modified it to take an output iterator for the destination.
Demo in ideone.com
",1,33081856
33089364,"
OK, this I've decided to transfer the responsibility to built-in PRNG and do the follwing:
Add n",0,33081856
33084111,"
What about generating a sorted array from statistical properties ? 
This probably needs some digging but you should be able to generate the integers in order by adding a random difference whose mean is the standard deviation of your overall sample. 
That raises some problem at range boundaries, but given the size of your sample you can probably ignore it.
",0,33081856
33078631,"
This following line in your code: (in method bubbleDown)
shall be:
or simply:
Or, your bubbleDown method may become incorrect when there are duplicated elements in the data.
UPDATED: Just FYI that in your sample data of 299 integers, there are two 4313
",1,33077687
33068515,"
You are not swapping array elements, but basically you write the min/max values to the corresponding places within the array. Their old value is simply overwritten. You need to track the positions of the min/max elements and swap accordingly, e.g. swap(a[i], a[min_pos]). Additionally, you could run your outer loop up until the middle of the array is reached as you put two elements into their place on each iteration.
Here's the working code:
Note, you need to take care of 'special cases', e.g. when the min_pos and max_pos are at the ends of the interval - they would be swapped twice staying in their original positions.
",0,33068403
33056289,"
There are at least a couple of problems with your code.
First, you cannot define functions within other functions so you should take your sales_sorter function out of main. Second, you have a leak - you allocate your database but you never deallocate it. I'd replace that with either std::array or std::vector. For example instead of 
you will have
or 
Then you need to pass your container to the sort function:
This should get you started. 
",3,33056096
33049312,"
A priority queue will normally have a function to get the highest priority element.
To sort all the elements, all you need to do is pop the elements one by one, and they will be in sorted order.
Normally, a priority queue is implemented as a heap, and a sorting algorithm using a heap as a priority queue is called heapsort.
Since you haven't given your priority queue code, using the std::priority_queue as an example, here is how you would get a sorted list of elements:
",1,33049265
33043859,"
Here is one way:
Basically, you pass two additional arguments and check that current value lies within the range (min, max).
On left recursion, you change your max, on right recursion -- your min.
I'm passing pointers so that when it's NULL, there is no need to check.
Hope it helped.
",1,33043258
33043915,"
Here we are passing a variable, by reference, called prev. I have initialized prev with INT_MIN from the climits header file, or you could initialize it with a value smaller than all your BST values.
You can change your code accordingly from here.
Also you can check out this following link
Hope you got the idea.
",0,33043258
33023607,"
Okay, pencil-and-paper time. Your input is:
Your counts are determined correctly:
You then turn this into accumulated counts:
This step is also correct. What does this array represent? For each element a in A, C[a] is the index of the element after all as in the sorted array, B:
The same is true for the elements not in A: C[2] is 2. There is an (imaginary) block of zero twos after the ones the index after that block is 2.
Because the index is the index after the block, you must decrement your index before you use it:
Otherwise, you will write to index 4 eventually, when you treat the element 4, but that index is one beyond the limit of your array. (The numbers you saw were just garbage from uninitialised elements in B.)
By the way, decreasing first when counting down is a frequent thing in C, which is owed to the fact that upper bounds of arrays are exclusive. Your loop could have been written like this:
The update part is missing, because the decrement happens before the loop body is entered. And you get away without subtracting one in the initialisation.
",2,33021601
33007650,"
It appears that you are trying to do a bubble sort on your array in sort_array(), but the logic is wrong.  Try using this code instead:
",1,33007532
33007603,"
The problem is in your sorting. j is from 0 to 9, and than you access p[j+1] when j = 9, p[10] is outside your array boundaries.
So fix your following part to proper sorting.
Clarification: the code above is the problematic part of the original code posted. This is NOT the fixed sorting. That is the part to be fixed.
",0,33007532
33076808,"
the sorting works fine once i changed the limit of inner loop. the problem was accessing the array index [10] but i had it declared till index [9].
",0,33007532
32995865,"
Your problem lies in traverse.
I guess your intention is for the call to traverse to return the smallest number contained in the tree and to remove that value from the tree.
So that succesive calls return the members in increasing order.
But that is difficult to do with your structure since nodes contain middle values. Once a value is returned you would need to erase it but without erasing the right node.
Another problem is that the parameter node is not passed by reference (by reference to a pointer to be precise) thus the instruction node = NULL; has no effect in the tree.
Rather than fixing your traverse I'll instead go for an easier strategy. Fill the array in a single run of traverse. traverse will not return any element, instead it will receive a pointer to the array and store the elements there increasing the pointer as it goes.
Both your code and mine still have something left to do. To delete all dynamic memory once we are done with the tree. If you understand how my traverse works you should be able to do it yourself.
",1,32994787
32969444,"
The comments quote an ""as-if"" rule. That's actually not necessary. std::sort isn't specified ""as if introsort is used"". The specification for std::sort is brief and only requires an effect (sorted) and complexity (O(N log N)) for the number of comparisons. Radix sort meets both.

25.4.1.1 sort
template<class RandomAccessIterator> void sort(RandomAccessIterator first, RandomAccessIterator last);
template<class RandomAccessIterator, class
  Compare> void sort(RandomAccessIterator first, RandomAccessIterator
  last, Compare comp);
1 Effects: Sorts the elements in the range [first,last).
2 Requires: RandomAccessIterator shall satisfy the requirements of ValueSwappable (17.6.3.2). The type of *first shall satisfy the requirements of MoveConstructible (Table 20) and of MoveAssignable (Table 22).
3 Complexity: O(N log(N )) (where N == last - first) comparisons.

In practice, comparing two register-width values a<b is a much faster operation than extracting digits and comparing a sequence of those digits, even if we'd use bits or hexadecimal digits. Sure, it's a constant factor difference, but extracting and comparing 32 individual bits is going to be about 100x slower than a direct comparison. That beats most theoretical concerns, especially since log N can't really be 100 on todays computers.
",1,32966824
32958836,"
When shifting items down, start with the last item in the list and work your way up to the insertion point. Should be something along the lines of:
Better approaches are to have Student implement the < operator and use a std::set or std::priority_queue. Why reinvent the wheel?
",1,32958708
32955099,"
This will run, but you'll need to check it as I don't know what anything does.  Also your binary search function will need to be fixed, cause as it currently is it'll be dividing by odd numbers.  There are mistakes all over the place, I'll try and point them out in your original code. 
",0,32954022
32955177,"
i can't comment so i must answer in here.
Your code is sure long, so i will tell what i know at the first look.

You must declare all the function. you didn't call binary search function.
Your defined function and your prototype function is not the same. It's must be the same. For example: 
int foo (int a); // this is prototype
int foo (int a) // this is your defined function 
{
int b;
return b = a+5;
}
Few of your errors are unused variables, it's okay, but it makes your code complicate.
when you call function, you must call correctly. Take my example above, if i called a function, i will call:  cout << foo(5);// cout << foo; doesn't work.

Yeah, just fix those first, rest of it is just minor problems.
Make sure you understand what are use using from textbook. it's okay to use, but without understand it, you can't find the error.
",0,32954022
32955452,"
OK, I've commented bits of your code, things are all over the place. 
",0,32954022
32936054,"
If you want to sort just keys, then use a std::set.  It's a map without any ""values"".
Whether this is a good idea depends on your data set.  For small datasets this is perfectly reasonable.
",2,32935652
32935697,"
Maps are implemented with some flavors of  Balanced Binary Search Trees ( AVL, Red-Black Tree, etc).
No it won't be efficient to simply sort a set of values using maps, unless they have some kind of associations , there are several others sorting algorithms to do that, depends on your data sets, distributions, etc. 
Look into std::sort too
",1,32935652
32936048,"

to use std::map to sort a set of values by storing those values in
  keys and use some dummy literals for values associated with those
  keys?

I am not suggesting you do the above, but there is already a data structure for the usecase storing those values in keys 
It's called std::Set

What sorting algorithm does std::map uses?

Since it is implemented as a balanced binary search tree, The keys would already be sorted if you do a inorder traversal.
But there is no standard way to access the ""actual tree structure"" of an instance of std::map.
",1,32935652
32926396,"

lambda function - you can capture the index variable:

function - if you have
you can std::bind index to the third parameter:
Consider this solution inferior to lambdas, use it only when they're not available, or you'll be treated badly.

",1,32926310
32926368,"
You could capture index and use it within the lambda function:
",1,32926310
32686562,"
We don't know the type of conVec and info, but if the type of conVec's elements is char* or std::string, the first character of the string can be accesed by conVec[index][0].
",1,32686545
32686775,"
Use the std::sort function to help you out like this: 
and call it like 
This will work with either chars or std::strings, just set the type right. 
",0,32686545
32685925,"
I know eveyone is getting frustrated with your code but actually it is sorting, so cheer up. your only mistake is you are not resetting counter in each outer-loop iteration. This one works fine, check for loop header !
",2,32685729
32681438,"
v[i]>v[i+1], here i+1 may be v.size(), then you are accessing out of vector's boundary
",3,32681404
32655415,"

However, as you can see from the website's own visual, when the first partition is stopped, a '3' is still to the right of the chosen '7' pivot

Partition moves everything such that left <= 7 <= right, which the algorithm presented does:
The chosen pivot is not the array element 7, but the value 7.
Think of the pivot as a value, not as an element of the array. That is what the theory says, and the website you linked to says it too:

Choose a pivot value. We take the value of the middle element as pivot value, but it can be any value, which is in range of sorted values, even if it doesn't present in the array.

Choosing the value of an element is just a convenience. If you replace the ""|"" above with 7, the algorithm fits the theory.
Quicksort can also be implemented as left | pivot | right, for example see the first pseudocode on Wikipedia. It doesn't have to be though, and left <= pivot | pivot | right >= pivot is a subset of left <= pivot | right >= pivot. So if you do the first, you actually do the second as well.
",10,32655257
33635791,"
I recommend using a structure (class) and providing methods in the structure for input, output and comparison:  
By placing the input method into the structure you can do things like this:
",1,33635391
33633058,"
You can use std::inplace_merge, like this(c++11):
update
if you use threads, you can use such strategy:
let's say you have 4 threads, 4 threads sort 4 chunks of array,
then 2 of these 4 threads with std::inplace_merge merge 4 chunks into 2 chunks,
and then 1 of these 4 threads merge this two chunks into 1.
Also look at here:
http://en.cppreference.com/w/cpp/experimental/parallelism/existing#inplace_merge
and implentation  https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/parallel/quicksort.h
",0,33632766
33634368,"
If you must sort an array the absolute fastest utilising all possible hardware threads then you need to create a quicksort that can utilize multiple threads.
A lot of the Standard Template Library all work to perform a couple of functions, Quicksort being one of them.  When you call std::sort it's quite possible that you are calling something that looks like:
(credit to en.cppreference)
The main function here is std::partition. If you divide the partitioned range into blocks of equal size based on the number of threads you will end up with partially sorted range - all the elements that return true to the predicate will be before those that returned false.  It also crucially returns an iterator to that element - helpfully called middle in the above example.
By storing these returned iterators in an array you can then 
where swap_block looks like:
Using std::rotate is very inefficient for large blocks/those where mid is towards the end of the range.  In those cases it would be better to use std::reverse (and remember kids if you want a stable swap_block you would need 3 std::reverses!)
TL;DR: Learn to use the STL algorithm library effectively.
There is a version of parallel_partition that I have written here.
",0,33632766
33406481,"
Create a single array (or vector) of std::pair objects, where first is from the first array and second from the second. Then just use std::sort with a custom comparator function that uses only second from the pair for comparison. Iterate over the sorted array (or vector) and split up into the original arrays.
Note: If the values in each array are tightly coupled then consider putting them in a structure or class instead of using two (or more) distinct arrays.
",3,33406432
33406540,"

What I think is use std::map 
Assign array e element as the key
And corresponding array s element as the value.
Then sort the may by key
Go trough the map and get the values one by one

",1,33406432
33406582,"
If you do this in a class, you can create an array of indices and sort the indices according to the values in e[]. If not doing this within a class, and for a more general approach, create an array of pointers to e[], then sort the pointers according to e[]. Then reorder e[] and s[] according to the pointers, converting the the sorted pointers to an index by using array_of_pointers[i] - &e[0] (or just array_of_pointers[i]-e). You could write your own sort, or use qsort, std::sort, or std::stable sort to sort the array of pointers, with a compare function that compares using dereferenced pointers (compares the values pointed to). Example C code using qsort and reorder in place logic with O(n) time complexity:
",0,33406432
33407902,"
If you don't want to use other Data structures and stick with the two different integer arrays..
Following code snippet will help you
",0,33406432
33408897,"
It is quite simple when we use structure.Your basic task is to sort two arrays. I want to suggest one method regarding it. Use a structure having two variables x and y which are used here for two arrays. Make two array of objects of this structure.
After providing entries to the array of structure objects, make use of STL function 
where myfun is function to sort according to ur need and it is defined as
And here is the complete program in c++
",0,33406432
33406515,"
",-2,33406432
33382565,"
The proper way to do the sort is with std::list::sort as follows:
You can see that run here.
In your bubble sort, the reason your first element is not getting sorted is that as soon as you find an out-of-order element, you do this...
...then the ptr++ for-loop operation kicks in and your sorting therefore restarts at begin() + 1.  That cursor = ptr = omegaList.begin(); is pretty wild - first O(n^3) sort implementation I've ever seen.
",5,33382232
33380725,"
C++ provides you with sort which takes a comparison function. In your case with a vector<string> you'll be comparing two strings. The comparison function should return true if the first argument is smaller.
For our comparison function we'll want to find the first mismatched character between the strings after tolower has been applied. To do this we can use mismatch which takes a comparator between two characters returning true as long as they are equal:
To decide if the lhs is smaller than the rhs fed to mismatch we need to test 3 things:

Were the strings of unequal length
Was string lhs shorter
Or was the first mismatched char from lhs smaller than the first mismatched char from rhs

This evaluation can be performed by:
Ultimately, we'll want to wrap this up in a lambda and plug it back into sort as our comparator:
This will correctly sort vector<string> foo. You can see a live example here: http://ideone.com/BVgyD2
EDIT:
Just saw your question update. You can use sort with string array[] as well. You'll just need to call it like this: sort(array, array + length, ...
",3,33379846
33381422,"
Instead of the < operator, use a case-insensitive string comparison function.
C89/C99 provide strcoll (string collate), which does a locale-aware string comparison.  It's available in C++ as std::strcoll.  In some (most?) locales, like en_CA.UTF-8, A and a (and all accented forms of either) are in the same equivalence class.  I think strcoll only compares within an equivalence class as a tiebreak if the whole string is otherwise equal, which gives a very similar sort order to a case-insensitive compare.  Collation (at least in English locales on GNU/Linux) ignores some characters (like [).  So ls /usr/share | sort gives output like
I pipe through sort because ls does its own sorting, which isn't quite the same as sort's locale-based sorting.
If you want to sort some user-input arbitrary strings into an order that the user will see directly, locale-aware string comparison is usually what you want.  Strings that differ only in case or accents won't compare equal, so this won't work if you were using a stable sort and depending on case-differing strings to compare equal, but otherwise you get nice results.  Depending on the use-case, nicer than plain case-insensitive comparison.
FreeBSD's strcoll was and maybe still is case sensitive for locales other than POSIX (ASCII).  That forum post suggests that on most other systems it is not case senstive.
MSVC provides a _stricoll for case-insensitive collation, implying that its normal strcoll is case sensitive.  However, this might just mean that the fallback to comparing within an equivalence class doesn't happen.  Maybe someone can test the following example with MSVC.

output of gcc -DUSE_LOCALE -Og strcoll.c && ltrace ./a.out  (or run LANG=C ltrace a.out):
with gcc -Og -UUSE_LOCALE strcoll.c && ltrace ./a.out:

POSIX.1-2001 provides strcasecmp.  The POSIX spec says the results are ""unspecified"" for locales other than plain-ASCII, though, so I'm not sure whether common implementations handle utf-8 correctly or not.
See this post for portability issues with strcasecmp, e.g. to Windows.  See other answers on that question for other C++ ways of doing case-insensitive string compares.

Once you have a case-insensitive comparison function, you can use it with other sort algorithms, like C standard lib qsort, or c++ std::sort, instead of writing your own O(n^2) selection-sort.

As b.buchhold's answer points out, doing a case-insensitive comparison on the fly might be slower than converting everything to lowercase once, and sorting an array of indices.  The lowercase-version of each strings is needed many times.  std::strxfrm will transform a string so that strcmp on the result will give the same result as strcoll on the original string.
",1,33379846
41984635,"
I use this lambda function to sort a vectors of strings:
",1,33379846
33379975,"
You could call tolower on every character you compare. This is probably the easiest, yet not a great solution, becasue:

You look at every char multiple times so you'd call the method more often than necessary
You need extra care to handle wide-characters w.r.t to their encoding (UTF8 etc)

You could also replace the comparator by your own function. I.e. there will be some place where you compare something like stringone[i] < stringtwo[j] or charA < charB. change it to my_less_than(stringone[i], stringtwo[j]) and implement the exact ordering you want based.
another way would be to transform every string to lowercase once and create an array of pairs. then you base your comparisons on the lowercase value only, but you swap whole pairs so that your final strings will be in the right order as well.
finally, you can create an array with lowercase versions and sort this one. whenever you swap two elements in this one, you also swap in the original array.
note that all those proposals would still need proper handling of wide characters (if you need that at all)
",0,33379846
33391847,"
This solution is much simpler to understand than Jonathan Mee's and pretty inefficient, but for educational purpose could be fine:
if you have to use your sort function, you can use the same approach:
",0,33379846
46654975,"
",0,33379846
33374911,"
In an expression of the form left-condition && right-condition:

The left-condition is evaluated first;
What happens next depends on the result of the evaluation of the left-condition:


If the left-condition is true, the right-condition is evaluated in second. 
If the left-condition is false, the evaluation of the right-condition is skipped.


In your case, the problems lies with the expression (temp < ts[j]) && (j>=0) since it implements the following behavior:

You first use ts[j] in the left expression;
Then you test in the right-expression that j>=0, so that ts[j] would not be out-of-bounds.

The solution simply is to exchange the positions of these expressions and to write the expression as: (j >= 0 && temp < ts[j]).
",2,33373650
33369192,"
It is unspecified. If you want to preserve ordering of equivalent elements, use std::stable_sort.
",12,33369167
33356527,"
Well, if you compare C++ and Python versions line by line you will notice that this line 
in Python differs from C++.
Also your choice of pivot point seems weird.
",1,33356473
33324395,"
The overhead of creating threads is quite large, so unless you have a large amount (to be determined) of data to sort your better off sorting it in the main thread.
The mergeStep also counts against the part of the code that can't be palletized, remember Amdahl's law.
If you don't have a coarsening step as the last part of you sortStep when you get below 8-16 elements much of your performance will go up in function calls. The coarsening step will have to be done by a simpler sort, insertion sort or sorting network.
Unless you have a large enough sorting the actual timing could drown in measuring uncertainty.
",1,33324078
33333598,"
Any Binary Search Tree when traversed in Inorder results in a sorted array.
If you want to sort strings just compare it normally like you do with integers as c++ has all those functions in built.
And after you have successfully inserted the data. Apply Inorder traversal and you will get an alphabetically sorted array.
Just include
and then you can compare strings like normal data type[for eg. str1 > str2 ]
",0,33321772
33321262,"
The problem is that sort uses swap to rearrange the order and swap gets addresses to swap that points to the data used for sorting ie. a of type int&.
So here is a solution:
And it works! NOT!!!

Before:9 8 7 6 5 4 3 2 1
  19 18 17 16 15 14 13 12 11
  swap:8 9 7 6 5 4 3 2 1
  18 19 17 16 15 14 13 12 11
  After sort:1 2 3 4 5 6 7 8 9
  18 19 17 16 15 14 13 12 11

So sort uses std::swap or std::swap_iter instead of a local visible swap.
You will have to make your own sort as all the sorts known to me only take a cmp and not a swap as arguments. 
",0,33319169
33315722,"
You should not use the key parameter but the cmp parameter. https://wiki.python.org/moin/HowTo/Sorting#The_Old_Way_Using_the_cmp_Parameter
",1,33315649
33314682,"
Since you are sorting a vector of pointers, but the operator applies to a struct, C++ ignores your operator < overload.
You can supply a custom comparer that calls your operator <, like this
or code the comparison straight into the lambda, and drop the unused overload of <, like this:
",6,33314653
33314774,"
Easiest way to do this is to use lambdas:
",0,33314653
33313960,"
I can only do this in a quiet fussy way since I turn string to char* and finally turn char* to string again. In my view,The string classes of the C++ standard library enable you to use strings as normal types that cause no problems for the user. Thus, you can copy, assign, and compare strings as fundamental types without worrying or bothering about whether there is enough memory or for how long the internal memory is valid. However,that also means we can only use interfaces and can't do whatever we want to do.You know,string based on the basic template class basic_string<> and looks like container more than char*.
",2,33313029
33313937,"
the simplest way to let the user enter the size of array and then sort and print the result on screen is by using STD approach like this 
",1,33313029
33313074,"
So you don't have what we call spaghetti code, you can put sort in a function. It's good practice.
",0,33313029
33310922,"
This line
causes all the elements to move right, not just the ones that should move.
You need
",1,33310814
33319374,"
You mentioned that the size of the array was always known to be 23. Moreover, the type used is unsigned short. In this case, you might try to use a sorting network of size 23; since your type is unsigned short, sorting the whole array with a sorting network might be even faster than partially sorting it with std::nth_element. Here is a very straightforward C++14 implementation of a sorting network of size 23 with 118 compare-exchange units, as described by Using Symmetry and Evolutionary Search to Minimize Sorting Networks:
The swap_if utility function compares two parameters x and y with the predicate compare and swaps them if compare(y, x). My example uses a a generic swap_if function, but you can used an optimized version if you known that you will be comparing unsigned short values with operator< anyway (you might not need such a function if your compiler recognizes and optimizes the compare-exchange, but unfortunately, not all compilers do that - I am using g++5.2 with -O3 and I still need the following function for performance):
Now, just to make sure that it is indeed faster, I decided to time std::nth_element when required to partial sort only the first 10 elements vs. sorting the whole 23 elements with the sorting network (1000000 times with different shuffled arrays). Here is what I get:
That said, my computer has been running for a bit of time and is a bit slow, but the difference in performance is neat. I believe that this difference will remain the same when I restart my computer. I may try it later and let you know.
Regarding how these times were generated, I used a modified version of this benchmark from my cpp-sort library. The original sorting network and swap_if functions come from there as well, so you can be sure that they have been tested more than once :)
EDIT: here are the results now that I have restarted my computer. The network_sort23 version is still two times faster than std::nth_element:
EDIT²: if all you need in the median, you can trivially delete the compare-exchange units that are not needed to compute the final value that will be at the 11th position. The resulting median-finding network of size 23 that follows uses a different size-23 sorting network than the previous one, and it yields slightly better results:
There are probably smarter ways to generate median-finding networks, but I don't think that extensive research has been done on the subject. Therefore, it's probably the best method you can use as of now. The result isn't awesome but it still uses 104 compare-exchange units instead of 118.
",12,33307957
33325864,"
General idea
Looking at source code of std::nth_element in MSVC2013, it seems that cases of N <= 32 are solved by insertion sort. It means that STL implementors realized that doing randomized partitions would be slower despite better asymptotics for that sizes.
One of the ways to improve performance is to optimize sorting algorithm. @Morwenn's answer shows how to sort 23 elements with a sorting network, which is known to be one of the fastest ways to sort  small constant-sized arrays.
I'll investigate the other way, which is to calculate median without sorting algorithm. In fact, I won't permute the input array at all.
Since we are talking about small arrays, we need to implement some O(N^2) algorithm in the simplest way possible. Ideally, it should have no branches at all, or only well-predictable branches. Also, simple structure of the algorithm could allow us to vectorize it, further improving its performance.
Algorithm
I have decided to follow the counting method, which was used here to accelerate small linear search. First of all, suppose that all the elements are different. Choose any element of the array: number of elements less than it defines its position in the sorted array. We can iterate over all elements, and for each of them calculate number of elements less than it. If the sorted index has desired value, we can stop the algorithm.
Unfortunately, there may be equal elements in general case. We'll have to make our algorithm significantly slower and more complex to handle them. Instead of calculating the unique sorted index of an element, we can calculate interval of possible sorted indices for it. For any element, it is enough to count number of elements less than it (L) and number of elements equal to it (E), then sorted index fits range [L, L+R). If this interval contains desired sorted index (i.e. N/2), then we can stop the algorithm and return the considered element.
Vectorization
The constructed algorithm has only one branch, which is rather predictable: it fails in all cases, except for the only case when we stop the algorithm. The algorithm is easy to vectorize using 8 elements per SSE register. Since we'll have to access some elements after the last one, I'll assume that the input array is padded with max=2^15-1 values up to 24 or 32 elements.
The first way is to vectorize inner loop by j. In this case inner loop would be executed only 3 times, but two 8-wide reductions must be done after it is finished. They eat more time than the inner loop itself. As a result, such a vectorization is not very efficient.
The second way is to vectorize outer loop by i. In this case we process 8 elements x = arr[i] at once. For each pack, we compare it with each element arr[j] in inner loop. After the inner loop we perform vectorized range check for the whole pack of 8 elements. If any of them succeeds, we determine exact number with simple scalar code (it eats little time anyway).
Here we see _mm_set1_epi16 intrinsic in the innermost loop. GCC seems to have some performance issues with it. Anyway, it is eating time on each innermost iteration, which can be reduced if we process 8 elements at once in the innermost loop too. In such case we can do one vectorized load and 14 unpack instructions to obtain vAll for eight elements. Also, we'll have to write compare-and-count code for eight elements in loop body, so it acts as 8x unrolling too. The resulting code is the fastest one, a link to it can be found below.
Comparison
I have benchmarked various solutions on Ivy Bridge 3.4 Ghz processor. Below you can see total computation time for 2^23 ~= 8M calls in seconds (the first number). Second number is checksum of results.
Results on MSVC 2013 x64 (/O2):
Results on MinGW GCC 4.8.3 x64 (-O3 -msse4):
As you see, the proposed vectorized algorithm for 23 16-bit elements is a bit faster than sorting-based approach (BTW, on an older CPU I see only 5% time difference).
If you can guarantee that all elements are different, you can simplify the algorithm, making it even faster.
The full code of all algorithms is available here, including all the testing code.
",4,33307957
33318730,"
I found this problem interesting, so I tried all the algorithms I could think of. Here are the results:
I think we can conclude, that you where already using the fastest
algorithm. Boy was I wrong. However, if you can accept an approximate answer,
there are probably faster ways, such as median of medians.
If you are interested, the source is here.
",2,33307957
33308698,"
A simple way to sort a std::bitset would be to convert it to a std::string using std::bitset::to_string and then use std::strings operator< to compare the bitsets.
Live Example
As pointed out in the comments if the bitset is small enough to fit into a unsigned long long then you can use std::bitset::to_ullong and compare the unsigned long longs instead of strings.
",7,33302286
33283801,"
It sounds to me like the first vector is a red herring and this would do:
A more stable variant in the presence of modifications to vector1 is to store indexes instead of pointers:
",1,33283628
33274871,"
If your data is in
then you cannot sort ""the pointers"" because that data structure has no pointers at all... just 100*30 = 3000 characters one after another.
Therefore to do the sorting you will need to actually move around the 100 rows will all their content.
std::sort cannot be used directly because the data structure is an array of arrays, and arrays are in C++ second-class citizens (for example you cannot assign an array to another).
",5,33274534
33274959,"
std::sort requires that its iterator type parameter must be:

ValueSwappable and RandomAccessIterator.

The type of dereferenced iterator type must meet the requirements of:

MoveAssignable and MoveConstructible.

Unfortunately, arrays are not swappable (i.e., you cannot assign one to the other). Consequently, you can't use std::sort with arrays.
What you can do is use std::array<std::array<char, N>, M> in the following manner:
LIVE DEMO
Impovements to code thanks to @Jarod42
",2,33274534
33275030,"
As already mentioned, arrays can't be assigned. Structures can be assigned, so this might be close to what you want. The array of structures might be padded for alignment. In the case of Visual Studio 2015, the array of structures was not padded, so the memory layout was the same as a 2d array.
update - changed to using references for compare parameters and switched to strnlen as suggested by Jarod42.
",1,33274534
33274950,"
You can try this:
",0,33274534
33272064,"
The immediate problem - causing the SIGTRAP - is your comparison operator:
It's implemented as ""! <"", which is >=, so returns true for equal elements.  An operator< must never return true for equal elements if it's to be used by std::sort.  Requirements are summarised here.
You could instead say return power > oth.pomer.
Note that file.good() works correctly in your case, as after parsing the final 72 value there's no whitespace and extraction of that int will be terminated by eof, affecting the stream state.  It's damned fragile though, as is the idea that because the stream state is good at any point in time, you can presume that future streaming operations work.  It's better to test the stream state's still good at some point before trusting the variables you've attempted to stream into, especially if you're doing something like resize followed by array indexing.
Example of more robust I/O:
",2,33271792
33271960,"
Your problem stems from using while (file.good()), which is virtually always an error (and is in this case).
This doesn't detect the end of file correct, and ends up writing the last item to the vector twice--but you've only made room for it to be written there once, so this writes past the end of the allocated space.
When the sort attempts to work with the data on the now-corrupted heap, you start to see the problem.
The correction is fairly trivial: read the data correctly, such as:
One final note: your comparison function works the reverse of what most people expect. It will also fail (completely) if you end up with a NaN in the pomer field of your struct (NaN's don't follow a strict weak ordering, as required by the comparison operator for std::sort).
",2,33271792
33271963,"
Ok, the problem was veci[i].pomer = c / (v+1); assigning to float variable divison of two ints, thus solution is to use pomer = float(c) / (v+1).
Still, i think that the original code should just sort incorrectly. I dont understand why it fails completely, especially on vector's desctrutor... Anybody?
//edit: i dont know why it works now. But problem would be probably with the stream as @Jerry Coffin answered. I will react later.
",0,33271792
33203731,"
Well all you need to do is adjust the next and prev members of both, as well as sync up the links from previous & next elements of those:
Alternatively: if you simply want to swap values at a particular logical position in the list then you can also simply exchange the values:
",1,33203610
33196120,"
const A *a means ""pointer to const A, and that means the object pointed at by a cannot be modified via a. sort modifies the elements of the iteration range passed to it. Since these elements are owned by the object pointed at by a, they cannot be modified via a.
So, you cannot call sort the vector a->vec. You need to find a different approach.
",2,33195972
33193116,"
If tournament style is a must, a recursive approach seems the most appropriate:
EDIT: Code is untested and errors might have slipped in, since it's been typed on the Android app.
EDIT: Forgot to say how you call this method. Like so:
EDIT: Or create another overload:
And to call use just:
EDIT: And here's non-recursive method (bare in mind that this method actually modifies the array):
",1,33192762
33192866,"
There are various simple solutions that utilize functions set up in C#:
Alternatively this will loop with a foreach through all of your values.
1 - What tree are you talking about? Your array has n values to start with, so it will have n values max. If you mean the number of values in all the arrays you will create is 2n-1, it still doesn't mean you need to fit all of these in 1 array, create an array, use it and then create another array. C# GC will collect Objects of a reference type that have no pointers (are not going to be used again) so it will be fine memory wise if that's your concern?
2 - Post your code. There are a few gotchas but likely you will be fine changing the current array values or creating a new array. Temp int will not be needed.
3 - The above posted algos are the ""simplest"" using built in functions available to C#. If this is a homework assignment, please post some code.
As a general direction, using a recursive function would likely be most elegant (and some general reading on merge sorts would prove useful to you going forward).
",0,33192762
33190417,"
The example top down merge sort divide() function just keeps calling itself until the sub-array size is reduced to a size of 1, in which case a sub-array of size 1 can be considered sorted. Only then does any actual merging begin, starting just after divide(arr,0,0) and divide(arr,1,1) return after doing nothing. numbersSort() then merges arr[0] and arr[1], and it returns. The next merge occurs just after divide(arr,2,2) and divide(arr,3,3), merging arr[2] and arr[3]. Then after that return, arr[0 1] and arr[2 3] are merged, resulting in a sorted array of 4 integers. Note that all divide does is generate pairs of indexes (low, high), numbersSort() is where the actual merging of data is done.
In general, top down merge sort is a depth first, left first sort. The non-iterative bottom up merge sort skips all the recursion used to generate indexes and just starts off by merging by even and odd indexes, merging [0] with [1], [2] with [3], [4] with [5], ... . Then on the next pass it merges runs of size 2, [0 1] with [2 3], [4 5] with [6 7], ... and so on until the array is merged.
Passing a temp array of the same size as the array to be sorted can be used to eliminate have to create, copy, and delete working arrays during a merge sort.
Example showing top down merge sort order of operation:
Example showing bottom up merge sort order of operation:
",0,33187711
33188199,"

Then how is it work for divide and numberSort() function?

Execution in a given function doesn't stop when you call another function, it just pauses until that function returns. So imagine you're currently executing divide(arr,0,1). low is still less than high, so you enter the condition and call divide(arr,0,0), which does whatever it needs to do (hint: try not to worry about what it does just now), and then you call divide(arr,1,1) which again does it's thing and returns. Next, you call numbersSort(arr,0,0,1), which recombines the two sections of the array, and the result is that the array is sorted from index 0 to index 1.
Good so far? Okay, well, next you just return. And it happens that the divide(arr,0,1) call we just talked about was invoked by a divide(arr,0,2) call, so when divide(arr,0,1) returns, execution of divide(arr,0,2) continues from the point just after the divide(arr,0,1). So the next thing to happen will be a divide(arr,2,2) call, right? 2 is not less than 2, so that just returns right away as well, and then you hit the numbersSort(arr,0,1,2), which combines the two sections of the array (i.e. 0 through 1, and 2 through 2) into a properly sorted array from 0 to 2. Now the array is sorted from index 0 through index 2.
But, of course, that divide(arr,0,2) was called in the context of a divide(arr,0,4) call, so when the divide(arr,0,2) returns the next thing that happens is divide(arr,3,4). Let's assume that that does the right thing and sorts the array from index 3 to index 4. And then you get to the numbersSort(arr,0,2,4), which combines the two parts of the array and returns to whatever function called divide(arr,0,4).
It can definitely be tough to get your head around recursion at first. Keep at it -- it'll click eventually. If you can step through the code for a small-ish example in a debugger, that might help you see what's going on. Also, working through the code on paper can help. Try not to get bogged down with understanding how it works at every level all at once, but instead look for what happens at a single level and trust that calls to any functions (even recursive calls) just do the right thing.
",1,33187711
33183883,"
I've figured this one out.
To find the last violator in a list that has descended at one point, you must initialize a new flag and set it to change AFTER the first violator is found.
In my example above, the condition that element1 == 0 should be false after the first violator is found. Once that condition has failed, there needs to be a else statement that changes the new flag to something other than one and a new element2 variable that changes the index number every time a violator is found.
",0,33182813
33979094,"
Well coming forward with this, mainly left that comment to be able to find this question faster on my laptop.
Like I said in the comment, if you want a presorted, by key value 2D ""array"", the quickest manner in which you could do this is with the map container., and if you really need the internal points to be ordered, and you will be using multiple entries within it, lets say entries 2,30 2,12 ... You could either build a map of vectors, or arrays, or use a Multimap. Not too sure of this data structure, as I have never really had a reason to use it as of yet.  Referenced here http://www.cplusplus.com/reference/map/multimap/
The above will provide you with the sorting done for you, and the reason why I recommended a vector is the lack of order within it, and not sure if the 'bursts?' are to be ordered as well. 
EDIT:
Forgot to mention, that a map will not hold more than one key of any given value, so if you are, again, inputting multiple points a above, then you will. if implementing things as you were before, overwrite things.
EDIT:
So this is more or less the fix I think I have, but you are working around this in a very indirect manner, that is hard to follow honestly. 
This fixes the insertion point, just because you give it an array it does not mean that the program will take that as a pair, as the first index is a point to another array in itself. And so on. I recommend starting off wiht a map object instead, as the multimap makes things a bit annoying, if you are familiar with the vector containers then use that instead within the map to log multiple values. 
",1,33979010
33975336,"
Your compare() function is a non-static member function which requires three parameters: in addition to the entities you want to compare it also requires the object which is pointed to by this. The trivial fix is to make the member static or turn it into a non-member function entirely.
However, you are better off using a comparator object with an inline function call operator if your objective is to obtain good performance: the call through a function pointer can generally not be inlined while an inline function call operator is trivial to inline.
",1,33975262
33974673,"
(strcmp(names[k],names[k-1]) < 0) && (k > 0) is wrong.  The correct form is
 (k > 0) && (strcmp(names[k],names[k-1]) < 0)
The sequence matters because names[k-1] is unsafe to read when k is zero.  && always computes its left operand first and only computes its right operand when the left is true
",2,33974613
33963722,"
You are trying to pass an object of type sortFcts as the predicate parameter of std::stable_sort(). Objects are type sortFcts are not callable, though. There are two simple fixes:

The simpler [and recommended] fix is to just get the fonc member of the object:

Make objects of type sortFcts callable as a predicate by adding a suitable function call operator:


",0,33963198
3761148,"
From section 12.8 of the standard:
 13 The implicitly-defined copy assignment operator for class X performs memberwise assignment of its subobjects. The
direct base classes of X are assigned first, in the order of their declaration in the base-specifier-list, and then the immediate
non-static data members of X are assigned, in the order in which they were declared in the class definition. Each subobject
is assigned in the manner appropriate to its type:
— if the subobject is of class type, the copy assignment operator for the class is used (as if by explicit qualification;
that is, ignoring any possible virtual overriding functions in more derived classes);
",7,33954082
3761092,"
operator= is not inherited. Your code is meaningless in C++, so compilers are free to issue any error they want for it.
From the KB article you pointed to: http://support.microsoft.com/kb/130486

Since operator= is not inherited, any declaration of operator= in the base class is unused and unnecessary. Do not declare the operator= in the base class.

It's probably just a side-effect of how they compile, and they are just letting you know that they don't consider it a bug, so there is no need to fix it.  ""By design"" doesn't necessarily mean that they specifically decided that this linker error is the right error message to give for this situation -- the code is wrong, you get an error, so from their point of view -- they're done.
",7,33954082
3761142,"
In the example code:
the line aB2 = aB1 does not call const A& B::operator=(const A&), but instead calls the automatically supplied B& operator=(const B&); which in turn uses the assignment operator for assigning the base portion of the class. But when it comes to linking, it turns out that that was never implemented.
",2,33954082
33949578,"
There are several problems in the posted code.
First, the function passed to std::sort has to be callable with two arguments of the type being sorted. PossiblePlate::sortDescendingByNumberOfChars is a non-static member function, so it has to be called on an object of type PossiblePlate, with two additional arguments. std::sort can't cope with that. Make it a static member function.
Second, PossiblePlate.cpp defines a free function named sortDescendingByNumberOfChars; that's okay, but it's not the member function. Change its declaration from sortDescendingByNumberOfChars to PossiblePlate::sortDescendingByNumberOfChars to define the member function.
Third, follow the advice in the error message. To take the address of a member function, the correct syntax is &ClassName::FunctionName. The call in the code does not have the &.
",4,33949465
33940867,"
Your sorting code does just the same thing as
taking 9 times longer.
You will have to exchange the loops of x and y.
Or to do it more efficiently, try this:
",1,33940809
33941769,"
I have found a problem just in sorting the numbers. So you need to learn bubble sort first. I have changed a little in your code. Just see as follows:
now give the inputs 9,8,7,6,5,4,3,2,1,0 and it works..
",1,33940809
33941792,"
In the inner loop of the loops you are comparing and swapping pancakes[x] and pancakes[x + 1] instead of to compare and swap pancakes[y] and pancakes[y + 1].
I think it is just a typo.
Nevertheless I'd like to point out that it is not a good idea to use magic 
numbers like 9. Also there is a tradition to use names i, j, k, l, m, and n as indices.
As for the algorithm itself then it could be stopped when the array is already sorted.
Take into account that you could use standard function std::swap to swap the elements of the array.
I will show such an approach when the loops stop iterate when the array is already sorted
If to enter for example
then you will get
If you want to keep the relation between a person and eaten pancakes by the person then you should declare an array of pairs.
Here is a demonstrative program
For the same input as above its sorted output will look like
",0,33940809
33938947,"
You could trade off additional O(n) preprocessing time to get amortized O(1) query time, using a hash table (e.g. an unordered_map) to create a lookup table.
Hash tables compute hash functions of the keys and do not compare the keys themselves.
Two keys could have the same hash, resulting in a collision, explaining why it's not guaranteed that every separate operation is constant time. Amortized constant time means that if you carry out k operations that took time t in total, then the quotient t/k = O(1), for a sufficiently large k.
Live example:
This requires additional memory also.
If the values can be mapped to integers and are within a reasonable range (i.e. max-min = O(n)), you could simply use a vector as a lookup table instead of unordered_map. With the benefit of guaranteed constant query time.
See also this answer to ""C++ get index of element of array by value"", for a more detailed discussion, including an empirical comparison of linear, binary and hash index lookup.
Update
If the interface of type T supports no other operations than bool operator<(L, R), then using the decision tree model you can prove a lower bound for comparison-based search algorithms to be Ω(log n).
",1,33936076
33936509,"
You can use std::lower_bound. It does it with log(n)+1 comparisons, which is the best possible complexity for your problem.
With the additionnal check for equality, you do it with log(n)+2 comparisons.
",0,33936076
33946112,"
You can use interpolation search in log log n time if your numbers are normally distributed. If they have some other distribution, you can modify this to take your distribution into account, though I don't know which distributions yield log log time. 
https://en.wikipedia.org/wiki/Interpolation_search
",0,33936076
33908266,"
You have 3 mistakes:

As mentioned by @Lukasz P. in the comment, int* ptr should point to the array arr, int* ptr = arr;
You access out of bounds for the last element (when j = 8)
You need to keep sorting until there are no more swaps:


",2,33908158
33903083,"
Operator new should be used to allocate memory. For dealloaction use delete.
Start from allocation the memory:
    int * dynArr = NULL; // pointer to work with dynamic array
    dynArr = new int[MAX_NUM]; // allocation of memory

Then check that memory was allocated, like:
    if( dynArr != NULL )
    {
        // do something
    }
    else
    {
        // report about problem and do not use pointer
    }

And use function for copying elements, e.g.:
void reversCopy(const int * source, int * destination, int number)
// Function for copying numbers from one array (memory) to other 
// in the revers order (first element goes to the last position).
// source - pointer to array where numbers will be read
// destination - pointer to array where numbers will be written
// number - number of elements to be copyed
{ 
    for(int i = 0; i < number; i++)
    {
        destination[i] = source[number - 1 - i];
    }
}

Eventually, free dymanic memory with operator:
and do not use dynArr after that.
",0,33903026
33903259,"
Dynamic memory management should be done using the C++ standard classes and concepts as available with either smart pointers or containers.
Using C++ language correctly doesn't require you to use new/delete for most of the use cases you actually need to cover.
",5,33903026
33894908,"
Since 
is a member function of your class, you can can access your array by replacing 
by
or better just use this->a instead of sp
You cannot use the syntax :
because your array is not a static attribute.
",2,33894660
33893791,"
It's much easier to sort items when they are grouped into some structure.
",3,33892630
33893553,"
Arrays do not have the copy assignment operator. So you need to change the data structure used to store your data.
Here is shown an approch with using the standard data structure std::array
The program output is
If you want to sort the array in the descending order then the call of the std::sort will look like
If your compiler does not support auto in lambda expressions than you have to spesify the type of the parameters explicitly
Also you could consider to use an array of std::tuple
Of course instead of an array of objects of std::array or type std::tuple you could use standard class std::vector.
",2,33892630
33894067,"
You goal : sort the records (I mean one line is one record) by the 4th column . so the next step is how to represent the every record , obviously,
you need a combination type to represent the record;for example : (pseudo code)
class Record{
    //成员变量
    char *name;
    int age;
    int date;
    float score;
    Record(){/* constructure */}
    ~Record(){/* distructure*/}
    //成员函数
    void sort(/*arguments*/){/*bubble sort . selection sort . quick sort*/}
};
The next method is not advisable：
In 2 dimensions array, one record is one dimension array, example, arr[0][0] arr[0][1] arr[0][2] arr[0][3] represent first record, at the same time, arr[0] represent string[4] ! Are you have any inspiration ? follow is pseudo code:
void bubble_sort(string ** array, int first_dimension_length, int sort_column){
    string mini = ""2100000000"";
    int mini_row = 0;
    string * swap = NULL; 
    for(int i = 0; i < first_dimension_length; ++i){
        for(int j = i + 1; i < first_dimension_length; ++j){
            if(mini > array[j][sort_column]){
                mini = array[j][sort_column];
                mini_row = i;
            }
        }
        swap = array[i]; 
        // swap point to one dimension array, that's swap is a pointer
        array[i] = array[mini_row]; 
        //array[i] also point to one dimension array
        array[mini_row] = swap; 
        //array[mini] also point to one dimension array
    }
}
In a word , first method deserved your try;
",0,33892630
33887230,"
It would be nice if the code worked as is. It makes sense to certain degree. However, C++ is not that easy.
You cannot into the std::map this way. Elements of std::map are instances of std::pair<std::string, int> but your input iterator provides only std::string items.
This is actually good enough. You do not need the previous copy.
Sorting an std::map does not make any sense. It is sorted by its key. You will have to copy the map elsewhere, like into an std::vector.
It is not possible to print out the std::map this way. There is no overload for printing std::pair<>. You basically need an ordinary loop or for_each() and do the printing manually.

Here is fixed code (Coliru link):
",1,33886875
33874512,"
Well if the list is sorted then:
min is first element
max is last element
sum is add all the elements together
average (assuming you mean mean) is sum / number of elements in the list
",3,33874475
33874766,"
With or without sorting, you could use the brute force method:
Edit 1:
To save some time, you can perform these calculations, the minimum, maximum, sum and quantity, while you are inserting into the list.  
Which brings up the idea that a list is unnecessary unless you are going to process the values after the average is calculated.
",0,33874475
33847683,"
In this case, std::set uses !(a < b) && !(b < a) to determine equality of two elements: a and b.
!(false) && !(false) will be yielding true everytime, when checking for duplicates, thus not allowing std::set to contain more than one element. This is a mistreatment of std::set.
",2,33847601
33847732,"
The comparision function needs to define a strict weak order on the elements. That is, these three conditions need to hold for all elements, a, b, c:

a < a is false (irreflexitivity)
a < b being true implies b < a is false (asymmetry)
a < b and b < c both true implies a < c is also true (transitivity)

When using a comparator object cmp the conditions above need to apply with x < y replaced with cmp(x, y).
Your first comparison function (always returning false) is actually a strict weak order, however, one which implies that all elements are equivalent. There is no way to distinguish between two elements. In particular, neither a < b nor b < a yields true. If both of these conditions are false the two objects clearly are equivalent. As a result, only one element is in the set.
The second comparison function (always return true) is not a strict weak order as it violates the first condition (irreflexitity). Whatever happens in the set is undefined behavior.
",7,33847601
33838509,"
strcpy_s() uses 3 parameters (at least with Visual Studio). The middle parameter is the size of the destination buffer. I don't know why you're not getting an error. You can use strcpy() instead of strcpy_s(), or add the size parameter.
Only 5 if swap statements are needed:
",0,33838148
33837946,"
The issue is using a[pivot] rather than setting pivot = a[left + (right - left)/2]. Your version with this fix:
Standard Hoare partition scheme, although your version works fine with the pivot fix:
",3,33837737
33834867,"
Strings are compared by their letters in order. Let's take a moment to remember that strings, at the end of the day, are characters arrays, and let's remember too that characters have a numerical value by themselves, ranging from lowercase 'a' to uppercase 'Z', 'a' being the lowest value in the alphabet and uppercase Z being the highest. So, behind the curtains, when comparing two strings with comparing operators, you are putting against each other two numerical values, if they happen to be the same, then the comparison is taken to the next letter in their string. For example, ""dog"" would be put first than ""doll"" if you are sorting lowest to highest.
Now, for the sorting, I would recommend you to look up for sorting methods in data structures, or try to come up with one yourself knowing how strings compare.
",-1,33834655
33835038,"
Use std::sort (2nd version) and write a comparison function that compares characters alphabetically rather than lexicographically.  If this has to deal with i18n/l10n then this function might be more difficult to write.
",1,33834655
33834818,"
First of all, please do not ask people to do your homework here on SO. However, since you've already got most of the program down, I'll give you a few tips:
Firstly you need to read in the strings, and store them in some way:

Strings (Decent method)
Arrays (Probably should avoid these)
Vectors (Much better alternative to arrays)

Now you can either use the built-in function std::sort (but I guess you're not allowed to use it as this is homework) or write a sort function on your own.
Think about how to search a string/array/vector for a specific letter in the alphabet (Googling 'c++ search string' would give you a few methods) and consider the effects of uppercase, lowercase and punctuation.
The main problem is that there's no way for a computer to see if a letter comes 'before' another - see if you can find a way to convert from a character to a number (hint: use casting in conjunction with an ASCII table).
That's all the info I'm gonna give, good luck!
EDIT: A few words on sorting methods
There are a few main sorting methods:

Bubblesort - Go through the string in order, swapping letters that
are in the wrong order. Repeat this over and over until the string is
sorted
Insertion sort - For each letter, put it in a new array/string/vector in the correct place
Quicksort - Split the string in two, compare the halves, swap portions and repeat

",0,33834655
33817880,"
Assuming this is Hoare partition scheme, and that median3 can handle length of 1 more elements. Changes from original noted in comments. Comments described as ""same logic as original"" are just cosmetic changes, there's no change in the logic of the code for these lines from the original example above. It's possible that the if(left+10 <= right) and the j = right-1 are the only real errors, but this example follows the typical Hoare partition scheme style.
A working implementation of quicksort can be tricky, since a minor error may only fail for specific patterns which may never get tested.
example median3
minimal change to original example to typical Hoare partition scheme style.
",2,33817560
33798378,"
Since listSort is vector of pointers, you need to align sorted function (and friend declaration) to accept pointers as arguments, like this:
and it will work.
friend declaration should look like this:
",0,33798284
33798894,"
My preference goes to overloading the operator< so that you will be able to compare 2 pass objects(if you do not need this operator for anything else). By doing this, your call to sort won't need the last argument for comparison, which I find nicer.
As for the rest, the other answers should solve your compilation issues.
",-1,33798284
33788156,"
I´ll answer myself because I found the issue and the solution could help someone else.
I´m building a rendering engine and I´m using two threads to draw the scene and update it. The draw loop runs at 60 fps while the update loop runs at 500 fps.
The camera position is updated in the update loop (faster) and this sorting happens in the draw loop. Being the update loop much faster, sometimes (rarely) happens that the camera position changes in the middle of the vectort sort. This code fixes th issue
Basically I´m capturing a copy of the camera position into the lambda to be sure it does not change during the sort
",0,33786518
33771353,"
My psychic debugging skills tell me that not only does your input have many duplicates, but the duplicate elements are consecutive, which makes the input mostly sorted to start with. A mostly sorted container is quick sort's worst case, with performance degrading to as poorly as O(n^2).
For mostly ordered input other sorts like heap sort and merge sort will offer better performance since their worst case is simply a higher constant on their average case.
",3,33771144
33772673,"
The example quicksort code below is similar to the example code in the question, but it takes less time if there are more duplicates, and is fastest if the data is already sorted or reverse sorted. The main difference is the usage of a modified Hoare partition scheme (dynamic pivot) and a median of 3 to choose the initial pivot. There should still be patterns that cause worst case performance, but I'm not sure what those patterns would be.
http://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme
",1,33771144
33782333,"
Normally, I do recommend you use the std library sort, partial_sort, nth_element, etc.  as suggested in the other answers.
However, it is not difficult to find a min, and avoid sort and avoid duplicating the vector, 
AND 
in case you really mean it when you asked for:

i need a simplest for loop or while statement to find the 10
  smallest value in the vector without sorting?.

Here is one approach:  (See comment ""find 10 smallest values"" below)
Results: (randomized shuffle)

update - what happens when a value in the smallest 10 is duplicated:
I added 
re-ran the code (so, this is a different random shuffle), output is:

update - how might we modify this code to reveal the index's of the smallest 10 unique values
Note: not run tested, and this 1st attempt code (probably) does not correctly handle the 100 element array with less than 10 unique values
",0,33758453
33758593,"
Check this example:
Output:
It uses std::partial_sort (as Jarod42 said), which sorts the first n values (the 10 in your case), while leaving the other values in any order. Now you can sure modify that to meed your needs.
",0,33758453
33759026,"
Actually, given that you only need to know the 10 smallest items (and don't need those ten in order) you can use std::nth_element instead of std::partial_sort. This does precisely what you've asked for with nothing extra, so it stands a good chance of being more efficient.
As far as avoiding copying your input, you could create a vector of indices that you use to index into the original array, and operate on the index instead of the original array.
The general idea would look something like this:
You could, of course, use a vector of pointers to the original items instead of indices, but you said you needed the ""row numbers"", so I wrote the code to provide exactly that.
",0,33758453
33761185,"
If you need to code this yourself, use quick select to find the 10th smallest element. This will separate the array into parts, the left with smallest to 9th smallest on the left but not sorted, the 10th smallest as the pivot, and the right with elements >= 10th smallest element. Wiki article:
http://en.wikipedia.org/wiki/Quickselect
",0,33758453
33747316,"
You are clocking only the call to quicksort, which would isolate the time difference to only the work of sorting the already-generated numbers.
The runtime of quicksort varies based on its input. Quicksort runs in O(n**2) in the worst case. O(n log n) on average. For instance, if a quicksort implementation were to select the first available element as pivot, then the worst case scenario would be to give it an already-sorted array because more swaps would be needed.
You are getting differences in timings because your inputs are different, not because you are generating the numbers in a function vs inline. Your generator uses the same seed in both programs, but you are using a different distribution (1,1000) vs (1,10000) -- which will lead to a completely different set of ints.
A smaller spread in your uniform distribution will reduce entropy in your array (e.g., there will be more duplicate values), which will affect the number of swaps you have to do to get the array sorted completely. The initial relative ordering in your array will affect how many times integers will have to shift around your chosen pivots.
The layout of your generated numbers in memory is the same in both cases (one linear array), and the program's footprint is small enough that we can safely rule out code cache misses as causing a difference in runtime inside the quicksort call. Your total runtime will be affected by the number of memory compares and swaps you're doing (and the few cache misses you're incurring -- you have 4MiB of numbers to sort, it isn't much). I assume the code in both quicksort()s is the same. 
Edit: 
To illustrate the problem, you can modify your program as follows:
for(int i = 0;i < 999999;++i)
  arr[i] = i; //u(e);

to drop the random generation altogether. this makes your quicksort algorithm work on an already sorted array -- and it is a worst case.
On my system, trying a few runs of the version where the numbers are generated inside a function completes within 1 to 2 seconds (as it is show in the external code link), whereas using the sorted version completes in a far longer amount of time. Sorting an already-sorted array of numbers from 0 to 100000 (instead of one million) alone takes over 15 seconds.
(edit: both stable/unstable algorithms are affected by duplicates. thanks @rcgldr )
",3,33747125
33748605,"
The issue is the partition method used in the linked to example. It's using a Lomuto like partition scheme, instead of a Hoare partition scheme. I tested using Visual C / C++ express 2010 release build, and the results were even worse, 0.1 second for 1->10000, 2.7 seconds for 1->100.
In the example code below, I used a Hoare partition scheme combined with a median of three for pivot, and the time improves with more duplicates or ordered data.
On my system, Intel 2600K, 3.4ghz, using Visual C / C++ express 2010 release build, sorting 10,000,000 integers. This variation of quicksort took 0.531 seconds with distribution 1->10000, 0.469 with 1->1000, 0.375 with 1->100, and 0.109 with already sorted data. clock() is based on 64hz ticker, so times +/- 0.015625 seconds.
",1,33747125
33738843,"
The most efficient way depends on how you will use this container.
If you want keep strings sorted while you inserting/deleting them, then most efficient way is std::unordered_map<std::size_t, set<string> >.
However, if it is possible to collect all the data and then sort all strings, then the most efficient way is to use std::unordered_map<std::size_t, vector<string> >.
",1,33738157
33735557,"
In STL algorithms that take ranges, if you want to provide the whole range you have to give as ending an element one-past-the-end and not the end of the range itself, thus in your case:
Or
Or even better:
",6,33735529
33735565,"
You have 3 values in array, but send only 2 (since in STL algorithms second parameter is past-end iterator).
Should be
",2,33735529
33733877,"
Using recursion mergeLists() is the issue, it will call itself for every node on the list. Try changing the code so that the code loops and appends nodes to the initially empty mergeList, using a second pointer to node, or optionally a pointer to pointer to node which is initially set to &mergeList. For example, using the name pMerge instead of mergeList:
Here is example code of a fast method to sort a linked list using an array of pointers to lists aList[], where aList[i] points to a list of size 2 to the power i, that makes use of mergeLists().
",0,33732551
33728959,"
Create another array/vector that contains the indices to the first array.
Then sort indices such that:
After that, given an index i, you can find the element in arr using arr[indices[i]].
",1,33728891
33729718,"
While you already have an answer for C++, continuing from the comment, and for sake of completeness, a similar C solution using an array of pointers could look similar to the following:
a-Sorted Output Maintaing Relationship
",0,33728891
33726470,"
You need a functor for comparison and give it to sort as the third parameter:
http://www.cplusplus.com/forum/general/59164/
",5,33726418
33726506,"
The std::sort function sorts correctly, but it only does what you tell it to do. 
It sorts the elements in mainList. The 2 most common mistakes are:

You sort mainList, but print a different copy of mainList.
You sort based on another criteria than you intended. This will happen if mainList isn't a container of Item but instead a different type, like  Item* or std::shared_ptr<Item>.

These are just guesses, but without a complete example of  your problem we cannot do more than provide very general answers.
",2,33726418
33726496,"
It's been awhile since I used any built in sorting but I think your comparator may be different than you intend.
Try telling sort to use the greater than
http://en.cppreference.com/w/cpp/algorithm/sort
",0,33726418
33726260,"
Your code is completely random. So it can swap when it should not. An easy fix would be to swap only if you need it.
Your array probably will not be sorted immediately, so you could also test if it is sorted only every five steps (for example) instead of every step.
But i think the most important is, you should not expect good performances from such an algorithm.
",5,33726150
33720808,"
Use an unorder_set to find unique the values, then put these unique values into a vector and sort them; and then put originals into an unorder_multiset to count the values, something like:
",1,33720312
33721015,"
According to wiki (see the comparison table of algorithms), we should use counting sort because we have not so much different values.
First, I supposed that our values are ints 0-100, and used the following code:
This code took 0.149s on my computer versus 3.002s used by std::sort.
This is a classic implementation of counting sort, but now try to speed up it, removing some excessive calculations:
This gives approximately 0.076s.
Secondly, given that our values are not ints 0-100, I use the following algorithm:

Find all 101 different numbers (considering uniform distribution).
Sort these numbers.
Lookup each of our 100000000 numbers in this array when performing counting sort.

Unfortunately, at the moment I have no time to implement this and check, but I'm sure the answer is out there.
",1,33720312
34578303,"
In addition to Sergey's answer, you could run the count in parallel using multiple threads, which speeds up the process at least 2 times.
So instead of:
we could spawn multiple threads that all do a part of the work (using Windows threading for demonstrational purposes only):
Where PartialResult and partial_count is:
Above code leads to execution time of 390ms instead of 860ms on my setup and could be improved by also aggregating the partial counts in parallel.
",1,33720312
34574991,"
Here is the full implementation of the algorithm described by some other users above.
Total algorithm complexity is O(n).
Main function to test speed:
Program output from my notebook (compiled by MSVC 2013 Update 5 for x86_64, ran on Core i7-4700MQ CPU @ 2.40GHz):
There are a number of magic and half-magic optimizations to get this result:

Use of own trivial hash function: -50%
Use 100 as multiplier for hashtable bucket count: -50%
Compile as x64 instead of 32bit code (x86): -25%
Use C++11 foreach instead of equivalent with iterators: -33%

",1,33720312
33720937,"
I believe that for this task counting sort is the most suitable.
However, if all that you need is just to print sorted list of integers as quickly as possible, consider not saving integers at all - but only their counters in map.
",0,33720312
33718436,"
You're computing your percentageLeft and percentageRight outside your loop.  Those values never change as you are swapping things.
You probably want them as the first line inside your for loop.
Because the first two don't need to be swapped, it thinks none of the elements ever need to be swapped.  If the first two DID need to be swapped, your program would run forever, as the if statement if(percentageLeft > percentageRight) would always be true and swap would always be set to true leading to an infinite loop.
",0,33718411
33717792,"
The main error you have is that you are giving wrong values to static_cast<>. Later you use them correctly by dereferencing, but in the cast you are missing that.
What you need is:
Added parentheses to make it explicitly clear what the dereferencing is.
Also if you are not changing the actual array pointers, but only the contents of the arrays, you can remove the dereferencing hassle altogether. If you define the function as
you can just use the normal indexing without dereferencing every time you use it.
",1,33717748
33717943,"
I propose using the STL for sorting. Makes things simpler and more understandable.
Dealing with raw arrays and sorting manually is almost always the more tedious and error prone approach.
See http://en.cppreference.com/w/cpp/algorithm/sort and http://en.cppreference.com/w/cpp/container/vector for reference
",2,33717748
33717788,"
You said:

I have a program with 2 ""paired"" integer arrays newNumerator[ ], and newDenominator[ ]

Yet your function defined as:
I think that should be:
If that is indeed the case, then the lines:
need to be:
",1,33717748
33724174,"
First, here is wrong:
you lost content of vec[pivot], after that here if (vec[i] <= vec[start]) you
order your vector by value of vec[start], then pivot is start, then why the hell,
you set pivot to  (start + end) / 2;? And as you use in compare NOT saved
value, but reread it from vec[start], which can be changed by swap operation in vector. And after all you order against start, but your index increased in ordering cycle for (int i = start + 1; i <= end; i++), so after iteration you
have (of course if previous bugs was fixed):
{pivot, sub array <= pivot, sub array > pivot}, so you need instead of just swap if do index from end to start + 1 you need move  sub array <= pivot to  start and insert pivot between,
so the right solution if reuse as much your code is possible will be:
Note: I use c++11(initializer_list), but only for testing, so without tests you can reuse c++98 or c++03
",1,33717365
33705140,"
vector of structs. Supply a specialized function for comparison that gets called during sort.
the specialized compare function shall compare based on income (descending order)
the first top 5 elements from sorted vector should give your answer
",0,33705092
33706165,"
If you just want the top 5 (and don't need them in order) you can use std::nth_element to find them. This is normally faster than sorting.
If you do want the top 5 in order, you could use std::partial_sort to do the job, something like this:
Note that I've swapped the two parameters when comparing them to get it to sort in descending order instead of ascending.
I don't see a very good way to use the index field you've put into the structure. To work very well, you'd want the index separate from the data you're sorting, and you'd do an indirect sort on the indexes (that is, you'd sort the indexes based on the income for the item at that index).
",0,33705092
33694310,"

Sort to ascending order of the name.
If the names compared are same, element with higher score should be come to earlier position of the array.
Print the first element and elements whose name differs from previous element.

Sample implementation:
",0,33694006
33694868,"
You've already done the difficult part. 
Suppose the ((first, last), score) pairs are already sorted, the highest score for each player is the first record for this player, so just keep the current player's name as curr_name when you visit the array:

If the next name is same as curr_name, you can safely ignore this item. 
If not, print this record, and update curr_name.

The code is like blew:
",0,33694006
33694238,"
As pointed out before, since it's a task I decided to rewrite the code and it should now look like this.

Sort the array based on the score
Sort the array based on alphabetical order
Print unique entries


",0,33694006
34373840,"
If this is C++, you should encapsulate the number and the name in your struct and overload the comparison operators for your class. like this:
now you can use std::sort from #include <algorithm>  to sort all of your objects that you put in a container such as std::vector.
the gist of the solution is you are letting std::sort know how to compare 2 different instances of your struct. when std::sort knows this, it can do the sorting for you. 
going the array route is very messy and not recommended.
if you are interested in making your own sorting algorithm or practicing insertion sort, merge sort, quicksort, etc. then you can still use the overloaded operators > < == <= and >=  to write your own sorting algorithm. 
",0,34373769
34373890,"
If both of the numbers are same you just have to take their names and then apply this algorithm
",0,34373769
34373897,"
Your code is a bit of a minefield, but you can achieve what you want with something like this:
This works because std::pair already overloads operator< and sorts by the first, and then then second element. If you don't want to use std::pair, you can overload operator< for your own class.
",0,34373769
34348686,"
std::map is sorted, and involves O(log n) cost for each insertion and lookup, so the total cost in the ""no duplicates"" case (or in the ""first duplicate near the end of the vector"" case) would have similar big-O to sorting and scanning: O(n log n); it's typically fragmented in memory, so overhead could easily be higher than that of an optimized std::sort.
It would appear much faster if duplicates were common though; if you usually find a duplicate in the first 10 elements, it doesn't matter if the input has 10,000 elements, because the map doesn't have time to grow before you hit a duplicate and duck out. It's just that a test that only works well when it succeeds is not a very good test for general usage (if duplicates are that common, the test seems a bit silly); you want good performance in both the contains duplicate and doesn't contain duplicate cases.
If you're looking to compare approaches with meaningfully different algorithmic complexity, try using std::unordered_set to replace your map-based solution (insert returns whether the key already existed as well, so you reduce work from one lookup followed by one insert to just one combined insert and lookup on each loop), which has average case O(1) insertion and lookup, for O(n) duplicate checking complexity.
FYI, another approach that would be O(n log n) but use a sort-like strategy that shortcuts when a duplicate is found early, would be to make a heap with std::make_heap (O(n) work), then repeatedly pop_heap (O(log n) per pop) from the heap and compare to the heap's .front(); if the value you just popped and the front are the same, you've got a duplicate and can exit immediately. You could also use the priority_queue adapter to simplify this into a single container, instead of manually using the utility functions on a std::vector or the like.
",2,34348611
34344149,"
You should compare number part and then string part on equal number part.
",2,34343898
34344013,"
You problem is the way you are comparing the strings.
Is just giving you the ending number from the string.  So any string ending in 1 will come before any other string.  This is why the right and left cameras file names are getting mixed together and in no particular order.  What you need to do is compare the number part and if that is equal then compare the string part.  If not then just compare the number part.
",3,34343898
34336467,"
You could do
In your while loop you could add:
Now you can sort by name like this
or by vintage like this
The sorting can be demonstrated like:
output:
",3,34336125
34336500,"
You want a struct to store your data, something like:
and then in your loop:
",1,34336125
34333409,"
sizeof(Log::a) / sizeof(Log::a[0]);
This does not get the number of elements in Log::a! It gets the size (in bytes) of the std::vector type, which has nothing to do with the number of contained elements, then divides by the size of an element. This gives you some garbage.
This idiom is for arrays, and std::size is better, but not standard yet - you can easily write it yourself like this:
(There are more convoluted versions if you need it as a compile time constant.)
Use Log::a.size(); to get the size of a std::vector.
(I may be missing other problems, but this one stands out.)
",0,34333016
34332063,"
@interjay the queues need to be sorted individualy , with the use of a 3rd assisting queue which is used when queue1 or queue2 is sorted. The queues must not be sorted at the same time because this will require 2 assisting queues
",0,34318504
34305634,"
Notice how a loop is used to extract n values from user. Also using a std::vector relieves you from writing code for a runtime sized array with new and delete.
Also, you inner loop was checking i<n-i-1 and incrementing j which should be j<n-i-1 instead, otherwise j will increment indefinitely till INT_MAX.
",3,34305477
34305988,"
The key word is dynamic allocation. In C, the function is malloc. In Cpp, it can be new and delete. Although a vector can work well, it is just a kind of method by STL. Notice that my code may have safe problem.
",3,34305477
34306104,"
You can't take an integer array like that, you need to run a loop. You can take a string like that. There are lot of errors in the bubble sort logic as well, try the below code snippet. It should work fine. You need to dynamically allocate the array for arr
Includes : #include<stdlib.h>
",1,34305477
34305714,"
As mentioned in my comment, you CANNOT dynamically declare the size of arrays in C++ (use std::vector if you are willing to achieve that).
You can then do this:
",0,34305477
34301003,"
Selection Sort:
The selection sort starts in the outer loop with the last value in the array. It then goes through the whole array with the inner loop and finds the largest value, assigning its index to the startIndex variable. It then replaces the last value, index i, with this startIndex value which is the largest in the array. It then repeats this process for all values in the array. Notice that in the inner loop, j<=i makes it slightly more efficient than j<=array_size-1. This is because, once the last index is assigned during the first iteration of the outer loop as the largest variable, nothing needs to be tested against that as everything left will be smaller than it. As i gets smaller and smaller, all the indexes above it have already been assigned the largest values in ascending order.
Bubble Sort:
The outer for loop takes the last value in the array and then iterates down to the first value. For each iteration of the outer loop, the inner loop is testing each pair of numbers, starting from the first and second, then going up until it reaches the index that the outer loop is at and the index at one less than that. For each iteration of the inner loop, the pair is being compared and if the value at the lesser index is smaller, it will switch with the value one index above it (so it is sorting in ascending order). The outer loop is really unnecessary, it just makes the loop more efficient. The idea behind it is that once the first iteration of the inner loop has run, the last value has to be the largest, which is what it should be, so that can then be ignored when running the sort for each resultant iteration. It continues this process until it gets to the last pair and sorts them accordingly.
",3,34300745
34281732,"
Since rand_ints is of type int, you probably mean reinterpret_cast<char *>(&rand_ints) (note the &).  Otherwise, you'll be making a pointer out of an integral value.
OTOH, trying to read two adjacent integers into the address of a single integer variable is very likely to cause problems.
Looking more deeply into your sorting algorithm, it seems to me that you attempted to generalize it for data elements of any size, and not just ints.  However, it is still clearly array-oriented; if you wanted to deal with files, you probably have to pass the function either a filename or a fstream reference.
Also, unless you're required to use Bubble Sort, I'd strongly advise you against it, especially for on-disk sorting, unless you make sure your data set is very, very small (say, no more than a hundred numbers).  For in-place sorting, I'd advise you to use Quick Sort.
",1,34281597
34273066,"
Seems to me the algorithm have a problem.
Consider:
In the first loop cur points to 7 and next points to 3 so there will be a swap of the nast pointers.
After the swap cur->nast will point to 5 while next->nast points to 3 which is itself. So the chain is broken and the element 3 is lost.
In other words - just swap of the nast pointers will not be sufficient.
",2,34272729
34274210,"
Here is a simple approach to the function implementation. The function just swaps data members x of adjacent elements. 
",0,34272729
34274803,"
There's an issue when swapping nodes in a list. If the nodes are adjacent, then 3 next pointers are rotated, if the nodes are not adjacent, then 2 pairs of next pointers are swapped. If the code swaps the next pointers that point to the nodes to be swapped first, then swaps the next pointers of the nodes to be swapped after, both cases are handled.
Then there's the issue if one of the nodes is the first node on a list that has a head pointer. and/or the last node on a list that has a tail pointer.
A simpler alternative is to use two lists (just need a second pointer to node, initially NULL). Remove a node from the source list, and insert it in order into the second initially empty list.
",0,34272729
34272164,"
I would actually combine the value and frequency into a std::pair<double, int> and then just sort them with std::sort; in this way you always keep a value and its frequency together. This enables you to write much cleaner code because there isn't an additional set of indices floating around:
Try it out in R:
We can also code up a naive R implementation to determine the efficiency gains that we get from using Rcpp:
To benchmark, let's look at a very large set of values:
For 1 million entries, the Rcpp solution is about 5x faster than the R solution; given the compilation overhead, that performance is only attractive if you're working on really huge vectors or if this is a frequently repeated option.
Linear-time approach
In general we know how to compute the median without sorting (for details, check out http://www.cc.gatech.edu/~mihail/medianCMU.pdf). While the algorithm is a bit more delicate than just sorting and iterating, it can yield significant speedups:
Benchmarking:
The linear approach offers a 4x speedup over the sort-then-iterate Rcpp solution and a 20x speedup over the base R solution.
",5,34271792
34246185,"
update : i was misunderstanding the question now it works as output in the question
simply you can count the occurrences of every string and print only strings which occur ones..
time complexity : O(N^2)
here is the code
",0,34245994
34274344,"
",1,34245994
34246939,"
Demo

std::sort, std::upper_bound,   std::find_if,   std::distance
",0,34245994
34277802,"
Note: Not tested as I am writing this on my phone and in bed.
",0,34245994
34236131,"
If you want to sort an array of characters in ascending order, there are several attempts to do this (Check out Wikipedia - Sorting algorithm). The simplest of all is probably the Bubble Sort algorithm.
The Swap()-function takes two parameters, and changes their value. Therefore in C++ this can easily be achieved via references:
The function won't return anything, as input parameters will be written to.
Your sort()-function will take an array of characters, the length of that array and will return the number of swaps that have taken place. (The return part really is optional, but you said you wanted it in your program). A Bubble Sort will look like this:
If you call this function on an array of characters the elements of the array will be rearranged in ascending order.
If you have any questions left, feel free to ask!
Cheers,
lindebear
",0,34235749
34220109,"
I don't know where you got data from, but you need to change it to array<int, 3> or make compareByValue a template:
",2,34220029
34220154,"
Also note that std::array has overloaded comparison operators, which compare arrays lexicographically. That means, if you want to sort based on the first element, you don't even need a predicate. Just std::sort your vector.
",5,34220029
34167311,"
You should change this line:
Use the following one instead:
The basic idea is quite simple indeed, in the second case you are checking if a number is greater than its successor while in the first one you were checking the opposite.
",1,34167044
34158127,"
list::sort does not want a pointer.
Just pass an object:
(There are other errors in the code you posted, but I guess those are caused by you retyping when you should have copied and pasted.)
",1,34157153
34157695,"
Your somelist variable is of type list<int*>, not of type list<SortID*>.
Your compiler does not know you have a pointer to a SortID class stored there, therefore can not recognize the () operator.
You can either change your list type:
Or cast it when being called - not safe though:
",0,34157153
34146923,"
The solution to this problem was solved through @PaulMcKenzie.
The line:
needed to become:

Below is the corrected function.
",0,34146583
34133780,"
The C++ standard does not require a minimum resolution for the std::high_resolution_clock.

20.11.7.3
Class high_resolution_clock [time.clock.hires] Objects of class
  high_resolution_clock represent clocks with the shortest tick period.
  high_resolution_- clock may be a synonym for system_clock or
  steady_clock.

Emphasis: may be a synonym for system_clock or steady_clock
You need to check your compiler's documentation. Your compiler's std::high_resolution_clock's resolution is probably too coarse to measure such small intervals, so your measured starting and ending time is the same.
",4,34133658
34124624,"
first of all show us errors.
second thing is that, in the documentation of std::sort we can read about compare function:

Binary function that accepts two elements in the range as arguments, and returns a value convertible to bool. The value returned indicates whether the element passed as first argument is considered to go before the second in the specific strict weak ordering it defines.
  The function shall not modify any of its arguments.
  This can either be a function pointer or a function object.

so you cannot pass pointers to it since they are out of range :D
im not sure how to use sort fucntion for two dimmensional array. but you can easily use it for your self-defined class. something like this (its not working code):
Update1:
After some research and reading your updated post with the error i think that it is not about pointers exactly. Rather passing 2d array to the sort Function might be problematic. Fortunetly you sholud be ale to use std::sort for vector of vectors as was done here:
How to sort a 2D array using the sort function in c++?
There is also pointed out that arguments of the compare Function must be static. I think that you sholud modify your code in that way at first.
I have also found that it is possible to use std::sort for 2d array with this cool trick:
https://www.quora.com/How-do-I-sort-a-2D-array-based-on-1-parameter-in-C++-using-an-STL-function
Which you sholud try as well. It's about using static cast to pass to sort Function not 2d array but the array of Pairs.
And Here is the explanation why Array of arrays can not be used with sort:
Sort a 2D character Array using sort() in C++
As written there, the point is that:

then you cannot sort ""the pointers"" because that data structure has no pointers at all... just 5000*2= 10 000 ints one after another

So your issue have combined reason of 1) using 2d array-> its not like you are sorting every second int, Rather your sort will work for all 10 000 ints without taking care that they are 2d...
2) so it's like sort is not sending adresses to your compare function. Instead it sholud send values which you are taking and using as pointers.
",1,34124582
34124619,"
EDITED
Instead of using a 2d int array (in essence treated as an 5000x2 1d array) you could represent your integer pairs as an array of your own integer pair struct
Create your integer list using std::vector
and use std::sort with a comparison function aimed at comparison of the first integer in your IntegerPair objects
",1,34124582
34121711,"
Pass the list by reference:
That's it. You don't want to be creating a copy of the list passed as the argument and sorting that. The changes won't reflect on the passed list.
",2,34121656
34120275,"
Try creating your own collator class or comparison function.  While in Java the more idiomatic approach might be to do this through extension, in c++ and for your case I'd recommend using composition.
This simply means that your custom collator class would have a collator member that it would use to help it perform collation, as opposed to deriving from the collate class.
As for your rules for comparison, it seems that you will need to explicitly implement your own logic. If you don't want spaces to be ignored, perhaps you should tokenize your strings.
",2,34119204
34106458,"
needs to be called with the same predicate:
Otherwise, the heap is built with the wrong criterion and will not be a max heap with respect to predicate. This violates the precondition for std::sort_heap(first, last, predicate);.
",2,34106440
34097701,"
You have a vector that contains vector-s. You have also have a function object that can sort vector-s that contain Object-s. That means your sorting functor can sort vector<Object>-s, not vector<vector<Object>>-s.
You have to write another functor that is able to sort vector<vector<Object>>-s, for example based on their size.
",0,34097428
34097811,"
If you have this:
You can either sort all the nested vectors:
or just one specific nested vector:
That's simple. However, in case you want to perform sorting in between the nested vectors, it will require a more complex algorithm and you should rather question yourself why you chose to use vector of vectors in the first place.
",0,34097428
34080453,"
The trick to solving this is to write a replacement for this line
that performs case-insensitive comparison. Start by writing a signature for it:
Now you can replace your if condition with a call to this new function:
Finally, you need to provide an implementation of greaterThanIgnoreCase function. This is the core of the problem, so you would need to do it yourself. The trick to it is using toupper or tolower function on each character of strings left and right, and compare them one character at a time. If you run out of characters in one of the strings, the one with some characters remaining should be considered greater. 
",4,34080344
34080485,"
The only thing you need to do is to compare lowercased characters. If you are not allowed to use any built-in functions, you can do it manually. 
Since lowercase characters are located in ASCII table starting from 97, and uppercase - starting from 65, you can simply add 32 to the uppercase char to get its lowercase equivalent.
Then, you can do the following in your if condition:
Note that you shouldn use lowerCase only when you compare, but not when you assign.
Here is the working IDEOne demo.
",0,34080344
34080448,"
If you have a vector of strings then you could/should use the STL library, which offers sort or stable_sort for a given comparison function (that can be a simple lambda expression, functor, function,...).
Update: You're not allowed to use built-in types except vector.
In this case you can develop easily a replicate of what STL does.
Define a sort function that receives a comparator (for a vector of strings).
",0,34080344
34055381,"
This code:
should probably be:
The first two arguments to std::sort are an iterator range. It'd be better style (assuming your compiler is C++11-compatible) to use std::begin(ndx) and std::end(ndx).
Also, the second line can be written std::iota( std::begin(ndx), std::end(ndx), 0 );
",1,34053986
34051277,"
Try this:
However, I am not sure I understand your swap. You should swap the entire struct, not the its members one by one. Consider this:
",1,34051144
34051207,"
Make a comparison function, then use its result.  The comparison function should return 0 if the structs are equal, -1 if the left should go first, +1 if the right should go first.
It will look something like:
",0,34051144
34033819,"
What happens here
when j==0? You access out of bounds. You're better off using std::swap from <algorithm> like
making sure that you run j until TEST_SIZE - 1. Or write the ""manual"" swap but with j exchanged by j+1.
",2,34033789
34026462,"
In NodeDequeue, I think you're calling getPrev on the first Node. The node before the first node should always be null. If you're removing the first node, you should set first equal to first->next and then set first->prev to null.
",0,34025941
34026376,"
Are you required to use quicksort (not list ""friendly"")? If not, use a bottom up merge sort with array of pointers to the first nodes of a list. It's an old algorithm, but for some reason, it's not well known. It only uses forward (next) pointers and the typical MergeLists() that merges two already sorted lists, so it's list ""friendly"".
Example pattern, first node is stored in array[0]. second node is merged with array[0] to create a list of size 2 and stored in array[1] (array[0] is cleared). Two nodes later, a list of size 2 is merged with array[1] to create a list of size 4 and stored in array[2] (array[0], array[1] cleared). array[30] holds a list of size 1 billion (2^30). array[31] list size is unlimited, 1 billion nodes are merged into it at a time. So array size of 32 is overkill, but takes so little space that you might as well use it.
Wiki article:
http://en.wikipedia.org/wiki/Merge_sort#Bottom-up_implementation_using_lists
",0,34025941
34052025,"
To answer my question, the solution was easier than I thought. I just needed one array of semaphores at the beginning, 
sim_semaphore semArray[NUM_CELLS] ;
and then initialized as stated in my question.
for (index=0; index<NUM_CELLS; index++) semArray[index] = create_sim_sem(1) ;
The child's job just consisted of signal and wait and the goal is to be able to swap the data all at once without having to wait one at a time. You can do this by having the child wait on i-1 and i before the actual swapping algorithm occurs and signal on i-1 and i after the algorithm.
The mother's job is to essentially walk down the line of data and double check that the child did its job. You can accomplish this by creating a for-loop before and after the for-loop already implemented. After that all you need to do is wait on i and signal on i after. This is just one solution though, there are more sophisticated solutions, but this is probably the easiest.
",1,34014617
34011415,"
std::sort is doing exactly what you're asking it to: it's sorting a list of strings in lexicographical order. To sort numerically, you're going to need to pass a custom comparator to sort which compares the strings as if they were numbers. For example:
This uses the function stoi from the standard library to convert the strings to ints for comparison.
",2,34011350
34011421,"
I have provided the same thing in a more simple manner. You have to use custom comparison in order to achieve this.
",0,34011350
33986627,"
Before answering the actual question: your code would benefit from factoring the partition code out of the body of the function! That way, you'd essentially call partition to determine the mid-point between the two arrays to be called, i.e., you'd have something like this:
The idea is that [a, mid) contains all elements sorting smaller than the pivot and [mid, a + n) contains all elements sorting equal or greater than the pivot. All what remains is

Call sort() recursively with the two array, i.e.,

Make sure sort() terminates if the array obtained is small than 2.

Of course, if you want your Quick Sort to be quick you'll also need to pull half a dozen or so tricks. Like:

Use Introsort to guarantee the complexity is O(n lg n) (e.g. together with Merge Sort).
Use Insertion Sort on small ranges.
Use an implementation of partition and insertion sort taking advantage of suitable sentinels.
Sort really sort ranges directly.

One of the things which oddly is rather futile to play with is choice of a pivot. As far as I can tell, using the middle element works as well as any more advanced technique (assuming optimizations like those mentioned above are implemented).
",0,33986397
33987443,"
Separate the called function from the recursive function:
",0,33986397
35256763,"
Take a look at frexp() family of functions as well as ldexp(), which is kind of opposite to frexp()
Link: http://www.cplusplus.com/reference/cmath/ldexp/
",1,35256691
35260658,"
Here's an example of type-punning floating-point values with unions and integer bitfields.
",0,35256691
35255989,"
There is a very simple std function that will give you the median of your array: std::nth_element.
Basically, if you want to get your median, you can do this :
This sample is taken directly from the documentation : http://en.cppreference.com/w/cpp/algorithm/nth_element
To find the mode, you could first sort your vector and the traverse the array. This would be in O(nlog(n)) because of the sorting. Since they are sorted, same elements are next to one another so it's easy to see where there is the most replication.
",1,35255839
50545615,"
The method for finding the median of a set, depends on whether it has an odd or even number of elements. In your case, the set is a vector and the number of its current elements is its size().
The code example in http://en.cppreference.com/w/cpp/algorithm/nth_element can only find the median if the size of the vector is odd, not even.
",0,35255839
35253242,"
The problem is in your orientation function. It is not transitive: if a > b and b > c then a is not always greater than c. THis is the problem: you cannot have any meaningful order if your comparison function is not transitive.
Proof of nontransitivity:

Assertion failed!
Expression: compare(&a, &c) > 0 && ""Transitivity violation""

",2,35252583
35254772,"
I think that your first example is wrong too. Maybe you need functions like compare or orientation for some other purpose, but you don't need them to sort some points by their distance from an origin.
Besides your compare function calculate a distance only if the points are collinear and in orientation the line if (signedArea == 0) ... is prone to rounding errors due to floating point approximation.
To sort a number of points with respect to their distance from a given point you can use something like this:
The order of the sorted points become:
",0,35252583
35231819,"
You could use a 
",0,35231785
35232709,"
Use std::vector. You can create a 2D vector like this:
And then read the lines from a file, and put the data into a one dimensional vector (vector<string> line). And then, You can push_back the line vector into the table, like this:
You can see more information about vector on this page: cplusplus.com
",0,35231785
35392051,"
I hope you must know what format of data that you are going to read from text file's row and column. First to understand, you will read first row, then second row and so on. If you do not know type of data, then believe all of it as string of characters. So, you can assume wherever you fine null char '\0' then you are finding data for first row, so go on read character by character look for next '\0'. Then wherever you find '\n' that will be last point of first row and you just discovered last column. After '\n' you will start reading 2nd row and so on. With this you can determine how many rows and columns are there. You keep on reading text file until you reach EOF.
See the attached image. 
Text File Format
Also, define a pointer to character type and use realloc to assign memory to it. With realloc() you can grow it, as you find more data. Please go through realloc() manual for reference. 
",0,35231785
35208774,"
The number of swaps made in insertion sort is equal to the number of inversions in the array (the number of pairs of elements that are out of order). There is a well-known divide-and-conquer algorithm for counting the number of inversions in an array that runs in time O(n log n). It's based on a slightly modified version of mergesort, and I think you shouldn't have too much trouble coding it up.
",1,35208616
35209030,"
The problem with your approach is that you're not correctly implementing insertion sort, what you've achieved is an inverse bubble-sort.
for a slightly less complex (yet with worse complexity :P) than @templatetypedef 's O(n log n) solution you can solve it in the same complexity of the sort O(n^2) by applying the correct implementation.
you should implement a function for swap(int* array, int index_a, int index_b) than count how many times this function was called.
this Link to wikipedia has a good pseudo-code for you 
",0,35208616
35196383,"
Initially C++ present in the tags... Test can be on cpp.sh
",0,35195484
35179550,"
Well the key thing to notice is that if you look at your two examples:
What's it look like it's doing? To me it looks like it's sorting all but the last two characters. 
What do your loop bounds look like?
You're skipping the last two characters! Change the bounds to just size.

A std::string knows its own size, there's a member function for this: size() (or length()). So you don't need strlen(). Then SortString() it actually taking a copy of the string and sorting it internally, would be much more useful if you sorted the original string by taking it by reference. And lastly, there exists std::swap():
",3,35179373
35179671,"
Why do you count until size - 2? This way you are not seeing the last two characters
",0,35179373
35179845,"
First of all there is no great sense to declare the second parameter because objects of type std::string keep inside themselves the information about their sizes.
Also this condition in the outer loop
is wrong. For example if the string has only two characters like ""BA"" then it is obvious that size is equal to 2 and the loop will iterate never. That is the characters will not be swapped to get the sorted string ""AB"".
The function can be written the following way
",0,35179373
35170505,"
The linker errors are reported if you have any problem with libraries or object files linked.  Were you able to successfully build the executable?
",0,35170342
35170888,"
I think this error is occurring due to more than one main() function in your code.You can have only one main() function.
",0,35170342
35175225,"
Not sure about the error. But I would suggest changing boxSort function to something like this.
change getVolume to this 
and boxSort to this
function call:
",0,35170342
35169693,"
This statement calculates the value of the expression toupper(word[0]), and then throws the result away. 
Change it to:
",3,35169642
35169719,"
You're not assigning the return value of the toupper() function. But anyway, it doesn't do, what you probably think it does (regardless, that word is not used afterwards): It will just capital one letter.
What you probably want to do is to capitalize the whole word:
std::transform with toupper as a parameter can be used.
",2,35169642
35155235,"
We can also perform this using do-while as follows:
",1,35146669
35155497,"
You can simplify the entire thing by using objects. Objects allow you to handle the related data in a sane fashion. Also highly recommend are vectors instead of C arrays. 
You can then store your products in vector<Product> my_products; and then sorting everything with 
You can keep the existing input/output format, but place the values in the right place. This way it's almost impossible to mess up the attributes and everything is easy to work with.
",1,35146669
35148668,"
int sortedID = **p; is not what you want, and should be removed. (I think you wanted int** sortedID = p;)
Your bubble-sort should be something like:
Live Demo
",1,35146669
35104702,"
You take the addresses of Binding pointers and pass them compareNumbers function in this line:
That is wrong because compareNumbers function excepts values convertible to Binding * as arguments, not Binding ** as you pass them now.
",2,35104605
35102828,"
Change the definition of temp to
When a value from the array is assigned to temp, it is truncated. Therefore, the decimal part is cut off.
The one double lucky enough to maintain its full value appears because it hasn't been assigned to temp; it was in the right order already.

Notes:

Use the C++ standard library whenever possible; don't reinvent the wheel. Therefore, use std::swap instead1:



1 Thanks to @PeteBecker!
",5,35102821
35083010,"
",0,35059941
35057877,"
You use quite dated compiler where stl used const& parameters, in more modern versions those are passed by rvalue references and does not require const operator<, so to fix it:
Change:
to
Alternately, use a later version of the compiler which supports more modern versions of C++ and then enable the more modern versions with '-std=c++11' or '-std=c++14'.
",3,35057647
35057871,"
Corrected Code:
",0,35057647
35029943,"
Your question is rather under-specified. So here are a few assumptions and possible solutions
Your vector is already sorted by birth date
In that case, if you really want to be fast, just use reinterpret_cast. It is evil, but if your Person-class really just consists of that one member, then it certainly is the fastest thing.
Your Person class has more members than just birth_date
Use transform with a lambda.
You just want to read from the new vector
In that case, you might consider using a view (instead of a vector), see for instance https://github.com/ericniebler/range-v3
",2,35028349
35028408,"
It's good to separate the values into a pre-allocated array first, that way they'll all be nice and contiguous for std::sort's rearrangements:
std::vector::reserve
",1,35028349
35030397,"
The answers posted so far create a new vector, copy the values of the birth_year variable into the new vector, and then sort the new vector.  
IMO, it would be better to sort the vector of People first by birth_year, and then to copy the birth_year values from the sorted std::vector<People> to a new std::vector<unsigned int>. This would have the same overall performance, but would leave the vector of People sorted, which might be beneficial in some contexts. You can do this by overloading operator< in the Person class, or by providing a custom comparison function, see std::sort. Here is an example:
Here is a live demo : Coliru demo
",0,35028349
35021258,"
The simplest solution is to split the string into a collection of string then sort that collection and concatenate the result into a string again: you can use a custom comparator using the size of the string and feed it to std::stable_sort with the collection of strings to sort:
Of course, this algorithm is not optimal. To avoid much of the computation, you could store directly a vector of strings and work with that instead of storing your words in a space-separated string. Among the suboptimals things: we copy many things from the original string while some things could probably be moved to and from the words vector (not sure). The mere fact that we strip the spaces to add them back is a clear hint that we're doing more than we could.
Also, note that the final string will have an additional trailing space that you can choose to remove with pop_back.
",3,35020794
35011588,"
This problem is twofold:

How do you get sortable date values from string representations 
How can you effectively sort said values.

Finding valid timestamps from a date-string
C++ uses the time_t object as a valid number of seconds from a set date (Jan 1, 1970 UTC) There's plenty of concise information about that, in every-case you may consider this an Integer-representation of time in seconds.
Next you need to know how to parse your data into a time-stamp: here are some rather some helpful links.
My preferred method is mktime - there's an example of that Here on stack-overflow. Also it seems someone else has done the same course as you ;)
You might want to consider using A function of your own design, if the date format is unusual. In this case, using scanf is often the simplest way - the interface of this function is somewhat old-school ""c-style"", but that doesn't change the simple fact it works, and well.
Here's a link to someone reading a simple-date with scanf.
Turns out the code I wrote below is close to The answer to this great question
Association and sorting of dates
Once you know how to get a time_t from your date, you can start creating an associative array of the data - in this case I'll be using a map.
With that, here's an example of using a map to insert, sort, and output the data.
Notes: 

I use C++11 syntax here, if you don't understand Range based loops you might want to read up on them.
I'm assuming the structure you described is stored in a vector.
The ""GetDateFromObject"" function I'm using here is a placeholder for whatever function you use to get the timestamp)
Inserting data into a map using std::make_pair.
I'm holding pointers to the original value-objects.

",1,35009876
35012303,"
The date format YYYY-MM-DD HH:MM:SS is special in that a lexicographic (letter by letter) comparison is the same as a time comparison, so you can just use that.
If your container isn't initially sorted by date, you'll have to go through all the dates one by one. std::copy_if provides a nice way of doing this:
copy_if looks through [v.begin(), v.end()[ and plonks the elements into u from u.begin() onwards whenever the lambda returns true. They'll be in the same order as you gave them in.
If your range is sorted, you can use std::lower_bound and std::upper_bound to get the start and end iterators instead:
lower_bound and upper_bound find the first value of at least from and the first value of more than to, so that the range [lb, ub[ is the range with values [from, to].
",2,35009876
35010137,"
In example you could do like that: convert all dates to time_t value (numberical representation of the date and time) and then iterate through your vector and use normal comparation between three time_t numbers. For reference: man mktime, man strptime.
",1,35009876
34990862,"
In the loop
stop is the length of the array, and you are iterating through values of j = 0 to stop - 1. When j reaches stop - 1, the next element that is j+1 becomes stop (10 in this case). But since your array has a length of 10, sortArray[10] is not part of the array, but is referring to some other object in memory which is usually a garbage value. The garbage value is 10 in this case. When you swap sortArray[10] and sortArray[9], the garbage value becomes part of the array and the value at index 9 leaves the array. This keeps on happening till the outer loop ends. 
The end result is that unless the garbage value < largest element in the array, the garbage value is pushed in the array and the greatest value of the array is put at sortArray[10] which is not part of the array. If the garbage value is greater than all the values of the array, it'll be found at sortArray[10] which is again not part of the array and your code will return the desired result.
Essentially, what you are doing is giving the function an array of 10 (or stop) elements, but the function is actually working with an array of 11 (or stop + 1) elements, with the last element being a garbage value. The simple fix is to change the conditional of the loop to j < stop - 1.
Note that if you had written this code in a managed (or a comparatively higher level) language like Java or C#, it would have raised an IndexOutOfBoundsException.
",1,34990406
34991204,"
At index 9, j+1 is out of bounds. So to fix this, you only need to check till index 8
Look carefully at the inner loop condition j<stop-1
",0,34990406
34976119,"
The error is in the way you update the array after finding the minimum.
In each iteration, you should find the minimum value between array[i]..array[4], and then you need to swap array[i] with array[min] as follows:
",1,34976016
34963525,"
Suppose the number of strings in your files are n and m, respectively. 
The way you're doing it now, the complexity is Θ(n m). Moreover, the complexity constants are those of file operations, which are incredibly slow. 
Instead, you should just read one of the files into a std::unordered_* container, then compare keys between the containers. This should reduce the running time to expected Θ(n + m).

As a side note, you might want to look at more modern ways to read strings into containers (using, e.g., std::istream_iterator).
",2,34962405
34962758,"
Load h in a vector of strings, and loop once through h2 by comparing each string with the vector's contents.
Since your test is symmetrical, you can choose h to be the smallest of the two files. That way, you'll save memory and time, especially if one of the files is much larger than the other. Using a set (std::set) instead of a vector could also help if the comparisons are costing a significant time.
",4,34962405
34948028,"
You're essentially using arr[x] as a std::map<int,int>. The index of the array is your key currently, against which you're storing numbers.
Use a map and put values in as you find them. Something like:
std::unordered_map and std::map both work here, choosing between them
",2,34947979
34944997,"
You need to provide a compare function for sort to work.
bool myfunction (my_data i, my_data j) { return ( i.data_one < j.data_one); }
std::sort(my_vector.begin(),my_vector.end(),myfunction);
",2,34944909
34943156,"
This doesn't look like a matrix to me.  This looks like a series of records.  I would define a record:
store the data as 
define a comparison function:
and sort using the standard function:
If you make sortByDate inline, you are very unlikely to be able to do much better.
",2,34942643
34933414,"
Use cudaGetSymbolAddress to take the address of the array variable from a __host__ function:
Here's the complete program:
Here's the output on my system:
The sorted output is the same as the unsorted output, but I guess that is intentional given the way the data is generated and the definition of element::operator<.
",2,34932416
34933472,"
This:
is illegal. In host code, array is a host address and can't be passed to device code.  Do something like this instead:
i.e. you need to use cudaGetSymbolAddress to read the address from the GPU context at runtime, then you can use the result of that call in GPU code.
",2,34932416
34906285,"
The comparison function which std::sort uses needs to be in the form of:
Here the types Type1 and Type2 must be such that the iterator can be dereferenced and then implicitly converted to both of them.
In your case dereferencing Workers.begin() gives you a unique_ptr<Worker> not a Worker. You will need to change your comparison function to take a const unique_ptr<Worker>&.
In this case it would wind up looking like:
",11,34906144
34906289,"
The datatype of your std::vector<std::unique_ptr<Worker>> is std::unique_ptr<Worker>, so your comparison function has to look like this:
The comparison function expects to arguments so that an object of the std::vector can convert to them.
",5,34906144
53727540,"
Since C++11, you can also use a lambda expression instead of defining a comparison function:
Note: This example directly uses Worker objects for the sake of clarity, but it should work for your derived Builder and Driver objects as well.
Code on Ideone
",0,34906144
34928027,"
When you are facing something complex in C++ template programming, it mostly helps to try to break it into several smaller steps (like with most programming problems). Here is a possible path:

Select the X which match the selected I and store them in a new data type replacing the I with the position (use recursion for this)
Sort the X in the selected_data by J. This is a bit annoying to write, I think. Maybe you should create a separate question for that.
Extract the positions from the sorted and selected X

And here is the corresponding code. I am using std::conditional, but that is easy to replace of course. I am using std::is_same in the tests, you do not really need that of course (and it would be trivial to implement otherwise).
Your stuff + utility header for std::conditional and std::is_same
Extract the Xs that match the I we are looking for and replace the is with the position.
Sort by J. This is done by incrementally inserting elements into a sorted list. There might be more elegant ways to do it.
Finally, extract the indexes you are looking for:
Word of warning: While I don't see any problems in the code, I have not tested it beyond your example...
",1,34904049
35036118,"
I'll share my approach to this problem which I think is kind of neat. I used C++11 std::conditional, and C++14 std::integer_sequence and std::make_integer_sequence, all of which you can find implementations of online.
Let's start with the data structures you had.
We'll use a metafunction concat, which concatenates N list of types. We use it to filter a list by returning list<T> when the predicate returns true, and list<> otherwise.
For example, to filter the even numbers from list<1, 3, 2, 4, 2>, we can perform std::conditional_t<I % 2 == 0, list<I>, list<>> for each I to get concat_t<list<>, list<>, list<2>, list<4>, list<2>> = list<2, 4, 2>.
Now we get to build_index. We perform bucket sort within the known range of [0, 32). We could have used a generic sorting algorithm, but it was more fun to cheat.
With which we get:
",2,34904049
34886931,"
This is not a full answer but to get the first 25 elements out of 13721057 you better use partial_sort.
If you only need the 25th element, then nth_element.
As a side note. For getting the first elements less than X in sorted order, I would do auto mid = std::partition with a lambda, and then std::sort(begin,mid). There may be a better way.
",12,34886851
34887310,"
EDIT: As suggested in a comment I also tried with a pre-sorted input and in that case I did manage to get sort faster than make_heap for my ""expensive to copy"" type, but only by a small margin around 5-10%.
No matter what I try, I am unable to reproduce your results on either Solaris or Linux (gcc 4.4). make_heap has always come out on the order of 1/3rd the time spent.

No optimization vs -O3 only changes total time, not relative order.
I used your exact number of items.
First tried sorting int then a larger ""expensive to copy"" class.
Guessed what includes you were using.
Moved timing calls outside the printf to make sure they were always ordered properly.

I assume that the actual reason for this discrepancy is that either your < and > operators aren't the same complexity or that copying your object is somehow expensive relative to comparing it in a way my test was unable to duplicate.
",9,34886851
34878454,"
You can combine these two vectors into one with type like std::vector<std::pair<int, float>> and sort it instead. The compare function can be like this:
And sort the combined data like this:
After this, you can get the sorted parts, i.e. its first component.
",6,34878329
34878629,"
@herohuyongtao 's answer is good, but uses templates.  You should learn templates.  If you don't want to do this though, just create your own struct
and your own compare function
Then bundle your vectors into a single vector<MyPair> and use std::sort on that and your compare.
Of course, vector<MyPair> is a template.  So was vector<int>.  You should learn templates!
",3,34878329
34915311,"
This is slower, but it doesn't require pairing the data and doesn't require allocating a temp vector:
",3,34878329
34893410,"
This is what I finally used, suggested by herohuyongtao, and it's working.
",0,34878329
42084595,"
Sort the indices (assuming it is 0 to N sequentially) like:
std::sort(indices.begin(), indices.end(), compareFunc);
using a compare function like:
This will sort only indices but predictions can be accessed in sorted order using index values from indices!
Complete Code:
",0,34878329
34867371,"
You need the partial template specialization.
",4,34867205
34867394,"
Your syntax is wrong for partial template specialization
Online Demo at Coilru
",2,34867205
34868330,"
You are trying to use partial template specialization. This allows to make multiple definitions for a class template.
But even with this feature, you have to create only one declaration of the type. The declaration is something like this:
You can even combine it with a definition:
Behind this declaration of s, you can add other definitions. But it is not allowed to add declarations which differs from the first. To add definitions (and no declarations), you have to add template parameters to the name of the type. Note the <10> after the name in the following definition. The definition is only used for the type s<10>:
You can also use more generic definitions. The following definitions is only used for s<x> where x is some integer. It will not be used for types which have more then one template parameter.

I would implement your s using C++11 this way:
",1,34867205
49986188,"
You do not need elaborate solution for this. 
First you need to define proper is_sorted since before C++20 is_sorted is not constexpr and then just use it.
",1,34867205
34851417,"
You can use a function with std::priority_queue as well. The difference in what you're doing is that you pass the function to std::sort as a function parameter, but you try to define the function as a template parameter of the queue. This obviously does not work because the third argument is a type argument as the error explains. Besides, you cannot even have pointer or reference template arguments.
If you take a look at the reference, you'll find that the queue has a constructor for passing the comparison object. That's where you must pass the function.
There is a difference with std::sort.  Sort is a function, and you can let the compiler deduce it's template arguments so you don't have to specify them explicitly. The queue is a class template, and template arguments of a class template can not be deduced (not in this context at least).
The template argument is defaulted to std::less<typename Container::value_type>, but you don't want to use that. Therefore, you must specify explicitly the type of the comparison object. You specify it where you're now trying to pass the object. How to get the type of the function pointer/reference, you may ask. You can do it like this: decltype(&cmp). If you have an outdated compiler that does not support decltype yet, then you'll need to specify the type without it: bool (&)(const int&, const int&).
Here is an example of how you would create a queue that uses your function.
",3,34850929
34851324,"
As the error message implies, functions cannot be used as template parameters. The priority_queue will copy an object of the comparison type. For example, this might be std::less<int>, where an object of that type is std::less<int>(), and it being called is std::less<int>()(x, y). In C++11, you could use decltype, but in C++03 the ""canonical"" way is to create a ""functor"" (an entire type dedicated to being used as a function object.) This is one of the reasons why lambdas were created.
",2,34850929
34851161,"
The answer is in compiler errors.
The third template parameter of priority queue is a comparator type (like structure or classes) and not a function.
",1,34850929
34843995,"
The problem here is that the incrementation step of a for-loop is always performed when the previous execution condtion was true.
So after inserting ""2"" the condition of the for-loop is true:
Afterwards the body of the for-loop is executed and i is incremented.
Now the condition is checked again and is evaluated to false, but nevertheless i is 1 instead of the expected value 0.
So after performing 
your array looks like:
[1] [10] [2]
",2,34843540
34843818,"
Instead of a raw array you could use a std::vector in combination with std::upper_bound and use the following construct for every user input:
Live Demo
",1,34843540
34843973,"
I suppose it's your homework and you're not allowed to use vectors with  vector::insert(), nor other appropriate standard container or algorithms.
I propose to simplify the algorithm by using one single general appraoch:  try to find the first element in the array to which x is slower.  If it is found, insert x at the correct place, otherwise, add it at the end:  
Here the live demo (arrsize is a const defined to 10).   
",1,34843540
34844104,"
You could try:
However, the line
will give you problem as well.
If your array holds
and the next input is 3, the if-statement will never become true and the program will fail.
",1,34843540
34844219,"
arrays are just bad for this kind of thing..
consider using a linked list,
you make a Node class that contains a value and pointer to next node:
and a bit more code for the List class to handle theme, 
you will find it a lot easier to insert a node in betwin tow other nodes,
rather then moving the array a thousand times.
better information -> http://www.cprogramming.com/tutorial/lesson15.html
",0,34843540
34844242,"
Maybe this will help, so 
",0,34843540
34817970,"
You can create a third array of pointers, a+0 to a+length-1, use a compare that only needs to know the type of elements in a[], to sort the pointers according to a[], then reorder a[] and b[] in place (in O(n) time) according to the array of pointers.
You could also use an array of indices 0 to length-1, and use a Lambda compare to compare indices according to a[]. This example uses A[], B[], and I[]:
",0,34792128
34823576,"
It's not completely trivial, but this will work.   This uses C++11 features.
The sort_base() function (a name I've plucked from the air) does assume that the range started by begin2 has (at least) the same number as in the range (begin1, end1).
",0,34792128
34775578,"
When you run through the loop above, you are consuming all the input. Therefore, when you call readSortOutput there is nothing left to read. You should use inStream.seekg(0); to reset your position in the file before trying to read the array again.
",1,34775449
34757192,"
Quick hints.

Don't use operator!() to sort.   Use a function named something like sort().   operator!() generally does a very different thing, and using it to sort will make your code harder to understand.
Don't use using namespace std in a header file (or before class definitions that rely on it).  There are plenty of explanations as to why on the internet.
Use standard C++ library capabilities rather than rolling your own as you have.

For example, the following omits constructors and the like, but does 90% of what you seek.   With no worrying about memory management, getting the algorithm to sort right, etc etc.
The thing to realise is that std::string, std::vector (and other containers in the C++ library) keep track of their size, and resize themselves cleanly when required.
Read up on std::string and std::vector to work out what you need to do to manage them (set contents, update, etc).
",1,34756562
34757137,"
You are not copying anything to your temporary pointer.
Change
to
Also, let me just say the method you're using is extremely inefficient and likely to cause problems. I would define  a comparison function for your class and use std::sort(). And please, do provide more information next time, an input and an output with the expected output, it helps.
",0,34756562
34766945,"
Since the outer for can't be parallelized due to the constant changes in the array, we need to parallelize the inner for.
So we need to use the max reduction, but since we just don't need the maximum value we also need the index of this maximum value, we need to declare a new reduction (Only available in OpenMP 4.0) that receives a struct, here it is fully functional:
",4,34752333
34753833,"
Selection sort is far from optimal. You should use a formally efficient algorithm in serial (eg qsort), since it will almost certainly beat threaded selection sort for nontrivial usage. 
The comment that suggests merge sort is a good one.
Threading selection sort as you've shown here is not hard, but since it's the wrong thing to do, I'm not going to demonstrate it. 
",0,34752333
34702893,"

How can I make sure that when I sort a vector of Data, std::sort will
  still use the move-constructor and move-assignment?

Actually, you don't need to. You have to make sure that the swap function used exploits directly or indirectly any trick already used in the move constructor. That is I think how it works. In other words, sort needs a good swap, not necessarily a copy.
Where ""directly"" could mean simply using the default std::swap that uses the move constructor when it can.
So, chances are, you don't need to do anything special because swap (or as @MarcGlisse noted, the sort algorithm directly) will use the move constructor.
",1,34700426
34707550,"
Just provide move-constructor, move-assignment and free swap-function (in the same namespace) for your Data class
",2,34700426
34700449,"
Your problem is that temp variable is declared as an int it should be double also you should swap the ids too 
",1,34700272
34657368,"
Make your method mycomp static, and write a method which does the sort job.
The method Npt::get_jverl has to be const
returntype get_jverl() const { return ...; }
If you do the sorting outside your class note that you have to return a reference to your vector in your method: vector<Npt>& get_xx() {return xx;}
",1,34657044
34657631,"
Firstly, we'll fix the error that you're fetching two instances of the list:
Replace with
I've added () to v.end, too, as we want to call it.  However, we don't mean to call Npl::mycomp() here - std::sort wants to receive a function, not the return value:
This still won't work, as Npl::mycomp is an instance method, and std::sort won't call it with an object pointer for this.  As it's implementation doesn't use this, it can be made a static method.  Better still, it doesn't use any of the private members, so can be made a free function, outside of any class:
That should be enough to help you on your way.
",0,34657044
34659684,"
You didn't say which version of C++, but assuming C++11 here's a more modern approach (compared to the two answers that are already here). Your requirements don't mention needing the comparator for anything else, so rather than write a comparator, you can do this:
You could put this code in the Sort method of the Nobelpreise class as Rabbid suggests.
Compared to the other approaches here, I'd argue it makes the code more readable as you can see inline what is being compared, instead of having to jump to a new function just to read one more line of code (assuming of course that function is not being used anywhere else). It also makes the code faster because you are passing a lambda rather than a function pointer, but you shouldn't necessarily worry about that at this stage.
",0,34657044
34658541,"
Broadly speaking, there are two ways to iterate through the contents of a tree: breadth first and depth first. Breadth first looks at all the elements at one level before going down to the next level. Depth first goes down one branch of the tree to it's leaf, then comes up and back down to the next leaf, etc. For a tree that represents sorted data, depth first can give you the data in sorted order, and that's what map iterators do, because it's most useful.
",2,34654693
34645461,"
your problem is that is that these loops 
are inside this loop while(i<lc && j<rc) and they should be outside it as you copy the rest of a[] if b[] is done while a[] has some elements and like wise for b[] and this is the whole merge function
",1,34644977
34645102,"
Your code will fail if the iterator reaches the last element in the list. When that happens std::next(it) is equal to list.end() and it's an error to dereference an end() iterator (causing a segfault in this case).
My suggestion is to use the std::is_sorted algorithm in the standard library. It's already written, debugged, and does what you want.
",6,34644767
34604167,"
will not work if R is of type std::vector<Rent>. There are two problems with those lines:

operator+() is not defined for std::vector.
The compiler expects the operator<() function to be a const member function.

You can fix the operator<() function by making it a const member function.
That still does not resolve the first problem.
However you should be able to use:
after that.
In theory, you shouldn't have to make the operator<() function a non-const member function. Take a look at http://en.cppreference.com/w/cpp/algorithm/sort. See the description of the comp argument. It says:

The signature of the comparison function should be equivalent to the following:
The signature does not need to have const &, but the function object must not modify the objects passed to it.

However, not all compilers adhere to that. They expect the signature of the function to be such that they can work with const objects.
",4,34604130
34604206,"
According to error, R is a std::vector<Rent> but following code:
would work only for C style array. If you want generic code that works for both C array and std::vector write it as:
",2,34604130
35820664,"
If you want to use bubble sort you should add this after your code:
All is left is to put all the words in alphabetized;
That´s it.
",0,35819528
35819716,"
You are taking the string from normalfile in 'word'.
After this you can try using sort function as sort(word.begin(),word.end()).Don't forget to include algorithm header. Now, since your word is sorted you can put its text in alphabetized file.
Hope it helps.
",0,35819528
35819038,"
std::set stores and searches for values based on the entire value.  So when you do a find for pair(key, null), and the set contains pair(key, somevalue), it won't find it, as they are not the same.
If you want to search by just the key, you need a std::map.  As you say, that doesn't do any searching or sorting by the value, so you can only have one entry with a given key.
If you want to search/sort by both just the key and the key,value pair (different searches at different points in the lifetime of the same data structure), then you'll need a more complex arrangement.
a map of sets can do what you want:
Now when you just want to look up things by key, you just lookup in the map, getting back a set of all the values with that key.  If you want to search further for a specific value, you look it up in that set.
",1,35818787
35819095,"
To find key in std::set by key stored in pair you need to redefine order comparision procedure for your set (if you need multiple objects use multiset):
This example define comparision object CustomObjectCompare and special set class Set with that comparision object. As search as sorting will be only by string. The function isSet search by string and emptyObject is ignored and may be any of existed object. In example it is an function internal once initialized static object.
",0,35818787
35820323,"
Statements like O(N²) are like a dimension; double the number of points and time taken quadruples.  An O(log N) algorithm can be slow for small N , the point being if N doubles or is increased by a factor of 10 running time doesn't.
Compare with finding a specific word in a 1000 page dictionary and one in a 20 word sentence. Sorting a 20 word sentence before finding a specific word takes longer than reading it straight through once.
",-1,35818747
35807739,"
Replace your while loop with this:
The >> operator for streams delimits at white space, but getline will read the whole line.
Additionally, using eof in a loop condition is BadTM.
",2,35807680
35774309,"
I changed the comparison function to this and the TLE went away (and changed to a WA):  
The reason for this, as suggested in the comments, is that the comparison function you gave did not have a strict weak ordering. (It returned true even when the two objects had the same time and the same type(EventType::LEAVE), whereas it should have returned false when both the objects are equivalent.)  
EDIT:
You are getting WA because of test cases like these:  
5   1 3   1 3   3 4   4 7   4 7
Your output - 2 6
Correct output - 2 3 
You are getting the maximum number of events right but their durations wrong.  
The remedy for this is to to calculate the answer in two iterations.
In the first iteration, we calculate the maximum number of events.
In the second iteration, we calculate the  maximum duration using the result obtained in the first iteration.  
The correct code (almost similar to yours) :
",2,35770603
35776407,"
You can simplify your code by doing away with the Event class altogether, and using pair<int,int> instead. Pairs are sorted by their first element (which would be your event time) and then by their second. I propose populating your vector with code similar to:
    vector<pair<int,int>> v;
    for (int i=0; i<n; i++) { // n events to add
        int a, b;
        cin >> a >> b;            
        v.push_back({a, 1});  // 1 for ""enter""
        v.push_back({b, -1}); // -1 for ""leave""
    }
    sort(v.begin(), v.end());

As you can see, sorting does not require anything extra to be defined. It just works (tm).
Two pitfalls:

if I arrive at t0, and somebody else leaves at t0, the number of people in the party has not changed. 
if many people arrive or leave at exactly the same time, you should only re-calculate change-in-assistance once (and if it is 0, ignore it altogether, as in the previous pitfall).

I can also confirm that, for this particular problem, the judge won't accept any answer that uses complex structures (I initially tried to solve it with a map<int, int>). Simply performing
    map<int,int> m;
    for (int i=0; i<n; i++) { // n events to add
        int a, b;
        cin >> a >> b;            
        m[a]++;  // add 1 party-goer at time a
        m[b]--;  // remove 1 at time b
    }

gets you a time-limit-exceeded (even though it sorts itself automatically). So even if interval trees are great for repeated interval queries, they are not the right tool for this particular problem (which queries only once).
Good luck fixing your code for that elusive AC! I can confirm that it is attainable.
",1,35770603
35764401,"
Try using this logic 
It gives you what you want. 
You are getting invalid comparator error because for some two items A an B being compared the operator returns true saying that A should precede B at the same time saying that B should precede A. At the same time returning false does not mean that the second should precede first.
Anyway the same task can be done with lower time complexity which is O(n) instead of O(n * log(n)). 
",1,35764025
35764145,"
For a number of reasons, you should prefer using std:partition for this:

As you note (in the comment), you're only using one of the arguments to your binary predicate. This makes your binary predicate inconsistent - it doesn't really define the relevant ordering. Conversely, the predicate in partition is unary, and you can semantically use it exactly for what you want.
In terms of complexity, sorting is an overkill for what you need, as the complexity is Θ(n log(n); conversely, the complexity of partition is linear.

Perhaps you can try something like this:
",2,35764025
35738851,"
Use a predicate function that parses data and return the result of less-than by comparing object 1 and object 2.
About the members first, second, third and fourth you parse (using stringstream possibly) and store this in the data members as parsing every time in your helper function may be costly.
",4,35738826
35739244,"
Make a struct of the data and then sort according to Mohits' answer. 
it could look like
now you can sort by using a functor. 
to input use a stringstream (will make life much easier).
",1,35738826
35738891,"
Your comp() predicate doesn't handle the case where l[i] > r[i].  So it returns 1 when comparing ""foo"" and ""boo"", and also returns 1 when comparing ""boo"" and ""foo"".  Therefore, it fails to implement a strict weak ordering (i.e., fails to behave like <=) , and the results of passing it to std::sort() are undefined.
",2,35738538
35738571,"
Try to use standard comparison method (not your own bool comp(const string &l, const string &r)), e.g.:
#include <algorithm>
#include <string>
#include <vector>
#include <iostream>
#include <functional>

using namespace std;

int main(void) {
    int N; 
    cin >> N;
    vector<string> v;
    for (int i = 0; i < N; i++) {
        string s; 
        cin >> s;
        v.push_back(s);
    }
    std::sort (v.begin(), v.end(), std::greater<string>());
                                // or   std::less<string>()
    for (const string& s : v) {
        cout << s << endl;
    }
    cout << endl;
}

Or change your function to simple one, like:
bool comp(const string &l, const string &r) {
    return l < r;
}

Update:
But if you really want to use your own comp function, you should understand that reason why exception invalid operator < occurs because your comparison function (comp) returns true when both relevant fields are equal (this not correct behavior for ""less than"" required for sort).
And at the end, small tip (it is hardly a solution) - try this for your code:
bool comp(const string &l, const string &r) {
    for (int i = 0; i < max(l.length(), r.length()); i++) {
        if (i >= l.length()) return false;
        if (i >= r.length()) return true;
        if (l[i] != r[i]) return l[i] < r[i];
    }
    return true;
}

",1,35738538
35715962,"
You cannot simply use file1, file2 and file_1n2 as simple pointers(maybe your confusion comes because you use plain arrays in that way). Here merge uses stl iterators, not just a pointer. To fix the problem, use:
",4,35715886
35708874,"
Quicksort doesn't get affected by range of numbers, but the order (i.e. if the numbers are already sorted or sorted in reverse order, and if you pick the first element as the pivot). If you are using random pivot approach, even that problem is solved.
In summary, every algorithm has a worst case complexity and it is usually discussed in the literature about the algorithm.
",1,35707801
35709278,"
N^4 isn't very big, an array of 2 billion integers would only require 128 bits for each integer to meet that requirement.  Since this would require at least 8GB to store in memory, you will generally be limited to O(N*log(N)) sorting algorithms that can sort in place, like quick-sort, rather than O(N) algorithms that require twice as much memory.
Algorithms that allow O(N) (in the best case, which is not likely here) will typically be limited by memory.  The example given, radix sort, becomes O(N log(N)) with large data elements, because the data is effectively variable-length - consider an integer that is 32,768 bytes - on a 64-bit machine, your first bucket might be based on the first 8 bytes, the second bucket on the second 8 bytes, but because of the very large possible range and the non-random distribution within buckets, most buckets will be small, leaving a few very large buckets to be sorted using an O(N log(N)) algorithm.  Also, this algorithm requires ""buckets"" to be allocated to hold elements for each radix, which will double the total memory requirement.
With small lists of elements that require very expensive comparisons, radix sort might be a good option, but the difference between O(N) and O(N log(N)) may not be as important with small lists.
Also, with very expensive comparisons, such as very large strings, some variation of a Schwartzian Transform would probably be helpful, and since each algorithm balances between memory and cpu, the optimal sorting algorithm will then be based on the choice between using more memory or using more cpu.
Extreme cases might favor a different sorting algorithm, such as nearly-sorted lists, but usually the cost of detecting those will be high, and making assumptions that an extreme case is true can cause big problems if there is ever a chance that it won't be.
Having said all of that, all practical implementations should attempt to use std::sort with a corresponding implementation of std::hash<> unless absolutely necessary, since std::sort can choose from more than one algorithm, depending on the input data.
",1,35707801
35709110,"
All of the well-known search algorithms are based on element comparison, i.e they check if an element is less, equal or greater than another element. Therefore they are absolutely independent of the range.
However there are special cases where the relative performance of certain algorithms can differ strongly from the average case. Examples for such cases are:

The elements are already sorted except a single element or a small subset.
The elements are in reverse order.
All elements are equal except one.

That's why for each sort algorithm, an average and a worst-case performance can be determined.
",0,35707801
35709304,"
The other answers are essentially right, in that generally sorting algorithms aren't better or worse based on the range of the inputs. However, there is at least one reason why an algorithm could be better or worse based on input range, and that is how they handle duplicate values. 
For example, Quicksort is worse on average when there are more duplicate values (see this question for an explanation of why), and when the range of inputs is greater, the chances of duplicates decreases (assuming they are distributed throughout the full range). 
",0,35707801
35696509,"
A quicksort that uses the last element as a pivot element is expected to overflow the stack for equal elements when implemented in a straightforward manner. This is how quicksort works. It is a ""defect"" in the algorithm. 
To see why just look at how the recursive function calls are created. 
The problem is that the quicksort(arr, 0, 99); will recurse for every element in the array. 
In your case your stack was full at 4039 elements. You seem to have about 8 integers worth of state in each of your calls, that will give you a hint on the max size of your stack. I'm guessing about 1 MB. 
This is not the case with random ints as the depth of the recursive calls will be evenly distributed between the left and the right part of the recursion. This desired behavior makes the recursive depth approach log N. For your MAX_SIZE this is a depth of about 17, instead of 100000. This is the reason quicksort is described as an N log N algorithm. The first N is from the partitioning.   
",6,35696167
35697183,"
A constant array with an end-pivot and splitting the array into two results in a recursion depth of ""number of elements in the array"", and O(n^2) time.
There are many ways around this.
First, partition the array into 3 components.  Greater, Less, and Equal to partition.  The equal goes between.  This fixes the corner case you ran into.  It increases the constant factor, but the quicksort cost becomes O(n lg m) where m is the number of distinct elements as a bonus.
Sorted arrays still die a horrible death.  Make a better partiton picker.  Random partitions make the probability of horrible behaviour near 0.  Picking 3 (or 2k+1) elements (maybe at random) and using their median is another approach.  For deterministic good behaviour, an algorithm to find an element berween the 30% and 70% mark in O(n) time is called ""median of 5"" (which is not just taking the median of 5 elements).
Another trick is to partition the array, recurse on the smaller partition, and loop on the bigger one.  This solves the recursion depth problem but not the runtime one.
Next, consider escape strategies for small array lengths.  Quick sort on (say) 8 elements may be seriously suboptimal compared to selection sort.  Once you have an escape strategy, you can optimisitcally use a fast and dirty quicksort (pick 3 random elements for pivot, etc) and track recursive depth.  If you pass 2*lg(n) depth, escape to provably correct quicksort (median-of-5 to find pivot).  And when you fall to less than 8 (tune this) elememts, switch to selection sort.
Finally, all of the above and more has probably already been done when you just std::sort.  So use it instead.
",2,35696167
35697303,"
You can guarantee the stack depth of O(log(N)) if you always recurse into the smaller half first and compiler generates tail recursion for the second call.
",0,35696167
35668627,"
In order to do the second part, you need to first realize checking comp(a[i], a[i+1]), and comp(a[i+1], a[i+2]) are not unrelated. The answer of the first might help you get the answer to the second.
To utilize it, first split the sequence to pairs,(a[i1],a[j1]), (a[i2],a[j2]),..., (a[i_n/2], a[j_n/2]). (such that i_k != i_h for k!= h, i_k != i_h for k!= h, and i_k != j_h for all k,h).
Compare each such pair. On average (assuming the bits are uniformly distributed), you will have n/4 conclusive answers of a[i] < a[j] or the other way around, and for the remaining n/4, you will have equalities.
So, first you can easily sort those with conclusive answer (the smaller at the beginning, the bigger at the end).
Next, you will recursively invoke the algorithm on the reminder. But here comes the ""trick"", if you know that for some i,j: a[i] = a[j], you don't need to get answer for both. Answer for one of them will tell you the value of the second as well. 
This means you can recursively invoke with only n/4 elements, and not n/2 (on average).
The stop clause will be when you have a single element, and just compare it to 0 to know its value.
This gives you complexity function of:
After some mathematics to find a close form for this recursive formula (or consulting with wolfram alpha), you will find that T(n) = (2n+1)/3
",2,35667917
35668751,"
I will not give you a full solution, but maybe it is enough to point you in the right direction. The problem gets probably a bit more clear, when taking the problem statement literally on what a comparison does:
The next step is to realize that you actually just have to count the zeros (or ones) to sort the array. However, whenever the numbers you compare are equal, you dont know if it was zeros or ones (otherwise you would need only n/2 ""comparisons""):
I basically compare the numbers in pairs, when they are the same, I dont know if it is zeros or ones (otherwise the problem is trivial) and I remember the index to compare it with the next pair of same numbers that I encounter. When they are again the same, I just have to remember how many of those pairs I encountered until I have one pair that is not equal to another pair. 
I didnt even try to compile the code yet, and it is not opitmal. It only works with even size of the array and I just realized that I forgot to add the temp_count when the loop finished. Once I have more time, I will fix it. However, it is sufficient to see how the complexity can be reduced:
The first comparison (1) executed exactly n/2 times and for average input, in 50% of the cases the second comparison has to be made. Not really the 2/3 n that was asked for, but it goes in the right direction ;).
",0,35667917
35640965,"
I think the main problem was that there was some confusion between the 'real' nodes and the nodes in your adjacency list. At least I got confused, so I split the structure into struct Node and struct Adj. The graph now has a Node* nodes[9] for the nodes.
and things almost instantly seem to work. The answer 
seems correct, [6 7 3 4 5] and [1 2 8 9]. See working example here
Please note that there are still numerous issues with the code, esp. with regard to memory management. Consider using a vector<Node> and a std::vector<Adj>. There are also uninitialized variables in the structs. 
",0,35635994
35633182,"
Many applications let the database perform most of the work.  
When tables are created, the application tells the database to set up columns for searching (indexing).  The database will usually create an index table of .  This makes searching faster because the order of the data in the table does not need to be sorted.  
The applications would send the database a query statement to choose data from the database in a needed order.  The application then iterates over the data.  
When displaying data in a GUI grid, many frameworks perform the sorting for you.  You tell the GUI which column to use for sorting and have the GUI resort and then display the data.  Real applications use existing libraries and frameworks as much as possible.  
If there is enough memory for your table, read the data in and sort the table.  Otherwise, tell the database to generate a new view and reload the table in the GUI (as necessary).  
",1,35631554
35607543,"
Your comparator is incorrect - since you are sorting vector<Descriptor> it has to compare two instances of Descriptor not vector<double>:
",1,35607233
35569170,"
Initially populate the indx with numbers 0 to len -1, and use indexed access for scanning and manipulating the array. Your current code has the potential to go out of sync with the input. And you don't need the tempData.
so something like this:
",4,35568983
35569221,"
the problem is you shouldn't swap the content of the array to get the right order, just ""flag"" it (you could see Hal's answer about the error explanation). this should produce the right output:
",4,35568983
35569184,"
There's a problem with your algorithm. Say the minimum value is in the last position. You store the last position in the first place of your array index. Then you swap the value there with the value in the first position. 
So now your last position could well contain the minimum of the remaining values.
Instead initialise your array of indexes with
{0,1,2,3,4,5,6 ...}
then sort that array based on the values of the data at those indexes.
",2,35568983
35569244,"
The index array stores the index of the last position during the sorting process, instead of the original index.
So initialize the index array with the original index
Also swap the index during your sorting process
",1,35568983
35569709,"
here is the logic error.
Each time an element is selected for processing, and it requires movement from its position, the index of the element changes as well
for example, after processing the first element (8.5) at index 0, it gets moved to the index of the smallest element at index 12 and so on.
the solution that involves the use of ""flags"" seem appropriate
",1,35568983
35567794,"
Consider:
You set the array index (index1, index2) to the number of games.
That's not guaranteed to be less than the # of elements in the teams array.
So you wind up accessing the teams array out of bounds == segfault.
More Info: Compare your code to the site you got the algorithm from:
Index is the position in the array, where array[index] is the value.  In your case, you are doing the comparison in the (inner) while loop correctly:
but you set the indexes incorrectly:
To make it more concrete, suppose there were 10 teams, but the first team (team #0) played 1000 games.  Then your code does this:
The problem is teams[1000] isn't valid if there are only 10 teams and when you access an array out of bounds like this in C, you get a segfault (if you're lucky) or corrupt memory and/or a security bug (if you're unlucky). 
Also, the suggestion made in comments to learn a source debugger (GDB, or whatever - depending on your platform) is critical to learning C.
",2,35567688
35563805,"
Try this instead:
By the way... there are certain optimizations you can to to your bubble sort method. Remember that each pass requires one test less, since one element gets stuck in its definitive position. This helps a lot when it comes to performance, if you have to sort long lists.
",1,35563636
35548086,"
Following on from the comments on the OP; you can refactor the lambda into its own functor for use the std::sort, or you could use a C++03 style by combining the std::greater, std::mem_fun with a bind (possibly std::bind) of some sort etc.; the C++03 style will be cumbersome to work with though.
The functor solution requires the call operator (operator()) to have the appropriate signature; accept the required values and return a bool, the const method and const& parameters are not needed, but by convention usually appear.
The float return from the area() function will work as expected with the operator >.
But considering the language level, ease of readability etc. your lambda is possible still the better solution.
The C++03 style is unwieldily to create and use in this case, I would not venture too far down this road.
",3,35547736
35549574,"
You may create a class for that:
And then
Demo
",3,35547736
35545691,"
First of all the sorted indices were {1,2,0,3,4} 
By using only for and if you can do it like this 

Output:
Original Array
7 4 5 8 22 
Sorted array
4 5 7 8 22 
Sorted indices are
1 2 0 3 4

",2,35545010
35545494,"
the possible solution is to create an array of pairs {value, index}, sort them by value (use std::pair which already has appropriate operator <) and read indexes from sorted array. It should be easy to write.
Another solution is to create an array of indexes and sort them using values from the first array. In c++11 it may look like this:
iota is used to fiil an indexes vector. Indexes is compared by values from the original array [l_idx] < array[r_idx]
Yes. It isn't ""fors and ifs"" solution. But you don't need them. Just use the sort function the way you need
",4,35545010
1181250,"
It is possible to use standard function if your type implements ""bool operator < (...) const"" and a copy constructor (compiler-generated or custom).
Alternatively, you can pass an ordering function (or a functor) as a third argument to sort() instead of implementing operator ""<"".
This is useful in the following situations:

you don't want to implement operator ""<"" for whatever reason,
you need to sort a container of built-in or pointer types for which you can't overload operators.
you wish to sort the sequence using different orderings. ex: sometimes you want a struct with first/last name members sorted by first name, other times by last name. two different functions (or functors) make such options trivial.

",11,35543056
1181688,"
There's three ways to do this: 
You could overload operator< for your class: 
This has the disadvantage that, if you ever want to sort them according to b, you're out of luck. 
You could also specialize std::less for your type. That makes std::sort working (and other things, like using the type as a key in a map) without hijacking operator< for this meaning. It does, however, still hijack a general-purpose comparison syntax for a, while you might, at other places in your code, compare your type according to b. 
Or you could write your own comparator like this: 
(Note: The const after the operator isn't strictly necessary. I still consider it good style, though.) This leaves the general-purpose means of comparison undefined; so if some code wants to use them without you being aware, the compile emits an error and makes you aware of it. You can use this or other comparators selectively and explicitly where ever you need comparison. 
",4,35543056
35544016,"
Just one line. Fix noted in comment:
Comment: in mergeSort, rather than allocate left and right, the code could use arr instead of left, and arr+mid instead of right. Two less allocations. An entry / helper function could do a one time allocation of a temp array the same size as the original array, and pass that as a parameter to mergeSort() which would in turn pass it as a parameter to merge(). In that case, all mergeSort does is create pairs of indices on the stack, and merge does the actual merge and copy back.
Although probably beyond the scope of this class, the copy back can also be eliminated with two mutually recursive versions of mergeSort, one where the merged data ends in in the original array, call this mergeSortO(), one where the merged data ends up in the temp array, call this mergeSortT(). mergeSortO() calls mergeSortT() twice (left and right halves), then calls merge() to merge from temp array to original array. mergeSortT() calls mergeSortO() twice (left and right halves), then calls merge() to merge from original array to temp array, or if size is 1, it copies one element from original to temp array.
Also probably beyond the class, another alternative would be bottom up merge sort, as most libraries such as STL std::stable_sort() use some variation of bottom up merge sort. 
",0,35542628
35525065,"
You can't make an array with range n when n isn't intialized.
Further, you currently use i with the value n in the if-statement. That will not work. You are accessing outside the values just entered in the array and - worse - outside array boundaries.
You need a loop for the check:
However, in C++ it is much easier to use the standard containers instead of old C-style arrays. Use vectorand set like this:
Finally notice that the vector isn't used for solving your problem. The setis sufficient for that. I used the vector so that input data was still saved somewhere in case you needed to do more with it - if not, you can delete the vectorpart.
For your second program:
Google: ""wiki bubble sort"" and you'll find  https://en.wikipedia.org/wiki/Bubble_sort
Comes with pseudo code and all.
",0,35524998
35520541,"
The inner loop is surely wrong here:
should be
Also, the condition at the end of the loop
is excessive. It is satisfied by definition after the inner loop exits.
See: Sorting algorithms - selection sort for the pseudocode and a nicely animated demo on different kinds of data.
",2,35520460
35520544,"
In the inner loop of the sorting loop, you have written: for( int j = 1; ...)
Now, every time, the inner loop is not going from 1 to n-1, but instead is going from i+1 to n-1
So change the loop to for( int j = i+1; ...)
Also, you may change the swapping condition to small != i, but this is optional.
",0,35520460
35520856,"
I've inspected your code and you have a logic error for the selection sort to succeed. In the inner loop, the initialization of the inner loop is always j = 1. This should change to:
and also change the condition value of your outer loop to i < n to ensure the loop goes from start to end.
",0,35520460
35520936,"
The inner loop should be 
And if they small is not equal to I variable then swap
",0,35520460
35512911,"
bool is a type that usually accepts true and false. Internally it is handled as an int. That is why you can assign numeric values to it. However, if you would like to do this, use int.
Also notice that your line with:
has no effect. You compare flag to 2 and the result of this comparison (either true or false) is just left in the air. This is not an error but the whole expression does not do anything.
",2,35512834
35513145,"
The variable flag only ever holds one of two values, so this would work, leaving your other logic (may not be the most efficient), ""as is.""
",2,35512834
35512993,"
A bool can only be true or false, it is binary. You can assign 1 or 0 to an int to get the same result as if you had used a bool if you don't want to use a bool. 
Also you use == which is to check equivalence. A single = is for assigning a number which it looks like you want to do when,
It should be declared and int (or something similar)
",1,35512834
35473095,"
You are reading uninitialized memory. You are copying elements from data to indx, but only when data[j] > data[j + 1]. When that isn't true twice in a row, you have an element of indx that isn't assigned a value. It has an indeterminate value of random bits left by whatever used the memory before, and reading it is undefined behavior.
",1,35472975
35461591,"
Here is an example from here:
You provide a lambda that gives the logic about what criteria you are sorting with. In your case, the criteria will handle the Center variable. a and b are any two elements in your vector that are being compared.
In your case, yours will look something like this (I'm not at a compiler at the moment to test, and the specifics of your sort logic may be different than I understand):
",3,35461446
35462039,"
Considering the fact that your example is wrong (77 should come before 128) you might want to use std::sort like this:
The problem here is that if you were to have: 75 and 125 it will put 75 first (if that was inserted first), as pointed out by James Adkison.
Live example
",0,35461446
35430007,"
An iterator doesn't represent the value, it represents some position in a container, stream, or stream buffer. Essentially, they are a generalization of pointers. Some iterators will let you modify what they are iterating over using indirection (*it).
In the simplest case, it could simply be a pointer. Consider this code:
An iterator provides much the same functionality (depending on the type of iterator).
",4,35429845
35417951,"
In your Sort function, you're seeking on byte boundaries, rather than on int boundaries (4 bytes usually). Instead of 
do
(You could have done * (j-1) but you swap if the first is smaller than the second, so you need num2 to be the next number, not the previous.).
I optimized out writing to the file if there are no changes, but other than fixing that index, there's no change:
Notes:

I had to compile with -fpermissive due to odd warnings
Reading and writing files like that is extremely slow.

",1,35417647
39969735,"
The program compares if arr[i] is less than arr[i-1], this may fail in case like 10000 1 1 1.
The solution that is O(n) it would be making the average and the change every number to the average number.
",0,35416696
35403975,"
Ok, there are several things wrong here.  First, you are not going to be able to do a one pass sort by just swapping adjacent elements.  That would be an O(n) sort, and if you managed to implement that, you would be an instant computer science celebrity.  Your professor said you can't use arrays?  If by ""arrays"", he/she meant any kind of in-memory buffer, then that's just silly. If you want a sort that doesn't use arrays, in a literal sense, just use a std::map.  Insert the numbers into the map as you read them from the file.  Then, use an iterator to retrieve the numbers in sorted order, printing them out as you do so.
Secondly, you are doing some things with file io that are probably not what you want.  In your loop where you read pairs of numbers from the file and then possibly swap them, your control flow allows for the pair of numbers to be written twice to the file, in the event that they are in sorted order.  Also, you construct one, or possibly two, ofstream objects in each loop iteration.  Each new output stream starts at the beginning of the file, so you're repeatedly writing to the beginning of the file.  You also don't seek your input stream to the beginning of the file before printing out the ""sorted"" contents. The reason it's printing out the same number 4 times is that it's reached the end of the file, and isn't assigning any new value to ""number"".
My advice would be to really avoid trying to read and write to the file at the same time.  Read the numbers in (not to an array, mind you ;) ), sort them, then output them. (From the assignment spec, it doesn't seem like you have to write them to the file again, but I'm not sure).    
",1,35402849
35403575,"
From what I can tell you keep recreating your output stream which means you keep writing to the beginning of your file.
In your compare function:
",0,35402849
35404361,"
Hmm, to sort a bunch of elements, whatever algorithm you use, there will be a time where you have at least to store one element (or its index) in a specified place in its storage => what ordinary programmers called using an array (or array or indexes).
Your requirement could be understood in two ways:

you cannot use arrays but are allowed to used other C++ containers. Fine, take a vector (that you use like an array once filled), or a map as suggested by @c_dubs. Maybe, but if I gave a requirement for not to use arrays and not explicitely allow C++ containers, I would not be pleased with that solution
you cannot use in memory storage at all. You must directly sort you file (or a copy of the file) on disk. If you follow that path, just use fseek to move pointer on file, and you will be able to read and write elements directly at a defined position on disk. That is enough to use any sort algorythm.

Beware: my advice is to use direct disk sorting for that assignement, but never do that in real world! Anyway it can be useful where sorting large number of elements, to split the initial data in bunches small enough to be processed in memory sort them and store them back to disk and then merge those sorted files. It is the only foolproof way to sort data that could not be loaded in memory.
",0,35402849
35405455,"
My guess is that you're allowed to use variables to hold numbers from the file and multiple files to hold temp data (or a single file that you random access as if it was 4 files). You could implement a bottom up 2 way merge sort using 4 files. It would be similar to the 4 tape drive sort mentioned in the wiki article on merge sort.
http://en.wikipedia.org/wiki/Merge_sort#Use_with_tape_drives
",0,35402849
35400988,"
You could take a look at std::sort 
http://www.cplusplus.com/reference/algorithm/sort/
You can create a custom comparator to compare the part of the objects you wish to compare.
",0,35400786
35400989,"
If you want any ordering (sorting) beyond the default (using operator <), you will have to write your own comparison function.  
Let's have a class:
The std::sort function will be passing references to two objects.  The comparison function needs to return true if the first argument comes before the second.  
If there is a std::vector of these objects, then use the std::sort function:
",0,35400786
35393797,"
In the case of Microsoft, std::list::sort uses an array of pointers to the first node of a list, where array[i] is either NULL or points to a list of size 2 to the power i (1,2,4,8, ... ). Nodes are taken from the original list one at a time and merged into the array, then the array is merged to form a single sorted list. Assuming compare overhead isn't excessive, this is a memory bound process, and multi-threading won't help due to the overhead of scanning a list to split up the list, nearly doubling the number of memory read operations. Here is example code for this type of list sort with the restriction that the compare is < not <=, so the operands have to be reversed to keep the sort stable.
",0,35390558
35373562,"
From my perspective, using vector would be a lot easier, and this is C++. However, if you are just doing this for the sake of learning, then you can dynamically allocate arrays like suggested.
",1,35373393
35373793,"
The technical equivalent of a variable length array allocates from the stack using alloca (the name may vary), but this is not recommended, since a large array will result in stack overflow.
Use new and delete[] as suggested in user3886450's answer.
",0,35373393
35353013,"

Luke,
You have defined the size of the array already. So it is not a dynamic array. It is a pointer to an array that has a size of 5 and can hence only store up to 5 ints.
So you basically have allocated enough space to hold 5 int. This means that if you try to store more than 5, for example the 6th int at index of 5, you are trying to access memory that is not yours to claim.
for example here you have:

[] [] [] [] [] 
1  2  3  4  5  
is good
[] [] [] [] []
1  2  3  4  5  6  7  8  ...
cause the heap corruption.
Might I suggest std::vector ?
",1,35352747
35350164,"
Problem:
You intialise swap to 0.  As swap is a pointer to bool, you have a null pointer.  
You later dereference this pointer without ever having it point to a valid bool object:  
Tha is UB and this is why you get an access violation ! 
Solution
Either you define this variable as plain object bool swap = false; and use swap everywhere.  Or you initialize it correctly bool *swap = new bool{false}; and you use *swap everywhere.
Miscellaneous advice:
Attention: bidArray is allocated with new[], so you have to delete[] it or risk undefined behaviour ! 
In pointer definitions, take the habit of puting the star next to the variable and not to the type.  Why ? Because optically it is confusing:    
",0,35350081
35350026,"
An elegant way (in my opinion) of doing this would be as follows
Here I used the sort method with a custom comparator, ask me if you need help understanding the syntax. 
",0,35349918
35349185,"
I hope you are patient, because there are quite a few possible combinations.
You don't allow 0, so the total is slightly less than 2128 possible combinations. There are only 4,294,967,2954 of them, or 340,282,366,604,025,813,516,997,721,482,669,850,625.
So if you could process a thousand million of those per second, then it would only take 10,790,283,060,756,779,982,147 years to do the computation, give or take the lifetime of a universe.
It's possible that you will need a better strategy for finding the correct solution than a brute force enumeration of all possibilities.
",3,35349007
35349081,"
Simply with several loops:
",1,35349007
35333914,"
This line:
Makes no sense to me. Essentially your routine doesn't bother to sort sub-lists of lest than 10 elements. 
Why? It's a recursive algorithm and needs to sort down to lists of 2 items to finish properly. 
As I said in my comment test your recursive algorithm from small to large sizes.
The error will pop out very quickly.
",0,35333486
35331342,"
This is just simple step by step bubble sort problem.
just make two functions as bubble_asc(), bubble_desc()
and call it from the main function(). 
",0,35330606
35307643,"
Clearly you were not swapping the items correctly. 
The problem is in these three lines:
Change the first line to index byj, not i
",1,35307604
35285393,"
If you want to merge them in one of the two vectors, I'd suggest std::inplace_merge:
For parallel execution: The experimental C++ Extensions for Parallelism, ISO/IEC TS 19570:2015 has std::experimental::parallel::inplace_merge which will probably be part of the standard some time in the future. You can find an implementation for the parallel merge algorithms in the CodePlex Parallel STL project which is the Microsoft prototype of the Parallelism Extension.

Edit:
Removing duplicates can be achieved by using std::unique.
",3,35285108
35281790,"
Your classes need a copy constructor (or a move constructor) and a custom assignment operator because they manage raw pointers (resources). Otherwise when std::sort performs assignments of your point or key objects, the corresponding objects' data is not deep copied, but only the pointers are copied. Your destructor then ends up freeing the memory for pointers that point to the same memory address, which results in undefined behaviour (you'll often get a segfault on Linux/Unix). Also, remove those malloc/frees and replace them by new[]/delete[]. Or better, use standard containers like std::vector.
Note that some compilers can catch this issues at compile time. For example, gcc with -Weffc++ spits out an warning:

warning: struct Foo has pointer data members [-Weffc++]
  but does not override Foo(const Foo&)

",3,35281726
35260267,"
First of all, there need not be any negative zeroes in standard C++, so I assume you are talking about the negative zero from IEEE-754, which is what most (I never encountered an exception) C++ implementations base their floating point math on.
In this case, the expression
will yield -0.0 only if either y == -0.0 before that assignment or if you set your rounding mode to ""round towards -INFINITY"", which you usually won't.
To actually produce a double with the value -0.0, you can just assign the desired value:
Now d == -0.0 in IEEE floating point math.
However, as 

Comparisons shall ignore the sign of zero

(IEEE 754-1985, 5.7. Comparison), -0.0 < 0.0 will yield false, so if you actually want to sort negative zero before positive zero, you will need to write your own comparator, possibly using std::signbit.

Appendix: Relevant standard quote:

When the sum of two operands with opposite signs (or the difference of two
  operands with like signs) is exactly zero, the sign of that sum (or difference)
  shall be + in all rounding modes except round toward –INFINITY, in which
  mode that sign shall be –.

IEEE 754-1985, 6.3 (The Sign Bit)
",4,35260063
35257493,"
It should work to do std::sort(a, a + n); - of course, whether that is allowed when you are not allowed to use standard containers is of course a different matter.
",0,35257401
36441299,"
Temp is a char and strcpy expects a char *(and compiler will give a compilation error in your case).
Use a char array instead- 
And then pass it to strcpy.
",4,36441272
36441542,"
Sorting an array of names could be done much easier:
",3,36441272
36369846,"
The function you are looking for could be std::partition, if all you want is to have the nulls at the back. If you also need sorting for the other values, std::sort is the right choice. Both allow you to define a comparison which defines the sorting or partitioning order, allowing you to customize how the elements are sorted.
",1,36369514
36369718,"
You can just use std::sort with a custom comparator:
This assumes that your custom type defines operator<. You can, of course, use anything else you like to compare them.
If you have to implement your own sorting algorithm, you can still just inline the body of the comparator function into the middle the sorting code.
",1,36369514
36355573,"
For a statement like student[j+1].getBal()=temp; to make sense, getBal() would have to return a reference to a member variable of the class. Your statement would then modify the value of that member variable through that reference.
But don't do it that way: the more normal thing to do would be to provide a setBal() method that takes a double as a parameter.
",3,36355483
36355683,"
student[j+1].getBal()=temp;
function call are ""Rvalue"". This mean that you can't assign them.
What you're doing is a bit like trying to write 1 = temp. 
",0,36355483
36355088,"
Here you are.
The program output is
Take into account that it would be simpler and the code would look more clear if you use the standard C function qsort instead of writing the bubble sort function manually.
For example
The output will be the same as shown above
In C++ you could use standard algorithm std::sort declared in header <algorithm>.
For example
The output is
",2,36354609
36344370,"
Instead of copying from the list at the beginning, Just keep track of where you are and do a merge into a new output list. When done, REPLACE the old values with the new ones. Don't use v.insert(). v[idx] = output[idx2]
OR
You can keep your two input lists, but you still need to REPLACE the value in your list. v[idx++] = value. idx needs to start at the beginning of the first list. 
In either case, you might think about using iterators instead of indexes. This way you can avoid passing the vector. You don't need random access to the structure to write a merge sort. It should work with a std::list. You can traverse the elements by using ++iter.
",0,36342213
36342714,"
One of the drawbacks of using quicksort is its stability. Certain data sets need more steps to be sorted than others. For pathological cases it may even scale as O(n^2). I measured the number of comparisons performed by quicksort for your test data and saw that at with 700000 steps there are less comparisons to be performed than with 650000 elements. Even though your data sets seem similar, apparently for quicksort they are not. There are ways to improve quicksort's stability, see for example Programming Pearls.
Here are the measurements:
time for 650000 elements: 4.41251 s. num. comparisions 5061169826
time for 700000 elements: 3.37787 s. num. comparisions 3824058435
time for 750000 elements: 6.07856 s. num. comparisions 6900645055
And here the corresponding code: gist
",2,36340420
36334880,"
In the loop where you find the minimum index, you must compare the current item at index j with the item at the current index of the minimum item:
You always compare with the item at index i and hence don't account for updates on minIndex.
",1,36334344
36316395,"
Instead of having a Graph data member in SortByFutureVolume you should have a Graph & or const Graph & if g can be read only.  This way, anytime the SortByFutureVolume is copied the Graph is not copied.
As pointed out by Benjamin Lindley in the comments if You change SortByFutureVolume to store a pointer to the Graph instead of a refernece then SortByFutureVolume becomes copy assignable as pointers can be assigned but references cannot.  That would give you
As a side not it is okay to have _g as a variable name in a function parameter as it does not start with a capital letter but it is a good habit to not use leading underscores.  This is doubly true in the global space where _g would be an invalid identifier as it is reserved for the implementation.
",4,36316281
36316325,"
std::ref is a pointer in disguise. What the code does is that instead of copying a heavy-weight SortByFutureVolume object, it copies around the pointer to the same object - which is obviously much faster.
The option would be to make the Graph g a (const) reference inside the sorter object.
",3,36316281
36316603,"
Your SortByFutureVolume was making a copy of whole graph each time it was being copied, and std::sort does a lot of copies by value of comparison function object.
see here:
http://coliru.stacked-crooked.com/a/49b9cdad8eb3bc06
for simple std::vector<int> sort it made internally 20 instantiations of SortByFutureVolume class. This same number of times your graph was probably copied. 
std::ref copies only reference to your comparison function object - this removes all the deep copies and so also speeds up whole thing.
",2,36316281
36316797,"
The prototype for the std::sort variant you are calling is
(see http://en.cppreference.com/w/cpp/algorithm/sort)
The compiler thus deduces that when you pass an unqualified SortByFutureVolume(g) you are passing by value. Constructing the temporary with your definition of SortByFutureVolume requires a deep copy of the graph. Potentially there is then a second copy made as the temporary is passed by value. If this parameter is passed by value within sort, further copies will be made.
When you use std::ref() the compiler can deduce that the third argument is a reference and so the pass becomes by reference, eliminating secondary copies of the graph.
As others have pointed out, the solution is to make member g a reference and make the constructor accept by reference.
of course, if you have a C++11 compatible compiler, you could just use a lambda:
",2,36316281
36309897,"
If you look at the signature, std::sort takes its comparison object by value:
So when you write:
your object gets sliced, and you end up trying to instantiate a function which takes an abstract class by value, hence all the errors you end up with. 
What you need to do is ensure that even though sort takes its comparison by value, you pass yours in by reference. Thankfully, there's an app for that! Just use std::ref:

That said, do you really need a polymorphic comparator? If you're just passing in different comparison function objects into the FilesList constructor, you should prefer to just make it a function template:
That way, you can just directly forward in what the user passes and avoid virtual dispatch.
",4,36309702
36309950,"
Your FileSorter argument is defaulted to a SortByExtension object rather than a SortByName object. As you haven't included the source of SortByExtension, I would start by checking that function signature of SortByExtension's function call operator is
If there are any differences between the base class and derived class function signatures, the derived class function won't override the base class one, and the derived class will be treated as an abstract class.
",0,36309702
36326259,"
I solved it. Turned out that forceing repaint() works, but wasn't best solution either. I searched to ""previous"" functions and I noticed there was break; missing in one case of switch .
",0,36304611
36302216,"
Your ""h function"" is a hash function, it takes a key as the input and returns a position of the key in the hash table.
A simple hash function can be return key % tablesize.
Apparently such simple hash function may result in different keys having the same position, known as ""collisions"". Choosing a proper hash function and choosing a way to solve the collisions is a broad topic.
There are some situations when we can find a perfect hash function to avoid collisions, and that's an even harder topic.
Normally in a hash function we don't search the whole hash table and find an empty position to return, because we expect the hash function takes O(1) time.
",1,36300865
36302139,"
Here is an example of a Hash Table for general demonstration purposes.
HashMap.h
HashMap.cpp
And here it is in use:
main.cpp
Now you can take this class and change the key and value to any type suitable, but even more to make this reusable and generic; you can easily template this class. Also if you are using a modern compiler, instead of using raw pointers, you can exchange them for smart pointers such as std::shared_ptr<> or std::unique_ptr<> that way you don't have to worry about memory leaks. However, to take this a step further you can simply just do this in your code:
",0,36300865
36302393,"
Yes， it's the naive quick sort. But you choose the middle element instead of the last element as your pivot.

When you fill a vector [max-num, 0], it's actually not the
worst-case scenario at all. Because each time you choose the
middle element as the pivot, you divide the vector into two parts
with almost the same size, so the time complexity is O(nlogn).
However, when you fill the unsorted vector [0, max-num/2] then [max-num/2, 0], it's the worst-case for you algorithm as you divide the vector into two parts with one extremely long and one extremely short. So the time complexity is O(n^2).

To gain a better performance on almost all vectors, you can:

pick a random element as your pivot
pick three random elements and choose the second largest one
when the size of vector is small enough, e.g., smaller than 10, apply insert sort on it
to deal with the situation that all elements are close to each other, you can do some extra work before recursively sorting subvectors to skip the elements equal to the pivot

",1,36300001
36299163,"
the member variable const int num_courses_; is const, which means it must be set in the initializer list of the constructor.
num_courses_ can't be set by the copy assignment operator Student& Student::operator=(Student&&), so it prevent the compiler from generating the copy assignment operator for that class. Since there's no copy assignment operator available, and the std::sort function needs it to work, the compilation fails and complains about the copy assignment operator not being available.
Simply remove the const and declare the variable as int num_courses_ and your code should work.
",2,36298778
36301652,"
Use the standard library and not just for sorting. Use std::vector if the number of elements can change or std::array if not.For your particular use case you can use what @Galik wrote.
",0,36297995
36288351,"
Sorting will always be the same complexity... You mean sorting an array filled with pointers to things you want to sort?
Sometimes it might be faster (faster execution, not complexity). This is because changing places of pointers may be faster than changing places of some complex objects.
",0,36287326
36285640,"
The loops that sort the array should look at least like
",1,36285549
36274032,"
Your compareId() needs to be a static function or a standalone function. The list's sort() method does not accept an object on which it can call a non-static object method.
",3,36273983
36239835,"
I think your problem is that you expect the ""sort"" function to return a value; it does not.
The ""sort"" function does not return a value, because it was defined with a ""void"" return value therefore trying to retrieve any data from the variable ""sort"" will not work (or should not, anyway).
Arrays are passed-in to functions by reference; This means that all of the changes done to the array within the sort function are are still there once the function returns; because of this, you should be outputting the ""grades"" array, not a non-existent return value.
EDIT: I believe that your problem is at the line:
Trying something like this instead:
EDIT 2: Also, change the line: 
to just:
EDIT 3: It turns out that there are a few problems with the ""sort"" function.  The first, and worst, problem is that the variable ""min_value"" is being used without being defined.
Once I changed this, the program would run, but the ""sort"" function did not work properly.
This brings me to the second problem:  The variables ""min_value"" and ""min_index"" need to be reset for every iteration of ""i"".
The final problem is that, within the ""j"" loop, ""min_value"" is assigned to ""x[i]"", whereas it should be assigned to ""x[j]"":
should be:
I fixed the function and tested it to make sure that it works. 
Here is the code.
",1,36239686
36235781,"
Notice the Merge1 function call Merge1(v, m, v+m, r-m);, and refer to the function declaration:
As the intended parameter L1 and L2 to be the length of the vector, the left part ranges from index l to index m, so the length of the left part is m-l+1, the right part ranges from index m+1 to index r, so the length of the right part is r-m. 
To sum up, the implementation of Merge1 function is ok, but the function call should be Merge1(v+l, m-l+1, v+m+1, r-m);. So the MergeSort function should be：
The revised code has been tested ok on my computer, see if it works for you on your data.
",3,36234301
36227066,"
The code
should be a no-op, since that's an empty range. The code
will sort the entire contents of myvec. If these happen to do the same thing, it means that your vector was already sorted. The first line is almost certainly a typo or a bug waiting to happen.
",4,36227019
36227548,"
Iterators are just a way of specifying range. You must have bad intuitions about them if you have even thought that this code could work properly. What if we used method that takes 2 indices -> begin index of the part of vector being sorted and the index indicating end of it. Would sort(0, myvec.size()) and sort(0, 0) be equivalent?
This code should undoubtly be sort(myvec.begin(),  myvec.end());
",1,36227019
36216839,"
Just write
",2,36216782
36216879,"
You can directly use std::vector::operator< (it will do lexicographically compare), example:
outputs 1. 
Here you can find vector implements also other operators: =,!=,<,<=,>,>=
",2,36216782
36201469,"
You can nest loops inside each other, including the ability for the inner loop to access the iterator value of the outer loop. Thus:
Would repeat your loop with an increasing start value, thus repeating with a higher initial value for i until you're gone through your list.
",2,36201379
36211876,"
Suppose you have a routine to generate all possible permutations of the array elements for a given length n. Suppose the routine, after processing all n! permutations, leaves the n items of the array in their initial order.
Question: how can we build a routine to make all possible permutations of an array with (n+1) elements?
Answer:
Generate all permutations of the initial n elements, each time process the whole array; this way we have processed all n! permutations with the same last item.
Now, swap the (n+1)-st item with one of those n and repeat permuting n elements – we get another n! permutations with a new last item.
The n elements are left in their previous order, so put that last item back into its initial place and choose another one to put at the end of an array. Reiterate permuting n items.
And so on.
Remember, after each call the routine leaves the n-items array in its initial order. To retain this property at n+1 we need to make sure the same element gets finally placed at the end of an array after the (n+1)-st iteration of n! permutations.
This is how you can do that:
and here is an example of the routine running: https://ideone.com/sXp35O
Note, however, that this approach is highly ineffective:

It may work in a reasonable time for very small input size only. The number of permutations is a factorial function of the array length, and it grows faster than exponentially, which makes really BIG number of tests.
The routine has no short return. Even if the first or second permutation is the correct result, the routine will perform all the rest of n! unnecessary tests, too. Of course one can add a return path to break iteration, but that would make the code somewhat ugly. And it would bring no significant gain, because the routine will have to make n!/2 test on average.
Each generated permutation appears deep in the last level of the recursion. Testing for a correct result requires making a call to ProcessThePermutation from within ProcessAllPermutations, so it is difficult to replace the callee with some other function. The caller function must be modified each time you need another method of testing / procesing / whatever. Or one would have to provide a pointer to a processing function (a 'callback') and push it down through all the recursion, down to the place where the call will happen. This might be done indirectly by a virtual function in some context object, so it would look quite nice – but the overhead of passing additional data down the recursive calls can not be avoided.
The routine has yet another interesting property: it does not rely on the data values. Elements of the array are never compared. This may sometimes be an advantage: the routine can permute any kind of objects, even if they are not comparable. On the other hand it can not detect duplicates, so in case of equal items it will make repeated results. In a degenerate case of all n equal items the result will be n! equal sequences.

So if you ask how to generate all permutations to detect a sorted one, I must answer: DON'T.
Do learn effective sorting algorithms instead.
",1,36201379
36179187,"
Rather than break down each step in the algorithm I'm going to tell you what it intends to accomplish which you can use to understand how it works. This looks like it is doing what is called an LSD radix sort.
If you've ever used a card sorter (hard to find nowadays) it does the same thing as this algorithm. The idea is to start with the least significant digit and work toward the most. The card sorter would have 10 bins -- one for each digit. A column (exponent) will be selected and the cards will fall into the proper bins depending  upon what digit it had for the selected column.
What the algorithm is doing is counting the number of records with each digit in the given exponent column then outputs that many records in order. Actually, it uses the counts to compute an offset into the output array.
Now with the records in order for a given column (exponent) it moves to the next higher exponent.
Edit: embellished somewhat.
",2,36178085
36183045,"
The j loop converts the counts into the ending index (1 + index to last element) for each bucket. The k loop moves the elements from last to first into the buckets based on the current digit. The process starts with the least significant digit, and ends with the most significant digit.
An alternative is to convert the counts into starting indexes, where the first index == 0, the second index == number of elements with '0' digits, ...  (number of elements with '9' digits doesn't matter and isn't used). The radix part of the sort would sort elements from first to last. 
In either case, the size of the buckets is variable, and the end of one bucket is the start of the next bucket. When a radix sort pass is completed, then there are no gaps between the buckets.
",1,36178085
36120948,"
Your countingSort function has a problem:

you should use an array of 10 indexes for counting instead of finding the largest element and declaring int C[m].  Your current code allocates a potentially huge array in automatic storage, invoking undefined behavior.

Here is a corrected version:
Note that this algorithm cannot sort an array with negative numbers.
The Hollerith algorithm uses least significant digit to most significant digit. It was invented for sorting US Census data tabulated on punched cards using tabulating machines. This is a very early example of computing for data processing that goes back to 1887. Punch cards used 2 different character encoding schemes named H-code and T-code all the way to the end of the 20th century, H standing for Herman Hollerith, inventor of these sorting machines, who died in 1929. (see http://ed-thelen.org/comp-hist/Knuth-Sort.html )
For the most significant bit down to the least significant bit, you need recursion, not an iterative method like the one you have:

Find the maximum value, hence the maximum exponent to get the most significant digit.
Sort the array according to the current digit
For each bucket of elements with the same digit at the current position:


if the bucket is empty or has only one element, it is sorted
otherwise, recurse on the bucket for the next lesser digit, using exp/10.


You can do this with any base >= 2.
",0,36120783
36119539,"
Not only do you need a comparator, but you need the other concepts required for std::sort to work as well. Specifically:


RandomIt must meet the requirements of ValueSwappable and RandomAccessIterator.


Therefore, I hacked a generic swap implementation. Note it uses implementation details:
The comparator can be similarly straight-forward, and looks like:
In all cases we simply defer to a standard library algorithm to do the work, recursively passing *this as the comparator!
Full Live Demo: Live On Coliru
Printing:
",1,36117142
36115154,"
You could use something like this:
Consider its part of STL and its well implemented.
",1,36115106
36115213,"
If you want to insert an element directly at the right place in a sorted vector, you should use upper_bound to get an iterator and pass it to insert to place the element at the right place:
Note that upper_bound will be fast (O(log n)) but inserting can be slow (O(n)) because it will have to shift all the elements that are after the insertion point.
However, inserting at the end of the vector and calling std::sort is O(n log n) so it's worst, at least on big vectors !
Another option could be to insert at the end of the vector and then shift with previous element until it's lower or equal. In this case, the insert is amortized O(1) and you have to do O(n) swaps.
I'm afraid there won't be an O(log n) solution as you could have with a list.
",1,36115106
36115189,"
Consider storing the values in a MAP instead.
",0,36115106
36115278,"
You can check the answer of 101010. I think it is very explanatory. You can analyse this with your case.
",0,36115106
36098447,"
The issue is that you cannot simply pass non-static member functions as part of the std::sort predicate.  
The simplest solution, given your code now, is to make Database::sortyByName and Database::sortById static member functions.

Note that there are various other solutions, such as using boost::bind, function objects / functors, and with C++11, lambdas.  I won't go over them, but just to give you other options.  
",2,36098367
36098952,"
You cannot use non-static member functions in std::sort(), please make your function non-member functions or make them static members(as you have already figured this out). The implementation of the code with non-member sort functions.
Database.h
Non member sort functions implementaiton (Notice removal of Database::)
An example how to use std::sort
",1,36098367
36098445,"
Irony at its best, I've been searching online for hours for a proper resolution to my problem, so I decided to ask the community here. While waiting for an answer, not long after, I found a possible solution to my problem. As for now, I am able to compile and build the solution, but I have not yet tested it to see if it works as expected. Here is what I've found to resolve my compiling issues.
I changed the 3 sorting functions declarations & definitions within my database class from the previous signature above to the following:
and I moved them from the private section to the public section. I made the functions both public and static, I removed the const reference from the parameters. Now my source file compiles and I am able to build with 0 errors. Now it is just a matter of time to test out my class.
Edit 
After reading a comment from a community member from my question above, I think that the major issue was the functions not being static. So now that I have the static storage for the method calls; I'll try to see if I can add the const reference back to the function signatures. 
",0,36098367
36096678,"
First note, big-O and raw performance have a complicated relationship.  In the case of heapsort, poor memory locality will cause it to scale worse on computers than big-O would suggest.  By contrast shell sort is only very slightly worse than O(n log(n)) and most of its passes have decent memory locality.
I'm therefore not surprised that they are comparable.
That said, you could try turning max_heapify from a recursive function into a loop.  That may avoid a certain amount of stack manipulation.
",0,36094645
36086844,"
When iterating over the list to find the position to insert a new node, you do:
But the tail variable is passed by a reference, that is you modify the tail member of yout List object, thus destroying its consistency.
Use another temporary variable, named, say current or position to walk along the list, and don't modify tail unless you're appending a new node at the end of the list.
EDIT example approach
",2,36085565
36086098,"
You want to do two things: find position in list where new node belongs AND insert new node at a position.  So, write two functions, one to do each task.  Then you can test and debug them separately before integrating.  This will be much more straight forward. Further reccomendation: write unit tests for each function, before implementing the functions.
It will also be handy to have a function to  insert the first node, if the list is empty,
The point is that you should hide all the pointer twiddling in functions that can be tested, so you can write a comprehensible mainline that will work first time:
Since you are using C++, make your list a class and the functions members.
Implementation details:  You have to worry about special cases: new value goes before head or after tail.  So I suggest using an enumeration to handle these. 
It also turns out to be slightly easier ( less code ) to do an InsertBefore rather than InsertAfter.  You can see the code running at cpp.sh/4xitp or the github gist 
",2,36085565
36086597,"
1. You can't initialize members inside a structure :
2.(a) Prototypes of functions insertIt and insertNode are wrong.You are passing head and tail using pass by reference.It should be  as follows :
void insertIt(Node * head ,Node * tail ,int value)
void insertNode(Node * head,Node * tail,int value)
2.(b) When you create a node in else part you should set the next and prev pointers of your new node to NULL :
2.(c) As you have passed tail using pass by reference whatever changes you make inside while loop on tail are reflected in program.Hence use temporary pointer of type Node.
3. Also the design you are using is not good.Hence I would advice you to change it.This is my implementation of linked list :
",1,36085565
36086687,"
The problem is the check value < tail->prev->value in the while loop head. This does not check that tail->prev != nullptr is true. This is a problem for the case that head == tail and value < head->value. If head != tail, your code would indeed work, because the first time value < tail->prev->value is evaluated, tail->prev != nullptr is true and the case head->next == tail would be caught by the code in the loop body.
The correct check would be tail->prev != nullptr && value < tail->prev->value. This first checks that tail->prev can be derefenced.
Then you may end with tail->prev == nullptr after finishing the while loop (due to the new condition). The check for that can be moved out of the loop, leading to the following code:

EDIT: You can still check the condition tail->prev == nullptr within the loop; the check after the loop would then only be useful to catch the case head == tail && value < head->value. Not doing the check in the loop has the benefit of a shorter and (in my opinion) mode readable code.
",1,36085565
36088265,"
This might be the code you're looking for ;-) You can run it as-is in VS2013. It simplifies your insert function to just a few if-statements. And that can be further simplified with use of terminal elements for head & tail.
I hope this helps :-)
",0,36085565
36019060,"
There are several issues in your code.
You should not use using namespace std; to avoid name clashing.
Moreover, unfortunately your time (lowercase) class conflicts with another time standard identifier. Just use Uppercase convention for naming classes.
In addition, you may want to mark your Time::getHour() and Time::getMinute() methods as const, since they don't modify the internal state of Time objects.
You also have a typo with sort calls, since you have a dot following sort.
And, in C++11/14, I'd suggest you using range-based for loops instead of explicit for with integer indexes.
I've refactored your code a little bit considering those aspects, and it now works, with both the lowerThan() static method and the lambda. Feel free to study it.

Note also that if you define a custom operator< overload for sorting instances of the Time class, you can simply call std::sort() without any custom comparator, and your custom implementation of operator< is automatically picked up by the compiler:

EDIT
As suggested in a comment by @DieterLücking, you can use std::tie() for the operator< implementation (live here on Ideone):
",2,36018505
36014817,"
Simple implementation:
Usage:
",0,36014635
35989616,"
std::is_sorted works on a range of iterators not on a ""container"".  To use it you need to pass an iterator to the start of the range you want to check and one past the end of the range you want to check.  Most if not all standard containers have a begin() and end() members which is very convenient but unfortunately a raw array does not.  
Fortunately though we have std::begin and std::end which will return an iterator and will work with raw arrays(this will not work if the array was passed to a function like void foo(int arr[]) as it decays to a pointer and is not an array in the function).
So if you want to use std::is_sorted with a raw array you can use
Which will check the whole array.
Additionally you can also use pointer notation as that is what iterators are an abstraction of like
Where x is in the range of [0, array_size - 1] and y is in the range of [x + 1, array_size]
",2,35989316
35988320,"
Pass the vector by reference. This should improve performance significantly.
When you pass the vector by value you copy it every time (adding complexity of O(n) in every step)
",1,35988247
35989788,"
Don't pass the vector around. Not by value, and not by reference. Pass iterators:
To split a range, just calculate the middle value:
This assumes that the code is still sorting values held in some sort of container (in the original code, a std::vector), so the iterators are random-access iterators.
",3,35988247
35988426,"
Passing the source data by reference, rather than copying it, would be a huge improvement.
In addition, you should reserve space in erg, otherwise you're repeatedly re-allocating and copying all the elements as you add more.
",1,35988247
36015932,"
Using push_back instead of indexing is slow. A one time allocation of a working array or vector, and indexing into that array eliminates doing all those recursive allocations. Using a pair of mutually recursive functions eliminates having to copy data back after a merge.
A bottom up merge sort would be slightly faster, and while bottom up merge sorts are normally what are used by most libraries (such as std::stable_sort), top down merge sort seems to be what is taught in class rooms.
Example template for a top down merge sort that will work for an array or vector (pass the vector as a pointer to the first element).
",1,35988247
35988333,"
Well you are missing a very big optimization.  You are passing all of the vectors by value instead of by reference.  This means every function call is copying the vectors which is very inefficient.  
Since everything in java is a pointer your java code is not going to be making all of these copies which should be a major part of the slowdown in the C++ code.
",0,35988247
35975049,"
I spotted two things which seem wrong.
a) This line 
is wrong (used in two functions). You need a pointer - not a new element - so no need for malloc.
b) This code
seems to get active when you reach the last element. However, you must still check if the new element is to be inserted before or after the element already in the list. Your code always place the new element after. Consider the case when your list only have 1 element.
BTW - If you want to write c++ you should use std::string instead of c-style char arrays. Also, take a look at std::multimap instead of your own linked list.
",0,35974745
35963494,"
The first partition call splits our data set into two: (1) those less than the pivot on the left and (2) those greater than or equal to the pivot on the right. 
The second partition splits that second set (2) into two sets: (2a) those equal to the pivot and (2b) those strictly greater than the pivot.
Then we recurse on (1) and (2b). Basically, this ensures that all the elements equal to the pivot are in the correct spots and don't have to be looked at again. 
I make no guesses as to whether this is a better performing algorithm than the canonical single-partition implementation - but this is what it's doing. 

Let's walk through an example:
",5,35963436
35939244,"
What you really should be doing is to step through the code line by line in a debugger. That way you will easily see what the problem is.
But since I started writing this I might as well post it as an answer.
The problem is that the array you allocate and assign to arr is not initialized, its contents is indeterminate. And using uninitialized data is undefined behavior.
What's really is happening is that the data you allocate will be seemingly random, and most likely none of it will be zero. That leads to your counts being all wrong.
The solution is to clear the memory you allocate before counting values:
",1,35939097
35928962,"
You didn't call your function insertionSort(int numbers[], int arraySize) in main(). Therefore nothing will happen to the original array.
Note that you need a return 0; statement inside int main(). And that you need to use numbers[i] instead of array[i]. And you need to set your insertionSort() to return ""something"" or to pass your numbers[] as a reference. Also not to forget about the function prototype before main().
This should work:
",0,35928130
35882323,"

initialize a pointer to the end of array.
foreach every new element, set it as the value which is pointed by current pointer, and reduce current pointer by 1.

If you use the void return function, you can pass new element value and current pointer as the parameter. And pay attention to check current pointer.
",4,35882223
35881101,"
I don't understand the complexity:  
Many sudoko boards are declared as:  
Because it is a 2 dimensional array, all the slots can be printed using 2 for loops.  
Making the board a character array with spaces and other characters complicates the program.  Leave the spacing for the printing function.  
",0,35880580
35878572,"
You have to make sure that you do not go out of bounds: 

do not go until the last element to compare it with the non existing next one
take into consideration that the removal of an item shrinks the size of the vector. 

So some minor corrections get it to work:
Online demo
To avoid the multiple passes, you could also start from the end:
EDIT:
@knivil's comment pointed out that more than 2 identical elements (for example 3 consecutive 8 instead of 2) could lead to inconsistencies in the vector (the final result being no longer sorted).  Here a modified version if these multiple repetitions would be a valid case  here a modified version (assuming that for n repetitions, it's still 1 more and not n-1 more):  
With a new online demo.   
I leave you as an exercise to make the single pass reverse version ;-)
",1,35878303
35878446,"
One route is to use a hash map to basically look at the frequency of each element.  Then use the frequency information to increment data.  
Try it here.
",0,35878303
35882208,"
Here is another approach to the problem.
I have one std::vector incremented holding the values that are incremented if duplicates are found.
The while loop runs as long as there are duplicates to be removed, increments the found duplicate and adds it to the incremented vector.
The vector is being sorted after each run to ensure the values are being removed properly and so that the output shows correctly.
Output: 12 9 6 5
Hope this appears useful.
",0,35878303
35867668,"
Simply use std::is_sorted something like:
",3,35867423
35867850,"
Check this stack overflow link hope you get it your answer.
How do I code a function to test if a linked list is sorted
",1,35867423
35846191,"
The problem is here:
So what if list[i] = rand()*rand(); results in a number that is greater than size which is 100,000 ? Your pointers of marker arrays will absolutely goes out of list bounds, which is the reason your program crashes.
To summarize, you should make sure all values to be sorted are under array max size, since you are using radix sort.
",0,35845079
46386650,"
try the bellow code for parallel radix:
don't forget to add option -pthread to compile it.
",0,35845079
36974636,"
There are two errors that I can see:
Error 1:
You're dereferencing an uninitialized pointer, thus the program will exhibit undefined behavior.  The fix, (if you still wanted to use pointers):

Error 2:
The Total is not initialized, thus assigning to it is undefined behavior.  The fix is simple, just set Total to 0 before the loop.
",0,36974362
36962921,"
You should put the day-of-week index (0 to 6) plus the value for that day into a struct, and then populate a std::vector of these structs.  Then you can sort them easily:
",1,36962891
36951503,"
Your problem is in your swap() function, you are not assigning the value you held in temp ""back"" to its supposed position:
",0,36951435
36932665,"
You can a use a lambda function to sort your vector:
It is longer than your version but you don't need to write anything prior to a call of sort.
If you need to do that kind of stuff often, you could put everything in a small functor (and allow it to work for both A, A* and smart pointers), it uses mem_fn (thanks to @T.C.):
Then:
",7,36932391
36932821,"
I'd recommend not overloading operator< just because you have one particular use case in mind. Keep the sorting logic local to where you need it; it's not part of the type.
If you want to sort by projections regularly, it may be worth writing a little helper:
Usage:
",1,36932391
36927948,"

Your bubble sort doesn't swap, but only copy. This would make it somewhat faster. Not sure this alone explains being so fast, though.
Your Heap<T> makes a copy of the array. This can explain the slowness. I guess you forgot a &.
You should have noticed 71ns to sort 32k array is not real. Your quicksort never sorts anything. You can use std::sort for a reliable quicksort.
Too much is known at compile time and the numbers are far from random. Switch to arrays with random numbers in this kind of testing.

",0,36923134
36921673,"
Your predicate has to accept Student * instead of string *:
note if you do not intend to modify data change parameters type to const Student * and that would make your code cleaner and safer (if you put code in pred, that by mistake tries to modify that structure then compiler will reject to compile and it would be easy to detect and fix that mistake):
",3,36921636
36899658,"
I found your problem:
In function:
At code part that I modified.
Reason?
The while statement:
stops can be because of either of conditions breaks or BOTH of them. I leave the left for you to think.
",1,36898884
36897721,"
What do you compare in your program? As I see, you have to compare names, but all you do is compare an array element which is a struct data type.
If you are trying to compare names, you have to use dot ""."" operator to reach names. After yo compare names, you can change the elements's place.
",2,36897292
36897441,"
The error means that > only takes two arguments and you are using it for something else. In this case you are comparing an entire data structure that does not have an override for > operator and is an undefined behavior. StudentsInfo[i] is a data structure that has more than one element in it. Replace the StudentsInfo[i] with StudentsInfo[i].GPA or another element whose data type has a defined > operator. 
",-2,36897292
36892158,"
Not at all. string allows comparison by <. You just need to use county in your comparison. 
The way comparison works is, strings earlier in the dictionary would be considered as ""lesser"" than than those later. So it'd work just as you expect.
Running code
",3,36892117
36880453,"
One simple way to count number of comparisons is to change your merge and merge-sort functions from void to return number of comparisons within them and counting recursively.
",2,36879963
36880429,"
The array of B 's length is only 100.it will be bound.
",0,36879963
36881713,"
The simplest way to do this is to use a static global variable, and increment it with each compare of A[] in merge(), then have the main program display the count after a sort. This avoids having to change the interface for the existing functions.
",0,36879963
44172251,"
you can try with this.. 
",0,36837538
36856412,"
What you are missing is:

The polygon winding rule.
The vertexes of triangle/polygon should be in specific order CW/CCW.
You should deciding target side for line not for point.
Deciding single point would be mistake as some points are in both sides.

So for example if:

order is CW
x+ axis goes right
y+ axis goes down
vertexes are A,B,C


Then you decide the left/right side from the change in y axis. So while rasterizing any of the outlines (AB,BC,CA) you look at the y change between first and last point. For example AB line:
For more info see related Q/A closed convex polygon filling.
",2,36830638
36856660,"
Edit: I am too late after Spektre's answer, but I do not want to throw away my hand-drawn picture :)
It seems you have missed important part: triangle vertices are numbered in clockwise manner. So knowing of Y-order allows to reject impossible variants.
And value 3 of *Compare is used to provide cyclic order.
Example for Y0 < Y1. For clockwise order point 2 may lie in one of marked regions (at right hand of P0-P1 vector):

",1,36830638
36819360,"
Best solution is use a tuple<property*, property*, property*> not a Task. This comes with comparison operators defined so you could simply do: vec.push_back(make_tuple(&propertyOne, &propertyTwo, &propertyThree)) for each entry into vec, then to sort just do:
If Task must be more elaborate than a tuple<property*, property*, property*>, you should define comparison operators for Task:
Once these two are defined you can again do:
",3,36819009
36819083,"
Let's task have three properties a, b, c for short. To sort such tasks in correct order you have to do something like this:
",3,36819009
36819437,"
I'd do it using a simple lambda containing a couple of ternary operators
This obviously assumes the properties a and b can be compared using ==, and that all three properties can be compared using <.
Alternatively, you might want to supply appropriate specialisations of functionals from <functional> (std::equal_to, std::less, etc) and use those instead.
",0,36819009
36810338,"
The problem is that your code writes past the end of the array. It happens after you have encountered the last element in the counted sequence, but before the array buf has been exhausted, i.e.
When you add the highest element, which is 65, to the result, i reaches 6, so assigning a[i] becomes illegal. See what's going on by adding an extra element to your array, setting it to -1, and watching what happens to it (it gets set to 100; demo 1).
You can fix it by adding an early exit condition to stop as soon as you filled the array back, i.e.
Now the -1 past the end of ""active"" part of our array remains -1 (demo).
",3,36810239
36810335,"
The logic of the second loop is wrong. You have six numbers in arr, no doubles, which means that a total of six elements in buf will be set to 1.
That means that after a while, the value of i will be 6, which you then use as an index into arr, but index 6 is the seventh element in an array, leading you to write out of bounds.
",2,36810239
36782329,"
In your index_of_minimal function, you need to reset the current smallest value(first) for the next comparison along with saving its index, otherwise another number, in your iteration, less that the original first value may still be larger than the ones you've already processed.
So it should be like this:
",1,36782185
36777944,"
Combine partitioning and sorting:
If you store the iterator returned from partition, you already have a complete description of the range of non-trivial values, so you don't need to look for −1s later.
",9,36777834
36777978,"
You can provide lambda as parameter for sort:
here is the demo (copied from Kerrek)
but it is not clear how you realize where is which score after sort.
",3,36777834
36778124,"
From your description, it appears that the score can be never negative. In that case, I'd recommend the scores to be a vector of unsigned int. You can define a constant
and load your vector with INFINITY initially. INFINITY is the maximum positive integer that can be stored in a 32 bit unsigned integer (which also corresponds to -1 in 2's complement)
Then you could simply sort using
All INFINITY will be at the end after the sort.
",2,36777834
36777943,"
std::sort supports using your own comparison function with the signature bool cmp(const T& a, const T& b);. So write your own function similar to this:
And then call sort like std::sort(myVector.begin(), myVector.end(), sort_negatives);.
EDIT: Fixed the logic courtesy of Slava. If you are using a compiler with C++11 support, use the lambda or partition answers, but this should work on compilers pre C++11.
",0,36777834
36778161,"
For the following, I assume that the -1 values are all placed at the end of the vector. If they are not, use KerrekSB's method, or make sure that you do not skip the indices in the vector for which no valid score is in the file (by using an extra index / iterator for writing to the vector).
std::sort uses a pair of iterators. Simply provide the sub-range which contains non--1 values. You already know the end of this range after reading from a file. If you already use iterators to fill the vector, like in
then simply use it instead of myVector.end():
Otherwise (i.e., when using indices to fill up the vector, let's say i is the number of values), use
",0,36777834
36779970,"
An alternative approach is to use reserve() instead of resize().
This way, the vector would have only the numbers that are actually in file, no extra (spurious) values (e.g. -1). If the vector need to be later passed to other module or function for further processing, they do not need to know about the special nature of '-1' values.
",0,36777834
36740001,"
Make sure you understand the three different ways to see a function:

Declaration of the function:
void insertion_sort( int ch[] );
Definition of the function:
void insertion_sort( int ch[] ) {
   // your code
}
Call to the function, like this, inside main():
insertion_sort(ch);


Check my example with Quicksort (C++), it's really relevant!
",1,36739917
36739959,"
void insertion_sort (ch ) ; doesn't make sense. It means declare a variable named insertion_sort with type void and initialized by ch. If you just want to call the function change it to
",0,36739917
36726998,"

Does this mean that if you call sort() on a user-defined type that has no move constructor or move assignment operator, then there are no move semantics used?

Correct.  If the class is not moveable then it will fall back to copying

In other words, to get the many benefits of C++11 performance improvements, you should edit existing code to add move operations explicitly?

If you can sure, who doesn't like more performance.  Do note that depending on the class you may get automatically generated move operations.

Further, if you are sorting, is it the container or the type inside the container, or both, that must have move operations defined?

The container itself is not required to be moveable.  std::sort requires that the iterator passed to it shall satisfy the requirements of ValueSwappable (17.6.3.2). and that the type returned by dereferencing the iterator shall satisfy the requirements of MoveConstructible (Table 20) and of MoveAssignable
(Table 22).
",7,36726723
36725893,"
To use the above, take your predicates, wrap them in zComp.  When you don't care, return false on both a,b and b,a.
Feed your raw X<int,int> comparators to zComp<int, X> -- you can change the above to work with packs of templates, but I have a bias for working with types in my metaprogramming, so I package up the templates into zComps.
live example.
Oh, another useful trick -- make sequence {} have an empty {} body.  Then you can use assignment as a better-debug-message ""is_same"" test, because you are told what the lhs and rhs types are and that they are not compatible.
",1,36724414
36732561,"
Ok, I worked around the compiler problems with my first method, and got my desired syntax working : composed_sort<T, Sequence, Predicates...>::type.
Main disadvantage with this implementation:  Neglects the DRY principle, as now the structs sort and composed_sort are basically repeating each other.
Arguably, the nice-looking syntax of composed_sort<T, Sequence, Predicates...>::type does not really offset this violation of the DRY principle.
Yakk's method is definitely better.
",0,36724414
36707081,"
The average case performance of insertion sort is O(N^2) (see the wiki entry). For your vector of 100 elements, the expected number of comparisons is therefore O(10000). Coming out with 2656 or, in your second run, 4995, comparisons is therefore lower than you might otherwise expect.
",1,36707034
36703468,"
If you want to be able to change the root you'll need to pass it as a **.
However even then I dont think your sort function will work it will just return a truncated list missing everything before the smallest element.
Is their any reason your using a custom linked list and sort alogorithm?
The standard library takes care of things like containers and sorting:
",0,36702312
36702236,"
This part of code
must be outside of for scope :)
Final code:
",1,36701700
36684806,"
I think what you’re trying to do is this:
",2,36683692
36684426,"
For learning purposes you can use bubble sort. Bubble sort is very easy, also very inefficient and slow. In a real application you would use std::sort
",1,36683692
36661273,"
Your question is not complete. You left the definition of set_type out of the question. In the future, please create minimal self contained programs when forming questions. Aside from everything else, creating the minimal program will often lead you to understand where the problem is.
Everything else in this answer is pure guesswork.
First, I'm going to bet that the comparison line isn't the one segfaulting. This is easy to check by compiling your program without optimizations and running it in a debugger. I'm guessing that the compiler optimizes out everything once you remove the comparison, which is why it doesn't crash when that line is removed.
Second, I'm betting the problem is inside the definition of set_type. You probably ignored the rule of three. Many forget that a C++ class has a default copy constructor unless you explicitly disable it.
If none of those answer your question, just create a minimal compiling example and post a new question.
",0,36660366
36659674,"
Since you're dealing with pointers, the easiest thing to do is to use std::vector and std::sort:
Also, your original code looped one more than it should (i <= n was wrong).  
Edit:
If your compiler doesn't support the C++ 11 syntax, here is an alternate solution:
",1,36658792
36651846,"
For n rectangles this can be solved easily in O(n^3) time (or just O(n^2) time if at most a bounded number of rectangles intersect) by looking at the problem a different way.  This should be adequate for handling up to thousands of rectangles in a few seconds.
Also, unless some other constraints are added to the problem, the latter time bound is optimal: that is, there exist inputs consisting of n non-intersecting rectangles for which O(n^2) smaller grid rectangles will need to be output (which of course requires O(n^2) time).  An example such input is n width-1 rectangles, all having equal bottommost y co-ord and having heights 1, 2, ..., n.
Grid size bounds
First of all, notice that there can be at most 2n vertical lines, and at most 2n horizontal lines, since each input rectangle introduces at most 2 of each kind (it may introduce less if one or both vertical lines are also the edge(s) for some already-considered rectangle, and likewise for horizontal lines).  So there can be at most (2*n - 1)^2 = O(n^2) cells in the grid defined by these lines.
The grid cell co-ordinate system
We can invent a co-ordinate system for grid cells in which each cell is identified by its lower-left corner, and the co-ordinates of an intersection of two grid lines is given simply by the number of horizontal grid lines below it and the number of vertical grid lines to its left (so that the bottommost, leftmost grid cell has co-ords (0, 0), the cell to its right has co-ords (1, 0), the cell two cells above that cell has co-ords (1, 2), etc.)
The algorithm
For each input rectangle having LL co-ords (x1, y1) and UR co-ords (x2, y2), we determine the horizontal and vertical intervals that it occupies within the new grid co-ordinate system, and then simply iterate through every cell (i, j) belonging to this rectangular region (i.e., every grid cell (i, j) such that toGridX(x1) <= i < toGridX(x2) and toGridY(y1) <= j < toGridY(y2)) with a nested for loop, recording in a hashtable that the ID (colour?) for the cell at (i, j) should be the colour of the current input rectangle.  Input rectangles should be processed in decreasing z-order (implicitly at least there seems to be such an order, from your example) so that for any cell covered by more than one input rectangle, the hashtable will wind up recording whatever the ""nearest"" rectangle's colour is.  Finally, iterate through the hash table, converting each grid co-ord pair (i, j) back to the LL and UR co-ords of the input-space rectangle that corresponds to this grid cell, and output this rectangle with the ID given by the value for this hash key.
Preprocessing
In order to accomplish the above, we need two things: a way to map input-space co-ordinates to grid co-ordinates (to determine the horizontal and vertical grid intervals for a given input rectangle), and a way to map grid co-ordinates back to input-space co-ordinates (to generate the output rectangles in the final step).  Both operations are easy to do via that old workhorse, sorting.
Given any corner (x, y) of some input rectangle, the grid x co-ordinate corresponding to x, toGridX(x), is simply the rank position of x within the sorted list of all distinct x positions of vertical edges that are present among the input rectangles.  Similarly, toGridY(y) is just the rank position of y within the sorted list of all distinct y positions of horizontal edges that are present among the input rectangles.  In the other direction, for any grid co-ordinate (i, j), the corresponding input-space x co-ordinate, fromGridX(i), is simply the i-th smallest x co-ord (ignoring duplicates) of any vertical edge among the input rectangles, and similarly for fromGridY(j).  These can all be computed as follows (all array indices start at 0, and I show only how to do it for x co-ords; y co-ords are similar):

For each rectangle i in the input having LL co-ords (x1, y1) and (x2, y2):


Append the two-element array [x1, i] to the list-of-arrays VERT.
Append the two-element array [x2, i] to the list-of-arrays VERT.

Sort the list VERT in increasing order by its first item.
Combine elements in VERT having identical x co-ords.  Specifically:


Set j = 0.
For i from 1 to n-1:


If VERT[i][0] == VERT[j][0] then append VERT[i][1] to VERT[j] (thereby forming an array of length 3 or more at position j), otherwise set j = j + 1 and overwrite VERT[j] with the two-element array VERT[i].

Delete VERT[j+1] and all later elements from VERT.

By this time, for any i, VERT[i] is an array that contains (in its second and subsequent positions) the IDs of every input rectangle that uses, as either its left or right edge, the ith-leftmost distinct vertical line used by any input rectangle -- or in other words, the rank-i vertical line.  We now ""invert"" this:

For i from 0 to n-1:


For j from 1 to length(VERT[i])-1:


Set toGridX[VERT[i][j]] = i.



For i from 0 to length(VERT)-1:


Set fromGridX[i] = VERT[i][0].


Running time
As previously established, there are at most O(n^2) grid cells.  Each of the n input rectangles can occupy at most all of these cells, each of which is visited once per input rectangle, for a time bound of O(n^3).  Note that this is an extremely pessimistic time bound, and for example if none (or none but a bounded number) of your rectangles overlap, then it drops to O(n^2) since no grid cell will ever be visited more than once.
",1,36648631
36649549,"
I suspect the lookups and iterations are not fast enough. Things like 'otherwise it searches the whole map' point out that you do very heavy computations.
What I think you need is to use a 2d datastructure. A k-d tree or a BSP would work but the easiest to understand and implement would be a quad tree.
In a quad tree each node represents a rectangle in your space. Each node can be split into 4 children by selecting the mid point along the 2 dimensions and having the children represent the 4 resulting rectangles. Each node also holds the value that you want to assign to the area and an extra flag if the value is uniform.
To mark a rectangle with some value, you start from the root and recursively:

If the input rectangle covers the node rectangle you set the value to that node, mark it as uniform and return.
If the input rectangle and the node rectangle don't touch just return.
If the node is marked as uniform, copy the value to it's children and mark the node not uniform.
Recursively call for the 4 children (you might have to create them).
On the way back, check if the 4 children have the same value and are all marked as uniform and if so mark the node as uniform and set the same value as the children.

The main advantage of this approach is that you get to mark large areas of your map quickly. You can also prove that marking a area is O(logN) where N is the size of your map (with a larger constant than the usual tree).
You can find a more detailed explanation and some helpful images on wikipedia.
",1,36648631
36652227,"
Assuming you know the top- and bottom-most y and the left- and right-most x, extend the four vectors belonging to each rectangle to the respective max and min x and y points. Keep a set of extended vertical vectors and a set of extended horizontal ones. Whenever an extended vector is added, it will necessarily intersect with each vector in the perpendicular list - the intersections are the cell coordinates of the matrix.
Once the list of cell coordinates is made, iterate over them and assign values appropriately, looking up if they are in or out of an original rectangle. I'm not too versed in data structures for rectangles, but it seems to me that two interval trees, one for horizontal, the other for vertical could find that answer in O(log n) time per query, where n is the number of intervals in the tree. 
All together, this method seems to be O(n * log m) time, where n is the number of cell coordinates in the resultant matrix and m is the number of original rectangles.
",1,36648631
36644353,"
According to the (now deleted) comment, this is main():
You sort the same vector two times, and print the comparision count of the second sort run. When the vector is already sorted, the number of comparisons is equal to the number of elements in the vector, because no work has to be done.
To get the true number of comparisons, change your main() to:
",0,36643929
36657939,"
Without knowing what your test cases are, it's not possible to comment on number of comparisons they perform.   If all cases have similar attributes, it is quite possible the code is behaving as it should.
EDIT:   the following added in response to claim by OP in comments that the test cases are vectors with 100 randomly generated two-digit elements.
If, as you have said in comments, your test cases involve vectors with 100 random two-digit values, then the value of counter will depend on how ""unsorted"" the elements are (with the minimum value possible related to the number of elements).   Assuming all of your test cases are the same size, then the only way the value of counter will be the same is if the vectors are sorted similarly BEFORE calling your function.   For example, if all your vectors are pre-sorted in ascending order and the same size, every test case will give the exact same return value.   Similarly, if all your vectors are pre-sorted in descending order and the same size, every test case will give the exact same return value (albeit different from the value returned if they are initially in ascending order).
For that reason, I do not believe your comment that the test cases are random.   They are probably presorted (or maybe partially sorted) in some way.   For example, you might be calling your function twice for each test case, and only printing out the value of count after the second call ..... when  the vector is (if your code behaves as it should) already pre-sorted.
End Edit
That said, the variable counter in your code is accumulating the number of times the body of the while loop is executed.  That has nothing to do with number of comparisons being performed, as there is no comparison performed in the body of that loop.    It is related to the number of insertions, not the number of comparisons.
If, by ""comparison"", you want mean evaluating the expression temp < v[j] (as distinct from other expressions, like i < v.size() or j >= 0, which could also be called comparisons in your code) then you might consider doing something like
and removing incrementing of counter from the loop body.
Since counter is initialised to zero, this will count the number of times temp < v[j] is evaluated (++counter will always produce a non-zero result).   Note that, since temp < v[j] can be false, it will not count the number of times j >= 0 is computed.
",0,36643929
36636031,"
This line
sets n1 to be the size of 9 integers, which is probably 36 (depending on your machine architecture)
You are then using this as an input to your bubble sort, which means your bubble sort is going way outside the array boundaries. This is undefined behavior and may lead to the values in the arrays being incorrect.
Change the lines to
or even just use 9 as you have that in several other places as well (maybe you could define a const int as 9 so you can easily change it later.
",1,36635852
36622743,"
You just:
std::pair is lexicographically compared.
On the other hand if you want to sort them with respect the second element of the std::pair then you would have to defind a custom comparator in the following manner:
",2,36622704
36625551,"
what i did was to store int value multiplied with -1 and then sorted it in ascending order and then again multiplied to -1 to the stored int value to restore int values. doing this made the vector of pairs arranged as needed.
",0,36622704
36619120,"
For this to work you need to implement == operator for class mixed. Example:
For second error, As rightly pointed out in the comments, you need to correct end iterator.
UPDATE: However this is NOT correct use of std::search. Use std::search which relies on == operator.
Reference: http://www.cplusplus.com/reference/algorithm/find/
This should work.
",0,36618885
36638865,"
For cases like this, where your find criterion may differ from call to call, I prefer find_if:  it does not force me to overload operator== for my type.
",0,36618885
36619165,"
The farther an x value is from the parabola's apex x0, the higher is its y value when a is positive and the lower its y value when a is negative.
When a is zero, your parabola is really a line and the x values are already sorted in the correct order when b is positive or in the reverse order when b is negative.
So when a isn't zero, find the apex:
Now find the value in your sorted list of x values that is closest to x: 
Add point i to the list. Create two indices:
Now take the point at either index l or r that is closer to the apex, and add it to the list. Update the index until you have exhausted the list.
Revert the list when a is negative. (Or add the items from the end of the list.)
Edit: Here's an implementation in Python. It pops elements off sub-lists rather than using array indices, but the logic is the same:
",0,36618284
36590491,"
The above code implies that you have an array of pointers,which you don't. What you have is an a array of of strings pointed to by string *myList, and you passed the address of this single(and not an array) pointer to the function.

So you only have one pointer(myList) pointing to a memory location where an array of strings are stored, saying something like string* arr[]=&myList; and arr[index]; in a loop will eventually(when index>0) access a value from a memory location which contain a garbage data(not a valid pointer) and trying to deference it will cause an error.
",1,36590236
36590761,"
Here is the working code

Parameter of arrSelectSort function is using : string *arr. It is beacuse you want to sort pointer of string. By using *arr[] means you want to sort pointer of (array of string)
minElem is only string datatype . minElem will contain string that pointed by arr, so it only a string, not pointer of string
Comparison is only : if (arr[index] < minElem) . To access string that pointed by arr, we can access it like an array of arr
Call the function : arrSelectSort(myList, size); . Parameter of arrSelectSort function is changed to *arr.

",0,36590236
36589540,"
This looks dangerous to do:
The node on the end of the list won't have a link, so you are trying null->link().
Try to change it in
and see if the seg fault still occures.
Maybe this will break the algorithm, but then you can work further from there..
Btw; I have a headache now from the bad formatting of your code :(
",0,36589144
36588447,"
prev->link() as well as minum->link() are functions that return a node. You can't assign a value/pointer to functions. To set the nodes, you could overload the link() function with an argument like void link(node* input).
",0,36588399
36533073,"
Are you messing up the assignments?
The right code should be
",0,36533041
36527465,"
Since your comparison function is quite complex, I've rewritten it very verbosely, so each possible case can be inspected separately. I've also separated into a different function the decision about which partition of the output each element goes into.
Output:
Bear in mind your comparator must induce a Strict Weak Ordering, which I think this does, but it's a bit trickier than one would normally use for sorting.
Always write your code as clearly as possible, not as short as possible. If you have some complicated logic, break it up, move parts out into functions, and add plenty of comments. Remember, other people have to read and understand it, including yourself in 6 months.

What might be a better approach is to split the sort up. You are really talking about splitting the array into 3 partitions, each being treated differently. So use std::partition twice, and std::sort three times. I think that may well be more understandable. This code has the exact same output as the above:

Also worth mentioning, many people (myself included) consider using namespace std; and std::endl are bad practices.
",1,36527297
36527615,"
Using std::partition to first ""split"" your array into three partitions, and then sorting each partition, you will get something like
Output

Before first partitioning: 18 5 24 9 12 6 2 3 
Before second partitioning: 3 9 24 5 12 6 2 18 
Before sorting: 3 9 2 5 12 6 24 18 
After sorting: 3 9 2 5 24 18 12 6 

The output after soring is as what you expect.
See here for it in ""action"".
It is more work, but is also guaranteed to behave as expected.
",1,36527297
36527621,"
This simple comparison function works for me:
But if you have large arrays and care about performance, you should likely partition data first and then sort each 3 parts independently as recommended by others (to avoid such a complex, i.e., slow comparison function).
",1,36527297
36527763,"
I would construct a tuple for that {partition1, partition2, order}:
Demo
",1,36527297
36517169,"
//you have just one err,in last for you missed =  :
//err: for(i = p; i < r; i++)
//correct: for(i = p; i <= r; i++)
//this is cleaned version of your code:
//this is another answer:
",2,36516575
36513612,"
You can use functor objects, like e.g.
The expression cmpAnyYear(year) constructs a (temporary) object of the type cmpAnyYear and passes year as argument to the constructor. This object is the ""called"" as a function, which calls the cmpAnyYear::operator() for the comparison.
",2,36513575
36513618,"
Use a lambda which captures the year:

The reason why year as template parameter didn't work is because it has to be a compile-time constant when you call it, which is not in your for loop.
",1,36513575
36504711,"
When you call a C++ function you pass it arguments. The std::sort function works on a ""range"" of elements, and in C++ today you specify a range by a pair of ""iterators"" which denote the beginning and end of the range. So in C++ today a range is not a single object, it's a conceptual thing described by two objects.
This is a very flexible design, as it allows std::sort to work with any range that can be described by a pair of iterators denoting the beginning and end (e.g. you can sort just the first half of a container by passing iterators pointing to the beginning and the middle of the container, or you can sort an array by passing pointers to the beginning and end of the array). So to call std::sort you need to pass two arguments, which must be iterators describing the range you want to sort.
But that flexibility comes at the cost of convenience: if you have an object that contains a range of elements, such as vectorname, it's a single argument, not two iterator arguments, so you can't pass it to std::sort. Instead you call the begin() and end() member functions to get a pair of iterators from it.
However, there are changes being planned for C++ to specify new versions of the standard algorithms, including sort, which work with a single object that describes a range. So in future you'll be able to represent a range as either a pair of iterators describing the range, or a single object which represents a range directly.
",3,36504482
36504572,"
std::sort works on ranges (specified by iterators), so it needs a place to start and end. It doesn't have to sort the entire container. The way it is specified is simply the most general way.
You can read the details over at cppreference: http://en.cppreference.com/w/cpp/algorithm/sort
Or read the standard if you want more detail: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4582.pdf
",1,36504482
36504580,"
Ranges are not a part of the standard C++ library yet. More details at CppCon 2015: Eric Niebler ""Ranges for the Standard Library"".
However, you can use Boost Range library, specifically boost::sort.
",1,36504482
36504623,"
The short answer is: ""because std::sort is defined to receive a pair of iterators, not a container.""
The slightly snarky answer is: 'because you included <algorithm> instead of ""boost/range/algorithm/sort.hpp""'.
A better (but still a little snarky) answer would be 'because you included <algorithm> instead of ""range/v3/algorithm""'.
Snark aside, I really would recommend looking at Eric Neibler's range library if you don't like explicitly passing begin() and end() iterators for things like this. Even if you don't mind that particular bit of syntax, I'd recommend looking at it anyway--I think it's a well thought out design, and it's well on its way toward being included in some future version of the C++ standard.
",1,36504482
36504591,"
I find it to be defect in std::sort. Yes, you do need an iterator-taking version of it (to be able to sort subranges of containers, or dynamic arrays).
However, it could as well have an overload which takes the container and obtains iterator from it.
",0,36504482
36490327,"
This code is comparing i-th character of corresponding titles, not the whole titles:
Possible ways to solve:

Change this
to
And after that you'll be able to write

Only if you can't use std::string for some reason, use strcmp:


",0,36489467
36485140,"
The easiest way
Read the data into a multimap of score (int) to name (string):
The container named data now holds all of your data, indexed (and inherently ascendingly-sorted) by score, with multiple names per score.
Now iterate the multimap backwards using .rbegin() and .rend() (backwards to get descendingly-sorted score), and, for each element, write out the name and the score:
Future work
The parsing would be more robust if you read from the file line-by-line, then parsed each line individually.
You could simplify the data store (though not much) if you knew that no two people could have the same score, by swapping the std::multimap for a std::map.
Also, if your input really is very large, you may not want to store all the data in memory at any point. This is hard but possible to avoid. You could consider researching this topic if you find that your program takes too much memory.
Finally, if for some reason you need the original order of names within each score value to be maintained (i.e. you need a stable sort) then you'll need to put much more thought into this than I have.
Disclaimer
I haven't tested the above snippets, so there may be typos in there. Instead of copy/pasting, read and understand then integrate the ideas into your own code.
",3,36485069
36479444,"
",0,36479206
36471792,"
Try using std::sort like
Demo
OutPut
",3,36471367
36471119,"
First, initialize the srand in the main, e.g. with srand(time(NULL)), to get a decent random. If you don't do this, you'll get the same ""random"" sequence on each run of the program. (You'll have to #include <time.h> for this.)
Second, as pointed out in the comments, you should choose the pivot with
This is because the size of the subarray for which you're choosing the pivot is high-low+1, which in general is different from the size of the original array (which is what you seemed to try to compute with the sizeof magic).
Update. As pointed out by Pete Becker, it might be a good idea to not use srand in the early stages of development (for the purposes of debugging). However,  it goes without saying that it's critical that you use srand if you want randomized quicksort.
",1,36470349
36470397,"
Common problem, you are not getting the size of the actual array to be sorted:
You will need to pass in the size of the array. This is why that sizeof trick is awful. Instead, you could use:
Then applying array_size(a) will give you a compiler error, since a is not an array. This construct appears in many libraries (probably boost, will paste a link here once I check), and will be in The Standard in C++17.
There are also better facilities for generating random numbers here, and here for a good explanation why rand() is bad.
",1,36470349
36463166,"
You are overwriting memory, that does not belong to you - in this line:
In C++ (and many other languages) arrays are indexed from 0. So an array of size N is valid for indexes from 0 to N-1. Your for loop iterates through 0 ... NUM_NAMES - 1, but inside, you use index i+1 which is NUM_NAMES for last iteration.
To solve this problem, you could iterate through 1 ... NUM_NAMES - 1:
And work on names[i-1] and names[i]:
(Or leave it as it is now, but change execution condition of the loop to k < NUM_NAMES - 1)
Also, instead of this:
You could simply do:
",0,36462871
37587885,"
The problem is here: 
Try:
You've to swap the smallest element found in the second loop, but you're swapping for every iteration in the second loop. That's why you're getting the wrong values.
Update:
There's another mistake: 
It should be:
You can try the code with my suggested changes here: http://code.geeksforgeeks.org/tjiwnu
It works.
",1,37587688
37581275,"
std::sort() takes two required parameters: the beginning iterator value and the ending iterator value that defines the sequence to be sorted.
What you're passing to std::sort() does not look remotely like a pair of iterators. It doesn't even compile.
NameArray.lastName is not valid C++. NameArray is an array. The . operator is used with structures or classes, not with arrays.
To sort this ten-element array you would normally use:
taking advantage of the fact that using an array's name in an expression gives you the pointer to the first element of the array, and these pointers will be logically equivalent to iterators, in this context.
However, this won't work either, here, because it is not defined how elements of NameArray can be compared. NameArray contains instances of a person class, and you can meaningfully sort something only if you can compare different values using the < operator, to sort lesser values before the greater values, of course.
In order to sort this array you will also need to either:
1) Pass the third, optional parameter to std::sort(), a lambda that compares two instances of the person class, or
2) Implement an operator< member method in the person class.
",1,37581206
37581276,"
For std::sort, you need to provide two iterators and a compare function
",1,37581206
37581312,"
Ok, this isn't how arrays work.
NameArray will give a pointer to the first element of the array, NameArray + 10 will give a pointer to the eleventh element, but NameArray.lastName doesn't exist. NameArray is an array, not a person. What is the last name of the array?
What you want to do is apply sort to NameArray, and sort it based on its last name. It is applied to NameArray, so it should be:
sort(NameArray, NameArray + entry).
Now you will have another compilation error. The sorting function needs a way to compare two person (and you should start your class names with an uppercase!).
There are two ways to do this. You can consider that a person is always inferior to another based on their lastName, in which case you will overload the < operator of person.
Or you will specify a special way to compare elements to your sort function:
Do some reading to understand a bit more, you can also look up lambda functions.

PS: Keep the names starting with an uppercase being your classes, naming variables like that is confusing.
You may also want to look up std::vector or std::valarray as alternatives to using a fixed-size array.
",0,37581206
37577699,"
If you want to keep compare_points in GrahamScan namespace you need to make it static:
The reason the compiler complains is that compare_points is a member function. It needs a GrahamScan object to be applied on. Behind the curtains the real function signature of compare_points is something like bool compare_points(GrahamScan *this, const Point2D& a, const Point2D& b). So either make it static or don't define it as a member function.
Once you make compare_points static, your lowest variable will no longer be accessible to it. Easier way to work around that is to make lowest also static:
and use it like this:
",2,37577347
3158569,"
Interesting problem if you are limited to go through the array row by row. 
I divided the rectangle in three regions. The top left triangle, the bottom right triangle and the rhomboid in the middle.
For the top left triangle the values in the first column (x=0) can be calculated using the common arithmetic series 1 + 2 + 3 + .. + n = n*(n+1)/2. Fields in the that triangle with the same x+y value are in the same diagonal and there value is that sum from the first colum + x.
The same approach works for the bottom right triangle. But instead of x and y, w-x and h-y is used, where w is the width and h the height of rectangle. That value have to be subtracted from the highest value w*h-1 in the array.
There are two cases for the rhomboid in the middle. If the width of rectangle is greater than (or equal to) the height, then the bottom left field of the rectangle is the field with the lowest value in the rhomboid and can be calculated that sum from before for h-1. From there on you can imagine that the rhomboid is a rectangle with a x-value of x+y and a y-value of y from the original rectangle. So calculations of the remaining values in that new rectangle are easy.
In the other case when the height is greater than the width, then the field at x=w-1 and y=0 can be calculated using that arithmetic sum and the rhomboid can be imagined as a rectangle with x-value x and y-value y-(w-x-1).
The code can be optimised by precalculating values for example. I think there also is one formula for all that cases. Maybe i think about it later.

Of course if there is not such a limitation, something like that should be way faster:
",4,37575709
11565249,"
What about this (having an NxN matrix):
",1,37575709
3153934,"
Follow the steps in the 3rd example -- this gives the indexes (in order to print out the slices) -- and just set the value with an incrementing counter:
",0,37575709
3154118,"
At a M*N matrix, the values, when traversing like in your stated example, seem to increase by n, except for border cases, so 
...and so on up to f(N,0). Then
and then
and
This is not conclusive, but it should give you something to work with. Note, that you only need the value of the preceding element in each row and a few starting values to begin.
",0,37575709
3154157,"
If you want a simple function, you could use a recursive definition.
This takes advantage of the fact that any value is H+the value of the item to its left.  If the item is already at the leftmost column, then you find the cell that is to its far upper right diagonal, and move left from there, and add 1.
This is a good chance to use dynamic programming, and ""cache"" or memoize the functions you've already accomplished.

If you want something ""strictly"" done by f(n), you could use the relationship:

n = ( n % W , n / H )   [integer division, with no remainder/decimal]

And work your function from there.

Alternatively, if you want a purely array-populating-by-rows method, with no recursion, you could follow these rules:

If you are on the first cell of the row, ""remember"" the item in the cell (R-1) (where R is your current row) of the first row, and add 1 to it.
Otherwise, simply add H to the cell you last computed (ie, the cell to your left).

Psuedo-Code: (Assuming array is indexed by arr[row,column])
",0,37575709
37575808,"
The important bit is 

""C:\Users\GS\Desktop\Programy\imageComparator\src\rightWindow.h|133|warning: lambda expressions only available with -std=c++11 or -std=gnu++11|"" 

You should turn C++11 functionality on using the compiler switch mentioned in the message.
Also, I imagine the comparison you are doing is likely going to be slow. It is probably wise to calculate all the image scores once, and then sort using the cached results.
",4,37575655
37574709,"
When you increment j, then erase the element there, the elements starting at j+1 are moved down. You're skipping over an element by incrementing.
A better approach would be to simply copy the non-repeating elements from one iterator to the other and setting the new length at the end of the main loop. Your current approach is potentially O(n^2), too slow for practical use.
",1,37573890
37574329,"
You can do it using iterators like this:
",0,37573890
37574926,"
I think this is that you need. This func loops array from tail to head and counts same values. Then performs shift of already unique values on ununique one.
It doesn't change actual size of vector due process because it would probably involve reallocation of memory inside of vector. 
",0,37573890
37574803,"
You are asked to use an array. Although vector is similar in many ways, it is not the same. Have a look at the example code below. 
In addition you are asked to keep memory allocated the same. You cannot ensure that using vector, it's size can grow / shrink once you add / remove elements and when an element is removed the data in the array behind the vector will be reallocated and rewritten.
",0,37573890
37561826,"
You should not use uint32_t or even uint64_t directly.
For indexing, you should size_t which is equal to the type return form the operator sizeof. So, if you are on x64 platform it would adapt automatically.
",1,37561753
37561443,"
First of all you do understand that your loop runs for 6 times and keep asking to enter numbers until you enter 36 inputs. 
I would recommend using a 1D array instead of a 2D array. And reduce the number if you can or add a functionality to stop taking inputs when the user think it's enough. You could do this easily with a if condition.
Anyway just to make your code do what it suppose to do(If i get it correctly),
You can change the last for loop like this.I have changed the array size to 2 since I can't enter 36 inputs.What's wrong with your code is that the second set of for loops finish running and print all the numbers and after that it runs the if statement which is again not correct because you are checking the value of j instead of checking the numbers you entered.Hope this will be helpful.
",0,37557856
37558093,"
you can include  then use sort function. In sort function you can write a sort method or you can use greater () as a sort method 
",0,37557856
37558500,"
The j variable is not initialized in 
It is not the same j as those which are used for the for loops since these ones are declared in the loop (with int).
Be careful to use only initialized variables.
Also I think you just need to make another for loop with i and j to check whether every element of the array is positive or negative (how about zero elements?). 
",0,37557856
37554991,"
You increase your counter only if the array value is less than the minValue :
If you want to count the number of arr[index] < minValue comparisons you make, you should change the code to:
And maybe give the counter a better name, what about counter ? ;)
By the way, just in case you want to compare your sort with the std::sort you could count its number of comparisons like this:
",2,37554915
37530651,"
Regarding the pivot for Qsort, there's no fixed rule for selecting the pivot. Choosing the pivot really depends on which strategy you want to impose on your input data, and that largely depends on the properties of the input data - range, size etc. 
Generally, we choose the pivot so that it splits the array into two equal halves (as much as possible). This is done so that we don't end up pushing all the elements on to one-side of the Qsort. If this happens your algorithm will become O(n^2) - think of skew trees if you're not able to see why. 
",0,37530411
37500362,"
Your specialization is inconsistent with your general case.
The template<T1, T2> class Pair; contain a member of type T1 and a member of type T2.
So, to be consistent, template<char *, char *> class Pair; should contain two char * (and allocate/deallocate it, I suppose). Instead, your specialization contain two char. Very naive.
What were your intentions? Crete a pair for char * (C-style strings) or a pair for single char characters?
As it is, and as observed by Bo Persson, you relational operators (in generic class) are really bad. Also wanting ignore that (IMHO) is better develop relational operators as friend and not as class methods, it's important that if result true a == b, a != b result false and conversely. Otherwise, the std::sort() can crash the program.
Look at operator==() and operator!=() implementations
Consider the case first == other.first and second != other.second; the result is that both operator returns false. That is dangerous; really dangerous.
Same problem with other relational operator. 
Consider the case first < other.first and second > other.second; all four other operators (<, <=, >, >=) return false.
I strongly suggest you to write the relational operator in a inter-dependent way; something like
remembering to declare friend in classes, operator==() and operator<().
p.s.: caution, example code not tested.
p.s.2: sorry for my bad English.
",0,37498488
37499011,"
Found solution. I implemented operator< for specialization so it compares 2 letters:
this way I can use sort method by default for my vector:
I know there are cases where letters can be equal, but I can do it with couple more ifs, idea is more important. Thanks everyone for help!
",0,37498488
37497042,"
why did you use the operator ""<"" for string. It can't work! GG for this and I think your idea about selection sort here is completely wrong. Your code just considers about array1[] and what about array2[]???.
That's my thought, sorry for my bad English!
",-2,37496921
37481756,"
It seems that you think that sort_arr[arr[j] - 1] = arr[j] will sort arr into sort_arr. It won't.
Sorting is already written for you here: http://en.cppreference.com/w/cpp/algorithm/sort You can use that like this:
Live Example
",0,37481012
37482761,"
Okay lets face the problems in your code.
The ""weird"" numbers you see there, came from the uninitialzied array sort_arr. What do I mean by uninitialized? Well sort_arr is a little chunck somewhere in your memory. Since a program usually does not clear its memory and rather claims the memory it used as free, the chunk of sort_arr may contain bits and bytes set by another program. The numbers occure since these bytes are interpreted as an integer value. So the first thing to do would be to initialize the array before using it.
Now why did these numbers occure? Well you're probably expecting your algorithm to set all values in sort_arr which would result in an sorted array, right? Well but your algorithm isn't working that well. See this line:
What happens when j is 1? arr[1] is then evaluated to 17 and 17 - 1 equals 16. So sort_arr[arr[1] - 1] is the same as sort_arr[16] which exceeds the bounds of your array. 
If you want to program a sorting algorithm by your self than I would recommend to start with an simple bubble sort algorithm. Otherwise, if you only need to sort the array have a look at the algorithm header. It is fairly simple to use:
By the way. You're looking for the biggest value in your array, right? After you have sorted the array sort_arr[N - 1] is the biggest value contained in your array.
",0,37481012
37485975,"
My guess is this is an attempt to implement a type of counting sort. Note that variable length arrays aren't normally allowed in C++ or some versions of C. You could use _alloca() to allocate off the stack to get the equivalent of a variable length array: int * sort_arr = (int *)_alloca(max * sizeof(int)); .
",0,37481012
37482281,"
If you want to sort a array into another array then one way is you make a copy of the array and then use the sort function in the standard library to sort the second array.
// this sort function will sort the array elements in ascending order and if you want to change the order then just add a comparison function as third arguement to the sort function. 
",0,37481012
37548261,"

In other words, atoms__d needs to be sorted with cellId as keys.

It should be possible to do that, at your indicated point in the refreshCellLists method.  For simplicity, I have chosen to use the raw device pointers directly (although we could easily wrap these raw device pointers in thrust::device_ptr also) combined with the thrust::device execution policy.  Here is a worked example:
When building thrust codes, especially on windows, I usually make a set of recommendations as summarized here.
",0,37433113
37383985,"
You pass a pointer to the vector, which basically means you try to sort an array of vectors, which is not correct and will lead to undefined behavior.
Instead you should pass the contents of the vector to the sorting function, using e.g. the data() member function:
",2,37383927
37384084,"
I would suggest having your functions accept a std::vector& rather than T[]. 
I would also suggest using std::swap instead of a custom version. – Alex Zywicki 3 mins ago   edit   
live demo:http://coliru.stacked-crooked.com/a/e22fe55a38425870
result is:
1 3 4 5 7 9
",0,37383927
37369858,"
As already suggested in other answers: Combining the name and the score of each individual is likely the simplest solution. 
Generically, this can be achieved with what is sometimes referred to as a ""zip"" operation: Combining two vectors into a vector of pairs - along with a corresponding ""unzip"". 
Implemented generically, this may look as follows:
",6,37368787
37368873,"
Best way to do this would be to have a struct which combines the names with their scores and have one vector.
Then you can declare your vector:
And sorting it is easy with std::sort from <algorithm>:
Or you can change the lambda if you want to sort in descending order:
",5,37368787
37368914,"
If you cannot merge the data into a vector of pairs or struct with both, you could create a vector of iterators, or the indexes from 0 to size-1.  Then sort this using a custom comparator.  Finally, create a new vector, populating it using the iterators or indexes.
",4,37368787
37368875,"
One way you could do this would be to store the Names and Scores in a single data structure such as a std::vector<std::pair<std::string,int>> and then sorting can be done as follows:
Alternatively, use storage such as a std::map or std::multimap if you want repeated keys (i.e. repeated names allowed).
",3,37368787
37370634,"
Couldn't this be done through a custom iterator type?
EDIT:
What I'm thinking in its simplest form - sorting a pair of vectors based on the first one - is to have an iterator whose functions such as dereferencing, subscripting, member access and equality and ordering comparisons would call the corresponding functions on the first iterator, all other functions (copy, arithmetics, swap, ...) acting on both iterators.  
The iterator could be extended into a multi_iterator to work with any reordering algorithm, pointing into any number of extra piggybacking sequences.
It could be a fun little project. Or maybe something similar already exists, in Boost or elsewhere.
EDIT2:
Forget the above.
Eric Niebler's Range-v3 library has a view::zip wrapper that ""Given N ranges, return a new range where Mth element is the result of calling make_tuple on the Mth elements of all N ranges.""
Sorting the range with a predicate on the first element of the tuples might just do the trick.
",1,37368787
46370189,"
So many asked this question and nobody came up with a satisfactory answer. Here is a std::sort helper that enables to sort two vectors simultaneously, taking into account the values of only one vector. This solution is based on a custom RadomIt (random iterator), and operates directly on the original vector data, without temporary copies, structure rearrangement or additional indices:
And this is an usage example that sorts both Names and Age based on Age values, employing standard std::sort:
sorted to:
Code tested on Visual Studio 2017 and GCC 5.4.0.
",0,37368787
37334524,"
There are a lot more factors to performance than just how many threads you throw at the problem.  Among them,

You need to have actual concurrency, not just multiple threads.  As @Rakete1111 and @user1034749 both observed, you don't.
Standard quicksort has good locality of reference, especially when partition sizes get small, but your technique throws a lot of that away because responsibility for a given array element is likely to be swapped to a different thread upon every partitioning.
Additionally, mutex operations are not particularly cheap, and you start doing quite a lot of those relative to the amount of actual sorting when the partitions get small.
It doesn't make sense to use more threads than you have physical cores.  Four threads is probably not too many, but it depends on your hardware.

Here are some ways you might improve your multi-threaded performance:

In method quick_sort(), do not hold mutex q_mutex locked during the actual sorting, as currently you do (the unique_lock constructor you are using locks the mutex, and you do not unlock it during the lifetime of the unique_lock).
Switch to the ordinary recursive technique for partitions smaller than some threshold size.  You'll have to test to find a good specific threshold value; perhaps it needs to be tunable.
At each partitioning, have each thread post only one of the sub-partitions to the portfolio; let it handle the other recursively -- or better, iteratively.  In fact, make it the smaller sub-partition that you post, as that will put a better bound on the size of the portfolio.

You might also consider increasing the number of elements on which you run your test.  100000 isn't really that many, and you might see different performance characteristics for larger problems.  1000000 elements is not at all unreasonable for such a test on modern hardware.
",6,37334109
37335941,"
It seems to me you should capture the behavior of portfolio tasks into a class.
The constructor would initialize the workers with threads that each call the work() method. The destructor would set quit_, signal all the threads, and join on them.
Then, your quick sort could be simplified:
Unfortunately, this way of formulating a parallel quick sort is unlikely to produce a large speedup. What you want to do is parallelize the partitioning task, which requires at least one single threaded computational pass (involving data comparison and swaps) before parallelization can begin.
It would probably be faster to first divide the array into WORK_SIZE sub-arrays, perform quick sort on each of them in parallel, and then merge the results to create your sorted vector.
",1,37334109
37322444,"
atan2 obviously won't help in generic case. It is mostly good for convex figures. Consider a narrow rectangle with (0,0) inside and an adjacent rectangle and try to sort their points by their atan2.
Have you tried painting a point in the set and then looking for the closest not yet painted point as an iteration step?
",1,37322047
37323988,"
If you're dealing with curves only then I'd suggest to use following algorithm:

Define angle range R
Take initial point A, mark it as visited
Find closest to A point B, mark it as visited
Calculate the direction formed by vector [A, B]
Find closest to B unvisited point C in angle range R and mark it visited
Go to step 4 with B as A and C as B

This is not an ultimate solution but it should be able to find basic curves and some polygons. With wider angle range R you can approximate more curved lines.
",0,37322047
37289122,"
Fixed It, Just changed the
to 
",-1,37288994
37289716,"
the code is okay but your compiler uses stack very ineffectively. you just need to raise reserved stack amount. it happens much more often in debug profiles rather than release ones just because compiler preserves large stack chunks to check if stack was broken during execution of your procedure.
",0,37288359
37288443,"
For sorted elements, you can avoid this problem by choosing the median of the three elements array[start], array[last] and array[(start + last + 1)/2] as your pivot value.
An additional strategy to avoid a large stack depth is to calculate which partition is smaller, and recursively call the smaller one. The other partition can then be optimized into a loop (tail recursion optimization).
Introspection can also be used to avoid a large stack depth. You track your recursive call depth, and if it is ""too deep"", you fail safe into a different sorting strategy, like merge sort or heap sort. This is the behavior currently used by std::sort.
",3,37288359
37293055,"
Example of Lomuto partition scheme like quicksort that uses recursion on the smaller partition, updates l or r, then loops back to split the larger partition into two partitions, repeating the process. Worst case stack space is O(log2(n)) which should avoid stack overflow. Worst case time complexity is still O(n^2) (depending on how partition is implemented).
Some call this example a half recursion. It's not an example of tail recursion, since tail recursion means that the recursive function just returns after calling itself. The second call in the original question example is a tail call.
",0,37288359
37268729,"
The reason's your broken logic...
For example, if a.fields.instrument[1] <= b.fields.instrument[1] you return true to say a < b, but a.field.instrument[0] might be greater than b's.
I could tell you how to fix it, but have a think yourself, and try a couple examples on paper.
",2,37268659
37268697,"
You need to pass the vector as reference:
Such large objects should always be passed as reference, or as const reference if called function doesn't modify it. Ideally never as copy.
",1,37268659
37248508,"
If I understand your question correctly, you want to calculate the inverse of the sorted permutation of B, and then order sorted A in that order.  You can do this pretty easily with the standard library.
Then you can indirect through pinv to get A in the order you want.
",1,37242285
37247444,"
From your first example, it appeared that you wanted to permute A using an array of indices B. But the second example shows that you actually do want a sort, but with comparisons based on the values in B rather than those in A.
So what you need is a sort function which takes a ""sort key function"". The sort key function should be passed an array index as an argument.
C's qsort does take a key function, but the arguments to the key function are the values being compared, not the indices of the values being compared. So it won't work for you.
You'll probably have to write your own sort function. It's not hard. If the arrays are small, a simple insertion sort will do just fine:
(You'll have to write your own swap.)
If the arrays are larger, you can code yourself up a recursive or iterative quicksort. It's not hard either. Make sure you also write some test cases to ensure it works. Your test cases should include empty arrays and arrays with 1 item.
",4,37242285
37242615,"
Looks like this is a copy operation and not a sort.  
The second array shows the ordering of the elements of the first array.  The difference is to subtract 1 from the second array to get the offset of the sorted array.
",3,37242285
37240176,"
The second method is sorting all the \0 elements to the front.  (They are less than any of the other characters.
When you try and print it with .data() you get a char const* object back which to the stream class is treated like a C-String. Which is a null terminated string. Since the first character is a null it prints nothing.
You could fix with
This uses a comparator which sorts \0 at the end.
But as Jerry Coffin said in comments, std::array is not std::string - use the one which fits your needs (probably std::string in this case).
",4,37240167
37240302,"
You're printing a C-String, which relies on the existence of a terminating null character: \0.
When you sort the entire array, you move that null character to the front, which tells your print functions that it is an empty string.  
Thus, you have no choice but to use the uglier version.  That being said, here's a safer way to write it which you may prefer:
",2,37240167
37234604,"
The are lots of thing to improve in your code. You have several syntax errors too. I recommend trying to debug you code first. But, the sorting part can be done as follows. First, make pairs from the data (id, netpay). Then, save pairs in a container like std::vector. Next, sort the pairs using std::sort with respect to their second elements, netpays. Finally, write back the data from pairs into id and netpay arrays.
You may check the code here and extend it as you progress. Of course, things can be simplified if you use std::vector instead of arrays and particular data structure for your input data.
",3,37234460
37224976,"

do I need to convert each element in the vector from string to double before calling sort?

This depends on the order that you would like to achieve, and on the numbers stored in the array. If all numbers have exactly one digit before the dot, you wouldn't see a difference; if some numbers have multi-digit whole part, your sort would be incorrect, because strings are alphabetized. For example, ""2.0"", ""9.0"", ""10.0"" would be sorted as follows:
As far as ""before"" in ""before calling sort"" is concerned, the conversion does not need to happen before sorting; you could perform it as you go if you use a custom comparison function:
Demo.
",4,37224899
37224969,"
Try this:
The output is n2 is less because the character '5' is greater than the character '1'. This is what happens if you compare the strings directly.
",1,37224899
37225142,"
C++ converts each character of the string to ascii code, and then it orders by ascii order, so this doesn't work, u have to convert each string to a numerical type to order it properly.
",1,37224899
37226756,"
The cost of converting a string to a double is actually pretty high.
A naive approach to this sort is to compare on the predicate stod(l) < stod(r). 
As the following test shows, in situations where the vector to be sorted is large, it's actually worth performing the conversions once and sorting the converted vector.
Here is the optimised algorithm:
And here's the test that argues for this approach (compiled on macbook pro with -O3 -march=native:
typical results:
",1,37224899
37199441,"
Think of Comp as some sort of ""is smaller than"" relationship, that is it defines some kind of ordering on a set of data.
Now you probably want to do some stuff with this relationship, like sorting data in increasing order, binary search in sorted data, etc. 
There are many algorithms that do stuff like this very fast, but they usually have the requirement that the ordering they deal with is ""reasonable"", which was formalized with the term Strict weak ordering. It is defined by the rules in the link you gave, and the first one basically means:
""No element shall be smaller than itself.""
This is indeed reasonable to assume, and one of the things our algorithms require.
",4,37199391
37176163,"
n is the size of arr. If n is even, on the last iteration of this for loop i will n-1, or odd, and this will end up swapping arr[n-1] with arr[n], which is undefined behavior because, of course, there is no arr[n].
This is where your random value comes from. Fortunately, it looks like you're managing to skate by without blowing up your stack, entirely.
",2,37176125
37149409,"
Use a std::vector or std::array and then run sort on the container after each step.
Note:
Don't, as suggested in the comments, use a std::multiset or std::set or std::map by changing the key! You can remove the old key and replace with a new one. Since you are changing all the elements,  it will be faster to run sort after each step rather than use a map or set which will sort after each insert.
You can do something like the following:
",1,37148983
37138180,"
",0,37137167
37136002,"
You need following fixes (at least to make this compile):
add method get_color to ColPoint3:
change signature of get_volume:
and finally define your constructors
[edit]
as for sorting, why not std::sort ?
",1,37135907
37121563,"
Looks like your bug is here
This should be
Its hard to tell if there are other errors but I suspect there are more here.
By using the length here (lengthToSort).
The point arrayToSort + lengthToSort is one past the end. This sort of indicates that you are using the standard C++ idiom of [begin,end).
This next call seems to follow that convention.
But this calls seems to indicate that length is inclusive. As you are excluding midIndex from the range (which means it should be in the call above). But that means lengthToSort should also be in the range below but that is not the implication of the original call.
Are your ranges correct? To help make this explicit a lot of implementations make this explicit by using the interface.
",0,37121452
37112117,"
With the update, this is now fairly trivial. You want to sort the points by atan2(p1.y,p1.x) < atan2(p2,y, p2,x).
",2,37110962
37105343,"
As pointed out in the comments, use std::sort.  In addition, you could also use std::max_element to find the maximum (and std::min_element to find the minimum).
Here is displayMax using std::sort, and std::max_element
The max_element function will return a pointer to the maximum value found in the range grades[i][0] to grades[i][MAX_GRADES].  Note we have to give std::max_element pointers to the beginning and end items, since max_element and most of the other STL algorithm functions use iterators as parameters, and a pointer is an iterator type.
Then we sort the students using std::sort, and give the predicate that we want to sort on the max value that we set in the loop above.  Note that the sorting is done in descending order, and that is controlled by the predicate
return s1.max > s2.max;
In other words, return true if s1's maximum value is higher than s2's maximum value (meaning the items are in order), else return false (the items are out of order).
You would write a similar function for finding the minimum value using std::min_element.  To find the average, you can use std::accumulate, but you have a loop already set to get the average, so I guess that will work fine also (with the change to the predicate to sort on average).
Live Demo Here
",0,37104659
37104961,"
use std::sort with a custom predicate:
",0,37104659
37098458,"
",1,37098158
37098615,"
As mentioned in a comment (sorry, too difficult to type to give credits) you could use a std::map. A maps elements are sorted and you save the extra effort of doing that ""by hand"". If you need two different ways of sorting you could use two maps or some other container and sort that twice. E.g. with a vector:
",1,37098158
37089107,"
STL is there to help avoid errors and wasting time debugging common algorithms such as this.
Or as Jarod42 points out, you can do it in place with
",0,37089007
37089104,"
You have 10 elements in your list (lsize), however are looping 11 times in your print statement (0 to lsize-1). 
",0,37089007
37089151,"
With <algorithm>, you may do
Demo
",0,37089007
37090269,"
Thanks a lot guys !!
I also found out that the if(condition) and  first if else(condition) were missing a condition as follows:
and
that is a third condition from each.
",0,37089007
37089504,"
C++ does not allow variable sized list. So, you should get an error in second line of your code.I don't know how it's working for you. Secondly, lsize should be 10 instead of 11.
",-1,37089007
37081133,"
You need to supply a custom comparator to the sort function.
Output:
",0,37081018
37081244,"
Here is how you can do this. Use comparator for the sort function as follows. Here is the link.
",0,37081018
37081079,"
Let's say we have two arrays A and B, of sizes m, and n respectively, with m <= n.
Then we have the following:

Lemma: The median of A and B is the same as the median of A and B', where B' is the middle m or m + 1 elements of B, depending on whether m and n have the same parity or not.

Now it only remains to use your O(log(m + n)) algorithm to find the median of A and B'.
Proof of the lemma: almost obvious ...
",0,37080689
37079215,"
One of the std::sort function overloads takes a comparator, use that form and provide it with two independent functions or functors (or lambdas) for each instantiation. 
Note the sort requires a comparison that obeys its ordering requirements, usually it uses a less than comparison to order the elements. The exact comparison can be different, but needs to obey the same ordering requirements (for further reading, see the information for the std::sort algorithm, and this on strict weak ordering).
",5,37079163
37079510,"
As suggested you could use std:sort algorithm.
You need to create 2 function each for sum and Id comparison and pass them as function pointer for comparison.
and to use them you need to invoke sort in this way
Apart from comparison function you could use more sophisticated approach by using functors or function objects.
",0,37079163
37079646,"
Instead of relying on operator< to do your sorting, you can explicitly pass a comparator to std::sort:
",0,37079163
37062576,"
std::back_insert_iterator is a template, like std::vector.
Do you think that something like:
would compile? Of course not. You need to specify the template parameters. What is it? std::vector<int>, or std::vector<char>, etc...
After examining your code, I believe you want this to be:
I haven't followed all the math here, so this may or may not be right, but at least it compiles, now.
P.S. This is redundant:
You're initializing a vector of a fixed size. Then you immediately replace the vector's contents. It is perfectly sufficient to have just:
Ditto for the other initialization, too.
",2,37062512
495056,"
It is not necessary to put the implementation in the header file, see the alternative solution at the end of this answer.
Anyway, the reason your code is failing is that, when instantiating a template, the compiler creates a new class with the given template argument. For example:
When reading this line, the compiler will create a new class (let's call it FooInt), which is equivalent to the following:
Consequently, the compiler needs to have access to the implementation of the methods, to instantiate them with the template argument (in this case int). If these implementations were not in the header, they wouldn't be accessible, and therefore the compiler wouldn't be able to instantiate the template.
A common solution to this is to write the template declaration in a header file, then implement the class in an implementation file (for example .tpp), and include this implementation file at the end of the header.
This way, implementation is still separated from declaration, but is accessible to the compiler.
Another solution is to keep the implementation separated, and explicitly instantiate all the template instances you'll need:
If my explanation isn't clear enough, you can have a look at the C++ Super-FAQ on this subject.
",1311,37055992
1272085,"
Plenty correct answers here, but I wanted to add this (for completeness):
If you, at the bottom of the implementation cpp file, do explicit instantiation of all the types the template will be used with, the linker will be able to find them as usual.
Edit: Adding example of explicit template instantiation. Used after the template has been defined, and all member functions has been defined.
This will instantiate (and thus make available to the linker) the class and all its member functions (only). Similar syntax works for template functions, so if you have non-member operator overloads you may need to do the same for those.
The above example is fairly useless since vector is fully defined in headers, except when a common include file (precompiled header?) uses extern template class vector<int> so as to keep it from instantiating it in all the other (1000?) files that use vector. 
",219,37055992
16493574,"
It's because of the requirement for separate compilation and because templates are instantiation-style polymorphism.
Lets get a little closer to concrete for an explanation. Say I've got the following files:

foo.h

declares the interface of class MyClass<T>

foo.cpp

defines the implementation of class MyClass<T>

bar.cpp

uses MyClass<int>


Separate compilation means I should be able to compile foo.cpp independently from bar.cpp. The compiler does all the hard work of analysis, optimization, and code generation on each compilation unit completely independently; we don't need to do whole-program analysis. It's only the linker that needs to handle the entire program at once, and the linker's job is substantially easier.
bar.cpp doesn't even need to exist when I compile foo.cpp, but I should still be able to link the foo.o I already had together with the bar.o I've only just produced, without needing to recompile foo.cpp. foo.cpp could even be compiled into a dynamic library, distributed somewhere else without foo.cpp, and linked with code they write years after I wrote foo.cpp.
""Instantiation-style polymorphism"" means that the template MyClass<T> isn't really a generic class that can be compiled to code that can work for any value of T. That would add overhead such as boxing, needing to pass function pointers to allocators and constructors, etc. The intention of C++ templates is to avoid having to write nearly identical class MyClass_int, class MyClass_float, etc, but to still be able to end up with compiled code that is mostly as if we had written each version separately. So a template is literally a template; a class template is not a class, it's a recipe for creating a new class for each T we encounter. A template cannot be compiled into code, only the result of instantiating the template can be compiled.
So when foo.cpp is compiled, the compiler can't see bar.cpp to know that MyClass<int> is needed. It can see the template MyClass<T>, but it can't emit code for that (it's a template, not a class). And when bar.cpp is compiled, the compiler can see that it needs to create a MyClass<int>, but it can't see the template MyClass<T> (only its interface in foo.h) so it can't create it.
If foo.cpp itself uses MyClass<int>, then code for that will be generated while compiling foo.cpp, so when bar.o is linked to foo.o they can be hooked up and will work. We can use that fact to allow a finite set of template instantiations to be implemented in a .cpp file by writing a single template. But there's no way for bar.cpp to use the template as a template and instantiate it on whatever types it likes; it can only use pre-existing versions of the templated class that the author of foo.cpp thought to provide.
You might think that when compiling a template the compiler should ""generate all versions"", with the ones that are never used being filtered out during linking. Aside from the huge overhead and the extreme difficulties such an approach would face because ""type modifier"" features like pointers and arrays allow even just the built-in types to give rise to an infinite number of types, what happens when I now extend my program by adding:

baz.cpp

declares and implements class BazPrivate, and uses MyClass<BazPrivate>


There is no possible way that this could work unless we either

Have to recompile foo.cpp every time we change any other file in the program, in case it added a new novel instantiation of MyClass<T>
Require that baz.cpp contains (possibly via header includes) the full template of MyClass<T>, so that the compiler can generate MyClass<BazPrivate> during compilation of baz.cpp.

Nobody likes (1), because whole-program-analysis compilation systems take forever to compile , and because it makes it impossible to distribute compiled libraries without the source code. So we have (2) instead.
",196,37055992
495048,"
Templates need to be instantiated by the compiler before actually compiling them into object code.  This instantiation can only be achieved if the template arguments are known. Now imagine a scenario where a template function is declared in a.h, defined in a.cpp and used in b.cpp. When a.cpp is compiled, it is not necessarily known that the upcoming compilation b.cpp will require an instance of the template, let alone which specific instance would that be. For more header and source files, the situation can quickly get more complicated.
One can argue that compilers can be made smarter to ""look ahead"" for all uses of the template, but I'm sure that it wouldn't be difficult to create recursive or otherwise complicated scenarios. AFAIK, compilers don't do such look aheads.  As Anton pointed out, some compilers support explicit export declarations of template instantiations, but not all compilers support it (yet?).
",68,37055992
495511,"
Actually, prior to C++11 the standard defined the export keyword that would make it possible to declare templates in a header file and implement them elsewhere.
None of the popular compilers implemented this keyword. The only one I know about is the frontend written by the Edison Design Group, which is used by the Comeau C++ compiler. All others required you to write templates in header files, because the compiler needs the template definition for proper instantiation (as others pointed out already).
As a result, the ISO C++ standard committee decided to remove the export feature of templates with C++11.
",56,37055992
495032,"
Although standard C++ has no such requirement, some compilers require that all function and class templates need to be made available in every translation unit they are used. In effect, for those compilers, the bodies of template functions must be made available in a header file. To repeat: that means those compilers won't allow them to be defined in non-header files such as .cpp files
There is an export keyword which is supposed to mitigate this problem, but it's nowhere close to being portable.
",32,37055992
16509701,"
Templates must be used in headers because the compiler needs to instantiate different versions of the code, depending on the parameters given/deduced for template parameters. Remember that a template doesn't represent code directly, but a template for several versions of that code. 
When you compile a non-template function in a .cpp file, you are compiling a concrete function/class. This is not the case for templates, which can be instantiated with different types, namely, concrete code must be emitted when replacing template parameters with concrete types.
There was a feature with the export keyword that was meant to be used for separate compilation.
The export feature is deprecated in C++11 and, AFAIK, only one compiler implemented it. You shouldn't make use of export. Separate compilation is not possible in C++ or C++11 but maybe in C++17, if concepts make it in, we could have some way of separate compilation.
For separate compilation to be achieved, separate template body checking must be possible. It seems that a solution is possible with concepts. Take a look at this paper recently presented at the 
standards commitee meeting. I think this is not the only requirement, since you still need to instantiate code for the template code in user code. 
The separate compilation problem for templates I guess it's also a problem that is arising with the migration to modules, which is currently being worked.
",26,37055992
495128,"
It means that the most portable way to define method implementations of template classes is to define them inside the template class definition.
",14,37055992
37189280,"
Even though there are plenty of good explanations above, I'm missing a practical way to separate templates into header and body.
My main concern is avoiding recompilation of all template users, when I change its definition.
Having all template instantiations in the template body is not a viable solution for me, since the template author may not know all if its usage and the template user may not have the right to modify it.
I took the following approach, which works also for older compilers (gcc 4.3.4, aCC A.03.13).
For each template usage there's a typedef in its own header file (generated from the UML model). Its body contains the instantiation (which ends up in a library which is linked in at the end).
Each user of the template includes that header file and uses the typedef.  
A schematic example:
MyTemplate.h:
MyTemplate.cpp:
MyInstantiatedTemplate.h:
MyInstantiatedTemplate.cpp:
main.cpp:
This way only the template instantiations will need to be recompiled, not all template users (and dependencies).
",11,37055992
7452293,"
That is exactly correct because the compiler has to know what type it is for allocation. So template classes, functions, enums,etc.. must be implemented as well in the header file if it is to be made public or part of a library (static or dynamic) because header files are NOT compiled unlike the c/cpp files which are. If the compiler doesn't know the type is can't compile it. In .Net it can because all objects derive from the Object class. This is not .Net.
",6,37055992
38604074,"
If the concern is the extra compilation time and binary size bloat produced by compiling the .h as part of all the .cpp modules using it, in many cases what you can do is make the template class descend from a non-templatized base class for non type-dependent parts of the interface, and that base class can have its implementation in the .cpp file. 
",6,37055992
43948426,"
A way to have separate implementation is as follows.
inner_foo has the forward declarations. foo.tpp has the implementation and include inner_foo.h; and foo.h will have just one line, to include foo.tpp.
On compile time, contents of foo.h are copied to foo.tpp and then the whole file is copied to foo.h after which it compiles. This way, there is no limitations, and the naming is consistent, in exchange for one extra file.
I do this because static analyzers for the code break when it does not see the forward declarations of class in *.tpp. This is annoying when writing code in any IDE or using YouCompleteMe or others.
",2,37055992
51412815,"
Just to add something noteworthy here. One can define methods of a templated class just fine in the implementation file when they are not function templates.

myQueue.hpp:

myQueue.cpp:
",2,37055992
38448106,"
The compiler will generate code for each template instantiation when you use a template during the compilation step. 
In the compilation and linking process .cpp files are converted to pure object or machine code which in them contains references or undefined symbols because the .h files that are included in your main.cpp have no implementation YET. These are ready to be linked with another object file that defines an implementation for your template and thus you have a full a.out executable.
However since templates need to be processed in the compilation step in order to generate code for each template instantiation that you do in your main program, linking won't help because compiling the main.cpp into main.o and then compiling your template .cpp into template.o and then linking won't achieve the templates purpose because I'm linking different template instantiation to the same template implementation! And templates are supposed to do the opposite i.e to have ONE implementation but allow many available instantiations via the use of one class.
Meaning typename T get's replaced during the compilation step not the linking step so if I try to compile a template without T being replaced as a concrete value type so it won't work because that's the definition of templates it's a compile time process, and btw meta-programming is all about using this definition.
",1,37055992
37045058,"
ADDED
the same with vectors:
",1,37042618
37037905,"
Since you want to sort based on the first two columns, the compare function needs to use both values. Also, change the return type of compare to bool
and the argument types to const&.
",3,37037776
37015561,"
@immibis has answered this, could you tag it as answered please?

alphabet[1] should be alphabet[0] and alphabet[2] should be alphabet[1] – immibis

",0,37015270
37011792,"
should be
Demo
",3,37011719
37012312,"
You can also take advantage of template deduction so you don't have to provide a type or size every time.
This is fine, but you have to provide a size each time. This could be annoying if you declared it like this:
For this, you can create a very simple template wrapper (I put two):
The reason for the second one is that you can pass a size_t ref into it and it will set that as the size. For example, you could run either of these:
The reason you may want to use the last one is that now you have a way of printing the correct size.
Of course this specific template will only work on stack-based arrays, not dynamically allocated ones, but you can always use the other call.
",0,37011719
37009112,"
There's no shortcut in this case.  You should check each element of the smaller set for membership in the larger set and insert it into an output set if it's found.  Since unordered_set is implemented using a hash with buckets, the lookup times should (with a decent hash function and reasonable maximum loading of the hash) be small.  You should be able to write a call to for_each on the smaller set that performs the check on the larger one and the insert into the output set without it getting too ugly.
If you want to build the intersection in place in one of the two original sets, you could check whether each of its elements is in the other set and remove that element if not.  This could be written with remove_if on the unordered_set that will hold the result.
Yet another option would be to use copy_if with an insertion iterator.  There are lots of options for doing this within the same time and space.  Pick one that seems to optimize for clarity.
I know of no canned library function that will just do it for you.
",1,37008631
37008769,"
I don't know of any such function in C++11. The answer is ""no"".
",2,37008631
36977798,"
Checks if (n - 2) is a power of 3 and is less than or equal to 2187 (3 to the power of 7)
As a generalization, to check if any unsigned integer n is a power of prime number k, you can check if n divides the largest power of k that can be stored in an unsigned integer. 
",25,36977353
36988932,"
This is very similar to recognizing a power of three, and you can adapt for example this solution:
With the given range, this can be further simplified (found by brute force):
",8,36977353
36978579,"

Hint: this time the numbers a[k] form a geometric progression: a[k]=2+3^k.

with definition of function isPow(x,y)
Similiarly we can deduct k..
",5,36977353
36977691,"
Found a similar problem in a related post:
You can use std::find
(make sure you include <algorithm>).
For this kind of stuff, in 99% of cases, there is a library that does the job for you.
",3,36977353
36984608,"
One very efficient way to do this sort of thing is with a set, especially an unordered_set. As a hash table, search is average constant, worst linear. It is also much more elegant than a string of conditions and scales well.
Simply insert the values you want to compare against, and count the value in the set. If it is found, it's one of your tested values.
",3,36977353
36977577,"
Here's what I came up with:
As the number n is a small integer, floating point inaccuracies shouldn't be a problem.
Ofcourse it won't be as fast as integer arithmetic, an it doesn't fit snuggly in an expression, it is probably faster than some kind of array search, especially if you where to increase the maximum n value.
EDIT I tested my code (without optimizations enabled) and on average (for all n less than or equal to 2189) my version took 185.849 ns wheras the || version took 116.546 ns, (running my program multiple times yielded similar results) so this is not faster.
Also for some bizarre reason, it sets b to false when n == 245, (it should be true).
",0,36977353
38464886,"

I have a list of data (in 4 columns) that I would like to sort by a
  certain column.

The problem is that the dimensions of the vector of vectors used to store the data in OP program is not consistent between declaration and use.
A minor problem is the use of while(!infile.eof()){... which should be avoided.
A fixed version is like this:
The output, given the example data is:
",2,38463158
38453426,"
It may be more logical to represent a line segment as an object, like:
And the set of line segments (called ""line"") as a vector of LineSegment:
This groups the ""line segments"", which should not be split when sorting, like:
With the code in the answer it is like:
Then line can be sorted as a whole using a comparator function that compares LineSegment instances:
",3,38452763
38453065,"
If there is no reason behind the choice of a vector, you could use a regular map:
This will output:

Segment of length: 10 and angle: 30
  Segment of length: 50 and angle: 20
  Segment of length: 100 and angle: 10

",1,38452763
38451620,"
Logarithmic complexity is almost always fast enough. std::map and std::set also have another advantage over hash tables - the performance is guaranteed 100% of the time, a property very useful in e.g. hard real-time systems. A hash table is faster than a red-black tree (map,set) most of the time, but e.g. if a rehash is necessary, worst-case performance will hit you.
",0,38448521
38448735,"

std::unorderd_set Solution

Instead of std::set<std::shared_ptr<Node>>, you can use std::unordered_set<Node*> to mark the visited nodes. unordered_set use hash to index nodes (complexity: constant on average), and it should be faster than set in most cases. Also save the raw pointer, i.e. Node*, in container, is faster than shared_ptr, since there's no reference count operations.
If this solution takes too much memory, you can try the bitmap solution.

bitmap Solution

Give each node an id beginning from 0, and use a bitmap to save the visited status.
Initialize the bitmap with all bits setting to 0. When visiting the nth node (whose id is n), set the nth bit on the bitmap. When you want to find out if a given node has been visited, you just check whether the corresponding bit has been set.
This solution only takes n bits of memory, where n is the number of nodes in your tree.
",0,38448521
38423114,"
The performance between the different methods is not very different, however, using < will let you be more flexible, and makes using built-ins much easier.  I also think using () is kind of weird.
The bigger issue in your example is that your methods should be using const refs instead of values.  I.e. bool operator<(Student ob) could be friend bool operator<(const Student& ls, const Student& rs){...}.  Also, see here for some examples of different things to consider when overloading operators. 
",2,38422886
38423002,"
The performance is not going to be noticably different. But it's convenient (and expected) in many cases to have a operator<, so I'd go for that over the special compare function.
",0,38422886
38423057,"
There really is no ""right"" way per se, but if it makes sense for your object to have custom comparators (i.e. operator< etc.) then it would be wise to simply use those. However you may want to sort your object based on a different field member and so providing a custom lambda based on those field comparisons would make sense in that case.
For example, your Student class currently uses an overloaded operator< to compare student ages, so if you are sorting a container of Students based on age then just use this operator implicitly. However, you may want (at another time) to sort based on the names so in this case you could provide a custom lambda as the most elegant method:
where the student names are sorted via lexicographical comparisons.
",0,38422886
38434051,"

How are these methods different and how should I decide between these.

They differ in their implicit statements of intent. You should use the form that expresses your intent most succinctly.
Relying on operator< implies to someone reading your code that your objects are implicitly ordered, like numbers or strings. They ought to be things that people would say, ""well obviously x comes before y"".
If the ordering of the map is more abstract, then an ordering function might be better because it expresses the idea that you are imposing an order on the map which may not be a natural order.
in the example you give, I might choose to express the intent in either a function object called ageIsLess for example. As a reader of code using the map is now fully aware of intent.
For example:
",0,38422886
38410395,"
For sort to work elements must necessarily be assignable; however, your tuple elements are all const, so obviously not assignable. Drop the consts:
Online Demo
",1,38410034
38410606,"
other way is to get index of sorted elements:
",0,38410034
38410610,"
the problem is in calculation of number of inversions that we get on each step. Lets take a look on merging: 
We have two arrays L and R, and on each iteration we look on first numbers in each array (coz they are already sorted):
1). L[i] <= R[j]. That means that L[i] don't create new inversion with some remaining element from R. 
2). L[i] > R[j]. That means that R[j] will create inversion with L[i], L[i + 1], L[i + 2], ..., L[n1 - 1]. From what I see your bug is in count  calculation. You add (m - i) instead of (n1 - i). 
One more bug that I see is in type of count. If you assume size to be quite big (~10^5) you need some bigger type to store your value.
Hopefully that helps.
",2,38408192
38402295,"
As the other answer alluded to, you have an out-of-bounds access error.  
In addition, you are lucky your program even got as far as it had, since you have an out-of-bounds access on the very first call of SortAndAggreate, thus the output you're showing in your question is basically useless since undefined behavior is being invoked.
In your MyComparator functor, you're doing this:
The value_vector is a vector that has size==10.  However, the values of i1 and i2 eventually become 9, and 10, thus you will be accessing an element that's out of bounds.
The problem's genesis is here in main:
You use these values as indices when you populate prof_buf_cnt, and you're using prof_buf_cnt as the indices within the std::sort functor MyComparator.  
The solution, at least here, is to use 0-based indices.

Note: If you replaced that line in your MyComparator functor with the following:
you would have seen the issue right away, as an std::out_of_range exception would have been thrown.  This would have guaranteed that your program would have stopped with an error, instead of going on and giving the impression that it was working properly (with the only problem being the output being wrong).

For an example of how unpredictable undefined behavior can be, see the two links below:
See this example of your code using at()
See this example of your code using [ ]
Note that the second link above shows your code ""working"", even though it shouldn't have gone as far as it did, while the first link properly diagnosis the issue by throwing an exception.
",2,38401734
38401812,"
i will be at most .size()-1 here:
but you then index the array with i+1, which is beyond the last element of arr.
",1,38401734
38382181,"
You could simply transpose the arguments to std::less with the help of std::bind:
But I think it'd be much cleaner to simply write the equivalent short lambda, even if it goes against the constraint of not writing your own Comparator:
",7,38382094
38382685,"
",2,38382094
38383852,"
You can sort array by using std::sort and then reverse it with std::reverse. This will sort in your desired way.
",0,38382094
38312154,"
You can change your variable from
to a
or
Then std::sort will just work as you intend since std::pair and std::array already have an operator< defined.
",4,38312133
38312204,"

What is the problem with my code?

In fact c-style arrays cannot be assigned, and std::sort calls the assignment operation implicitly. They need to be filled using std::copy or alike.
I'd recommend you use a std::array<std::array<int,2>,1000> instead of the raw array.
",1,38312133
38308677,"
Having a map or a set makes sense if and only if you are going to do many insert/erase operations it. If the data structure is static, storing a vector and sorting it once is way more effective. That said, if I understand your question correctly, I think you don't need a map, but a multiset.
here, the operator < of pair will take care of the ordering. 
If you don't want to refer to the id as elem.first, and to the strings as elem.second.first, and elem.second.second, then you can use a struct and overload operator < for it.
",0,38308550
38308685,"
You could just use a std::set<std::tuple<int, std::string, std::string>>. Tuples are lexicographically compared thus you would get the effect you want for free.
Live Demo
",0,38308550
38308687,"
Elements in a multimap are sorted by the Key. You cannot 'sort' multimap. What you can do is to create vector of pairs<Key, Map<Key>::Interator> with elements fulfilling some logical condition and sort vector.
",0,38308550
38295472,"
There are many ways to get parallel sort without writing your own. First, there is an experimental parallelism namespace that lets you say sort(par, data.begin(), data.end()): http://en.cppreference.com/w/cpp/experimental/parallelism/existing#sort
That namespace is being merged into the standard in C++17, so it should be in the std:: namespace at some point (https://parallelstl.codeplex.com/). There is also an older nonstandard GNU g++ parallel sort implementation based on OpenMP: https://gcc.gnu.org/onlinedocs/libstdc++/manual/parallel_mode.html
Finally, there are many pages online describing how to write your own parallel sort in C++11. Try searching. Here is a very comprehensive page: https://software.intel.com/en-us/articles/a-parallel-stable-sort-using-c11-for-tbb-cilk-plus-and-openmp
",2,38295351
38295886,"
Example multi-threaded bottom up merge sort, using Windows threading interface, in this case 4 threads meant for a processor with 4 (or more) cores. Depending on the size of the array, it's about 3 times as fast as a single threaded merge sort, mostly due to the operations that occur within each core's local L1 and L2 cache. The semaphores are used to start all threads at the same time for benchmarking purposes. On my system (Intel 2600K 3.4ghz), it takes about 0.5 seconds to sort 16 million 32 bit integers, versus about 1.5 seconds for a single threaded merge sort.
",1,38295351
38244299,"
You can do:
The + 1 is necessary because the end iterator must point 1 element after the last element of the row vector. 
If you want to sort the whole row, you can do it more elegantly like
",3,38244246
38194059,"
The line
should be
On a deeper note, the average complexity for insertion sort is O(n^2) so that it works best for small arrays. That is, it is not the correct algorithm for sorting 50,000 values.
",2,38193980
38193015,"
Your code breaks because you are using erase incorrecrly: you need to pass the begin() of the vector being erased.
However, using erase is a bad idea to begin with, because it makes your sort asymptotically slower by a factor of N. You should make a pair of iterators, one for left and the other one for right, and move them as you progress through your arrays. This will keep merge an O(n) operation, instead of O (n^2) in your current implementation.
",1,38192866
38193057,"
Never ever do this.  foo.erase requires a member of foo.  
Even if you wrote left.erase(left.begin());, this would still be a terrible coding, and I mean terrible.  Unless you erase last element, or one very close to the end, erasing a vector element is slow like hell. It takes O(N) steps.  So don't erase (or insert, for that matter) vector elements, unless you are absolutely sure it is a right thing to do.
The whole point of the merge sort is to do sorting in O(N log N) steps.  By using erase, you make it O(N**2*log N) steps.
And don't ever call your function ""sort"", because there is a sort function already in STL. It is confusing.  Calling a global (not member) function ""sort"", ""exp"", ""abs"", etc. is really a bad idea.  With member functions, it is slightly better. Calling your function ""sort"" is as if I would change my name to Matt Mclaugin, and went to live near you.
Newbies also like to call a vector ""list"".  I'll never understand why.
You should copy the error message(s) exactly as they were, not ""some of the error message"".
Besides, your code is not complete.  You should present enough of your code so that we'll be able to reproduce your error.
",1,38192866
38184979,"
std::greater is a functional object that is it is a structure that provides the function call operator.
Expression
calls the constructor of the structure and creates a temporary object of type std::greater<std::string> for which the function call operator can be called in an algorithm.
Relative to your function object definition
to create an instance of the class you should use expression
So you can write either
or
Take into account that the results are equivalent for these code snippets
and
",4,38184800
38184927,"

Why do I have to pass instance() as argument instead of instance.

You don't.
Either pass instance (the name of the instance), or A() (which is a separate, temporary, instance).

One more thing , when I pass something like greater(), I am not even instantiating the class !

Sure you are. This is a temporary of type greater.

Don't forget to make your operator() be public.
",3,38184800
38172199,"
The runtime is bounded by the sorting step, O(nlgn). The for loop may have O(n) complexity, but the overall runtime is always dominated by the highest power. See here for a mathematical proof: 
https://math.stackexchange.com/questions/324200/big-o-notation-sum-rule
",1,38172087
38172202,"
Yes, you can sum them: O(n) and O(n log n) becomes O(n + n log n).  But note this is not O(2n log n) as you suggest, because addition comes after multiplication in basic arithmetic.
Now, just as O(1 + n) is always reduced to O(n), your O(n + n log n) will be reduced to O(n log n) because the solitary n term is less than the n log n term, and big-O notation is always about the limits, not the exact equation.
Some people might find it more intuitive to recognize from the outset that O(n) is dominated by O(n log n), and never sum them in the first place.  That's a useful mental shortcut, but both perspectives get you the same result.
",1,38172087
38172164,"
The complexity class O(N) is a subset of the class O(N log N), since log N > 1 for sufficiently high N. Thus, the complexity class of the code O(N + N log N) is a subset of O(2 N log N), and since the complexity classes are invariant w.r.t. constants, it's O(N log N) at the end.
",0,38172087
38172193,"
The way we calculate complexities is by choosing the highest among all the ones.
So, lets suppose you have the following code
So, here there the complexities would be O(n^2) + O(n). Which would finally be O(n^2). So, the complexity of the whole above code is O(n^2).

Similarly, in your case the complexity is O(N log N) + O(N), which makes the final complexity to be O(N log N)
",0,38172087
38172233,"
First of all, O(N+N log N) would not give you O(2N log N), it would give you      O( (log N+1) * N).  This algorithm would be bounded by O(N log N), as this grows faster than O(N) as N approaches infinity.
",0,38172087
38161263,"
In expressions an array designator is implicitly converted to the pointer to its first element. Adding an integer to a pointer you will get again a pointer. It is so called the pointer arithmetic.
Thus for example if you have an array
then expression 
will point to the sixth element of the array.
Here is a demonstrative program
Its output might look like
Also a function parameter declared like an array is also adjusted to pointer. So for example these function declarations
are equivalent and declare the same one function.
",0,38161209
38156556,"
First and foremost, the basics:
Here you define data as dynamic array of size numFaces, each element of it is an array of static size 24, which means data[0] is an array of size 24, data[1] is an array of size 24 and so on.
So sorting data using std::sort means sorting the elements — data[0], data[1], data[2], ..., data[numFaces-1] —  which are statically-sized arrays themselves.


Since I've specified in the lambda declaration that the parameters should be      references I can't see why the compiler is producing this error message.


The error is because arrays are not assignable in C++ (and C as well), as the error message says it clearly. In order to sort the elements, the std::sort needs to rearrange the elements, and that is done by assignment only — there is no other approach used by the library. It uses iterators and somewhere does this:
which is basically equivalent to this,
Since data[i1] is an array (of static size 24), the above assignment is invalid. You'll get the same error if you do this:
Hope that helps.
",5,38156525
38146132,"
Notice that you can split the array into two parts before sorting the array, and then sort each array alone.
Example: 
Split into:  
then sort each array alone, result:  
",1,38145968
38146755,"
If I am understanding you correctly, you wish to filter a list of tuples based on the second element, and then you wish to sort a list of tuples based on the first element. I'm not detecting any vital impact on the order of operations, so you should filter first.
Representing the problem as two distinct sets of elements is probably not the way to go (this of course assumes that you are not required to use two separate lists due to some outside constraint). 
In keeping with the above, you should use one list, but it should be of pairs (std::pair). Any mutations based in X will drag Y along for the ride implicitly. 
As far as removing pairs whose right element == 0. That should be fairly linear. Even if you did it first, the resultant impact on your overall run-time (a single run through an array of pairs, will not be noticed when the sort is where the real heavy lifting happens anyway) will not be noticed.
Sorting pairs is fairly easy:
Sorting a std::vector<std::pair<std::string,bool>> by the string?
Choice of data representation is important. You may want to use an std::vector but since you may be removing a lot of things your performance may suffer. For a large range of datasets this could trigger massive reshuffles. In these cases, it may be better to use std::list. 
",0,38145968
38147634,"
You're performing operations that indicate that your container type is wrong.

You're sorting the ""second array"" based on the values of the ""first array"", maintaining the arrays as sorted would be preferable
You're splitting the arrays based on the values of ""second array"" it would be nice if there was a link between them

multimap already accomplishes 1 so you'll never need to sort your keys (""first array"".) Given multimap<int, int> arrays 2 can be done like this:
Live Example
",0,38145968
38136725,"
If you change your variable name from firstYear to latestDate you might find it clearer. firstYear makes you think you only have a year to work with, but you have the entire WeatherData structure to work with instead.
You don't need a third inner loop (your k loop in your current code) - you can compare the year, month, and day for each item as you check it.
So you can do
Ideally you would encapsulate this in a member function of WeatherData or even as a standalone compare function which takes two WeatherDataobjects, but you can leave it in the sort method if that is what is required by the task.
",0,38136329
38112047,"
Your manually written class copies the vector:
The lambda expression merely references it:
If you took sortBySelf by copy (without the &) then they would likely have similar performance.
",2,38111673
38103411,"
Your while condition seems wrong.  You are looping as long as one of the two containers are not empty and then subsequently calling the front() member function on them.  You should probably be looping till both of them have elements in them, i.e. use && on line 21 instead of ||.  
So this line 
I am not sure if that breaks logical correctness of your code but that was the cause of the segfault (it was coming from line 25)
",3,38103251
38103462,"
The segfault happens on the line: if (buffer1.front() < buffer2.front())
A queue is typically just implemented as a wrapper around a deque or list you can find a more descriptive caution against calling front in their methods that you can in queue's method:

Calling front on an empty container is undefined[1][2]

If you're running under Debug in Visual Studio, when you get a segfault it will pop up this dialog, and you can hit ""Retry"" to debug with all state preserved:

You're problem is on this line though:
That means the while-loop is executed if either buffer1 or buffer2 is non-empty. You need to change that condition to:
",1,38103251
38090484,"
Something along these lines perhaps:
",4,38090429
38090468,"
For each pair in the original map, reverse the pair and insert into the other map. The sorting is automatic because std::map is sorted by key.
Also, if you might have multiple keys in the original map with the same data (for example both ""A"" and ""E"" have the data 5) then you need to be using std::multimap instead.
",1,38090429
38090594,"
For std:map, it is order by key default.
Please read the link:http://www.cplusplus.com/reference/map/map/
Here is the code exmaple:
the output is:
So you don't sort it by yourself.
",1,38090429
38061072,"
Separate into k sublists of n/k elements each.
Check impossibility condition.
Impossibility condition
Let k = 2 ,
3 4 1 2  is the array
For n/k lists maintain array to see if a number is present in O(1).
For eg. at spaced interval of 2
We can divide into two sublists , 3 1 and 4 2
Now we know sorted is 
1 2 3 4 (Use counting sort as heights between 1 and n O(n))
So , we expect 1 at first place. Now ask , can 1 come here? If only it is in sublist.[Y]
If [N] say ""impossible""
If impossible we are done else continue.
k times Merge sort, k * n/k(log(n/k))
(The number of inversions is equal to the minimum number of adjacent swaps to sort an array [known property]
refer:
Sorting a sequence by swapping adjacent elements using minimum swaps
)
complexity of approach is n log n , which will easily pass :)
",3,38059158
38055467,"
Here are the issues I found:

In your posted code, this does not compile:
I added a close parenthesis there.
It's not necessary to take the address of the array in these cudaMemcpy statements:
the array name is already the address of the array, so I removed the ampersands.  If you use a dynamically allocated array, such usage would be broken.
Your usage of __syncthreads() here is broken:
usage of __syncthreads() inside a conditional statement is generally incorrect unless the conditional statement evaluates uniformly across the threadblock.  This is covered in the documentation.  We can achieve the desired effect with a slight change:


With the above changes, your code appears to run correctly for me, for most cases.  Your usage of FLT_MIN in your validity check is also questionable, if you intend 0 (or any negative values) to be sorted correctly.  Speaking generally, FLT_MIN is a number that is very small, close to zero.  If you were thinking that this is a large negative number, it is not.  As a result, zero is a possible output of your random number generator, and it will not be sorted correctly.  I'll leave this one to you to fix, it should be straightforward, but it will depend on what you ultimately want to achieve.  (If you only want to sort positive non-zero floating point values, the test may be OK, but in this case your random number generator can return 0.)
",3,38048753
37970236,"
First of all string literals in C++ have types of constant character arrays. So the correct array declaration will look like
Thus the string literals pointed to by the elements of the array are immutable.
You should declare at least a two dimensional array. 
Here is a demonstrative program
Its output is
If your compiler does not support the range based for statement then you can write instead
",6,37969857
37934374,"
It's a simple case of problem with the operator precedence. The member selection dot . has higher precedence than the dereference operator, so e.g. *(a.second).valA is parsed as *((a.second).valA).
Simply change to e.g. a.second->valA (or (*a.second).valA).
",4,37934330
37934372,"
a.second and b.second appears to be iterators, so this should simply be:
",1,37934330
37932586,"
Lambdas:  
See What is a lambda expression in C++11? for a detailled introduction.
",0,37932537
37932766,"
Pre-C++11 solution: use an object instance as a custom comparator
C++11+ solution: use a lambda
My advice: go for a lambda if you're allowed to use C++11 features. It's probably more elegant and readable.
",0,37932537
37919686,"
You modify both arr[i] and j, therefore the loop will end too fast when both are part of the comparison.
",1,37919418
37839862,"
One problem is that you are computing the cost based on pos[n[a]].  
pos[n[a]] returns the position in the original array, but the cost should be based on the position in the current array P (i.e. with some elements moved to Q).
For example, if P is originally {4,1,2} then the position of the 2 is x==3, but after P is reduced to {1,2}, then the position of the 2 is x==2.
",0,37838792
37828932,"
I presume you're talking about sorting the vector within the map, not the map itself as your question states.
You can use std::sort, with an appropriate lambda to define the comparison:
",1,37828878
37805475,"
",0,37804312
37805104,"
Try this code with c++11 compiler support(you need improve this):
",0,37804312
37776393,"
MyDataSortPredicate is not a concrete object or function. It is a function template. As such, it cannot be passed as an argument to a function. You need to instantiate it with a template argument.
",2,37776312
37776442,"
If you do not want to explicitely provide type for comparator, you can make a polymorfic function object like std::less<void>:
",2,37776312
37767922,"
To call compare you need a Field object. You could use a lambda a call it from in there if you have C++11 support:
Or just move your comparison method out of the class, you don't need to access it's members anyway.
",1,37767847
37768095,"
Thank you for the comment πάντα ῥεῖ.
Your hint works very well, I ended up using a class Compare and called an operator.
",0,37767847
37754516,"
Use an array of structures.  The structure would contain the original value and a container of divisors:  
You can then write a custom comparator function and pass to std::sort:  
The sorting then becomes:
The generation of divisors is left as an exercise for the OP.  
",0,37754181
37754525,"
Reworking your code with std::sort:
Demo
",0,37754181
37750967,"
You can use std::partial_sort for this, sorting small chunks of vector each iteration. After all chunks done you can use inplace_merge to merge sorted chunks pair-by-pair together and get finally sorted vector.
",1,37750877
37750983,"
What do you mean by frames? You could split your data parellize a merge sort using  std::inplace_merge.
",0,37750877
37732329,"
What you're looking for is called tag sorting (or index sorting). Here is a minimal example using lambdas in C++11:
Live on Coliru
",10,37732275
37725353,"
Here you go:
",1,37721593
37718294,"
You need to make a compare function which compares 2 strings and use that as the last argument in qsort.
read more about the function here 
http://www.cplusplus.com/reference/cstdlib/qsort/?kw=qsort
",1,37718007
37714082,"
If you want something that is just like if (array[index] < minValue) then you should probably pass minValue to your counters function.
",1,37713952
37714199,"
This line of code compares subsequent elements and finds the lesser.  So the inner loop finds the last item that was less than the preceding item, and does not find the minimum in the range.  Instead of comparing against the previous, compare against the minimum:
(As a note, arr[index + 1] also reads past the end of the array, so you got lucky it didn't crash)
",2,37713952
37714221,"
Your selection sort is incorrect.
First, ""isEqual"" is not equal. 
Second, you should be finding the smallest value in the (unsorted) remainder of the array. Instead, you are comparing every adjacent pair.
Update minValue and minIndex as needed.
Hope this helps.
",1,37713952
37712194,"
Try doing this:
And you'll find which one gets compiled, and would find that these expressions are not equal. 
First statement would compile since the type of v[0] is sort_map, hence &a applied on it would make it
sort_map*
Second statement's base type is vector<sort_map>::iterator, and its address would be 
iterator* 
for this vector type. As you can see iterator* cannot be assigned to sort_map* - they are not similar.
qsort takes void* without enforcing any type-safety from the compiler. A void* can be passed any type of pointer without any typecast needed, hence it compiles well. You are passing a wrong thing to qsort. As others recommended, you better use std::sort
",-2,37711636
37691871,"
You can solve this recursively in O(k log k) if you partition in the middle of your range, and randomly sample from the hypergeometric probability distribution to choose how many values lie above and below the middle point (i.e. the values of k for each subsequence), then recurse for each:
Sampling from the binomial distribution could also be used to approximate the hypergeometric distribution with p = (n >> 1) / n, rejecting samples where k1 > (n >> 1).
",3,37690539
37691247,"
If in practice k has the same order of magnitude as n, perhaps very straightforward O(n) algorithm will suffice:
It produces all ascending sequences with equal probability.
",5,37690539
37690728,"
As mentioned in my comment, use a std::set<int> to store the randomly generated integers such that the resulting container is inherently sorted and contains no duplicates. Example code snippet:
",2,37690539
37691144,"
You can do it in O(k) time with Floyd's algorithm (not Floyd-Warshall, that's a shortest path thing). The only data structure you need is a 1-bit table that will tell you whether or not a number has already been selected. Searching a hash table can be O(1), so this will not be a burden, and can be kept in memory even for very large n (if n is truly huge, you'll have to use a b-tree or bloom filter or something). 
To select k items from among n:
That's it. At the end, your hash table will contain a uniformly selected sample of k items from among n. Read them out in order (you may have to pick a type of hash table that allows that).
",0,37690539
37690886,"
Could you adjust each ascending index selection in a way that compensates for the probability distortion you are describing?
IANAS, but my guess would be that if you pick a random number r between 0 and 1 (that you'll scale to the full remaining index range after the adjustment), you might be able to adjust it by calculating r^(x) (keeping the range in 0..1, but increasing the probability of smaller numbers), with x selected by solving the equation for the probability of the first entry?
",0,37690539
37691348,"
Here's an O(k log k + √n)-time algorithm that uses O(√n) words of space. This can be generalized to an O(k + n^(1/c))-time, O(n^(1/c))-space algorithm for any integer constant c.
For intuition, imagine a simple algorithm that uses (e.g.) Floyd's sampling algorithm to generate k of n elements and then radix sorts them in base √n. Instead of remembering what the actual samples are, we'll do a first pass where we run a variant of Floyd's where we remember only the number of samples in each bucket. The second pass is, for each bucket in order, to randomly resample the appropriate number of elements from the bucket range. There's a short proof involving conditional probability that this gives a uniform distribution.
",0,37690539
37690892,"
Assuming that you can't store k random numbers in memory, you'll have to generate the numbers in strict random order. One way to do it would be to generate a number between 0 and n/k. Call that number x. The next number you have to generate is between x+1 and (n-x)/(k-1). Continue in that fashion until you've selected k numbers.
Basically, you're dividing the remaining range by the number of values left to generate, and then generating a number in the first section of that range.
An example. You want to generate 3 numbers between 0 and 99, inclusive. So you first generate a number between 0 and 33. Say you pick 10.
So now you need a number between 11 and 99. The remaining range consists of 89 values, and you have two values left to pick. So, 89/2 = 44. You need a number between 11 and 54. Say you pick 36.
Your remaining range is from 37 to 99, and you have one number left to choose. So pick a number at random between 37 and 99.
This won't give you a normal distribution, as once you choose a number it's impossible to get a number less than that in a subsequent choice. But it might be good enough for your purposes.
This pseudocode shows the basic idea.
Note that this takes O(k) time and requires O(1) extra space.
",0,37690539
37647138,"
You're already using
to allocate an array of a size known only at runtime. If you understand that, you can use the same approach to allocate an int * count which will work the same way. You need to initialize it to 0 yourself, and delete [] the resulting array when finished.

You could instead use a std::vector as Patrick Roberts suggested in the comment, this is the more appropriate way to do it in C++, and it has the benefit of deallocating itself when it goes out of scope:

int count[radix] is a Variable Length Array, which is present in newer versions of C but not C++ (see Why aren't variable-length arrays part of the C++ standard?).
",0,37646161
37606052,"
In merge(), the code doesn't check to see if the end of a vector has been reached, specifically, if i >= firstList.size() or n >= secondList.size(), in which case the remainder of the other vector would be copied. The while statement should not have the -1 near the end.
VS complains about the temp vector creation using &playlist[playlist.size()], since the subscript is out of range. An optional way to do this is to use begin() + index, which is an iterator:
It's been over a day, so posting a fixed version in case anyone is interested. All that vector creation and push backs add a lot of overhead, it would have been better to do a one time allocation, and then just use iterators or indices to deal with the sub-vectors.
",0,37602265
37604173,"
I didn't see with a lot of attention, but maybe you want
the &playlist[playlist.size()] without -1 I think is the source of your problem,
but I have not tried.
",0,37602265
37595580,"
You are using Lomuto partition approach. Right way to do it:
The second issue - main call should be:
",0,37595151
37595316,"
you have to go from left until you find some bigger number than your pivot and than from right to left until you find a lower number... (this two loops make the quicksort extremely fast...) look at this code...
https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Quicksort
you need this both lines:
so here is your problem:
",0,37595151
39581829,"
In your merge function you shouldn't initialize k to 0 because it will write the result of merge in the wrong place. Instead you should initialize k to lower. Because that is the start index of the part you are actually sorting.
",2,39581639
39622626,"
Why do you need to sort it in-place? Your had disc should have no problem to store another 17 GB file.
I would sort it this way.

read the file in chunks you can handle in RAM. Use any sorting algorithm you want on that chunk (e.g. quicksort, heap sort, ..)
write the sorted chunk to the had disc (in a separate file for each chunk)
goto 1 until you reached the end of your data
merge the sorted files of the chunks and write the overall sorted result as a final sorted file.
delete the sorted-chunk-files.

",0,39568403
39568812,"
Since the first few elements of the array are accessed the most I decided to load the first elements into RAM until I reach the limit (which is passed a parameter). The achieve that I modified my code like that:
",0,39568403
39541851,"
First of all, use std::sort instead of your manual sorting code. The reason that qsort() crashed is because it's a C library function that knows nothing about C++ classes. std::sort() will be able to correctly sort your array.
Setting that aside, there are multiple bugs in the code that gets executed after the sort. The current code does the following:
The problem here is that currentPtr was already used, before the sort, to walk through the list, and at this point it is NULL. If you simply tried discussing your code with your rubber duck, your rubber duck would've told you that.
So the very first iteration here results in a null pointer dereference, and a crash.
You simply need to:

Reset currentPtr back to listPtr.
You can get rid of the special-casing for the last element of the list. It accomplishes absolutely nothing useful. Besides, it's wrong:


Since a has N elements, the last element is a[N-1], and this will run off the end of the array, resulting in undefined behavior.
Like I said, you can remove this completely, and simply iterate over the entire range:
Finally, you appear to be using gcc's variable length array extension, which is non-portable. Instead of declaring
You should simply use a vector:
... and then push_back() each value, in the loop that follows.
If you don't want to use std::vector, you can temporarily new the array, and then delete it afterwards.
",1,39541807
39542141,"
Based on your question and logic example, I feel like this is what you're trying to do:

You desire to sort the entire matrix/2d vector such that reading from left to right and top to bottom the martix/2d vector will read in ascending/descending order.

In this case, you could treat the entire matrix/2d vector as though its a set of N elements for sorting, but you will have to ensure that you properly place/replace your data in a 2d format.
An example of this would be:
[3, 5, 1] 
[1, 3, 1] 
[12, 4, 1]
This could be handled as standard array/vector if you represent it as: [3, 5, 1, 1, 3, 1, 12, 4, 1]
By treating it as a standard array/vector, you could perform a normal sorting function on the set.
Then to convert it back into a matrix/2d format you'd be able to iterate through the set and each time you've read the number of elements that make up the size of a row N, you'd move to a new row.
",0,39541712
39462443,"
Your code has three issues:

You never print the number of matches num.
Instead of return hand[i]; you should either print hand[i] or store in an output container. You should print the contents of the mentioned container (if you use it) in the main()
In any case cout << printPairs(hand) << endl; should be changed appropriately to the decision taken in p.2

",0,39462372
39462498,"
With a bit of STL help...
You better sort the numbers first and then use adjacent find to look adjacent numbers that are equal. Complexity O(n log n + n) = O(n log n)
",0,39462372
39462510,"
I think with below code you can start.
In your code you are always comparing hand[0] with hand[0] and so on. 
You are doing num++ but not using it any where.
In my below code I am using exception but, if you know your input sequence then you can return -1 or 0 instead of throwing exception.
",0,39462372
39462716,"
Similar To Your Code I Made Some Modifications
Ideone Solution For Your Problem
But In My Case I will be returning the number of duplicates and updating it in a array.
",0,39462372
39462952,"
Since the Question is tagged as C++, so use the facilities already available in c++ STL for solving the problems. This problem can be solved using std:map. 
std::map is a Key-Value data structure. So you can make:
Runnable Code:
http://ideone.com/CPNCUu
",0,39462372
39463060,"
If you don't mind the order in which they are printed, then you can use a map:
",0,39462372
39453796,"
The problem here is subtle and not easily noticed by new developers.  You're passing your argument to mergsrt by value, which means a copy is made.  The sorting is done on this copy, and the original deque is not changed.  You need to pass by reference (mergsrt(deque<int> &)) instead.
",4,39453689
39433754,"
Your comparison function is not a valid. It fails both at irreflexivity (comp(x, x) should never be true) and asymmetry (if comp(x, y) is true, then comp(y, x) must be false), both of which are part of the strict weak ordering which std::sort requires for its comparator. operator< or operator> satisfy this requirement. But operator<= and operator>= do not.
If you change your comparison function to this:
It will work. Of course, that is functionally identical to what you get as the default, so you could just do this:
",6,39433709
39415530,"
You can use std::sort() with your own comparison function.
Bye the way, I think you do not need Case insensitive for all datatypes.
For your comment in question: you can always ignore the 3rd parameter if you want default comparison.
Example:
",2,39415431
39402335,"
Basically, when a EXC_BAD_ACCESS exception is thrown it means that you are sending a message to an object that has already been released. Your code in a C++ compiler creates a segmentation fault. It is explained in more detail here:

When you send a message to an object, the pointer that points to the object you're sending the message to needs to be dereferenced. This means that you take the memory address the pointer is pointing to and access the value of that block of memory.
When that block of memory is no longer mapped for your application or, put differently, that block of memory isn't used for what you think it's used, it's no longer possible to access that chunk of memory. When this happens, the kernel sends an exception (EXC), indicating that your application cannot access that block of memory (BAD ACCESS).

When you are writing this in the first loop:
you are assigning a value to a memory block that doesn't exist and you get the exception. Here you can understand further.
The following code works for me. I will leave up to you to optimize it if you need better performance and remove the first loop where I assign the integers to Arrptr. I have left it there for clarity.
Hope this will help you:
",1,39400852
39401130,"
",-2,39400852
39399008,"
The best way would be to use std::sort from <algorithm> as such:
where v is the vector and std::tolower can be found in <cctype>. If you don't have access to C++11 lambdas, it can easily be replaced.
",5,39398959
39399026,"
You can use std::sort with your own custom comparator, which uses std::tolower on each letter to do a case-insensitive comparison
Live demo
",2,39398959
39399229,"
While everyone else has suggested std::sort in their answer, I will suggest a solution with your algorithm, like this. (You will need std::tolower or std::toupper):
",1,39398959
39393312,"
You can cast pointer to the first row of a two-dimensional array to pointer to int and sort the array as a one-dimensional array.
Here you are
The program output might look like
Another approach is to write the function bubble_sort as a template function. In this case it could look the following way as it is shown in the demonstrative program below.
",1,39393035
39371102,"
If you wish to sort according to the .second element of the pair, then why not placing the double in front of the pair<int,int>? Sorting orders pairs by their first element then their second element, thus instead of
You could use
Also I suggest not using keywords as variable names (map is an in-built data structure in C++)
",2,39370916
39371220,"
Thanks Benson!  I just realize that I have to construct a  struct that compares
Thanks for the advise!
",0,39370916
39359141,"
You have an infinite loop in your quicksort function. As this function never returns, nothing after the ""The random numbers are:"" line is printed, as the quicksort call never returns. The random numbers themselves may or may not print (and do print on my system) as the system is not guaranteed to flush the output buffer to the screen immediately. (They probably would be printed if you wrote a std::endl to cout after the for loop that prints the numbers.)
I suspect this is the problem:
That statement while (arr[l] > pivot) should probably actually be while (arr[r] > pivot).
",4,39358997
39359077,"
This happens because something goes wrong inside quicksort() and you print the numbers without an std::endl!
You see, without the std::endl, the numbers are written in the output buffer, but they are not flushed. They will, eventually, without the std::endl, but that your code doesn't make it to that time.
Pro tip: Always use std::endl when you debug your code!

I won't debug your quicksort(), since you should do that, in order to practice! If you need a reference, you can always use my baby example: Quicksort (C++), which is written in a c-like way, so that people from both c and c++ can easily follow! :)

Hunch: You use recursion, your program doesn't terminate...Infinite loop may be the cause... ;)

BTW, if I were you and didn't have any important reason to use:
I would discard that (along with the accompanied #endif).
",1,39358997
39315991,"
Apparently the problem is not in the comparison but in what you are passing to std::sort. What is the declaration for
?
If that for example returns a const Point * then you have a const correctness problem because std::sort needs to be able to write to rearrange elements.
",1,39315662
39305282,"
you're accessing wrong data area here when it is in the last iteration: (it + 1)==matrix.end() in that case => undefined behaviour.
",0,39305230
39267395,"
It is a bubblesort implementation.  It just is a very basic one.
Two improvements:

the outerloop iteration may be one shorter each time since you're guaranteed that the last element of the previous iteration will be the largest.
when no swap is done during an iteration, you're finished. (which is part of the definition of bubblesort in wikipedia)

Some comments:

use better variable names (test2?)
use the size of the container or the range, don't hardcode 5.
using std::swap() to swap variables leads to simpler code.

Here is a more generic example using (random access) iterators with my suggested improvements and comments and here with the improvement proposed by Yves Daoust (iterate up to last swap) with debug-prints
",4,39266885
39268971,"
The correctness of your algorithm can be explained as follows.
In the first pass (inner loop), the comparison T[i] > T[i+1] with a possible swap makes sure that the largest of T[i], T[i+1] is on the right. Repeating for all pairs from left to right makes sure that in the end T[N-1] holds the largest element. (The fact that the array is only modified by swaps ensures that no element is lost or duplicated.)
In the second pass, by the same reasoning, the largest of the N-1 first elements goes to T[N-2], and it stays there because T[N-1] is larger.
More generally, in the Kth pass, the largest of the N-K+1 first element goes to T[N-K], stays there, and the next elements are left unchanged (because they are already increasing).
Thus, after N passes, all elements are in place.

This hints a simple optimization: all elements following the last swap in a pass are in place (otherwise the swap wouldn't be the last). So you can record the position of the last swap and perform the next pass up to that location only.
Though this change doesn't seem to improve a lot, it can reduce the number of passes. Indeed by this procedure, the number of passes equals the largest displacement, i.e. the number of steps an element has to take to get to its proper place (elements too much on the right only move one position at a time).
In some configurations, this number can be small. For instance, sorting an already sorted array takes a single pass, and sorting an array with all elements swapped in pairs takes two. This is an improvement from O(N²) to O(N) !
",2,39266885
39267338,"
Yes. Your code works just like Bubble Sort. 
Input: 3 5 1 8 2
Output after each iteration: 
Actually, in the inner loop, we don't need to go till the end of the array from the second iteration onwards because the heaviest element of the previous iteration is already at the last. But that doesn't better the time complexity much. So, you are good to go..
Small Informal Proof:
The idea behind your sorting algorithm is that you go though the array of values (left to right). Let's call it a pass. During the pass pairs of values are checked and swapped to be in correct order (higher right).
During first pass the maximum value will be reached. When reached, the max will be higher then value next to it, so they will be swapped. This means that max will become part of next pair in the pass. This repeats until pass is completed and max moves to the right end of the array.
During second pass the same is true for the second highest value in the array. Only difference is it will not be swapped with the max at the end. Now two most right values are correctly set.
In every next pass one value will be sorted out to the right.
There are N values and N passes. This means that after N passes all N values will be sorted like:
{kth largest, (k-1)th largest,...... 2nd largest, largest}
",0,39266885
39267936,"
No it isn't. It is worse. There is no point whatsoever in the variable cntr1. You should be using test1 here, and you should be referring to one of the many canonical implementations of bubblesort rather than trying to make it up for yourself.
",-1,39266885
39255334,"
Here it's done with std::sort from the header algorithm
output:
",1,39255148
39255191,"
It just so happens to be that a string containing only digits is alphabetically sortable, so you just put each string into a vector, and simply sort the vector.
As noted, this only works if the ""numbers"" all have the same number of digits. Else you need pad the strings with leading zeroes so they are all of the same length. The leading zeroes can then be removed once you have sorted the vector.
",1,39255148
39222038,"
Assuming there's only one Graphic object with a given position():
Build an unordered_map : int → Graphics*, that you call e.g. gp, so that gp[i]->position() = i.
Building the map is linear time, using it for each index is constant time, roughly.
If there can be more than one Graphics object with a given position, build an unordered_map : int → vector<Graphic*>, then with usage code like
Or, for the last case you might use an unordered_multimap.
",13,39220854
39221024,"
You already know how many elements you want to process, so you can use a vector that keeps pointers to your Graphic instances, already allocated with the appropriate number of elements:
Then you can fill this vector with the elements, sorted using order:
",3,39220854
39221044,"
Instead of nesting these you could create a temporary vector and do this step by step.
The sort assumes, that the order vector entries and the ones which are selectedGraphics match. I am not sure if there will be any strange side effects if an selected graphic object has a position which is not in the order vector. 
",3,39220854
39191407,"
Assigning to a vector doesn't allocate memory.
Usually we use push_back to add items with auto-memory 
allocation. Code like that you usually write like so:
etc..
But nowadays with C++11 this style of coding is old.
It's possible to do it like that (see also the loop):
Actually, C++11 puts some convenient syntax into the constructors:
",3,39191320
39191678,"
Unlike map::operator[], vector::operator[] never auto-inserts a new element into the container. It is undefined behavior to access non-existing elements (in debug mode the runtime may throw an assertion to aid debugging).
In C++11 the most efficient ways to populate a vector are:
Via an initializer-list:
Or create entries in-place:
",0,39191320
39187213,"
You don't need the adjustment. atan2 will give you the angle from positive direction of x axis, counterclockwise in range of -PI to PI.
Firstly, to make the starting point positive direction of y axis, let me give parameter to atan2 as if negative direction of y axis is positive direction of x axis and positive direction of x axis is positive direction is y axis.
Then, this will make the angle counterclockwise, so negate the angle in order to reverse the order.
",4,39187184
39187470,"
This is an example c++ implementation of the algorithm mentioned in this link:
The findPermutation function accepts the length of the original string and the index of the required permutation, and returns an array that represents that permutation. For example, [0, 1, 2, 3, 4] is the first permutation of any string with length 5, and [4, 3, 2, 1, 0] is the last (120th) permutation.
",0,39186661
39186796,"
I have had a similar problem where I was storing lots of row in a Gtk TreeView and did not want to go over all of them every time I want to access a row by its position and not by its reference.
So, I created a map of the positions of the row so I could easily identify them by the parameter I needed.
So, my suggestion to this is you go over all permutations once and map every std::permutation in an array (I used a std::vector), so you can access it by myVector[permutation_id].
Here is my way I have done the mapping:
So in your case you would just iterate over the permutations like this and you can map them in a way that allows you accesing them by their id.
I hope this helps you :D
regards, tagelicht
",0,39186661
39075669,"
Using the standard approach (of merging the sorted arrays and then sorting) will give you O(NMLog(NM)).If you want an efficient approach then you should use min Heap data structure.You might want to read about heap data structure.

Create an output array of size N*M.This will hold the output sorted array.
Create a min heap of size N.Insert first element of every sorted array.
Remove the top element(minimum) from heap and put it in the output array.Replace this removed element with the next element from the same array of which this removed element was part.Repeat this until all elements are accounted for.

Complexity will be O(NMLog(N)).
",1,39075086
39075314,"
Since all the elements in a[M][N] reside in sequential memory, you can treat that memory as flat. So you sort in place like this:
and sort c, given that the size of the array is M*N.
Or you can copy it to b, by defining b like this:
and now sort b.
",0,39075086
39075904,"
Think of a merge sort, but applied to N arrays instead of 2. For each row you could keep an index of currently considered element. Now we need something to compare all the N values (instead of just 2). What you could do is use a heap (priority_queue) with an element structure like this:
The algorithm would be as follows:

You add all the values from the column 0 to the priority
queue
Declare an array which will keep your currently considered index for each row. Initialize it to zeros.
In a loop (until you run out of elements)


check the element on the top of the queue (element = queue.top())
add element.Value to the 1d array
increment currently considered index for element.Row
remove the element from the top of the priority queue (queue.pop())


The resulting 1d array is sorted and the complexity is O(MNlog(N)). This is because you considered M*N elements and for each element adding/removing it from the priority_queue took log(N) time, because at any given moment the heap keeps no more than N elements.
I think that treating the 2d array as 1d and sorting would result in MNlog(MN) complexity which is a bit worse.
",0,39075086
39076177,"
",0,39074907
39048339,"
I assume you are reading pieces of information about songs, and you want to sort them according to the song titles. Since you are reading the same kind of data for each song, use a single array of structures, not separate arrays.
For instance, this is how you would sort the songs by title.
",3,39048148
39049081,"
Totally untested c++11 code
",1,39048148
39047512,"
You can represent the data as a structure of some kind
To sort by ID only...
Three benefits:

If you later need other_data_2 to also stay ordered with id, it's trivial to add it
You can avoid using complicated multi-dimensional arrays
You can avoid using arrays (by using vectors)

",1,39047363
39009629,"
The problem is in countSort. The output and output1 arrays are local arrays, not dynamically allocated, and they're too big for local variables. You're also using the C feature of variable-length arrays, which aren't part of standard C++. Change them to:
and add
at the end of the function.
",2,39009557
39009206,"
First, you got the variable wrong. The argument is arr, not a.
a[i] = rand() makes no sense. a[i] is a whole row, you can't assign a number to it. To access an element of a 2-d array, use two subscripts.
",3,39009172
38987903,"
should really be:
",0,38987497
38980682,"
That depends on whether you're trying to find the minimum number of swaps, or actually trying to sort the array. 
If you're trying to sort the array, the minimum number of swaps will not help you sort it faster. Finding the best sorting algorithm will help you sort faster. Generally, that means finding one with an O(n log(n)) complexity (unless the array is small or memory is a major constraint). For help with this problem, Google is your friend.
If you're just trying to find the minimum number of swaps needed, without actually sorting it, you're looking at some modification of the selection sort. The way that one goes is find the lowest value, swap with the first index, find the second-lowest, swap with the second index, etc.
But as I said, finding the minimum amount of swaps does not optimize sorting. The selection sort may have fewer swaps than the quicksort, for example, but it takes longer for the selection sort to determine which indeces to swap. The time complexity of the selection sort is O(n^2). 
The difference between O(n^2) and O(n log(n)) is not as trivial as it looks, by the way. If the number is around 1,000,000, it could be the difference between 20,000,000 and 1,000,000,000,000.
",4,38980407
39028202,"
I can speak with some authority on this question as I'm the one who wrote this code.
Here is the comparison which is asserting in your example:
https://github.com/llvm-mirror/libcxx/blob/master/include/algorithm#L3994-L3995
As the link is likely to go stale (point to the wrong line) as time goes on, I'll also quote the code here:
This is known as an ""unguarded"" loop because there is no check for the iterator __i running off the end of the sequence as it is incremented.  The reason this works is because an invariant of this algorithm is that at this point it is known that __i <= __m (which is also in a comment 3 lines above this quote).
If you look at the code above this quote, you will see these comments:
So before we get to this point, a guarded search down the sequence is done.  That is, this test:
After this test finds the lower guard, the algorithm then jumps to the unguarded loops which have only one test per iteration, whereas otherwise there would be two tests per iteration (a test on the iterator and a test on the dereferenced value of the iterator).
The use of ""unguarded loops"" is the cause of an element being compared with itself.  During development I measured that the cost of the one extra comparison in the loop was a better deal than including two comparisons per iteration in the loop.
Of course this is an engineering tradeoff.  If the comparison function turned out to be horribly expensive compared to the cost of comparing the iterators themselves, one could come to a different conclusion.
This answer is completely consistent with rici's answer which is also correct (and I've upvoted it).  I added my voice as I could drop the ""presumably"" and point to specific lines of code in the algorithm.
",2,38966516
38966593,"
Presumably, in the opinion of the standard-library authors, it is faster to do a test which is guaranteed to return false than to constantly check for equal indices as well as comparing elements. This might come about because the pivot element is used as a loop sentinel.
It is certainly permitted for the comparison function to be called in this way, and the assert in your code is not permitted.
",2,38966516
38956100,"
You could try using Boost Multi-Index. One index provides map access, the other provides ordered iterator access.
",0,38955580
38955668,"
Solution using priority_queue  
",0,38955580
38939828,"
You are defining j in the initialization of the inner loop, which limits its scope to that loop. If you want to use it outside of the loop, you should define it outside of it. E.g.:
",1,38939793
38939918,"
A scope of a variable refers to the block of code which can access it. You cannot access that variable outside that block of code. So, when you define the integer j within that for loop, you can only access that code within that for loop. To access it outside the loop, you'll have to declare it outside the for loop.
One extra thing to note is that when there are multiple declarations of the same name, the compiler will resolve to the one closest to it. For ex:
Also, in your case, you probably want to swap with A[i] as in swap(A[min], A[i]). So, the code should be following:
",0,38939793
38917651,"
A small clarification for other answers: the std::vector<T> already has operator< with exactly the same behavior as you described (cplusplus description).


Description:

The less-than comparison (operator<) behaves as if using algorithm lexicographical_compare, which compares the elements sequentially using operator< in a reciprocal manner (i.e., checking both a < b and b < a) and stopping at the first occurrence.

So, you can just write
UP: It's written in the comments that you have an array of std::vector, not std::list<std::vector>. The array has no methods begin() and end(), so this exact code will not work. The solution is
where SIZE is size of the part of the array you want to sort.
",6,38917392
38917566,"
Answer based on this link:
You can create compare method like this:
and call: 
",0,38917392
38917568,"
Check out this post.
You have to implement your own comparator, which will be used later to sort your list of vectors.
",0,38917392
38917582,"
You can follow this algorithm:
",0,38917392
38917666,"
I hope this can sort your vector
",0,38917392
38917600,"
The STL function std::sort contains an optional predicate.
In this case, I guess you would like to write you sort like:
Note that this code will crash if the list contains empty vectors.
If sol ain't an std::list, though a c-style array std::vector<int> v[50001] like indicated in the comments. One should rewrite this to:
",0,38917392
38886581,"
In ascending_sort(),
You should use index instead of j, which might be list.size() after the for loop, then list[j] will cause out of range issue. Change it to

std::vector::operator[] doesn't perform bounds checking, it leads to undefined behaviour when subscript is out of range. It seems VS will throw exception in DEBUG mode, but this is not guaranteed by the standard. You could use std::vector::at instead, which will throw std::out_of_range when subscript is out of range.
",4,38886523
38843024,"
As @verbose says, you never really assign a value to currTitle, try using curr.getTitle(currTitle) at the start of the loop, or using curr->title in its place.
With regards to inserting in order, you needn't worry about head's previous value, only if the head itself is null, or the title comes before the head. You should iterate through the list, if the title comes after the current node, and the next node is null, you set curr to the next element (done in the for loop) and check again. If The next element is NULL, and the title comes after the current one, you have reached the end of the list, may insert the song, and break. 
If the song title comes before the current one, or is equal, you insert the new song before the current one and return. Example code below:
",1,38842602
38843067,"
You are comparing the two strings but the second doesn't appear to ever be initialized. Presumably aSong.getTitle(title) copies the title of the current song to the title[] array. But when is anything ever copied to currTitle[]?
So the elements of currTitle[] are garbage, and the comparison won't work. To fix this, compare the title of the song you want to insert to the titles of the songs already in the list. You probably want something like strcmp(title, curr->title). 
Of course you first need to check that a song actually exists before doing the comparison. Start by checking whether a song exists at head, and if not, insert the song as the head song. If there is already a song at the head, compare the two titles and determine whether the new song should be the new head, or whether it should go somewhere after the head. The rest of the logic should be straightforward.
",1,38842602
38817458,"
Due to the very limited domain of elements in your array, you can trivially solve this with (a simplified form of) counting sort. 

Create three counters, one each for red, green, and blue, initialized each for 0.
Count the occurrences of each of the three.
Overwrite the array - first with red to the number you found, then blue, then green.

",2,38817391
38817450,"
You have only three colors, so you'll have repetitions in your array. In this case it's easier to start with these than with the original positions. Just count how many reds, blues, greens are there, then write that many of each to the array.
",1,38817391
38817683,"
Following edit should make it work
",0,38817391
38748313,"

Why is doing less costing more?

Because you are doing more - copying all strings multiple times in the lamba taking time. As stated in documentation std::stable_sort:

O(N·log2(N)), where N = std::distance(first, last) applications of cmp.

So for every call of cmp you copy 4 strings. Change parameters type to const reference and remeasure.
",5,38747694
38748063,"
There is an operator< for std::pair, which will compare first the first value and then the second. Thus, if you use the default comparison function, it will do the exact same thing: compare the first value. After that it will most likely stop, since the key value is likely to be sufficient to apply a sorting order. 
The lambda does the same thing, of course, but the string_pairs are passed by value, and the additional copying is also taking some time. If you pass them by reference, presumably the speeds will be identical.
",0,38747694
38748106,"
Regarding the SWI-Prolog version, when using keysort/2, the sorting algorithm only compares the keys. But sort/2 must compare the keys and, for any two pairs where the keys are the same, it must also compare the values. It is also possible/likely (I have not looked into the implementations of these predicates) that keysort/2 goes for the keys in a direct way (given that the list members must be pairs using the (-)/2) infix operator) while sort/2 must be able to deal with arbitrary terms which, for compound terms, implies traversing the whole term in the worst case using generic code. For pairs (which are, of course, a compound term), it means comparing the (-)/2 functor, finding it to be the same, then descending into the arguments and comparing them. Thus, always twice the number of comparisons compared with keysort/2.
",0,38747694
38740415,"
You are setting initial valule of j in strQsrt function to 99. Then you are incrementing that value. Segmentation fault pops out when j =101, that is past the ary size. If you want to see for yourself modyfy your function to
",0,38739272
38740723,"
your
goes from 0 to 99 for 100 elements.
Changing the code to the following
avoids crashes during read of data.
",0,38739272
38735608,"
Your sort result is in charactor sequence, e.g. ""2"" < ""24"" < ""3"".
I believe your ""startBits"" is something like std::string, and your sortingSignals() is comparing string instead of the values.
So your sort is working, but in another way.
To really get your desired result, you may convert the string to int and compare the int values in sortingSignals()
",8,38735460
38727692,"
Not sure that this is your problem but... you define v1 inside a for loop.
So you, every iteration, create a vector, insert a single element, sort the vector (with a single element), print the single value and destroy the vector.
Suggestion: define v1 outside the for loop.
--- Edit ---
As pointed by aichao, the sort and the print part are presumably better outside the for loop; something like
If you can compile C++11 or C++14, the last for can be simply
p.s.: sorry for my bad English.
",4,38727196
38683409,"
You should use std::list as suggested. But assuming you need this for other reasons, you can modify the function to compare values and swap the nodes as follows:
Or simply use 
You may also consider std::vector which out performs std::list most of the time. 
",0,38679322
38622739,"
You need a custom comparator (functor, lambda, or overloaded operator <) satisfying strict weak ordering that you can feed into std::sort or std::set. The simplest one would be:
std::tie creates a std::tuple that implements the lexicographic comparison for you.
",0,38622297
38600816,"
I've finally resolved the problem!
The tricky part was in the way the original Intel code handled equal values of adjacent pairs inside the loaded 4-tuple — it didn't explicitly handle it!
The bugs were present in the very first stage and in the last passOfStage (i.e. passOfStage = 0) of every other stages. These parts of code are interchanging individual 2-tuples inside one 4-tuple (represented by the cl_int8 array theArray).
Let's consider this excerpt for example (it doesn't function properly for equal adjacent 2-tuples in the 4-tuple):
Imagine what would happen when we'd use this (unfixed) code and srcLeft.even = (int4)(7,7, 5,5). The operation srcLeft.even < srcRight.even would result yield (int4)(0,0,0,0), then we'd mask this result by imask0 and we'd get … pseudomask = (int4)(0,-1,-1,0) – i.e. the imask itself. This is, however, wrong.
The pseudomask's value is required to form this pattern: (int4)(a,a, b,b) (where a and b can be either 0 or -1). This means that it is sufficient do do the following comparison to form the correct mask: quasimask = srcLeft.s07 < srcRight.s07. Then the correct mask would be created as mask = quasimask.xxxxyyyy. The first 2 xes mask the first key-value pair in the first 2-tuple of the 4-tuple (4-tuple = one element in theArray). And since we want to bitmask corresponding 2-tuples (which are specified by imask0 as 0–-1 pairs), we add another xx. We bitmask analogously for the second 2-tuple in the 4-tuple, which leaves us with yyyy.
Visual example for bitshifting with imask11
The fixed, fully functioning version (I've commented the fixed parts):
",3,38571955
38561421,"
You could use something like the following:

Explanation
copies the integers from the file into a list using istream_iterators and the copy algorithm.
Then 
sorts the items using list's method.
",1,38559558
38561753,"
The algorithm you should to implement is called ""Insertion Sort"". Check out the wikipedia article: https://en.wikipedia.org/wiki/Insertion_sort for more detail.
What it basically does is, it puts the first element into the list and for each following element it walks through the list until it finds the place where it belongs.
What I would do in the first place is creating a list instead of using all these interger fields (this makes your code usable for lists with more or less than just 12 elements).
Next, create a new list, which holds the sorted list.
Your assignment says to iterate over all elements in the unsorted list. This obviously begs for a for-loop. Your code suggest that you might be unexperienced with that. Please check out control structures. These are absolutely essential. But let me help you out with that.
I haven't checked if the code compile or produces any runtime errors. But this is more about the concept. Hope this helps!
Best,
Thomas
",0,38559558
38540371,"
In addition to @stryku's answer since you only want to print frequencies, you don't even need to create the v vector:
",2,38539472
38539640,"
Here you go (:
I think your teacher will be surprised if you would explain it to him
",1,38539472
38517547,"
Is the fixed version of your code. I don't know he algorithm to know what to expect; however I did track down the issue with the list causing the crash. It had to do with all of the popping off. Plus the max iterator made no sense to me.
",0,38517359
38513781,"
your following function seems to be wrong:
You read lastName twice, you do not ignore the ',' character... try something like this:
UPDATE:
  If you consider spaces inside lastName, you should have to change the first line to use std::getline as follows:
Then:
...and...enough updates!
",1,38513628
38493670,"
You meant to write this as:
",4,38493652
40167587,"
In my experience, the best solution to your problem is something like:
Some explanations:

Sort set::const_iterator guarantees to be faster than sort Obj. Iterator is pointer based. 
Inserting to a vector and sort the vector guarantees to be faster than inserting into a set.
Reserve the vector size ahead of time to avoid dynamic memory reallocations.

",0,40167368
40160171,"
Well... The problem is that there might not be the right or wrong answer to this question. 
First of all, when you're comparing only 10000 elements, you cannot really call it an effeciency test. Try comparing much higher number of elements - maybe 500000 (although you will probably need to alocate an array dynamicaly for that).
Second of all, it might be the compiler. Compilers often try to optimize things so that the program execution will run smoother and faster.
",1,40159342
40140588,"
I think that if you sort it in smallest to largest (x is an integer after all)  that you should be able to use std::adjacent_find to find duplicates in the array, and process them properly.   For the performance issues, you might consider using reserve to preallocate space for your large vector, so that your push back operations don't have to reallocate memory as often.
",0,40140310
40139834,"
Often it's most convenient to embed the function into the class/struct:
Now they can be sorted like the basic types:
",3,40139450
40139584,"
You need to create a comparison function that you can pass to sort, that knows how to compare two different Rain objects.
",1,40139450
40103435,"
Shouldn't you be comparing contents of the address instead of the address?
Specifically,
and 
Also you should swap the contents and not the pointers.
It is unclear from the question what you want to achieve though. My answer has an underlying assumption that elements of the array you want to sort are stored contiguously.
",0,40103329
40103576,"
Conditions i < pivot and j >= pivot compare pointers while you should compare values pointed here.
",0,40103329
40102953,"
The compiler does all its work in one pass.  So when it sees the usage of ""partition"" before it's actually declared (or defined), it doesn't know how to interpret that symbol.  So it spews an error.
Simple solution is to just forward declare the partition function.  Add this line above the quickSort function.
What this basically says to the compiler is, ""hey, when you see partition token later in the compile, don't freak out, it's a function that takes two int pointer params.  It will be defined later and the linker will take care of resolving it."".
",3,40102903
40102955,"
Either declare function prototype above
or 
define partition() above quickSort()
",2,40102903
40123227,"
The main problem is that pivot must not be an int * but simply a plain int, as you are comparing array values, not array references.  you have to change your code in partition function, to show something like:
NOTE 1
you have to check first for the array position, before comparing, as you can lead comparing elements that are outside the range.  Be most careful when using && operator and double check the order in which you check the clauses (in boolean algebra this is not important, as the AND  operator is commutative, but not in C/C++, you have to first check for array boundaries, then the array element, or you'll run into trouble)
NOTE 2
You have to copy apart pivot, as it can be moved as the result of some comparation, and you'll finish using different pivots in each call to partition.  The best should be that you get the pivot (as the selection of pivot is something open in the algorithm) from a possible external function call and pass the value directly to partition (well, but this is  not related to the problem)
Of course, the problem of the missing forward declaration of partition() is another thing already described in other answers. C++ requires that everything used in the program is properly declared before its use.
",0,40102903
40078578,"
MergeSort function - assume low + 1 == high thus mid==low.
Recursive call with MergeSort(a, low, mid) will return immediately, while MergeSort(a, mid, high) will be passing again the same low and high - until your application will overflow the stack (and you'll post again a question on SO?)

merge function, assume low==3, mid==4, high==5.
You allocate a b[] of 3. So far so good.
But then you start with k=low (which is 3) and perform the assignment of b[k++] - already out of bounds even more at the next steps when you'll be writing at b[4] and b[5] (while b[0] and b[1] will stay untouched).
And so on (including  for (int i = low; i <= high; ++i) a[i]=b[i]; )
What you probably want to do is to perform all the assignment to temp storage with a - low offset (b[k-low] followed by k++ at the end of the while cycle).
",1,40078497
40078697,"
I found only a minor problem. Try this simple fix.
Your code was missing the brackets in the for statement.
This code works on my computer with this fix.
",0,40078497
40065670,"
I recommend looking through This Documentation.
It explains that the signature of the compare function must be equivalent to:
Being more precise it then goes on to explain that each parameter needs to be a type that is implicitly convertable from an object that is obtained by dereferencing an iterator to the sort function.
So if your iterator is std::vector<ClassType*>::iterator then your arguments need to be implicitly convertable to ClassType*.
If you are using something relatively small like an int or a pointer then I would accept them by value:
",2,40065593
40065638,"
In most situations this signature will also work, for comparators. The reason it is not used is because you have to realize that this is passing the objects by value, which requires the objects to be copied.
This will be a complete waste. The comparator function does not need to have its own copies of its parameters. All it needs are references to two objects it needs to compare, that's it. Additionally, a comparator function does not need to modify the objects it is comparing. It should not do that. Hence, explicitly using a const reference forces the compiler to issue a compilation error, if the comparator function is coded, in error, to modify the object.
And one situation where this will definitely not work is for classes that have deleted copy constructors. Instances of those classes cannot be copied, at all. You can still emplace them into the containers, but they cannot be copied. But they still can be compared.
",1,40065593
40065617,"
const is so you know not to change the values while you're comparing them.  Reference is because you don't want to make a copy of the value while you're trying to compare them -- they may not even be copyable.
It should look like your first example -- it's always a reference to the const type of the elements of the vector.
If you have vector, it's always:
So, if T is a pointer, then the signature for the comparison includes the comparison.
",0,40065593
40065893,"
There's nothing really special about the STL. I use it for two main reasons, as a slightly more convenient array (std::vector) and because a balanced binary search tree is a hassle to implement. STL has a standard signature for comparators, so all the algorithms are written to operate on the '<' operation (so they test for equality with if(!( a < b || b < a)) ). They could just as easily have chosen the '>' operation or the C qsort() convention, and you can write your own templated sort routines to do that if you want.  However it's easier to use C++ if everything uses the same conventions.
The comparators take const references because a comparator shouldn't modify what it is comparing, and because references are more efficient for objects than passing by value. If you just want to sort integers (rarely you need to sort just raw integers in a real program, though it's often done as an exercise) you can quite possibly write your own sort  that passes by value and is a tiny bit faster than the STL sort as a consequence.
",0,40065593
40059011,"
If you just want lexicographic ordering, std::tuple will help you out:
",4,40058962
40052910,"
I'd add an iterator
find out more about string::compare at http://www.cplusplus.com/reference/string/string/compare/
find out more about inserting into a list at http://www.cplusplus.com/reference/list/list/insert/
",1,40052747
40052829,"
Assuming you can use std::set or std::multiset:
This will add all the words and sort them automatically. The main difference between multiset and set is that the former allows duplicates, while the latter doesn't. 
You can then iterate over l with a for loop:
",0,40052747
40051783,"
Your proposed alternative is incomplete, you did not post the code for swap().  In C, swap must be a macro and such a macro is easy to botch, whereas in C++, it can be a function that takes both arguments by reference.
Furthermore, you should test j > 0 before dereferencing A[j - 1]. As posted, the code invokes undefined behavior.
Regarding your questions, both functions are equally slow with a time complexity of O(N2), but the second is potentially slower because swapping involves more reads and writes than simply shifting the values by one position, but it could be faster on a sorted array because the first version has redundant stores.
Note that you can further simplify the code at the price of efficiency this way:
",0,40051083
40055829,"
Time complexity for both the approaches is O(N^2) in worst case. But number of operations in the second approach is more as compared to the first because second approach performs the same number of swaps as the number of shifts in the first approach but swap require 3 assignments as compared to just one in in shift-based approach. Hence, method proposed by you will be slower as compared to just shifting the elements.  
}
Here is what I got when I called both functions on the same array of size 10000. Compilation and execution for 10000 elements array. If still not convinced, try to generate a random array of size 1000-10000 and run the above code to observe the difference. 
",1,40051083
40047331,"
Your immediate problem can be fixed by having a comparator that actually takes references to arrays instead of references to pointers:
But since you can't assign an array to another array, your code won't compile anyway.
You can avoid this by using std::array:
The added benefit is that operator< is automatically defined if array's value_type that defines it.
",4,40047011
40021675,"
Your program is running in O(n²) time, since you have two nested loops that both depend on the size of the input. So once you go from 10,000 to 1,000,000 elements, your program will take 100² = ten thousand times longer to complete. Furthermore, it can be that your dataset fit in the processor's cache before, but with 1 million elements it no longer does, so this will slow it down even more.
O(n²) algorithms make things go very slow very quickly. With an input size of 10⁶, it means your program will take in the order of 10¹² operations to complete. Assuming your processor runs at a few 10⁹ operations per second at most, and that your algorithm will surely use more than one operation per step, it will take more than 10³ seconds for your program to complete.
",8,40021474
40023302,"
Merge sort is O(n lg(n)) in the worst case, insertion sort is quadratic on average (not only in the worst case).
The difference is huge.
Suppose that you had two algoritms, A and B.
For any input of size n, A takes n2 operations, while B takes n*lg(n) operations.  
If you double the input, algorithm A takes (2n)2 = 4n2 operations - four times as many.  
B takes 2n * lg(2n) = 2n * (lg(n) + 1) = 2n * lg(n) + 2 = 2(n * lg(n) + 1), which is just a tiny bit more than twice as many.  
To illustrate the difference when you go from 10,000 to 1,000,000 elements (using ten-logarithms for simplicity): 
That's 10,000 times as much. 
That's 150 times as much.
So it's not unexpected that, if the ten thousand case takes approximately the same amount of time, insertion sort will take much longer than merge sort for the million case.
",0,40021474
40013192,"
What you want to do is basically find connected components in a graph. In your case you are starting with a set of edges (each pair is an edge).
There is for example the boost graph library, which has an implementation.
",0,40013056
40013191,"
It looks like finding the longest path in trees. What do you do with loops ? I would try with a tree or graph storage of your items.
",0,40013056
40013424,"
You are looking for Union Find or Disjoint Set Data Structure
An efficient implementation along with a great tutorial can be found here.
",0,40013056
39979141,"

Passing by reference is must as others have pointed out.
Keep pivot constant during a partition. pivot = v[pivot] ensures that. 
outer loop bounds changed to left<=right from left<right.

The running code.
",1,39978427
39971847,"
Don't reinvent the wheel. Just modify the default comparison function so aA < bB (regardless of case) and A < a.
EDIT I used the wrong comparison function. It should return true for <, and false for >=. This has been fixed
",3,39971585
39975382,"
First, get rid of the hard-coded ASCII-isms. C and C++ have long had functions for determining whether a character is a letter, a digit, uppercase, lowercase, etc. Look them up.
Second, describe clearly what goes into determining the order that you want the result to be in.
Third, from that description, write a function that takes two strings, and tells you whether the first string should come before the second. Use that function in the sort.
",1,39971585
39971705,"
You can sort a vector using std::sort and get a reference to the first character in a std::string using std::string::at() :
",0,39971585
39972066,"
I think it's really enough to skip exactly equal prefixes and then compare once with uppercasing:
If you need to compare by first letter only, simply remove while(*s1 && *s1 == *s2) {++s1; ++s2;}
",0,39971585
39942778,"
You should either use a debugger, or try to explain your algorithm to a rubber duck. However, I am in a rubber duck mood and will point you to a mistake:
In each iteration of this loop you want to go trough a range of elements, find the minimum value in that range and put it as the first element of that range. It works for the first iteration, but already on the second it goes wrong. You initialize maxx (which is supposed to be the first element in that range) to 0, ie the first element of the array. However you should only consider elements that have not yet been sorted, ie change it to
Also note, that (apart from exercises) you should not write your own sorting algorithm but use std::sort.
",1,39942717
39936792,"
Your algorithms seem fine. It is only a matter of complexity. If you count the number of times the while of the insertion sort algorithm is executed, on average, it is close to n(n-1)/2 where n is the size of your data set (see insertion sort).
If n=1.000.000, the complexity is close to 500.000.000.000 which is very long.
Just try to comment the call to insertionSort in main and your main function should end early.
Note that even if you do (too) multiple vector copies in your mergeSort algorithm, it will terminate early. Complexity is 'n * log(n)' (see merge sort).
",0,39936457
39932699,"
your merge function is declared as : 
and u are calling merge inside mergesort by. 
Ordering of arguments is wrong. See low and high variable ordering
",3,39932343
39934194,"
Replace the tab '\t' by a single space.
",0,39931169
39924242,"
As per my comment: 

I believe that if you initialize pass to 0, initialize i to (pass + 1), replace all V[i] with V[pass], and all V[i+1] with V[i], your code should work as expected 

You should also clean up your input to make it easier to tell which values are going where. Here's what I did, you can change it to say whatever you'd like, but you get the idea. 
OUTPUT
** Enter Quadratic Equations **

Set values for equation 0
a: 1
b: 2
c: 3

Set values for equation 1
a: 4
b: 5
c: 6

Set values for equation 2
a: 7
b: 8
c: 9

Set values for equation 3
a: 8
b: 7
c: 6

Set values for equation 4
a: 5
b: 4
c: 3

Set values for equation 5
a: 2
b: 1
c: 0

Set values for equation 6
a: 0
b: 0
c: 0

** NOT SORTED **
1x^2 + 2x + 3     root 1 = -1.00+i 1.41       root 2 = -1.00-i 1.41
4x^2 + 5x + 6     root 1 = 0.00+i 1.05       root 2 = 0.00-i 1.05
7x^2 + 8x + 9     root 1 = 0.00+i 0.98       root 2 = 0.00-i 0.98
8x^2 + 7x + 6     root 1 = 0.00+i 0.75       root 2 = 0.00-i 0.75
5x^2 + 4x + 3     root 1 = 0.00+i 0.66       root 2 = 0.00-i 0.66
2x^2 + 1x + 0     root 1 = 0.00       root 2 = -0.50

** SORTED BY A **
1x^2 + 2x + 3     root 1 = -1.00+i 1.41       root 2 = -1.00-i 1.41
2x^2 + 1x + 0     root 1 = 0.00       root 2 = -0.50
4x^2 + 5x + 6     root 1 = 0.00+i 1.05       root 2 = 0.00-i 1.05
5x^2 + 4x + 3     root 1 = 0.00+i 0.66       root 2 = 0.00-i 0.66
7x^2 + 8x + 9     root 1 = 0.00+i 0.98       root 2 = 0.00-i 0.98
8x^2 + 7x + 6     root 1 = 0.00+i 0.75       root 2 = 0.00-i 0.75
",0,39923337
39922373,"

For example, if the sorting happens on insertion and the internal container remains sorted, wouldn't the extraction be able to happen in constant time? 

Extract could happen in constant time, but insertion would become O(n). You'd have to search for the place in the list to insert the new element and then shift all the other elements. O(1) extraction and O(n) insertion might be good for some use-cases, but not the problem that priority_queue is trying to solve.
If sorting, on the other hand, happened on extraction, then you'd have O(n lg n) extraction and O(1) insertion. Which, again, is good for some use-cases, but that's not what priority_queue does.

Rather than sorting elements, std::priority_queue stores its elements† in a heap, which by construction has O(lg n) insertion and extraction. The structure is a tree, and insertion/extraction simply maintain the tree invariant. For some problems (like, say, search), in cases where we need to insert and extract many nodes, having O(lg n) for both operations is far superior than O(n)/O(1). 
As an example, and stealing images from Wikipedia, inserting the element 15 into the heap would initially place it at position x:

then swap it with the 8 (because the sorted invariant is broken):

then finally swap it with the 11:

In array form, the initial heap would be stored as:
and we would end up at:
Extraction is just the reverse operation - bubbling down instead of bubbling up. As you see, there's no explicit ""sorting"" going on. We're not even touching most of the elements most of the time. 

†std::priority_queue is a container adapter, but the container you provide should be a random access container with O(1) complexities for indexing, push_back, pop_back, front, back, etc. So the choice of container (unless you make a bad one) does not affect the overall complexity of priority_queue's operations. 
",4,39921320
39922149,"
The pop opration, remove the top element. There are several ways to implement a priority queue but in all of them, deleting the top is logarithmic. From wiki - Priority queue. 
",0,39921320
39910333,"
Here is the correct code.    
You were swapping array[i] with array[j] in line 32. array[j] and array[j+1] should be swapped. Also, as pointed out by dd2, your loop bounds are not strict. The code would work correctly nonetheless but would take more steps. You can change the bound to j < (arraySize - i - 1)
",3,39910288
39910343,"
Your loop bounds are not correct and swapping was wrong as well.
",3,39910288
39903045,"
To sort an array:  
To copy an array:
Addresses can be substituted for pointers or iterators in most functions in <algorithm>.
With Pointers 
",1,39902513
39866561,"
Your issue is that you are mixing cin >> and getline which is problematic in C++ due to trailing newlines and what not. 
Good practice is to always use getline and then use a stringstream to split the line up into tokens. For example, I modified your solution to only use getline and string streams (NOTE: You need to #include <sstream> at the top of your file.
You can read more about the issues with mixing cin >> and getline and also other ways to solve them here.
",1,39866351
39835336,"
The problem is on this line:
It compares characters in case-insensitive way, with no provision for tie breaking when lowercase characters are the same.
You need to modify this to swap characters when lowercase on the right is greater than lowercase on the left, or when lowercase representations are the same, but the right side original character is in upper case:
",4,39835224
39835473,"

sorts a given string in alphabetical order in a way where the uppercase letters precede their lowercase equivalent.

You can just define a comparison functor reflecting your intention
Then use std::sort:
",4,39835224
39836007,"
std::string can be considered as a container of chars, and as such you can apply STL's algorithms to its content, including std::sort() (just like you would apply an STL algorithm to e.g. std::vector).
You can specify your particular custom sorting criteria using a lambda, to be passed as the third parameter to std::sort(), e.g. (live on Ideone):
",1,39835224
39819841,"
Yes the swapper(vec[0],vec[size]); is the extraction. 
You are extracting the first element into the last element of the vector. Hence getting the opposite result. 
The heaps min element is vec[0]. Swapping that to the last position will create a max to min ordering within that vector. 
If you implement something like
You will get the ordering you were expecting.
",3,39819787
39813112,"

Use getline to read a line.
Create an istringstream from the string you just read
Read words from there into a vector<string>
Sort the words in that vector

",2,39813072
39813101,"
I would suggest getting a dictionary of words like this and comparing each word with the beginning of the string. If there's a match, you remove that many characters from the beginning of the string and store the word in an array. Repeat this until you get an array that contains all the words and then sort the array alphabetically.
Note: It might be worth going through the entire dictionary and keeping track of each matching word. Once the dictionary has been exhausted, select the longest match as the word before continuing on.
",0,39813072
39891173,"
this is a tough problem If you add constraint that concave/convex gap is always bigger then max distance between any 2 neighboring points

then you should:

for each point add 2 indexes
I would use for points storage something like this:
struct point
 {
 float x,y,z; // point coordinates
 int i0,i1; // index to 2 closest neighbors
 int tmp; // temp for computation purposes 
 };
point pnt[n]; // n is number of points you got

and clear them i0,i1=-1; There is a good idea to also add temp variable so you got space for flags during latter processing
find closest neighbors
so for each point go through all points and remember 2 closest points to it. set their indexes to i0,i1. beware this is O(n^2) unless your points are spatially ordered. I see it like this:
for (i=0;i<n;i++) pnt[i].tmp=0;
for (i=0;i<n;i++)
 {
 i0=-1; l0=-1;
 i1=-1; l1=-1;
 for (j=0;j<n;j++)
  if (i!=j)
   {
   x=pnt[i].x-pnt[j].x; x*=x;
   y=pnt[i].y-pnt[j].y; y*=y;
   z=pnt[i].z-pnt[j].z; z*=z;
   l=x+y+z;
        if ((l0<0.0)||(l<=l0)) { i1=i0; l1=l0; i0=j; l0=l; }
   else if ((l1<0.0)||(l<=l1)) {               i1=j; l1=l; }
   }
 pnt[i].i0=i0; pnt[i0].tmp++;
 pnt[i].i1=i1; pnt[i1].tmp++;
 }

Now the i0,i1>=0 and temp==2 for all valid points. All of the points should be valid if not then the constraint was not met or you got grouped the points wrongly (on one side of point is high density on the other is low so both neighbors are just on one side)
form the polyline
so start on first valid point you found and use it as first point of your polyline/polygon. Then look use its i0 and so on until you hit the starting point or invalid i0. Something like this (assuming all points are valid):
 for (i0=0,i=0;;i++)
  {
  if (i<0) break; // not valid point
  // here add pnt[i] to polyline
  i=pnt[i].i0;
  if (i==i0) break; // end of polyline/polygon
  }


In case you got also invalid points then you should recursively do this on the remaining points (not including already valid points) and also use some max limits for distances so you do not merge point that do not belong to each other. After this you should got few polylines so join them if their endpoints are close ...
To improve #2 you can add condition that neighboring points are not in similar direction but that can affect sharp edges.
If nothing helps you can use convex hull and then remove all vertices that does not correspond to your sample points (concave parts) and recursively do the missing parts. At last join the polylines to single polygon
",0,39796452
39752057,"
In compare, you are subtracting two sub-1 doubles and casting them to an int, the result will in most cases be 0. Instead of subtracting you should compare them and return -1/1.
",8,39751981
39752123,"
Consider using this compare instead:
That said, this style of coding is ancient/deprecated/bad practice.
Consider writing similar to this instead:
Suggested changes:

don't import std names globally
don't mix cstdio and iostreams (only include one of them)
use std::vector or std::array instead of native array
define the sorting order in the interface of the class (bool operator <). (this should also imply that you define the other arithmetic operators - it is good practice and avoids subtle bugs later, but it is not required for this particular implementation to compile and work)
use std::sort instead of qsort
don't use raw pointers (using them like this is a source for bugs)

",5,39751981
39739264,"
Compare the current difference with the previous largest difference (stored in the initialized variable astate), if it's larger than the previous largest then assign. Print the value of astate after the loop.
",2,39739222
39731885,"
In the first outer iteration, we would bubble down the largest integer into a[n-1]. The second iteration only needs to traverse the remaining unsorted part of the array i.e. from index 0 to n-2 and bubble down the second largest integer into a[n-2]. The third iteration only needs to traverse array from index 0 to n-3, and so on.
Variable j achieves this by limiting the range of array to traverse in subsequent outer iterations. We can very well traverse the entire array in every iteration (as you would do after changing n-j with n-1) and obtain the same result. But that would be inefficient, since we would unnecessarily be comparing elements in sorted part of array in every iteration. Let me know if you have any questions.
",1,39731655
39731977,"
As bubblesort works it's way up the list, it swaps the bigger number to the end of the list. This means that with every iteration of the algorithm the last elements are guaranteed to be sorted. If the last elements are sorted, there is no point to revisiting them to sort them again. n-j prevents this by restricting the range of the list to be visited on any iteration. If j grows as the algorithm proceeds, n-j contracts.
Rather than just looking at the code, fire it up in the debugger that almost certainly came with your development environment (and if you don't have a development environment with a debugger it's long past time you corrected this. The debugger is possibly the greatest productivity tool the working programmer has) and step through the code. Watch what happens to the list and the range of the list visited on each iteration. 
The debugger is not just a great tool for fixing code, it can be a great educational tool as well.
",1,39731655
39731729,"
The j variable is used to move the largest number towards the right. On every iteration we move the pointer from n (initially n-j=n as j is 0) to 0 by step 1. Finally we have a sorted array.
",0,39731655
39730173,"
If using the first value for the pivot value in quicksort, an already sorted list is the worse case, since the pivot will always be the lowest value in the partition. This can greatly increase the recursion depth. Each recursive call requires room on the stack frame (consisting of the parameters, local variables and return address). For an almost sorted list of a million numbers, your may need close to a million stack frames active at one time. That could easily exhaust the available stack space and generate your error.
You could try a different pivot algorithm to solve this, like median of three.
",1,39729984
39733196,"
One method to avoid stack overflow, is to use a combination of a loop and recursion. In quicksort() after each partition(), check if (p - left) <= (right - p - 1), and only use recursion on the smaller part, then loop back to split up the larger part. This limits worst case stack overhead to log2(n). The time complexity for worst case remains at O(n^2) though.
Worst case time complexity can be reduced to O(n log(n)) using median of medians
http://en.wikipedia.org/wiki/Median_of_medians
but the constant factor factor is greater, slowing down the quicksort for the average and best cases.
",1,39729984
39710725,"
Say you start with
You can transform it into a vector of strings:
Now we'll check the number of digits required, starting at 1:
At each iteration, we'll create an unordered_set
For each number, we'll attempt to place digits digits of it into the set:
If the size of the set is the size of the vector, we're done:
Otherwise, we need to increase the number of digits:

Full code:
",2,39710112
39710813,"
if you want to sort numbers so use one of sort algorithms let's say bubble sort. then check for uniqueness and store the unique values in a new array then print them:
we make our code for understanding and practice but in a real program we use libraries they are too much powerful and quick:
",0,39710112
39695014,"
Ok. I assume you don't know the in-built sort functions in C++. Take a look at std::sort()
Take Input :
input values into struct array + printing out
Now to make an array of structs :
How do you make an array of structs in C?
Creating an array of structs in C++
Now to sort these arrays :
Sorting a vector of custom objects
How to approach this problem :
std::sort() allows you to give custom functions based on which non-tivial objects are comparable. Example of one such function is :
It takes argument as 2 students that need to be compared by the sorting function and returns the ordering of students s1 and s2 based on GPA. 
This is why the statement s1.GPA < s2.GPA is important. 
So if the student s1 has GPA = 5.0 and s2 has GPA = 4.0 we want the order to be s2,s1 (ascending) so this function returns false, stating that s2 should come before s1.
So in the call of the sorting function :
notice the 3rd argument, gpa_comparision_function, this is telling the in-built function to use our comparison function.
Talk is cheap show me the code :
",0,39694759
39694374,"
This isn't pretty, and relies on picking apart the matrix using its template parameters - but it works.
Thankfully, due to template argument deduction, you can simply call this mess like this:
I'm almost positive there's a more elegant way to do this, but I can't think of it right now. And, because it uses std::vector, you'll need to compile with -std=c++11 or better.
",1,39693909
47871204,"
The best solution I came up with was to copy the rows into a std::vector and then go on to sort that:
",0,39693909
39684202,"
In the test you are using i while instead most probably you wanted to use j (as i is constant in that loop).
",1,39684194
39684236,"
A compiling and properly working code for sorting the vector in increasing order.
",0,39684194
39684302,"
You were trying to swap between ith index only. there was a problem.
",0,39684194
39683301,"
This is just a code snippet and not tested. Code is commented and hence self explanatory.
",-2,39683179
39653485,"
Bubble sort:
Counting words after ordering:
",1,39653350
39653494,"
The best way to count unique words is to use std::unordered_map<std::string, int> and then increment values in the map: wordMap[word]++; Note that if this is the first occurrence of the word, default value would be created and it is 0, which suits the task well.
Beside this, it is not good to implement sorting yourself when there is std::sort which is quite good for great majority of cases.
",4,39653350
39653513,"
You can use std::find from algorithm:
This returns a bool (true if present, false otherwise).
You can also set a counter and then increment it on every true encountered.
",0,39653350
39653600,"
One way of doing the same will be to keep all the sub-string into vectors and then use std::count function on the vector and put the results into a map. Here is the sample code
",0,39653350
39643267,"
You're showing a variation on radix sort. Along with bucket sort, these algorithms are prime examples of sorting not based on comparison, which can offer better complexity than O(n logn).
Do note, however, that your implementation is actually O(n + size).
",2,39643176
39643262,"
It is O(n). More specifically it is O(n+k) where n is the number of elements in input array and k is the range of input in your case size. You are just keeping counts of all elements which occur in the array. And then you just store them in increasing order as many times as they occur in the original array. This algorithm is called count sort.
",1,39643176
39635235,"
This is the working code for bubble sort you might be looking.

First you have to pass the list by ref not value
Bubble up the maximum value at the end of the list.
Properly initialize the it,it2 inside first for loop.


",3,39634884
5056797,"
Even though correct answers have already been posted, I thought I'd add a demo of how you can do this cleanly:

Generic Associative Source (requires C++11)
If you're using an alternate to std::map for the source associative container (such as std::unordered_map), you could code a separate overload, but in the end the action is still the same, so a generalized associative container using variadic templates can be used for either mapping construct:
This will work for both std::map and std::unordered_map  as the source of the flip.
",50,39631634
19528891,"
I needed something similar, but the flipped map wouldn't work for me.  I just copied out my map (freq below) into a vector of pairs, then sorted the pairs however I wanted.
",29,39631634
5056677,"
If you want to present the values in a map in sorted order, then copy the values from the map to vector and sort the vector.   
",10,39631634
14431337,"
I like the the answer from Oli (flipping a map), but seems it has a problem: the container map does not allow two elements with the same key.
A solution is to make dst the type multimap. Another one is to dump src into a vector and sort the vector. The former requires minor modifications to Oli's answer, and the latter can be implemented using STL copy concisely
",8,39631634
5056720,"
You can't sort a std::map this way, because a the entries in the map are sorted by the key. If you want to sort by value, you need to create a new std::map with swapped key and value.
Remember that the double keys need to be unique in testMap2 or use std::multimap.
",3,39631634
23050953,"
To build on Oli's solution (https://stackoverflow.com/a/5056797/2472351) using multimaps, you can replace the two template functions he used with the following:
Here is an example program that shows all the key-value pairs being preserved after performing the flip.
Result:

",3,39631634
5056731,"
A std::map sorted by it's value is in essence a std::set. By far the easiest way is to copy all entries in the map to a set (taken and adapted from here)
One caveat: if the map contains different keys with the same value, they will not be inserted into the set and be lost.
",1,39631634
19783706,"
In the following sample code, I wrote an simple way to output top words in an word_map map where key is string (word) and value is unsigned int (word occurrence).
The idea is simple, find the current top word and delete it from the map. It's not optimized, but it works well when the map is not large and we only need to output the top N words, instead of sorting the whole map.
",1,39631634
20174585,"
Flipped structure might no longer be a map but rather a multimap, thus in the flip_map example above not all elements from B will necessarily appear in the resulting data structure. 
",1,39631634
5056736,"
U can consider using boost::bimap that might gave you a feeling that map is sorted by key and by values simultaneously (this is not what really happens, though)
",0,39631634
54472371,"
In this context, we should convert map to multimap. I think convert map to set is not good because we will lose many information in case of there is many duplicate values in the original map. Here is my solution, I defined the less than comparator that sort by value (cmp function). We can customize the cmp function as our demand. 
",0,39631634
39630622,"
Wild guess: compNodes is overloaded. You smartly tried getting a pointer to the right overload with compareNodes, but you're not actually using it in std::sort(). Change the line to:
If your warning level was high enough, you'd see that compareNodes is currently unused.
",1,39630447
39984362,"
No You can't write a single generic function for sorting, You need to have compare function for each field or You need to keep track of member by which you want to sort by sending one more argument and inside sorting do check for which tag which field to be compared and then swap.
The best way to sort to use compare function per field.
And then use sort function defined in #include <algorithm>
to know more about sort See
If you don't want to use external sort libray modules then you have to write
sorting functions per field.
",0,39623373
39603031,"
The standard library contains the merge function, allowing to merge two sorted vectors (in particular). 
Say you have k sequences, with total length n. Of course, you could merge each time 2 sequences until only a single one remains, but this is known to be worst-case Θ(k2n). 
There are two alternatives:

Merging By Greedy Size In this variant, each time, the two shortest sequences are merged. This [reduces the worst-case time to Θ(k log(k) n).
Merging With A Priority Queue In this scheme, a priority queue holds pairs of iterators and sequence indices, when a smallest element is popped, the next item from the sequence with this index is pushed. This has time Θ(log(k) n), as the priority queue has at most k items at each time.

The following contains an implementation of the latter (with the full code on ideone). (I suspect that, while asymptotically better than the former, it has much higher constants than the former. A generic implementation of the greedy algorithm is (at least for me) a bit trickier, though.)
You can use it as follows:
",3,39597920
40726171,"
As stated by std::sort documentation it requires random access iterator, which std::list does not provide. That's why std::list has it's own method std::list::sort so solution could be:
Note: even if you use container, that supports random access iterator your method would not work, every time you call child.getList() you create a new copy, so would you get UB for calling begin() and end() on 2 different instances. If your idea was to sort data member, you need to return it by reference, which is not a good idea but technically would work:
but better you pass functor to a method of MotherClass, which would sort it's 
data.
",3,40725885
40722402,"
I had the same requirement recently. I was modelling database entities in code and needed a way to map dependencies so that the entities could be created and destroyed in the correct order.
I found a solution with the boost::graph library. I have included a snippet (of real code) in the hope that it can get you started in the right direction.
In the code below, the function create_order yields a vector of entities in the order they must be created, and drop_order does the opposite (the most dependant entity comes first):
",0,40721470
40723404,"
No - I don't think so.
Imagine the following:
B and C depend on A, D depends on C. Now:

B does not depend on C, therefore B is not less than C.
C does not depend on B, therefore C is not less than B.
Therefore B ""is equal to"" C as far as the sort algorithm is concerned.
Similarly, D ""is equal to"" B

First problem: B=C, B=D, but C<D is likely to confuse many sorting algorithms.
Secondly, the algorithm used by std::sort is not specified, but we know many implementations use some form of quicksort. Quicksort implementations are allowed to partition values into three buckets - those that are less than the pivot, those that are greater than the pivot, and those that are all equal to the pivot, and therefore do not need any additional sorting. (See the ""Repeated elements"" section on Wikipedia.)
If such a quicksort selected B as the pivot, then C and D would both find themselves in this ""fat partition"" in some unspecified order, and std::sort wouldn't even test C against D with your comparison function.
",0,40721470
40692899,"
I'm not a C++ expert and the others are pointing out that std::sort() doesn't require three-way comparison, only a <. But to clean up your code as written:
Your compare_dates() keeps doing three-way comparisons for >/</==, and wants a +1/-1/0 return value. So declare a three-way cmp() helper function which does that, like we do in Python. Now your code reduces to:
You only fall-through into doing the lower-order comparisons if the higher-order comparison gave '=='. So that allows you to avoid all the else-clauses, braces and indenting, which keeps your indent level constant and is easy on the eyes. It also calls out the symmetry of the computations.
",3,40692789
40692875,"
This will be enough for sorting a containers of dates into ascending order:
Edit
I intentionally didn't handle -1 separately as for overriding comparator of STL containers like std::sort(), priority_queue or std::set we don't need to provide integer return code and make to code relatively complex. Boolean is enough. 
",3,40692789
40692940,"
What about using the fact that a day use only 4 bit and a month only 5?
--- EDIT --- 
As pointed by Christian Hackl, this code is a little obscure.
I hope that can be more comprensible if you translate the bitfield part in the date struct, trasforming it in a union.
So you can initialize separate year, month and day components and use a full component for compares.
Something as follows
",0,40692789
40692463,"
One way is to find the convex hull of those points, the furthest points are the vertices of that convex hull, take the furthest 3 of the vertices.
This is one way to find the convex hull of a set of points.
You can also check this, it may help you find your way in solving your problem.
",0,40692307
40692345,"
You can define a struct Point that defines a coordinate instead of having two separated variables.
With an operator< on points expressing the distance from the center, you can use std::sort to sort arrays/vectors of Point.
Something like:
helps you to find the three farthest points.
",0,40692307
40683201,"
There are a few errors.
You are incrementing begin in the first for loop, but never resetting it. So the second for loop will never be entered. Each ++begin changes the position of your iterator! The loop for( int i = 1; i < len; ++i) will go to the current position of begin plus i and thus leave the memory.
The following should do what you want:
",0,40682043
40654481,"
You can write a custom iterator, that iterates the elements in specific column, over each row. Something like this:
A lot of the boilerplate for a custom iterator can probably be avoided by using something from boost.
Note: This was written quickly, and may contain errors and unnecessarily convoluted code.
",3,40651837
40629882,"
update - VS2015 introduced non-default-constructible and stateful allocators, which presents an issue when using local lists as was done with the prior bottom up approach. I was able to handle this issue by using node pointers instead of lists (see below) for a bottom up approach.
In @sbi's comment, he asked the author of the top down aproach, Stephan T. Lavavej, why the change was made. Stephan's response was ""to avoid memory allocation and default constructing allocators"". The new top down approach is slower than the old bottom up approach, but it only uses iterators (recursively stored on the stack), doesn't use any local lists and avoids issues related to non-default-constructible or stateful allocators. @T.C.'s answer goes into detail about this.
As for performance, if there's enough memory, it would usually be faster to move the list to an array or vector, sort, then move the sorted array or vector back to the list.
I am able to reproduce the issue (old sort fails to compile, new one works) based on a demo from @IgorTandetnik:

I noticed this change back in July, 2016 and emailed P.J. Plauger about this change on August 1, 2016. A snippet of his reply:

Interestingly enough, our change log doesn't reflect this change. That
  probably means it was ""suggested"" by one of our larger customers and
  got by me on the code review. All I know now is that the change came
  in around the autumn of 2015. When I reviewed the code, the first
  thing that struck me was the line:
which, of course, can take a very long time for a large list.
The code looks a bit more elegant than what I wrote in early 1995(!),
  but definitely has worse time complexity. That version was modeled
  after the approach by Stepanov, Lee, and Musser in the original STL.
  They are seldom found to be wrong in their choice of algorithms.
I'm now reverting to our latest known good version of the original code. 

I don't know if P.J. Plauger's reversion to the original code dealt with the new allocator issue, or if or how Microsoft interacts with Dinkumware.
For a comparison of the top down versus bottom up methods, I created a linked list with 4 million elements, each consisting of one 64 bit unsigned integer, assuming I would end up with a doubly linked list of nearly sequentially ordered nodes (even though they would be dynamically allocated), filled them with random numbers, then sorted them. The nodes don't move, only the linkage is changed, but now traversing the list accesses the nodes in random order. I then filled those randomly ordered nodes with another set of random numbers and sorted them again. I compared the 2015 top down approach with the prior bottom up approach modified to match the other changes made for 2015 (sort() now calls sort() with a predicate compare function, rather than having two separate functions). These are the results. update - I added a node pointer based version and also noted the time for simply creating a vector from list, sorting vector, copy back.
For sequential nodes, the prior version is only a bit faster, but for random nodes, the prior version is 30% faster, and the node pointer version 35% faster, and creating a vector from the list, sorting the vector, then copying back is 69% faster.
Below is the first replacement code for std::list::sort() I used to compare the prior bottom up with small array (_BinList[]) method versus VS2015's top down approach I wanted the comparison to be fair, so I modified a copy of < list >.
I made some minor changes. The original code kept track of the actual maximum bin in a variable named _Maxbin, but the overhead in the final merge is small enough that I removed the code associated with _Maxbin. During the array build, the original code's inner loop merged into a _Binlist[] element, followed by a swap into _Templist, which seemed pointless. I changed the inner loop to just merge into _Templist, only swapping once an empty _Binlist[] element is found.
Below is a node pointer based replacement for std::list::sort() I used for yet another comparison. This eliminates allocation related issues. If a compare exception is possible and occurred, all the nodes in the array and temp list (pNode) would have to be appended back to the original list, or possibly a compare exception could be treated as a less than compare. 
As an alternative to the new VS2015 std::list::sort(), you could use this standalone version.
or use the similar gcc algorithm.
",20,40622430
40669664,"
@sbi asked Stephan T. Lavavej, MSVC's standard library maintainer, who responded:

I did that to avoid memory allocation and default constructing
  allocators.

To this I'll add ""free basic exception safety"". 
To elaborate: the pre-VS2015 implementation suffers from several defects:

_Myt _Templist, _Binlist[_MAXBINS]; creates a bunch of intermediate lists (_Myt is simply a typedef for the current instantiation of list; a less confusing spelling for that is, well, list) to hold the nodes during sorting, but these lists are default constructed, which leads to a multitude of problems:


If the allocator used is not default constructible (and there is no requirement that allocators be default constructible), this simply won't compile, because the default constructor of list will attempt to default construct its allocator.
If the allocator used is stateful, then a default-constructed allocator may not compare equal to this->get_allocator(), which means that the later splices and merges are technically undefined behavior and may well break in debug builds. (""Technically"", because the nodes are all merged back in the end, so you don't actually deallocate with the wrong allocator if the function successfully completes.)
Dinkumware's list uses a dynamically allocated sentinel node, which means that the above will perform _MAXBINS + 1 dynamic allocations. I doubt that many people expect sort to potentially throw bad_alloc. If the allocator is stateful, then these sentinel nodes may not be even allocated from the right place (see #2).

The code is not exception safe. In particular, the comparison is allowed to throw, and if it throws while there are elements in the intermediate lists, those elements are simply destroyed with the lists during stack unwinding. Users of sort don't expect the list to be sorted if sort throws an exception, of course, but they probably also don't expect the elements to go missing.


This interacts very poorly with #2 above, because now it's not just technical undefined behavior: the destructor of those intermediate lists will be deallocating and destroying the nodes spliced into them with the wrong allocator.


Are those defects fixable? Probably. #1 and #2 can be fixed by passing get_allocator() to the constructor of the lists:
The exception safety problem can be fixed by surrounding the loop with a try-catch that splices all the nodes in the intermediate lists back into *this without regard to order if an exception is thrown.
Fixing #3 is harder, because that means not using list at all as the holder of nodes, which probably requires a decent amount of refactoring, but it's doable.
The question is: is it worth jumping through all these hoops to improve the performance of a container that has reduced performance by design? After all, someone who really cares about performance probably won't be using list in the first place.
",8,40622430
40607021,"
Create vector of all the maps and sort them by tieing their keys in the order of key's specified priority: 
Live Demo 
",0,40605975
40606762,"
For the purposes of education...
std::map requires that the key in the key/value pair is invariant. It also requires that the key fully describes the ordering.
In the case of allmap, the key provided is a std::string, which is all the map has to go on - even with a complex custom comparison function.
In order to allow any kind of sorting, we would need to roll both the outer name and the maps they represent into one key object, and sort on that.
This starts to argue for either using a set of objects (since there is now no associated data) or keeping a separate, sorted index of keys, sorted by our custom predicate.
Here is the latter:
",0,40605975
40605533,"
The first one has complexity of n² in any case.
Whereas in the sorted case, your second algorithm is linear:
toSort[minElem] < toSort[minElem - 1] and toSort[maxElem] > toSort[maxElem+1] is always false, so your inner loop break immediately.
",0,40604651
40579703,"
It is Unspecified by the C++ standard how a standard library should implement a Heap. So you should not expect a specific arrangement. The C++ standard only specifies the behavior.
TL;DR;
There is a difference between heap[0] = 0and heap.push_back(0). The former doesn't change the size of the container while the latter does. And the heap representatioin for odd/even sized container may be different; it doesn't matter, all we want is a heap behavior when we access it using appropriate functions.

Again, whenever you use functions like std::make_heap, you should use its associated functions (std::push_heap and std::pop_heap) to access the container (this is guaranteed to maintain the heap properties of the container). 
Any other modification to it may result in the container losing its heap properties. This includes:
And even:
",2,40579647
40579803,"
To be a valid heap, heap[i] <= heap[(i - 1) / 2] for all i > 0.
In both cases make_heap() is creating a valid heap.  The first has 5 elements, and the second has 6.  I don't understand parts of your question, but they don't seem relevant to make_heap().
",1,40579647
40577274,"
45 and 5 compare as equal according to your comparison function, so they can appear in any order. List sort is stable, so they will remain in the order they were in originally. 
Initially , this order was 45 5, and this is what your first print should display. After l.sort() (using the default comparison function), the order becomes 5 45 and any further sorts with your custom comparison function will retain this order.
",1,40577211
40576513,"
The major problem for crash is that you are changing n inside for loop for iterating in newAbc. And your if condition will be true for at least 25 times so incrementing n by 25(minimum) in each iteration resulting in accessing out of bound memory(SEG-FAULT).
Assuming that your duplicate counting works fine, below are the changes required:-
",0,40575802
40572528,"
If you inspect the execution of the insertion sort you see that it gets to sort far larger arrays than size 10. This would have been caught, had you followed the excellent advice given in Lipperts writeup linked by πάντα ῥεῖ. 

If you’ve still got a bug then first double check that your specifications contain all the preconditions and postconditions of every method.

and

If you’ve still got a bug then learn how to write assertions that verify your preconditions and postconditions.

The function call 
Indicates that insertionSort operates on the entire array [0, last] not [first, last]. 
Change this and the performance of your modifiedQuicksort will behave as expected.
",1,40572182
40565659,"
Of course, there are.
For example, have a look at lower_bound and upper_bound functions.
Also binary_search may be useful.
All these functions work on the sorted input and have logarithmic complexity.
",4,40565591
40565637,"
Try std::binary_search from #include <algorithm> 
",2,40565591
40562113,"
While sorting the first row, just iterate over rest remain rows and do the swaps on similar indexes.
",1,40562096
40559951,"
The sort function automatically assign a pair to both a and b.
The function you use (here, sortbysec) needs to have a return type of Boolean.
By defining it in this way:
, pairs inside vector are sorted in descending order based on second value of each pair, when (a.second < b.second) is true.
More info:
",1,40559800
40552709,"
You are not updating head to point to the new start of the list.
At the end of the first iteration of the outer loop, firstPointer will point to the smallest element and can be updated to the new head.
",0,40552392
40552802,"
Sorting of list is not as easy as it appears in your code:
should look like this upon swapping first with second: 
How to do that:

Store next1 or next2, and keep track of prev1 and prev2 all the time as you can't look back in singly linked list.
first->next = next2 and second->next = next1
prev1->next = second and prev2->next = first

During all this, you need to take special care for list's head.
",0,40552392
40557378,"
As pointed out by Kenny Ostrom, even if the head issues are fixed, if the initial sequence of student id's is 5,3,1,4,2, then the sort ends up with 5,1,3, not sorted and losing two values.
The code is swapping firstPointer and secondPointer, which are used as the inner and outer loop variables. This creates a problem.
When swapping nodes in a linked list, the nodes may be adjacent (three next pointers rotated) or they may be non-adjacent (two pairs of next pointers swapped). To handle both cases with the same code, first swap whatever points to the two nodes to be swapped first (like swap prev1->next with prev2->next), then swap the two node's next pointers (like swap curr1->next with curr2->next).
Trying to use bubble sort or any swapping sort to sort a linked list is complicated because you need to keep track of two previous pointers to nodes as well as two current pointers to nodes.
It would be simpler to start off with an empty ""sorted"" list, then remove one node at a time from the original list, and insert the node into it's proper location into the ""sorted"" list. For this method, start off with Node * sorted = NULL; Once all nodes have been removed from the original list and inserted in order into ""sorted"", then set head = sorted, so that head points to the sorted list.
A much faster method to sort a linked list uses a small (25 to 32) array of pointers to nodes combined with a bottom up merge sort, but that is more than what is needed in this case.
",0,40552392
40528131,"
Moving the rows of the matrix around during sorting is something you should avoid. Instead I would sort a vector of
that contains your id and the original index in the array. Once you sorted that std::vector<IdAndIndex> you can rearrange the matrix rows accordingly.
Or if you really want to sort the matrix directly (maybe it is small) you could instead sort a vector of 
",1,40528046
40499086,"
Your index in randomizedPartition should be start + rand() % len, not just rand() % len.
Also, as a side note, your print function isn't actually doing what you want it to. You want it to print the elements start through end, but it's actually printing 0 through end - start. Your debugging process and your coding process in general would benefit from trying to keep things clean and simple. The code is a bit of a mess right now which makes it harder to debug.
",0,40498906
40476285,"
This will get your data into memory about as fast as possible, assuming Linux/POSIX running on commodity hardware.  Note that since you apparently aren't allowed to use compiler optimizations, C++ IO is not going to be the fastest way to read data.  As others have noted, without optimizations the C++ code will not run anywhere near as fast as it can.
Given that the redirected file is already open as stdin/STDIN_FILENO, use low-level system call/C-style IO.  That won't need to be optimized, as it will run just about as fast as possible:
That code will read your data into memory as one long C-style string.  And the lack of compiler optimizations won't matter one bit as it's all almost bare-metal system calls.
Using fstat() to get the file size allows allocating all the needed memory at once - no realloc() or copying data around is necessary.
You'll need to add some error checking, and a more robust version of the code would check to be sure the data returned from fstat() actually is a regular file with an actual size, and not a ""useless use of cat"" such as cat filename | YourProgram, because in that case the fstat() call won't return a useful file size.  You'll need to examine the sb.st_mode field of the struct stat after the call to see what the stdin stream really is:
(And for really high-performance systems, it can be important to ensure that the memory pages you're reading data into are actually mapped in your process address space. Performance can really stall if data arrives faster than the kernel's memory management system can create virtual-to-physical mappings for the pages data is getting dumped into.)
To handle a large file as fast as possible, you'd want to go multithreaded, with one thread reading data and feeding one or more data processing threads so you can start processing data before you're done reading it.
Edit:  parsing the data.
Again, preventing compiler optimizations probably makes the overhead of C++ operations slower than C-style processing.  Based on that assumption, something simple will probably run faster.
This would probably work a lot faster in a non-optimized binary, assuming the data is in a C-style string read in as above:
That is also very fragile.  It relies on strtol() skipping over leading whitespace, meaning if there's anything other than whitespace between the numeric values it will fail.  It also relies on the initial count of values being correct.  Again - that code will fail if that's not true.  And because it can replace the value of next before checking for errors, if it ever goes off the rails because of bad data it'll be hopelessly lost.
But it should be about as fast as possible without allowing compiler optimizations.
That's what crazy about not allowing compiler optimizations.  You can write simple, robust C++ code to do all your processing, make use of a good optimizing compiler, and probably run almost as fast as the code I posted - which has no error checking and will fail spectacularly in unexpected and undefined ways if fed unexpected data.
",3,40473560
40473624,"
You can make it faster if you use a SolidState hard drive. If you want to ask something about code performance, you need to post how are you doing things in the first place.
",2,40473560
40474238,"
You may be able to speed up your program by reading the data into a buffer, then converting the text in the buffer to internal representation.  
The thought behind this is that all stream devices like to keep streaming.  Starting and stopping the stream wastes time.  A block read transfers a lot of data with one transaction.    
Although cin is buffered, by using cin.read and a buffer, you can make the buffer a lot bigger than cin uses.
If the data has fixed width fields, there are opportunities to speed up the input and conversion processes.
Edit 1:  Example 
The tricky part is handling the cases where the text of a number is cut off at the end of the buffer.
",0,40473560
40475935,"
Can you ran this little test in compare to your test with and without commented line?
Pure read test:
",0,40473560
40466974,"
Ahh..Too many edits  in your question for anyone's liking. Just keep it simple by using map. 
In C++, map comes really handy in storing the unique + sorted + respective_count values.
Edit:

maybe suggest some more elegant and fast way to solve my problem  (without hash tables)!


Sort the vector
Traverse through the sorted vector, 

and do
To start, initialize previous_value = current_value - 1
and previous_previous_value as current_value - 2.
",1,40466502
40466998,"
While this may be frowned upon (for not using standard algorithms and such), I would write some simple solution like this:
",1,40466502
40467587,"
O(n) complexity solution:
cpp.sh/4i45x
",1,40466502
40467471,"
std::vector has a constructor that accepts 2 iterators for range [first,second[ You cannot call constructor for existing object - it is already created, so your code 
actually tries to use myVec as a functor, but std::vector does not have operator() hence the error.
you have 2 ways, pass 2 iterators to  constructor directly:
or use copy initialization with temporary vector:
Same for the second vector:
as pointed by Logman std::unique does not seem to guarantee value of duplicates, so working solution can use std::set instead (and you would not have to presort source vector):
",1,40466502
40460238,"
Danh's comment is right, but this is actually a duplicate question. However, there are no duplicates with accepted answers yet.
So: the problem is that member functions need a this pointer, unless they're static. And std::sort won't give you a this pointer, nor do you need one. So making it static is the straightforward solution.
",1,40460048
40460180,"
sort is not a method of the class so it will not have the correct this pointer, so calling a member function is a problem.

When a non-static class member is used in any of the contexts where
  the this keyword is allowed (non-static member function bodies, member
  initializer lists, default member initializers), the implicit this->
  is automatically added before the name, resulting in a member access
  expression (which, if the member is a virtual member function, results
  in a virtual function call).

http://en.cppreference.com/w/cpp/language/this
",2,40460048
40460454,"
I would suggest you have a look at this. There is a difference between types of non-static member function and static member function. And I believe the cpp concept Compare requires the form like the static ones
",0,40460048
40455777,"
i variable should be less than 9 not 10. As you can see in if statement you are checking arrSort[i + 1], so in last element you are checking number which is out of your table range (arrSort[10] doesn't exist). I'm not able to check it right now, but I guess it's the problem.
",1,40455706
40455834,"
I think the problem is here:
When
Your array have 10 elements and you try to compare
And 
Does not exist
",1,40455706
40446368,"
Approach:

Use map <convert_to_lower_case(words) as string, index as integer> to put all the words in the list. 
After that create a sorted vector myVec using:
for(it_type iterator = m.begin(); iterator != m.end(); iterator++) {
       myVec.push_back(original_list[it->second]);
 }

myVec is the lexicographically sorted list you are looking for.
You need to implement convert_to_lower_case(word) :
Other answer is good too, uses comparator to sort the vector.
",2,40446250
40446289,"
Does this not do what you want?
stdout looks like this:
",1,40446250
54265246,"
Use compareToIgnoreCase Method
",0,40446250
40874189,"
For both questions you need to create dynamic arrays, 1 dimensional array for the 1st and 2 dimensional array for the 2nd. You do this using the new operator.
Don't forget to deallocate the dynamically allocated memory whenever you use the new operator.
Try this for the first question:
and try this for the second question:
",-1,40438854
40435940,"
You can try use vector<vector<char>> to  build the 2D array. And the code is like this:
In that way you can obtain a 30*30 array. You can access every elements in that array by using arrays[i][j]. 
  By the way, if you are using iostream and cin,cout, please do not use printf(),because they have same function but printf is a C-style function and iostream is C++ style. If you are writing in C++, keep using C++ style code instead of C-style.
",1,40435527
40405691,"
To sort the data, but only have the indices show the sort order, all you need to do is create an array of indices in ascending order (starting from 0), and then use that as part of the std::sort criteria.
Here is an example:
Live Example
Even though the example uses std::array, the principle is the same.  Sort the index array based on the items in the data.  The tumor array stays intact without the actual elements being moved.
This technique can also be used if the items in the array (or std::vector) are expensive to copy if they're moved around, but still want to have the ability to produce a sorted list without actually sorting items.  
",1,40405266
40399149,"
std::sort works on iterators, and doesn't care about the iterator implementation. Hence, if you define a struct RowIter which wraps a std::vector<double>& matrix, with a member size_t RowSize for operator+(size_t) (and operator-, operator++ etc) and a Row operator*() const, then std::sort can sort by that iterator.
Still quite a bit more work than qsort, unfortunately, but it would generalize to non-POD types.
",3,40397977
40398781,"
It is possible to replace qsort with std::sort to sort the underlying array, but you have to define:

a Row type that directly accesses the underlying storage of the vector - you cannot use a vector here because even if an array or arrays is still an array, a vector of vectors is not a vector of square size. Worse, I know no portable way to assign an existing storage to a vector. That Row type will have to be move-constructible and move-assignable, and correctly support swap.
a RandomAccessIterator on that Row type, able to correctly process the end of the underlying array.

It is up to you to do that, but all the versions of standard C++ explicitly support the C library, so there is no harm is using qsort in this use case because it is much simpler and in the end less error-prone. The qsort way only required 7 lines, which is easy to control and peer review. The nice C++ way will require at least 2 classes with non-trivial constructors so much more lines and much more possibilities of mistakes in them.
If you really cannot use qsort, maybe for internal coding rules, then I would simply copy the data to a vector of vectors, sort it and copy the data back to the initial vector. It involves 2 additional full copies of the matrix but at least use standard classes and requires far less coding.
",2,40397977
40438996,"
The easiest solution is to keep the qsort() and just use std::vector::data(), which returns a pointer to the first element, thus allowing you to use a std::vector much the same as a C array:
Using std::sort() properly is possible, but verbose, as you would not only need an random access iterator class to iterate by rows, but also a class that abstracts a row so that std::sort() can swap them.
A way around that, but still using std::sort is to extract the elements you want to sort into their own std::vector along with an index. Then sort that vector and finally reorder the rows in the original matrix by the indices in that vector.
",0,40397977
40397240,"
You can use std::map to store std::vector<char> for each integer. The integer value is the map's key. Each key contains a vector of characters:
Or use std::multimap
Depending on the data, you may also be able to use std::map<char, int>. But this assumes char is the map's key, and each character appears no more than once. Each character can be associated with any number.
",3,40396144
40394395,"
log(N) Solution
Essentially the same idea you have for a better way to solve it, but rather than store only a 10th of the elements, store all of them and use binary search to find the index of the one closest to your value.

Analysis
Even though this solution is O(logN), you really have to ask yourself if it's worth it. Is it worth it to have to create an extra vector, thus accumulating extra clock cycles to store things in the vector, the time it takes for vectors to resize, the time it takes to call a function to perform binary search, etc?
As I was writing the above, I realised you can use a deque instead and that will almost get rid of the performance hit from having to resize and copy contents of vectors without affecting the O(1) lookup of vectors. 
So I guess the question remains, is it worth it to copy over the elements into another container and then only do an O(logN) search?
Conclusion
TBH, I don't think you've gained much from this optimization. In fact I think you gained an overhead of O(logN).
",5,40394199
40392827,"
Generate a vector of indices from 0 to ages.size()-1. Sort the indices according to ages, probably using a lambda compare function. Then reorder all three vectors according to the sorted vector of indices. This will keep all three vectors in ""sync"", regardless of any duplicates in ages.
The reordering is simple if you just copy a vector according to indices sorted[i] = original[sorted_index[i]]. Reordering in place can also be done, as shown in the example below, but it's a little known algorithm, and if this is homework, I don't know where a student would be expected to be aware of this algorithm or be able to find examples of this algorithm. The algorithm is based on the fact that a permutation can be considered as a sequence of cycles:
http://en.wikipedia.org/wiki/Permutation#Cycle_notation
",0,40392384
40374513,"
You sort a local copy, iterate by reference instead:
",2,40372865
40315187,"
After sorting the x partitions, you would merge the x partitions. This could be done with log2(x) passes doing a 2 way merge, or a single pass doing an x way merge. An x way merge commonly uses a heap to speed up determining which of x elements (and which partition the element belongs to) is the smallest. Other than initialization, elements are removed from and added to the heap one at a time. Eventually the end of one of the x partitions is reached, and the merge becomes an x-1 merge. Finally just one partition is left and it's copied to the output array.
If the array is so large that it's partitions are much larger than the core specific L1 and L2 caches, parallel radix sort won't help much due to conflicts since all cores share the common L3 (and L4 if present) cache and main memory. For example, each core's L1 cache might be 32KB and each core's L2 cache might be 256KB. 
An alternative would be to split up the array into z 256KB partitions, and then do x radix sorts at a time for the z partitions. The last step would be a z way merge of the z sorted 256KB partitions.
As for the radix sort, instead of using base 10, you may want to use base 256 for 8 bit fields (you can shift instead dividing to split up an element into fields).
",0,40315036
40314496,"
You need:
Don't forget to #include <functional>.
",4,40314474
40314662,"
A couple ways other ways to do this.
We can't just pass in a class method without binding the instance as Kerrek SB does in his answer. A method will have a hidden this parameter whether you use it or not.
In this case it looks like you use it not, so a static method is probably the easiest:
Slightly more and less complicated at the same time option is everybody's close, personal friend the Lambda Function:
Note: you will need two more Lambdas to get an electric violin solo.
",1,40314474
40625134,"
std::bind() definitely works.
A simple method with just a struct.
",0,40314474
40297487,"
A binary merge sort has a very simple recursive definition: split the input array into two halves, sort the two halves using binary merge sort, merge the two halves into a sorted sequence. This is what you implemented.
A different version is a bottom-up merge sort. This first splits a sequence up into subsequences of length 1, and then starts merging them.
A natural merge sort has a different first step. It doesn't split the input sequence into halves, but into runs. A run is a sequence of elements that are increasing or decreasing. For example the following array:
Can be split into runs like this:
Where each run is is already ascending. Then you start merging runs as if you would in merge sort, except you merge from the bottom up.
The reason this is called a natural merge sort is that if your input is already (partially) pre-sorted, the algorithm will start to approach a O(n) best case performance.
",4,40297282
40266715,"
If you use a vector, you gain the performance that all the memory you're working with is contiguous, but lose performance because you have to copy.
If you use a linked list of any type, you gain because you don't have to copy, but you lose because your memory is scattered all over the place.
As such, this will depend on the number of items being sorted, the processor cache, and probably a whole host of other things.
Given that this sorting algorithm is known to be slow for any numbers of N, the correct solution is to not worry about performance at all and just use std::sort.
",0,40266453
40245728,"

I don't know how to implement this bit into my code, I'm not sure about what bucket[] do in the code above. Can anyone explain what changes should I make?

To be honest, buckets[] is not needed. The idea is to keep indexes of bucket beginnings here, but since later buckets are processed in the same order one by one, it's possible to use a couple of additional variables instead of this array.
As I've said, you should convert numbers to strings and sort strings. This way you'll be able to check 1 character per bucketing, not doing all create-string->compare->destroy-string operations. In the end you'll have to convert strings back to numbers.
The part of code you were asking can look like this:
To sort string vector you can do something like this:
",2,40240729
40236993,"
You are using Selection Sort. Your program has 4 errors. Use 'if' instead of while.
",0,40236607
40237090,"
The Reason for the failure.
Changes of your algorithm in each iteration:
Now hope you can fix it.
",0,40236607
40237095,"
I believe that this:
might cause problems in general. I mean, you increment y, but don't check if it's less than the array length (5 in this case), so I think that for some cases it would start comparing and swapping with elements from beyond the array. I'm amazed that you didn't get segfault yet.
This problem appears to be in the both of the options (ascending and descending).
What I'd dp with that would be changing this while loop with and if statement, and removing y++ from it
That way the parent while loop still handles incrementing y and checking if it's less than 5 but we can't address something out of the array.
I'm not sure if it will solve the problem, although that 0 appears out of nowhere, so it's most probably from somewhere beyond the array, and since it appears somewhere near the end of the sorting it doesn't go down, because your algorithm assumes (and correctly btw) that all previous elements are already sorted.
I'd suggest you implementing bubble sort, since it's easy to understand and implement, and holds some potential for optimization (I optimized it so hard that it's worst case was faster than merge sort... don't know why though).
",0,40236607
40226568,"
The problem is unrelated to passing arrays by reference, value types
or unwrapping. The real problem is that in Swift, a 
statement defines a variable which is valid only in the scope of the loop, possibly hiding a variable with the same name in the outer scope.
You cannot refer to the ""last value"" of the variable after the
loop statement (which you can in C).
In your case,
defines a variable i for the scope of the loop body, hiding the outer variable i defined at the top of the function. Therefore in
i is always zero, because that variable was never changed.
Actually the compiler warns you about the problem:
A correct version of your code with slight simplifications would be
",1,40224581
40195756,"
The template is called std::greater, and it is declared in the header <functional>, which you must include.
",2,40195723
40194241,"
To sort something the sort algorithm needs to know how to compare items std::sort. Otherwise it will use the default comparison for int. Either you implement comparison operators (<, >, ==) for item (or implement a comparison class for your item).
",0,40194100
40229429,"
The algorithm provided in the book considers the indices as 1,2,3....N, they start from 1.
So just follow the algorithm but keep one thing in mind when we access array we must subtract 1 from the index
So your first method code should be:
In second method, what you are doing wrong is that you are checking bounds with respect to 0 based index.
We cannot go by 0 based index here, because for 0 index, the left child is at index 1, but 2*0 is 0 only, So the only way is to use 1 based index everywhere and only while accessing elements you subtract - 1
",1,40168231
40168464,"
I ended up figuring out the indexing issues.  I still couldn't get the first method to work due to the fact that I was using pointers to point at A and the size was never correct.  So I stuck with my second method.  Here is the corrected code.  
",0,40168231
41201251,"
You don't actually resize the vector, your vector is empty.
Instead of:
Use:
This would have been obvious if you had used the range-based for loops:
",2,41201195
41201305,"
You can replace your for loop where you initialize the vector using indexes to push_back.
",1,41201195
41203628,"
If you are starting to learn C++, learn C++11 features. It will make your code easier to write, and less buggy. This is a much better way to write your program, IMO, and it addresses the bug you had. Also, note that return 0 by main means ""ok"" and 1 means ""not ok""
",1,41201195
41188027,"
You could just add a partial specialization for std::set<T> and std::map<T1,T2> for your template function:
This answer has details about the template functions overload resolution.
",6,41187782
41187881,"
alexeykuzmin's answer is simpler and should solve your issue. My answer below is slightly more complicated but it could be an interesting read for educational purposes.


Can fixOrder be written in such a way that it would only do things for std::vector and not for other containers?

Yes! You can use std::enable_if and an helper is_specialization_of trait:
With the above code...
...will print:

C is a vector
C is not a vector

wandbox example
",5,41187782
41186848,"
You can use any sorting algorithm with a simple addition. When swapping 2 values you can swap index values too.
Create index values for initial indexes
",0,41186649
41187556,"
As @cokceken said (I know answers shouldn't refer to other answers but I'm not a high enough Stack Overflow rank to comment on answers :/ ), use any simple sorting algorithm, and simply add in your own functionality for any special cases, such as values of 0 or negative values in your example.
For example, assuming you don't actually want to sort the original array and just create a new array that links indices in the array to their sorted rank,
(note that arraySize must be a value and not a variable, since C++ does not let you statically define an array with a variable size)
",0,41186649
41187701,"
I found this was easier if you keep separate values for the value, original position and the rank in a class:
Output:
",0,41186649
41185674,"
Your problem is a misconception on rankings. Array indices are of size_t not float, so you'll need to return a vector<size_t> not a vector<float>.
That said your sort is O(n2). If you're willing to use more memory we can get that time down to O(n log(n)):
Live Example
EDIT:
Yeah this actually gets a little simpler when taking a vector<float> instead of a float[]:
Live Example
",1,41184561
41185063,"
",1,41184561
41184616,"
v_sort[i] is a float (it's just an element of v_sort vector) while only integral types can be used as array subscripts.
Probably you meant v_sort as an array of indices, thus, you should declare it as std::vector<size_t> or std::vector<int> something like that.
UP: Also, given that you change the values of the array passed, it's not an elegant way of pass it by const reference.
To sum up, the following code compiles correctly on my machine:
",1,41184561
41186129,"
I suggest you adopt a more robust solution by taking advantage of what you have in the STL. To do so, we will first make an ""index vector"", ie. a std::vector<std::size_t> vsuch that for any i, v[i] == i is true:
Now all we have to do is to sort this vector according to a specific comparison function that will use the input vector. Furthermore, to allow for the most generic approach we will give the user the opportunity to use any comparison functor:
In the sorted index vector, index[0] is the index of the lowest value in the input vector, index[1] the second lowest and so on. Therefore, we need one additional step to get the rank vector from this one:
Now we combine all the pieces together:
Result with [10, 332, 42, 0.9, 0]: [3, 5, 4, 2, 1].
You can find a Live Demo on gcc 4.3.6 to explicit this behavior.
",1,41184561
47619503,"
Here is my codes using STL to achieve this in a concise way to get the rank. 
",0,41184561
41169451,"
Looks like your particle object is quite heavy (~420 bytes), so instead you can heave multiple different pre-sorted array that only store an index that point to your main vector storing particles.
unsigned int can be used to index all those 250k elements.
If my math is correct they're only going to be about 7MB each.
Keep in mind though, that because access pattern to your main array is going to be non-local (you going to jump between different indices that are far away from each other), it will lead to a lot of cache misses and can make it quite slow. 
",0,41169201
41188999,"
This approach worked fine for me. I got the time to load an unsorted vector to a new sorted vector from around 15sek to something about 35ms with additionally multithreading(duo core) the load process. 428x faster. Thx for the help.
",0,41169201
41165230,"
Fixing the bugs
Try this:
I added a missing } and changed the condition of the inner loop to i+1 < n to avoid array access out of bounds. 
This is the output:
Aligning the output
You can make the output aligned more nicely by replacing 
with 
and writing 
at the top of your file. Then the output is 
",4,41165068
41164628,"
Whereas the complexity is good, you create a lot of copies which might be avoided.
You may use the modified version:
",0,41161046
41157277,"
You can do this with a custom comparator for struct sokaddr_in. The snippet below explains what I mean. The advantage of this approach is you can customize the comparator for IPv6 and to include port nos. and other stuff if IP addresses are same.
Hope this helps.
",4,41156952
41157053,"
Convert the addresses to unsigned integers. The code could look like this:    
Insert all identifiers to some vector/array and sort it.
",0,41156952
51723209,"
The third inet_pton parameter is a pointer to a in_addr structure.  After a successful inet_pton call, the in_addr structure will be populated with the address information.  The structure's S_addr field contains the IP address in network byte order (reverse order).  The ntohl function will convert the address from network byte order to host byte order.
",0,41156952
41154329,"
You need to reposition the call to sort so that it's outside the for loop.
Currently your sort is invalidating the iterator (on its first call as thereafter it's a no-op) which is causing the effect you observe.
(I'm sure you know that you don't need to sort the vector in order to compute the total.)
",3,41154304
41131614,"
You can just use 
list.sort() 
and 
list.sort(std::greater());
to get the ascending and descending order.
You can check the following link:
http://en.cppreference.com/w/cpp/container/list/sort
",2,41131497
41131569,"
As user2357112 hinted, you should have:
",0,41131497
41131013,"
Change the while loop to 
Here is the updated code:
",4,41130915
41175692,"
Such a large difference is the product of two conditions.
The first condition is related to the original code.  The in-place merge is so efficient there would be difficulty devising anything significantly faster, even if coding manually at the assembly language level.  The application of generics is straightforward, so the compiler ** produced the same assembly with or without it.  Because the algorithm implementation is efficient, only a few machine instructions added into the loop is capable of producing the significant proportional change indicated in the question.
** Compilation specifics throughout this answer were using g++ 6.2.1 20160916, the default Fedora 24 dnf package, along with LINUX kernel 4.8.8-200.fc24.x86_64.  Runtime was Intel i7-2600 8M cache.  Also to Atmel SAM3X8E ARM Cortex-M3 with arm-none-eabi-g++ 4.8.3-2014q1.
The second condition is related to the compilation of the second trick described in paragraph 3 sentence 2 of the question.  The first trick, the reduction of types in the template, did not produce any significant change in the assembly language.  The second trick produced flop-affecting assembly level differences in the compiler output for the two calls.
This precompiler hack can ease testing.
Execution and compare using these commands in a bash shell exploits the precompiler hack.
These instructions are a result of initializing the InputIterator store[ ], but that is outside the loop.
The primary slow down comes in dereferencing the two items contained in store[ ], as needed by the compare and swap, and that is within the loop.  These instructions do not exist in the version without the second trick.
Although there is duplication of code in the bodies of the conditional for the version without the trick, that only impacts the compactness of the code, adding two calls, five moves, and one compare instruction.  The number of CPU cycles required to perform the in-place merge is the same between branches resulting from the compare, and both lack the instructions listed above.
For each of several syntax permutations tried, removing the redundancy in the branches to improve compactness inescapably leads to additional instructions required along the execution path.
The details of the instruction sequences for the various permutations discussed thus far will vary from compiler to compiler, optimization option selection, and even the conditions of calling the functions.
It is theoretically possible for a compiler to employ an AST (abstract symbol tree) refactoring rule (or the equivalent) to detect and reduce both program memory and CPU cycle requirements for either version of the function.  Such rules have have antecedents (search patterns) that match the pattern to be optimized within the code.
Optimizing speed for the code with the second trick would require a rule antecedent that matches at the atypical score[ ] abstraction both inside and outside of the loop.  Detecting the branch redundancy without the second trick is a more reasonable goal.
Integrating the two statements within each branch, one can see how the two like patterns in the AST might be simple enough for a refactoring rule antecedent to match and perform the desired code size reduction.  There would be very little gain in speed for this case, if any.
",13,41129442
41247409,"
The following is just a short intuitive explanation:
If we scale away everything and assume that the iterators are normal pointers we can in the first example store all iterators in registers. 
In the branch-less code we cannot easily do that, due to store[cmp], and ++store[cmp] - and that implies an overhead for all use of store[0], and store[1]. 
Thus (in this case) it is more important to maximize use of registers than avoiding branches.
",3,41129442
41126558,"
First for merge - you should pass const references to arguments, otherwise you make too many unnecessary copies. Also you get out of bound access to result as you create in empty and accessing by index. And it is not a good idea to use int for index. So simplified version could be:
or version that closer to your:                
",1,41126162
41126204,"
The recursive calls to MergeSort do nothing, because intArr is taken by value (copied) and you're not using the result value.
Something like this should work:

As Slava mentioned in the comments, you also have UB when accessing result, because its size is 0:
You should invoke std::vector::resize before accessing the elements using operator[].
",3,41126162
41109090,"
on your first for loop you have a semicolon at the end:
you have an empty loop and a block of code that executed once.
",3,41108910
41104174,"
I would strongly suggest that you never store any kind of pointer in a container.
Instead, make a handle class which supports the required arithmetic and comparison operators.
It makes for code that's easier to reason about:
",3,41103886
41104033,"
Lambdas are just syntactic sugar for a class with operator(), so you can very easily write one directly (especially if you don't need captures):
",2,41103886
41092193,"
If I have understood you correctly you have a set of arrays that contain animal characteristics. And you are going to sort by one characteristics such a way that all arrays would be sorted. If so then you can write one common function for all arrays.
For example
Take into account that this swap function 
should not use an array of strings. It can be written like
",0,41091909
41088516,"
If you cannot use vector, one solution is:

Create an array with a lot of space (with a few empty positions at the end);
int * array = malloc(sizeof(int) * array_size);
Use two variables one to save the size of the array (lets called size) another to count the number of elements already added (lets called number_of_elements_in_the_array)

When you added an element at the position 'x', you do the following (with x < size of the array):
}
when you reach the limited, create a new array with more memory, copy from the old array to the new one, and update the variables number_of_elements_in_the_array and size accordingly.
Disclaimer : I didn't tested, thus it might be some minor erros, but the overall ideia is there.
",2,41088242
41088717,"
If you can use the C++ Standard Library, then std::vector is a replacement for arrays. It has a dedicated method insert to do what you want:
This is good if you know where to insert your new element. However, it seems that your list should always be sorted, and you want to insert the new element so it remains sorted. If so, you better use std::multiset:
Here, you don't need to tell where to insert the new element.
",5,41088242
41090299,"
Your test code has several issues.

The string you generate in ret is not null terminated so it will contain garbage from the stack which is likely to change with compiler settings. This the most likely cause of your strange results: the c++11 version sorting longer strings.
Your casts lead to strings which are all identical. Not an actual problem with measurements but probably not what you're interested in testing.
You should not use a truly random seed for benchmarking. You want to produce the same strings on every run to get reproducibility.

This fixed version of the code:
produces what I believe you were expecting:
By the way, g++ from Xcode on a mac is actually clang. But the results are similar:
Tested with g++ 6.2.1 and clang 3.9.0. The -std=c++03 switch is important as without it, g++ compiles in a mode which gives the fast times.
",2,41084230
41096636,"
Surely you can apply counting sort.
It is applicable to any field which can be mapped with integers. In general counting sort should be used if the range of values(in your case m_echeance) is small.
Below is high level approach to do that-
Let's say your objects are stored in array A[]
range of m_echeance is [0,R-1]

Make a count array.
loop through the array A to count frequencies of the objects with different m_echeance values.

something like count[A[i]->m_echeance + 1]++;

Get the cumulative frequencies for the count array.
Copy objects in auxiliary array  based on cumulative frequencies.
Copy back objects from auxiliary array to original array.

Hope it helps!
",0,41080661
41075450,"
Here are some mistakes you are doing in your code you shouldn't like.
Initialise str[] as
Otherwise you will get some warning related to C++ compiler version. 
First for loop should be
And last one, this code will not sort str[]. The output of you code(after obove modification) will something like this:
This is partially sorted. To fully sort this array you have to use two nested for loops same as bubble sort.
",0,41075133
41061737,"
http://en.cppreference.com/w/cpp/algorithm/sort

comparison function object (i.e. an object that satisfies the
  requirements of Compare) which returns ​true if the first argument is
  less than (i.e. is ordered before) the second.

Using such a function sort(v.begin(), v.end()); sorts ascending.
",1,41061658
41061715,"
Algorithm

Put all the height (increasing order) in a hash (say ordered map on STL) - key as height, data as frequency of that height.
For N/M times, get freq (say sum) and keep adding.
Result = N - sum.

Pseudo Code
",0,41060726
41033098,"
Your index i should start from the first element which is 0 instead of 1.
Fixing line 11 should do the job:
Edit:
Oh, and also, your variable j should start from the second element which is index 1 instead of 2: 
",-1,41033008
41016413,"
In the for-loop condition there is sense to check j value before comparing items:
",1,41012769
41009577,"
I don't have a specific answer, but these are some quick debugging tips:
1 - run the code through clang-format. If you don't/can't install it on your computer, there's online formatters available such as http://format.krzaq.cc/
2 - compile your code with the clang compiler with all the warnings turned on. Again if you don't/can't install clang on your computer there's a few online sandboxes to play with. Why Clang? They made a big effort to give it very nice warning/error messages.
I did both, and this is what clang had to say about the program (link here)
These might help - especially the last one!
",2,41008980
41016008,"
The shellsort is broken. It seems to be attempting to sort the gap sequence seq[] when it should be sorting the value sequence arr[]. Additionally the gap sequence should be a series of values. For example:
Shell sequence:
Knuth sequence:
Collectively the values of h at each call to hsort is your gap sequence. Alternately these can be precomputed and stored.

Testing the sequence for descending (or more accurately non-ascending) can be done with:
However, this test is insufficient for verifying algorithm correctness. Consider a function that simply sets all elements to a single value. The resultant sequence would pass this test. Visual inspection - while somewhat useful during debugging - is error prone and impossible for large sets.
A better solution is to allocate a duplicate array and sort it with a known good algorithm, then compare each element for equality.
",0,41008980
41050361,"
The stack overflow error is due to an infinite recursion ""loop"".
merge() needs two more parameters. In this example, I allocated from stack using _alloca(), so no free is needed. This will only work for arrays small enough to not overflow the stack. The alternative is to use malloc() and free().
The last while in sort() needs to use j instead of i:
Alternative approach - use a one time helper function to do a one time allocation of a second array the same size as a[], perhaps calling it b[], and use the same indexing for b[] as a[] when doing the splitting and merging. b[] would be passed as a parameter to both merge() and sort(), and would be used instead of left[] and right[].
The names are confusing, merge() is really a ""sort"", and sort() is really a ""merge"".
",0,40997871
40983117,"
The problem is that std::sort requires random access iterators, but std::list doesn't provide them; it only supports bidirectional iterators. That's why std::list has it's own sort member function. So instead of calling std::sort(l1.begin(), l1.end(), sortByAge) call l1.sort(sortByAge).
",1,40983021
40983131,"
std::sort accepts RandomAccessIterators
but std::list::iterator is a BidirectionalIterator.
Since you are sorting the entire list, you can use std::list::sort instead.
",1,40983021
40964187,"
The parameter max is never used. Normally the right index for mergesort is the ending index (one more than the last index in the vector). In merge(), setting h and i to low-1 will cause the out of range problem, set them both to low, not low -1. Since the merge copies back to list, then mergesort and merge should be void functions using reference for parameters:
The main code in mergesort should be:
In merge the early lines should be:
The other lines using <= should be changed to use <.
The initial call to merge sort should be:
You may want to use size_t for indices instead of int.
",0,40963806
40953249,"
Problem found on line 20, where you try to swap letters[i] with letters[max]. That line should be
",1,40953058
40943006,"
Change the Array function declaration to:
int* Array() and make it return the array Ar. And in main get the returned value from Array function like this:
int* Ar = Array(); 
and pass it to the function ISort like this : ISort(Ar);.
Here is an example on SO passing an array to a function.
",0,40942964
40943103,"
Ar in your Array function will be destroyed once this function finishes, you need to have a way to prevent this, one way is to pass an array by parameter instead of making it function local variable:
I would also change Your current ISort definition to:
where acount is number of elements in Ar. This is because it makes no difference whether you use void ISort(int Ar[1000]) or void ISort(int* Ar) (read here for more on this). If you want to preserve array type then you must pass it by reference using: void ISort(int (&Ar)[1000]).
Finally changes in main:
working code is here: http://coliru.stacked-crooked.com/a/678f581f802da85b
You also forgot to increment count inside your sorting loop.
",2,40942964
40943001,"
Your array int Ar[1000] variable inside an Array() function is a local variable. Make it a global variable by moving it out of the function scope:
You should also modify the Array() function to accept array as parameter as pointed out in the comments below. Please note that I am omitting the array size part as it seems the number of the elements is set to 1000:
in which case the above code would be:
",1,40942964
40943141,"
The easiest solution would be to change Array function a bit:
Hope that helps. Also there are many other solutions to this but I don't know what exact restrictions your task has. If you have any questions feel free to ask.
EDIT: So I totally forgot about that C arrays are just a plain old pointers... Well then the solution would be like this:
Sorry for the error but using C style arrays really isn't common in C++ when you can use vectors and maps.
",0,40942964
40932389,"
You have an index out of range problem.
This will not give you the solution, but it may help you to find the reason why your program fails.
I have modified your program so it uses a vector of int rather than a raw array of int, and when you run this program you get an index out of range exception.
The sequence 4 3 7 1 6 4 that triggers the problem  is hardcoded, so you don't need to type it each time.
",0,40927301
40933920,"
First of all, what you made is not quick sort, but some combination of divide-ans-conquer partitioning and insert sort.
Canonical quicksort goes from from lower (p) and upper (q) bounds of array, skipping elements arr[p]m respectively. Then it swaps arr[p] with arr[q], increments/decrements and checks if p>=q. Rinse and repeat until p>=q. Then make calls on sub-partitions. This way p or q holds pivot position and subcalls are obvious.
But you are doing it different way: you insert elements from right side of subarray to left side. Such thing can produce O(N^2) time complexity for one iteration. Consider 1,0,1,0,1,0,1,0,1,0,1,0,... sequence, for example. This can increase worst case complexity over O(N^2).
Out of time complexity... The problem in your function lies in assumption that j holds pivot location in subcalls:
Actually, j is set again and again equal to i in your main for loop. If last element is equal or greater than pivot, you end up with j=n-1, the you call qsort(arr, n, n) and first lines check is passed (sic!), because n-n != 1.
To fix this you should do two things:
1) find pivot location directly after rearrange:
or initialize it in different variable, update after this line:
and update recursive calls to use new variable instead of j
2) make a more bulletproof check in the beginning of your function:
the latter will be enough to get some result, but it will be much less effective than your current idea, falling down to probably O(N^3) in worst case.
",0,40927301
40942048,"
You seem to be re-ordering the output at the same time as you're reading the input. I think you should parse the input into a set of rules, process the rules a bit, then re-order the output at the end.

What are the constraints of the problem? If the input says that 0 goes before 1:
does it also guarantee that it will say that 1 comes after 0?
If so you can forget about the 2s and look only at the 1s:

From reading the input I would store a list of rules. I'd use std::vector<std::pair<int,int>> for this. It has the nice feature that yourPair.first comes before yourPair.second :)
You can discard any rules where the second value is never the first value of a different rule.
This list would then need to be sorted so that ""... before x"" and ""x before ..."" are guaranteed to be in that order.
Then move 6, 0, and 2 to the front of the list 0123456, giving you 6021345.
Does that help?
",0,40919970
40920789,"
Thanks for the suggestion.
As suggested, only ones 1 are important in 2D array. I used them to create vector of directed edges and then I implemented Topological Sort. I decide to use this Topological Sorting Algorithm. It is basically Topological Sort, but it also checks for the cycle.
This successfully solved my problem.
",0,40919970
40889286,"
A simple typo: the function is declared and implemented as BuubleSort_Function.
You attempt to call it using BubbleSort_Function.
The compiler error messages are very helpful. Do learn to interpret them.
(Finally, standard C++ requires you to mark main() as returning an int - a C++ compiler will insert an implicit return 0 into main if it's missing. Some compilers - especially ones for embedded systems - drop this requirement but that is a deviation from the standard.).
",3,40889245
40889358,"
Defination - BuubleSort_Function
Caller - BubbleSort_Function
",1,40889245
40889409,"
Compare the 5th line and the 7th line with the 64th line,and you will find what the problem is.Just a simple typo.
",1,40889245
40877758,"
In order to compare two pair of numbers, you can make comparisons like:
Or you can use one expression: expr = suratno * 10000 + ayatno. And make just one comparison:
Also, I have a few observations about your algorithm/code:

Don't use using namespace std. Specially in big programs, because it can cause obscure bugs (see an example here). Instead use using std::<name> when you want to avoid std::. Ex. using std::string. In general, avoid using namespace xxxx.
I see you did parse the input lines manually, I prefer to use regular expressions, that are much more versatile and powerful, but requires a little learning.
When it's necessary to write an error message, always write to stderr stream cerr in C++.
In the sort algorithm, it's better start in 1 than 0, because the first item doesn't have a previous item to compare with.
Finally the swap can be done with an existent C++ function.

Here is your code reorganized and using regular expressions that I tried to explain as much as possible:
Note: The regular expression is really one string ""\\d+\\. (.*\\((\\d+):(\\d+)\\))"", I used a C/C++ feature that concatenates strings separated by spaces before compilation, so the compiler sees only one string.
Don't forget to compile with -std=c++11 option.
",0,40865531
40879104,"
using namespace std; is considered bad practice and can be dangerous sometimes. Check this
Here is your solution:
",0,40865531
40827025,"
Rewrite cmpr() as
Or, you may also reuse cmpre() to implement cmpr().
",3,40826904
40826768,"
It will be ascending , you'll always pop the smallest element of the queue. A priority queue sorts in reverse to the order relation it is given.
The default template definition looks like this:
It applies less<>()(lhs, rhs) to get the ""biggest"" rhs element. But in your case, it will apply greater<>()(lhs, rhs) to get the ""biggest"" rhs element (which will of course be the smallest).
std::sort, on the other hand, preserves the order type you give it. So std::less will sort in ascending order, and std::greater in descending order.
",4,40826745
40826772,"
std::greater<int> inverses the sort-order of integers.
std::priority_queue dequeues the next largest element by default, so by using std::greater<int> you're inverting this so it dequeues the next smallest element instead.
Similarly, std::sort will sort elements in ascending order by default, but by using std::greater<int> you'll see a descending sort-order.
",1,40826745
40824349,"
I think you forgot to include <algorithm>
Add #include <algorithm> and see if it works.
",1,40824229
40823853,"
I've come up with this:
It seems that it works. However, I wonder is there a better way to do it?
",0,40822031
40824492,"
If a node is inserted before head, then then the last node's next pointer is not updated to point to the new head node, and the code currently doesn't have an easy way to find the last node in the list.
The usual way to handle this is also have tail pointer (pointer to the last node). Since this is a circular list, you only need to maintain a tail pointer for the class, since head can be created at anytime using head = tail->next;
Optional: add_node can be updated to handle an empty list, eliminating the need for create_node.
",0,40822031
40805046,"

1-how do u make a recursive function that is a void i mean shouldnt a recursive function always return the last step then what is before it .. it's a void so how would it preform the task 

A function can have side effects. It means, that a function can modify the state of the program. A void function always works by side effects. A void function that doesn't have side effects is completely useless. Whether the function is recursive makes no difference to this question.

2-merg_sor() was called twice in one function .. do u call that nested recursion ?or what ?? 

I'm not sure if it is commonly used term, but I would describe it as multi-branched recursion.

2 .. and how does it affect the merg function

It doesn't, because it has no side effects.

i did exactly what the pseudo code told me

Perhaps you didn't interpret the pseudo code correctly. Perhaps the arguments are implicitly references in the pseudo-language that you're reading such as they are in languages like python.
",0,40804497
40773810,"
The code is correct overall with a simple error. You are printing the output in one of the recursive steps and hence are getting the intermediate results mixed with the answer.
Removing the cout in the merge function and moving it out to a main function will do the trick:
Output:
",0,40771108
40771094,"
So there are a few problems in your code:
You had defined int a and then you assigned to it first item of your array. I guess this is not what you wanted, because at the end of code I've cited You pass pointer to a variable into sorting function. You probably wanted to pass pointer to array to sorting function. Also you use your a variable in for and you completly change its initial value.
Here above there also a few problems:

b actually never changes, so comparing it in in for loop for sorting is a little bit pointless.
you use table's element as iterator in your loop. Not good.
your sorting algoritm seems to be bubnle sort, but lacks of one extra for loop.

Below I attach my version of your program which does a little bit better than your implementation. ptr_sort is not finished - as I seed you need extra for.
Compare it with your work and ask if You have any doubts.
",1,40770771
40766335,"
First, if you allocate memory with operator new, you must release it with operator delete[]. 
Second, when you sort strings instead of values, they are sorted just like strings would do, and here is where your problem lies. You see, 100 is alphabetically less than 2 or 20, that's why it would appear earlier.
Here's the output your program gives. Check this rule out, and you'll see that i'm right.
Third, using operator new is discouraged for pretty much anything. You have STL, and you seem to be using it extensively - why not vector?
Fourth, you don't check if anything we write into numbers[i] is actually a number. Think on that.
Fifth, for N being long enough(more than 2^sizeof(size_t)) your problem will NEVER stop due to integer overflow.
Sixth, you don't check for n == 0, and you will ultimately get memory access violation if you enter it.
A fast-right-off-the-bat fix for your problem:
Still, it has a number of problems:

Checking if numbers[i] is actually a number 
I'm not sure that
predicate I wrote doesn't have bugs - I'm just trying to give you
the idea of how it should work.

",2,40765131
40760530,"
So when you have something like this: 
The list will look like: [1,2,4]
You should provide us your code to get an answer that is more detailed for your problem
",-2,40760369
40751780,"
You could use std::lower_bound like so:
",1,40750825
40730854,"
you can simply use the std::sort function to sort the vector:
",0,40730549
40730724,"
As Slava pointed out in the comments, I needed to pass the vector by reference to my functions. Before I was just editing a local copy of the vector.
Thanks Slava!
",0,40730549
42005071,"
Your code is attempting to take a non-const reference to a const object, which is not permitted. The compare function doesnt modify its arguments so change: 
bool AssemblyObject::compare(AssemblyObject &a, AssemblyObject &b){
To
bool AssemblyObject::compare(const AssemblyObject &a, const AssemblyObject &b){
",4,42004938
42004969,"
The error is pretty clear - you need compare to accept const lvalue-references, not mutable ones:
",3,42004938
41992253,"
A precondition of using std::merge is that both lists are already sorted. So yes, it takes advantage of this.

Merges two sorted ranges [first1, last1) and [first2, last2) into one sorted range beginning at d_first. 

",3,41992207
41992244,"
std::merge requires that the two input lists be sorted, so it does take advantage of this. There is no need to build your own.
From the standard (N3242 §25.4.4.2):

Requires: The ranges [first1,last1) and [first2,last2) shall be sorted with respect to operator<
  or comp. The resulting range shall not overlap with either of the original ranges.

",1,41992207
41992333,"
For starters the standard container std::list has member functions merge that accept a comparison function object. They are
So you can use them.
Thus you have a choice either to use the standard algorithm std::merge or to use these member functions of the std::list.
Take into account that you should use the same comparison function sort_func() that was used to sort the lists if you want that the result list would be also ordered according to this function.
Here is a demonstrative program that shows how the task can be done using only native methods of the class std::list. Instead of your comparison function there is used function object std::greater declared in header <functional>
The program output is
",0,41992207
41991142,"
The main issue with your code, is that when 1 word needs to be swapped with another, you do not swap the two words in the array. Instead you swap just the characters of the first word, which are larger than the characters of the second word. This creates a jumbled mess.
For example, when you try to Swap the following two rows
Your end result is:
Another problem include missing a comma between ""John"" and ""Hats"", resulting in only 9 entries in the array, one of them being ""JohnHats"". 
Lastly, your bubble sort needs to use different indices in your loops to preserve the already sorted elements.
Using helper functions helps make this more clear. Here's an example solution close to what you originally wrote but with helper functions.
",1,41990511
41991001,"
To make the code more readable, let's define a swap method:
A comparison function may make the code more readable:  
A bubble sort works by swapping items, in your case, names.  
",0,41990511
41990956,"
First you have a UB in your code: 
""John"" ""Hats"": missing a comma will cause a great disaster.
You can use class string easily instead of an array of constant strings so you need only to compare the first letter of each word in the array and swap if the condition is true:

If you want a full comparison which means compare the first letter of the two words and if they equal then compare the seconds and so on you need some extra work or use some facilities of some classes.

",0,41990511
42262989,"
Bubble sort is a poor sorting algorithm.
But it does have one advantage, which is that it can easily sort data you don't hold in memory, as long as you can hold a temporary.
One each pass load the first two data items. Then save the lower one back to the file, and keep hold of the higher. Continue loading in one by one and saving the lower. Finally save the higher. 
You don't need random access to the data, though you do need to be able to pass through it at will.
",0,41990511
41970370,"
The simplest optimization idea here is to read an array once and then reuse it:
and then somewhere
",2,41959214
41956975,"
Digits, when considered as characters, are handled the same as alphabetical characters. (i.e. they have a relative lexicographical order, which is the same as their ordering based on ascending value)
In effect, when you're handling integers as string,s you may consider digits 0,1,2,3,4,5,6,7,8,9 to be letters 'a','b','c','d','e','f','g','h','i','j'. Consequently, sorting the input can be thought of as sorting strings.
Your original input;
can then be considered as;
for which the appropriate ordering would be;
If you switch back the values, you may see that this is the output you provided in your question, namely;
",2,41956378
41956426,"
That is just how default lexicographical string comparison works.
What you are probably looking for is called natural sort:

Natural order means sorting strings so that embedded numbers are treated as numbers. This means that if you use natural order for sorting you get this:
Instead of the default sort behaviour:

",1,41956378
41960042,"
Reading a list of numbers, sorting them and then printing them out is extremely easy in C++ once you know the ""secret"".
The ""secret"" is to use the functionality that exist in the standard library. In this case (reading numbers, sorting them, printing them out) you need to know about std::vector, std::istream_iterator, std::sort, std::copy and std::ostream_iterator.
Then you could do something like
",0,41956378
41944326,"
Your operator is correctly defined, but it is not the operator you are looking for. You want to define the operator <, then use std::sort.
",2,41944273
41941500,"
You just cannot sort the graph the way you want using std::sort().
If I understand correctly, mygraph[u] contains {v,w} pairs such that there is an edge from u to v of weight w. You want to sort the edge list by weight for Kruskal. But you simply cannot do this with the structure proposed!
std::sort() on mygraph will reorder the rows of your adjacency list without ordering the edges within a row. And there is no natural way to order the rows themselves because the smallest edges might be in different rows.
For example, consider two rows of the vector like this:
Now you want the {2,2} edge to come between the other two edges in sorted order but this is impossible if you just sort the vector.
You are hence forced to flatten the vector so that you have a 1D vector of edges (of the form {w,{u,v}} the way Halim has) which you can sort.
",3,41936073
41917966,"
The primary point to mention here is that, once you've found a match, you need to break; out of the inner loop. 
Also, you need to make sure to print either ""yes"" or ""no"". As your program currently stands, it will unconditionally print ""no"" after the inner loop. You can make use of a flag to accomplish that.
Finally, as your logic states, ""....of element of second array is present in first array"", you need to change the loop structure to reflect that. The outer loop should be used to index the second array b whereas, in the inner loop, you should be traversing the first array a.
You need to do something like (pseudo code, not tested)
",3,41917942
41918021,"
Per your stated goal in your question, you should be enumerating your second array (b[]) as your outer loop, hunting for each of its values within your first array (a[]) as the inner loop, and most importantly, breaking the loop with detection (code outside the inner loop knows you broke early) if you found a match and thus know whether Yes or NO should be printed
In short, your algorithm is backwards and still not complete. Fixing the algorithm and using ranged-for as the enumeration method (use it or use subscripting like you are now, up to you), gives us:
Output
",2,41917942
41919001,"
The whys of your broken algorithm have been already given by the other answers. I would like to give you a hint that can help to improve it in terms of time of execution (once fixed, of course).
Note that two nested loops means a complexity of O(N*M), where N is the length of a and M is the length of B.
For you are working with integers, if you can accept to spend a few bytes of space (O(N)) for a set, you can reduce the complexity to O(N+M).
Moreover, the whole code seems to me even easier to understand:
The basic idea is this:

Iterate over a and put all the values in your set
Iterate over b and check if the set contains the _i-th_value

The second step doesn't require anymore to iterate over a for each value in b. Therefore the overall complexity is reduced (in the average case at least - see the documentation of std::unordered_set for further details).
",2,41917942
41918130,"
A more C++ way to do it would be to use std::find (C++11 inside):
",1,41917942
41918080,"
I did change in your program and it gives the expected output.
",0,41917942
41910954,"
Make a vector of std::pair<int,char> instead. Since operator < on the pair compares first and decides ties on the second, sorting std::vector<std::pair<int,char>> will produce the exact effect that you want:
Demo.
",3,41910924
41910961,"
You can do something like this:-
The sort function by default sorts according to first value but you can always define according to which criteria should the sort work 

C++ STL - How does the third argument of the STL sort() work?

",2,41910924
41926317,"
Try the following. 
The way it works is to sort the position key pair based on the int vector value only and then use this ordering to extract values. 
",0,41910924
41859978,"
This is a call to the standard sorting function std::sort. We pass the begin and end iterators(pointers, in this case) to the range we with to sort, and a third argument which is a function object that returns true its first argument is strictly less (in terms of the strict weak ordering we want to sort according to) than the second argument and false otherwise. The part that starts with [] is called a lambda-expression: in other languages similar objects can be known as anonymous functions. It was introduced in C++11.
",4,41859926
41861675,"
With range-v3, you can simply do (with projection):
Demo
",0,41859926
41829810,"
With range-v3, you may do:
Demo
",6,41829450
41829693,"
Not so efficient but a working solution would be:
",1,41829450
41829730,"
This can be implemented by calling std::sort with a custom iterator, that skips indices and with a custom comparison fucnction, that compares the adjacent value if current comparison is equal.
The custom iterator can be built on top of the existing iterator. A construct like that is called an iterator adaptor. You don't need to write such iterator adaptor from scratch yourself, since boost has already done the hard work. You can use boost::adaptors::strided. If you cannot use boost, then you can re-implement it.

Much simpler solution would be to use pairs, though. Or better yet, a structure if there are sensible names for the members.
",1,41829450
41831484,"
Not the fastest sorting algorithm but it works:
[On Coliru]
",0,41829450
41821627,"
You can add state to your comparator:
",3,41821551
41807766,"
In addition to the comment by Igor Tandetnik, your calculations for left and right child are wrong. In a vector with index 0 being the first item, the root of your heap is at index 0. So the calculations for left and right child are:
The calculations you have are for a heap with the root at index 1.
Also, the loop in your Build_Max_Heap function needs to be:
That is, you must check to see if the first item in the vector needs to be rearranged.
",0,41796938
41795012,"
All the indexing that you're doing on your vectors is 1-based.  C++ vectors (and arrays) use 0-based indexing.  At the very least, x and y should be initialized to 0, the indexing in the i and j population loops should start at 0 (with appropriate changes to the end condition and usage within the loop), and the second parameter in the call to mergeSort in main should be 0, not 1.
",0,41794495
41787036,"
Pass 1
In your (original) partition code, you had:
You're only supposed to access a[start] to a[end], but you start off with the first iteration of the loop accessing outside theses bounds.  This is bound to be part of the problem.
The fix isn't necessarily so obvious.  It's tempting to just drop the subtraction and addition, but that's not necessarily correct.  One of the key things is getting enough useful diagnostic printing in place to know what's going on.
Pass 2
The pseudo-code has been added and fixed since Pass 1.  The pseudo-code is very similar to what's presented at Wikipedia under QuickSort.  It is a minor variation on the theme of the 'Hoare Partitioning' — the variation being the use of repeat … until in the question versus do … while at Wikipedia.


Your current version of the partition code is:
There are a number of key differences:

You are using the last element instead of the first as the pivot.
You are not looping at all while incrementing i and decrementing j.

Fixing those problems leads to code like this:
There are lots of commented-out printing functions, which were used at times to reassure me that things were working as intended.
Your main quicksort function was OK, though it got decorated with (lots of) printing too:
The dump_data() function looks like:
And the test code (main()) looks like:
The check_sorted() function doesn't usually say anything (but it did when used on unsorted data):
There are various sets of 20 random numbers in the range 0..9 in the main() program.

Careful re-readingfor the Nth time of the Wikipedia page shows:

Partitioning: reorder the array so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way).

A previous version of this tail-end commentary was concerned about a pivot value sometimes appearing in the lower half of the partition data, but noted that the sort worked anyway.  The quotation shows that is perfectly permissible — there isn't a problem.  There are partitioning schemes, such as fat pivot schemes, where that would not be true.
",4,41786918
41785285,"
The most direct answer to your question is yes, it is insertion sort. It is a very inefficient insertion sort, but it nonetheless insertion sort.
Your code lacks the conclusive step of knowing that, once the location of an element is determined, comparisons can stop and a shift operation on the sorted sequence ensues to make a hole for the new element. Rather, you rely on your comparison loop to perform that shift for you, even when comparisons are no longer needed, which is not very efficient.
That probably seemed a little confusing, so I'll elaborate against your code. 

Your prospect element for each iteration of i is initially a[i].
You enumerate linearly over the already-sorted part of your sequence, looking for where a[i] belongs
Once you find the location (unless it is already where it belongs), you swap a[i] with the element a[j] that currently resides in your target.
From that point on, the original value of a[i] is now in-place in the sequence, but...
For the remainder of the sorted sequence, the swap-comparison is guaranteed to fire as true (hint: so why do it?) against whatever value is stored in a[i] because the values that previously succeeded it were already sorted. Therefore, a[i] is constantly replaced with the next value in the sorted sequence until it eventually holds the largest value, which is by-definition where it belongs.

Therefore, yes, this is insertion-sort. It maintains a sorted sequence at the beginning of the whole that ever-expands with each primary iteration. And for each primary iteration the prospect element is ""inserted"" and the trailing elements are shifted down to make the available hole to do that.

... are the number of comparisons or swaps more/less with this kinda approach?

Considerably more comparisons required with your approach. Each iteration is guaranteed a linear O(n) complexity, and there are n iterations. Therefore, you're guaranteed to have O(N^2) complexity for your comparisons, which is the plague of efficient sorting algorithms. Not just worst-case; guaranteed.

A C++ Insertion Sort
That said, consider this
That probably seems like Greek (no offense to the Greeks) if you just starting out in C++, but is utilizes two fundamental algorithms that make it surprisingly efficient: std::upper_bound and std::rotate.
std::upper_bound operates on a sorted sequence. Taking advantage of that, it can utilize a binary search algorithm to locate the first element in the sorted sequence that is strictly greater than the prospect value (*it). Therefore, searching for the insertion point for a single prospect is O(logN), far better than a linear search of O(n).
Once the insertion point is known, std::rotate is used to put the element in place by using the iterator of the insertion point. It effectively does this:
Note that rotation requires no comparisons. 
Obviously this template solution isn't something someone will be submitting for some remedial algorithms course. But I hope it gives you some ideas on how insertion-sort can have its comparisons minimised by:

Using binary search on the already-sorted part of the sequence to minimize comparisons.
Use no comparisons when performing the rotation.

Best of luck.
",3,41784725
41785101,"
This code is an insertion-sort implementation. Take a look at the inner loop:
Or simplified:
Now we know that the subarray a[0:i - 1] is already sorted from the previous run of the outer loop. This is a logically golfed version of finding the index n at which we need to insert a[i] and pushing all elements with index in  the range [n, i - 1] one index higher:
The logical equivalence to these two snippets of code is the following:
Up to the searched index n (insertion-index for a[i]), no swaps will occur. Now we swap out a[i] and a[n]. From that point on a[i] would be equivalent to the tmp-variable in the above code. Since the rest of the array is still sorted up index i - 1, we now swap out every element against it's previous element, which is currently stored at index i. Definitely some nicely golfed insertion-sort.
The outer loop is just the standard 
",3,41784725
41781625,"
Passing permutationComparator as the third parameter of std::sort is not valid. Only static class members is valid and functor objects. To resolve the issue, here's four choices:

Create a closure object using lambda expression and do your comparison there.

You can use std::bind, if your comparsion function needs not to be static.

Make your comparison function static, if it's possible.
Overload bool operator () ( const int *i1, const int *i2 ) in your class in order that your class to be a functor object.

Note that logically a comparison function should not to be a member function. It is a function that takes two objects and determines their orders. So, almost in all cases, only the third option applies.
",0,41781504
41778919,"
Create a function which transposes the vector, so it should modify {{3, 5, 1}, {4, 8, 6}, {7, 2, 9}} into {{3,4,7},{5,8,2},{1,6,9}}. Transpose the vector with your function, then sort the vector with custom comparator comparing the second elements of rows. Then call the transpose function again.
The transpose function could look like
Then the entire code would be
If a vector is square then the transposition can be done in place making the solution much more effective then this general one.
",2,41778699
41779136,"
The structure of question won't allow us to use built-in sort function. Because, custom sort will only provides ""rows"". And you can compare ""rows"" only.
But there are some alternative ways to accomplish that. 
For example you can do that by transposing vector of vector. 
""Transpose > Sort by column > Transpose"" may solve your problem.
But my solution is based on another dynamic. 

Sort nth column and keep indexes as array. (n is the position of ordered row)
Using the array defined at step 1, sort all rows one by one.

http://cpp.sh/4dkzg
http://www.geeksforgeeks.org/reorder-a-array-according-to-given-indexes/ (if you want to apply in-place sorting, there are some fixes)
",1,41778699
41779070,"
You could make an std::vector of std::pair<int,int> where in the first variable of the i-th element of the vector you have the i-th value of the second row while in the second variable you have the value of the index i.
Then you sort that vector based on the first values of the pairs. That way you can make a new 2D vector where in every row you order the elements based on the second value of the pairs, which are the old indices.   
You have to #include <utility>. 
",0,41778699
41779320,"
This code is very dirty. but exactly is the same code you want.
",0,41778699
41760932,"
Try this : corrected-code
",2,41760341
41760466,"
When you define min, you seem to be assigning it the value of the array sort at jth index. Yet, you are using an extra variable tmp to swap the elements, and you seem to fail to initialize it before the inner for loop, similar to how you initialize min. And if all the other elements in the array are smaller than the element at sort[j], tmp will be uninitialized for that iteration of the outer loop, possibly causing it to have an incorrect value in it.
You may see this code at work here. It seems to produce the desired output.
",4,41760341
41760818,"
If you can use C++11, you can also solve sorting (as in your example) with lambdas. It's a more powerful and optimized way. You should try it maybe in the future.
[EDITED]:
A short example:
",-2,41760341
41724700,"
The way the standard library generally deals with this problem is to allow users to specify their own compare functions. You can add a templated parameter that users of your type can use to provide a Compare function, like std::sort does. In the implementation of sort, you assume that comparer is a function that compares two elements of the list and returns rather or not the first should be before the second.
",1,41724506
41711048,"
comp is a binary function that accepts two elements in the range as arguments, and returns a value convertible to bool. The value returned indicates whether the element passed as first argument is considered to go before the second in the specific strict weak ordering it defines.
You can refer to cplusplus
",2,41710997
41714432,"

Why if I use the following comp function, the sort function makes the vector inversed?
bool comp (int i, int j) { 
      return true; 
  }

Ideally the above code should not compile because you are not making use of the arguments passed to comp function.
Coming to your question, the third argument in std::sort provides a way to supply custom comparator so that the supplied comparator will be called to compare elements of the vector while sorting.
When the above is used, the comparator returns true only when the first item is greater than the second item. When the comparator returns true, the sort function takes action to place the element i before element j. Hence you see the vector sorted in decreasing order.
",-1,41710997
41659342,"
The array of counts was converted in to an array of ending indices, point one past the end of each logical bucket, so 1 is subtracted from each index. This could be combined to use pre-decrement, and the array scanned backwards:
Getting back to the counts after they are summed up, note that count[0] contains a count of all the elements equal to zero, and count[1] contains a count of all elements == zero and all elements == 1, and so on, so count[0] is the logical size of the bucket that will contain the zeroes, and the size is 1 greater than the index to the last element. The same logic applies to count[1] and so on.
Example code where the counts are converted into starting indices. output[] converted to use new (to avoid stack overflow and some compilers don't support variable length arrays). count[10] assumes the range of numbers is limited to 0 through 9.
",4,41658822
41651709,"
This question will probably get closed down as ""off topic"". However,
First question: does the server ever need a sorted scoreboard?
If not, why do the work?
If anything, the server will want to index the scoreboard by player ID, which argues for either sorting by ID (to aid binary searches) or using a hashed container (O1 search time).
Furthermore, the ultimate bottleneck is network bandwidth. You'll eventually want to be in a position to send scoreboard deltas rather than state-of-the-world messages.
This further argues for making the clients do the work of resorting. 
There is one more philosophical argument:
Is sorting by anything other than a primary key a data concern or a presentation concern? It's a presentation concern. 
What does presentation? A client.
QED
",1,41651634
41626934,"
Similar to the C++ approach above, there is a library function in the C standard library called qsort. It is based upon a comparision function, that creates the ordering on the array members.
For your case a minimal example could look like this:
Note the comment about comparing floating point values.
If you are using Linux, you can investigate system calls and functions of the C standard library by looking up the corresponding man page, e.g.

man qsort

",1,41626700
41626777,"
For example you ll have 
Now you want sort this using sort from STL 
You first must create method for operator  "" < "" 
I hope this helps you I m sorry for my bad grammar :)
Example of usage
Now your vector of person will be sorted upside - down  order.
",0,41626700
41624499,"
When you're sorting the points by their relative angles, you don't need to know the exact angle the two points make. Rather, you just need to know whether one point is to the left or to the right of the other.
Image, for example, you want to compare two points (x1, y1) and (x2, y2), assuming that the bottommost point is at (xp, yp). Look at the two vectors v1 = (x1 - xp, y1 - yp) and v2 = (x2 - xp, y2 - yp). To determine whether v1 is to the left or to the right of v2, which means you want to look at the sign of the angle made going from v1 to v2. If it's positive, then v2 is on the left of v1, and if it's negative, then v1 is on the left of v2.
The 2D cross product has the nice property that

v1 × v2 = |v1| |v2| sin(θ)

where θ is the angle made by going from v1 to v2. This means that θ > 0 if v1 is to the right of v2 and vice-versa, which is nice because that lets you compare which one goes where purely by taking a cross product!
In other words:

If v1 × v2 > 0, then v2 is to the left of v1.
If v1 × v2 = 0, then the points are collinear.
If v1 × v2 < 0, then v2 is to the right of v1.

The 2D cross product formula is given by

(Δx1, Δy1) × (Δx2, Δy2) = (Δx1 Δy2 - Δx2 Δy1)

Where, here, Δx1 represents x1 - xp, etc.
So you could compute the above quantity, then look at its sign to determine how the two points relate to one another. No square roots needed!
",3,41623829
41632800,"
You can make ad hoc optimization through caching.
First, Length() can cache its result in member variable. You only need to invalidate this value in case point is changed (and probably it's not the case). You can make lazy calculation, so Length will check if it has value and calculate/store if it doesn't, then return stored value.
Second, for given minElement and xAxis, angle (minElement - a, XAxis) becomes function of 1 argument, so you can save (cache) values of it for each point before sorting and use comparator on prepared values.
Naive approach to these things: use subclass of Point in main algo, so every point already has necessary methods and place for cached values.
",0,41623829
41629053,"
In case your Integers are more or less random 1), most comparisons only need to compare the first few integers of each vector (until the first mismatch), so in practice / on average
M (counterintuitively) doesn't have any effect on the algorithmic complexity 
To give you some Idea: Even, if your vectors have infinite length and the most frequently occurring integer has a probability p of 50%, you need less than 2 comparisons on average:
For other probabilities the results are:
Keep in mind that all those numbers are upper bounds for the average number of integer comparisons and independent of the number of elements in the vector
1) By random I don't mean random in a cryptographic sense. The numbers don't even have to pass most quality tests for random numbers. The only requirement is that they don't form the same prefix - which grows with the length of a vector - in a systematic manner.
Except for malicious input I can't currently think of a realistic example that would not qualify as ""more or less random"", but there is probably something else.
",2,41623824
41624235,"
There isn't enough information.  You also need to know the distribution of the M values across the N vectors.  When you have that, then it's straight forward to find the overall complexity:

std::sort has a complexity of O(N·log(N)) comparisons.
std::vector uses std::lexicographical_compare(v1, v2) for comparison, which has a complexity of O(min(v1.size(), v2.size())) comparisons.
int comparison has a complexity of O(1).
We'll let E(M, N) be a function on M, N that returns the mean number of minimum elements between every pair of inner vectors.  

For example, if you have a uniform distribution, this is
trivially equal to M/N.

Take the product: 
Big Oh = N·log(N)·E(M, N)·1.  


For a uniform distribution, this would be M·log(N).


You can use Discrete Probability Distribution theory to figure out what the E(M, N) function is for any distribution of M across N.

Edit 1: To drive the point of how/why this matters: Consider a distribution that always makes my vectors look like:
In this case, E(M, N) = 1, because std::lexicographical_compare will only ever have one other element to compare to for any pair of elements.  Thus, for this particular distribution, I will always have a complexity of O(N·log(N)).  But with a uniform distribution, I'll have O(M·log(N)).

Edit 2: Following the comment where you define your distribution, let's try and find the E(M, N).
First, notice that there are in total T = (N choose 2) = N(N - 1)(1/2) different combinations of vector comparisons.
One (and only one) combination will take X = O((M - N + 2)(1/2)) comparisons, and has probability P(X) = 1/T to occur.
Every other combination will require just  1 comparison (O(1)), and so those cases occur with probability P(1) = (T - 1)/T.
Finding the mean is simple: X·P(X) + 1·P(1).
Given this, WolframAlpha says: E(M, N) = (M + (N - 2) N)/((N - 1) N).  
Multiplying that function by N log(N) gives us (M + (N - 2) N) log(N) / (N - 1), which can be further simplified to the Big Oh you're looking for: O((M/N + N) log(N)).
",2,41623824
41610957,"
You should add guard for out of range access. Most probably the error you see is caused by matrix[i][i+1] when i + 1 is out of bounds for matrix[i]. I believe this should be a fixed version of the code.
",2,41609713
41586166,"
Assuming your array (arr) is a container of std::string, and that you want to prioritize the numerical sorting (i.e. C1 < A3), you can do it using a single call to std::sort (I am using a c++11 lambda here but you could use a custom Comparator if you need):
I am not converting the second char to an int since the standard guarantees '0' < '1' < ... < '9', but this assumes that you have only numbers between 0 and 9.
If you want to prioritize the sorting on the first character, you simply have to do a standard std::sort:
",1,41586024
41582273,"
To avoid stack overflow, the code needs to compare partition sizes, (wall - start) versus (end - wall), recurse on the smaller partition, and loop back for the larger partition. It's not really tail recursion. Something like this:
If using a Hoare type partition scheme, wall or wall+1 may point to the pivot value. You can add a check in partition so that the returned index always points to the pivot value (instead of sometimes pointing to 1 before pivot value).
",1,41580660
41580391,"
The first thing I see, you're passing a std::function<> which involves a virtual call, one of the most expensive calling strategies. Give it a try with simply a template T (which might be a function) - the result will be direct function calls.
Second thing, never do this result-in-local-container (vector<int> sorted;) when optimizing and when in-place variant exists. Do in-place sort. Client should be aware of you shorting their vector; if they wish, they can make a copy in advance. You take non-const reference for a reason. [1]
Third, there's a cost associated with rand() and it's far from negligible. Unless you're sure you need the randomized variant of quicksort() (and its benefits regarding 'no too bad sequence'), use just the first element as pivot. Or the middle.
Use std::swap() to swap two elements. Chances are, it gets translated to xchg (on x86 / x64) or an equivalent, which is hard to beat. Whether the optimizer identifies your intend to swap at these places without being explicit could be verified from assembly output.
The way you found the median of three elements is full of conditional moves / branches. It's simply nums[a] + nums[b] + nums[c] - max - min; but getting nums[...], min and max at the same time could also be optimized further.
Avoid i++ when aiming at speed. While most optimizers will usually create good code, there's a small chance that it's suboptimal. Be explicit when optimizing (++i after the swap), but _only_when_optimizing_.
But the most important one: valgrind/callgrind/kcachegrind. Profile, profile, profile. Only optimize what's really slow.
[1] There's an exception to this rule: const containers that you build from non-const ones. These are usually in-house types and are shared across multiple threads, hence it's better to keep them const & copy when modification is needed. In this case, you'll allocate a new container (either const or not) in your function, but you'll probably keep const one for users' convenience on API.
",2,41579949
41582458,"
For quick sort, use Hoare like partition scheme.
http://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme
Median of 3 only needs 3 if / swap statements (effectively a bubble sort). No need for min or max check.
For merge sort, use an entry function that does a one time creation of a working vector, then pass that vector by reference to the actual merge sort function. For top down merge sort, the indices determine the start, middle, and end of each sub-vector.
If using top down merge sort, the code can avoid copying data by alternating the direction of merge depending on the level of recursion. This can be done using two mutually recursive functions, the first one where the result ends up in the original vector, the second one where the result ends up in the working vector. The first one calls the second one twice, then merges from the working vector back to the original vector, and vice versa for the second one. For the second one, if the size == 1, then it needs to copy 1 element from the original vector to the working vector. An alternative to two functions is to pass a boolean for which direction to merge.
If using bottom up merge sort (which will be a bit faster), then each pass swaps vectors. The number of passes needed is determined up front and in the case of an odd number of passes, the first pass swaps in place, so that the data ends up in the original vector after all merge passes are done.
",0,41579949
41526753,"
Sorting a container, you need a function that compare couples of element contained in the container.
So, sorting a std::vector<std::vector<int>>, you need a function that receive a couples of std::vector<int>.
But your compare() receive a couple of std::vector<std::vector<int>>.
That is wrong.
Off Topic: your compare() function (IMHO) is very dangerous because access to the second element of both vector without checking if they contain at least two elements.
I think you should, at least, use at() instead operator[]; just to perform a bound cecking and, in case, obtain a catchable exception; something like
--- EDIT ---
The OP ask

how do I sort it based on an index that is decided in runtime?

Decided how? And where?
Suppose that is decided outside compare() (in the function that call std::sort(), by example), you can use a lambda function.
An example
",1,41526640
41526621,"
First, your array is declared incorrectly (the sample code below shows the correct declaration).
Second, I would recommend leaving the first row alone, and only sort the second row of indices.  Since the second row is being used as the indexer, there is no need to sort the first row.
Third, using qsort in a C++ is not recommended.  

qsort is not typesafe.  You have to cast void pointers to the types that you are sorting with qsort.  If the cast is done incorrectly, then your program has runtime issues.
qsort cannot be used on non-POD types (anything that isn't C compatible).  
C++ compiler optimizers do a much better job optimizing for speed std::sort than qsort.
std::sort is just plain easier to use.

Here is a working example:
Live Example
The std::sort works on the second row, not the first row.  Then the compare lambda sorts the second row based on the data in the first row.
The output loop shows how to index the first row, given the second row.  For example, to get the sorted third number in the first row:
A[0][A[1][2]]
Since A[1][2] is the index of the third sorted number, the third sorted number is A[0][A[1][2]]
Edit:
If you are trying to use a dynamic two dimensional array, then use std::vector, as this example shows
",2,41525945
41527021,"
I don't know the purpose, so I can be wrong, but maybe you should use structure or class with two fields: index and number, overload <, <=, ==, >, >= operators and use array of objects, and just use sort method. 
",-1,41525945
41524507,"
Have the comparison function check an atomic flag and throw an exception if the flag is set.  The sorting thread should catch the exception and exit cleanly.  The GUI thread then just needs to set the flag.
",7,41524454
41518622,"
If you can define a bijective operation in which the comparison is total/weak order then you are fine. 
It turns our that for your type (unsigned) this is simply -=2/+=2
Well, that also depends what you want to do with zero.
This relies in 1 - 2 == std::numeric_limits<unsigned>::max() so when you ""compare"" e.g. 1 with x you get std::numeric_limits<unsigned>::max() < x - 2 which is false, even if x is also 1 (it will be true for 0 if there is such).
",1,41517882
41488178,"
The comparison function must meet the requirements of Compare concept. One of the requirements is:

If comp(a,b)==true then comp(b,a)==false

Your function violates this requirement, so the program has undefined behaviour.
",13,41488093
41490115,"
You write qsort by taking an item at random, then separating all the input into ""bigger"" and ""smaller"" piles. Then you do the same to both of the piles. It only works if you more or less halve each pile on each step. If the comparison function always returns true, everything goes into the ""bigger"" pile, and thus the recursion never stops until the stack is exhausted and the computer reports an error.
That's probably what is happening.
",0,41488093
41486465,"
Assuming your implementation is correct, two O(N logN) won't necessarily run at the same amount of time. Asymptoptic complexity is a measure of how much the resources required to run a program grow as the input becomes very large. Just to give you an example, the following loops are both O(1), since each of them always run a constant number of steps:
But there's no question that the second will take much longer to run. As a matter of fact, the runtime gap between these two loops will be significantly larger than the gap you are observing for your sort algorithm versus std::sort. That's because asymptoptic analysis neglects constants.
Moreover, asymptoptic complexity is usually for the average or worst case scenario. The same algorithm can run in more or less time for inputs of equal size depending on the data.
Not to mention that std::sort is very likely not a single sorting algorithm. It probably uses different strategies depending on the size of the array. In fact, somple implementations of std::sort use a mixture of algorithms.
The proper way to analyze a program's complexity is by reading the code. For a numerical approach, the closest you can do is to run your program, without comparing it to other programs, for several inputs of different sizes. Plot a graph an observe the curve.
",4,41486335
41490538,"
In the case of Visual Studio, std::sort() is a mix of quick sort, heap sort (only to prevent worst case O(n^2) time complexity), and insertion sort, while std::stable_sort(), is a mix of merge sort and insertion sort. Both are reasonably fast, but it's possible to write faster code. The example code in the question is copying data before every merge, which consumes time. This can be avoided by doing a one time allocation of a working buffer, and switching merge direction based on level of recursion, using a pair of mutually recursive functions (shown below), or a boolean parameter to control merge direction (not used in example below).
Example C++ code for top down merge sort that is reasonably optimized (bottom up merge sort would be slightly faster, as it skips the recursion used to generate indices, using iteration instead).
",0,41486335
41475062,"
What memory the standard library algorithms can use is not mandated by the standard, so the implementation can generally do as it wants. That includes allocating heap memory.
You can check if some specific implementation provides the guarantees you want, but again, in general, you have no control over how the implementation implements its algorithms.

However:

The background is that I consider to introduce some of the standard library algorithms into an embedded environment in which a controlled memory usage is crucial. (especially the heap shall not be used).

The implementation must make sure that its algorithms do what they are supposed to do as defined by the standards. That means: If you have a C++ compiler that supports your target environment, it must do the right thing on said target platform, however it achieves that.
In particular: If your platform does not have a heap, any implementation that supports it must not use the heap.
",7,41474992
41470908,"
Space complexity remains O(n) independently on array argument calling method - it is size of buffer needed for (classic) merge sort implementation.
So you have input array (it is usually also output array) and buffer array of the same size - that is why additional space is O(n)
",1,41470507
41449986,"
If the arrays must be parallel, the better way to sort them is to have a third array of indices, and sort those integers based on Array2.  Note this is C++ code, not Java:
The output function could have also been written this way:
",1,41449167
41449775,"
I am suggesting a different solution, please discard if you don’t want to use. Design a class with two fields, one for the number from array1 and one for the number from array 2. Instead of the two int arrays, make one array of objects from this class. Now no matter how the array is reordered, the numbers from each of the original arrays will always follow each other. Also, it’s easy to sort by either the first or the second number as necessary.
I didn’t expect to write the code for you, but on your request here are some useful snippets in Java to get you started. The class is quite simple, two fields, constructor and getters:
You may of course add toString method and what else you may like. Since you know your domain better, you can also find a better name for the class. With this class you may do:
You will recognize your original arrays in the printout:
As an example of sorting, here’s how to sort the ParallelNumbers elements first by elem2, next by elem1 (to resolve clashes):
This time it prints:
Exactly as you had requested, isn’t it?
EDIT: Something similar has been written before. See for example Anti-pattern: parallel collections and Parallel array.
",0,41449167
41443948,"
This is an odd way of writing insertion sort, https://en.wikipedia.org/wiki/Insertion_sort
I would assume you can change your condition to:
But I would suggest using a proper sorting routine instead
The idea is to separate duplicates by saying that if the values are the same we sort according to their order in the sequence; as if the sequence was a pair of the value and the sequence number (0, 1, 2, 3, 4, 5, ...).
",2,41443567
41443931,"
The issue here is that for any 2 equally sized numbers the nested loop will return the same counter value. Thus for such a counter value tempArray[counter + 1] will never be initialized.
The way to solve this would be to maintain a vector<bool> denoting what each position had been written and write to the next valid position if that is the case.
But supporting a second vector is just going to make your O(n2) code slower. Consider using sort instead:
",1,41443567
41411660,"
You have many problems there.

The most obvious one is that your code lacks [this].
vec.begin(),flow.end()

You can't take the beginning of one and the end of another vector.
This is the corrected code:
However, you should tell us what you are trying to achieve and I'm sure we can find a better solution. Using vectors of iterators of other vectors is already very dangerous, doing subtractions on them without checking is just careless.
Less dangerous solution:
",3,41411568
41411229,"
You have an off by one error with your sorting portion. In the following lines:
At this point size is 4, and v1.size() is also 4. In the for-loop i goes from 0 to 3 like usual. But you are using v1[i+1], so your loop will try to access v1[4], which is out of bounds and gives you the garbage value that you are seeing.
To fix it, just fix your loop bounds:
",1,41411115
41409510,"
1.overloading operator<
you can do this by overloading the < operator
2.using lambda expressions
(what is lambda expression?)
3.using custom compare functions
If the possible fields to be used for sorting are known prior, it may be easier to read to implement custom compare functions specifically for the sorting.
",4,41409390
41409497,"
std::sort accepts a third optional parameter that is a comparator function. This function should behave as < between elements (i.e. return true when the first is ""less than"" the second.
For example to sort an std::vector of your structures on increasing payment value what you can do is:
",2,41409390
41409448,"
let the array be struct singlePaymentStruct a[N]
sort(a,a+N,cmp);
How it works under the hood?
Simply put basically it uses some sorting algoritm like quicksort or mergesort.
Why do we specify comparator functor ?
Well we need that comparator functor to decide the ordering of elements.
The basic thing is in any sorting algortihm the basic operation is comparison..and if we can specify that we are basically controlling the sorting operation. 
Hope now you get the pieces together. That's why cmp() takes two values which it will compare and based on which order them. 
",0,41409390
41397217,"
Main idea - put all points to multimap (where key is a point coordinates and value is a index of line and begin/end mark). After that you need to select any point as startup, find index of line that has this point and fetch another end of line. Then you mark current line as used and use end of current line as startup for next iteration.
The complexity of the algorithm is O(N * logN).
This algorithm doesn't required end-to-start sorted data.
You can find full source code with example generation here:
http://ideone.com/TuzjMn
",0,41395855
41378562,"
Your function signature is wrong and you're calling std::sort incorrectly, you want something more like:
",1,41378329
41378528,"
where you can use pass float arr in this form 
With this comparator you can sort it.
",1,41378329
41314139,"
A lambda will work:
or bind:
",1,41314059
41314188,"
You've got a couple of options:
If you don't have access to C++11 you can go old school and implement your own comparator that preserves state:
However, if you do, you can just use a lambda:
",1,41314059
41314109,"
Quick and dirty way: Move Func outside the class.
",0,41314059
41310210,"
Add this method:
to your Entry structure.
Add this to your source code:
Change your containers to:
Your input loop will look something like this:
You may also want to search the internet for ""stackoverflow c++ read file struct"" for more examples.
In summary, create a struct or class to model the record.
Overload operator >> to read in a record.
Use std::vector of your struct, not a vector of each data member.
If you are serious about a database, then use one; don't rewrite your own.  
Edit 1: Sorting
To make sorting easier, overload the > operator:  
Now, you can sort the database by using:
Edit 2: Other sorting
To order the container using different criteria, you can create ordering functions and pass them to the std::sort function:  
Your sort becomes:
",-1,41310129
41297542,"
Check below code, where new variable moves indicates the number of moves of elements made during sorting:
Swapping two elements to each other position is assumed to be 2 moves.
",0,41297018
41259520,"
@molbdnilo already commented on the issue, int temp[size] is allocating too much space from the stack. If you want to use an array, use malloc() and free():
or as also suggested, use a vector.
",1,41245157
42687884,"

The problem is when i ask the user ""to enter how big the array will be"" If I type in 6, I only get to enter 5 number only not six

Let's say you enter 6 here, this loop will run from 0 to 4 i.e. FIVE times. Hence you are able to enter only FIVE numbers
You can modify this loop like this below:

PS: im trying to picture the code to make a dynamic array then a sorted. How would I do that? As you can see below I have the user enter their own array but the limit is n AKA 1000. How can I fix that issue as well please. thank you

Your requirement is not clear. Please re-state your question. As mentioned in the comments, I do not see any need for n. You can ask the user to input the number of elements required for the array i.e. k and then you can dynamically allocate space for so many integers like this:
",0,42686020
42676721,"
If you put arrival and duration in an std::pair<int,int> and put that pair in a std::set, they will be sorted as expected.  If needed, you can make 2 new vectors with the sorted values.
A bit cleaner would be to use a struct with the needed fields, but then you should define a compare function to decide the order.
",1,42676325
42662705,"
The standard in-memory merge sort does log(n) passes over the data, merging successively larger lists with each pass. In the first pass, you merge lists that contain one item each. Next, its lists with two items each, then four, etc. With this method, you make log(n) passes over the data, and you look at n items during each pass. Thus the O(n log n) complexity.
That method is very effective for in-memory sorts, because the cost of accessing an item is not very high. For disk-based sorts, though, it becomes very expensive because the cost of accessing each item is very high. Basically, you're reading and writing the entire file log(n) times. If you have 20 GB of 100-byte records, you're talking 25 or more passes over the file. So your sorting time will be dominated by the time it takes to read and write the file 25 times.
An external sort is a much different animal. The idea is to reduce disk I/O as much as possible. You do it in two passes. In the first pass, you read as much of the data as you can into memory and sort it using Quicksort, merge sort, or another in-memory sorting algorithm, and write that chunk to disk. Then you read the next chunk of the file into memory, sort it, and write to disk. 
When you're done with the first pass, you have some number of sorted chunks out on disk. If you have a 20 GB file and you have 4 GB of memory free on your machine, then you'll have five chunks, each about 4 GB in size. (Note that you'd probably actually have five chunks that are slightly smaller than 4 GB, and a sixth, very small, chunk). Call the number of chunks k.
Note that after the first pass is done, you've read and written each record one time.
In the second pass, you merge the multiple chunks. This is done with a heap of k items. The idea is that you initialize the heap with the first item from each chunk. You select the smallest of those k items (which is at the top of the heap), and write it to the output file. Then, you take the next item from the chunk that contained the item you just removed, and add it to the heap. You repeat this procedure until you've emptied all the chunks.
The first pass is O(n log n). Actually, it's k*((n/k) log(n/k)), which works out to n log n. The second pass is O(n log k).
The important part here is that in the second pass, you once again read and wrote each item one time. You've reduced your disk I/O from reading and writing each item log(n) times to reading and writing each item twice. That will run much faster than the code you wrote.
It's also important to note that both algorithms are indeed considered O(n log n). The I/O constant is the killer. The second algorithm actually does more computation, but it saves so much disk I/O time that it's faster than the theoretically faster algorithm.
The External sorting article on Wikipedia gives a decent explanation, and the GeeksforGeeks article gives a working example in C++.
",0,42661455
42662356,"
The algorithm is O(N logN) but there's more to the performance than just the number of records being sorted.
The constant seeking and file access is extremely slow.  You should read multiple records in one chunk, as the time to read 16 records (or 200) is not much different than the time to read one.
In your main for loop, you're reading in data when you already have it.  Only reading in the new record (corresponding to which of l or r got changed) would help a lot, although the multiple record reading mentioned above would be much better.
You last loop, where you copy data from fd2 to fd would be much faster if you use large chunks (many records) instead of copying them one at a time.  The same applies to the middle two loops, where you copy the remnant of one of the sides, and there the r loop is redundant since you immediately copy the same data back in that last loop.
For all the gory details on sorting a large file on disk, see Chapter 5 (in volume 3) of Knuth's Art of Computer Programming.  (Section 5.4 in the second edition deals with external sorting.)
",0,42661455
42657653,"
You can do one of the following:
Use std::vector instead of array
or
Allocate new array with size = source_array.size()+1;
copy old array to a new one, and add a new value
You better use std::vector :-)
",0,42657560
42658249,"
Instead of
you should write
if you want to include that number at the end of arrry
",0,42657560
42659479,"
Your code as it stands uses a single thread to handle each of your rows separately. As a result you are starving for quick scratch memory (registers, L1 cache, shared memory). You are allocating at least 1600 bytes per each thread - that is a lot! You want to stay at around 128 bytes per thread (32 registers of 32 bits each). Secondly, you are using local arrays addressable at run-time -- those arrays will be spilled into local memory, trash your L1 cache and end up in global memory again (1600B x 32 threads gives 51KB, which is already at or above the limits of shmem/L1).
For that reason I would suggest handling a single row per block of 64 or 128 threads instead, and keep the row you sort in shared memory. Bubble sort is actually very easy to implement in parallel:
Notice how your inner for j = ... loop is replaced by threadIdx, but the core idea of the algorithm stays the same. In each iteration I perform bubble swap first only on even pairs and then only on odd pairs to avoid parallel conflicts.
I assume that nCols is lower than the dimension of your block, which for 100 elements is easily achievable.
There are many ways that the above code can be improved further, for example

Cut the thread count in half and assume j=threadIdx.x*2 for the first half of the loop, and j=threadIdx.x*2+1 for the second half. This way no thread stays idle.
Use only 32 threads, each handling two values of j sequentially. This way your problem will fit a single warp, allowing you to drop __syncthreads() altogether. With 32 threads, you might be able to use warp shuffle intrinsics.
Experiment with #pragma unroll, although the amount of produce code may be unfeasible. Profiling will help.

Also consider experimenting with hardcoded merge sort instead of bubble sort. If my memory serves me right, when I implemented a warp-sized bubble sort and merge-sort with all loops unrolled, merge sort performed almost twice as fast as bubble sort. Note, it was several years ago, on the first generation of CUDA-capable cards.
",1,42620649
42561200,"
You forgot that after shifting everything, you must look at indexCounter once again (you don't know if the value that arrived in the first iteration of the loop when you did arr[indexCounter] = arr[indexCounter+ 1]; is correct or not)
Simplest fix is to add indexCounter --; just after arr[arrSize - 1] = tempValueHolder;
It's also incredibly innefficient and I suggest you look at std::partition
",0,42561003
42561251,"
Use standard algorithms with the correct custom comparison function:
expected output:
As per Fezvez's suggestion, std::partition:
",0,42561003
42561318,"
You can do this much, much easier with std::sort: Demo
Output:

Or, if you desire internal sorting within odd and even: Demo
Output:
",0,42561003
42560851,"
You are exceeding the array's bounds and swap in an (uninitialized) value right after that array. Note that your array contains 10 elements, i.e. 0..9, and an access to number[10] is not permitted. In your code index runs up to 9, and you access number[index+1], which actually means number[10] then:
Though being actually undefined behaviour, common behaviours are that the program either crashes or accesses (and uses) memory that has not been initialized and therefore contains some ""random"" values, e.g. -13248.
",1,42560749
42538966,"
It appears you might not be making good use of an important stated feature of the input data, namely that the cars are already sorted by time of arrival.
This allows you to perform your bucket sort as you go.
Allocate your 100 buckets and your time variable, as you already have.  But, instead of bucket sorting all cars, bucket sort only the cars that have arrived.  Since the cars are already sorted by time of arrival, this is efficient.  Simply check to see if the first car in the array has arrived (by comparing to your current time value) and, if so, throw it into the appropriate priority bucket (and ""remove"" it from the array).  Repeat until the first car in the array has not yet arrived.  At this point, your buckets contain only the cars that have arrived.  So, iterate through your priority buckets, starting with the lowest, and grab the first car you find, output it, and remove it from its bucket.  Increment your time value.  Repeat until you run out of cars.
A note about ""removing"" a car from the list... there is no need to shuffle memory around by actually removing the car from the array.  Instead, you can simply keep a car counter variable that always points to the first unprocessed car in the array.  Since the input data is never destroyed or moved around, this also allows your buckets to contain nothing but indexes (or pointers, if you prefer) to the input array, rather than copies of the cars themselves.
By the bye, another approach would be to skip the buckets altogether, and replace them with a dynamic list (or vector) of cars that have arrived.  As each car arrives, you would need to find its place in the list by priority.
Either way, the main idea is: at a given point in time, only concern yourself with cars that have already arrived.
",0,42533073
42504540,"
I have concerns about your code about the logical steps and/or the naming of things. I couldn't just edit your code to fix it, so I've rewritten your code based on this understanding if you agree with me:

A head points to the first node, and a tail points to the last node.
Check to see if the list is empty, then head and tail point to the new node.
Otherwise, check to see if the new node is to be placed at the start, and do it
Otherwise, check to see if it fits in the middle, and do it
Otherwise, place it at the last place

In addition, my other changes include:
A. For the class stack

I renamed it to LinkedList
I put two member variables head and tail to refer to the first and last nodes

B. For the sort() method

I renamed it to insert
I explicitly wrote each of the important cases clearly (empty list, first node, middle node, last node)

I also removed the using namespace std and explicitly wrote std:: because it is a better practice. There are also some minor changes here and there.
My final code:
class Node
{
public:
  int data;
  class Node* next;

  Node(int info, Node* ptr = 0) 
  {
    data = info; 
    next = ptr;
  }
};

class LinkedList
{
private:
  Node* head;
  Node* tail;

public: 

  LinkedList()
  {
    head = 0;
    tail = 0;
  }

  bool isEmpty()
  {
    return head == NULL;
  }

  void insert(int data)
  {
    Node* newNode = new Node(data);

    if (isEmpty())
    {
      head = newNode;
      tail = newNode;
    }
    // if node to be placed at the top
    else if (data > head->data)
    {
      newNode->next = head;
      head = newNode;
    }
    else
    {
      Node* temp = head;
      Node* previousTemp = head;

      while (temp != NULL)
      {
        // if node to be placed in the middle
        if (temp->data < data)
        {
          previousTemp->next = newNode;
          newNode->next = temp;
          break;
        }
        previousTemp = temp;
        temp = temp->next;
      }

      // if node to be placed at the end
      if (temp == NULL)
      {
        tail->next = newNode;
        tail = tail->next;
      }

    }
  }

  void print()
  {
    std::cout << ""Stack from the top"" << std::endl;
    Node* temp = head;
    while(temp != NULL)
    {
      std::cout << temp->data << "" "";
      temp = temp->next;
    }
  }

  int pop()
  {
    if (isEmpty())
    {
      return -999;
    }

    int intReturn = head->data;
    Node *top;

    top = head;

    head = head->next;

     delete top;


     return intReturn;
  }
};

int main(void)
{
  int num = 0;
  LinkedList linkedList;

  while (num != -1)
  {
    std::cout << ""Please enter a number: "";
    std::cin >> num;
    if (num == -1)
    {
      linkedList.print();
    }
    else
    {
      linkedList.insert(num);
    }
  }

  std::cout << std::endl << std::endl;

  system(""PAUSE"");
  return 0;
}

Does this help?
",0,42501815
42469399,"
In general this statement 
can result in undefined behavior particularly when the vector is empty.
This loop
also can have undefined behavior because before comparing the dereferenced iterators *right < *left you should at first be sure that right != v.begin(). Otherwise the iterator left will be outside the valid range of iterators for the vector.
I am suggesting the following function definition
The program output is
",1,42468765
42468817,"
what if you'll create a starting method, which will check the array size, and only if larger than 2, will call the original method:
which will be implemented as:
",0,42468765
42457870,"
If you change file_contents from a string to a std::vector<string>, you will be able to operate on it in a similar fashion to how you would manipulate the contents of a plain-old-array.  Storing all of your data in a single string (as you do in the code snippet you posted) makes sorting the substrings difficult (impossible?) because it's not obvious to the sort algorithm where one substring ends and the next one begins.
",0,42457318
42454865,"
Assuming that the range of numbers has 100,000 values or fewer, you can use Counting Sort.
The idea is to use memory cells as counts for the numbers in the range. For example, if the range is 0..99999, inclusive, make an array int count[100000], and run through the file incrementing the counts:
Once you went through the whole file, go through the range again. For each count[x] that is not zero output x the corresponding number of times. The result will be the original array sorted in ascending order.
",2,42454790
42456686,"
I think I read it somewhere on SO or Quora about map-reduce:
Divide 1 mil. numbers into 10 blocks. Read in the first block of 100k numbers, sort it using quicksort, then write it back to the original file. Do the same procedure for the remaining 9 blocks. Then perform a 10-way merge on 10 sorted blocks in the original file (you only need 10 cells for this) and write the merged output to another file. You can write to a ~100k buffer then flush it to output file for faster write.
",3,42454790
42454908,"
You can implement a version of the quick-sort algorithm that works on files instead than on vectors.
So, recursively split the file in lower-than pivot/higer-than pivot, sort those files, and recombine them. When the size gets under the available memory, just start to work in memory than with files.
",1,42454790
42408464,"
It will have some error because the compiler will search the int main() so change the void balloon, and remove the clrsrc(); 
Since you used the setw(), you must use the #include <iomanip>
The header  is part of the Input/output library of the C++ Standard Library. It defines the manipulator functions resetiosflags(), setiosflags(), setbase(), setfill(), setprecision(), and setw(). These functions may be conveniently used by C++ programs to affect the state of iostream objects.
And lastly you must make the cout<<setw(5)<<N[z]; into cout<<std::setw(5)<<N[z];
and if you run it... here is my sample output
Hope this works on your assignment! Good Luck!
",0,42405047
42382629,"
Because

Simply sorting only may not be always the requirement. The requirement can be different. You may need to modify / integrate a sorting algorithm in order to develop a completely different thing.
The predefined sorting methods may not be the efficient at all cases.
Its always not about the sorted result but the approach of sorting in order to improve time and space complexity. Efficiency is the key.
There is no particular algorithm that is guaranteed to work best at all cases. Pros and cons may differ for different algorithms.
Need to understand which algorithm to be applied at what scenarios.
Sorting may not always done with numbers. It can be applied on other different complex types / structures. (There may not be pre-defined methods for complex cases )
There is always scope for a better approach.

",3,42382438
42388842,"
The current design of the standard library which splits into algorithms, data structures and iterators has some very nice conceptual implications: Algorithms only operate on iterators, never on containers. That means that algorithms cannot by themselves invalidate iterators, and all iterator invalidation comes through container modification, which must be made explicitly.
This is, for example, why remove-erase requires two components: a non-invalidating rearrangement of a sequence, followed by a container operation to shrink the container.
Moreover, not all ranges come from containers, so expressing algorithms in terms of iterators is closer in spirit to operating on abstract ""ranges"" than on concrete things that contain ranges.
And of course there's the original argument for complexity: By expressing both algorithms and containers in terms of iterators, the library requires O(M + N) components where M is the number of algorithms and N the number of containers, whereas if you had one algorithm per container, you would need O(MN) components. Yes, you could use templates, but completely unconstrained templates (e.g. template <typename T> void sort(T&) have non-local implications, and constraining templates is hard and subtle (e.g. count the hair on anyone who's ever needed to work with enable_if, or face their users, or tried to add ""concepts"" to C++).
",1,42381940
42402639,"
In fact, numbers are not inserted into the tree correctly. The main problem is located in the insert() function of the class BinarySearchTree.
In the while-loop while (curr), the switch between left and right is managed by the if-condition if (t->data > curr->data), assuming that case t->data == curr->data is connected to the left side.
After the while-loop, the switch between left and right is managed by the if-condition if (t->data < parent->data), assuming that case t->data == parent->data is connected to the right side. And not to the left side !!!
Solution - just swap the switch condition inside the while-loop as follow.
Instead of:
",0,42381556
42380981,"
Just use std::string::find to find index of a symbol and compare them:
another version is to convert a string to vector of indexes and compare them:
this solution is inefficient, but for learning purpose should be ok.
",0,42380780
42380820,"
One option is to replace every character by the corresponding one from your special alphabet. Then do a sort and change back.
For example:
",0,42380780
42381205,"
You can try customize sort.
Please refer to this link
Sorting a vector of custom objects
Below is my code sample for your case, but I dint handle for lower case letters.
Here is the result,

PS : Maybe I miss some conditions, but just share with you, how to apply the customize sort.
",0,42380780
42381737,"
You can overload < operator for strings and then use c++ function sort() located in <algorithm>
I don't quite understand how do you exactly want to sort strings with that rule, so it's up to you to encode the comparison of two strings, and that would be it.
",0,42380780
42382489,"
Edit: Added the lookup table and corrected the tests in getless.
Here is another solution using std::sort and a function that tests each string and returns true if one string is less than the other in QWERTY order:
Live Example
A lookup table is built that maps the character's relative ASCII position to where the character is found in the sequence string.  So for example, lookup[0] is the position of A (which is 10), lookup[1] is the position of B (which is 23), etc.
The getless function scans the string and tests the character associated with the i'th character of each string with the corresponding lookup position.  
The for loop basically ""waits for"" a character difference in the two strings being compared.  If the character in the string for s1 has a lookup value less than the lookup value for the character in s2, then we immediately return ""true"", meaning that s1 < s2.  Otherwise we return false if s1 > s2.  
If the characters are equal, we keep looping until we run out of characters to compare.  If both strings are equal up to the point we exit the for loop, we return true or false, depending on the length of the strings (a shorter string would mean s1 < s2).
",0,42380780
42374863,"
I figured out the solution myself using the debugger. Refer to the comment in uppercase to know the change made to correct the code. Following is the working code for Quicksort implementation for 10000 input values:
Thanks for the helpful advice. Really appreciate you guys insisting on using a debugger. Learned something new and really helpful, now my code works fine, for input of 10000 values. Cheers!
",2,42373261
42355401,"
You can use the following method:
and after that use array2 instead of array
then just change the prototype of your function to int *insertionSort
All remaining is to return array2 at the end of task
But be aware of memory leak: https://en.wikipedia.org/wiki/Memory_leak
",-2,42355227
42414292,"
Your current comparator probably looks like this:
You can achieve your desired sorting by using a slightly different comparator:
This means that we sort first by parent_id and in the case the parent_id is empty we do as if the string_id was the parent_id (what I call an effective_parent_id, similar in concept to the effective user id in unix :) ).
In case you cannot modify the class comparator method, you can implement a specific comparator (in a lambda or functor for instance) and use it with std::sort.
Some references:

basic_string::compare
std::sort, with an example of sorting using a lambda and a functor.

",0,42343668
42344024,"
The logic here is to add an extra int in the struct X. Yes, the memory will increase by 4-8 bytes for every object, but it's fine for my requirement.
The other thing is that, the vector is updated chronologically & not at once with {} (Sorry: This important part I missed to mention in the Qn). So whenever a new element is added, it will pull down its parent near to itself. That logic is mentioned below in form of a class, which contains the collection (vector, array, list etc.) & adds the objects:
Demo.
",0,42343668
42333499,"
You have two problems, solve them and it will work fine. (I checked it)
Problem 1
Update your last else block as follows. [you are missing a else condition if num1 is not greater than num2]
Problem 2
Put curly-braces in the else conditions inside the if and else if conditions block. So, the final code should look like as follows.
",0,42333405
42333537,"
Your indentation is misleading:


Should probably be:
Otherwise, the code would be equivalent to this, which I believe is not what you intend to do:
There are also logical pathways through your program in which numMid and numSmall are left uninitialised. Look at the last else.
If an uninitialised int is read, undefined behaviour occurs, which can lead to all kinds of strange effects.
You should use a higher warning level with your compiler. For example, Visual C++ with /W4 instantly spots the bugs:
",1,42333405
42333450,"
Looks like you forgot else in the last stage of ifs and will always get wrong results if the largest number is the third one.
",0,42333405
42333577,"
The corrected code. Thanks to everyone for the help.
",0,42333405
42322676,"
This is what structs are for
This way you can also increase the amount of numbers by just increasing the array size.
",0,42322128
42323041,"
As pointed by others, if you ask the user for how many assignments they have, std::array is a wrong container because it's dimension is fixed at compile time.
As others, I discurage the use of direct memory allocation but the use of std::vector to manage it.
I just suggest the use of reserve() (method of std::vector), when you know how many assignments.
The following is a full example using, instead a couple of std::vector of int, a single std::vector of std::pair<int, int>
",0,42322128
42322982,"
There are many reasons to avoid using arrays (dynamic or otherwise).  See for example Stroustrup's FAQ entry What's wrong with arrays?  As Greg suggests in the comments you will most likely write better quality code if you use a container like std::vector.  
If you can calculate or input the size of your container before allocating it you can (if you wish) pass that size to the constructor ...
On the other hand if you prefer to use a container that dynamically grows to hold data as it arrives you can do that too...
Update
I should have pointed out how to calculate the result from the two vectors.  You can calculate your overall grade with just one more line of code by using std::inner_product from the STL's <numeric> header.  Note that in the code below the last argument is 0.0 (rather than just 0) so that std::inner_product returns a double rather than an int.  That avoids any risk of float values being truncated to int (and avoids some pretty ugly warnings from the compiler).
",0,42322128
42304235,"
Except for special numbers like NAN, you can treat floats as 32 bit sign + magnitude numbers for sorting purposes. For radix sorting, it would be simplest to convert sign + magnitude numbers to 32 bit unsigned integers, then convert back after the sort. Example macros to convert from float to unsigned and from unsigned to float. Note that -0 would be treated as less than +0, but this should not be an issue. Cast a float to an unsigned int before using these macros.
",1,42303108
42290857,"
startScan is the starting position for finding the minimum value. 
is never never true, the left hand side and right hand side are always equal.
It looks like you want to say 
Your debugger should be able to produce the value of *(input + startScan) as a watch or as an expression for your future debugging sessions. 
",2,42290778
44620322,"
For the sake of clarity I made an external bubbleSort function, here is the code. I hope it helps you understand how it works.
",0,42290054
42279201,"
Your structure should look like this:
and then you declare array of treasures: 
taking items:
and finally sorting:
http://ideone.com/GL3VKz
",2,42278877
42278270,"
As stated in documentation for std::copy_if it expects unary predicate ie function with one argument, on another side std::sort needs compare function, that must meet requirement of Compare concept. So is is completely unclear why you expect the same function used for std::copy_if work with std::sort.

And how can I fix it?

Just pass std::greater<int> without binding second argument to constant. If you do need to use std::bind you can just pass both arguments:
but that would have the same effect as passing greater<int>() directly.
",1,42278033
42278284,"
sort's comparator requirement is:

Comparison function object (i.e. an object that satisfies the requirements of Compare) which returns ​true if the first argument is less than (i.e. is ordered before) the second

The greater functor takes 2 arguments, but you are using bind to make it into a functor that takes 1 argument and compares it to 3. This no longer satisfies sort's requirement.
If you're trying to move all the elements that are greater than 3 to the front of v you could use partition with greater_binded. Calling partition(begin(v), end(v), greater_binded) results in:

5 8 7 4 6 3 2 1

You could also go further using the return of partition which is an:

Iterator to the first element of the second group

Using that to sort or reverse-sort the 1st or 2nd groups with sort.
",0,42278033
42273638,"
Different containers have their own iterator types. For example for one-dimensional arrays there are used pointers as iterators while for objects of the type std::vector there are used iterators defined in this template class.
The variable swapped is used as a criteria whether the elements are already sorted. If there was not swapping of elements of the sequence when it was traversed then it means that the sequence is already sorted.
Take into account that the implementation you showed has undefined behavior due to this statement
because there is an attempt to decrement the last iterator when the range can be empty. So the implementation is incorrect.
Moreover the algorithm is not efficient. For example a tail of the array can be already sorted after some iteration of the internal loop. However in the external loop the last iterator is moved left only one position.
It is enough to use forward iterators for the bubble sort. In this case you can use the algorithm even with std::forward_list and others containers that do not have random access iterators.
Here is a demonstrative program that shows how the algorithm can be implemented using forward iterators.
The program output is
Here in the program there are used an array and an object of the type std::forward_list and the algorithm can be applied to the both containers.
",1,42273197
42273476,"
The template is there simply for convenience of using the function with different types. Implementing the function to use iterators and not a simple array saves you a lot of trouble with pointers and sizes.
The swapped variable indicates to the algorithm that the last run from begin to the end did not result in any swaps. This means that the array is sorted already in this range (and past the end it's sorted as well because that's what was handled in the previous passes) and there is no need to loop until the begin and end iterator are the same. The algorithm will work if you remove this check but could result in a time waste in case of partially sorted arrays.
Let's look at this example:
You can see that after 0: the array is already sorted, but without the swapped flag the algorithm would not break and continue checking. If the flag is there after 1: the swapped flag is false and the algorithm quits.
",3,42273197
42252201,"
A multidimensional array in C++ stores its data in contiguous memory.  Thus getting a pointer to the first and one past the last item is all that is required to use the STL std::sort algorithm function to sort the array.  
This will be much easier than trying to write your own sort, and will more than likely run faster since there is no need to ""flatten"" the array into a temporary one-dimensional array, and that you're taking advantage of std::sort's guarantee of logarithmic run-time complexity (as opposed to the bubble sort, which has O(n^2) complexity).
Here is an example of sorting the array in your question using std::sort:
Live Example
If you have to write a bubble sort (or any other type of sort), the basic reasoning still applies.  As long as you get a pointer to the first item, you can write the traditional bubble sort, as shown here.
Additional Note:
Since the multidimensional array stores items in contiguous memory, not only std::sort will work, but any STL algorithm will work on the sequence (for example, std::unique, std::partition, etc.)
Arrays that are not layed out in contiguous memory
If you have created an ""array"" that does not lay out the data in contiguous memory (for example, creating a two-dimensional array of type T dynamically using a T** and dynamically allocating each row of data), then flattening the array to a temporary one-dimensional array, calling std::sort on the one-dimensional array, and copying back the one-dimensional array back to the multidimensional array would be one solution.
",1,42237620
42225741,"
The code compares current->no with current->next->no. If out of order, the code should swap current with current->next, but this requires updating whatever points to current, which the code is currently not doing.
The bubble sort in this case moves the node with the relatively largest number to the end of the list on each inner loop. The outer loop needs to start at the beginning of the list each time, so that the node with the smallest number ends up at the front of the list. Use a swap flag that is set if any swaps are done, and if it ends up not set after a pass, the sort is done.
Instead of bubble sort, it would be simpler to create a new empty sorted list, and then remove nodes from the original list and insert them in order into the initially empty sorted list.
",0,42224828
42189845,"
You don't need to sort the array. You can have another array (freq) which will count the numbers appearances. So, a mini code for that:
I hope you got the idea :)
",0,42189317
42184757,"
You need to swap the entire struct, not just the member sku.
",1,42184706
42184741,"
The easiest way is to keep an array of pointers of inventory structs. Sort the elements on the same condition product[count]->sku > product[count + 1]->sku
but instead of swapping the sku values, swap the product[count] and product[count+1]. I hope it helps.
You can see here how to initalize an array of pointers to struct
source: http://www.cplusplus.com/forum/beginner/13778/
",0,42184706
23612713,"
Using the -G switch disables most compiler optimizations that nvcc might do in device code.  The resulting code will often run slower than code that is not compiled with -G, for this reason.
This is pretty easy to see by running your executable in each case through cuobjdump -sass myexecutable and looking at the generated device code.  You'll see generally less device code in the non -G case, and you can see the differences in specific optimizations as well.
One of the reasons for this is that highly optimized device code may eliminate actual lines of source code and actual source code variables.  This can make it very difficult to debug code.  Therefore to enable debugging, most optimizations are disabled with -G.
Also note that with Thrust, using the -G switch may result in unpredictable behavior.  Newer versions of thrust should behave better, but there may still be unexpected issues when compiling thrust code with -G.
",6,42184283
42184264,"
To find the max you just need to add the elements at index n-1 and n-2, as the array is already sorted and the 2 biggest elements will be only at the end of the array. No other element in the array will be bigger than these and hence their sum will also be greater than the sum of any other elements.
Time complexity : O(1)
For finding the min , you should look for pivot in the array. I choose to start from a[0]. If space is not a constraint create another array of similar size and populate it with the delta values from your pivot.
Now the second array will have the delta values from your pivot. All you have to find is the indices of the Minimum and next-Minimum values of Array b. These 2 will be the closest values to each and hence their difference will also be the least.
Time Complexity : O(n) + O(n) = O(n)
Space Complexity : O(n) as a new array of same size has to be created.
",2,42184090
42181456,"
EDIT: Got your code working but forgot the most important part, namely:
You're comparing the index to the array value, use:
Instead of:
Also, you always start swapping from the beginning when you should be starting one past first.
Instead of:
You want:
",0,42181298
42176551,"
You might use std::partial_sort:
Demo
",3,42176254
42125732,"
Both algorithms do O(n^2) comparisons.  customSort does O(n^2) swaps while selectionSort does O(n) swaps.  But that only tells you about the relative performance as n goes to infinity.  How long this actually takes depends on the optimizer, the processor, and the cache and memory speeds.  It can go either way, especially when n is ""small.""
The only way to know which will actually be faster is to measure.  It's not a matter of how to think about the problem.
Given that you've already determined that selectionSort is faster in your case, we could come up with some hypotheses.
Since selectionSort needs only two extra values, it's quite probable that the optimizer arranged to keep them in registers.  It also is very cache friendly in that almost all the memory reads are sequential.
Compare to customSort, which has to read two values from memory.  The swapping happens more often and requires at least two stores to memory.
If storing to memory is slower than storing to a register (which is probable), then it's not surprising that the selectionSort is faster, even though it customSort uses a trick to avoid the need for temporary variables.
",2,42105529
42123315,"
Thanks to @TinyT, I realized that the speed of the algorithm depends on the amount of potential operations that algorithm might perform.

Per @TinyT's suggestion, I drew out a simple use case for both of these algos, and determined that customSort has the potential to perform more operations than selectionSort, given the same array size.

@TinyT also provided approximations for the potential number of operations of each algorithm, which make sense if you refer to his comment on my question, and note the triangle pattern in the assignment of i with respect to j.

As a side note - in my drawing I used the variables i and j with selectionSort for convenience rather than accuracy with respect to the actual variable names. Also, in the drawing, the size used in the approximations is the size of the loop iterations.


",0,42105529
42099959,"
the code that you have written above is not bubble sort !
however , try this instead , this is bubble sort:
i offer you use a pair instead of two vectors
",-1,42099846
42100376,"
for each loop, you should compare each neighborhood, from the first to the end.
your error:

for (index = 0; index < names.size() - pass; index++) {

should be 

for (index = 0; index < names.size() - 1; index++) {

here is a sample
start: 5 4 3 2 1
loop: 0
index: 0 : [5 4] 3 2 1   =>   [4 5] 3 2 1
index: 1 :4  [5 3] 2 1   =>  4  [3 5] 2 1
index: 2 :4 3  [5 2] 1   =>  4 3  [2 5] 1
index: 3 :4 3 2  [5 1]   =>  4 3 2  [1 5]
loop: 1
index: 0 : [4 3] 2 1 5   =>   [3 4] 2 1 5
index: 1 :3  [4 2] 1 5   =>  3  [2 4] 1 5
index: 2 :3 2  [4 1] 5   =>  3 2  [1 4] 5
index: 3 :3 2 1  [4 5]   =>  3 2 1  [4 5]
loop: 2
index: 0 : [3 2] 1 4 5   =>   [2 3] 1 4 5
index: 1 :2  [3 1] 4 5   =>  2  [1 3] 4 5
index: 2 :2 1  [3 4] 5   =>  2 1  [3 4] 5
index: 3 :2 1 3  [4 5]   =>  2 1 3  [4 5]
loop: 3
index: 0 : [2 1] 3 4 5   =>   [1 2] 3 4 5
index: 1 :1  [2 3] 4 5   =>  1  [2 3] 4 5
index: 2 :1 2  [3 4] 5   =>  1 2  [3 4] 5
index: 3 :1 2 3  [4 5]   =>  1 2 3  [4 5]
loop: 4
index: 0 : [1 2] 3 4 5   =>   [1 2] 3 4 5
index: 1 :1  [2 3] 4 5   =>  1  [2 3] 4 5
index: 2 :1 2  [3 4] 5   =>  1 2  [3 4] 5
index: 3 :1 2 3  [4 5]   =>  1 2 3  [4 5]
final result: 1 2 3 4 5
",0,42099846
42055814,"
",2,42055649
42055910,"
With std:
",2,42055649
42053531,"
Try with
otherwise, with your code, {3, 1} result lesser than {1, 3} and result also true that {1, 3} is lesser than {3, 1}.
P.s.: but you can also use the operator<() for vectors
",4,42053459
42047725,"
You have two problem in your code.
1. value of i and j becomes out of range at some stage.
2. condition to check if the array is in ascending order is wrong.
Let's solve one by one


To keep the value of i,j inside the range change the for loop like this


Before:
After:
Explanation:
What your program was facing wrong is when the value of j becomes SIZE-1 you are checking if gameBoard[i][j]>gameBoard[i][j+1].But gameBoard[i][j+1] will try to access gameBoard[i][SIZE] and you know that there is no value in that index because you saved value from 0 to SIZE-1.
Same problem happens with i when your program is checking the last row.


To fix the checking condition if the array is in ascending order or not change your condition like this:


Before:
After:
Explaination:
When the index of j is less than SIZE-2 compare gameBoard[i][j] & gameBoard[i][j+1] and see if they breaks the condition or not.But when the index of j is equal to SIZE-2,we have to compare two things.One is compare gameBoard[i][j] with the next element gameBoard[i][j+1],Another one is compare the next element of j with next rows first element gameBoard[i+1][0].
N:B: Only that time you should check if gameBoard[i][j] is greater than gameBoard[i+1][0],not everytime.
",5,42047495
42047807,"
Here is a much safer version that doesn't require to do any comparisons or check for indices wrapping around to the start of each row, all using the std::is_sorted algorithm function.  
Since a 2D array is contiguous, there is no need to write a loop, since the range starts from the address of the first item to the address one past the last item in the entire 2D array.
Live Example
Live Example showing that the test data is not sorted
",3,42047495
42008296,"
I think it's a bad idea try to recalculate numerator and denominator when you can simply memorize they.
If you, instead of a std::set<double>, use a std::map<double, std::pair<int, int>>, you can use the key (a double) to sort the fractions and the value (a std::pair<int, int>) to print they.
So foo() can receive numerator and denominator.
The following is a full example
",0,42005950
42006835,"
This is the wrong way to go about it.
You should try to make a fraction class which stores the numerator and denominator and works with them directly.
Something like this should work:
This is just the bare thing and should work for the kind of input that you have, but you might need to specialise it (negative numbers, large numerator and denominator, dealing with different representations of the same fraction…)
",1,42005950
43343795,"
From LPWIN32_FIND_DATA (file information structure) you get as an output from FindFirstFile,you can fetch the time of every file in the directory,and as you iterate over the directory,you can insert each file handle in a map whose key would be the time of creation i.e. for 'x' file whatever its time of creation is you just insert it into a map.
The map by the virtue of its property would sort itself on the basis of key which here would be the TimeOfCreation
",1,43342255
43338193,"
Since this question is tagged with C++, I recommend a completely different solution: Embrace the power of C++ and use a std::vector. 
This approach frees you from having to manually manage the memory allocation. When the vector is allowed to go out of scope the storage will automatically be freed.
Documentation on std::vector
",2,43337761
43338058,"
C++ compilers are more strict than C compilers. Therefore not all C code will compile using a C++ compiler, so you shouldn't use a C++ compiler if you are not using any C++ feature.
malloc returns a void * so you must cast it to the corresponding type, provided that you are using a C compiler:
But if you must use C++ and malloc, then like mentioned in the comments, the C-style cast should be a last resort and you should rather use static_cast
",1,43337761
43337844,"
You should cast the malloc like this.
because malloc just return void pointer
",0,43337761
43334231,"
The inner loop for mergesortIter() could be simplified (this may also fix a potential problem, I didn't check all the possible issues):
For the mergesort function, which is really a merge function, the pair of if statements are comparing data before checking if an index is out of range. It's also not copying the remainder of data when the end of a run is reached. Here is an alternative:
Note that the variables from, to, last would be better named as left, right, end .
",0,43330806
43343548,"
Generally speaking, there's no relationship between the alphabetical order of letters in any given language and numerical codes assigned to said letters in any given character set. In order to compare strings according to the alphabetical order of a given language (or more generally the collation order of the current locale), C has a special function called strcoll.
In order to use it, you need to set up your locale accordingly. Unfortunately, locale names are not standard in C. If you are on Windows, the linked example is unlikely to work.
This is what you should be using in real software. It matters little for you assignment since you are not supposed to use fancy library functions. You need to implement a function similar to strcoll yourself, and it should only work for your language.
In a language where each character has its own place in the alphabet, this function is simple: write a function that takes a character and returns its place in the alphabet (e.g. for 'a' return 1, for 'b' return 2, ..., for 'å' return 27, for 'ä' return 28...) Compare the strings according to numbers returned by this function. This may or may not take into account letter case depending on what exact sort order you want.
If you don't want to write a big switch, you can use the fact that letters that are in ASCII are already ordered as you want, you only need to fix the order of three additional letters. So you can write something like this:
Of course this means that non-alphabetic that come after Z/z in the ASCII table will get sorted incorrectly. If you want to sort those after Ö/ö, you need to extend collation_order accordingly. Try doing this without resorting to a case for each individual character.
Another way to write collation_order is to use character codes (cast to unsigned char) as indices in an array of 256 integer elements. 
Also please note that old 8-bit encodings are old and should not be used for serious new development. For more information, read this.
",2,43323781
43325756,"
Since your options are constrained and you can also constrain your input to a foreseeable universe, I'd suggest you to use a simple parser function to fit non-ASCII characters inside the places you know they should:
",0,43323781
43278594,"
Your code for swap without the 3rd variable looks ok. Unfortunately, this algorithm cannot be applied for swapping a value with itself, for example:
Also, please note that there's a standard function for swapping (std::swap) and that your code, if compiled without optimization, works slower than the usual swap (with 3rd variable) as it performs more memory operations. Also, this code may lead to integer overflow or underflow which is undefined behavior by the standard and may or may not work as you expect. If we add readability issue (the most important thing) to this list, the recommendation is just don't use swap without 3rd variable.
",7,43278503
43268897,"
Assuming this is for homework (and if it's not, doing this by yourself will help you a lot more than just seeing the answer,) I'm just going to give you a few pointers to help you out.
Compare ASCII values:
http://www.asciitable.com for the ascii values. I recommend using tolower() on the player names, because capital letters are lower values than lower case letters.
If the first digit is equal, move on to the second:
(One way of doing this.)
",1,43268672
43268790,"
A simple solution for doing this is storing the values as a set. This is a fairly standard way to store data in C++ and has the advantage of automatically sorting alphanumerically. You will have to wrap your head around iterators though to output them effectively.
Consider this execution:
From here you can use this to output the names:
You will also need an #include <set> in your header file.
",0,43268672
43268863,"
Sorting is provided by the standard library, on types with an operator<, or other types if given that comparator. You can build one off of string::operator< which performs lexical comparison.
If you don't have C++11 lambdas then you'd use a functor.
",0,43268672
47702552,"
The largest item must be moved by 2 positions each time we partition the array in order to exchange it the maximum number of times. It cannot be moved by just 1 position, because in this case it will become a pivot element and will be moved to its final position. For example, consider the following array:
After partitioning the array the largest element (10) is moved by 1 position to the right
But now the largest item becomes a pivot element and will be moved to the end of the array, adding only 1 exchange.
Instead, we need to arrange the items so that the largest item is moved by 2 positions keeping 1 item in front to become a pivot element:
After partitioning:
The largest item is moved every time by 2 positions, therefore the number of exchanges is floor(N/2).
Example (N = 10)
The maximum number of times that the largest item (10) is exchanged is 5 in this case.
",2,43263249
43263446,"
Your answer for the question is not accurate. The maximum number cannot be passed over more times than there are spaces available, since it should always be approaching its right position. So, going from being the first to the last value spot, it would be exchanged N times.
There is an one exclusion for this case, and that is when the array has size 1, the largest element can't be moved any more, so the maximum number of moves would be N - 1.
This answer was provided already before in here: Scenarios for selection sort, insertion sort, and quick sort
",0,43263249
15976375,"
Whenever you call a function, including recursively, the return address and often the arguments are pushed onto the call stack. The stack is finite, so if the recursion is too deep you'll eventually run out of stack space.
What surprises me is that it only takes 4793 calls on your machine to overflow the stack. This is a pretty small stack. By way of comparison, running the same code on my computer requires ~100x as many calls before the program crashes.
The size of the stack is configurable. On Unix, the command is ulimit -s.
Given that the function is tail-recursive, some compilers might be able to optimize the recursive call away by turning it into a jump. Some compilers might take your example even further: when asked for maximum optimizations, gcc 4.7.2 transforms the entire function into:
This requires exactly two assembly instructions:
Pretty neat.
",19,43261344
15976376,"
Your stack is limited in size and so when you make 4793 calls you are hitting the limit while 4792 just comes in under. Each function call will use some space on the stack for house keeping and maybe arguments.
This page gives an example of what a stack looks like during a recursive function call.
",1,43261344
15976368,"
You just hit the call stack's size limit of your system, that's what's happening. For some reason the stack in your system is tiny, a depth of 4793 function calls is rather small.
",1,43261344
15976384,"
My guess is you stack is exactly big enough to fit 4792 entries - today.  Tomorrow or the next, that number might be different.  Recursive programming can be dangerous and this example illistrates why.  We try not to let recursion get this deep or 'bad' things can happen.
",0,43261344
15976456,"
Any ""boundless"" recursion, that is recursive calls that aren't naturally limited to a small(ish) number will have this effect. Exactly where the limit goes depends on the OS, the environment the function is called in (the compiler, which function calls the recursive function, etc, etc). 
If you add another variable, say int x[10]; to your function that calls your recursive function, the number needed to crash it will change (probably by about 5 or so). 
Compile it with a different compiler (or even different compiler settings, e.g. optimization turned on) and it will probably change again. 
",0,43261344
39753891,"
Using recursion, you can achieve SuperDigit:
",0,43261344
43254602,"
This sets max to the first element of the array, not the last one. So when this line of code runs:
count always has a size of 1.
Change it to:
Also, C++ does not support Variable Length Arrays; there are only some compilers that have extended their support for it. The size of the array must be a fixed constant at the time of compilation for these compilers. If you want to use VLAs, use std::vector instead.
",1,43254267
43255913,"
The function countingSort has around 50% lines with bugs.
Your count array always has exactly one (array[0] - array[0] + 1) element. 
This means that you have undefined behaviour when reading or writing beyond index 0.
(Variable-length arrays are a non-standard extension. Learn how to use std::vector.)
You don't know the maximum and minimum values until after the loop that determines what they are has completed.
Move the array declaration after that loop.
Also, you need to fix that loop, because it doesn't necessarily find the minimum value (array[i] <= max does not mean that you have found one).
You will have min == 6 for your example input, for instance.
The counting loop needs to be
because you're looping over array, which has length elements.
And you need to adjust your counter, since the minimum value corresponds to index 0 but isn't necessarily 0:
And the ""result-gathering"" loop should be
because count has max - min + 1 elements, and you need to
because the first element counts the min occurrences, not the zeroes.
I think that covers most of your problems.
(And a side note: ""sum""  is a very peculiar name for something that isn't a sum.)
",1,43254267
43256444,"
I improve it in some places but not it gives me a output 6,7,8,9,10,6...
",1,43254267
43246522,"
your remove function has small fault. You didn't take care of the possibility of removing the first node. 
final sort function. The objective is to sort the existing list by using the minimum and remove functions and get the new sorted list. You need to get minimum from the existing list and keep adding them at the end of the new list. And finally change the head pointer to point it to the new list. 
The while loop should run until the existing list becomes empty.
",1,43246218
43271585,"
You do not need to implement everything your self, just use the standard library:
",0,43223183
43191524,"
std::vector::operator[] never inserts a new element into the container and no bounds checking is performed (vector/operator_at). If you access an element that is out of bounds leads to undefined behaviour which is your case.
You must use std::vector::emplace_back or std::vector::push_back, other option is to use the constructor explicit vector<T>(size_type count); that constructs the container with count default-inserted instances of T:
First option:
Second option:
And std::sort(one.begin(), one.end()) must work.
",0,43191321
43191448,"
Your values for your vector[i] are not allocated. Hence, accessing vector values (e.g one[999999]) that are out of bounds leads to undefined behaviour. 
Use push_back() for your std:::vector to allocate and assign the values to your vectors:
That will solve the segmentatio fault.
As for sorting, once you have values.
std::sort(one.begin(), one.end()) sorts by default using operator< so leave it as it is.
",1,43191321
43191455,"
You didn't push/append elements in vector. Without allocating space or pushing back, you can't add element in vector this way (My clang compiler would yield runtime error due to bad allocation/array out of bound). Use push_back instead.
To quick test -
",0,43191321
43175484,"
You are reading/writing out of bounds. i+gap is 15 in your first iteration. You have only 15 elements in your array, so you are reading one past the last element. This is the most common mistake in C, don't feel bad about it!
",0,43175406
43181927,"
",0,43175406
43163281,"
Firstly, it appears to your containers store pointers of Dodavatel * types. However, in your cycles pointers a and b are declared as independent local variables. Swapping around pointers a and b does not affect the contents of your array.
So, the question is: what are you supposed to reorder in order to ""sort"" the array? The pointers? Or the objects these pointers point to?
In the former case in order to reorder the pointers you need to declare the cycle variables as references
In the latter case you can can keep the current declaration, but inside your if you have to swap *a and *b, not a, and b.
Secondly, your if makes no sense since it compares *a with itself.
",2,43163254
43163278,"

if (a->getNazov() < a->getNazov()) {

this line will never be true.
",1,43163254
43162632,"
You're in luck.  The C++ Extensions for Parallelism Technical Specification added parallelized versions of the many of the standard algorithms including std::sort. They are available in C++17.  GCC has support for this and you can see their page about it here.  It looks as though they are utilizing OpenMP for multi-threading.

GCC Prerequisite Compiler Flags
Any use of parallel functionality requires additional compiler and runtime support, in particular support for OpenMP. Adding this support is not difficult: just compile your application with the compiler flag -fopenmp. This will link in libgomp, the GNU Offloading and Multi Processing Runtime Library, whose presence is mandatory.
In addition, hardware that supports atomic operations and a compiler capable of producing atomic operations is mandatory: GCC defaults to no support for atomic operations on some common hardware architectures. Activating atomic operations may require explicit compiler flags on some targets (like sparc and x86), such as -march=i686, -march=native or -mcpu=v9. See the GCC manual for more information.


I know you said you are using Linux but I also want to included that it appears MSVS, starting with version 2013 RTM, also has support for the Parallelism Technical Specification.
",1,43162542
43154398,"
You are missing a namespace qualification in your call to integer_sort.
integer_sort is in the boost::sort::spreadsort namespace (see the documentation). So your call should look like:
Also note that you will have problems if you try to use boost::sort and the Boost.Sort library in the same program, as the boost::sort function template conflicts with the Boost.Sort namespace (see the bug report).
boost::sort is just a wrapper for std::sort, so it is expected that the two would have identical performance.
boost::sort::spreadsort::integer_sort will use std::sort if the data size is too small (below boost::sort::spreadsort::detail::min_sort_size), so for small data sizes it would be expected that they too have nearly identical performance (up to the extra cost of integer_sort checking whether to use std::sort or not).
",1,43153976
43126046,"
yes that is correct. But i cant find where it goes wrong. First of all. i can't manage the programe van writing the words to a textfile and second i have no idea how to give the program the wright code to look to all the words and not only the words on a new line.
",0,43099571
43093144,"
This line from Repository.h is your problem:
You're returning a DynamicVector by value, instead of by reference, which means you're making a copy of the vector.
As a result, when the compiler hits
It gets compiled as, ""Make a copy of movies and pass a pointer to the beginning of that copy. Make a second copy of movies and pass a pointer to the end of that copy. Then sort from the beginning of one copy to the end of the other copy."" This results in an assertion.
Typical C++ style would instead do something like
I.e., provide both const and non-const access to the vector.
",0,43091528
43084237,"
here:
you are trying to pass sortType, but it is a template; actual type is sortType<T>, so function signature should be
also, what n.m. mentioned in comments
",0,43084131
43057622,"
One way to tackle your problem is through a definition of a meaningful comparison operator< / comparison lambda expression / comparison class, which then be used along with the sort algorithm:
for example a comparison class would be:
and then to sort a vector of roman number for example, you do:

assuming:
",4,43057423
43011758,"
 1. You need to provide invComp for us to see if there is something wrong.
 2. You'd want to use nth_element instead of sort for this task.
",2,43011643
43008185,"
sort decision should be like this
because if if (lhs.age_ == rhs.age_) is true, return lhs.age_ < rhs.age_ will always be false, and your comparator will return false if ages are same.
",1,43008069
42998021,"
One quick, non-intrusive way is to use a lambda function. you can use a lambda if you are using C++11 or above, so something like the following:
",6,42997917
42998178,"
To complement the observational approach, you can read the documentation. On complexity, std::sort must be:

O(N·log(N)), where N = std::distance(first, last) comparisons on average.
      (until C++11)
O(N·log(N)), where N = std::distance(first, last) comparisons.
      (since C++11)

Obviously, big-O notation can mask some constant factors, but in general, expect it to be proportionate to N·log(N) (where the log is base 2, like all good CS logs).
",2,42997917
42999785,"
You want to increment the counter before you do the comparison. Consider this code, from your shiftRight method:
That only increments the counter if the conditional is true. If pq_keys[swpIdx] >= pq_keys[leftChild], then you made the comparison without counting it. You need to change your code to be:
You need to do the same thing in the other two places where you count comparisons: increment the counter, then do the comparison.
",0,42995689
42996133,"
",0,42995689
42990154,"
Considering that your static arrays never change, and that you have infinite pre-processing power I think the best approach would be to create a specific hash function for each of your arrays. 
My approach - define a parameterized hash function (code in java):
For each test array find such a combination of parameters, that max bucket size is the smallest. 
Some testing (input array has the size of 10k, filled with random elements):

Hash mapping into [0..262k] results in a bucket of 2 items max. 5k random arrays tested, single-threaded version finds hash functions at ~100 arrays/second rate.

Considering that with the max bucket size of 2 it is possible to map both values into one 64-bit integer, this approach will result in only one memory jump and the simplest operations for CPU - hashing is made through xor, plus and shifts, which should be extremely fast as well as bits comparison.
However your data may not be so good, and may require bucket size of 3, which destroys possibility of long long usage for bucket items. In this case you can try to find some decent hash function instead of the random mess I've written.
",3,42989312
42975880,"
Well, first of all, you get n^2 entries, the largest of which will be n^2, and of the possible value range, only a tiny amount of values is used for large n. So, I'd suggest a counting approach:

Initialize an array counts[] of size n^2 with zeros.
Iterate through your array of values values[], and do counts[values[i]-1]++.
Reinitialize the values array by iterating through the counts array, dropping as many values of i+1 into the values array as counts[i] gives you.

That's all. It's O(n^2), so you'll hardly find a more performant solution.
",4,42975359
42975877,"
This is in essence the O(n*n) solution as described in cmaster's answer.
",3,42975359
42958335,"
In your test example A B C D E F your tree is basically a linked list. First, you insert A, so it becomes your new root. B is bigger than A, so when you insert it, it goes as a right child. The same happens for all next strings:
A->B->C->D->E->F.
So when you traverse your tree from left, you just print your list as it is since there are no left child in any of the nodes in the tree. When you traverse it from the right, you just print it backwards.
Since your tree is unbalanced, this is an expected behaviour. There are no bugs in your code from what I can see. Try to add balancing or make another root.
",1,42957322
42940557,"
You can pass a custom comparator to std::sort:
",6,42940528
42940572,"
You can utilize std::tuple's comparison:
This way you can add more fields for sorting very easily.
",2,42940528
42915841,"
The standard library - on purpose - doesn't have a sort-while-copying function, because the copy is O(n) while std::sort is O(n log n). 
So the sort will totally dominate the cost for any larger values of n. (And if n is small, it doesn't matter anyway).
",4,42915772
42916674,"
below link is not general algorithm, but worth to read.
https://probablydance.com/2016/12/27/i-wrote-a-faster-sorting-algorithm/
",1,42915772
42916482,"
Assuming the vector of doubles doesn't contain special numbers like NAN or infinity, then the doubles can be treated as 64 bit sign + magnitude integers, which can be converted to be used for a radix sort which is fastest. These ""sign + magnitude integers"" will need to be converted into 64 bit unsigned integers. These macros can be used to convert back and forth SM stands fro sign + magnitude, ULL for unsigned long long (uint64_t). It's assumed that the doubles are cast to type unsigned long long in order to use these macros:
Note that using these macros will treat negative zero as less than positive zero, but this is normally not an issue.
Since radix sort needs an initial read pass to generate a matrix of counts (which are then converted into the starting or ending indices of logical bucket boundaries), then in this case, the initial read pass would be a copy pass that also generates the matrix of counts. A base 256 sort would use a matrix of size [8][256], and after the copy, 8 radix sort passes would be performed. If the vector is much larger than cache size, then the dominant time factor will be the random access writes during each radix sort pass.
",1,42915772
42913152,"
I think you're complicating the problem. If I were you, I would define a struct like
and declare a vector<Whatever> text
After that, you could use the algorithm sort with a custom compare function that would sort your text vector in lexicographic order.
If you really have to use binary search trees for the assignment, take some time and do some research. The basic idea is that every time you want to insert a node in the tree, you compare it with the current node (which at beginning will be the root) and see if it's greater or lesser in value (in your case, lexicographic compare) and go in the specified direction (left for lesser, right for greater) until you reach a NULL node and there you add it. After that, you can gen a lexicographic order by doing a left-root-right parse of the tree. Again, I would use that struct for ease.
",0,42912544
42916947,"
Here's the structure you should use along with insert function to implement the problem using binary tree-
In your case, you were including this structure in a class LexTree which isnt of much help but instead complicates things.
Here's how you should implement insert function-
EDIT-
Here is your check function-
To use insert just pass root node of your BST along with your word as arguments to insert
Some tweaks in InOrder and main that should solve the problem
",0,42912544
42909105,"
I'm not writing out the full soution, but you can pass a comparer to std::sort:
",0,42908973
42884892,"
Generally one sorts into a power-of-2 number of buckets, so that one can reduce the number of passes AND benefit from bitwise operations.
",1,42884880
42863676,"
If you need to save z order while reordering by y, then yComp = [](const auto& p1, const auto& p2) {return p1.y < p2.y && p1.z <= p2.z;};
",0,42863359
42863406,"
Is it performance critical ? If not, just split your existing vector into two, sort by Y and then put the results back into a single vector ?
?
",0,42863359
42841270,"
To check that a particular graph has a unique topological sorting, it is apparently enough to check for a Hamiltonian path in the DAG. Quoting wikipedia:

If a topological sort has the property that all pairs of consecutive vertices in the sorted order are connected by edges, then these edges form a directed Hamiltonian path in the DAG. If a Hamiltonian path exists, the topological sort order is unique; no other order respects the edges of the path. Conversely, if a topological sort does not form a Hamiltonian path, the DAG will have two or more valid topological orderings, for in this case it is always possible to form a second valid ordering by swapping two consecutive vertices that are not connected by an edge to each other. Therefore, it is possible to test in linear time whether a unique ordering exists.

So you just need to get the DAG for the first sorting you find and check that it forms a path that visits all the vertices.
",0,42839016
42828123,"
This a classic in linear algebra libraries: the layout of a given matrix can impact a lot the performance due to the patterns of element access.
You face exactly the same outcome. Obviously each vector of int is a row in your case. You need to sort columns. What you can do is the transpose trick:

Compute the transpose of your matrix
Sort the rows of that transpose
Compute back the transpose of this sorted matrix
Profit

Some code to illustrate the idea:
Now we have the transpose function, we can implement the algorithm.
The result can be viewed on this Live Demo
",3,42827748
42812770,"
The right way to do this is implement operator<() for Person rather than your sortByName() routine:
From there you can use a variety of techniques to compare your two Person objects, as long as the ordering is always the same.  See Case insensitive string comparison in C++ for one solution.
Converting the case of arbitrary strings is surprisingly complex (maybe even border-line impossible), if you want to work properly for all situations, such as any language.  You can side-step some of this by doing a case-insensitive comparison, rather than a conversion; but there are still a lot of issues.  With additional constraints like ""English only"" or ""just ASCII characters"" this is significantly easier.
",1,42812436
42812643,"
Your getName() function could return the lower case of the name instead of what is actually stored (or make an alternative getName() used only for the sorting part. The tolower function (http://www.cplusplus.com/reference/cctype/tolower/) works on only one character at a time, so you would have to iterate through the whole name. But there's a solution for that, too (How to convert std::string to lower case?)
",-1,42812436
42819943,"
Nearest neighbor search is a standard problem. Your are probably looking for a cover tree. The Wikipedia article itself is very short on detail, but it links to the original paper and an implementation on GitHub.
",0,42811050
42784473,"
The reason your output of array b won't work perfectly is because not all elements of array b has a value stored in it. For all the values of i for which a[i]<=k, b[i] will have a value 0 or a garbage value (dependent on the compiler).
In order to avoid it you should write your code as:
",0,42784220
42768781,"
The easiest way I can see to do this is to construct a histogram of each array.  Then you can compare those histograms together.  That should be O(NlogN) to convert each array to a histogram where N is the array size and then O(N) to compare the histograms when N is the number of unique elements in the array (size of the map).  That would look like
",1,42768479
42752766,"
try 
",0,42752284
42752701,"
Remove the i variable from declaration. Use just the size variable.
",0,42752284
1380496,"
A simple example using std::sort

Edit: As Kirill V. Lyadvinsky pointed out, instead of supplying a sort predicate, you can implement the operator< for MyStruct:
Using this method means you can simply sort the vector as follows:
Edit2: As Kappa suggests you can also sort the vector in the descending order by overloading a > operator and changing call of sort a bit: 
And you should call sort as:
",320,42748144
26295515,"
In the interest of coverage.  I put forward an implementation using lambda expressions.
C++11
C++14
",131,42748144
1380481,"
You could use functor as third argument of std::sort, or you could define operator< in your class.
",52,42748144
1380488,"
You are on the right track.  std::sort will use operator< as comparison function by default.  So in order to sort your objects, you will either have to overload bool operator<( const T&, const T& ) or provide a functor that does the comparison, much like this:
The advantage of the usage of a functor is that you can use a function with access to the class' private members.
",13,42748144
37334886,"
Sorting such a vector or any other applicable (mutable input iterator) range of custom objects of type X can be achieved using various methods, especially including the use of standard library algorithms like 

sort, 
stable_sort, 
partial_sort or
partial_sort_copy.

Since most of the techniques, to obtain relative ordering of X elements, have already been posted, I'll start by some notes on ""why"" and ""when"" to use the various approaches.
The ""best"" approach will depend on different factors:

Is sorting ranges of X objects a common or a rare task (will such ranges be sorted a mutiple different places in the program or by library users)?
Is the required sorting ""natural"" (expected) or are there multiple ways the type could be compared to itself?
Is performance an issue or should sorting ranges of X objects be foolproof?

If sorting ranges of X is a common task and the achieved sorting is to be expected (i.e. X just wraps a single fundamental value) then on would probably go for overloading operator< since it enables sorting without any fuzz (like correctly passing proper comparators) and repeatedly yields expected results.
If sorting is a common task or likely to be required in different contexts, but there are multiple criteria which can be used to sort X objects, I'd go for Functors (overloaded operator() functions of custom classes) or function pointers (i.e. one functor/function for lexical ordering and another one for natural ordering).
If sorting ranges of type X is uncommon or unlikely in other contexts I tend to use lambdas instead of cluttering any namespace with more functions or types.
This is especially true if the sorting is not ""clear"" or ""natural"" in some way. You can easily get the logic behind the ordering when looking at a lambda that is applied in-place whereas operator< is opague at first sight and you'd have to look the definition up to know what ordering logic will be applied.
Note however, that a single operator< definition is a single point of failure whereas multiple lambas are multiple points of failure and require a more caution.
If the definition of operator< isn't available where the sorting is done / the sort template is compiled, the compiler might be forced to make a function call when comparing objects, instead of inlining the ordering logic which might be a severe drawback (at least when link time optimization/code generation is not applied).
Ways to achieve comparability of class X in order to use standard library sorting algorithms
Let std::vector<X> vec_X; and std::vector<Y> vec_Y;
1. Overload T::operator<(T) or operator<(T, T) and use standard library templates that do not expect a comparison function.
Either overload member operator<:
or free operator<:
2. Use a function pointer with a custom comparison function as sorting function parameter.
3. Create a bool operator()(T, T) overload for a custom type which can be passed as comparison functor.
Those function object definitions can be written a little more generic using C++11 and templates:
which can be used to sort any type with member i supporting <.
4. Pass an anonymus closure (lambda) as comparison parameter to the sorting functions.
Where C++14 enables a even more generic lambda expression:
which could be wrapped in a macro
making ordinary comparator creation quite smooth:
",11,42748144
1380493,"
Yes, std::sort() with third parameter (function or object) would be easier. An example: 
http://www.cplusplus.com/reference/algorithm/sort/
",4,42748144
1380487,"
In your class, you may overload the ""<"" operator.
",3,42748144
36736713,"
Below is the code using lambdas
#include ""stdafx.h""
#include <vector>
#include <algorithm>

using namespace std;

struct MyStruct
{
    int key;
    std::string stringValue;

    MyStruct(int k, const std::string& s) : key(k), stringValue(s) {}
};

int main()
{
    std::vector < MyStruct > vec;

    vec.push_back(MyStruct(4, ""test""));
    vec.push_back(MyStruct(3, ""a""));
    vec.push_back(MyStruct(2, ""is""));
    vec.push_back(MyStruct(1, ""this""));

    std::sort(vec.begin(), vec.end(), 
        [] (const MyStruct& struct1, const MyStruct& struct2)
        {
            return (struct1.key < struct2.key);
        }
    );
    return 0;
}

",2,42748144
50040873,"
I was curious if there is any measurable impact on performance between the various ways one can call std::sort, so I've created this simple test:
What it does is it creates a random vector, and then measures how much time is required to copy it and sort the copy of it (and compute some checksum to avoid too vigorous dead code elimination).
I was compiling with g++ (GCC) 7.2.1 20170829 (Red Hat 7.2.1-1)
Here are results:
Looks like all the options except for passing function pointer are very similar, and passing a function pointer causes +30% penalty. 
It also looks like the operator< version is ~1% slower (I repeated the test multiple times and the effect persists), which is a bit strange as it suggests that the generated code is different (I lack skill to analyze --save-temps output).
",2,42748144
20763862,"
",1,42748144
45567530,"
You can use user defined comparator class.
",1,42748144
38730028,"
To sort a vector you can use the sort() algorithm in .
The third parameter used can be greater or less or any function or object can also be used. However the default operator is < if you leave third parameter empty.
",0,42748144
45992778,"
if compare is false, it will do ""swap"".
",0,42748144
42725281,"
You have an array of size 11, but you do loop over 10 elements only, leaving the first element uninitialized. That means that it contains junk (undefined behavior), in that case 1606416304, which is the max, isn't it? =)
Change your loops from:
to:
std::minmaxelement() then shall as you want it to work.

Aftermath:
In general, one common mistake when working with functions that give you something different than the expected result is to check your data you give that function. That way you know whether the data have the problem or/and the function. In your case, printing the array would have make you understand that your data were not OK! 
",7,42725205
42725255,"
finds the min/max indeed, but the array indexing in C++ starts at 0. You fill int pan[11]; starting from the 1 index,
so pan[0] will contain junk which (in your case the value 1606416304) will be considered by the minmax_element. 
In fact, reading from an un-initialized variable is undefined behaviour in C and C++, anything can happen, although most of the time you just read what happened to be stored at that memory address.
If you use C++11 (which you should by now), then you can also use a range-based for loop to process the pancakes :)
and
",9,42725205
42725291,"
Your pan array is defined as having 11 elements, but you only initialize 10 of them. Of note, pan[0] is never initialized, and will have some random value. I'm guessing your random value happened to be 1606416304.
",2,42725205
42722145,"
You might use std::partition (or std::stable_partition):
",0,42721344
42711486,"
The counter is in the wrong place. Your assignment is to count basic operations. What is a basic operation in sorting? Typically we count the number of compare operations to measure complexity of sort. 
We know that QuickSort is O(N Log N) on average where N is the number of items being sorted, while worst case it is O(N^2). 
Your numbers are smaller than N, which is not possible since each of the N items must be compared to some other elemnt at least once, the cost of sorting cannot be less than N (otherwise at least one element was not compared to anything, so you could not guaranteed that it is sorted).
In your algorithm, the compare operation occurs when you compare the elements of the array to the pivot value. So increment your counter every time you compare an array element to Pivot. Your measured numbers should be at least N, and will typically be about N*log N, and rarely be be close to N^2.
See the suggested points below in SplitArray where to increment counter:
No change to swap:
SplitArray does the comparisons, so the counter should be incremented here:
",0,42710726
42688386,"
I fixed it, 
Apparently the for loop wasn't even executing, but the above seems to work.
",0,42687400
44119245,"
You can do this in time O(nlogn) and even better O(n).
O(nlogn) approach:
1.Sort the elements in time O(nlogn) time.
2.For each element movies[i], apply binary search in array from position i+1 till end of the array to search element k - movies[i].
3.If found, you have your tuple since movies[i] + (k - movies[i]) = k
O(n) approach:
1.Store all the elements in a hashtable.
2.For each element movies[i], search k - movies[i] in hashtable, if found you have your tuple.
3.Since search in hashtable takes O(1) time, this approach takes time O(n).
",3,44118732
44107518,"
EDIT: Now that I have reread(and edited) your question, it seems you have tasked yourself with implementing a dumbed down version of one of the overloads of std::sort. Note that if you are just required to use templates in any way possible, making a class template would be much easier. The rest of this answer was written as if your professor had explicitly asked you to implement such a sorting algorithm.
I think the point of your assignment is to get you to understand the use of custom comparison functions(also known as predicates or comparators) in sorting algorithms. You pass in one function for comparing based on Data::x_ and another for comparing based on Data::y_.
Here is an example:
The sorting function is admittedly crap, but you should get the idea. If you aren't allowed to use C++11 for some reason, you can manually define functors like this:
and use them like this:
You would also have to get rid of the autos.
Note that if you are doing this outside of an assignment, you should probably use std::sort, as it is structured exactly the same way(except with a much better implementation). e.g.
The output of the example is:
",3,44103293
44093502,"
Some Problems:
1) The only place the function takes any data is if head is null. Take the input code out of the if statement, and debug from there.
2) To take more than one node, then you need some sort of loop. Best to place that loop, along with the input code you just removed above, into a main function:
For the rest of the code that we are not seeing, best to use a debugger and try to understand what each control path is doing.
",1,44093409
44028053,"
the working code with changes is
#include<iostream>
#include<fstream>
#include<cstdlib>
using namespace std;
int main()
{
    int *x, size, temp;
    cout << ""Enter the size of array\n"";
    cin >> size;
    x = new int[size];
    for (int i = 0; i < size; i++)
    {
        cin >> x[i];
    }
    cout << ""\nData before sorting: "";
    for (int j = 0; j < size; j++)
    {
        cout << x[j] << ' ';
    }
    for (int i = 0; i < size; i++)
    {
        for (int j = 0; j < size-1; j++)
        {
            if (x[j] > x[j + 1])
            {
                temp = x[j];
                x[j] = x[j + 1];
                x[j + 1] = temp;
            }
        }
    }
    cout << ""\nData after sorting: "";
    for (int j = 0; j < size; j++)
    {
        cout << x[j] << ' ';
    }
    cin >> temp;
}

changed ""size"" to ""size-1"" in loop statement to avoid access to un-allocated array members
",0,44027257
44028106,"
The for loop should be corrected so that j runs till size - 1 & i runs till size. Else you gobble up one number in an unnecessary comparison with non-existent numbers thus displaying zero or garbage number in some cases.
Following for loop replaced into your program fixes your issue.
",0,44027257
44025528,"
C++ can not sort values based on their names, only based on values, so you have to provide a mapping to the order you want it sorted. Either use a table, or a ranking function like:
And now std::sort(v.begin(), v.end()) should work for a vector of MyEnums.
You can turn the operator< into a functor and pass it to sort, if you don't want the enums compared this way other than in the sorting.
",0,44022094
44011467,"
If we don't need an efficient algorithm, we can simply implement the selection sort.
",1,44007289
44007955,"
You can't sort a map by value.
Because std::map organizes the entries by key in order to do it's job (like O(log n) lookup and insertion), there is no way to change this behavior.
What you can do, however, is use a std::set<YourType> where YourType is a tuple (like std::pair or a custom type as shown below) and you provide your custom comparison operator such that the set is organized by value.
",-3,44007289
43947864,"
What you are asking for is lexicographical ordering that basically amounts to saying the comparison (x1, y1) < (x2, y2) is equivalent to saying if (x1 < x2 || (x1 == x2 && y1 < y2))
The body of your Coordinate::operator< can be modified as follows:
We return false at the end because we are performing strict less-than comparison. When we've reached that line we know that all the elements of both coordinates are identical, so if we return true then we've satisfied <= instead.
However, I would propose that you update this code to use more modern C++. Namely vectors and arrays. This is nice especially because the default operator< for a std::array will perform lexicographical ordering for you. (Additionally you don't have to worry about pointer math because you get to use iterators).
Here is your new class:
And here's how you'd implement operator<:
And finally main:
Prefer the templates for Coordinate so that you can make coordinates of arbitrary dimensionality at compile-time. Right now there is a lot of magic numbering going on to make it all work.
Here's a live demo
",1,43936023
43937057,"
I've found the answer and I'm posting here for posterity's sake.
The sorting criterion must define strict weak ordering, which is defined by the following four properties
Accordingly I've re-implemented operator< as follows. 
Note: implementation intentionally suboptimal for sake of clarity. (Comparisons should ideally be done once and cached.)
",0,43936023
43929606,"
In idomatic C++ what you're trying to do can be achieved like so using the std::sort algorthim:
",2,43929447
43929471,"
You seem to be confused about how scope works in C++.  You defined an array in main() called xpPoints, but it is local to that function.  Simply calling a function which sorts another array has no effect on your local xpPoints array.  Hence, when you print the first element nothing has changed.
To remedy this, you can refactor xpPoints_Sorting() such that it takes an array as input and then sorts it, e.g.:
And then in your main() function:
",2,43929447
43911515,"
If I understand you, your problem is that you want to sort your frequency vector, but that then you lose track of their corresponding word. As suggested, using a struct with a custom comparison function is probably desirable:
Now, having a std::vector<word_freq> wf; and applying std::sort(wf.begin(), wf.end()) should order your list min -> max. To print the k words with highest frequency you would print from the back of the wf list.
",0,43903692
43897770,"
It's answered here Difference between pointer and reference as thread parameter. Thread deduces argument types and stores them by value. That's why references won't work and you should use pointer.
",0,43897403
43887075,"
You cannot pass function template pointer in c++, what you can do is to create functor with operator() template (something very similar to lambda with auto parameters):
[live demo]
Remember that operator must have const qualifier to make caller to be able to access to it from temporary object.
",2,43884538
43884667,"
Basically what you need is a higher order function: a function that returns a function.
Here I have T be explicitly specified; you might be able with extra programming to deduce T but it can be quite tricky to make it work correctly for both function objects and function pointers.
Edit: to make this work in C++03, we have to obviously remove our usage of lambdas. Converting a lambda to a function object is pretty straightforward though. We declare a struct:
Edit: I templated the call operator in the 03 example; to do this with a lambda you need C++14, not just 11. If you are using the 03 form, then you don't need to explicitly specify <int> to make_pointee_comparison.
Usage:
Which prints 10 (true false). Note that this takes a function object rather than a function pointer, which is more idiomatic in C++. But you can pass a function pointer too:
You could then write your function like this:
",5,43884538
43885085,"
guess you are looking for something like this:
You are trying to pass value of type comparison_function to a template expecting type.
",0,43884538
43862904,"
I'm not sure if this solves it completely, but after sorting the left part, you still need to sort the right part, but you already return instead.
Also, passing the vector by value and returning it is overhead and not needed, because in the end there should only be one version of the vector, so passing by reference is preferred.  Passing by value and returning is sometimes needed when doing recursion, especially when backtracking (looking for different paths), but not in this case where left and right provide the needed state.
",2,43862642
43881977,"
I was able to solve this following Igor's suggestion about using a custom type (instead of int, which I was using earlier) and instrumenting the custom copy/move constructors/assignment operators. I also added an instrumented custom swap() function for the type, which simplified the std::swap() function template specialization.
Now, I get the following output:
If the move constructor/assignment-operators are not defined, the Moves counts above show up under Copies.
The following code works:
",0,43860495
43834530,"
auto row is an iterator. That iterator's operator[] does not call the according operator on the pointed-to element but returns the element that the iterator would point to if it were incremented by the given operand. Hence, the statement row[1] may try to dereference the end() iterator of the vector, which is not possible. What you want to do is this:
You should also write your comparison predicate in a way that uses the second entry whenever the first entries are equal.
",1,43834458
43833417,"
You need to modify your sort part like this. Assuming you are sorting in desc order.
Also you might need to edit variable type of team name as it can be string.
As you are using C++ there is a one liner function that you can use to sort 
Also you can simply write the comparator inside the struct and then use the sort function:
",0,43833113
43833760,"
I'm curious about why you include algorithm but do not use any of it. Do you know STL? Since you include algorithm, I guess you may know some simple functions such as swap, sort and copy. They are easy to use, you just need to type one line instead of writing a bubble sort by yourself. Before you use the sort function, you should define which order can take effect on these teams. Just like this:
The code above defines a direction we consider to sort the teams, first we sort them by scores, if both of the scores are equal, then we sort them by their names.
Finally We can use the sort function which is ready-made in STL. Now the order we defined can be used. (I guess the array v[] stands for the teams. Am I right?)
",0,43833113
43817164,"
this works like charm
#include<iostream>
#include <stdio.h>
#include <math.h>
#include <vector>
#include <algorithm>
#include <time.h>

void bubbleSort(int arr[], int size)
{

    int i, j;
    for (i = (size - 1); i >= 0; i--)
    {

        for (j = 1; j <= i; j++)
        {
            if (arr[j - 1]>arr[j])
            {
                int temp = arr[j - 1];
                arr[j - 1] = arr[j];
                arr[j] = temp;
            }
        }
    }
}

void selectionSort(int arr1[], int size)
{

    int i = 0, j = 0;

    for (i = 0; i<size - 1; i++)
    {
        int min = j;
        for (j = i + 1; j<size; j++)
        {
            if (arr1[j]<arr1[min])
            {
                min = j;
            }
        }
        int temp = arr1[i];
        arr1[i] = arr1[min];
        arr1[min] = temp;
    }
}

void insertionSort(int arr2[], int size)
{

    for (int i = 1; i<size; i++)
    {
        int index = arr2[i];
        int j = i;
        while (j>0 && arr2[j - 1]>index)
        {
            arr2[j] = arr2[j - 1];
            j--;
        }
        arr2[j] = index;
    }
}

using namespace std;

void main()
{
    char t = 'f';
    char *t1;
    char **t2;

    int choice, choose, temp;
    const int  size = 10000;
    int  arr[size], arr1[size], arr2[size];

    for (int i = 0; i < size; i++) {
        temp = rand();
        arr[i] = temp;
        arr1[i] = temp;
        arr2[i] = temp;
    }

    do {
        std::cout << ""\n\nWelcome to the algortihm tester!\n"";
        std::cout << ""What algorithm would you like to test?"";
        std::cout << ""\nChoose: \n1.Bubble Sort\n2.Selection Sort\n3.Insertion Sort\n"";
        std::cout << ""\nNumber of choice: "";
        cin >> choice;

        switch (choice)
        {
        case 1:
        {
            clock_t tStart = clock();
            bubbleSort(arr,size);
            printf(""Time taken: %.2fs\n"", (double)(clock() - tStart) / CLOCKS_PER_SEC);
        }
        break;


        //bubble sort
        case 2:
        {
            clock_t tStart = clock();
            selectionSort(arr1, size);
            printf(""Time taken: %.2fs\n"", (double)(clock() - tStart) / CLOCKS_PER_SEC);
        }
        break;
        case 3:
        {
            clock_t tStart = clock();
            insertionSort(arr2, size);
            printf(""Time taken: %.2fs\n"", (double)(clock() - tStart) / CLOCKS_PER_SEC);
        }
        break;
        }

        printf(""\nDo you want to test the other algorithms?:<1-Yes/0-No>: "");
        cin >> choose;
    } while (choose != 0);
}

I think Insertion is the fastest
",0,43816240
43816282,"
Your int arr [] is the same as int *. It doesn't carry array size information.
You'll need to pass the number of elements in the array separately.
edit: you're probably getting sizeof( pointer ) = 8 sizeof( element being int ) = 4 yielding a length of 2. Not what you're intending at all.
",0,43816240
43816550,"
You are using an unnecessarily convoluted way of creating arrays.
Use #define N if you want to dynamically change array size when coding. It's much simpler for testing.
You can use setprecision with cout if you want to set how many digits print. Check it out, it's really nifty: http://www.cplusplus.com/reference/iomanip/setprecision/ It also helps keeping things uniform.
If you want better randoms, you can use srand(time(NULL)); It basically uses system time as a seed to generate random numbers. It's not perfect, but it's a step up.
",0,43816240
43795757,"
pairs is raw array, not a STL container; you can't invoke method on it like pairs.begin() and pairs.end().
Since C++11 you could use std::begin() and std::end(), which are overloaded for supporting raw arrays. e.g.
",1,43795735
43788730,"
Perhaps it makes more sense to first restructure your code and convert four vectors into one vectors of structures.
Something like that:
Then, if you want to sort by radius:
Output:
This code uses std::sort with custom function that compares two circles. To compare by radius you'd need to update it to compare c1.weight with c2.weight.
",0,43788429
43788792,"
With ranges-v3, you may do something like
Demo
But having class Circle would make sense, that would avoid to zip the arrays, and allow to have a shorter projection.
",0,43788429
43789153,"
You can create a 5th vector of indices, sort the vector of indices according to one of the 4 vectors, then reorder all 4 vectors (and also sort the vector of indices) in O(n) time. Example to sort 3 vectors according to one of them (the ages vector). The vector of indices I is created then sorted according to A (using lambda compare), then all 3 vectors and I are reordered according to I by undoing the ""cycles"" in I.
",0,43788429
43775126,"
Are duplicates allowed? 
If no duplicates are allowed, use std::set, otherwise use std::multiset. set and multiset will keep your elements sorted all the time, and every insertion will go in the right, ordered place. You don't have to worry about when to sort them.
Having everything sorted during insertions is effectively cheaper, because when you have to search, you don't have to compare with all the elements, but only a subset of them.
",1,43774977
43776971,"
Use std::multiset. It would be simple and clean:
You can try it: http://ideone.com/moD3bg
The complexity of all operations with multiset is O(nlogk). But don't remember that complexity of printing all this data is O(n*k).  
",1,43774977
43799747,"
Just another approach to solve this problem :
",0,43774977
43738861,"
You are on the right way and your code needs only a little tweeking. Others have given valuable suggestions, most of which I won't repeat.
First the definition of your LinearSort(). You are passing a number of variables (i..k) that we call local variables and that should not be passed. Local variables are only used by your function and are declared inside the function. The proper definition now becomes:
Then you must call it from your main, after you read all the data. Call it like:
You passs 10 for a because you read a fixed number of integers; would you have read an arbitrary number (but less than 50), you would have passed a variable with this amount. 
For your information: you pass the array variable sort[] but note that this name sort is the same in your main and in your function. There is no need and this just coincidence.
As for the sort algorithm, it seems based on bubble sort but uses for-loops. That is at least unusual and probaby wrong; the outer loop must go as many times as is needed until no more elements have been exchanged; however, a for loop normally executes a fixed number of times, so you see why this is probably wrong. I suggest you read about bubble sort.
",0,43737616
43738056,"
First, remove this statement 
As you have already declared the function in header file and header is included in all files.
you should call LinearSort() with proper argument in your main() , after scanf() . And in your LinearSort() function, like this 
And in LinearSort(), inside for loop,i don't see any specific use of else statement.
",-2,43737616
43727298,"
Since after each swap it does j--, after the final swap (which frees up v[j]), it decreases j once more. Hence you need to put the new element at v[j + 1].
By the way, swap is not necessary for this code, you might as well do v[j + 1] = v[j] instead of swap.
Edit
Regarding the question on implementation, perhaps the author was making a some point which needed the swap - without knowing the context, we can't say for sure.
Since no one really uses insertion sort, I reckon the purpose of this was only theoretical, and likely to compute complexity by counting number of swaps. Hence the author may have been demonstrating the sort with swap as a building block.
Back to the question,

the implementation is correct, if you are okay with the extra writes that swap does.

(Essentially swap(a, b) is t = a; a = b; b = t;, so two additional writes.)

If you do have the swap, then the commented out line is indeed not necessary.

Without the swap you may rewrite it as -
Note that since this reduces asymptotic time taken by only a constant, complexity still remain the same as the one with swap, i.e. $O(n^2)$.
",2,43727260
43721184,"


This line causes undefined behaviour. &p is the address of the local p pointer object, not the location of the array where that object points to. &p + n then performs illegal pointer arithmetics with the address of the local object.
You should do it like this:
And of course, all of this is ultimately an exercise in futility, because you should just use std::vector anyway, and then it becomes:
",4,43721094
43701982,"
You will want to use a vector of pairs.  This is in this case more convenient than a map because you want to sort by value rather than by key.  There are also methods to sort a map by value (see question Sorting std::map using value), but for this purpose a vector of pairs seems appropriate.
If you want to have a constant memory array instead of a dynamic memory array (std::vector) then use std::array<std::pair<std::string,int>, N>, where N is the number of elements.
Needs C++14 because of the template lambda.
",1,43701915
43700414,"
The main problem you're seeing is random garbage on the output. Stepping through the code with the debugger, you can see this happens even before the sort, as you (try to) output the values before calling the sort method.
That problem is caused by the line cout << id.ID + "" "";.
What you want is cout << id.ID << "" "";
Perhaps not the easiest thing to spot with the debugger; hopefully you'll have better luck fixing the sort itself.
",0,43699478
43681554,"
First of all, don't use so slow implementation of sorting algorithm (O(N^2) is a very slow). I'd recommend to do something like this:
1) Extend Book class by comparison operator:
2) Call standard sort function:
After it you can extend operator< to take into account other properties of a Book (don't forget that std::sort requires a strict weak ordeing comparison).
Another way (in case if it is impossible to modify class Book):
1) Create a function
2) And call it this way:
In this case you will extend the function Greater to support other properties of a Book.
",2,43681384
43682313,"
As addition to @Ilya if you're able to use c++11 you can pass simple comparing lambdas to std::sort
and then just use it like
",1,43681384
43682405,"
As @Beta mentioned, a function pointer could be used here:
UPDATE:
Inspired by @llya, you may also extend Book (or just edit the source code if you could) and create a compare function accepts a key argument like this:
And the usage would be something like this:
",0,43681384
43671675,"
So what I did was I passed count by reference and changed the functions' return type to void, and it works perfectly now. I have to pass in count and have it ""returned"" somehow since it is called recursively. So to accomplish that, instead of the functions returning anything, I just passed count by reference.
",0,43671310
43626514,"
The best solution would be probably to create a struct that contains the values or use a std::tuple, put instances of it in a vector and sort the latter, thus getting rid of all the other arrays.
If you can't do that, you can introduce one layer of indirection that is an array of indices (actually a lookup array).
Order it according with your policy and never change the positions of the items in the other arrays. Whenever you want to get the i-th tuple of elements, get the i-th element from the array of indices and use it to get the right values from all the other arrays.
You won't have problem if you add more and more arrays in the future, as long as you create them implicitly ordered somehow each in respect to the other.
When you add a new tuple, simply push at the end of the array of indices the size of the other arrays (I assume all of them have the same size): that will be the index of the new elements. Then sort again the array of indices if needed.
Sort function probably requires you to pass a comparison function that has access to the outer arrays, but that's quite simple to do with lambdas and capture by reference.
",3,43626245
43631626,"
Actually I would suggest to use data structures that tie together the tuples spread over individual arrays, like a struct or a tuple.
But one could make use of the fact that a sorting algorithm like qsort uses a custom comparison function to decide whether to swap two values or not.
Given that, one could define a comparison function that, besides returning the result of the comparison, has side effects in the sense of ""manually"" swapping values in other arrays. 
I know that it is ugly, as it relies on the internals of sorting algorithm qsort, and I am not completely sure if I miss something essential (and I will not cry if somebody downvotes the answer for that reason). But maybe it can be a help in very exceptional cases:
",1,43626245
43628285,"
With range-v3, you may do
Demo
",0,43626245
43603305,"

Move strings containing <cr> into a different container.
Sort the rest of the strings.
Sort the containers holding the strings containing <cr>
Add the second containers items at the end of first list

Moreover, instead of using separate containers, you can move the strings containing <cr> at end of the list (std::partition) and apply qsort on the two subarrays differently.
And now:
",3,43603268
43603902,"
I'm not sure about your actual setting, because vector is a C++ type, whereas you state that you want to use C.
Anyway, maybe the following code written for std::vector in combination with std::sort shows the basic principle, where you introduce a custom comparison function for sorting. Note that qsort allows custom comparison functions, too, yet the syntax will be different.
The custom comparison function works as follows: if both strings start with <, then their remainders are compared. If one of them starts with <, then this one is always ranked below the other. Otherwise, they are simply compared. I used char*-data type to keep up some flavour of C for you :-) :
Output:
",0,43603268
43595114,"
You need to maintain another matrix which has indices of every line and then apply the same operations on it that you are applying on each line of the original matrix to sort it.
Here is the code:
",0,43589635
43585571,"
There are many problems with this code.

while(eof) is wrong.
The main loop expects exactly 100000 elements.
All key comparisons are exact (<, >). There are no rotations performed when a duplicate element is inserted. Thus a tree of identical elements will not be balanced at all.
The height of an empty tree is hardcoded to -1, but the height of a single-node three is initially set to 1, thus violating the invariant height(node) = 1+max(height(node->leftChild))+height(node->rightChild)). 
height traverses the entire tree every time it is called, thus making insertion O(n).

",5,43580076
43586140,"
So, it seems to me that the reason that it was taking so long was because of too many recursive calls all over the place. This modified code has less recursive calls and thus bogs down the CPU with less stacks to have to process. At least, that's what I'm getting out of this.    
",0,43580076
43581711,"
You can define a comparator class that takes a and b as constructor arguments:
and later pass its instance to the sort function:
",1,43579246
43557957,"
You cannot sort with a comparison function like that, because the sorting rules it defines are internally inconsistent. In order to sort, X < Y must imply that Y < X is false.
Consider these two objects:
No matter how you compare them, X > Y or Y > X, you would get true, because X.a > Y.b and Y.a > X.b.
Even X > X and Y > Y would produce true, which must never happen.
For that reason, you should define your comparison rules in terms of comparing the same attributes. Otherwise, you will break reflexivity and transitivity rules.
",2,43557771
43557859,"
What if a < b? You can solve this problem more robustly and concisely:
",1,43557771
43555071,"
You can't pass a full array as an argument to a c++ function, only a pointer to the first element in the array. As a result you need some way to tell the function how long the array is. One way it to pass that in as another argument (as shown below). There is some discussion and suggestions of other/better ways to do it here.
For example if you accidentally pass in the wrong length argument to these functions they will start operating on whatever memory exists after the block of memory where your array is.
",1,43554932
43548169,"
The best way to ""debug"" this kind of problems is to use a performance profiler tool, however in this case I think I can give you a good hypothesis:

Insertion sort is an ""in place"" algorithm, no memory allocations are required.
Your AVL tree requires many memory allocations, and these are expensive

In summary, your comparison is not ""fair"".
How to ""fix"" this?:

Experiment with memory management libraries, like Boost.Pool. 

As an example, if you know in advance how many nodes your tree will have, you can allocate all the required nodes at once at the beginning of your algorithm, and create a pool of nodes with them (if you use Boost this should  be a lot faster than calling the standard new operator every time, one by one). 
Every time you need a new node, you take it from the pool. You can then ""compare"" the algorithms from the point where no additional memory allocations will be required.
",1,43547996
43547229,"
Use std::sort with your own comparator. I would solve it like this: 
",-1,43547188
43525260,"
Try to change your input loop:
Can you provide sample input that you use and what output you expect?
",0,43524228
43483781,"

I have following error: ""Error C2065 'compareById': undeclared identifier""

Like always, compareById must be declared before you use it.  (Unless it's a member of the same class as an in-class function, but it doesn't seem to be a class member at all.)

It is illigal when i want to execute this method on const object

Sounds like you just need to make your function a const member function.  Declare it like
and you will be allowed to call it on const objects.
",1,43483745
43476210,"
I assume you know how to read a file in C++, if not, please look at it, for example on this tutorial.  
For the sorting part, you could use a STL container
to store the ids. I would recommend a map with the id as key and the string as value. 
The advantage of the map, is that it's already sorted (ascending order).
If you use another container, you should look at the sorting algorithms if you want to understand how they work. For instance bubble sort, selection sort, quick sort or merge sort for the main ones. 
However if you want to sort without any implementation, have a look at this.
This doesn't provide you a specific answer for your problem, but it can help you start.
[UPDATE]
I didn't read correctly and I haven't seen that multiple lines could have the same ID. A map would not necessarily be the most suitable container. 
",1,43474663
43466841,"
Sorting the vector can be done using std::sort and finding the range of elements that have the specified weight can be done with std::equal_range.
However, as Daniel pointed out in the comment, it is likely that getASpecificWeight() returns a double and not a Structure, so in order to call equal_range we either need to create a dummy Structure or a function object that compares doubles to Structures with the desired semantics. A single lambda doesn't work because the binary search needs to be able to compare Structures to weights both ways.
Alternative 1:  Using a dummy Structure
So first, lets create a dummy Structure, since this is less code.
In total, it might look something like this
If you need to modify the elements in the structures vector, you can replace cbegin and cend in the call to std::equal_range and the if-condition by begin/end respectively.   
Alternative 2: Handcrafted function object
However, I personally don't think creating the dummy struct is very clean, so lets see how a custom function object would improve the code.
The function object itself can be defined as
Then the code would look like this:
Alternative 3: Using Boost.Functional/OverloadedFunction
As you can see I'm bad at naming things, so having to name the function object used to compare Structures to weights is kind of awkward, in particular if it only used in this single place. If you have access to Boost, in particular to Boost.Functional/OverloadedFunction, you can use two lambdas instead of the handcrafted function object. 
The code then looks like this:
",1,43466570
43442346,"
The value_type of the iterators returned by m.begin() and m.end() is a std::vector<int>. Hence, your lambda needs to take that type for both of its parameters.
Note: I am using the at() member function here rather than operator [] to prevent UB should you ever mistakenly attempt to sort by in invalid index.
Demo
",3,43442312
43442349,"
When you want to sort a std::vector<std::vector<int>>, the items of the container are of type std::vector<int>, not int. Hence, you cannot use a lambda with the declaration
to sort such a container. You need to use a lambda with the declaration
or
Using the first version is expensive since it will end up making copies of std::vector for each call to the lambda. Hence, it is recommended to use the second version.
",2,43442312
43442438,"
Although not the most efficient solution, the simplest thing to do would be to transpose your 2D vector (aka matrix) sort each vector and then transpose again. Here is a tested, working function that will do this for you:
Again this isn't the most efficient or the most modern way to sort a matrix by columns but it works and is simple to understand.
",0,43442312
43455436,"
So what you want is a C++ implementation of a Schwartzian transform. I don't have a simple solution in a few lines of code, but I did implement a Schwartzian transform utility in a C++14 library of mine. Unfortunately it relies on proxy iterators, which aren't handled by std::sort (at least not until the Ranges TS), but you can use any other sorter from the library instead. Here is how you could write the sort function mentioned in your question:
When called this way, the sorter will cross [left, right) and create std::distance(left, right) pairs associating an iterator it to f(*it). Then it will use the passed sorter (default_sorter in the example above, which is a pattern-defeating quicksort at the time of writing) to sort the collection of pairs. Proxy iterators are used under the hood so that elements of the original collection are swapped whenever pairs are swapped.
I wouldn't say it's quite simple, but it should solve your problem. If you don't want to rely on an external library, you can still take inspiration from the soure code. It is under a permissive license, so you can do pretty much whatever you want to with it if you need to use elements from it.
Anyway, it looks like it mostly satifies your requirements:

It doesn't allocate additional instances of T (unless f returns a new instance of T since it stores the return value of f).
It applies f exactly std::distance(left, right) prior to the actual sorting.
It maintains the overall complexity of O(n log n) if used with an O(n log n) sorter.
This latest bullet is the only one not being satisfied: it doesn't use std::sort because std::sort isn't smart enough as of today, but it can use equivalent algorithms without you having to write your own.

",3,43437958
43438282,"
If you want to stick to std::sort just write a comparator that caches the value of your function for every instance of T.
Example:
You can find a complete example here: https://gist.github.com/PandarinDev/ee75b095c4cc256a88496f1985bf57ba
This way evaluate(const Foo&); (f(T) in your case) will only be ran N times, where N = the number of unique instances of Foo.
Edit: As mentioned below in the comments, if the copy of T instances into the map is a problem to you, you can use a unique identifier - such as the address of your object - as a key instead of the object itself.
",0,43437958
43354834,"
I am not sure if I get you right, but what you can do is to measure time before and after call of sorting functions. For time measurement C++ has various tools for example std::high_resolution_clock which I am using in code bellow. You can then observe how sorting algorithms behave on arrays of different sizes. There I wrote you template function which should be usable with every sort you plan to implement(don't forget to include chrono header):
You can call it like this :
Note that you can change precision of duration cast:
",2,43353964
43352694,"
Actually you never get to the point where You assign value to arrC[13] which is the last 14 element. In last iteration for your outer loop i==6 and the same for the inner loop. So you end when i+j is equal to 12.
",3,43352282
43347061,"
You only need to swap the pointers, and just iterate from 0 to 2, because you are comparing with the next value i+1
Working code
Note: 
I used strncmp because it is more safe, you can specify n: Maximum number of characters to compare.
",1,43346459
43347553,"
Smaller inner loop than before. A argument for the size of the array.
",0,43346459
43348295,"
For starters this declaration
declares an array of pointers to first characters of string literals. In C++ string literals have types of constant character arrays so a correct declaration of the array should look like
To sort the array means to rearrange the elements of the array that is the pointers. The string literals themselves will be unchanged. All you need is to swap pointers to string literals not the string literals. Moreover string literals are immutable. So in any case you may not do what you are trying to do in the program shown in your question. You could do that if instead of the array of pointers to string literals you used a two dimensional array of strings. That is if the array would be declared for example like
You could use standard C++ algorithm std::sort. For example
The program output is
If you want to use the bubble sort method to sort the array then the program can look like
The program output is the same as it is shown above that is
",0,43346459
43347832,"
The problem was very trivial. I wasn't printing final array...
",0,43346421
45113400,"
I coded up a pretty straight forward implementation of your algorithm: 
I'm not sure what the exact algorithmic complexity is, but you can see two things: 

At the beginning, there are very few collisions, so the inner loop doesn't actually depend on T, so it behaves more like O(N*k) (where k is the average number of times you can assign a particular score).
Even if N grows very large, not all scores can actually be processed, because the algorithm can terminate early and compares the latest free day against the earliest da a score can be assigned to.

Of course, you can create an worst case input, where you have T*(T+1)/2 passes of the inner loop (for N == T and k = 1 and min_i = 1) but my gut feeling is that on average it is much better than O(N*T) or at least has a very small constant (actually, the sort could be the dominant factor).
Long story short: I'm pretty confident that your algorithm is in fact applicable in practice and could probably be further improved by more intelligent data structures as suggested by Prune.
",1,45108935
45111736,"
If you maintain a table of available intervals, I believe that you can keep this to O(N + T).  Don't range through the entire length T each time; just check your list of open intervals and begin at the first available interval that contains the input line's Y value.  There will be no more than N/2 intervals in this ""open"" list, and either hashing or a binary search can keep the complexity under control.
",0,45108935
45100697,"
If you store the available days in an ordered set, then you can perform your algorithm much faster.
For example, C++ provides an ordered set with a lower_bound method that will find in O(logn) time the first available day after the starting time.
Overall this should give an O(nlogn) algorithm where n = T+input_size.
For example, I suspect that when you have your 4 tasks of penalty 120 to assign from day 3 onwards, your current code will loop over days 3,4,5,etc. until you find a day that has not been assigned.   You can now replace this O(n) loop with a single O(logn) call to lower_bound to find the first unassigned day.  When you greedily assign the days, you should also remove them from the set so they won't be assigned twice.
Note that there are only T days so there will be at most T day assignments.  For example, suppose all tasks have starting time 1, and quantity T.  Then the first task will take O(Tlogn) time to assign, but all subsequent tasks will only need a single call to lower_bound (because there are no days left to assign), so will take O(logn) each.
",0,45099645
45088120,"
You are using values in a to merge, but you are putting sorted subarrays in na. The merge operation will only give you a sorted array if the subarrays are sorted. As BLUEPIXY suggests, you need to be using one container for storing sorted subarrays and for merging sorted subarrays: whether you use a or na for that purpose is immaterial but a would be the better choice since you already have it.
",0,45087659
45088245,"

Try to read the guidelines for asking a question on StackOverflow.
In mergeSort , you are merging unsorted arrays instead of the sorted ones (void merge_sort(int a[], int p, int r) : since you are merging a[], you should sort a[] and not na[]).

Otherwise merge segments of na[] and copy it to a[] in each function call to merge_sort(:);
",0,45087659
45071031,"
The Comparer function is supposed to return true if the first item in the parameter list is placed before the second parameter when the list is sorted, false otherwise
Unfortunately, your Comparer function doesn't return true or false.  Instead it is returning the value of calling the std::string::compare function, which returns -1, 0, or 1 depending on the results of the comparison.
To fix your function, do this:
That will return true if s1.FirstName < s2.FirstName, and false otherwise.
Or simply do this:
",3,45070941
45068836,"
There are a couple possible ways to do this. The easiest way is to wrap name, x, and y in a struct:
Then you can have a std::vector<Person> people and sorting it would be (assuming C++14)

However, if you know that this will cause performance problems due to fewer elements fitting in the cache (that is, you'd frequently iterate over only x or only y and you are in a very constrained environment such as high performance gaming), I'd suggest only sorting one vector. Unless you know what you're doing, you'd need to benchmark both options.
Basically, have a vector that keeps track of the ordering:
Then you can simply iterate over ordering to go through each parallel vector in the new order.
It's possible that the extra level of indirection will make it less efficient. For example, the CPU might think that there's a data dependency where there is none. Furthermore, the extra data we are keeping track of in ordering could easily take enough room in the cache to counteract the benefit of separating name, x, and y; you'd need to know the specifications of your target architecture and profile to be sure.
If you would want to keep iterating over them in this new order, you would want to use this ordering vector to sort the other vectors, because the access to the elements would become random. That would counteract the benefit of keeping the vectors separate (unless the vectors are small enough to fit in the cache anyway).
The easiest way to do that would be to create a new vector:
Reconstructing the vectors like this is probably what you want to do if the sorting happens during initialization.
",4,45068782
45068948,"
It sounds like you want a struct to keep the data together. For example:
From there, you'll want a comparison function to do a custom sort that ensures you are sorting from the field you want to sort by:
",1,45068782
45048794,"
In C++, all types are throwable and catchable, but you are only catching subclasses of std::exception.
The best fix to your code would be changing your throw statement to:
",2,45048539
45048841,"
If you want to catch an exception, you should throw an exception, not a const char*.
See this answer: c++ exception : throwing std::string
",0,45048539
45048778,"
You're throwing a const char* not an std::exception. So catch it as a const char*:
Or throw an std::exception.
Remember that you can throw many types and have many catch blocks, the one that will be invoked is the one that matches the type of the thrown exception.
",0,45048539
45002123,"
Most typical systems use ASCII or some derivative of it. In ASCII, all the lower case letters come after all the upper case letters, so 'A' < 'Z', and 'a' < 'z' and (the part you may not have previously expected,  'Z' < 'a'. That is, the order (with some others interspersed in between) is A..Za..z.
When alphabetizing, most people (apparently including you) would generally prefer something like AaBbCc...Zz instead.
We could implement this with a table specifying the relative order we want--but this requirement is common enough that the standard library already provides for it. std::locale includes a collate facet, which overloads operator() to do a comparison suitable for that locale. That overload will be used automatically by std::sort if we specify the locale as the comparison operator, so we can do something like this:
The ""locale without a name"" selects the locale for which the computer has been configured, so it's typically a fairly save choice. It looks like you're dealing with French, where you also have letters with accents and graves and such. The locale should know how to sort those correctly as well.
If you need to specify sorting for some specific locale (regardless of how the user's computer is configured) you can do that as well. For example, if I wanted to use French-Canadian sorting even though my computer is configured for US English, I could specify:
The exact set of strings that are accepted varies with the compiler. The only ones listed in the standard are ""C"" (which is what you already got by default), and """". It's up to the implementer to decide on what others to support. The ""fr-CA"" I used above is supported by Microsoft's compiler, but if you were using gcc on Linux (for example) you might need to specify some other string to get the same result.
At least with Microsoft's current compiler, either """" or ""fr-CA"" will do to sort these strings as you want them:
For these characters, almost any locale other than ""C"" will probably do the job. If you might have diacritical marks, however, you'll just about need the right locale to get them correct.
",3,44998169
44985305,"
As you know, it is memory that is taking all your time.
Cache misses are bad, but so are stalls.
From this paper:

Applications with irregular memory access patterns, e.g.,dereferencing chains of pointers when traversing linked lists or trees, may not generate enough concurrently outstanding requests to fully utilize the data paths. Nevertheless, such applications are clearly limited by the performance of memory accesses as well. Therefore, considering the bandwidth utilization is not sufficient to detect all memory related performance issues.

Basically, randomly walking pointers can fail to saturate the memory bandwidth.
The tight loop on each is blocked each iteration by waiting on where the next pointer is to be loaded.  If it is not in cache, the cpu can do nothing -- it stalls.
The combined tight loop/merge tries to load two pages into the cache.  When one is loading, sometimes the cpu can advannce on the other.
The result you measured was that the merge has fewer stalls that the naked wasted double iteration.
Or in other words,


is a big number and smaller than:


I am surprised this is enough to make a 10% difference, but that is why perf is about measuring.
",3,44984485
44982055,"

std::sort uses operator< unless specified otherwise.
According to the documentation of std::pair:

http://en.cppreference.com/w/cpp/utility/pair/operator_cmp
Comparison operators, such as < are defined as the lexicographical equivalents:

Compares lhs and rhs lexicographically, that is, compares the first elements and only if they are equivalent, compares the second elements.

In your case, this logic will be applied recursively at each pair level.
",2,44982041
44982757,"
It will sort by first element of the first pair of pairs. In another word, the most left value of pair of pairs.
See this simple example.
",0,44982041
44974040,"
Well, there is not need to create new space at each call of merge.
std::vector<int> L(&array[0], &array[lo]); will actually create space to accomodate lo elements and will perform lo copies as well.
You are never gonna use more then O(n) additional space for storing values. So, why don't you allocate a buffer large enough accommodate the 
a copy of the whole vector upfront and make each recursive call operate on a specific portion of the data? this way you don't have to create new vectors at each call.
Plus, I will also encourage you to make the mergesort works on iterators instead on vector<int> only. An interface like the following should be enough. 
On Github you can find a version of mergesort I have implemented a while ago. It should be enough I guess.
",0,44973765
44974147,"
The only additional memory you need for merge sort is array of size n for merging any of two sorted vectors produced on any step of the algorithm. Obviously, your solution uses more. On first merge it allocates two vectors of n/2 length , then it will be four vectors of n/4 and so all, giving n * log(n) in total. That's slightly more than n.
The cost for allocating vector is generally linear from its length (if copying vector's elements can be done in O(1)), but you should remember that allocating memory on the heap is expensive operation if you did not use custom allocator. Allocating memory may issue a system call, which may use complex algorithms to find the continuous piece of memory to satisfy your requirements. It may even need to move already allocated pieces of memory somewhere else. So there's really no point in allocating memory many times if you can stick with just a single allocation.
",0,44973765
44957194,"
",1,44957144
44957230,"
example:
You should begin from last element array, and decrement iterator (i) to i == 0
",1,44957144
44957331,"
You can simply use a sort function. There is one included with the algorithm header.
the [](int x, int y){return y<x;} part is just to make it descending. Normally it is y>x, at which point you can just omit the third parameter
Here is a repl:
https://repl.it/JQor/0
",-1,44957144
44952686,"
I recommend the following:
1. Create a class or structure with one member for each field.
2. Overload operator>> for your class.
3. Create a std::vector of your class.
4. Read the data file into your std::vector of class objects.  
You can sort the std::vector by writing functors (function objects) that compare by a field, then passing that functor to the std::sort algorithm. 
",2,44952468
44952712,"
Look at regex. You basically need to match the content after the last |.
This pattern should work (working example at regexr.com):
Explanation

\| matches a literal |
(...) creates a capture group (this is the group that you will want to extract)
[...] creates a character set
\d captures digits
\. captures literal .s
+ tells the parser to grab 1 or more of the previous token (in this case, the character group)
$ matches the end of the line
g, m match globally and multi-line, respectively

Thus the entire regex says match starting at a | and then group all digits and . in a capture group until the end of the line.
",1,44952468
44947803,"
You can look into your headers and see which function gets called if the extra buffer isn't available. For me on gcc it is
This is of course not standards compliant. The __inplace_stable_sort is a helper function and is not intended to be used directly.
The call by std::stable_sort to this function is a result of the following code
",14,44947510
44948166,"
Unfortunately there is no standard way to tell stable_sort to do the in-place sort.  In C++14 the only options we have 
C++17 added versions that allow the execution policy as you point out but those will not affect the decision either.  If we look at the complexity requirement in [stable.sort] we get

Complexity: It does at most N log²(N) (where N == last - first) comparisons; if enough extra memory is available, it is N log(N).

So it is mandated to use more memory if it is available.
You're either going to have to write your own and you can see Worst case O(nlnn)O(nln⁡n) in place stable sort? about that or find a library that provides the function for you.
",7,44947510
44914361,"
I think the main issue is statement vector<Node> vec(n), which initialises the vector with n ""empty"" nodes before you additionally add another n nodes with individual values. So if you sort ascending, and then print the first n nodes, it is very likely that you print the ""empty"" ones, i.e. the ones with value 0 (which shine up in the beginning).
So mainly you should write 
Further, as stated by others, a comparison function used for std::sort must meet 
a strict weak ordering relation (cf. cppreference.com):

The return value of the function call operation applied to an object
  of type Compare, when contextually converted to bool, yields true if
  the first argument of the call appears before the second in the strict
  weak ordering relation induced by this Compare type, and false
  otherwise.

This means, among other requirements, that...

For all a, comp(a,a)==false

",0,44914167
44914525,"
Let's go through each mistake:
Issue 1:
You are calling push_back on a vector that has already been sized to n entries.  Thus in the input loop, you're just adding more items to the end of the vector, thus increasing its size.
The correction should be as follows:
Issue 2:
The comparison function for std::sort requires a strict-weak-order.  In other words, your function must uniquely state, when given two items, which item comes first in the sorted order by returning true if the first item comes before the second item, false otherwise.
Your comparison function violates this,  since you return true if A == B, and true again if B == A.  So does A come before B or B come before A?  
Of course, this will not work correctly and will totally throw off the sorting algorithm if you have duplicate items in the vector (this is what Visual C++ debug runtime does to check if you have a valid comparison function -- the comparison function is called twice and checks the return value for both calls).
The correction should be as follows:
Also note the usage of passing by reference instead of by value.
",1,44914167
44904368,"
Actually my recursive quicksort was wrong. While testing with a vector of ints I used a slightly different version, in wich the partitioning of the array was performed in another function. This version is flawed since I'm passing to the recursive quicksort (divide and conquer I understand..) the same high and low indices that are used in the algorithm...so I'm passing the same index...hence no sorting.
",-1,44900919
44868136,"
Try this code.
void bubblesort(type list[], int size)
{
    for(int i=0;i


}
",0,44867604
44868086,"
Implementing bubble sort for integers is straight forward. A simple google of bubble sorting will answer that for you. Strings are slightly different. You would have to grab the first character of the string 
then youre back to a simple integer bubble sort.
",0,44867604
44862850,"
boost::multi_index_container allows you to define a container of any type with any number of different indexes, or views.
The container keeps the indexes up to date automatically upon insertion and removal.
It's a massive template library which takes a little time to get used to, but the documentation is good, with plenty of examples.
Here's an implementation expressed this way:
expected output:
documentation here: http://www.boost.org/doc/libs/1_64_0/libs/multi_index/doc/index.html
",5,44862484
44863052,"
Consider replacing your vector of Person, by vector of pointer to Person.  With that in place, it is pretty cheap to swap two Persons just by swapping the pointers.  Then use the functors defined in your class to put the pointers in the desired sort order, and start printing.
",2,44862484
44862986,"
I would use 3 std::set instances of std::shared_ptr<Person> each sorted by corresponding field of Person:

By using std::shared_ptr you will not waste memory when storing
objects in several containers.
std::set is already sorted container, so that you have not to sort
it every time when using it, just enumerate elements from begin to
end.

",2,44862484
44862705,"
IMO, the approach you are using right now is good to go i.e. sort whenever you need it on runtime. For larger datasets, you need to first evaluate your requirements in terms of memory and processing power. For example, for a very large dataset, you won't be able to sort it in memory. And, there'll be synchronization issues in case you decide towards a multithreading solution. So, you'd be needing some specialized solution like a DBMS where you can query sorted data as you required on runtime. You'll have features like indexes to optimize query time.
",1,44862484
44862728,"
Among many it depends primarily on 3 factors -
1. Data Size
2. What kind of performance you are looking at
3. Amount of space (memory) you can trade off for #2
In general std::sort() performs at an avg at nlogn - 

Complexity On average, linearithmic in the distance between first and
  last: Performs approximately N*log2(N) (where N is this distance)
  comparisons of elements, and up to that many element swaps (or moves).

Now if your use case involves  the sort methods to be invoked too often, it might make sense to pre-sort and save the vectors - In which case you will have considerable performance gain. Now in this design you have to factor in cases like is the collection modifiable? If yes then how often? then you have to consider avg case insertion performance hit.  
So in summary it depends
",1,44862484
44862732,"
Instead of sorting vector of objects (which is rather is expensive for complex objects that have many fields) you should build several vectors of indexes to objects stored in main vector and sort them by various criteria.
Also sortSurname should take a const reference to avoid copying:
",1,44862484
44862753,"
If the vector is small or the elements are cheap to copy you can probably just re-sort it when needed without any problems.
If the elements of the vector are large and expensive to copy you can sort the vector once in one of the ways you need and then create a second vector of std::reference_wrappers and sort that a different way, to create a second ""view"" of the original vector that does not modify the original nor copy the elements to the second vector.
As for container choice; just go with std::vector unless you specifically need some special property of one of the other containers.
In any case, benchmark different solutions (with a optimized build) and measure the performance of different solutions before setteling on one.
",1,44862484
44860409,"
I think the correct way to use a std::lock_guard in your case is:
You probably have other issues. For example, your first join() will just block forever.
",0,44860208
44855205,"
std::sort takes iterators: Although a custom sort could likely take both indexes and the values in a single sort step, it's unlikely to be of much use (and may require different algorithms, making it slower).
Algorithm Design
Why? Because std::sort performs in O(n*logn) time. Moving elements from the sorted indexes will take O(n) time, which is relatively cheap in comparison.
Using the example from above, in the link given, we have this existing code:
We can now create a sorted array from these indexes, a cheap step:
If copying the values is too prohibitive, you can use a std::reference_wrapper to create a non-nullable wrapper. 
Even for large arrays, this should be pretty efficient.
Caution
Don't try to sort two arrays at once. Don't try to move items in your value array when sorting the index array. Why? Because the comparison is index-based for the value array: moving items will destroy the sort in the original array. Since moving the items to the correct position is so cheap once you have the sorted indexes, don't worry about performance here: the sort is the bottleneck.
",1,44854972
44855563,"
The reorder of the array(s) or vector(s) according to sorted indices can be done in place in O(n) time. This example sorts two arrays using a third array of indices. During the reorder, the array of indices is restored back to it's original state of going from 0 to n-1. I manually did the iota part in this example, and it doesn't use templates, but could be easily converted to templates and vectors:
or an array of pointers can be used instead of an array of indices, which allows a normal compare function instead of a lambda compare function.
",0,44854972
44794887,"
The problem of your comparison algorithm is for case when a.first < b.first. You must rewrite the logic for something like:
bool comp(const pair<int, int> &a, const pair<int, int> &b) {
    if (a.first == b.first) {
        return (a.second > b.second);
    } else {
        return (a.first > b.first);
    }
}

Comrarison for second is used only when first are equal, so first check the first with ==
",0,44794817
44794919,"
You didn't handle in your code the case where a.first < b.first. A complete version would be:
Or:
Which can be simplified into:
",0,44794817
44739529,"
You are on the right track. Here are areas for improvement:

Your code is incomplete: you do not read the student details. You can use fscanf() for that.
You sort based on the conversion of the grades to int.  This might be incorrect if the grades are not whole numbers.

Complete your code and fix your sorting function this way:
",0,44739235
44727962,"
Vector declaration is correct, vector construction is incorrect.
std::vector does not have a constructor which accepts two arguments of vector's element type.
If you want to initialize vector with the values from your code - change this line to:
See list initialization for detailed explanation how it works under the hood.
Edit:
For earlier than C++11 stardard - see this post.
Or if you don't care about this explicitly to be a single-statement assingment - just use push_back:
",2,44727859
44725359,"

This doesn't really make sense to me since the key is the same and the
  memory is already allocated by the time sorting starts.

The difference is not due to allocations taking place. The size of the vector doesnt change while sorting, so there are no allocations. However, sort has to copy the elements around to put them in the right place. And it shouldnt be too surprising that copying a double, 3 strings and an int takes more time than copying a single double.
",3,44725194
44745909,"
Finally found the bug. I was actually pushing an element extra in each row. 
As one could notice, program is checking for column number to be n, while it actually ranges from 0 to n-1. 
",1,44722146
44688981,"
You can use a custom function that compares strings with a special case for digits:
Depending on your sorting algorithm, you may need to wrap it with an extra level of indirection:
",1,44688918
44688985,"
I think you can play around with your data structure. For example instead of vector<string>, you can convert your data to vector< pair<int, string> >. Then {""good_6"", ""good_7"", ""good_8""...,""good_660""} should be  {(6, ""good""), (7, ""good""), (7, ""good"")..., (660, ""good"")}. In the end, you convert it back and do whatever you want.
Another way is just to define your own comparator to do the exact comparison as what you want.
",0,44688918
44689084,"
You can use string::replace to replace string ""good_"" with empty string, and use stoi to convert the rest of the integral part of the string. Lets say the value obtained is x. 
Create std::map and populate it in this way myMap[x] = vec_element. 
Then you can traverse from m.begin() till m.end() to find sorted order.
Code:
",0,44688918
44689283,"
If I understand your question, you're just having trouble with the sorting and not how you plan to change the names after you sort.
Something like this might work for you:
",0,44688918
44689113,"
Managed to do it with the following compare function:
full file name was good_0.png, hence that find_last_of(""."").
",-1,44688918
44664344,"
You can do it like this for example:
",0,44663158
44664571,"
Currently, you can use a counter and use it as flag, something like:
Demo
",0,44663158
44662979,"
Writing this up so we can archive the question ...
(1) Write a linear search function that takes the array and a value, then returns the index of that value in the array.
(2) The -1 failure return results in array access out of bounds -- this is a coordination problem between the original code and the search function.  Removing that line returns NULL instead, which results int he desired functionality.
",0,44640380
44662951,"
The requirements of the homework, as stated in the original post, did not restrict calling an additional function so I added a linear search function to the program, called it from within back_rec_sort.  However, I kept getting a hexadecimal garble in the array, as linked in comments, so I debugged as suggested by Prune, deleted the ""return -1"" from the search function and it works.  I would like to learn more about how to determine corner cases for testing, debugging and on writing assertions.  
",0,44640380
44614630,"
Instead of comparing values pointed to by the pointers in statements like this
you are comparing pointers themselves.
You should rewrite the condition like
",0,44604472
44570639,"
There is nothing wrong with your input or output. The program is sorting string and is not ignoring any char or digits.
The ordering you obtain is an alphanumeric one.
Infact executing it on the following input:
yelds:
which is clearly ordered alphanumerically.
To fix the problem you can

make  vector<std::string> sort_vec; a vector<long long> sort_vec;
making sure to convert the line you read from the file to a long long (or whatever type you like using std::stoll function.

Something like the following should work:
sort_vec.push_back(std::stoll(text_input));

Another option is to use a custom comparator. The only change in this case is in the way you call sort.

The following alone should do the trick:
As suggested by  @Toby Speight there is no need to convert the strings to numbers (one good reason to do that is that you cannot sort numbers longer that the maximum number of digits of long long, because of overflow problems.). One can simply compare the lengths of the stings first and if they're equal then proceed with an alphanumerical compare (taking care of any leading zeros). 
I have modified your code and the output i obtain is correct:
input
output
which is what you want.
",5,44570231
44570824,"
C++ defaults to sorting strings in alphabetical order.  The string ""1000115080"" comes before the string ""100011777"" in alphabetical order because the character '5' in the 7th position in the string comes before the character '7' alphabetically.  It's the same reason that the word ""apple"" is sorted before the word ""axe"", even though ""axe"" has fewer characters.  To sort these as integers, either convert strings to integers before performing the sort:
or pass a custom comparison function to std::sort:
As mentioned in the comments, you will probably get the wrong answer if you implement option 2 yourself (leading zeros, negative/positive signs, etc.), so better stick with letting the standard library do the conversion to integers for you.
",1,44570231
1380496,"
A simple example using std::sort

Edit: As Kirill V. Lyadvinsky pointed out, instead of supplying a sort predicate, you can implement the operator< for MyStruct:
Using this method means you can simply sort the vector as follows:
Edit2: As Kappa suggests you can also sort the vector in the descending order by overloading a > operator and changing call of sort a bit: 
And you should call sort as:
",320,44533375
26295515,"
In the interest of coverage.  I put forward an implementation using lambda expressions.
C++11
C++14
",131,44533375
1380481,"
You could use functor as third argument of std::sort, or you could define operator< in your class.
",52,44533375
1380488,"
You are on the right track.  std::sort will use operator< as comparison function by default.  So in order to sort your objects, you will either have to overload bool operator<( const T&, const T& ) or provide a functor that does the comparison, much like this:
The advantage of the usage of a functor is that you can use a function with access to the class' private members.
",13,44533375
37334886,"
Sorting such a vector or any other applicable (mutable input iterator) range of custom objects of type X can be achieved using various methods, especially including the use of standard library algorithms like 

sort, 
stable_sort, 
partial_sort or
partial_sort_copy.

Since most of the techniques, to obtain relative ordering of X elements, have already been posted, I'll start by some notes on ""why"" and ""when"" to use the various approaches.
The ""best"" approach will depend on different factors:

Is sorting ranges of X objects a common or a rare task (will such ranges be sorted a mutiple different places in the program or by library users)?
Is the required sorting ""natural"" (expected) or are there multiple ways the type could be compared to itself?
Is performance an issue or should sorting ranges of X objects be foolproof?

If sorting ranges of X is a common task and the achieved sorting is to be expected (i.e. X just wraps a single fundamental value) then on would probably go for overloading operator< since it enables sorting without any fuzz (like correctly passing proper comparators) and repeatedly yields expected results.
If sorting is a common task or likely to be required in different contexts, but there are multiple criteria which can be used to sort X objects, I'd go for Functors (overloaded operator() functions of custom classes) or function pointers (i.e. one functor/function for lexical ordering and another one for natural ordering).
If sorting ranges of type X is uncommon or unlikely in other contexts I tend to use lambdas instead of cluttering any namespace with more functions or types.
This is especially true if the sorting is not ""clear"" or ""natural"" in some way. You can easily get the logic behind the ordering when looking at a lambda that is applied in-place whereas operator< is opague at first sight and you'd have to look the definition up to know what ordering logic will be applied.
Note however, that a single operator< definition is a single point of failure whereas multiple lambas are multiple points of failure and require a more caution.
If the definition of operator< isn't available where the sorting is done / the sort template is compiled, the compiler might be forced to make a function call when comparing objects, instead of inlining the ordering logic which might be a severe drawback (at least when link time optimization/code generation is not applied).
Ways to achieve comparability of class X in order to use standard library sorting algorithms
Let std::vector<X> vec_X; and std::vector<Y> vec_Y;
1. Overload T::operator<(T) or operator<(T, T) and use standard library templates that do not expect a comparison function.
Either overload member operator<:
or free operator<:
2. Use a function pointer with a custom comparison function as sorting function parameter.
3. Create a bool operator()(T, T) overload for a custom type which can be passed as comparison functor.
Those function object definitions can be written a little more generic using C++11 and templates:
which can be used to sort any type with member i supporting <.
4. Pass an anonymus closure (lambda) as comparison parameter to the sorting functions.
Where C++14 enables a even more generic lambda expression:
which could be wrapped in a macro
making ordinary comparator creation quite smooth:
",11,44533375
1380493,"
Yes, std::sort() with third parameter (function or object) would be easier. An example: 
http://www.cplusplus.com/reference/algorithm/sort/
",4,44533375
1380487,"
In your class, you may overload the ""<"" operator.
",3,44533375
36736713,"
Below is the code using lambdas
#include ""stdafx.h""
#include <vector>
#include <algorithm>

using namespace std;

struct MyStruct
{
    int key;
    std::string stringValue;

    MyStruct(int k, const std::string& s) : key(k), stringValue(s) {}
};

int main()
{
    std::vector < MyStruct > vec;

    vec.push_back(MyStruct(4, ""test""));
    vec.push_back(MyStruct(3, ""a""));
    vec.push_back(MyStruct(2, ""is""));
    vec.push_back(MyStruct(1, ""this""));

    std::sort(vec.begin(), vec.end(), 
        [] (const MyStruct& struct1, const MyStruct& struct2)
        {
            return (struct1.key < struct2.key);
        }
    );
    return 0;
}

",2,44533375
50040873,"
I was curious if there is any measurable impact on performance between the various ways one can call std::sort, so I've created this simple test:
What it does is it creates a random vector, and then measures how much time is required to copy it and sort the copy of it (and compute some checksum to avoid too vigorous dead code elimination).
I was compiling with g++ (GCC) 7.2.1 20170829 (Red Hat 7.2.1-1)
Here are results:
Looks like all the options except for passing function pointer are very similar, and passing a function pointer causes +30% penalty. 
It also looks like the operator< version is ~1% slower (I repeated the test multiple times and the effect persists), which is a bit strange as it suggests that the generated code is different (I lack skill to analyze --save-temps output).
",2,44533375
20763862,"
",1,44533375
45567530,"
You can use user defined comparator class.
",1,44533375
38730028,"
To sort a vector you can use the sort() algorithm in .
The third parameter used can be greater or less or any function or object can also be used. However the default operator is < if you leave third parameter empty.
",0,44533375
45992778,"
if compare is false, it will do ""swap"".
",0,44533375
44448156,"
We beginners should help each other.:)
In any case you need a second container because the std::map is already sorted by key.
A general approach is to copy the map in some other container and sort the new container before outputting it. 
For your task you can use std::set as the second container.
Here you are.
The program output is
Also pay attention to that in your program instead of this if-else statement
you can just write
",1,44447642
44445755,"
One thing that immediately jumps out at me is the repetition caused by:
It may be better to extract this logic into a function and then call it instead:
I can't tell you if this is more efficient in terms of processing time, but there's much less repetition.
If you'd prefer to use references rather than pointers use this (C++ only):
and
then call with:
",-1,44445427
44421162,"
Should do the trick.
Alternatively, if you want to be able to switch out the vectorness of g1 with, say, a plain array, without having to modify this code, or if this was in template code where you want to work with multiple container types, then the form
may hold more appeal.
In any case; Please, do read the documentation.
",3,44421069
44421268,"
Instead of sorting, find the position where the new element should go and insert it there:
Or, more briefly:
",2,44421069
44428335,"
Just keeping it simple, let arr be the vector name. Write: sort(arr.beg(),arr.end());
(assuming already you have  written using namespace std;)
",0,44421069
44395137,"
Elaborating on my quick comment:
If you have already checked that there are no loops in your items, then what you have is a  directed acyclic graph (DAG).
Sorting that is the problem known as Topological sorting:
 (https://en.wikipedia.org/wiki/Topological_sorting) which has known efficient solutions, like Kahn's algorithm, though to take advantage of it's efficiency, you'll have to be careful how you store your nodes and edges, so that some operations (for example, finding a node with no incoming edges) is efficient (constant time)
Some well known libraries, like boost also provide implementations:
http://www.boost.org/doc/libs/1_33_1/libs/graph/doc/topological_sort.html
",2,44394462
44393740,"
You have a bug with indexes, fix:
Exchanged k and j in this snippet.
",4,44393515
44393808,"
Better variable names would help.  Try replacing j and k with something more descriptive like lowIndex and uprIndex.  Then you should see the problem.
",4,44393515
44393830,"
I noticed you were using j variable for uppercase and k for lowercase in the while loop then proceeded to do the opposite later.  Was this intentional?  Wondering if that's causing a bug.
",2,44393515
44338228,"
The problem with your implementation is a mix of boundary inclusions and wrong arrays. 
First, look at the 2 last while loops in merge, you did:  R[k]=R[i];when you meant  R[k]=A[i];
On the same function, your for loop is missing an iteration, the loop guard should be i<=hi instead of i<hi.
The initialisation of hi is also wrong, as you initialised it to the number of elements rather than the last index, you should have subtracted -1.
Also I have no idea what your print code was doing so I commented out and added my own, that I found more clear.
I corrected your code as follows:
",1,44337081
44303008,"
std::sort allows you to pass a custom predicate to it:
If you have an older compiler that cannot use lambdas, you have to create a class that implements the comparison:
",0,44302859
17074810,"
Finding a sort permutation
Given a std::vector<T> and a comparison for T's, we want to be able to find the permutation you would use if you were to sort the vector using this comparison.
Applying a sort permutation
Given a std::vector<T> and a permutation, we want to be able to build a new std::vector<T> that is reordered according to the permutation.
You could of course modify apply_permutation to mutate the vector you give it rather than returning a new sorted copy. This approach is still linear time complexity and uses one bit per item in your vector. Theoretically, it's still linear space complexity; but, in practice, when sizeof(T) is large the reduction in memory usage can be dramatic. (See details)
Example
Resources

std::vector
std::iota
std::sort
std::swap
std::transform

",95,44284558
25097083,"
In-place sorting using permutation
I would use a permutation like Timothy, although if your data is too large and you don't want to allocate more memory for the sorted vector you should do it in-place. Here is a example of a O(n) (linear complexity)  in-place sorting using permutation:
The trick is to get the permutation and the reverse permutation to know where to put the data overwritten by the last sorting step. 
",3,44284558
46506051,"
I would like to contribute with a extension I came up with.
The goal is to be able to sort multiple vectors at the same time using a simple syntax.
The algorithm is the same as the one Timothy proposed but using variadic templates, so we can sort multiple vectors of arbitrary types at the same time.
Here's the code snippet:
Test it in Ideone.
I explain this a little bit better in this blog post.
",2,44284558
53785022,"
With range-v3, it is simple, sort a zip view:
or explicitly use projection:
Demo
",2,44284558
17074762,"

Make a vector of pairs out of your individual vectors.
initialize vector of pairs
Adding to a vector of pair
Make a custom sort comparator:
Sorting a vector of custom objects
http://rosettacode.org/wiki/Sort_using_a_custom_comparator#C.2B.2B
Sort your vector of pairs.
Separate your vector of pairs into individual vectors.
Put all of these into a function.    

Code:    
",1,44284558
17074639,"
I'm assuming that vectorA and vectorB have equal lengths. You could create another vector, let's call it pos, where:
pos[i] = the position of vectorA[i] after sorting phase
and then, you can sort vectorB using pos, i.e create vectorBsorted where:
and then vectorBsorted is sorted by the same permutation of indexes as vectorA is.
",0,44284558
41602163,"
I am not sure if this works but i would use something like this. For example to sort two vectors i would use descending bubble sort method and vector pairs.
For descending bubble sort, i would create a function that requires a vector pair.
After that i would put your 2 vector values into one vector pair. If you are able to add values at the same time use this one and than call the bubble sort function.
If you want to use values after adding to your 2 vectors, you can use this one and than call the bubble sort function.
I hope this helps.
Regards,
Caner
",0,44284558
44278583,"
The invalid comparator assert was thrown because the function returned -1 and 1, while std::sort takes only true or false in order to have a weak strict ordering.
By changing the function to:
Everything works as expected. 
In the end it was indeed a very obvious mistake.
",1,44278059
44278677,"
Accordin to the reference for sort a comparator must:

comparison function object (i.e. an object that satisfies the requirements of Compare) which returns ​true if the first argument is less than (i.e. is ordered before) the second. 
  The signature of the comparison function should be equivalent to the following:
bool cmp(const Type1 &a, const Type2 &b);

I guess that what you really want is something as the following:
",0,44278059
44261860,"
should be 
btw I dont really understand what that function does, but it definitely does not sort anything. I would strongly suggest to give it a better name.
",1,44261765
44254459,"
I'm not sure of an ""Efficient"" way of sorting a vector, or array, in the manner you'd like (i.e. 1,2,3,4,1,2,3,4,1,2,4,4). But for an exhaustive way you could...
Iterate through the unsorted vector (UV) and find the minimum value above the previous runs minimum value (initialize with zero for first round and each time there is no value above the searched value). When a minimum value is found record its index and after iterating through the vector remove the value at the stored index and add this value to the sorted vector (SV). Continue to iterate through the UV until it is empty, and each item has been added to the SV. Now iterate through the SV and add 1 each time the preceding value is less than the current value.

Init prev-min value. and current-min, also storing its index each time its updated.
Loop over the UV (unsorted vector).
If a value is above prev-min but below current-min set as new current-min, and update the current min index.
At the end of the vector loop you have your current-min and its index value.
If the prev-min was the same as the current-min then set the prev-min back to zero and loop again (step 2).
Add the current lowest value to the SV and remove the current-min from the UV. 
Set the prev-min as the current-min and repeat the loop (step 2).
Once the UV is empty iterate through the SV.
each time the current value is above the previous value add one to count.

This should produce the sorted vector with each consecutive value higher than the previous unless it was the highest, in which case the next lowest value is used.
",0,44252878
44232309,"
As LogiStuff said in the comments, you are sorting copies.  This is  because the way you use the for-range, having a iteration variable that is copy constructed from each element of the range. 
To solve this, you just have to add an & to iterate over the range by reference, so that the vector is sorted in place.  Even better, use auto to move a step forward towards modern C++: 
Here the online demo
",1,44231744
44191394,"
I assume you've done using namespace std; above this code. In this case, std::partition is an algorithm designed to work with STL containers, not raw C-style arrays. Consider checking with the reference (for example, here).
Unfortunately, you'll need to either find/write a partition algorithm that works with raw arrays, or migrate from int arr[] to something like std::vector<int>.
Otherwise, if partition is indeed another function in your code, please provide it as well.
Hope that helps.
",2,44191363
44124231,"
The problem is, in the line:
and inside,
you are trying to access operator+ of the list iterator. But the iterator returned by std::list<T>::begin/end is a bidirectional iterator. Bidirectional iterators don't have operator+ defined. You can use operator++ though.
The std::vector on the other hand, returns a random access iterator by std::vector<T>::begin/end. Random access iterators do define operator+.
So, try something like this:
",1,44124174
46335646,"
Change T pivot = list[(lowerBound + upperBound)] / 2; to 
T pivot = list[(lowerBound + upperBound)/2];
",2,46335579
46263107,"
A better implementation could be:
I prefer to use a vector to store gap data so that you do not need to compute the division (which is an expansive operation). Besides, this choice, gives your code more flexibility.
the extern loop cycles on gap values. Once choosen the gap, you iterate over your vector, starting from vec[gap] and explore if there are elements smaller then it according to the logic of the Shell Sort.
So, you start setting j=i-gap and test the if condition. If it is true, swap items and then repeat the while loop decrementing j. Note: vec[j+gap]is the element that in the last loop cycle was swapped. If the condition is true, there's no reason to continue in the loop, so you can exit from it with a break.
On my machine, it took 0.002s calculated using the time shell command (the time includes the process of printing numbers).
p.s. to generate all that numbers and write them in the array, since i'm too lazy to write a random function, i used this link and then i edited the output in the shell with:
",0,46262239
46236154,"
That's a C comparison function, not a (C++) sorting function.  A sort function (probably qsort, given the const void* arguments) would call it a number of times (passing it pointers to what are apparently indices into a buffer containing a number of null-terminated strings) in order to sort those indices (and, indirectly, the substrings they indicate).
",2,46236098
46236130,"
This will not sort a string.
This is a method that helps comparing strings and is used by sorthing methods as a helper method.
It will return a negative number if string a is lexicographically smaller than string b, 0 if they are equal, or a positive number if b is greater than a.
",1,46236098
46192670,"
compareFunc() is a member function and requires an instance of Coefficients to be called.
You can make it a static class member function to solve that problem:
",4,46192596
46192709,"
using c++14, the best solution is very easy to write thanks to lambdas
or you can use comparator like:
",2,46192596
46181068,"
If vector2 consists of numbers that always appear in vector1, you can map numbers from vector1, for example vector1 is [3, 2, 4] and vector2 is [4, 3];

Map all elements to indexes for exampe 3->0, 2->1, 4->2
(keys are numbers and values are indexes). Use map or hashmap for
it.
Now loop through vector2, for each element search for it in the map and replace it with value from map: 4 becomes 2, 3 becomes 0 so now vector2 becomes [2, 0]
Now use sort(vector2.begin(), vector2.end()); vector2 becomes [0, 2]
Now loop through vector2 and for each element i replace it with vector1[i]:
0->3 (because number at the 0th index in vector1 is 3), 2->4 (because number at the 2nd index in vector1 is 4).
Hope this helps.

",0,46180589
46180953,"
You might create a map of values, something like
",0,46180589
46153591,"
The only code that sets h2 to b1 is this code:
But h2 should be set to b1 if b1 is between b2 and b3. And that can be true two different ways, and you only test for one of them.
For example, 10 is between 5 and 30. But 10 is also between 30 and 5!
Trying to cover every possible case is not a sensible way to sort more than two numbers. Use a sensible sorting algorithm.
",1,46153392
46153661,"
",0,46153392
46154184,"
The problem is in second nested if condition. If you put the values automatically the value of h2 will become 30. Instead try this..
",0,46153392
46137953,"
QStandardItemModel does not implements sort.
From Qt documentation:

void QAbstractItemModel::sort(int column, Qt::SortOrder order =
  Qt::AscendingOrder)
Sorts the model by column in the given order. The base class
  implementation does nothing.


You need to sort through QSortFilterProxyModel
",-1,46124997
46068116,"
it is not clear to me from the description what problem the program really tried to solve. I'm assuming it's kind of like a two column spreadsheet, the second column is the name entered by the user(but what is in the first column?).
assume you need to keep the array in sorted order as the data goes in, just do a binary search (you can do a linear search for small dataset like 100 entries).
of course we can use a typedef to make it cleaner, but that's left to you.
",1,46066319
46061122,"
You can generate your numbers in sorted order in linear time. The paper describing how to do this is: Generating Sorted Lists of Random Numbers by Bentley & Saxe
https://pdfs.semanticscholar.org/2dbc/4e3f10b88832fcd5fb88d34b8fb0b0102000.pdf
",4,46058304
46061023,"
Here is pseudo-code for how I'd do it.
",0,46058304
46077988,"
The standard library has a merge sort, but you need to use random access iterators.  If you can use mmap (or its equivalent), you have random access iterators (yes, I know that you need to take COUNT from the command line):
The msync calls aren't actually needed.  I'm honestly surprised that this has decent performance.
",0,46058304
46039612,"
If every element is within k positions of its proper place, then insertion sort will take less than kN comparisons and swaps/moves.  It's also very easy to implement.
Compare this to the N*log(N) operations required by merge sort or quick sort to see if that will work better for you. 
",1,46039401
46039604,"
It is not defined which algorithm uses, allthough it should be around N log N on average, such as quicksort.
If you are appending packets to the end of the ""queue"" as you consume them, so you want the queue always sorted, then you can expect any new packets correct position to nearly always be near the ""end"".
Therefore, rather than sorting the entire queue, just insert the packet into the correct position. Start at the back of the queue and compare the existing packets timestamp with those already there, insert it after the first packet with a smaller timestamp (likely to always be the end) or the front if there is no such packet in the event things are greatly out of order.
Alternatively, if you want to add all packets in order and then sort it, Bubble Sort should be fairly optimal because the list should still be nearly sorted already.
",1,46039401
46039601,"
On mostly-sorted data Insertion Sort and Bubble Sort are among the most common ones that perform the best.
Live demo
Note also that having a list structure puts an extra constraint on indexed access, so algorithms that require indexed access will perform extra poorly. Therefore insertion sort is an even better fit since it needs only sequential access.
",0,46039401
46045137,"
In the case of Visual Studio prior to 2015, a bottom up merge sorting using 26 internal lists is used, following the algorithm shown in this wiki article:
https://en.wikipedia.org/wiki/Merge_sort#Bottom-up_implementation_using_lists
Visual Studio 2015 added support for not having a default allocator. The 26 internal lists initializers could have been expanded to 26 instances of initializers with user specified allocators, specifically: _Myt _Binlist[_MAXBINS+1] = { _Myt(get_allocator()), ... , _Myt(get_allocator())};, but instead someone at Microsoft switched to a top down merge sort based on iterators. This is slower, but has the advantage that it doesn't need special recovery if the compare throws an exception. The author of that change pointed out the fact that if performance is a goal, then it's faster to copy the list to an array or vector, sort the array or vector, then create a new list from the array or vector.
There's a prior thread about this.
`std::list<>::sort()` - why the sudden switch to top-down strategy?
In your case something like an insertion sort on a doubly linked list should be faster, if an out order node is found, remove the from the list, scan backwards or forwards to the proper spot and insert the node back into the list. If you want to used std::list, you can use iterators, erase, and emplace to ""move"" nodes, but that involves freeing and reallocating a node for each move. It would be faster to implement this with your own doubly linked list, in which case you can just manipulate the links, avoiding the freeing and reallocation of memory if using std::list.
",0,46039401
45944047,"
You are dereferencing pointer which might be uninitialized.
I guess you should change condition to (since in step earlier you already moved to next node)
or atleast check whether pointer doesnt point to NULL.
",2,45943920
45929522,"
The compare function simply models a ""less than"" operator. Consider how the < operator works for primitive types like int:
Returning true means you want a to be ordered before b. So return false if that is not the case, either because you want b to be ordered before a, or because their order doesn't matter.
If you return true when the arguments are equal, then you are saying that you want a to come before b and you want b to come before a, which is a contradiction.
",4,45929474
45929812,"
The algorithm which std::sort uses is unspecified. By using a comparison function which does not meet the requirements set by the standard, you break the algorithm's assumptions, and cause undefined behavior.
Look what happens in the output of this noisy comparison function which uses <= (which is not a valid comparator) instead of < (which is valid).
http://coliru.stacked-crooked.com/a/34e4cef3280f3728
In the output, I am printing an incrementing variable (for reference to point out when the algorithm goes haywire), followed by the value of the first argument and its position in the vector, and then the second argument and its position in the vector. An example looks like this:
Which means this is the 124th invocation of the comparison function, and it is comparing the value 2 at index 12, with the value 4 at index 7.
Things go crazy starting at line 37
It is comparing values that I didn't even insert into the vector (144, 192, etc...) and at indexes outside the range of the vector (negative indexes, in this case).
",3,45929474
45931193,"
For an explanation to Benjamin Lindley's answer, consider the typical case where std::sort uses quicksort with Hoare type partition scheme. The left side is scanned for values < pivot using compare(value,pivot) to do the compare, while the right side is scanned for values > pivot using compare(pivot, value). Note that quicksort partition may rely on the fact that a left or right scan is stopped when it encounters a value == pivot and doesn't continue scanning past the pivot on that scan. If the user supplied compare function returns true on such a compare (true when value == pivot), the scan could continue beyond boundaries of the array or vector being sorted, which is apparently what happened in Benjamin Lindley's test case.
",1,45929474
45929776,"
Without going in the depth of the math, 2 variables can be compared using just '<' operator (or '>' if you wish). However '<'  is used commonly in explanation of the 'strict weak ordering` and in implementation of sorters.
The idea basically is that in practical programming if a < b == false and b < a == false then a == b.
",0,45929474
45928566,"
A quick way to optimize you first function while reducing the possibility for errors:
Function #2:
As for main(), you do not check for allocation errors in return value from command(), you leak every single buffer returned by command(), and you assign values into d, which is an uninitialized pointer, this very likely generates a segmentation fault.
",0,45928240
45928465,"
The most obvious issue I see is the assignment to the uninitialized pointer d.  You need to allocate a block of memory for that.  There could be other problems in the program too which you'll need to debug in order to find.  
",0,45928240
45907374,"
Try this code:

If you'll look into the code, the sort depends on the second column to be edited. Then, will check the range if the is still a blanked cell.
Just apply your additional code to meet your goal and I think that will work.
Hope this helps.
",0,45896503
45865459,"
The problem is that std::sort is not stable - this means that when you sort by the length, you destroy the sorting by the name.
The easy way to do this, is reverse your pair.  std::pair has an operator < which compares first values, and if they are the same compares the second value.  So what you need is:
Note I have moved thename inside the loop (it is never used outside), and made the final for loop a foreach loop (which should be your prefer loop form where possible).
However you don't need to store the lengths in the vector.  You can  just store the names, and then use a custom comparator to do the comparison.  
Note that I have used std::tie to compare both length and string.  The advantage over std::make_pair is that it will default to using a reference, and hence not copying the string.  The advantage over doing it yourself is that it is hugely easier to get right (and it's easier to read too).
Note that you might replace the lambda
by a functor manually written:
and use it:
",5,45865239
45865664,"
You do not need a vector<pair<int,string> to store your array of strings, you can a vector<string> and write an appropriate sorting function here is an example:
input:
output:
",3,45865239
45875031,"
I propose pidgeonhole sort followed by a sort of each pidgenhole.
The initial step is only O(N+n) followed by sorting each pidgeonhole in O( p log p), as each p <= n the total sort time should be less or equal to O(n log n)
Warning untested code:
",0,45865239
45776325,"
My reasoning is that MyCustomSortFunctionHere function (or class methods?) is called with the calling convention you ask it to: with
it would be called with ""C"" calling convention.
Since std::sort() is a template function, it is actually compiled together with your code in its same translation unit, including the part where your comparison function is called, and the call to MyCustomSortFunctionHere follows the rules you have specified in that translation unit.
If you are defining the comparison function in the same translation unit, you should get away with not specifying any convention.
If the function is instead defined in a different translation unit, you would need to express to the compiler which is the right calling convention.
",4,45775522
45776766,"
How is your MyCustomSortFunctionHere implemented?
a. using functor or,
b. using the method signature bool cmp(const Type1 &a, const Type2 &b)
In case of 1st method ""thiscall"" calling convention is used and in case of 2nd method __cdecl calling convention is used. 
I verified the above using the dissassembly of the code generated by Visual Studio compiler for each of the above methods.
Hope this helps!
",0,45775522
45768667,"
According to reliable documentation, std::sort accepts the function object by value. This means the Func being used by std::sort is a copy of  FuncObj. This means that when 4 is compared with 4, the copy's flag variable is set to 1, and FuncObj is unchanged. The copy is destroyed when std::sort returns, so this flag is lost.
The simplest solution define int flag as static int flag to that all instances of Func share the same Flag.
If this is not an option, different Funcs must have their own flag, my inclination was to go with a std::shared_ptr. Each default constructed Func would have had it's own flag and shared this flag with any copies made. 
However Benjamin Lindley reminds of std::reference_wrapper and this provides a much more convenient solution for the problem. The wrapper is passed by value and copied rather then the Func it references, allowing the source Func to be modified inside std::sort.
",1,45768345
45758198,"
Compared to billions, 2^18, or 256k seems suddenly small. The good news is that it means your histogram can be stored in about 1 MB of data.  A simple approach would be to convert each letter to a 2-bit representation, assuming your file only contains AGCT, and none of the RYMK... shorthands and wildcards.
This is what this 'esquisse' does.  It packs the 9 bytes of text into an 18 bit value and increments the corresponding histogram bin.  To speed up[ conversion a bit, it reads 4 bytes and uses a lookup table to convert 4 glyphs at a time.
I don't know how fast this will run, but it should be reasonable.  I haven't tested it, but I know it compiles, at least under gcc. There is no printout, but there is a helper function to unpack sequence packed binary format back to text.
It should give you at least a good starting point
This algorithm can be adapted to run on multiple threads, by opening the file in multiple streams with the proper share configuration, and running the loop on bits of the file.  Care must be taken for the 16 bytes seams at the end of the process.
If running in parallel, the inner loop is so short that it may be a good idea to provide each thread with its own histogram and merge the results at the end, otherwise, the locking overhead would slow things quite a bit.
[EDIT] Silly me I had the packed binary lookup wrong.
[EDIT2] replaced the packed lut with a faster version.
",2,45755943
45756137,"
This works for you,
",1,45755943
45756208,"
std::sort takes a predicate to compare element.
As your method requires extra information, you have to bind it in some way;
lambda (via capture) is a simple one:
",2,45747963
45750643,"
Couldn't you use a map instead of a vector, with the key being the calculated distance, so the sorting would be done automatically at insertion of the values?
",-1,45747963
45748070,"
I think your problem is that this three-argument form of std::sort expects the third argument to be a class, which this->sortFunction is not.  It might be more straightforward to replace sortFunction with a definition of the < operator in myClass - then you can simply call std::sort(this->structVector.begin(), this->structVector.end())
",-3,45747963
45736022,"
You can use std::multimap for same. It will automatically sort w.r.t keys.
",0,45735720
45710121,"
You could perhaps monitor the differences (first-order derivative) for each eigenvalue. Then, you can continue ""tracking"" the eigenvalue even if it intersects by making educated guesses on whichever has the closest derivative(s).
For this, we need a distance function (or cost function). One such example:
We now match pairs of eigenvalues which have the least distance between each other:
Of course, for all this to work, you need to maintain the correct values of your Eigenvalues:
This method is not foolproof. There may be collisions, in which case you might want to try more orders of derivatives or try to reduce the speed at which the eigenvalues change.
",2,45709565
45710142,"
Use std::sort 
",0,45709565
45677924,"
If your container is
you could sort it as
If you want to switch between ascending and descending just switch from < to > accordingly.
",8,45677860
45678180,"
The standard library provides a data structure std::pair and a sorting algorithm std::sort, to which you can pass your custom comparison that defines the order. See the following code, that defines a comparator taking two std::pair<int,int> and comparing them based on their ""absolute difference"", together with the code how to invoke std::sort with it. Hope it helps. 
Output:
",2,45677860
45678013,"
std::sort has an overload that takes a compare callable.
So, you can pass a lambda (or other function) as that third parameter that tcompares any way that you want.
From cppreference.com:
So, for example
(that requires c++14, you may have to modify that depending on your compiler version)
",1,45677860
45643557,"
You can give a predicat to std::sort like 
First, I encourage you to do not use new, new[], delete, delete[] in C++ modern.
It is better to use Container and Smart Pointers (I use std::vector here)
Second, what does mean : [](auto a, auto b){return a.level < b.level;}.
It is an ""object"" that is named a lambda. Lambda are a bit like function or something like that. This ""function"" takes two arguments : a and b, which them type are automatically deduced at compile time (thanks to auto).
The whole function is what we call a predicat. Here, you want to compare only the level part, that's why I am using a.level < b.level.
Also, you can check the documentation of std::sort function here : 
http://en.cppreference.com/w/cpp/algorithm/sort
As you can see, I am using this one :
Compare comp here is the predicat that I defined by a lambda.
More information about lambda here https://stackoverflow.com/a/7627218/4950448
However if like Michaël Roy suggests, you must use C++98, you can use a ""functor"" (not sure about the name)
",3,45643522
45643695,"
In c++11 and later, you can use Antoine's lambda function based solution. If you have to use c++98, or if the level data member is the meaningful value for comparing your struct data, or if you expect to do a lot of comparisons, or if the comparison is more complex, you can create an operator to help order your struct values.  
",2,45643522
45643785,"
When std sort is called, the ""normal"" version of this function will perform some comparison using operator<. Like you understood, the comparison between two string is lexicographic (like a dictionary).
However, people that developed the std::sort function think about cases like :

There is no operator<
User may want another way to sort it

Here it is where the predicate is useful. The predicate (like Igor Tandetnik says) is called inside the std::sortfunction.
So, with the normal version, std::sort will do something like that :
In the predicate version, it will do almost the same :
Going that way, your predicate replace the operator< function.
",2,45643415
45643848,"
A binary predicate is nothing else than a callable object (including a function or lambda) that expects two parameters of the type of the dereferenced iterators of the container. Its ""role"" is to provide a comparison criteria for the sort algorithm.
The std::sort algorithm expects that this function or function object returns a value that is convertible to bool and which yields true, if and only if the first argument is before the second argument in the sort order (so-called strict weak order). The std::sort algorithm then operates (sorts) on the given range of objects (begin to end of container) by applying the predicate to elements when comparing the elements individually.
In your case, if the container is a vector of strings, the dereferenced iterators yield std:string and thus your lambda works fine.
Here is some example code showing how it works with a lambda that is independent of the concrete type, but requires at least the size() operation to be defined on the objects in the container. It also shows, how the binary predicate could be provided as a function object (in which case I reverted the sort order by inverting the predicate):
",0,45643415
45640383,"
Just change  (You got confused with indexing  )
0 index is the first element
to
Apart from that changed 
to
After changing that
Output
",3,45640247
45640632,"
You can print the contents of the array at the end of each iteration in the for loop to diagnose where the error is in your code.
Output:
51 2 4 6 1 3
51 2 4 6 1 3
1 51 2 4 6 3
1 51 2 3 4 6

Final result:
1 51 2 3 4 6


I saw the following errors in your logic.
Your for loop needs to start with j=1, not j=2. Remember that the index 1 is used to access the second element of the array, not the first element of the array.
The conditional of the while is not correct. It breaks the loop too early. The iteration of the elements and the swapping of the elements need to be separated.
I did not follow the reason behind the existence of the variable key. I think it can be removed. YMMV.

Here's an updated version of the program and its output.
Output:
2 51 4 6 1 3
2 4 51 6 1 3
2 4 6 51 1 3
1 2 4 6 51 3
1 2 3 4 6 51

Final result:
1 2 3 4 6 51

",1,45640247
45628057,"
The order you're referring to is called 
Lexicographical order
You could simply sort your vector<Test> with std::sort by providing either a suitable comparator, or by implementing operator<, as explained in Sorting a vector of custom objects
The last implementation could be something like:
",2,45627903
45628484,"

Implement operator < in Test

use std::sort to sort


",1,45627903
45630907,"
std::sort takes a comparer, so you can use:
",1,45627903
45630893,"
You can use std::sort, and provide a comparison function object.
This works because std::tuple::operator< provides an ordering based on the first value, with later values breaking ties. Note how we use the right hand side num on the left in NumDescErrorAsc. That's equivalent to using > for num.
",0,45627903
45624218,"
std::sort() is a hybrid algorithm. While a vanilla quicksort could get away with only swap() operations (from std::partition())  the real sorting approach most likely uses insertion, heap, and/or merge sort, too. For these sorting algorithms it is generally more effective to lift an object out of the way (by move construction), moving objects into the current ""hole"", and finally moving the out of place ibject out of the way. It may be reasonable to keep just one temporary object but most likely the algorithm uses some functions and keeping on temporary ibject around is somewhat impractical (although something I hadn't contemplated before and possibly worth trying).
Earlier this year my Quicker Sorting talk got recorded at the Italian C++ Conference: it goes over the details of making quicksort quick.
The upshot is: if you want to sort objects you better make sure that copy/move construction, copy/move assignment, destructor, and swap() are fast. I can imagine that keeping a temporary object could lessen the need for construction and destruction but assignments will remain. A dedicated destructive move could possibly improve performance, too, but I haven't experimented with that (yet).
",4,45623856
45618296,"
I'm assuming by frequency you mean the number of times an identical structure appears in the array.
You probably want to make a hash function (or overload std::hash<> for your type) for your custom struct. Then iterate over your array, incrementing the value on an unordered_map<mytype, int> for every struct in the array. This will give you the frequency in the value field. Something like the below would work:
For this to work, the map will need to be able to create a hash for the above function. By default, it tries to use std::hash<>. You are expressly allowed by the standard to specialize this template in the standard namespace for your own types. You could do this as follows:
The primary goal is to ensure that any two variables that do not contain exactly the same values will generate a different hash. The above XORs the results of the standard library's hash function for each type together, which according to Mark Nelson is probably as good as the individual hashing algorithms XOR'd together. An alternative algorithm suggested by cppreference's hash reference is the Fowler-Noll-Vo hash function. 
",2,45618035
45618089,"
Look at std::sort and the example provided in the ref, where you actually pass your own comparator to do the trick you want (in your case, use the frequencies). Of course, a lambda function can be used too, if you wish.
",1,45618035
45532607,"
Because of the condition you wrote
so if the previous element is smaller than the farther element it gets swapped
",1,45532550
45532675,"
You don't have to make any change, If you start your inner loop from (i+1)th position.
Replace the second code with following snippet:
",0,45532550
45532692,"
Change your code in your innerloop j = i+1;
",0,45532550
45532608,"
Change if (a[i] < a[j])  to if (a[i] > a[j])
For sorting in ascending order you want to swap elements when previous element is greater than the next element.
This animation will help you to understand the working of bubble sort http://cathyatseneca.github.io/DSAnim/web/bubble.html
",0,45532550
45494618,"
Use std::sort with a custom predicate, eg:
(with appropriate error checking, of course).
This sorts each item of the ""outer vector"" (each item being a 1D vector corresponding to a row) with respect to the given predicate, which orders them by their 4th element (the 4th column in the ""row"").
As detailed in the docs, the predicate should take two items and return true if the first is ""strictly less"" than the other, and false otherwise. When comparing numeric types this is nice and easy, as we can just use the < operator. And in your case, one ""row"" is ""less than"" another if the 4th element is less than.
Edit: See here for working demo.
",6,45494567
45491295,"
I will take a stab at this, since I am not a Qt user.
In general, if you need to sort a list of objects that cannot be copied, or if the copying aspect is expensive, one workaround is to sort a list of indices instead of the data, and after the sorting is done, use the index list to access the data.
According to the docs for Qt's qSort, something like this may work using the method above:
Once this is done, you access the sorted myList container thusly:
Note:  I am assuming that qSort accepts a lambda function as the third argument.  If there are issues, you can use a function object.
",1,45490707
45651641,"

QObject has neither a copy constructor nor an assignment operator. This is by design.

http://doc.qt.io/qt-4.8/qobject.html#no-copy-constructor-or-assignment-operator
So you just can't qSort a container with QObjects or derived classes, at least not in C++ before C++11. You could try switching on C++11 support (or higher) in your compiler (and make sure your Qt libs are compiled with that, too); if the Qt folks are as good as usual they're using move semantics in this case.
Else using pointers or perhaps one of the Qt pointer classes like QSharedPointer would be a valid way to go. And you'll need a lessThan operator or function anyway if you don't want the order to be by memory address.
",0,45490707
45490587,"

but without any success because tolower works only char / wchar_t.

You want std::ctype<wchar_t>::tolower:
Alternatively, instead of std::ctype<wchar_t>::tolower you may like to use towlower that uses the current (global) C locale.
",4,45490542
45456418,"
Although I'm not sure it is guaranteed to do the first option, I'm pretty sure it moves std::wstring structures which are constant in size (they do not depend on the size of the string).
The bytes representing the string are not inside its structure, there just are a pointer to a memory zone where they allocated. 
",1,45456330
45456459,"
std::wstring copy/move constructors or preferably swap method (depends on implementation) should handle this and swap internal pointers instead of data. As relevant std::basic_string properties weren't changed since C++03 standard version won't affect performance in this case.
Compiler and its standard library implementation however will. Also remember, that if you care about performance you should run benchmarks and use profiler.
",1,45456330
45456499,"
Neither 1. nor 2. exactly.
std::sort swaps elements with (std::)swap. No new elements are created (unlike your 1. suggests). Only the existing ones will be modified. However, the character data does not need to be touched (unlike your 2. suggests). Simply the size, iterator, pointer etc. data is copied from one string to the other. Although, this depends on implementation. Only guarantee is that the complexity is constant.
This did not change in C++11 as far as standard strings are concerned. However, custom types that rely on the default std::swap are more efficient to sort due to more efficient generic std::swap that benefits from move semantics.
",1,45456330
45463475,"
std::wstring is permitted to and typically does use the small string optimization.  This means for short strings, the characters are stored within the std::wstring.  For longer strings, the std::wstring stores a pointer to the buffer of characters in the free store (aka the heap).
When you sort a container of std::wstrings, the std::wstrings are conceptually moved around.  The buffer of characters on the free store are passed from one std::wstring instance to another, and never duplicated or modified.  The ""small string"" cases can be modified and copied around.
This is true both in C++11 and in C++03.
Prior to C++11, there where some implementations of std::wstring that used copy on write smart pointers.  C++11 tightened requirements on std::basic_string which made such implementations illegal.  COW (copy on write) smart pointer strings rarely use SBO (I guess they could).
std::sort is written in terms of std::swap, which was specialized for std::basic_string or uses std::move to efficiently not reallocate the buffer.
",0,45456330
45455442,"
According to sgi doc, partial_sort uses heapsort, sort uses introsort:

partial_sort(first, last, last) has the effect of sorting the entire range [first, last), just like sort(first, last). They use different algorithms, however: sort uses the introsort algorithm (a variant of quicksort), and partial_sort uses heapsort. See section 5.2.3 of Knuth (D. E. Knuth, The Art of Computer Programming. Volume 3: Sorting and Searching. Addison-Wesley, 1975.), and J. W. J. Williams (CACM 7, 347, 1964). Both heapsort and introsort have complexity of order N log(N), but introsort is usually faster by a factor of 2 to 5.

So, it is normal partial_sort is 4 times slower than sort.

I have checked my VS2017 library, and found the implementation of partial_sort and sort. And it is similar with SGI.
partial_sort
sort
",5,45455345
45457821,"
Nothing requires partial_sort to be implemented in a certain way, except the guarantees of complexity

25.4.1.3 partial_sort [partial.sort] 
template void partial_sort(RandomAccessIterator first,
   RandomAccessIterator middle, RandomAccessIterator last);
   template 
   void partial_sort(RandomAccessIterator first, RandomAccessIterator middle,
   RandomAccessIterator last, Compare comp); 
1 Effects: Places the first middle - first sorted elements from the range [first,last) into the range [first,middle). The rest of the elements in the range [middle,last) are placed in an unspecified order. 
2 Requires:
  RandomAccessIterator shall satisfy the requirements of ValueSwappable
  (17.6.3.2). The type of *first shall satisfy the requirements of
  MoveConstructible (Table 20) and of MoveAssignable (Table 22). 
3 Complexity: It takes approximately (last - first) * log(middle - first) comparisons

An alternative implementation could be
",1,45455345
45528808,"
I understand answer the question. 
add following code in base class :
and add following code in main :
This code is correct! :)
",0,45454320
45538991,"
You're looking for std::rotate.
This yields the following output, according to ideone.com:
",2,45447361
45447717,"
Here is a solution, that moves each of the non-selected elements at most once:
Readability is admittedly not too good. It couldprobably be improved by better variable names and/or putting some of it into a separate function
",0,45447361
45448152,"
The above two examples had issues with different input (noted above).  I worked out the algorithm to handle the different cases and it passed my unit tests.  It can probably be improved for speed. 
",0,45447361
45443637,"

PS: Even better: would it be possible to produce a
  std::vector<wstring> w sorted? i.e. each element w[0], w[1], etc.
  would contain a ""link"" (pointer?) to fNames's wstrings, but not a copy
  (to avoid duplicating the string data)?

A vector<wstring> would contain duplicates of the strings (as CoW - Copy on Write - has been forbidden for std::[w]string since C++11). If you want to use const wchar_t* to avoid string duplicates, you can do something like this:

EDIT As per your comment, you can use vector<const wstring*> as well, e.g.:
",1,45443268
45443438,"
Use a vector of pointers to the elements of the map, and sort those pointers. This gives you access to both the longs and the wstrings, without copying.
Now you have access to the wstring values through v[N]->second, and the long values through v[N]->first.
Pre-C++11 version
If you only need the strings, and not the longs, then you can just use a vector of pointers to strings instead.
",1,45443268
45444364,"
I will solve this in c++14, because it is simpler there than c++11 or c++03, and every major compiler vendor has enough support for this to compile:
Make a vector of pointers-to-string and reserve enough space (for efficiency reasons).
Populate the pointers:
Sort them:
for a vector of keys:
In c++17 you can do away with the .first and .second:
using structured bindings.
",1,45443268
45439427,"
Something along these lines:
",0,45439137
45336356,"
This algorithm should do it. I removed the templates to make it easier to check on godbolt.
Should be easy enough to put back in.
The O score for this method is that of std::sort - O(N.log(N))
We can of course do better with unordered maps, if:

the label is hashable and equality-comparable
we don't need to order the output (if we did, we'd use a multimap instead) 

 
The O-score for this method is linear time O(N)
",1,45335797
45335953,"
Why not create a map from ints to vectors, iterate through the original vector once, adding each MyClass object to TheMap[myclass[i].label]? It takes your average runtime from f(n + n*log(n)) to f(n).
",1,45335797
45329140,"
Your biggest issue here is that
doesn't construct the vector you think it does. p[0] and p[N-1] are floats, not pointers.  So what you do is construct a vector with p[0] number of elements all with the value of p[N-1].  What you need if you want to construct a vector for an array is

You also have an issue with 
Since N is the size of the vector vec[N] is not a valid element.  It is one past the end.  What you need is

Do note that the vector is not needed here at all.  You can just take a float* in yourFunction and sort that directly.  That would look liked
Even though you said you cannot change the code in main I would also like to let you know that new should be preferred over malloc 
",2,45328895
45329004,"
First your vector creation is wrong.
Then,
should be
Also why do you have both array and vector.
Either use 
or directly put values into vector.
",0,45328895
45305160,"
This is not a sort
At least not as std library defines its sorts.
You just want to move some elements around.
4 steps:

Find the first A.  This is where we want to shove the Cs.
Stable partition all C to be right before the first A.
Find the last A.  This is where we want to shove the Bs.
Stable partition the Bs to be right after the last A.

All Cs before the first A remain stationary.  All Bs after the last A remain stationary.
Cs keep their relative order.  Bs keep their relative order.  Both move the least possible to generate the guarantee you require.
Everything that isn't a C or a B keeps their relative order.
Code:
Live example.
With enough spare memory, the above is O(n).
Of course, this could simply be done in one line:
but I wouldn't recommend it.
",11,45302314
45306500,"
It is not a strict weak ordering, but it is a partial ordering. An algorithm for sorting by a partial ordering is called a topological sort, like this naive implementation:
It partitions the sequence so that all the elements that are not greater than any other element are moved to the front. Then it takes all the remaining elements and partitions them in the same way, until there remain no more elements to be partitioned. Its complexity is O(n²) comparisons and O(n) swaps.
Then we need to fix the bug in the comparison function:
Live demo
For reference, an unstable version would use partition instead of stable_partition.
",3,45302314
45308096,"
What you want is some sort of stable topological sort. Your DAG is that Cs point at As point at Bs.  See https://stackoverflow.com/a/11236027/585411 for a description of a reasonably efficient algorithm to implement the topological sort that is lowest in lexicographic (in your original list) order.  Its output in your case would be:
Thinking about it that way makes it easy to generalize lots of different kinds of rules that you might have, rather than special casing how this example works.  So long as they don't add up to a circular path, your algorithm will still work.
",2,45302314
45302645,"
If I understand your desired algorithm right, it's probably easiest to just split manually into three lists and then splice back together.
",0,45302314
45305225,"
The problem with a non strict weak ordering is that the order is not enough to define the sorted list. With the input A1, B, C1, A2, A3, F, G, C2, H, A4 you proposed the output C1 C2 A1 A2 A3 F G H A4 B. But in fact, B came before H in original list and now comes after which is not conformant with a stable sort. If you wanted to preserve B < H, you could get the following list:
but here it is the A4 < H that has been broken.
To build a stable sort, you have to define a strict weak ordering. To obtain the list you propose, this order could be used:

C comes before A
B comes after A
all other letters are equivalent to A

In that case, the compare function becomes :
Alternatively, you could try to specify an algorithm that accepts a non weak strict ordering, but you will have to specify what happen when you have this original list
X Y Z, Z < X, X,Y and Y,Z non comparable: do you want Z X Y, Z Y X or Y Z X? In fact it depends whether Y should be processed as equivalent to X or Z or... And then wonder what could happen in more complex use cases...
",0,45302314
45270909,"
A multimap from calculated double to vector.  If you need to reverse it, a map from vector to double as well.
You could shave the double off by storing a pointer to the caching vector to double in a multiset of vector's comparison, but that seems unwise.
",0,45269622
45201775,"
Replace:
by:
It was just checking till the 1st index while the zeroth index was not touched
And you might want to print the contents of the array like this:
",2,45201036
45201821,"
For starters this loop
has an incorrect initial setting. It will not sort an array that has only two elements or the second element will be never swapped with the first element if the second element is less than the first element. 
It would be correctly to write the statement like
The inner loop
does not touch the element A[0] due to the condition i > 0, Thus the subcondition A[0] > key will be never checked.
It is better instead of swapping each pair of elements that satisfy the condition just to copy elements and then to write the ""added"" element in the required position.
The program can look the following way.
The program output is
",2,45201036
45169462,"

I get 2 different hash values:

One problem is that you're printing out 128 bytes of data, but MurmurHash3() only outputs 128 bits.  That means that only the first (128/8)=16 bytes of each line of your output are valid hash data; the remaining bytes you are printing out are uninitialized/random data that isn't meaningful.
A second reason is mentioned on the MurmurHash3() Wikipedia page:

When using 128-bits, the x86 and x64 versions do not produce the same
  values, as the algorithms are optimized for their respective
  platforms.

On to the next part...

There are also negative values. I'm not an expert of hash functions.
  Is it normal this behavior?

Whether the values are negative or not depends on how the data-printing mechanism interprets the bytes.  Currently you're printing the values out as if they were ints, and int is a signed data type, which means that any value that has the most-significant-bit set will be printed as a negative value.  If you want to see the values printed as unsigned, you should cast them to (unsigned int) before passing them to cout, instead.

How can I compare hash values efficiently?

memcmp() is one common way to compare the contents of two arbitrary memory buffers.
",1,45169248
45136116,"
There is a logical error in your program.You need to update index with current value of i with every iteration.
try this, it works fine :
",0,45135531
46965208,"
There were few bugs in your code. Check this one. Doing it only for 10 numbers. Make it for 1000 or whatever you prefer by writing your random number logic. 
",1,46964538
46962797,"
You need to declare merge before calling it. That means, you need to declare it before sort. For example - 
Write this declaration before the definition of sort
EDIT I just figured out another error in this line 
You cannot do this. In C++ the size of array must be a compile time constant.
",1,46962624
46949625,"
Your max never gets reset, so on first iteration it gets set to 9 and stays that for the rest of the execution
",1,46949529
46949880,"
Your inner loop always set max to 9 on its final iteration, and your outer loop only ever reads max once the inner loop is completed, so high[j] will always be 9.
",0,46949529
46941384,"
I figured out how to fix this. The inner loop ran while (current != nullptr) so when current was at head and it was assigned current->prev it was pointing to nullptr. I changed the while loop condition to current->prev != nullptr and now it runs properly since it's never pointing to nullptr.
",0,46923848
46922216,"
Unordered sets and maps doesn't sort anything. They are hashed containers that depends solely on the operator== of the key (all keys with same hash will be save in some kind of internal list or vector, called bucket). The order given to the keys is unspecified.
Hashed containers are very fast to find if something is inside the container, but are not sorted. If you want sorting, you have to replace the type of network_percent for a simple std::map.
The operator< of std::string is implemented following a lexicographical order, so, you don't have to do anything else here to get the intented behaviour.
NOTE: Didn't you notice why unordered_map is called unordered? :)
",0,46919649
46909676,"
In your loop inside sort_bubble, where i goes from 0 to 4, you use numbers[i+1] which at the end will be numbers[5] which is an invalid number of the array. Make the loop for (int i = 0; i < 4; i++) instead.
",1,46909591
46909686,"
Your array has 5 elements.
Comparing the current element with the next, your sorting loop need to run from 0 to  3, because with 4 it would be undefined behavior to access the next element because it's outside of the array. 
",0,46909591
46902111,"
The problem is in the swap function.
You are passing the object by value, you need to pass it by reference.
This should work.
",1,46902081
46902148,"
Have you test your swap() is working or not?
You should write it in this way:
For the reason that your code is operating the copy of Person a and Person b, and have no effort on the a and b in your sort function.
",1,46902081
46902539,"
Main problem in your code swapping does not work as intended in selection sort.
I would suggest to store index in min variable and swap values outside of second loop.
And don't forget to change parameter type as it is commented already
",0,46901039
46900933,"
Firstly, use a integer object, not a double, as you are working with 3 integers. Also, a<c returns a bool so it essentially doing:
instead, try 
",1,46900885
46896313,"
Update: This answer has changed slightly from the original
For an Arduino where resources are tight, this code would suffice, no need to link in extra libraries:
This is exactly how the std::shuffle function is implemented, limited only by the effectiveness of the implementation of the builtin Arduino random() function
",5,46895781
46896365,"
If you need to generate m random ones in an array of zeroes, you can simply iterate through the entire array and set the current element to 1 with the following probability P
In your case you need to set 4 random 1's in an array of 8 elements
This generates the random array in one pass - no need to post-shuffle anything.
P.S. In order to make the decision with the above probability P I used the oft-criticized rand() % (N - i) < m method. This is besides the point, of course. You can use any other method of your choice.
",4,46895781
46870508,"
The two versions are not logically equivalent. In the first version, j gets decremented only when both conditions are true. In the second version j gets decremented only when the first condition is true. j still gets decremented when the key comparison fails in the second version.
Because j is used as part of computing the loop's condition, this directly affects how many times the loop gets executed.
",4,46870471
46870525,"
In the first loop j decreases only when arr[j] > key condition is true. In the second loop j decreases every step. Let's say that arr[0] < key then the first loop will make 0 iterations, this example is the best illustration of these loops difference.
",1,46870471
46870953,"
Let's check both loops: Let j = 10, let key = 3 and arr[] = {1,2,3,4,5,6,7...}
In the first loop we have this pattern:
Output each step:
Simplified Output:

In the 2nd loop we have this pattern:
Using the same initial conditions from the first loop above where j = 10, key = 3 and arr[] = {1,2,3,4,5,6,7...}...
Let's output each step:  
Simplified Output:
These two loops are not the same and do not have the same behavior. The second while loop is going to execute more times than the first while loop.
",0,46870471
46871140,"
For first case your statements 
count++;
j = j-1
will be executed while both the conditions 
j >= 0 and arr[j] > key are true.
But for second case the statement j = j-1 will be executed only while j>=0 is true and the statement count++ will be executed while both the conditions 
j >= 0 and arr[j] > key are true. :)
",0,46870471
46864102,"
The following simplified version in pure C works fine:
As you request, the function of variable swapped is to indicate that following a complete pass through the array no swap occurred and so it indicates the array is now sorted.
",1,46863962
51022166,"
You can use an explicit bound on the outer loop. 
You should also split things out into smaller functions.
",1,46863962
46864230,"
another solution:
",0,46863962
46838345,"
If you really want to sort a linked list, which is not recommended, you would have to adjust your algorithm to work with pointers instead of array indices. This would look something like this:
}
You could write your own swap algorithm that applies to pointers, this might be difficult unless you keep track of the item before the ones your sending in the list.
",2,46837890
46838043,"
Because of not having quick access to every element in the linked list, all regular sorting algorithms will take too much time, especially in the singly linked list, so one approach will be to just keep list sorted in the process of insertion. Worst case O(n^2)
",1,46837890
46828777,"
The simultaneous effects of the for loop's ++i and the _item.pop_back() has the effect of incrementing twice, when you only wanted to increment once.
Change the for loop to a while loop:
Live Demo
",1,46828492
46828870,"
You are re-implementing std::min_element, and you if you use it, you don't need to find the element again, you also don't want to change the size of _item whilst looping over it's size().
You can also sort in place, as follows:
",1,46828492
46822242,"
So have you considered to change which variable holds the lower number? e.g.
Then you can just use one print
",1,46822227
46832098,"

This is where I'm getting stuck because I need two count[sic]
  statements to organize in ascending order as shown above

You have marked this post as C++:
Additional options to consider:
use algorithm lib:
or use conditional / ternary operator in your cout:
References are sometimes fun ... but perhaps this challenge is too trivial.
Pointers can do the same:
or you can use 

lambda expressions, or 
c++ functions, or 
c++ class methods 

But I think each of these would be directly comparable to either of the first alternatives.
",1,46822227
46819023,"
You are not checking front_ for nullptr before accessing front_->data.
But more importantly, you are not trying to insert the data in any kind of sorted position.  You are inserting only at the very front or very back of the list.  To insert in the middle, you have to scan through the list looking for the correct place to insert at.
Try something more like this instead:
",0,46818725
46819141,"
I did not see any code that searches the list to find where to insert the element.  You have not specified the number of elements you expect to have; the performance of a linear insertion into a sorted list is on the average O(n/2), which leads to the conclusion that you will overall have O(n^2/2) [that's n-squared over 2] which is intolerable if n is, say, 10,000 and irrelevant if n < 10.  I faced this problem 20 years ago with n > 200, on an 8088.  There is a solution that is approximately O(log2(n)), but without knowing n I don't want to spend the time to explain it if it is not relevant.
",0,46818725
46819282,"
Your code points to lack of clarity in your thinking.
You have to deal with the following cases:

The list is empty.
The new data is less than the values of all the items in the list.
The new data is greater than the values of all the items in the list.
The new data is in between the lowest and highest values of the items in the list.

Also, your use of ""prev"" and ""next"" seems a bit strange to me. When I think of a doubly linked list, I think of it as:
You seem to be using:
My answer corresponds to what I think you are using, the second version. If that is incorrect, the usages of ""next"" and ""prev"" need to be updated in a few places.
Case 1
Add the following at the start of your function:
Case 2
You need:
Case 3
You need:
Case 4
You need:

Putting it together:
",0,46818725
46814845,"
Otherwise you are getting undefined behavior.
Also in the output array formation 
You got the algorithm right. Now just dry run a bit. That way you can find these kind of errors in your code.
As the OP used the 0-indexing. I am using the same in my answer
In case you can't use vector ..allocate memory using new. Check the reference a bit for this.
Another thing is whenever you code counting sort always try to prove that you can hold the range in the auxiliary arrays. That helps.
Counting sort code:
main code
",1,46814723
46787727,"
You could sort subsequences of the initial array (in parallel, so in different threads) then merge them.
BTW the overhead is not negligible. You probably need to get an initial array of many dozen of thousands to observe a gain in parallelisation, and you are likely to sometimes observe some loss (e.g. with a too small initial array).
And for a first multi-threaded project, I'll rather suggest having a (nearly) fixed small set of threads (at most a dozen of them, assuming your computer has 8 cores). So both thread pools and futures are IMHO too complex for that.
Threads are heavy and expensive. They need at least a call stack (of a megabyte) each, and actually much more.
Don't forget synchronization (e.g. with mutexes).
This is a Pthread tutorial that you could adapt to C++ threads.
",1,46787683
46779735,"
here is the small example how you sort your cards (you have also to think about error handling it, didn't implement it):
",1,46778857
46778915,"
You can use std::sort  with vectors (you can read more in the documentation)
It takes as input an array like this:
std::sort(cards.begin(), cards.end());
",0,46778857
46782552,"
You have to have vector or array. If you are not allowed to use vector then create an array by first reading the array and counting the number of items (count). Create an array based on that size, then read the file again and set the array items:
To sort the values, break the string in to two parts. For example break H4 in to H and 4. Then run a comparison. The following uses lambda sort. Maybe you want to change it to something similar to the other answer.
For cleanup:
Note, you may wish to add exception handling for stoi
",0,46778857
46777284,"
The function qsort requires that the function type of the corresponding parameter would be
also this magic with pointers
is unclear and results in undefined behavior.
Thus for example the function compareX can be defined the following way
Or it can be declared with the ""C"" linkage
Take into account that in C++ you can use standard algorithm std::sort with a comparison function.
Here is a demonstrative program that shows the both approaches with using the standard C function qsort and the standard C++ algorithm std::sort.
The program output is
",2,46777092
46767471,"
As far as I understand, you'd like to retrieve the values of the map sorted in the mentioned way, but still have access to the key. Right?
Quickly speaking, a map is a collection of <key, value> pairs automatically sorted by key, then you may try a list of <value, key> pairs manually sorted by value instead. Something like QList<QPair<myStruct, QString>>, while overriding the operator< for myStruct.
Of course, it is a one-time use structure that doesn't keep updated with your original map, but you mentioned that the map is fixed (constant?) so it may not be a problem then.
BTW, a QMap can be used for the inverse look-up but only in the case the values of the myStruct part are also unique (so they can be used also as a key), otherwise you may overwrite values when constructing the inverse map.
Note: The std::tie is used just to simplify the sorting condition for tuples (so you'd need to include <tuple>).
UPDATE
Answering one of your comments: Yes, you can also specify your own comparison predicate and then avoid overriding the operator<, but I think it is harder to read and less re-usable:
Of course, you can implement that comparison lambda as you want, I've used the std::tie again to simplify the logic in the post. The downside is that if you need to generate the inverse map in several places you'd have to repeat the lambda expression everywhere (or create a function to create the inverse map of course).
As a side note and in case you are curious, lhs and rhs refers to left-hand side and right-hand side respectively, in this case they are used as lhs < rhs by the sorting algorithm for comparing the elements.
Finally, if you'd want to avoid the std::tie you'd have to make the comparisons manually (code below modifies the operator< of the first version):
",2,46765436
46771558,"
You can't sort a QMap manually, you'll have to use a QList (or QVector) for that and use std::sort on it. Use QMap::values() to extract the values (structs) from the map into a list, then implement a compare function/method and call it with std::sort. See cbucharts answer for some hints how to do this.
Keeping map and list in sync when the values change is a different issue, if this is a requirement you should create a separate question, adding a MCVE and more details on what you tried.
",1,46765436
46759118,"
It is not clear how cmp is defined but you can use this code and you will get the expected result.:)
The output is
",3,46758965
46750055,"
operator< of vector performs lexicographical comparison, i.e. it looks at the first position that is different in the two vectors and performs a comparison of the values at this position. This is about as optimal as it gets and having your vectors sorted won't make it any more efficient. You could write your own comparison function that (in contrast to operator<) assumes that the vectors are of equal size, but I doubt that would be worth the effort.
Edit: Some explanation why this is optimal (in some sense): Given that the order of the vectors should be based on their contents, you have to inspect at least one position. You compare the values at this postition, and if they are unequal, you're done. If not, you have no choice but to inspect another position, and so forth. The only thing that could be optimized here is the order in which the positions are inspected, trying to inspect postions that vary more strongly first. If that is possible depends, of course, on your use case. If you sort vectors much more often than you change them, you could also calculate some kind of hash for every vector and compare these.
Another Edit: There is in fact one small thing you can do: If you go through the vectors in sorted order and encounter the largest possible value your vector can contain, you don't have to inspect any further postions, because these will be equal anyway. The first vector therefore cannot be smaller. This is the only situation where the fact that the vectors are sorted makes it possible to predict the value of all the postitions that have not yet been inspected, so there should not be any further possible optimizations.
",1,46749707
46750549,"
One way o solve the problem is to create two kinds of methods, one that deals with the comparison and other one that sort the linked list.
The below method deals with comparison. In this case it is comparing the length of the string, but it could be anything.
The second method sorts the linked list. Even if there is a sort method, the easiest way is to keep the list sorted during the method AddNode.
",0,46748881
46742223,"
Each string is using the maximum space available, however maybe only needing a few characters.
",0,46742114
46734453,"
Yes.
You have to declare another array (we can say b) with length 101. The length represents and range of our numbers.
Now you have to over the first array and for each cell, and when you find every number k (0 <= k <= 100) , you have to ++ the b[k]. Something like: b[a[i]]++;  Now we have array b which represents how many times each number k appeared in the first array. We can override the first array:
While on your case, RANGE is 100.
Complexity: O(n)
Notice that we can implement that with one variable instead of using an array, which is doing the same thing, but every time for a different number.
Not saves much but saves a little Complexity of space.
",1,46734266
46708042,"
Here are some points for you:
instead of going [first, last) I would go (first, last] this is because you need to look at the previous value. But your way works too.
here you go through the right of i unconditionally. This is wrong. You need to:

first check if v[i + 1] >= v[i]. If not, the elements are in place. You can continue
else. You need to decrement all elements [first, i). For this the for should look like this:
for (int j = 0; j < i; ++j)
and you don't need to actual decrement by 1. you can see the difference between the elements and then subtract. For instance when you encounter the elements 6 1 you need to subtract 6 (6 - 1 + 1) from all elements up until i.

The rest is up to you.
",0,46703561
46707872,"
This is the super lazy implementation of the mentioned lazy algorithm: it has just O(n) complexity:
",0,46703561
46704437,"
after reviewing you code it seems you're making mistakes in the algorithm it self and in C++ as language so i've edited your algorithm to be more neat and more readable algorithm i will explain some part of the code 
Code 
1- I get rid of the printing inside the sorting function so we keep the code clean 
2- 
 the first error you've did at the language level is you didn't copy the returned sorted vector object from merge_sort_value to the vectors.(i've mentioned that in the code in a comment) so that's the first thing to keep in mind 
3- the logic part of the algorithm wasn't clear to me because i didn't see how you're sorting specially that part else if ((j == n) or (tmp[i] < v[j])) {
        v[k] = tmp[i];
        i += 1;
      }
like you're comparing unsorted sub vector to another unsorted vector and you're giving it unsorted value again (you must compare v1 against v2)
the whole logic is missed up i think you need to review it 
anyway i hope that helped  
",0,46701827
46698113,"
An iterative algorithm that uses a ""kind of"" merge sort to sort an array in-place could look like below.
Let's take this unsorted array as example:
The algorithm will have an outer loop on the size of the merged arrays. So at the start this size is 1 (nothing has been merged yet). Then in each iteration this size is doubled, which effectively takes two already sorted, consecutive segments together in a merge.
The actual merge will use two indexes in the to-be-merged segment: one at the start of each of the two segments that are to be merged.
As long as the value at the left index is less or equal to the other value, the left index is incremented (moves to the right). In the other case the most complex operation in this algorithm is executed:
The values between the two indexes are shifted to the right and the rightmost of those (the value at the second index) is moved to the first index. So the values cycle around one position. After this cycle, both indexes are incremented.
This process is repeated until either the left index reaches the right index, or the right index reaches the end of the second segment (which can be the end of the array). When this happens the merge is complete, and the two segments will be considered as one in the next iteration of the outer loop.
Here are some images illustrating these steps as they would be performed on the example data:

Here the merge is performed to make segments of size two. Sometimes the last segment will not have a full size, but that is not a problem. For each of the colored segments, the two indexes are placed, one pointing at the first of the two values, and the other to the second value. Where the first value is greater than the second, they are swapped. In case of a swap both indexes are incremented and the second index reaches the end of the second segment (which was only 1 value wide), and so the merge ends. In case no swap happens, only the first index increments, but reaches the second one, so then also the merge ends (without having made changes).
It becomes more interesting in the second iteration of the outer loop:

The first segments to be joined are [3 4] and [5 8]. The two indexes point to 3 and 5 respectively (underlined in blue). The left index is incremented as long as the corresponding value is not greater than the value at the second index. In this case that means the first index reaches the second without any changes. For the second pair of segments, there is more work to do:

Now [2 9] and [1 5] need to be merged. As 2 is greater than 1 the cycling operation kicks in: 1 has to be shifted in, pushing the 2 and 9 one position to the right. Both indexes are incremented. Now 2 is not greater than the other value (5), so only the first index is incremented. Finally, 9 is greater than 5, so they need to be swapped, and then the merge is complete for these segments.
A similar sequence of operations is executed for the next pair of segments:

The last ""pair"" of segments, really does not have a second segment: the second index points beyond the array end, so there the merge stops immediately.
Again the outer loop iterates, doubling the segment size. Now the following has to be merged:

Note how the 1 (at the second index) is shifted in before [3 4 5 8], which all move one position to the right to make room for it.
The same happens with the 2: it is shifted in before the same 4 values again.
But then we find that 3 is not greater than five, and the first index increments until it points to the 8. There the 5 is injected before the 8.
Finally, 8 is not greater than 9 so the second index reaches the end point.
I will not present the same for the other segment, and the final iteration of the outer loop, which will do one more merge.
As you requested, I provide no code ;-)
Some considerations
Although this could be named a merge sort, the cycling of values really defeats the efficiency of the original algorithm in the worst case scenarios. True, the number of comparisons is still the same, but the number of moves can be more. Take for instance the values [3 4 5 8]  which are moved twice to make room for a moving 1 and moving 2. This already totals to 10 moves (and the merge in that step is not yet complete), while the original merge sort will always make the same number of moves as there are values in the segments that are being merged. In the better cases, this algorithm needs no movements at all, or fewer than the original algorithm.
This method guarantees a stable sort.
",1,46695942
46698870,"
You mention constant space and in place. 
If the in place merge sort doesn't have to be stable, you can swap elements instead of moving them between arrays. Do a merge sort on the left half of the array into the right half of the array, swapping the merged output with the right half of the array, so that the merged output ends up in the right half of the array, and what was in the right half of the array ends up swapped to the left half of the array, reordered (this is the unstable part) but unsorted.
Merge sort the 2nd quarter into the 1st quarter of the array, so that the 1st quarter ends up with sorted data, the 2nd quarter ends up with reordered but unsorted data. Then merge the 1st quarter with the 2nd half of the array into the array starting at the beginning of the 2nd quarter again swapping during the merge operation. The last 3/4s of the array ends up sorted, and the first 1/4 array is reordered and unsorted.
Merge sort 2nd eighth into 1st eighth, then merge sort 1st eighth with last 3/4 of the array, ending up with last 7/8 sorted and first 1/8 reordered but unsorted.
Continue this until there is only one or two unsorted elements on the left. These can be put in place doing a partial insertion sort for the one or two elements.

If using constant space and the merge sort needs to be stable, you can use bottom up merge sort, moving part of the array into the constant space, merge into the now freed space in the array, then repack the array to fill in the one or two gaps left behind by the merge process, and repeat until you reach the last remaining freed part of the array, at which point you can do a normal merge sort using the constant space and the freed part of the array. This completes one pass of the merge sort. 
",0,46695942
46674769,"
If the input range is non-empty and no element in it satisfies the predicate, your code will be stuck in the goto loop and not reach the while again. Eventually, --end will take end before first.
If this is a learning exercise, I suggest you get rid of goto; you don't want to be learning bad practices and while goto can have rare legitimate uses, replacing loops is not one of them. Also, the dance with tmp can be replaced with std::swap.
If this is not a learning exercise, just use std::partition which does exactly what you want.
",3,46674584
46653088,"
You can use std::begin and std::end to determine the start and end points of your array, assuming you are on C++11.
So:
",2,46653046
46739780,"
Well, thing is I ended up solving the issue myself.
Apparently that was a collateral effect of a huge collection of bugs. And when I say huge I mean dozens. Undefined behavior is a true pain in the ass.
It's a pitty that sanitizers and softwares like Valgrind are unable to te identify properly what code is corrupting stack memory sometimes. The sort function was just accessing an already corrupted linked list in this case. Wonder If there's any more precise/detailed tools for this.
Anyway, thank you all.
",0,46638577
46637177,"
If you are going to do merge that way, you might as well be doing selection sort; the merge steps are all quadratic and you are still doing a logarithmic number of them.
In-place mergesort is tricky (and not as fast as mergesort). You should just merge into a temporary vector and then copy back over the original. Or avoid the copy by alternating between two vectors as you recurse.
",0,46637116
46637159,"
Bubble-sort is an O(n²) algorithm, which is slow. Merge-sort is O(nlogn) which is fast.
To unserstand the spees of these algorithms see https://www.toptal.com/developers/sorting-algorithms
",0,46637116
46636002,"
Turns out dynamically allocating the array fixed the problem! Thank you @RetiredNinja! 
As @user4581301 pointed out, ArraySize is not constant in the original code and may not compile with all compilers. Using vector might also be a better idea for any program.
Solution using vector (recommended):
There is no need for freeing memory manually, as std::vector cleans up after itself, as pointed out by @MikeMB (Thanks for inputs!). However, the std::sort method needs some editing. For sorting the vector, use
Solution using new (usually not as good as using vector):
Also, freeing the memory before returning might be a good idea:
",0,46635594
46600114,"
If you change names into a std::vector, then you can populate it using push_back. You could fill names like this.
Alternatively you could fill all the words into names and then utilize the Erase–remove idiom.
",1,46599863
46574110,"

Do vectors not sort uppercase AND lowercase?

No.
std::vectors doesn't sort (simply appending elements).
std::vectors maintain the order of insertion.
If you want an insert-and-ordering container, you should use std::set (or std::multiset).
",0,46574042
46537522,"
you want the values to be sorted by arr[i]%m, and if two values are equal then you want to sort by arr[i]/m.
See here for a working example.
",1,46537364
46539857,"
Simply:
",4,46537364
46537476,"
Pair arr[i]%M and arr[i]/M now calling sort(arr,arr+n) in ascending order with respect to arr[i]%M and if arr[i]%M are equal with arr[i]/M. If you want a different sorting write a function and call sort like sort(arr,arr+n,func).
Also see this.
http://www.cplusplus.com/reference/algorithm/sort/
http://www.cplusplus.com/reference/utility/pair/
Here sorting by a[i] is equivalent to sorting by a[i]/n and you can get second elements by v[i].second.
",-1,46537364
46535687,"
You can fake a non-clumsy data structure with
Where vector<string> is a single record. To make it ""manageable"" I'd use some aliases, accessor functions and this enum:
The code becomes a lot shorter:
Live On Coliru
For the input
Prints
",0,46535399
46535765,"
Why dont you use parallel vectors, and when you order the years vector, if you swap position i with position j, do it on every vector.
",0,46535399
46533879,"
When sort(v.begin(),v.end()) is called on vector< pair< int,tuple< string,string,string,string> > > v it sorts by the int.
",0,46532051
46524936,"
I'd bundle the pairs together while reading, making them easy to sort:
",3,46524870
46525094,"
You can gather your lines by pairs into a vector of std::pair<std::string, std::string> : 
and sort them by their .first:
DEMO
",2,46524870
46524971,"
Yes, there is.
View the entire file as a map of key and value pairs, read into a std::map<std::string,std::string>, then output the map. Since string compares are lexicographic by default and maps have ordered keys, the map will do the sorting for you.
",1,46524870
46528972,"
Here's a take that works nicely if you have a file that's too big to fit in memory, or, in general you need the efficiency.
It combines

a memory map¹
string views²
standard algorithms

Live On Coliru
Prints

¹ it's trivial to use POSIX mmap instead of the boost thing there
² you can use std::[experimental::]string_view if your compiler/library is recent enough
",1,46524870
46514625,"
Heap-sort is slow compared to quicksort. Of course, a vanilla quicksort is slow,too, but it can be made very fast by using insertion-sort and some fallback for the rare cases where a part of the range is suboptimal for quicksort. In practice std::sort() is a hybrid algorithm. For more details see my Quicker Sorting presentation.
",2,46513598
46514662,"
Er, no, heapsort is used in the Standard Library.
The introsort, created for the Standard Library, works by being “introspective”. It sorts using a quicksort, but if the quicksort becomes too expensive, it switches to a heapsort.
edit
In order to improve an answer to the underlying assumption of the question, there needs to be made clear a difference between algorithmic complexity and actual speed.
Big O, Big Θ, Big Ω
The complexity of an algorithm (commonly measured using Big O and related notations) has little to do with the actual speed of an algorithm. What these notations represent is a relationship between n (the size of input) and the degree to which the algorithm’s computational complexity scales as n grows towards infinity (or anything sufficiently large). This is why you can throw out all but the most significant term in the complexity polynomial: as n grows large the most significant term dominates all the others.
Another way of putting it is that Big O notation tells us how much slower our algorithm becomes as the size of the input grows larger.
Big O is of especial interest because it represents an algorithm’s worst case behavior when n grows large. Any algorithm runs fairly quickly when n is small. If all you have are a few hundred inputs, an O(n3) sorting algorithm will work fine. But for any enterprise-level business application, with literally millions of data, it would be very costly to use such an algorithm. (It could even cost you your job.)
Worst case ≠ normal use
There is another issue. Big O only tells you what the worst case behavior is. This is where you need to understand the data that you usually supply to a function. If you can normally avoid input that causes worst-case behavior, then an algorithm with a poor Big O rating might not actually be that bad.
This is the case of a quicksort. Quicksort has an O(n2) behavior for the worst case — which can and does happen — but it also has the really nice property that the worst cases are a very small subset of all inputs. That is to say, for any random input (and that is important here), you are more likely to have a good-case behavior than a worst case behavior. This is actually a very significant property. Not all algorithms are this cool.
Know your data
Again, being able to control for the data you process is significant. Guessing, or making any kind of generalized assessment is just plain bad programming[1]. Always profile for all possibilities. Fortunately, quicksort and heapsort are both very old and very well-understood algorithms. They have frankly been studied to death. The reason we use them is because they have stood the test of time. Other algorithms have not, so we don’t study them much.
But... unknown data?
Quicksort has a very good behavior for most inputs. But here is the wrinkle: if we allow any random input we also allow bad input. If we presume that we cannot control for all bad inputs (because we are accepting any data), it is entirely possible for an attacker (or even just a poorly written input process) to give consistently bad inputs that bog quicksort down. 
Heapsort, on the other hand, cannot be bogged down. It has a nice Θ(nlogn) operational complexity. (Remember that Big Θ is a very tight bound on both worst and best case behavior.) 
So why not just use heapsort? Because heapsort is actually slower than quicksort for each n. In other words, the algorithm does more stuff for every loop than quicksort; Quicksort is a very lean algorithm in comparison. So for even small inputs, quicksort does less work than heapsort, and is physically faster for every n.
Computer architectures make a difference too. Quicksort also has a better cache/access behavior than heapsort. Heapsort uses random access across the entire input. Quicksort quickly settles down to work on only small pieces of the input at a time, making it cache friendly. (You can even offload the pieces to multiple cores for increased performance; something you cannot do with heapsort.)
Finally, quicksort can switch off to insertion sort for n < [50,100]. Heapsort cannot[2]. (And here again you see a trade off. For less than 50 to 100 elements, nothing beats insertion sort[3], even though insertion sort is clearly inferior for even relatively small n.)
Introsort to the rescue!
Introsort solves this problem by being “introspective”. It recognizes when quicksort has found a worst-case input and switches to a heapsort, thus preventing quicksort from degenerating into an O(n2) problem.
Notes:

I even just recently had someone give me grief after asking him to stop making generalized statements about unknown input probabilities here on SO, LOL. Generalizing about your data is BAD. Just say NO. ;-)
I keep making references to the inner workings of quicksort and heapsort. You should look them up. But better, take this away: O(n) only gives you one piece of information about an algorithm’s behavior. If you want to know how an algorithm behaves on your data, profile the quiznak out of it using your actual data. Then seek to control your data or choose an algorithm that better matches it.
Yes. Insertion sort rocks. For really, really tiny n. Don’t forget it. The takeaway: it is okay to intelligently combine multiple algorithms to handle your data well. Profile, man! Just do it!

",1,46513598
46511516,"
Use an std::multimap, which keeps the keys sorted, and allows for duplicate keys.
Example:
Output:

PS: Another approach would be to use std::multiset where every element would be std::pair, where the first would be the number, and the second the cumulative sum.
",1,46511214
46499964,"
As VTT and Peter rightly pointed out, my comparative needed to be marked as static because it was a member of a class.
More information on this can be found here under requirements and BinaryPredicates. 
Thanks for the help
Solution.
From:
To:
Thanks again for the help
",0,46499812
46461623,"
Read more about C++11 at least (or C++14 or C++17), e.g. some good C++ programming book (any standard older than C++11 is obsolete, and C++11 has evolved a lot since its predecessors, so you should almost consider C++11 as a new programming language). Look also some C++ reference site.
[](const string &left, const string &right) starts a lambda expression, that is an anonymous function implemented as a closure.
Then you have a range-for loop: for (const string &s : a) which could even be for (const auto& s: a) or in your case for (auto s: a) because the auto specifier brings a limited form of type inference.
Read also SICP to improve your views on programming (it is not about C++, but an excellent and freely downloadable introduction to programming).
",0,46461548
46459380,"
I suppose you have to call func(), inside test(), as
instead of
",0,46459176
46434907,"
You need to provide comparitor functions that compare individual rows during the sorting. Hopefully you’ve got a modern version of C++ and can use lambdas:
Once you have sorted by a specific column you can iterate through the sequence and count consecutive fourth column 1s.
edit
The lambda is a way of creating a function object on-the-fly. The above is equivalent* to:
The [] is the “capture list” that introduces the lambda.
Read more about lambdas.
(Sorry I don’t have a better FAQ up for the world yet...)
* Roughly. It is actually a little more complex than this behind the scenes.
",0,46433368
46381294,"
This is not possible using the standard library set.
The comparison operator is tightly coupled with the ordering.
Although a bit worse solution in terms of performance, you could have a set that contains all your objects, sorted by 'a' only using:
And then, whenever you want to sort it using your unique algorithm, just copy it into a vector and sort it according to your needs:
Edited
This implements the logic you used in your Pastebin example.
Entire sample here
",0,46381134
46382126,"
There's a ready-made library for this kind of thing in boost called boost.multi_index.
It allows the declaration of a container that satisfies multiple indexes and their constraints.
It's a little archaic and could do with some love but it does the job.
You can start with something like this:
",0,46381134
46377465,"
If you're using the container to insert/remove in the middle frequently then the std::vector might not be your best bet.
Think about it: std::vector stores elements in contiguous memory, so every time you want to insert in the middle of it, you will move all the elements after it. It's faster to look up (even more if it's sorted) but the overhead on insertion is something to have in mind.
You could take a look at lists or other kind of containers which implement a linked list, since insertion is as simple as creating a node, changing next and prev pointers of the element before, the element itself and the element after.
Hope it helps
",0,46376120
46349053,"
You should call QSortFilterProxyModel::invalidate to indicate that the current sorting is invalidated, i.e. a new sort action should be performed. 
Note that calling sort explicitly will also work when dynamicSortFilter is false or you specify another column or order as can be seen in the code:


",0,46347275
47517949,"
The problem is with the line:
Change that to:
And then in one of your .cpp files have:
Having the code (in the header is fine, so long as the definitions are inside the class body or they are declared with the 'inline' specifier.
",1,47517675
47518232,"
You can clean this up and split it out into separate files which helps from an organizational perspective.
In your .h header file you try and stay focused on laying out the big picture:
It's worth noting that from an object-oriented design perspective you want to avoid exposing internals that should not be accessed by other code. Keep these private or protected depending on how you want to lock down access.
Then in your bridge_lt_str.cpp implementation file you define how these work:
Do try and flag things as const in your arguments if you're not intending to change them. The isDenomLess function doesn't modify those strings, so const std::string& is the appropriate type for those arguments. Leaving out const usually communicates an intent to modify them. It can also annoy those trying to use your function when all they have is a const string and for no reason you need one that's non-const.
In some other file like main.cpp you can then use your class:
You'll need to link both the compiler output from main.cpp (e.g. main.o) and that from the other one (e.g. bridge_lt_str.o) together. This is standard in any non-trivial C++ program so you should have a Makefile or equivalent to do that for you automatically.
",1,47517675
47516256,"
It might be that the overhead for distributing the data into multiple parallel processing units and combining the result back again exceeds the performance gain due to parallelising the code. 
I'd suggest you to increase your input size to see a considerable performance gain. 
",1,47516118
47516915,"
In your case the time to create thread, allocating memory and time slice by O/S to each thread is taking more time than time taken to short the data. 
Performance of parallel processing can be seen only when it process large volume of data. Besides lots of other factors also need to be considered in multiprocessing or parallel processing, like system memory number of processors etc. You can get lots of online document on this topic.
",0,47516118
47515717,"
This is a relatively straightforward change:

Increment comparison count before the if statement
Increment the swap counter inside the if statement

Take two int& parameters for the count, like this:
The code incrementing the counters would look like this:
The call from the main() would look like this:
",3,47515667
47515753,"

However I was curious how can I find a number of total comparisons and number swapping that bubble sort makes? I created a CountBubbleSort integer for comparisons. However I'm not sure in which part of my code should I increment it.

There's exactly one line in your bubbleSort() function where you actually compare two elements in the array, so it stands to reason that if you want to count the number of times you compare elements, you should increment the counter either immediately before or immediately after the comparison happens.
",1,47515667
47504675,"
isn't going to do anything, algorithms take the start and one past-the-end, In effect you are saying to sort zero elements. Add the correct size instead of 1.
",2,47504621
47501076,"
These two sorts have been analyzed mathematically and the results show that a Merge Sort is likely going to be faster in most cases.
The Quicksort analysis shows a range and the best case scenario is equal to the Merge Sort timing:
I think that the Wikipedia analysis explains pretty well why one is eventually faster than the other. As Kenny Ostrom commented on your question, what you should do is count the number of comparisons, which is not easy to do if you're implementation uses algorithms and with optimizations you never really know how many compares and branches are going to happen once you run the code (i.e. newer processors have conditional MOV instructions meaning that you can avoid branches altogether!)
However, if you are looking for a pure analysis, then speed in itself is not an issue (i.e. you don't need to time the function), but instead just count the number of times you do a compare and the number of times you swap two entries. This gives you the timing for a particular array of objects, whatever the objects (although the compare function could be really expensive: imagine comparing two images that require some OCR work before they can be sorted...)
Why is speed not an issue when doing analysis?
If you read the Merge Sort algorithm on Wikipedia, you will notice that they mention the fact that to reach  the best case scenario you need to properly implement the algorithm. So if you wrote it yourself or use a version that's not well implemented, then you could find that the Merge Sort is slower than the Quicksort.
",2,47499936
47489902,"
Refer to this documentation, you need to use omp_set_nested as shown in the link. To have parallelism, declare it where you've done #pragma omp parallel sections and also don't forget to set OMP_NUM_THREADS
",0,47488805
47481830,"

Is putting integers into a vector, and then sorting faster, or putting integers into a set

Both have same asymptotic complexity O(n log n).
Set is a more complicated data structure, and it is most certainly going to have higher significant order coefficients and thus will be slower than a sorted vector by some factor in practice.
Whether the complexity difference has any significant impact to the performance of the program, depends on whether the size of the data structure is significant enough compared to other sources of complexity. This can be measured with a profiler.

However, if for example you were to need to keep your data structure sorted between insertions, rather than only after all insertions, then set would be asymptotically simpler O(n log n) than sorted vector O(n2).
Asymptotic complexity only guarantees that beyond some input threshold, set will be more efficient. But due to smaller coefficients, vector is probably still faster for inputs that are below the threshold. Many factors affect the threshold, such as hardware. To find out the threshold on a particular system, you can measure with a profiler.
",4,47481353
47481443,"
You can pretty simply determine average run times for a function call (like sort) using the C++ high resolution clock and getting the difference between two time_point's retrieved with now.  This answer contains a good explanation of how to use that bit of the chrono library: C++ Cross-Platform High-Resolution Timer
You can use this kind of measurement to determine how long sorting takes in each case, but you should also bear in mind that set sorts as you go whereas a vector is sorted when sort is called on it.  If your application can benefit from amortizing the cost across multiple insertions -- for example, you insert elements into the set and access elements in the set in interleaved operations, vs. inserting all elements at once, sorting, then only accessing the sorted collection later -- set might be the right choice.  Several commenters have already mentioned that the right choice depends on your application, and it's why the advice is to decide on your own benchmarks and then measure them.
",1,47481353
47479028,"
In normal English usage, when we sort words alphabetically, we employ two rules:

If two words have the same first letter, we compare the second. If the second letters are the same, we compare the third, etc. Finally, one word comes before the other if the first differing letter comes before the corresponding letter.
If two words are identical up to the length of the shorter word, the shorter word comes first.

So ""Tom"" comes before ""Tooth"". The first letters are identical (""T""), the second letters are identical ""o"", but the third letters diff and ""m"" comes before ""o"". Therefore ""Tom"" comes before ""Tooth"".
""Tom"" comes before ""Tomas"" because the two words are identical through the first three letters ""Tom"" and ""Tom"" is shorter than ""Tomas"".
Lexicographic order is simply alphabetic ordering, generalized for non-letter values. Consider a sequence of values, not necessarily letters:
(1,5,10) comes before (1,6,3) because ""5"" comes before ""6"".
(1,5,10) comes before (1,5,10,15,20) because (1,5,10) is shorter than (1,5,10,15,20).
Lexicographic ordering is particularly useful if the elements of the sequence have some specific meaning, with the earlier values giving a higher precedence. For example, consider these times: 9:13 AM and 8:25 AM. If we represent these with the sequence (9,13) and (8,25), then (8,25) comes before (9,13) because 8 comes before 9. What if the hours are the same? For example, (9,13) comes before (9,45) because 13 comes before 45. As you can see, lexicographic ordering allows the hour field to have a higher precedence than the minute field.
",3,47478926
47478963,"
In layman's terms, this means alphabetic order. In practice, you'd be sorting the strings character by character, according to their underlying numerical (usually ASCII) representation.
",2,47478926
47478956,"
Most of the out of the box string sorting algorithms are implemented as lexicographic sort. (More Details at the Bottom)

Example 1: 

Random Elements:
Sorted with lexicographic ordering:

Example 2:

Random Elements with different length:
Sorted with lexicographic ordering: 

Difference between lexicographic and natural sort",2,47478926
47484796,"
Problem solved. The thing is I didn't set the position of items, but only work with theirs rectangle's property. The on_comparision function should looks like this: 
insted of 
",1,47475882
47473245,"
The problem here is that you have a vector of pointers. Therefore the comparison done by std::sort is done using the pointers and not the structures pointed to by them.
For it to work, you have to either provide a global operator< function which takes two pointers as arguments. Or you provide a comparison function as a third argument to std::sort. Both needs to dereference the pointers.
Also, you still need to mark your functions as virtual for polymorphism to work.
",8,47473111
47468312,"
In this section
When r = l + 1 you get m = l and then you call mergesort asking the function to sort an empty vector, while the code of mergesort assumes that it is not empty. 
What is
in this case?
This should be a good starting point to carry on debugging. 
",2,47468216
47469057,"
The problem is in memory allocation for vectors L and R in function void merge(std::vector<int>& A, int l, int m, int r).
Following is corrected code snippet, though not optimized(You are free to do optimization ;) ):
You can find the complete working code here
",0,47468216
47454951,"

For the parallel algorithm to work, the individual iterations of the for loop should be generally independent. In this case, the individual iterations are not independent.
The race condition can happen not only in i++ part, but also on the swapping part.

",1,47453983
47423216,"
Have a look at http://en.cppreference.com/w/cpp/algorithm/stable_partition and use it like this:
",0,47423136
47423546,"

what i need is something like : in a array of 5 elements {1,2,3,4,5}
  and interval A(2) and B(4). result should look like {2,3,4,1,5}.  i
  dont need the code above if there is other ways. its just what i have
  found and tried to use.

You can use standard algorithm std::stable_partition declared in header <algorithm>.
Here is a demonstrative program
The program output is
",1,47423136
47414470,"

What would happen if I take it out of the struct definition?

Assuming you do it intelligently, nothing terrible. Your sample could just as easily be rewritten as:
But now the comparison is done via an indirect call. The algorithm will have to call the function via a function pointer. That can be harder to inline.
On the other hand, the call via the functor object is resolved statically. The compiler has more type information. It knows the type that function is a member of. It resolves the call directly. And that can be more easily inlined.
The difference is in how much the compiler can glean from the type information it is given.
Also, it should be noted that you can have all of the above without the hassle of choosing a name for a new type. C++11 introduced lambda expressions, and their closure types. You can easily rewrite your code to this idiomatic form:
There's just as much type information present as there was in the named struct version. You are just saved the hassle of dealing with boiler-plate, and get to have the comparison criteria embedded in the call to sort itself. 
",4,47414302
47414434,"
According to std::sort documentation, its Compare type argument must be a

comparison function object (i.e. an object that satisfies the requirements of Compare) which returns ​true if the first argument is less than (i.e. is ordered before) the second.

In other words, this version of std::sort's third argument must be a function or a function object, something which can be invoked with the operator(). Without that operator in less_than_key,
is ill-formed (won't compile).

With C++11 and following, you could write:
",0,47414302
47414531,"
Change your assignment operator like this:
You have wrong &p == this check, return too early and no return path on the else path (at the end).
And your comparison operator like already pointed by @StoryTeller to:
You can also make your comparison operator const, use std::string etc.
",1,47414225
47347615,"
You can use array of structure to get input and then use built-in sort according to a compare function.
",3,47346980
47348283,"
You shouldn't need to implement many operations.
Define your ordering relation:
Read the data:
Sort the data:
Insert while maintaining the order
",1,47346980
47344672,"
No, it is not O(log n). Idea of binary search is to reduce the search space by half each time, which your code is not doing.
If array is ordered, majority value could be the middle value. To verify this, let mid be the middle value.
Find the lower_bound and upper_bound of mid check if difference is greater than half of array size.
code :
",1,47343805
47341563,"
You're never setting smallestVal to anything from the array. You don't need nested loops. Just go through the array once, comparing each value to smallestVal. If it's smaller, you set smallestVal to that value. You should also have a variable that holds the index of the smallest value, which you update at the same time.
At the end, you swap the first element with the smallest one.
You can then increment STARTLOOP and repeat this.
",0,47341488
47341617,"
What you want to achieve is some sort of a modified insertion sort. Check out this implementation :
What this function does is that it searches the array every time for the smallest element starting from index i and when it finds this element it keeps on swapping it will all of the previous elements in the array until it reaches a smaller element.
",0,47341488
47335216,"
With STL containers you can use std::sort function. First two arguments define the range of elements to be sorted. Third argument defines a LessThan function used for your custom elements comparison (you can use lambda expression for that).
",2,47334667
47317853,"
Well, the way that sort is going to be implemented is that it will swap objects as needed. A class with a const member and no copy or move assignment operators is not going to be ""swappable"".
I would probably make the id member private and non-const. Then I'd have it accessed via a getter (but not providing a setter). Making it logically const, but the class would be copyable.
Something like this:
",4,47317740
47318321,"
Direct functions calls are inlined automatically most of the time. 
The complexity in your example isn’t that you call »the getter« twice but that you do your calculation several times – for all comparisons with a specific element. 
Using unordered_map you also have to create the hash table first. 
Have a look at these benchmarks.  
Using the members directly vs a getter function makes no difference.
The hash lookups are 10 times as slow as doing the calculation for each comparison.
If you have to sort several times it may be useful to keep the calculated value (cache) by storing it as a pair (as a cheaper alternative to a hashmap). 
Using pointers to your class instead of values may change the performance (for the worse) but it shouldn’t change the observed differences. 
",0,47317193
47314772,"
The logic used in the compare function is not correct. It does not meet the requirements of strictly weak ordering.
Change it to:
",3,47314698
47318675,"
Your problem (finding lowest x value and highest y value) is ILL-POSED, since the lowest x value may be another point than the highest y value. You must not ask for both at the same point, but be clearer what you actually want. There are a number of possibilities:

The highest y amongst the points with lowest x

the lowest x amongst the points with highest y

the point with maximum difference y-x


From your example, I guess it's the last one of these that you actually want, as [48,498] has neither the lowest x nor the highest y, but the largest difference.
Finally, for merely finding the maximum of (some function of) some values, you don't need to sort them, but merely do a single pass:
",1,47314698
47314892,"
The C++ sort function your are calling is quicksort, so each elemento will be evaluated multiple times. You need a more strict to make sure each possibility is evaluated by the function.
",0,47314698
47299913,"
I've created a minimal example for you to reproduce the behavior:
Before you read further, can you figure out the reason on your own now?
std::string::operator= has a few overloads, and the one that fits the most here is std::string::operator=(char ch). 100 is ASCII code for 'd' so that is what Jackson's grade turns into when you assign its value to a string grade in your information struct.
",2,47299730
47264411,"
If you use the middle element rather than the last element in the list (and rearrange the algorithm slightly), you can avoid swapping.
For optimum qsort, you are better off using the median of the first, last, and middle element (known as ""median of three"").  
If you are concerned about the performance sorting attacker generated data (qsort has average O(n log n) performance, but worst-case O(n²)), use a random pivot.
Note:  I can see the question is about partition and not qsort, but it's quite likely to be in the context of qsort.
",0,47264035
47249157,"
With a correct sign, the code works fine:
Result:
",1,47249031
47233055,"
What you posted is not a true translation of the Wikipedia pseudo code.
Welcome to StackOverlow. Before you post another question, please read all the links about Asking.  Pay particular attention to the one about MCVE
",1,47232638
47227013,"
There is something very wrong with your merge_sort function:
You're unconditionally calling merge_sort inside of merge_sort. Even if your program didn't crash, it would never complete, and probably be killed by your system because of the mess it's causing.
I suggest you to get more comfortable recursive functions before trying to fix your code.
",0,47226919
47229460,"
The mistake is the displacement of brackets.
",0,47226919
47227169,"
Oups, you have still to improve your C++ knowledge...

int temp[a] is not valid C++ as you have been told in comment - Variable Length Arrays are a C feature
b is passed as a pointer (an arrays decays to a pointer to its first element when passed to a function). When you write b=temp; at the end of you function, you only change a local copy... which immediately goes out of scope: in short the current code is just a no-op.
array indices start at 0

If you want to train in using pointers, you could do something like that:
",0,47226294
47225251,"
In selection sort you find a minimal (or maximal) element and put it to top (bottom), then repeat it again for the rest of list.
It would be a selection sort, but you don't need to do swap every number you compare to find the smallest one. Store smallest number index in each internal loop and do one swap at the end of it.
",1,47224918
47218122,"
The problem is that you're using the same index as the index into both list and greaterThan. Which means that when a number is not greater than 10, you skip that index in greaterThan, and that element is left uninitialized. And when you're printing the results, you're only going up to finalCount, even though you filled in higher elements of greaterThan.
You should use a different variable for the index into greaterThan. You can use the finalCount variable, since it's incremented exactly as you want.
",3,47218053
47209542,"
You can use std::function as comparator type and then provide particular comparator for constructor:
note you cannot change comparator after creation of set, you have to create another instance:
and that would involve copying or moving whole set. If you want to be able to use both ways at the same time use boost::multi_index instead.
",4,47209421
47210160,"
You can do it via template:
Prints:
",1,47209421
47193874,"
I would use std::lower_bound for this. It returns the correct insert position in a sorted container to keep the elements sorted.
Sample Output:
To get this to work on a user defined type you will need to define certain functions that enable the class to be sorted and tested for (in)equality.
For example:
",0,47193727
47186892,"
When you construct the right vector, you are adding a number of elements equal to middle, when you should be adding vector_sort.size() - middle number of elements elements. Because division rounds down, this causes you to drop the last element on lists that are odd length. And because you merge sort down to 0 or 1 elements, it causes your results to be powers of 2.
",2,47186777
47159489,"
mediaDescrescator is a member function of Studenti. It's defined withing the lexical scope of the class. So you can access Studenti::mediaDescrescator, but not mediaDescrescator. There is no function named mediaDescrescator in the global namespace.
Also, to ward off the next error you may face, be sure it is a static member function. You don't need a valid instance to call it, after all. It doesn't access any member variables of this.
",5,47159407
47159625,"

std::tie returns a std::tuple of references.
std::tuple defines comparison operators which perform correct lexicographical comparisons.

So all you need to do is turn Studenti into a tuple with tie - then compare the tuples.
You may find it useful to provide a method called as_tuple() on classes that you write:
",5,47159407
47159680,"
There are several problems with your implementation. The first, and the one that your compiler complains about is that mediaDescrescator is defined in the scope of Studenti and you try to access it in the global scope, use Studenti::mediaDescrescator to get a pointer to it. Second, mediaDescrescator is a normal member function of Studenti and as such it will need to be called on an object. This can be fixed, e.g. by making it a static member function instead, or by making it take one parameter and compare against the current object. Third, the std::sort function can not be applied to an std::list as it needs random-access iterators and std::list only provides bidirectional iterators.
",2,47159407
47159621,"
Change function declaration to:
Basically have it outside the class.
If you don't want to make the members public, write getter functions for them and use them instead inside the sort.
",1,47159407
47160576,"
Firstly, if mediaDescrescator() is a non-static member function, it only needs one ""other"" parameter because it can work the this member.
Secondly, lambdas are easy to have algorithms work with member functions (not tested):
You could also implement the order function directly in the lambda as combined with Richard Hodges' answer (in this case with public members):
Based on Johan's answer: std::sort can't be used on std::list, use std::list<>::sort() instead as in my code snippets.
",1,47159407
47151611,"
Your algorithm sorts the array, but then looses the sorting again.
You want to swap elements only when i > j, in order to push elements to the top only. As a result, you need to change this:
to this:

Consider this array example:
Your code will sort it to:
but when i = 3, it will try to populate the 5th cell, and it will swap it with rd 2, which is not what we want.
This will push rd 2 down, but we don't want that, we want gaps (zeroes) to go to the end of the array, thus we need to swap eleemnts only when they are going to go higher, not lower, which is equivalent to say when i > j.

PS: If you are a beginner skip that part.
You can optimize the inner loop by using one if statement and a break keyword, like this:
",0,47151415
47151608,"
If I understand your requirement correctly, you want to move all the non-blank entries to the start of the array. To do this, you need an algorithm like this for example:
So, starting from the beginning, if we encounter a blank entry, we look forward for the next non-blank entry. If we find such an entry, we swap the blank and non-blank entry, then break to loop again looking for the next blank entry.
Note, this isn't the most efficient of solutions, but it will get you started.
Note also I'd replace the 4 and 8 with definitions like:
Finally:
That will not do what you want it to do; try:
To append the digits, not the byte codes, to the end of the number. Or perhaps, if you have C++11:
",1,47151415
47151695,"
I see couple of problems.

The expression ""word"" + static_cast<char>(i); doesn't do what you are hoping to do.
It is equivalent to:
When i is 2, p will be ""rd"". You need to use std::string(""word"") + std::to_string(i).
The logic for moving objects with the non-empty names to objects with empty names did not make sense to me. It obviously does not work for you. The following updated version works for me:


",1,47151415
47151699,"
There was two problems as :

wordArr[randomNum].name = ""word"" + static_cast<char>(i); this is not what your are looking for, if you want that your names generate correctly you need something like this :

Your sorting loop does not do what you want, it's just check for the ""gaps"" as you said, you need something like this :


",1,47151415
47120839,"
The operator< for std::pair compares the first member first, and if those are equal, it then compares the second member. Since you want to ignore the second member, you can't use that default ordering. You can specify a comparison to use instead by passing a lambda as an extra argument to sort:
But that won't get you what you want either:

The value which was inserted first should come first.

std::sort doesn't guarantee anything like that.  You know only that the final result obeys the ordering, but the order of equivalent elements is unspecified.  But the similar function std::stable_sort does act the way you want.  So:
",3,47120724
47120789,"
If I got correctly what you want, you need a so-called ""stable sort"", and the standard library does provide an aptly-named std::stable_sort that you should use instead of plain std::sort. 
",1,47120724
47120737,"
No, it is likely not to work. std::sort contract requires a strict weak ordering comparator; violating it results in undefined behavior. BTW, I've seen several times libstdc++ std::sort brutally crash (reading elements outside the container, IIRC) for this kind of comparator ""relaxing"". 
",1,47120649
28513139,"

...giving priority first to the X dimention, then Y, then Z

Use std::sort with std::tie, something like following 
DEMO
",2,47098679
28513135,"
You could use an std::tuple<double, double, double> to represent a point. The comparison for std::tuple works lexicographically, the way you want it to. Alternatively, you could provide a custom sort function to your vector of points. Something like this:
Also, as this question shows, you can achieve some sort of a named-tuple-with-lexicographic-sorting by using std::tuples lexicographic sort and std::tie.
",3,47098679
28513145,"
You can use the std::sort() to easily sort according to your specific conditions by making your own comparator function.
Assuming you have stored a single 3D point in a struct point, and the points in a std::vector<points> (A std::tuple might be more useful.), try out this code.
Example:
",2,47098679
47096141,"
As stated in std::stoi documentation:

Discards any whitespace characters (as identified by calling isspace()) until the first non-whitespace character is found, then takes as many characters as possible to form a valid base-n (where n=base) integer number representation and converts them to an integer value.

(emphasis is mine) it does what you need already, so your lambda can be just:
note, converting string to integer is not very simple operation so you may want to reorganize your data so you do not have to do it for that strings so many times.
",2,47095835
47096177,"
You can try to express your intent: treat the entries as pairs of ints, and use existing sorting logic for that:
",0,47095835
47096013,"
Here you have 2 local string vars, empty (I suppose, no idea what's FString). You provide a lambda as a sorting function. Usually such function should have signature bool(const Key& left, const Key& right), and your lambda almost satisfied this requirement (pay attention to const). left and right here will be two keys to compare, and you need to define this comparison to define your sorting order. So correct version would be:
This still doesn't explain your error, mainly because I have no idea what the error is. 
By the way, GetIntFromString should be a free function, or at least a static member function, because its implementation depends only on input parameters.
P.S. listen to @Slava in the question comments, which can lead to
",0,47095835
47086620,"
Create an array of N items. For each item in the table, go through the array and check if current_array_item <= table_item <= next_array_item. If yes, shift all items in the array that are <= current_array_item by one (erasing the smallest one from the array) and insert table_item in place of current_array_item.
",1,47086379
47017101,"
The problem is in this declaration of your vector:
It does not simply reserve n spots, it creates a vector with n empty vectors inside. Hence the first call to sortcol for any of these empty entries produces undefined behavior, because
references non-existent element at position zero.
Replace the declaration with 
to fix this problem. If you would like to reserve space for n entries, add a call to vector::reserve after the declaration:
You should also pass vectors to your comparator by const reference, rather than by const value.
",3,47016970
47017337,"
The problem is that you are trying to reserve the wrong way in this particular case. Use
instead.
",3,47016970
47017139,"
Your comparator has 2 issues:

it does not check if vectors passed to it do have at least one element
you should pass vectors by const reference (this is not error, but can lead to bad performance issue)

So in your code:
you create v with n empty vectors and then you push back additional data after it. Then you try to sort it and you get UB with your comparator when it hits empty vectors you created.
",1,47016970
47007983,"
The compiler has no way of determining whether your operator< is a strict weak ordering. Instead, what is meant by std::set requiring this is that it will only work correctly if you give it a strict weak ordering. It makes no guarantees about what will happen if you give it something else.
In general, what C++ means when it requires something is that it is your responsibility to make sure that something happens. If you do, then the compiler and library will guarantee that you get the right results.
",4,47007924
47008328,"
Standard guarantees expected behavior if comparator requirements are met. Otherwise, what happens depends on implementation and data sets. Your comparison function may work properly for some data sets (where for all points greater x implies greater y). Set cannot contain equal elements (as a math concept), and for std::set equivalence means equality, so it'll just prevent you from inserting value a if there is already value b, such that:
even though a may be not equal to b
",1,47007924
47008687,"
When the comparison operator implements strictly weak ordering of the contained elements, the objects in the std::set are ordered in a predictable patten. If not, there is no telling which object appears first in the std::set when you iterate over the objects.
Take the following sample program in which ordering of Pixel1 is not done right and ordering of Pixel2 is done right.
Output
Pixel1 ... 
(4, 1) (4, 2) (2, 3) 
(4, 1) (2, 3) (4, 2) 
Pixel2 ... 
(2, 3) (4, 1) (4, 2) 
(2, 3) (4, 1) (4, 2) 

The order of objects in the std::set<Pixel1> depends on the order of insertion while the order of objects in the std::set<Pixel2> is independent of the order of insertion.
Only you can tell whether that is acceptable in your application, 
",1,47007924
47007907,"
When implementing a recursive function, you need to ask yourself the following questions explicitly:

What is the base case of your recursive function?
What is the recursive case of your recursive function?

Answers:

If the current array position compares against NaN, then we are sorted.
If our position is not sorted, we know the list isn't sorted. If our position is sorted, then the array is sorted if the recursive condition holds on the next pair.

Therefore:
Note that I only directly return true; on the base cases. Otherwise, we either fail the function, or we recurse.
",0,47007808
46987281,"
Assumint that you have a class the Record described in your question with a defined operator== and you have a vector of these that you read into memory from your csv file, you can do something like this to remove duplicates using the algorithms library:
Note std::unique will use your defined operator== in Record.
",0,46986992
46985610,"
Change your swap function to take in references, instead of values:
When a function takes in a value, the object is copied before passed over and is not affected in the callee.
",2,46985568
46985626,"
In your program, selection::swap() taking arguments by value. Since it is supposed to modify the value of the receiving parameter by swapping them, it should take the references:
",0,46985568
46980609,"
std::array<Row, 50> records{}; is an array containing exactly 50 instances of Row. If your array contains 50 elements and you only specify 3 of them, there are 47 default constructed elements left in your array. It seems that you do not assign a value to all of the elements in your array when you read from your file and the remaining default constructed elements are being sorted at the front of the array. 
Consider using std::vector instead if, at compile time, you aren't certain how many elements you will need.
",6,46980397
46977043,"
Global variables are easy to forget. Here in case 1, n is not initialized to the number of records and keeps its initialization value of 0. So you sort and display an empty array.
Just changing the read part to:
is enough to get rid of the problem.
But my advice is to remove the global variable and pass it explicitely to the sort function.
",0,46975991
48013327,"
sortname returns a copy of its array argument.
So, sorted points to the same array as array. Therefore once array is deleted, the sorted points to that deleted array. It no longer points to a valid object.
Deleting a pointer that doesn't point to an object has undefined behaviour.

A rule of thumb: You need exactly one delete for each new. You've called new once. Calling delete twice is more than once.
Another rule of thumb: Don't ever allocate memory directly. You could have used std::vector instead.
",3,48013266
48013164,"
Here is the basic idea for an algorithm in O(n log n), I am sure it can be done more efficiently:
1) sort all intervals accoring to their endpoint, each endpoint is a potential splitpoint where intervals to the right and intervals to the left do not overlap
2) now scan through the sorted intervals and for each spiltpoint remember the minimum cost interval to the left.
3) sort all elements according to their startpoint
4) for each splitpoint memorize additionally the minimum cost interval to the right(having its startpoint after the splitpoint). This is also possible with a single scan from back to front of the sorted elements
5) for each splitpoint add the two corresponding cost and look for the minimum.
Sorry this is a bit informal since i am on mobile.
",0,48012794
47990424,"
There's nothing wrong with your solution. It sorts the vector fine. But it seems there's something wrong here:
This code sets the number of each camera, the index of it in the original vector NOT the sorted vector. I think it should be replaced with:
",1,47989208
47987272,"
The third argument is the comparison function.
First it checks the argument length, and returns true if the first is shorter than the second, false if the second is shorter than the first. 
Then if the two strings are of equal length it compares the two strings character by character and returns true if a char from the first compares less than the char from the second, false if the char from the second compares less than the char from the first.
 Finally it returns false if the two strings are equal because the comparison needs to implement a strictly less-than ordering.
",1,47987125
47987255,"
The check function is used as a comparator in std::sort (in other words std::sort calls check when it needs to compare elements).

The value returned indicates whether the element passed as first
  argument is considered to go before the second in the specific strict
  weak ordering it defines

This function compares the length of the numbers (considering there are no leading zeroes in the numbers), then if these numbers have the same length it compares numbers themselves. This function can be shortened: 
",3,47987125
47973502,"
I compiled your sort_cards() function (after providing the missing }),  with GCC 7.2.0 on a Mac and the command line:
With these options (the critical one is -Wextra), it warns immediately:
That indicates a serious problem.  Especially as on the first iteration of the outer loop, i is 0, so i - 1 is a very big number.  Frankly, your claim that the function will sort an entire array successfully is bogus.  It won't.  And I don't run code that won't compile with the command line shown.
If you fix that function, your code is then OK.  I used:
The array is initialized with the sample data you gave; the residue is all zeros, but that doesn't matter for this exercise.
Sample output:
Inspection shows that the each sub-array is correctly sorted.
",2,47972674
47971850,"
In this for loop
there is an attempt tp access memory beyond the array when j is equal to 0 and k is equal to s - 1. That is in this case k + 1 is equal to s though the valid range of indices is [0, s-1].
At least change the loops the following way
",1,47971792
47971943,"
Your use of the index is off. You are picking up garbage values from outside your valid range (they just happen to be zeros). An easier style might help detect the problem.
",0,47971792
47974197,"
Code
Explanation
In bubble sort, you swap the elements recursively.  Here is a 15-line code.  Hope it helps.
",0,47971792
47961819,"
If you are using C++11 (or later) an easy way is to use std::tie from <tuple>.
Example use in your code (just guessing here):
",0,47961706
47961943,"
In your function you just compare the year, if there are data with same years, your function can't sort them. 
You can convert D-M-Y time to time_t, like:
time_t refers to the seconds of time in parameters to 1970. 
",0,47961706
47919843,"
You are doing noofcomparison++ inside if statement. Your code doesn't increment noofcomparison when comparison results false. You need to move noofcomparison++ outside of if statements.
",0,47919750
47911240,"
No


There are two problems here.  Assuming you are talking about double comparisons (rather than integer), the comparison may or may not occur. 
 Secondly your indentation is deeply misleading.  (You always increment.) 
 You need
There are probably other errors, but it is impossible to tell because I can't read your language, so the printed text, comments, and names are meaningless.
Given you are writing in C++, I would write a class with operator <() and operator =, and a copy constructor, and instrument those.  That way you cannot possibly get it wrong.
",1,47911066
47909426,"
A quick solution would be to replace anywhere you use the subscript([]) operator do this instead: A = new double[(int)N];
I hope this helps.
",0,47909270
47896095,"
Read your error message carefully, especially the first line.
Then compare the versions of your toolchain on the two computers and check whether that might cause the difference in the default C dialact being assumed or whether you have different default flags for building in your environment variables or build environment or similar.
",1,47896069
47891359,"
A straightforward approach of sorting the array using the bubble sort can look the following way
The program output is
All you need is to extract the code of the bubble sort from main and rewrite it as a separate function for any 2D array and any row used as the criteria of sorting.
",0,47890711
47925330,"
The problem would be easy to solve if instead of parallel vectors we had a structure containing parallel values. 
It is easy enough to get back to such a structure: just create some intermediate vector containing sort keys and indexes and sort it. 
After sorting the indexes are giving us a direct way to reorder all the individual vectors in the right order.
I would  do something like below (I put it in a Boost Unit Test, but what is done should be obvious) .
",0,47890711
47874174,"
This is a way to get the columns of each line.
Hope this helps.
",0,47873667
47861612,"
At first glance, you have at the bottom of your loop:
To me that should be
",1,47861580
47851186,"
This is similar to the answer given by @JerryCoffin, but maybe a little bit simpler for you to digest.
A simple solution is to place this code in a class and have a member variable, maybe called int swapcount, that will increment for each swap done.  This alleviates having to maintain a local swap counter variable.
Note that we have a function startSort that starts the sort within the class.  In the merge function, the swapCount is incremented as needed.  At the end, we just output the value of ms.swapCount.
",1,47850495
47850862,"
I would do the job rather differently.
Instead of trying to instrument the sort itself to track the number or comparisons and swaps, I'd create a type that keeps track of the number of times it's compared and/or swapped. I was too lazy to write a whole merge sort to demonstrate it, but here's one doing a bubble sort:
Note that with this, you should be able to (for example) get results for std::sort, std::partial_sort, and so on, not just your own sort functions.
",2,47850495
47851022,"
If I understand correctly a swap happens when the original array is altered in merging steps. So in each call of merge I look at the value in original index and compared it with the newly formed value corresponding to that index. If they are different I incremented swap.
",1,47850495
47828543,"
Use a std::vector to hold your ints. Then use std::sort on it. If you have to write your own sort, try to implement a quicksort or a mergsort. 
This is a fast sort via a vector and std::sort.

If you need to read up about faster sort algorithms:
https://en.wikipedia.org/wiki/Quicksort
https://en.wikipedia.org/wiki/Merge_sort
The general idea is to do some kind of presorting for parts of the array and then sort everything. This make the runtime log(n)n instead of nn. This is a major speed up, even more the bigger the numbers rise. Example:

log(1024)*1024 = 10*1024 = 10.240 Operations.
1024*1024 ~ 1.000.000 Operations <- 100 times slower

log(1.000.000)*1.000.000 = 20*1.000.000 = 20.000.000 Operations.
1.000.000*1.000.000 = 1.000.000.000.000 Operations <- 50.000 times slower
",1,47828129
47829628,"
I think you are doing it wrong.
first of all you should not call the sorting function inside loop, it does the same work every time, and increasing time. It will be enough to call it once after the end of the while loop. This will drastically speed up your program.
Also inside while loop you have first incremented the value of j then you have assigned 
a[j-1] = x;
you should first assign 
a[j] = x;
and then j++;
because
a[j-1] = x; // here j-1 will take some fraction of milliseconds to calc [j-1].
Hope your program will speed up. 
",1,47828129
47795374,"
Unique pointers can not be copied (otherwise they would lose their uniqueness). For that reason when they are sorted, they will need to be moved (or swapped). Those operations need to change the internals of the unique pointers. Of course you can't change the internals of an object through a const reference.
",1,47795274
47795345,"
Because std::sort sorts the elements in the range by moving them. That means the elements will be modified via the iterator; it won't work with iterator to const.
",1,47795274
47795693,"
Why cbegin() and cend() does not work? std::sort() as stated in documentation has following type requirements:

-RandomIt must meet the requirements of ValueSwappable and RandomAccessIterator.
-The type of dereferenced RandomIt must meet the requirements of MoveAssignable and MoveConstructible.
-Compare must meet the requirements of Compare.

emphasis is mine. So std::vector::const_iterator does not satisfy those requirements. So even if you have std::vector<int> and try to use them that would not work either. If you ask why it works on begin()/end() with std::unique_ptr then you can see that in documentation as well:

std::swap(std::unique_ptr) (C++11) specializes the std::swap algorithm 
  (function template)

so std::unique_ptr as value satisfies ValueSwappable concept.
",1,47795274
47796293,"
here's a solution. Compatible down to c++11:
",0,47795274
47782778,"
You're initializing totalPrimes to 0 every time the function runs. You would need to have totalPrimes as a global variable, or better yet (because global variables can become problematic), set it equal to the first available member of PrimeNumbers before you do anything else in that function.
",0,47782654
47782782,"
Keep track of a position along with your PrimeNumbers array.
",0,47782654
47782756,"
It looks like you're having some trouble with variable scoping. The reason for your problem (as I noted in the comment) is that totalPrimes is local, so you're creating a new integer variable and setting it to 0 every time the function is called.
However, you've made PrimeNumbers global and are having the isPrime function modify it, which doesn't look like good practice.
All of this can be fixed with a little restructuring to make the code nicer:
",0,47782654
47782945,"
Your program can be re-structured little bit to make it easier to follow and debug.

Don't put things in isPrime other than the logic to decide whether a number is prime. Make sure it returns a bool. This will make the function a bit simpler and easier to debug.
Use the return value of isPrime in the calling function to perform other bookkeeping tasks.
The logic you have used to check whether a number is prime is incorrect. That needs to be fixed.

Here's an updated version of your posted code.
and its output:
1 is a Prime number
2 is a Prime number
3 is a Prime number
5 is a Prime number
7 is a Prime number
9 is a Prime number

",0,47782654
47784258,"
Everybody is talking about how your totalPrimes variable is reset each time the function is called, and this is obviously true. You could return the value from the function and increment it from main, you could use global variables having the variable being defined outside of the function so that it's not reset each time inside the function or you could use 
A static variable!
Take a look at this simple case. I have a function called up_two which increases the value of by two each time the function is called. The static variable int value has a memory of each time the function up_two() is called which increments value by two each time. If I were to use a just an integer it would always reset the value and have it be zero, which is what I initially defined it to be. 
The advantage of using a static variable is that I can count how many times a function has been called, and I can keep my counter specific to a particular function. 
This program doesn't solve the particular problem that you want to solve, but if you figure out how the static variable is working, it should make your workflow easier.
The magic line here is this: 
With it like this my program prints the following: 
Without the static declaration, you just get 10 lines of zeroes 
which is troublesome.
Hope that helps you optimize your program the way you want it to be. 
",0,47782654
47742058,"
std::sort cannot do that. It sorts a range of elements in accord with a strict, weak ordering. The ordering you define is not strict-weak. And there's no way to define an ordering that is strict-weak, such that certain values remain in their current positions. And therefore, if you attempt to use sort with such an ordering, you get undefined behavior.
So you're going to have to write your own sorting function. Or you can remove the -1's (recording their positions), sort the list, then reinsert them.
",3,47741862
47742321,"
It can't be done using std::sort alone. Alternative is to extract the locations of -1s, erase all -1s, sort the vector and reinsert where appropriate:
",0,47741862
47739002,"
I don't know if this is the exact code you tested with, but I see another error, the compiler will complain about. In:
You treat Nodes a and b as pointers, which they are not. If I changes this to:
I get no errors at all while compiling.
",0,47735798
47735716,"
The deleted function is the assignment operator. Property cannot be assigned because the const member groups cannot be assigned. The most logical solution to this is to declare groups to be static so that all instances of Property share it and it does not need to be assigned. Eg:
and storage for groups needs to be assigned and initialized outside of the class definition:
TL;DR
The default behaviour of the assignment operator is to copy all of the members of the source into he destination without applying any smarts to the copy. This means a really simple example
Will generate the equivalent of 
which is not possible because a is const and cannot be changed even if there is no change.
You could add your own assignment operator
but the only reason you would want this is if there is no method by which you can change the value of a at initialization. If you cannot change a, then all instances of test have the same value of a, and a might as well be a static member.
Example of failure where two tests have a different value for a: 
",5,47735318
47744551,"
I changed (int j = 0; j < 1; j++) to int j = 0; j < i; j++, which fixed my problem. 
",0,47733819
47735535,"

[res.on.data.races]/8 Unless otherwise specified, C++ standard library functions shall perform all operations solely within the current thread if those operations have effects that are visible (4.7) to users.
/9 [ Note: This allows implementations to parallelize operations if there are no visible side effects. —end note ]

std::sort could, in principle, use parallel execution when sorting elements of fundamental type (it wouldn't be observable whether it does), but not user-defined type (unless explicitly given permission via execution policy parameter, of course). The type's operator< may not be thread-safe.
",1,47707277
47701969,"
It sounds like you want to compare the max of the two pairs.
",1,47701888
47702099,"
The custom compare function should compare the max value of the pair(s). So something like:
Not tested, nor tried to compile, but I hope you can work things out from here.
",1,47701888
47701984,"
Here you are
Here is a demonstrative program
Its output is
",1,47701888
47704511,"
If you're just looking to count visitors by URL, you don't need to write a program to do this.
That gives me counts by URL, for GET requests. If I wanted to do something like sum up the number of bytes by URL I would use awk. 
Admittedly, the laptop that I'm using to do this has 12 GB of RAM and an SSD, so that will affect the numbers. But even if it takes a minute to run such a command pipeline that's still a lot less time than it would take to write and debug a C++ program.
",-1,47693591
47699928,"
It appears you want a binary search tree (BST) stored in array form, using the same internal represenation which is often used to store a heap.
The expected output is an array such that the one based indexes form a tree, where for any one-based index x, the left node of x is at index 2*x, and the right node of x is at index 2*x+1. Additionally, there are no gaps, meaning every member of the array is used, up to N. (It is a complete binary tree) Since c++ uses zero-based indexing, you need to be careful with this one-based index.
That way of representing a tree is very good for storing a heap data structure, but very bad for a binary search tree where you want to insert things, thus breaking the completeness, and forcing you into a very expensive rebalance.
You asked for a mapping from the sorted array index to this array format. We can build it using a recursive function. This recursive function will take exactly the same amount of work as it would have taken to build the binary tree, and in fact, it is nearly identical to how you would write that function, so this is not an optimal approach. We are doing as much work as the entire problem requires, just to come up with an intermediary step.
The special note here is that we do not want the median. We want to ensure that the left subtree forms a perfect binary tree, so that it fits in the array with no gaps. Therefore, it must have a power of 2, minus 1 nodes. The right subtree can be merely complete.
This gives me {7, 3, 9, 1, 5, 8, 10, 0, 2, 4, 6} as the index mapping. It differs from yours because you left spaces in the lower left of the tree, and I am ensuring that the array is completely filled, so I had to shift the bottom row over, then the BST property required reordering everything.
As a side note, in order to use this mapping, you first must sort the data, which is also about the same complexity as the whole problem.
Additionally, the sorted vector already gives you a superior way to do a binary search, using std::binary_search http://en.cppreference.com/w/cpp/algorithm/binary_search.
",1,47678895
47677576,"
Rather than doing your way to get the index a simple way to do it.
This way is safe and ensures that it gets the right index. After testing it the output is C \n B \n A which is what I think you want.
Hope this helps.
",0,47677263
47669916,"
The reason is probably because rectangles in the same row has different height. Let's say a rectangle is followed by a taller rectangle in the same row, the taller rectangle is going to be sorted earlier than the left one. 
Using your first compare function, rect1.tl().y <= rect2.tl().y is false and rect1.tl().y < rect2.br().y) is true, thus return (rect1.tl().y < rect2.tl().y) which will put the right rectangle smaller than the left one
One suggestion to overcome this is if the rectangles top left corner difference in y is within a threshold, consider them to be on the same row and compare by x instead. 
fabs is the floating point absolute function under <cmath>. One way to calculate threshold is by using average height of the rectangle.
K is a constant which you can experiment to see which perform best, it should be between 0 and 1.
",1,47669644
47677147,"
When std::sort acts funny, it's almost always because of an invalid comparison function. The comparison function that you pass to std::sort must provide a strict weak ordering. The usual failure is that the comparison function is defined such that for two objects a and b, compare(a,b) returns true and compare(b,a) returns true, i.e., a comes before b and b comes before a. When that happens, the sort algorithm may well run off the end of your data and do all sorts of wild and crazy things.
The actual answer to this question lies somewhere inside this:
",2,47668982
47658509,"
Store the string values and count into std::map< std::string, int > and for each word, check if it is already in the map. If it is there, increment the count. In opposite case insert it with count = 1
",2,47658352
47657691,"
First IF: Checks if the first letter is lowercase and the second letter is uppercase.
Second IF: Checks if the first letter is uppercase and the second letter is lowercase.
Third IF: then both letters are uppercase or lowercase.
",1,47657232
47632788,"
You need some data abstraction.
First define a suitable data type:
then you define how to read one of them:
then you read them:
then you can easily sort them by id:
or by decreasing result:
or by whatever.
",2,47630702
47624503,"
I have used another loop and a boolean var swapped to check in this iteration if anything changed.
You may check some optimizations in wiki.
",0,47624394
47624609,"
Here is the code changes you need:
",0,47624394
47619887,"
The compile error is trivial. void selectionSort(int [], int); accepts array of integers, it sorts that array. But you want to sort array of strings. You have declared:
You have to change the sort function to accept array of strings. The modification is rather easy since std::string supports =, <, >, == operators.
",0,47619708
47609867,"
Your comparison function isn't implementing strict weak ordering
Consider this scenario:

t1: year=2017, month=2
t2: year=2016, month=5

compareDateAndTime(t1, t2) would return true.
You should proceed to compare month if and only if year is the same.
... and so forth ...
",2,47609774
47610070,"
A nice way to leverage the Standard Library:
You can add the missing members inside the std::tie's (it's a variadic template). This uses std::tuple's operator<, which is defined to do what you expect.
",1,47609774
47575597,"
Indices start at 0 in c++, so you have to do the following:
",0,47575540
47682277,"
You are getting wrong answer because here your arrays are filled with garbade values at random spots ,
 for example in your function generate_factors only those spots are filled for which the condition is being satisfied. So because of that when you search common values in functionfindHCF those garbage value comes and cause unexpected output to occur.
So you should initialize the arrays with 1 
Although a simple way to calculate the HCF of two numbers is the use of Euclid's Algorithm.
Here's an implementation of Euclid's algorithm in C++:
",0,47565456
47550558,"
For example in the called function selectionSort substitute this statement
for the following statement
Also the function showVec should declare the parameter as having a constant referenced type
}
",0,47550061
47545660,"
After you compute the frequency in count array.
For myCompare,
This should sort the array in descending order. 
",1,47545253
47545815,"
The problem you are facing is because you have frequencies in the array but the frequencies are not mapped to corresponding character. When the frequencies are sorted,the array is rearranged but your printing of the frequencies is not character dependent,you are printing characters from a-z and assigning frequencies as they are in sorted array.
What you can do is map the frequencies with corresponding character. One solution can be using an unordered map,char being key. An unordered map because it won't internally sort the map on character value,so u can maintain frequency ordering as well.
You can also use vector with pair as @lamandy suggested.
sort by second value of pair
Once after you have calculated frequencies,you can use this,this will solve your purpose and you wont need your sort function.
P.S : One more thing,you must initialize your (array)count to 0,like int count[26] = {0},because initially it contains garbage if uninitialized and adding up 1 ( count[(fileContent[f]-'a')%26]++;) to a garbage will not produce result(frequency) u expect
",0,47545253
47546387,"
The answer is probably a three-liner for a standard library guru, which I am not quite yet. I hate the standard library. It makes programming so easy that anyone can do it.
Here are two versions that I hacked out. This is fun.
Another one that doesn't use std::map.
",0,47545253
47545496,"
You have to use iterator of the beginning of that array and end of that array which is :
",0,47542537
47537314,"
Here is my favorite. Sort an index and not the original array/vector itself.
After this, indexofarray[] elements would be 0, 2, 3, 1, while intarray[] is unchanged.
",5,47537049
47537235,"
As suggested in the comments pass the function argument by value std::vector<int> original:
That will sort a copy of your original vector leaving the original intact.
As pointed out below this might restrict some optimizations such as  RVO but will call vector's move constructor in the return statement instead.
",2,47537049
47539391,"
For the case where you are interested in proxy sorting (sorting an index list), you may want to implement a more flexible algorithm that allows you to deal with containers which do not support random access (such as std::list). For example:
Sample run:
As you would expect, relying on proxy sorting could have important performance implications. For example: every time you want to traverse in order, you will possibly incur cache misses. In addition, the traversal will have the same complexity as the underlying container for random access: In the case of std::vector, std::next(v.begin(), n) is O(1), but in the case of std::list, std::next(l.begin(), n) is O(n).
",2,47537049
47537466,"
For int's it doesn't make much difference if you're sorting an index or making a copy & sorting the copy; the data still needs to be initialized, and in the case of the indexes, this will involve a loop assigning values rather than faster memcpy routines; so may end up slower; in addition you're going to be jumping around memory lots more; so now the cache can't do its job nicely.
For larger objects I'd not sort the index, but use a vector of pointers.  The copy of the pointers is cheap compared to copying the objects themselves; the containers are still obvious because they're containing pointers of your object; and the sort isn't attempting to reference another vector.
",1,47537049
47534100,"
Sorting a vector of queues is as easy as typing std::sort(a_vector_of_queues.begin(), a_vector_of_queues.end()) where a_vector_of_queues is std::vector<std::queue<T>> and T is any type which has < operator defined for it like int or std::string.
",1,47533335
47529370,"
Because a swap requires at least two elements.
So if you have 6 elements, you only need to consider 5 consecutive pairs.
",10,47529349
47523554,"
As written, every recursive call spawns two new threads, so the number of threads increases exponentially. omp_set_nested
You need to arrange to call the parallel version only at the top levels of recursion. I suspect you want to spawn only Nthreads-1 new threads. If you would post a MCVE, we could fix it.
",1,47522680
47521776,"


You have an error in heapSort which lead to the wrong sort result. It also causes increased number of comparisons and swaps in a failed attempt to sort successfully. Change n to i in the second call to heapify
Result:


Test on ideone
",1,47519432
47518660,"
Ok, i think i got it.
sorry for the dumb and repeated question, i resolved adding a lambda function to my sort, and changing the list to a vector (i realized that i had no reason to use a list)
in this way: 
",0,47518098
1380496,"
A simple example using std::sort

Edit: As Kirill V. Lyadvinsky pointed out, instead of supplying a sort predicate, you can implement the operator< for MyStruct:
Using this method means you can simply sort the vector as follows:
Edit2: As Kappa suggests you can also sort the vector in the descending order by overloading a > operator and changing call of sort a bit: 
And you should call sort as:
",320,48697900
26295515,"
In the interest of coverage.  I put forward an implementation using lambda expressions.
C++11
C++14
",131,48697900
1380481,"
You could use functor as third argument of std::sort, or you could define operator< in your class.
",52,48697900
1380488,"
You are on the right track.  std::sort will use operator< as comparison function by default.  So in order to sort your objects, you will either have to overload bool operator<( const T&, const T& ) or provide a functor that does the comparison, much like this:
The advantage of the usage of a functor is that you can use a function with access to the class' private members.
",13,48697900
37334886,"
Sorting such a vector or any other applicable (mutable input iterator) range of custom objects of type X can be achieved using various methods, especially including the use of standard library algorithms like 

sort, 
stable_sort, 
partial_sort or
partial_sort_copy.

Since most of the techniques, to obtain relative ordering of X elements, have already been posted, I'll start by some notes on ""why"" and ""when"" to use the various approaches.
The ""best"" approach will depend on different factors:

Is sorting ranges of X objects a common or a rare task (will such ranges be sorted a mutiple different places in the program or by library users)?
Is the required sorting ""natural"" (expected) or are there multiple ways the type could be compared to itself?
Is performance an issue or should sorting ranges of X objects be foolproof?

If sorting ranges of X is a common task and the achieved sorting is to be expected (i.e. X just wraps a single fundamental value) then on would probably go for overloading operator< since it enables sorting without any fuzz (like correctly passing proper comparators) and repeatedly yields expected results.
If sorting is a common task or likely to be required in different contexts, but there are multiple criteria which can be used to sort X objects, I'd go for Functors (overloaded operator() functions of custom classes) or function pointers (i.e. one functor/function for lexical ordering and another one for natural ordering).
If sorting ranges of type X is uncommon or unlikely in other contexts I tend to use lambdas instead of cluttering any namespace with more functions or types.
This is especially true if the sorting is not ""clear"" or ""natural"" in some way. You can easily get the logic behind the ordering when looking at a lambda that is applied in-place whereas operator< is opague at first sight and you'd have to look the definition up to know what ordering logic will be applied.
Note however, that a single operator< definition is a single point of failure whereas multiple lambas are multiple points of failure and require a more caution.
If the definition of operator< isn't available where the sorting is done / the sort template is compiled, the compiler might be forced to make a function call when comparing objects, instead of inlining the ordering logic which might be a severe drawback (at least when link time optimization/code generation is not applied).
Ways to achieve comparability of class X in order to use standard library sorting algorithms
Let std::vector<X> vec_X; and std::vector<Y> vec_Y;
1. Overload T::operator<(T) or operator<(T, T) and use standard library templates that do not expect a comparison function.
Either overload member operator<:
or free operator<:
2. Use a function pointer with a custom comparison function as sorting function parameter.
3. Create a bool operator()(T, T) overload for a custom type which can be passed as comparison functor.
Those function object definitions can be written a little more generic using C++11 and templates:
which can be used to sort any type with member i supporting <.
4. Pass an anonymus closure (lambda) as comparison parameter to the sorting functions.
Where C++14 enables a even more generic lambda expression:
which could be wrapped in a macro
making ordinary comparator creation quite smooth:
",11,48697900
1380493,"
Yes, std::sort() with third parameter (function or object) would be easier. An example: 
http://www.cplusplus.com/reference/algorithm/sort/
",4,48697900
1380487,"
In your class, you may overload the ""<"" operator.
",3,48697900
36736713,"
Below is the code using lambdas
#include ""stdafx.h""
#include <vector>
#include <algorithm>

using namespace std;

struct MyStruct
{
    int key;
    std::string stringValue;

    MyStruct(int k, const std::string& s) : key(k), stringValue(s) {}
};

int main()
{
    std::vector < MyStruct > vec;

    vec.push_back(MyStruct(4, ""test""));
    vec.push_back(MyStruct(3, ""a""));
    vec.push_back(MyStruct(2, ""is""));
    vec.push_back(MyStruct(1, ""this""));

    std::sort(vec.begin(), vec.end(), 
        [] (const MyStruct& struct1, const MyStruct& struct2)
        {
            return (struct1.key < struct2.key);
        }
    );
    return 0;
}

",2,48697900
50040873,"
I was curious if there is any measurable impact on performance between the various ways one can call std::sort, so I've created this simple test:
What it does is it creates a random vector, and then measures how much time is required to copy it and sort the copy of it (and compute some checksum to avoid too vigorous dead code elimination).
I was compiling with g++ (GCC) 7.2.1 20170829 (Red Hat 7.2.1-1)
Here are results:
Looks like all the options except for passing function pointer are very similar, and passing a function pointer causes +30% penalty. 
It also looks like the operator< version is ~1% slower (I repeated the test multiple times and the effect persists), which is a bit strange as it suggests that the generated code is different (I lack skill to analyze --save-temps output).
",2,48697900
20763862,"
",1,48697900
45567530,"
You can use user defined comparator class.
",1,48697900
38730028,"
To sort a vector you can use the sort() algorithm in .
The third parameter used can be greater or less or any function or object can also be used. However the default operator is < if you leave third parameter empty.
",0,48697900
45992778,"
if compare is false, it will do ""swap"".
",0,48697900
48677421,"
Generally, I would go for something of this sort :
Creating a vector of the Video class.
And for the sorting, you could use the std::sort present in <algorithm>.
All that you would need to do would be :
OR
You could also implement the < operator or the > operator and implement the less than/greater than operator for your case.
",2,48677302
48677407,"
use std::sort with custom comparator.
and
",1,48677302
48647735,"
Your counting sort is the way to go: build a simple count table for the 26 letters in order.  Iterate through your two strings, counting letters, ignoring non-letters.  This is one pass of O(n).  Now, simply go through your table, printing each letter the number of times indicated.  This is also O(n), since the sum of the counts cannot exceed n.  You're not printing n letters n times each: you're printing a total of n letters.
",2,48647589
48647790,"

Concatenate your strings (not really needed, you can also count chars in the individual strings)
Create an array with length equal to total nr of charcodes
Read through your concatenated string and count occurences in the array made at step 2
By reading through the char freq array, build up an output array with the right nr of repetitions of each char.

Since each step is O(n) the whole thing is O(n)
[@patatahooligan: had made this edit before I saw your remark, accidentally duplicated the answer]
",2,48647589
48647724,"
If I've understood the requirement correctly, you're simply sorting the characters in the string?
I.e.  ADFSACVB becomes AABCDFSV?
If so then the trick is to not really ""sort"". You have a fixed (and small) number of values. So you can simply keep a count of each value and generate your result from that.
E.g. Given ABACBA
In the first pass, increment a counters in an array indexed by characters. This produces:

[A] == 3
[B] == 2
[C] == 1

In second pass output the number of each character indicated by the counters. AAABBC
In summary, you're told to sort, but thinking outside the box, you really want a counting algorithm.
",1,48647589
48626505,"
You declare an array of size 9, but you want 10 elements. To fix, change the declaration of the array to int list[10];
A few things to note on the side.

You have a variable int c in the beginning, but you create a new variable inside each for loop called c as well. (Get rid of the first variable declaration)
Loop conditions are generally of the form < size, not <= last_index.
You mix pre and post increment in your loops. Pick one (hopefully pre increment)
Do not call your variable list, (A very common name for a class).

",3,48626434
48626701,"
You are invoking undefined behavior by reading out of bounds in your for and while statements:
also in
But at this point it doesn't really matter as UB has already been invoked earlier. Arrays in C++ are zero indexed so when c becomes 9 the program invokes UB. Change your array declaration to:
Or change your upper boundary to be less than 9, not less or equal than 9.
",3,48626434
48626663,"
Arnav Borborah's answer shows how to fix the code into a C program that uses std::cout. I upvoted his answer, because it shows where the error is. Here is the C++ way:
",2,48626434
48613677,"
What happens when this line runs?

tempStack is moved to a temporary object.
tempStack is destroyed.
Temporary object is returned.

In step 1, the top and stackSize of tempStack are copied to the temporary object (that's what your move constructor does).
In step 2, all the items in the stack are deallocated.
In step 3, this returned object's top is now pointing to deallocated memory.
Your move constructor should set the moved-from object's top to NULL (and presumably also stackSize to 0) so that that object won't deallocate anything when it's destroyed.
",3,48613527
48619020,"
It is important to inform the moved object that it should not destroy its resources. For instance you may use a guard preventing cleaning stack if the object was moved.
Like:
",0,48613527
48612886,"
Here's at least one problem. The size variable is local to the initializeArray. The value entered by the user can never be seen outside of this function. Specifically calling this function will not change the value of SIZE in main.
If you want the size entered to be visible in the rest of the code you need to pass size by reference.
That extra & is crucial.
",0,48612821
48583532,"
As per Documentation std::sort

Sorts the elements in the range [first, last) in ascending order. The order of equal elements is not guaranteed to be preserved.

Definition
template< class ExecutionPolicy, class RandomIt, class Compare >
void sort( ExecutionPolicy&& policy, RandomIt first, RandomIt last, Compare comp )
Parameters

first, last   -   the range of elements to sort
comp  -   comparison function object (i.e. an object that satisfies the requirements of Compare) which returns ​true if the first argument is less than (i.e. is ordered before) the second. 

Complexity: O(N·log(N)) where N = std::distance(first, last)
Note: Its better to use vector than array, specially in your case(2D strings).
Example:
Live Code
",0,48581222
48573993,"
I'll answer the specific question, about the three-line add-subtract swap.  This is a slightly sneaky algebra trick to exchange two values without using a temporary variable (which the code does in the following three lines).
Let's look at this with a couple of single-letter values.  let
Now, let's trace the execution through the three lines of code.
This trick also works with bit-wise XOR and a variety of other operations.
",1,48573875
48566286,"
You can utilize a skip list structure for this problem. The way they work is, they offer some additional pointers to skip ahead of some parts of the list, in the form of additional layers. This increases space complexity but improves time complexity. With proper arrangements I think you should be able to reach O(logN) average complexity, however with still worst case O(N) complexity. 
",4,48566053
48545441,"
use std algorithms, it will make your code readable and maintainable. For example you can sort your objects with std::sort:
which outputs the sorted records:
I hope this gives you inspiration for your code!
",0,48544331
48582717,"
There are many problems in your benchmark that prevent you from making any conclusions form it:

You compare std::sorting a std::vector of std::strings with qsorting an array of char*s. Proper benchmark should use the same data structures.
An set size of 6 is not representative for benchmark by a few orders of magnitude.
Both algorithms sort in place, so despite performing one million iterations each, only first actually performs sort. The following 999999 iteration ""sort"" already sorted data.
You don't do anything meaningful with sorted data, so compiler might even remove your code.

",14,48540113
48540289,"
The problem was found，as @manni66 pointed out, I made a big mistake..  I used Debug mode , when I changed to Release mode, the result was reasonable:
",0,48540113
48510735,"
First off, your assumptions are wrong. std::sort is not going to call the comparison with the same arguments twice. As a result, the whole idea is flawed.
Second (and more importantly) your idea is flawed because predicates are not supposed to hold state. std::sort can copy those predicates and reuse the copies (in fact, gcc version certainly copied predicates when I checked some time ago) and thus will break the whole comparison.
",3,48510380
48513336,"
Yes, in the case proposed here, the idea isn't useful as sort doesn't need to distinguish the exact equivalence - it may painlessly mix a > b and a == b cases (thank to the unspecified ordering of equivalent elements).
But, if we consider stable_sort instead, the idea does work. Stable sort actually needs to distinguish all the three cases: a < b, a == b and a > b so it will call Cmp functor twice.
In general, taking care of such an optimization is often reasonable, and in some cases it's absolutely necessary in order to avoid an exponential growth of computation time (for example, if you sort/search some multi-level container when you need to search through children levels before you know the result of upper level comparison).
Also, storing the results of string comparison may be useful for subsequent sort/search/insert operations. Of course in order to implement this efficiently one needs a fast random access container which doesn't require string character iteration (otherwise it will be worse in runtime complexity than mere strcmp). It may become possible if your strings are canonicalized first. 
",0,48510380
48923182,"
Topological sort worked just fine.
Here's the code which can sort objects using typical topological sort. It also have a couple of functions to manage the graph. Will be flattered if it will help someone.
",0,48505206
48505453,"
Your code is almost correct. 
Issue is in the condition i.e. if(x<ar[q]). 
Consider array: 
its indices are:
consider user passed w=50, middle index q is computed to 5
The condition if(x<ar[q]) will be false because 50 is not less than 50. so its else part i.e. return(binarysearch(ar,x,q+1,r)); will be run i.e. return(binarysearch(ar,50,6,10)); Here the code takes the wrong turn. We start looking in the wrong subarray.
The item 50 we are looking for is in the first subarray i.e. 0 10 20 30 40 50, not in the second subarray i.e. 60 70 80 90 100. 
One way to fix your code is to make the condition if(x<ar[q]) as if(x<=ar[q]). Or you can add another if condition that just checks for equality and adjust q as required in other ifs.  
",1,48502749
48484763,"
On the last iteration of for cycle statues[i+1] will be out of bounds causing undefined behavior. You need to add checks that statuses is not empty before for loop and then iterate until size - 1.
",1,48484751
48455284,"
This is known as ""not a valid strict weak ordering"":
The fix is simple: don't reinvent the wheel:
",15,48455244
48459618,"
@T.C.'s answer is a good one since the question is tagged C++11, but in case future readers are after a C++03 solution, the 'canonical' way to write such a comparison operator (for members m1, m2, .... mn) is
(see here for a discussion, with the question having the above style but avoiding operator!=).
One further thing is that you are using pointers and your code is not bomb-proof. If a or b is NULL you'll get a crash. If you can't avoid pointers and you want to be paranoid then you need to add checks like
",1,48455244
48504114,"
A possible solution could be this:
which outputs the following:
including pairs is easy, just change how the compare functions are done for them. I don't know if this is what you meant. It can also be further optimized, this was a quick solution that might serve your needs or inspire you for a better one.
",3,48455182
48494651,"
Are the elements in each column bounded the depth of the column? If so just iterate through each column of your multi dimensional array and place the elements in their corresponding row. It is simple to do this if you allocate more memory or you can do it in place with swaps (still O(n)). You can apply more complicated grouping after the fact.
",0,48455182
48438212,"
The error message describes your code in a clear way.
You will have to reconsider what that line is supposed to do.
",4,48438149
48438186,"
string wordarray [1024]; is an array of string's. Getting an element from an array of strings gives you a string:
In C++ there is no conversion from std::string to int.
",2,48438149
48435073,"
In main 
is a forward declaration of the bubbleSort function, not a call to it.
will call the function.
",2,48434638
48386914,"

Flatten the list<pair<string, string>> to a list<string>
sort the list<string>
remove duplicates from the sorted list.

",0,48386608
48388332,"
There are easier and efficient ways to do this. Since you insisted and asked to find the error in your program, I solved it for you.
I assumed there are no cycles. Compare this with your sort function and understand why I moved 

iterator++

It's the only major thing you missed.
See below.
",0,48386608
48377486,"
Using your class (which formatting is messed up in the question): 
I was able to solve the problem using this code:
I can't claim that the code is typesafe as there is narrowing conversion at
when the size_t typed k is converted to short int. But I'll leave the type safety and all that to you.
Also I can't claim the code to be most efficient, but it's at least a working starting point. I definitely agree with @super, I think using a 1D vector for bit instead of 2D would be better. It would be trivial to convert it from 2D to 1D so I'll also leave that to you.
You may also call .reserve() on v_pairs before you start adding elements to it if you have many elements to insert.
",0,48374940
48374686,"
Just put the comparator inside top_trend my help, like this
or use lambda like @Igor comments, 
",1,48373728
48374267,"
And std::sort
needs a functor as its third parameter, pop is an int.
",0,48373728
48350256,"
There are various ways to do this. You can associate each word with a letter, for example using structures, std::map, etc. Create a data array where each member contain a word and integer value which points to its order in the sentence.
For data entry, note that you can start with an empty array vector<string> sentence instead of vector<string> sentence(n), then use the vector::push_back method to add additional input.
",0,48349089
48342983,"
It is actually quite easy:
This sorts the vector, based on the value of wt, in increasing order.
You also have another option: Defining operator< for particle, as follows:
Then, when calling std::sort, you can just do:
With the code above, std::sort will call operator< on each pair of particles, which now have overloads to compare them as such.
If you noticed, the lambda I used in the beginning is the same as the function overload I used above. This easily illustrates the beauty and flexibility of the STL and C++.
",3,48342907
48335661,"
It should work, this is what you meant?
",1,48335243
48337436,"
Live Code
",1,48335243
48334319,"
Instead of two place holders name[3] and arr[3] try using vector of pairs something like below:
Then you can use sort to sort your pairs based on finish time like below 
",4,48334250
48334358,"
Sort names also corresponding to their finishing times.
",0,48334250
48335018,"
What you are doing wrong here is that you are sorting the time array but not making respective changes to the name array. so you can pass the name array also along with time array and when you swap the time, at the same time swap the corresponding names. something like this..
and one more thing is that your function not returning this changed array. so either you return this changed array or make this time and name array globally accessible.
",0,48334250
48275803,"
You need to sort the lists at the same time to maintain the relative order. Eg,


",0,48275446
48275813,"
One solution to this problem is to create a pair<int, string> to store both the score and the player name in the same data element, then store those in whatever array type suits you (I would recommend std::vector, but I will use your choice of a simple array in my example).  As noted in previous answers, pair<T1, T2> has an overloaded operator< defined that compares the first element first, then the second element.  std::sort will take advantage of that:
Result:
You can reverse this list by simply iterating backward through scoreboard.  You can see a working example here.
",2,48275446
48276068,"
Thinking in the future of your project, you should rely on encapsulation. Create a Player class with the properties name and points, in the future you might want to add more functionality to your players! And you don't want to break your code, so encapsulation is the way to go.
You should try to use the algorithm library, it will make your code more expressive, and thus easier to maintain.
Try to use standard containers to manage your memory. The usual recommendation is to use vector for dynamic memory.
Here you have an example of a simple implementation of these tips, try your own!
Here I use the sort algorithm to sort the players in the vector. Sort uses the operator <, that's why you see the operator overload in the Player class. This tells how (player1 < player2) should behave (in our case, it's just comparing their points. But you could do anything, such as adding a bonus property to the Player class) 
Another recommendation is to separate the Player's class into a different file to keep things more structured.
",1,48275446
48274673,"
Not sure why you are sorting the index here as that causes a new order to be introduced compared to bb[aa,].
Anyway, the idea here is to subset using the .rows() index, which requires a uvec or unsigned integer vector. As aa contains R indexes, we can translate them from R to C++ by subtracting 1 to take it from a 1-based index system to a 0-based index system.
Test code:
",2,48274486
48276338,"
If you don't want to use any built-in sorting function then you have to implement it manually.
Its complexity is O(N^2). It takes much time when a number of the product is huge. You can use other algorithm with complexity O(Nlog(N)) such as Merge Sort, Quick Sort etc. to make it faster.
",0,48270489
48255628,"
Your operator< does not implement a strict weak ordering.  Part of that means if A < B, then !(B < A), and if A < B and B < C then A < C.  Since your operator calls play, which appears to update the score, the value for successive comparisons of elements changes for different comparisons, and the compiler is complaining because it is getting inconsistent results from the comparison.
Don't call play from the comparison, just call g.getScore() and compare those values.
",1,48254460
48203542,"
pthread_create() expects a void* -> void* function as third argument, but you provide quicksort which has signature arg_struct* -> void*. This is what the error message says:


Simply change quicksort's signature:

Now, if you use a decently recent compiler, C++11 provides a more portable and easier way to manage thread: std::thread.
",1,48202355
48152344,"
I implemented greedy approach here:
The algorithm needs O(N) space and O(N2) time.
",2,48148951
48149416,"
Let's divide up the sub sets into ""generations"", where each new generation differs from the next one by the subsets having one value more in length.
Obviously, the first generation is formed by the subsets consisting of only one single number. You get them by simply iterating over the array of numbers.
From each generation, you get the next one by adding to each subset each of the numbers following the last one in the current subset (store this index together with your subset!), but only if the number in question is larger than the last one in the subset. Increment a counter whenever you discover such a new subset.
You are done if you discover the new generation to be empty.
Interestingly, the empty subset is not to be considered???
Edit: WARNING: Worst case is a sorted sequence of numbers - In this case, the number of subsets in each generation will follow the pattern of the pascal triangle, which calculate as binomial coefficients! So largest generation, 300 elements given, would be 300!/150! subsets with each of them holding 150 values, which is far beyond what we could hold in memory!
",1,48148951
48157309,"
I will approach this problem by adding up the subsets starting from each of the elements given. This will end up to be a dynamic programming problem because:
Suppose there are 6 elements in the passed array v {5,2,6,1,1,8}. Then when we are counting the subsets starting with the 2nd element '2', we can use the solutions for the number of ascending subsets starting from the 3rd, 4th or the next elements. 
Our definition for the recursive dp function will be:
And answer will be:
So each call gives the index where to start and for every number ahead than the index, we have an option whether to take it (if it follows the ascending condition) or leave it. We take both the possibilities and return the sum of both.
Base condition will be when index reaches the length of the array v. Check whether this is a valid subset and return 0/1 accordingly.
",0,48148951
48143412,"
First of all, you should use a suffix tree for this. But I'll answer your original question.
C++17 :
NOTE: uses experimental features
You may use std::string_view to reference the strings without copying. Here is an example code:
Everything before C++17:
You could use a custom predicate with the sort function. Instead of making your vector store the actual strings, make it store pair which contains the index.
Here is an example of code needed to make it work:
Even if you reduce your memory usage, your program will still take 40T iterations to run anyways (since you need to compare the strings). Unless you use some sort of hashing string comparison algorithm.
",1,48143321
48143848,"
You could use a combination of std::string_view, std::hash and std::set.
If the amount of suffixes are extremely high, there is a chance for false positives with the std::set. It has std::size_ts max value number of different hashes, which is normally a uint64.
It also starts searching for matches at the maximum lenght of the strings, maybe a more reasonable approach is to set some sort of maximum lenght for the suffixes.
",1,48143321
48143474,"
std::sort sorts data in main memory.
If you can fit the data in main memory, then you can sort it with std::sort.
Otherwise not.
",0,48143321
48138871,"
Consider how many steps are required if n is 1.  
Basically, you don't need to sort the first element.
",3,48138693
48138890,"
The sorting is done by comparing pairs of elements.
How many pairs are there in an array of N elements? (hint: N-1)
This animation might help explain how the algorithm works.
",3,48138693
48143447,"
There is actually nothing wrong with your intent in the comparison function, it's a perfectly valid solution to use original ordering to turn an unstable sort into a stable one.
So, why it's being rejected, I cannot tell for sure, at least without having access to the test data being used.
It's possible that the names may contain spaces which will screw up your input method but (1) that doesn't seem to be indicated by the test description; and (2) it would make the input much more difficult, at least for the level the assignment seems aimed at.
However, though you may consider it unlikely, there is the possibility that the sorting algorithm may at some point compare an object with itself. This means it will return some arbitrary value since you assume they will always be different, given the added order checking.
You should probably cater for that since the one rule you're meant to follow in the comparison function is consistency and that, if a > b then b < a. So, two rules, really :-)
In addition, one thing I would suggest is to minimise your use of the legacy-C stuff like printf and scanf where C++ provides better facilities.
To that end, I believe you'd be better off with:
You might also even want to consider moving away from the legacy-C qsort since C++ provides stable sort built in, specifically the stable_sort found in <algorithm>.
",5,48135394
48136008,"
It ends up that I missed a line in the description: 

The input includes multiple test cases. In each test case, the first line contains one integer N.

After several approaches, I got it passed  with the following code:
std::stable_sort just works, However, it received TLE(Time Limit Exceeded),and the cin/cout causes TLE, too. So that's the reason I stick with printf/scanf.
Thanks everyone for answering this question! :)
",0,48135394
48121529,"
You should be able to use arma::sort_index for this, which you mention in your post:
Result:
Of course, there are other ways as well. Variations on this question have been asked a few times on Stack Overflow in the context of plain C++. Below I've adapted the answer here for Rcpp:
Result:
",2,48118248
48096937,"
As DAle already noted.
You can first sort the n numbers. A good algorithm, like merge or heap sort, will give you a complexity O(n*log(n)). 
After that you need to use search algorithm for both your 'first' and 'second' parts of each interval. Depending on the algorithm, the complexity should be around O(log(n)) - std::lower_bound has complexity of O(log(n)) when working on sorted data, so its good enough. Or that will be O(m*log(n)) for all intervals.
Comparing the result of the search will give you the amount of numbers in each interval. 
In total you'll have around O((m+n)*log(n)).
",0,48095346
48064566,"
Here's one way, which is O(N) at the expense of maintaining storage for every possible char value.
This portable solution is complicated by the fact that char can be signed or unsigned.
",13,48064179
48064527,"
Here is what @bathsheba mentioned and with improvements by @Holt:
",3,48064179
48054035,"
To swap first and last names, use the following trick:

Reverse the entire string
Reverse the individual names in the string

To do this, you should write a function that reverses a string between two indices, and you will need to use string::find() (or a loop) to find the space between the names.
To sort three items, use the following trick:

sort the first two items
sort the last two items
sort the first two items

Again, sorting two items is perfect for a function.
Hints:
",1,48053159
48053877,"
Assuming it's a homework question and you shouldn't use macros or try to cleverly avoid restrictions: 
Use string concatenation (strcat in standard C library) to join two string together. Use "" "" to separate them. This will preserve the lexicographical order and reduce the problem to the one already solved :) 
Use the 6 if clauses you've already made for selecting proper order of the resulting (single) string. 
In c++ you can just use operator+ to join strings.
If you cannot print the resulting single string (the order of printing and comparison are different) - you have to split them (strtok) and reverse the first/last name before printing. 
@EDIT
Also, while we're at it, you can just use std::cin >> firstName >> lastName to read strings (it will read until first whitespace) and lowercase them char by char in the same loop using std::string::operator[] to access chars
",1,48053159
48050778,"
I found the problem, replacing inv_count += (mid - i) to inv_count += (n1 - i) did the work as it makes sense
",2,48050334
48022621,"
12 decimal digits is too long to fit into a 32-bit number, which is how int is usually represented. Reading that number using >> therefore fails and cin >> input converts to a false value, which terminates the loop.
See operator >> documentation for details of handling failure modes.
",3,48022563
48022699,"
You can get the maximum number of base-10 digits that can be represented by the type using the std::numeric_limits::digits10 constant:
Chances are the maximum number of significant digits for type int is 9, and you try to supply 12 via standard input. The program doesn't crash, the condition of (cin >> input) simply evaluates to false.
",1,48022563
48022687,"
12 digits is too much for 32-bit integer, try to use as unsigned long long int, check these limits:
http://www.cplusplus.com/reference/climits/
",0,48022563
49582451,"
The fastest way will depend on ... imponderables.  You'll need to benchmark the actual application on the actual machine-type, under typical load. 
Version f3 can be improved so it does not expand v1, which could cause a reallocation.
I am going to contribute a merge routine from my personal stash. It uses move-semantics when appropriate.
",0,49581667
49579826,"
C++ comes with a standard implementation of a queue data structure. Take a look!
Here is a quick example using your packets:
I know this is a very brief example, so take a look at the documentation to get a better grasp.
I hope this answers your questions. It is kind of broad.
",2,49579036
49580309,"
Well, I see many issues that we can address in your code. Some are important and some just nice to have. But let's star:

You said you wish you will have ""queues"". In that case, I would say, use std:queue (http://www.cplusplus.com/reference/queue/queue/), this will give you a chance to save a lot of time and will make your code cleaner.
You said, that you wish you will have many prioritized queues. I would say that's nothing more than std::vector of std::queues, so will end up with something like this:

std::vector<std::queue<Frame>> queues;

Then you can pack it in a little bit of structure:

//

So the usage is much clear then:

That's all about queues... but now you need to prepare a structure/class describing your data. Something like:
class Frame {
    std::string preamble;
    std::string mac;
    int vlanId;
    /// ... and so one
}

Then you have to split your message into small parts, but not using char* (which comes from c language) but using std::string.substr(n,p);
So let say you will have something like this in your code:
",1,49579036
49569269,"
Your code has undefined behavior since not all values from v1 are valid indices for v2. In particular, 5 is an invalid index for v2.
Here's a way accomplish what you want to:

Create a std::vector<std::pair<double, double>> created from v1 and v2.
Sort new object using the second of the pair.
Pull out the values from the sorted vector and assign them to v1.

Here's an updated version of the function.
You can probably use boost::zip_iterator to simplify that task but I have not used it myself.

Update, in response to OP's comment.
If you change v1 to be of type std::vector<size_t> instead of std::vector<double> and make sure that it contains {0, 1, 2, 3, 4}, then you may use:
to sort the indices without a problem.
You can also update your function so that v1 is resized to match the size of v2 and make sure to set the indices correctly before calling sort.
",2,49569228
49534978,"
Considering you have a class or struct CustomType
Pre c++11
Post c++11, using lambdas:
There is third option:
You can use std::less but there must exist an operator < that takes your CustomType as arguments
Example:
And you can specialize std::less:
",0,49534791
49535076,"
As Sam Varshavchik stated, replace your comparing operator with your comparing function. Meaning this:
Changes to this:
Btw you have a not handled case:
",1,49534791
49540302,"
I think you are over complicating your implementation(s) for merge and merge sort. I've written the same function with 2 overloads and placed them in a namespace so that they don't conflict with the std library's version of merge. Take a look at my example to see what has been done.


These 2 overload functions do exactly what you are looking for; to merge and sort while being able to choose what predicate comp function, functor, etc. to use in a single function. 
Using the template class InputIt notation simplifies a lot of the internal parts of the functions; not having to keep track of sizes, index positions, indexing into arrays, etc. 
All we really need to do is go through a for loop using the appropriate comparison operators on the Input Iterators then decide when to either use std::copy(...) or to assign an element from either first2 or first1 then increment our iterator.  Finally after the for loop finishes we want to use and return std::copy(...). The first overload without the compare predicate by default uses the < operator where the second overload takes a predicate.
This also allows for you to pass any kind of container that has a begin and end, iterator making it very generic, modular and portable while trying to maintain the best practices of modern c++. 
",0,49534791
5056797,"
Even though correct answers have already been posted, I thought I'd add a demo of how you can do this cleanly:

Generic Associative Source (requires C++11)
If you're using an alternate to std::map for the source associative container (such as std::unordered_map), you could code a separate overload, but in the end the action is still the same, so a generalized associative container using variadic templates can be used for either mapping construct:
This will work for both std::map and std::unordered_map  as the source of the flip.
",50,49511869
19528891,"
I needed something similar, but the flipped map wouldn't work for me.  I just copied out my map (freq below) into a vector of pairs, then sorted the pairs however I wanted.
",29,49511869
5056677,"
If you want to present the values in a map in sorted order, then copy the values from the map to vector and sort the vector.   
",10,49511869
14431337,"
I like the the answer from Oli (flipping a map), but seems it has a problem: the container map does not allow two elements with the same key.
A solution is to make dst the type multimap. Another one is to dump src into a vector and sort the vector. The former requires minor modifications to Oli's answer, and the latter can be implemented using STL copy concisely
",8,49511869
5056720,"
You can't sort a std::map this way, because a the entries in the map are sorted by the key. If you want to sort by value, you need to create a new std::map with swapped key and value.
Remember that the double keys need to be unique in testMap2 or use std::multimap.
",3,49511869
23050953,"
To build on Oli's solution (https://stackoverflow.com/a/5056797/2472351) using multimaps, you can replace the two template functions he used with the following:
Here is an example program that shows all the key-value pairs being preserved after performing the flip.
Result:

",3,49511869
5056731,"
A std::map sorted by it's value is in essence a std::set. By far the easiest way is to copy all entries in the map to a set (taken and adapted from here)
One caveat: if the map contains different keys with the same value, they will not be inserted into the set and be lost.
",1,49511869
19783706,"
In the following sample code, I wrote an simple way to output top words in an word_map map where key is string (word) and value is unsigned int (word occurrence).
The idea is simple, find the current top word and delete it from the map. It's not optimized, but it works well when the map is not large and we only need to output the top N words, instead of sorting the whole map.
",1,49511869
20174585,"
Flipped structure might no longer be a map but rather a multimap, thus in the flip_map example above not all elements from B will necessarily appear in the resulting data structure. 
",1,49511869
5056736,"
U can consider using boost::bimap that might gave you a feeling that map is sorted by key and by values simultaneously (this is not what really happens, though)
",0,49511869
54472371,"
In this context, we should convert map to multimap. I think convert map to set is not good because we will lose many information in case of there is many duplicate values in the original map. Here is my solution, I defined the less than comparator that sort by value (cmp function). We can customize the cmp function as our demand. 
",0,49511869
49481223,"
Here is a way to do it using std::rotate and std::sort.
It rotates the elements that should not be sorted to the end, then sorts the beginning part and then rotates back the ones we moved.
I used a std::array instead of a c-style array. Works on a std::vector as well.
",7,49480377
49481133,"
This is a nice show case for a range library, e.g. Boost.Range.
We first create a slice range for the parts to be sorted left and right to the fixed part.
Then we create a new range which joins these two slices
and sort it
Together with output this gives us the following code using Boost.Range:
Running the code prints
It should also be very efficient since there is no extra moving or copying of data involved. I also find it very expressive.
",2,49480377
49480864,"
You can take out the elements that you want to sort and store them in a temp array, then restructure the array in the form you need. I've provided a crude code solution; however, you should look into using std::vector or another std container (also array lengths are hardcoded, if you want to change the length of the orignal array you would need to use something like sizeof(a)/sizeof(a[0])).
",0,49480377
49483268,"
I provide two solutions:

sort a temporary copy and put the sorted items back into the original list
create several views of the data, and sort one of the views of the data

Solution One - Make a temporary array with entries 1 - 3 missing. Sort the temporary and put the temporary back into the original array. To make this ""elegate"", I use an index array which is a lookup into my original array for where to pull the values from and push the values back to:
Solution Two - Use a custom comparator to sort a the subset of the array:
",0,49480377
49482562,"
Here is a solution that uses bubble sort to sort the array around the non-sort interval:
",-1,49480377
49477068,"
Not exactly what you asked but... what about putting in the vector a pair with the sorting ID and a B ?
I mean... if you define an enum for sorting IDs
and a type using to make shorter the code
you can define the vector as follows
add elements remembering the correct ID
and sorting with the use of a simple lambda 
When you add another class E, you have only to add an isE ID in the idClass enum (in the position you prefer) and there is no need to modify B, C or D.
The following is a full working example
",1,49476184
49472913,"
Using lambda you can implement like this:Use a property int get_gpa() const to access the protected member.
Here how to implement the property ( a member function to return the protected variable) :
",0,49472862
49471016,"
Ok, so Solver::solve() starts by calling normalise:
What that's doing is taking an array A of integers - say {4, 2, 9}, and populating an array S where A's values are sorted and paired with the index at which they appear in A - for our example, {{2, 1}, {4, 0}, {9, 2}}.
Then the solver calls  get_maximum_xor()...
The ""for i"" loop is used to get successive sorted values from S (those values originally from A).  While you haven't posted a complete program, so we can't know for sure nothing's prepopulating any values in P, I'll assume that.  We do know P's is a std::map and upper_bound searches to find the first element in P greater than S[i].second (the index at which current_value appeared in A) and values above, then something similar for P_rev which is a std::map in which values are sorted in descending order, likely it will be kept populated with the same values as P but again we don't have the code.
Then...
...is saying that if any of the values in P were >= S[i].second, look up A at the index it_after found (getting a sense now that P tracks the last elements in each subsequence (?)), and if the current_value XORed with that value from A is more than any earlier result candidate (res), then update res with the new larger value.
It does something similar with P_rev.
Finally...
Adds the index of current_value in A to P and P_rev for future iterations.
So, while I haven't explained why or how the algorithm works (I haven't even read the problem statement), I think that should make it clear what the C++ is doing which is what you said you're struggling with - you're on your own for the rest ;-).
",1,49470143
49441796,"
This is insertion sort. well its very primitive. as you can see it take each element and trys to find its place by comparing between element before and after it using for looping 
",1,49441444
49411491,"
There is no break in the body of your while (true) { ... }, so anything after it is unreachable. 
As your test cases run to completion, and there are no exceptions thrown or caught, that means they must have all hit return j;, each time you partitioned. 
",0,49410095
49438075,"
Confusion arose, because I had implemented the algorithm wrong. As a couple users pointed out in the comments to the original question (before edits), the listing on wikipedia uses a do/while as opposed to a while, such that the increment of i and decrement of j occur before the evaluation of the condition.
I had assumed there was no functional difference, but there is.
So, given an equivalent partition function:
It becomes obvious that the check for i >= j will get a true hit after the loop walked the marker at each bound closer towards the middle, when they are pointed to the same element or have crossed over each other.
With the fixes increment and decrement loops, an increment and decrement occur each iteration of the main loop. Whereas before, they didn't.
As always, when dealing with algorithms, step through it on paper and it will become clear.
",0,49410095
49383950,"
I think you are asking how to implement Validation::checkFormat, because Validation::valDate doesn't seem incorrect.
Note that checkFormat sounds to be the wrong name for returning a string formatted in a particular way. I would call it fixFormat, and compare input to the result of fixFormat. If they are the same, then input is in the specified format
",0,49312039
49272621,"
This looks like a selection sort for an array of size 5 that sorts the elements in descending order. 
",3,49272573
49228024,"
The sort in your post is a natural merge sort.  The binary merge sort works like a merge sort with the additional step of using a binary insertion sort before the merge sort.  
This is done to combine the efficiency of insertion sort on small sets of data with the efficiency of merge sort on large sets of data.
Check out the 'Variants' section here: https://en.wikipedia.org/wiki/Insertion_sort#Variants
Here is a related SO question, as well: Binary Merge sort & Natural Merge sort
",2,49227706
49222298,"
Here is a possible solution I came up with using an std::unordered_map and tracking the order of inserting using a std::vector.  

Create a hash map with the string as key and count as value.
In addition, create a vector with iterators to that map type.  
When counting elements, if the object is not yet in the map, add to both map and vector. Else, just increment the counter. The vector will preserve the order the elements got inserted to the map, and the insertion / update will still be in O(1) time complexity.
Apply bucket sort by iterating over the vector (instead of the map), this ensures the order is preserved and we'll get a stable sort. O(N)
Extract from the buckets to make a sorted array. O(N)

Implementation: 
",0,49213443
49200496,"
Try this:
or use std::stable_sort if you want a stable sort. Although not needed in this case, as commented below, a lambda compare function with no capture could also be used:
",0,49200416
49294080,"
simply overload the operator inside struct then sort the array.
sort(a,a+n);
",0,49200416
49162644,"
This is why your program stops. It is waiting for you to type something at the keyboard. (cin is the standard input in C++)
",1,49162383
49162632,"
My sincere advise would be always use pen and paper and note down your requirement first. Base on that write down the algorithm and convert that algorithm into code. What are you doing in your codes are all wrong unfortunately. Just deeply think what are you doing in your code specially below codes:-
If you consider all this very carefully you will understand all your mistakes.
Hope this will help you..
",0,49162383
49144889,"
Several suggestions:

You should carefully consider your variable types and usage. Since you choose to use std::string, you should get familiar with its basics from documentation.
Thoughtful variable naming can help you avoid some obvious programming bugs. For instance, you use
which should clearly be the string studentName1 and not the int.
Plan out your usage of variables. Do you really need all the ints? You are sorting the names themselves alphabetically, not numbers.
Use assignments carefully.
indicates you are assigning the value of firstEntry, i.e. 0 to studentName, effectively replacing anything it was meant to contain before.
For the actual sorting, you have a choice to make between available std::string functions, or if that's prohibited in your class constraints, classic string iteration. In case of the latter, the biggest lead would be the fact that a string can be iterated as a character array. Sorting then simply reduces to character comparison.
Last tip, which judging from your attempt, you probably had in mind already. Since you only need to output the first and last names in the queue, you need not sort the entire list, just maintain the first and last names.

Good luck!
",1,49144411
49145305,"
if you just need max and mi just compare the strings and store in 2 separate variables
set the first name as min initially then traverse the entire file 
compare with the initial name
if it is less replace else store in max
compare max with the incoming text if greater replace  
correct me if i am wrong
",1,49144411
49144820,"
Ask your professor to teach you about std::set and std::getline then you can let the power of C++ work for you.
Edit: If you're not interested in the full sorted set of names and you just care about the first and last entries, you can simply set up iterators to those elements in your set and just dereference them to get their values.
",0,49144411
49142125,"
std::string::compare returns an int, not a bool. According to cppreference.com the return value is

negative value if *this appears before the character sequence specified by the arguments, in lexicographical order
zero if both character sequences compare equivalent
positive value if *this appears after the character sequence specified by the arguments, in lexicographical order strong text

The returned value is cast to bool which evaluates to true for all non-zero values. That means that your function returns true for every non-identical pair of strings.
The C++ standard actually defines operator< for strings so you can change your function to
But that still leaves a big issue in your code. You absolutely do not need pointers for this. In fact, you are leaking memory right now because you neglect to delete them. The proper tool for this job is std::vector<std::string>. This has the added benefit that without the extra level of indirection, std::sort can implicitly call operator< without a helper function, leading to the following solution.
",4,49142024
49142087,"
You can do it with a lambda:
",2,49142024
49142107,"
Your comparison function is meant to simulate the less-than operator - that means it should return true if a comes before b. Your current implementation returns true if a doesn't equal b.
You have:
which should be:
or just:
",2,49142024
49142174,"
std::sort expects Strict Weak Ordering. It doesn't give a crap about equals; it only cares about before and after.
The comparison function should return true if the right hand side goes before left hand side. Unfortunately in 
bool is true for any value that is not 0. This means that both greater than and less than are true. This makes logical ordering pretty much impossible because greater than and less than go before.
Improvement cut 1: return bool based on lexicographic (alphabetical) ordering. String already implements a less than operator that does exactly what you want. Let's use it.
Improvement cut 2: std::string a1 = *a; creates a brand new string that is a copy of the original. Since you have a pointer to the original you can dereference the pointer and use the original. No need for the copy.
",2,49142024
49115417,"
IMO, a 2D vector is the wrong place to start with this. I'd start with a struct with a member for each field in the file, and define comparison for those structures. Since the time field you want is a floating point number anyway, and those (on nearly all reasonable implementations) support a representation of infinity, I'd use that to get the behavior you want.
As you'd expect, infinity sorts as being larger than any other number, so you don't have to do anything special with the comparison to get these to sort into the order you want--all the ones that had numbers present sorted by that number, followed by all the ones with a '-' for the time field.
Simplifying a bit (leaving out most of the unrelated fields), code might look something like this:
Output looks like this:
",0,49114595
49099027,"
You're facing the famous 'index out of bound' error. Your sorting loops are exceeding the array bounds resulting reading/writing violation. As short, check the array bounds and make sure you're not violating any memory address.
",0,49098977
49080573,"
C++ is all about not re-inventing wheels. It was specifically designed for writing libraries and generic code like the STL (Standard Template Library).
",2,49080060
49084911,"
Alright, I'm going to give you a plain and simple answer that'll be very easy to understand.

Start using STL.It'll have most of the pre build functions that might come handy all the time.
Instead of using #include<iostream> use #include<bits/stdc++.h>.


Now coming to your question, I'll tweak your code and make it simpler and will become easy to understand.
Let me know if you don't understand anything.
",0,49080060
49080242,"
//Got IT!!!!
",-1,49080060
49070646,"
*a will be 4 in both cases, as the value pointed to by a would be 3.2 if that was inserted correctly into the container.
lower_bound and upper_bound will return the same iterator if the value passed is not present in the container, which is the case here.
The iterator returned by lower_bound is defined to be the lowest position where the element passed could reside it was in the container, higher_bound returns the highest position. They do not return anything related to the closest element present in the array. 
In order to find the closest element, you know that the dereferenced result of lower_bound is greater than or equal to the value passed. The value before that, if any, must be less. You can make use of this in order to arrive at the closest value.
",1,49070559
49071010,"
As the value 3.2 is absent in the array then the both algorithms std::lower_bound and std::upper_bound will return the same iterator.
In such a case you should consider a previous iterator.
Here is a demonstrative program.
Its output is
",1,49070559
17074810,"
Finding a sort permutation
Given a std::vector<T> and a comparison for T's, we want to be able to find the permutation you would use if you were to sort the vector using this comparison.
Applying a sort permutation
Given a std::vector<T> and a permutation, we want to be able to build a new std::vector<T> that is reordered according to the permutation.
You could of course modify apply_permutation to mutate the vector you give it rather than returning a new sorted copy. This approach is still linear time complexity and uses one bit per item in your vector. Theoretically, it's still linear space complexity; but, in practice, when sizeof(T) is large the reduction in memory usage can be dramatic. (See details)
Example
Resources

std::vector
std::iota
std::sort
std::swap
std::transform

",95,49027570
25097083,"
In-place sorting using permutation
I would use a permutation like Timothy, although if your data is too large and you don't want to allocate more memory for the sorted vector you should do it in-place. Here is a example of a O(n) (linear complexity)  in-place sorting using permutation:
The trick is to get the permutation and the reverse permutation to know where to put the data overwritten by the last sorting step. 
",3,49027570
46506051,"
I would like to contribute with a extension I came up with.
The goal is to be able to sort multiple vectors at the same time using a simple syntax.
The algorithm is the same as the one Timothy proposed but using variadic templates, so we can sort multiple vectors of arbitrary types at the same time.
Here's the code snippet:
Test it in Ideone.
I explain this a little bit better in this blog post.
",2,49027570
53785022,"
With range-v3, it is simple, sort a zip view:
or explicitly use projection:
Demo
",2,49027570
17074762,"

Make a vector of pairs out of your individual vectors.
initialize vector of pairs
Adding to a vector of pair
Make a custom sort comparator:
Sorting a vector of custom objects
http://rosettacode.org/wiki/Sort_using_a_custom_comparator#C.2B.2B
Sort your vector of pairs.
Separate your vector of pairs into individual vectors.
Put all of these into a function.    

Code:    
",1,49027570
17074639,"
I'm assuming that vectorA and vectorB have equal lengths. You could create another vector, let's call it pos, where:
pos[i] = the position of vectorA[i] after sorting phase
and then, you can sort vectorB using pos, i.e create vectorBsorted where:
and then vectorBsorted is sorted by the same permutation of indexes as vectorA is.
",0,49027570
41602163,"
I am not sure if this works but i would use something like this. For example to sort two vectors i would use descending bubble sort method and vector pairs.
For descending bubble sort, i would create a function that requires a vector pair.
After that i would put your 2 vector values into one vector pair. If you are able to add values at the same time use this one and than call the bubble sort function.
If you want to use values after adding to your 2 vectors, you can use this one and than call the bubble sort function.
I hope this helps.
Regards,
Caner
",0,49027570
49042792,"
I'm only giving you bubble sort.
",0,49019957
49011734,"
This error occurs due to memory corruption. Here memory corruption occurred because you wrote past the array limit.
Eg: If there is an array of 5 integers like
You should not do things like
C/C++ doesn't check for array out of bound operation. It permits such operation without compilation error. Result is, anything can happen to when you run program. So its the responsibility of the programmer to check such errors.
One such instance is found in your code.
",0,49009941
49010324,"
In bubbleSort your array index goes out of range. Modify the function like shown below and you'll see what happens:
There afre most likely similar problems in your other sort functions.
",0,49009941
48989059,"
Yes, use std::vector type. It will automatically handles allocations for you each time you push value to it (using push_back method).
Example
It's also a good idea to avoid new syntax, as it doesn't automatically deallocate, unlike std::vector.
Also, while this is unrelated to question, C++ provides a function that does what you want already called std::copy_if.
",5,48989014
48989763,"
std::remove is the algorithm you're looking for.
It moves all matched elements (42 in the example) to the end of the array. When inspecting array after std::remove runs, you get {1, 314, 42, 42}, and end points past the last nonmatching element (the first 42 in this case).
It's also possible to copy the nonmatching elements to another array using std::remove_copy, or std::copy_if, but in order to do this, you'll have to allocate another array of elements. At this point, you're better off using a dynamic growing array such as std::vector. In that case, use std::vector::erase like here in the answers with std::remove.
",0,48989014
48980634,"
To resolve the out-of-range error, simply change the for loop to the one below to make sure that que1count and que2count never goes above their string sizes:
Now this will compile. However, your merge loop still doesn't do what you intend it to. Try using some vector functionalities for que1 and que2 too. You're only using vector functionalities for queMerge right now.
This can be helpful: http://www.cplusplus.com/forum/beginner/98971/
",0,48979346
48978632,"
This is a pretty clever algorithm -- in each iteration it counts the inversions that will be removed by the division by two...  Although it's unnecessary to use an array for B, since all you do with it is add to the elements and then sum them up.  You can just keep a single running sum.
Anyway...  In order to speed up step (2) you can use another array C[v] to remember counts for all the odd values in A, like this:
",1,48977484
48972435,"
I'll just go off of the comment in your code and explain what's wrong with it (if anything), and how you would fix it.
Good so far
What if both participants have the same disposition as the initiator? Even if you can guarantee that no 2 elements will satisfy this condition, the sort algorithm is allowed to compare an element against itself. This test would return true in that case, violating one of the conditions of a strict-weak ordering, which is that an element must compare equal to itself (i.e. compare(a,a) must always be false).
Perhaps instead you want to say that if a has the same disposition as the initiator, and b does not, then a should be considered less than b. This can be encoded as:
So your full test would look like this:
",1,48972158
48975345,"
The reason for the crash hasn't been explained yet. Most implementations of std::sort are based on quick sort, specifically Hoare partition scheme, which scans an array from left towards the right as long as element values < pivot values, and scans the array from right towards the left as long as element values > pivot values. These scans are counting on the fact that finding an element value = pivot value will stop a scan, so there's no check for scanning beyond the boundaries of an array. If the user supplied less than compare function returns true in the case of equal elements, then either of the scans may go beyond the array boundaries and cause a crash.
In the case of a debug build, testing of the user compare function may be done to ensure that the compare is less than and not less than or equal, but for a release build, the goal is speed, so these checks are not performed.
",2,48972158
48970113,"
leftRotateByOne is the key function here. The others can stay the same. Have a look at what it is doing, preferably with a pen and paper to keep track of the operations:

Keeps a copy of the first element. 
Moves all elements to the ""left"" (that is, to the element with index
one less), being careful not to overwrite anything you need later.
Puts the first element in the last place.

So you need to do the opposite:

Keep a copy of the last element. 
Moves all elements to the ""right"" (that is, to the element with index
one more), being careful not to overwrite anything you need later.
Puts the last element in the first place.

For example:
",1,48970065
48960758,"
You can go for recursive shell sort like this:
",1,48960639
48926507,"
Don't allocate memory in merge, allocate one large array of size MAX in advance and use it within merge_sort. 
Your merge function is called a lot of times, moreover from multiple threads. Each new modifies free store (heap), which is typically done in some form of critical section. There are scalable allocators, such as malloc from Intel TBB for this purpose. However, there is no reason for such allocation in mergesort implementation.
Moreover you don't delete[] temp in your merge function. There are many more problems with your code, such as data race (int thread_part = part++;). You perform final merge only sequentially, which hinders scalability. Efficient implementations of mergesort (and quicksort) typically uses insertion sort at the end of recursion (e.g., below 10 elements), since it is faster than calling a function. Etc...
",1,48919646
48903421,"
The lines like
Are creating objects of type LocationNode on the stack. The new operation creates a new object on the heap, that is copied in your local object (see A, B, ...) and then leaked.
As you are adding local object to your nodes conatiner, as soon as you exit the Init function the data contained in the nodes becomes unusable for any purpose.
Change the line above in:
and then add them to the list using
it should get rid of the 90% of your issues.
",3,48903194
48903329,"
You are pushing pointers to stack-allocated objects. These pointes become invalid right after those objects go out of scope so your nodes container ends up with a bunch of dangling pointers. You should populate this container with pointers to heap-allocated objects so they will be valid. And don't forget to delete them later or use smart pointers. Alternatively, you can store objects in the list by value. Note that unlike std::vector, std::list does not invalidate pointers to existing items when new items are added or removed.
",6,48903194
48903375,"
What are you doing here ? You created object new LocationNode('A',1,2) on heap, then copy of this object is made LocationNode A = *(new LocationNode('A',1,2));, A is copy and it is created as local variable in init function. You push address of local variable object into nodes vector, but when init function ends all local objects are deleted, and you have in nodes dangling pointers - they point to objects which don't exist.
You can change to 
and remember to delete all dynamic allocated objects.
",2,48903194
48897792,"
In order to correctly overload the < operator, your relation would have to be a strict weak ordering, meaning that, for it to be a strict order, it would have to be asymmetric and transitive, and for it to be a weak order, its incomparability relation must be transitive. In other words, this means that if you're comparing three matrices, A, B, and C, then your ""<"" cannot have both A

To satisfy that last requirement, the comparison of A and B must return ""equal"" only if the matrix A is the same as matrix B, which we know can only be true if every element of A is equal to every element of B. Taking this into consideration, we must use every element in the matrices to ensure that A and B returns ""equal"" only if the matrix A is the same as matrix B.
Consider the following function:


If matrix A has less rows than matrix B (return A is less than B)
If matrix B has less rows than matrix A (return B is less than A)
If they have the same number of rows, continue
If matrix A has less cols than matrix B (return A is less than B)
If matrix B has less cols than matrix A (return B is less than A)
If they have the same number of cols, continue
Iterate through every element in A 
i. Compare the integer value at each position and the integer value
  of B at that same position
ii. If element at A < element at B (return A is less than B)
iii. If element at B < element at A (return B is less than A)
If all entries are equal (return A = B)


This means that in the worst case, the function will have to check every element in the matrices, but in order for the < operator to be correctly overloaded, there is no other choice
In every other case, the function will return as soon as there is a difference in the elements which will be fairly quick most times
",2,48896876
48890082,"
Don't understood why your question has been down voted. As I understood you have develop two programs with same operation. One you implemented with multi process and other one is with multi thread. First of all you need to know the difference between multi process and multi thread. I think you are using fork() in your multi process version. In multi process version, operating system create separate data segment for each process, hence while you are using fork() OS allocate a new memory space for the child process and copies all the memories from your parents process to newly created child process's memory location. But in the case of multi thread that never happens. So during memory access in multi threading environment, if you are using synchronize memory access the performance in thread version will be severely impacted but not in multi process version.  
",-1,48889007
48878701,"
You get different behaviors because you are in fact calling two different (overloaded) sort functions. 
In the first case you call the two parameter std::sort, which uses operator< directly. Since the iterators to your vector elements produce non-const references, it can apply operator< just fine.
In the second case, you are using the three parameter version of std::sort. The one that accepts a functor. You pass std::greater. And that functor has an operator() declared as follows:
Note the const references. It binds the elements it needs to compare to const references. So your own operator> must be const correct as well.
If you were to call std::sort with std::less, your operator< will produce the same error, because it's not const-correct.
",81,48878629
48878735,"
Use of std::sort(vec.begin(), vec.end()) depends only on the operator< function. It does not require that the function be able to work with const objects.
std::greater, on the other hand, requires the function be able to work with const objects.
You will see a similar problem if you use std::less, such as std::sort(vec.begin(), vec.end(), std::less<MyStruct>()).

Having said that, there is no reason for the operator< function and the operator> function to be non-const member functions. Any member function that does not modify member data should be made a const member function.
",24,48878629
48857543,"
It appears this is for a class assignment. In the real world this would not be done with inline assembly. 
Problems:

You clobber digit by overwriting the associated register when you move 10 to RBX. The C++ compiler doesn't know this since you made no mention of RBX being modified in the constraints. The compiler may assume RBX was the same before and after your inline assembly.
Since you are using 32-bit integers you can use long instead of quadword division. 
DIV is unsigned division, IDIV is signed division. Your C++ code operates on signed numbers. This really doesn't matter though since this code will crash with negative numbers in the array. If you use signed division you can sign extend EAX into EDX with CDQ. 
Use the assembly template to pass the divisor (10) via a register chosen by the compiler.
You can cast i to a long type in the constraint. In 64-bit code long is 64-bits and will cause the compiler to use a 64-bit register by default when referenced inside the assembly template. 
Integers are 4 bytes wide, not 8. When accessing the memory associated with the integer array you want to use instructions that read 4 bytes. The MOVQ and INCQ instructions you use move 8 bytes. You'll want to consider MOVL and INCL or other equivalents that move 4 bytes. If you want to move a signed 4-byte value from memory to a 64-Bit register you can use MOVSXD. In AT&T syntax it is preferable to use MOVSLQ/MOVSL or MOVSXL as they are understood by both CLANG and GCC/G++.
Allow the compiler to pick registers for input and output operands when you can rather than hard code them in the assembly template. In your code the only register that is modified implicitly by one of the instructions and we can't do much about is RDX. Add it to the clobbers list so the compiler knows its contents may change.

The revised code could look like this:
I've also removed the memory clobber and told it that the array is an output memory operand that will be modified. This is discussed in the GCC inline assembly documentation. Since there are no other side effects of the assembly template besides what are specified in the constraints and clobbers, we don't need to use volatile.
You could remove the first MOV instruction and use an intermediate variable. This would allow you to pass the current value at array[i] via the constraint via EAX. Since EAX is now in its own input/output constraint (use +) we can remove it from the clobbers. The code could look like:

If the answer above is overly complex and you want to fix the immediate problems in your code then a minimal set of changes could look like:

We fix modifying the register containing digit by using another register to store 10 in to do the division. Modifying a register listed as just an input constraint may cause undefined behaviour if the optimizing compiler assumes the value of a register didn't change. It is imperative the compiler knows what has been changed.
Since our assembly template now modifies RAX, RDX, and RSI we must add them to the clobber list. They need to be in the clobber list if they don't have output constraints associated with them already.
We use the MOVL instruction to move a 4 byte integer from the array to EAX. When the destination register of an instruction is a 32-bit register the CPU automatically zero extends it to the upper 32-bits of the 64-bit register.
INCQ is changed to INCL to update the 4 byte memory address.


Notes: 

The ""cc"" clobber is effectively ignored by C / C++ when targeting x86 and x96-64 platforms. It isn't a bad idea to specify ""cc"" as a clobber if the template does clobber the flags, as is the case in this code. If anything it is a good habit to get into if you ever work on processors where the flags being modified have to be explicitly specified in the clobber list.
If an assembly template has no output (or input/output) constraints it is implicitly volatile and the volatile modifier is not needed.

",5,48854260
48826251,"
There is a good answer here on how to use std::sort
https://stackoverflow.com/a/1380496/6115571
On another note, you don't really need two return statements in your function there
",0,48825829
48797559,"
C++ doesn't automatically know how to perform a comparison on class Person.
If you just want to sort by age, try
If you want to learn about defining special operators so that ""Person <= Person"" will work automatically, check out cppreference.com: http://en.cppreference.com/w/cpp/language/operators
",5,48797496
48797562,"
You said you want to sort by age, so you need to compare their ages:
Your code gets an error because you haven't defined a <= operator for your Person class.
",3,48797496
48797593,"
In order to apply the <= operator for your Person object in C++ you will need to override the <= operator as described here
",0,48797496
48766460,"
One common way is to create an index and sort it, rather than sorting the original values. This is known as indirect sort or argsort.
Example:
Outputs:
",5,48764471
48766078,"

A and B have equal length, which is at least 4 and at most 20 (if that's helpful in any way).

Since you have both of them the same size you can store pointers to values of B in A eliminating O(n) time needed to rearrange B according to A. Method you would like to use is gonna cost you every time you would like to do sth. to A or B.

[...]which one is the most efficient, as I'm concerned with repeating that operation O(1M) times.
What's the most efficient (= fast + memory saving) way of doing this?

So we are looking for linear in-place algorithm for sorting ~20 floats?
Hard task.
I would recommend Block Sort for this kind of problem. It's a stable O(nlogn) time complexity and of course O(1) memory use.
Here you have it's implentation in C & C++ named: Wiki Sort. There is also nice comparison vs std::stable_sort() analysing algorithm behaviour with different data ordering.
",3,48764471
48776520,"
It's really hard to beat std::pair<float, float> with std::sort in this scenario and this is coming from one who has tried a lot:
... and can easily get something faster than std::sort (as well as tbb::sort which still takes over a second) except that's with an input size of 1 mil single-precision floats. Once you start talking about the input sizes you are talking about with 4-20 elements, it becomes extremely hard to beat std::sort. I've tried for an entire day with the most micro-tuned insertion sort spending an entire day on just that with endless vtune sessions only to just end up getting the same performance and giving up, and it wasn't the first time I tried to beat std::sort for teeny input sizes (it's so easy to beat std::sort for large input sizes which keeps tempting me over and over to try to also beat it for small inputs every year or two on a weekend as I improve my assembly and computer architecture knowledge, but seems impossible to me at least given my skills/lack thereof to beat it for teeny inputs). I've also sifted through all kinds of libraries for sorting numbers and they don't beat std::sort for small inputs either or mine for large inputs (I wouldn't be bothering to handroll my own numeric sorts for large inputs if I could just plug one in from elsewhere).
These other suggestions like indirect/algo sort tend to be quite excellent for non-trivial input sizes, but it's really tough to beat std::sort for trivial input sizes (and 4-24 32-bit elements is really trivial if you ask me). Probably the most micro-tuned insertion sort or heap sort or some other kind of quadratic complexity (O(N^2)) sort as your best bet, possibly with some kind of super fancy SIMD implementation or something like that. We shouldn't be thinking about algorithmic complexity at these kinds of teeny scales: mostly just machine instructions, and it might be more productive to think about how to parallelize the sorts and sort multiple teeny sequences at once instead of trying to make each individual sort go faster for such teeny, teeny inputs.
I've always been interested in faster sorts of floating-point numbers since they can improve the build times for certain K-d trees and BVHs used in raytracing and other areas which could save tremendous money for studios (studios like Pixar and ILM pour tons of money just on their render farms), but I've never been able to beat std::sort on input sizes with, say, less than 64 floats (<256 bytes). Again it's easy for me to beat it for thousands of elements or more, but it is already really fast (in ways that should make you content) for teeny inputs.
That said, the memory savings part is easy. Just sort in place (std::sort would be a start). Don't create any temporary array as needed for other sorts like, say, radix sort. Chances are that this will also be the fastest way to do it in this case for such teeny input sizes.
You might be able to get the tiniest boost using your own pair type:
... difference with std::pair in this scenario is that it doesn't bother to compare b. I doubt that would help much since the expression would be short-circuited, but maybe the optimizer might be able to do something a little bit more with that if it knows that b is not accessed in the comparator.
You'll definitely get a speed boost if you avoid using std::vector here to store each teeny sequence. It's not efficient to store a million vectors that only contain 4-20 elements each. That would require at least a million heap allocations as well as more memory used than needed for size/capacity/pointer container data. Instead store all 4-20 million elements in one std::vector instance, e.g., and sort ranges of it if you need to gather the teeny sequences in advance. If not, use the stack with std::array or just a plain old array of floats with an upper-bound size of 20.
",1,48764471
1840131,"
Most implementations of std::sort use quicksort, (or usually a hybrid algorithm like introsort, which combines quicksort, heapsort and insertion sort).
The only thing the standard requires is that std::sort somehow sort the data according to the specified ordering with a complexity of approximately O(N log(N)); it is not guaranteed to be stable.  Technically, introsort better meets the complexity requirement than quicksort, because quicksort has quadratic worst-case time.
",28,48713761
1840182,"
C++ Standard ISO/IEC 14882:2003

25.3.1.1 sort
1 Effects: Sorts the elements in the
  range [first, last). 
2 Complexity:
  Approximately N log N (where N == last
  - first) comparisons on the average. 

There is no information about method but complexity is always N log N.
",10,48713761
33141984,"
There are three algorithms that are used in MSVC2013 STL, referring to the source code of std::sort.

It is most likely to use QuickSort, or a variation over QuickSort called IntroSort.
If the recursion goes too deep, the HeapSort will be used here.
Otherwise InsertSort will be used.

",7,48713761
45998880,"
Probably all implementations of std::sort use introsort (aka introspection sort), a hybrid algorithm that combines quicksort and heapsort. Actually, introsort was particularly invented in 1997 for the purpose of a performant sort implemenation in C++ STL.
The only thing the standard requires is that std::sort somehow sort the data according to the specified ordering with a complexity of O(N log(N)); it is not guaranteed to be stable (there is a separate std::stable_sort algorithms available, if this should be required).
Technically, introsort better meets the complexity requirement than quicksort: This is because heapsort has guaranteed O(N log(N)) complexity in the worst case, whereas quicksort has quadratic worst-case time.
However, heapsort is 'slower' than quicksort in the average case, in the sense that heapsort performs C*N log(N) whereas quicksort has D*N log(n) performance, with D being significantly smaller than C (the numbers C and D are constants). In other words, the per-comparison-overhead of heapsort is higher than the one of quicksort.
To get the best of both worlds, introsort starts with quicksort —a recursive algorithm—, but when recursion depth gets too high (which means it gets into a degenerated worst-case behaviour), it switches to heapsort.
See also the Wikipedia entry for introsort or the original paper from David Musser, who invented introsort particularly for STL.
",4,48713761
1840142,"
Do you mean std::sort?  If so it can be implemented any way they want.  Its probably Quick sort but could be radix or something else.  As long as it produces you a sorted list in at least O(n log n) the implementation is fine, afaik.
",0,48713761
32230449,"
Just some empirical results:
I translated a python script using numpy 1.9.2 sort to C++ using std::sort (VS2008 toolchain).
I only get the same exact results in the python and C++ sides when I use numpy.sort argument kind='mergesort'. I get different relative ordering for elements with same key when kind='quicksort' or kind='heapsort'. So I guess that at least for the version of STL that comes with VS2008 std::sort uses mergesort.
",0,48713761
48700062,"
The name of the function is sorting.  The expression sorting(a, b) would call sorting and return a bool.  The sort routine std::sort will call sorting that way many times.
The name is not a good one. I would suggest percent_less_than rather than 'sorting'.  Furthermore, the parameterization is wrong. It compares the percent of students.
",3,48699979
48700426,"
Jive Dadson correctly responded to your question.
You can also use lambda syntax for sorting.
",1,48699979
48698402,"
First problem lies in length being a pointer. Make it just double instead of double *. double * will store it as an address. Just double will work fine. 
I think compiler should have given a warning on assigning double to double *.
For the above, change
to
Following condition should be
should be
Former condition will push video of longer length to the end. Here, we want to push shorter video to the end.
",1,48698339
50310830,"
I'd start by creating a term class along this general order:
Then you'll separate your equation into some number of terms, sort the terms, and then write the terms back out in sorted order (separated by +/- as appropriate, of course).
",1,50310711
50298264,"
assuming you use the map<int, vector<int>> you can do:
Afterwards you can sort the numbers in the vectors...
",1,50297949
50293784,"
Here I have used std::vector<> instead of array to store the sheeps. 
Secondly, using std::sort() and a lambda function, you can easily mention how you want to sort the elements in the std::vector<>/ Sheeps. That would be the easiest way to approach.
Here is the live code, in case of reviewing: https://www.ideone.com/ay7TWU
The output:
",5,50293494
50293976,"
The best is to solve your problem one by one.
First - define the sorting order - see doc about - e.g. in std::less
So, you need functor class that defines your sorting order:
Now, having defined the order  - just use std::sort - it can be used with arrays - no problem:
or:
You can also use std::tuple to make it easier to define sorting order (tuple has operator < by default if their elements have this operator too):
With tieMembersForSorting defined as free function - lambda could be used as well (as it will be just one liner):
",2,50293494
50293834,"
https://en.cppreference.com/w/cpp/algorithm/sort shows you how to use std::sort.
You write a function bool less_than(const Sheep& a, const Sheep& b) that represents the order of two sheep and then simply call std::sort(container.begin(), container.end(), less_than);, with container being something like a vector of Sheep.
Edit: The function written out:
",1,50293494
50293005,"
You can use vector of pairs to save your array with their index, then sort them based on the value, and return the biggest values as you want, like this
",0,50292741
50292833,"
You cannot find the indexes of the two largest values easily with the <algoritm>'s functions (unless of course you're OK with altering the array). You'd better roll your own.
You then will be able to call it with:
or better yet, with C++17 tuple unpacking:
Or for pre-C++17:
",0,50292741
50294182,"
It's easy to find the largest value in the array: just scan through it, and keep track of the largest value that you've seen so far. When you reach the end, that's the largest value.
Finding the second largest value is just as simple: when you do the scan for the largest value, if you find a value that's larger than the largest value you've seen so far, that's the new largest value, and the largest value that you've seen so far is now the second largest value.
In code:
I used <= for the comparison because with plain < (which is what I would use to find the largest value), the function would return a bad result for an array with all equal values.
",0,50292741
50272639,"
Look at the upper bound of your inner loop. Notice that we can have j equal to the size of the array for the last iteration. 
In C++, an array of size N has its elements indexed from 0 to N-1. In your case, you're trying to access an element past the end of the array, and are running into Undefined Behaviour. Ensure your index is within the bounds of the array. 
Secondly, you should be using std::vector over raw arrays wherever possible anyways. 
Third, the standard library provides the std::sort algorithm for you, which will almost always be faster than the bubble sort that you have implemented. 
",5,50272491
50272655,"
Your error is made in sort algorithm in the last iteration.
The thing is, that in first for loop variable i goes from 0 to listSize,
and in second for loop variable j goes from i+1 to listSize+1. When variable i reaches listSize-1, variable j will start from i+1 in the second for loop. This means j=listSize, and then when you try to access contactList[j] an error is going to occur because elements of contactList start from index 0 and end with index listSize-1.
this is how your code should look like:
",3,50272491
50271257,"
You have many bugs in your code.
First one i have noticed is in your while loop
Second one is that you are starting from index 1 and go to index 6 in your input loop (first for loop in code), but when you are trying to make some difference in your heap in third for loop you are starting from index 7 and you go to index 2.
I couldn't find a way in your code so i will post mine. It is following the algorithm in that wiki page you posted.
",0,50263013
50236382,"
Whever you access an element in a vector using [] you might get a seg fault.
This code, 
gives you an empty vector.
Asking for a[0] won't work if there's nothing in a yet.
Trying to set a[0] to a value won't work either. 
It doesn't exist.
Yet.
You have a similar problem in mergeSort when you use
These are also empty vectors.
You can use push_back (or even emplace_back) to add new elements.
Or use a constructor overload to state how many elements you want.
For example, 
gives you a vector of ten ints, so a[0] is fine to read from or write to.
a[11] isn't.
Practise using a vector first then try your merge sort.
",1,50235988
50236543,"
The reason for getting a segmentation fault is you access the location of the memory which does not exist (more accurate to say as not allocated). Say you have a vector of length 3 and you try to access 4th position, you get a segmentation fault.
As opposed to @doctorlove's answer, I would say it is possible to use []. However, you need the following implementation (only shown for main(), please implement with the same logic in the other functions). See the documentation of std::vector for more info.
Hope this helps. Cheers.
",0,50235988
50236854,"
here is the final code after changes:
",0,50235988
50233290,"
The first error message stems from the missing move assignment operator for ShapeDescriptor:
It also gives you a note why there is no implicit move assignment operator:
This means the class has const members, so the compiler cannot generate any assignment operator itself. Note that in order to sort a sequence, the compiler must swap the elements, and this requires the class to be move-assignable and move-constructible by default. You could also implement a swap function for ShapeDescriptors.
Your comparison is probably OK, but depending on the size of ShapeDescriptor it may be more efficient to take the arguments to be compared by const reference.
",2,50232941
50207486,"
Are you allowed to use all of C++ or are you really only allowed to use C with std::string and std::cout?
If you can use C++ here is how I would do it (still using a linked list since you specified that in your question - std::vector and std::sort would be more performant if you don't need to use a linked list):
",0,50206373
50193540,"
When you do vect.push_back(make_pair(name[i], score[i])); it creates new objects in array, there is no reference with std::string name[MAX]; and    int score[MAX];. So when you do input std::cin >> name[i] >> score[i]; you change name array and score array, your vector(vect) stays uninitialized.
You need to create temporary std::pair < std::string, int> pair_input; and push_back to vect it each iteration, like this:
Remove part of pushing back, where you were initializing your vector before:
because we will do push_back to vector each input operation. After all changes your code looks like:
While I was testing I got this output result:
",0,50193385
50185250,"
Use if (strcmpi(last[count2], mname)  < 0); for the comparison, instead of if (strcmp(last[count2], mname)  ==-1);
strcmpi() functions same as strcmp() but it is not case sensitive. 
Also add exit(1) if ifstream in fails to open.
",2,50185062
50185139,"
Convert all names to uppercase before storing.
",0,50185062
50157220,"
Somehow, putting the structure definition into the include file wound up causing an ambiguity in the templating.  I'm not sure how, but it was resolved by putting the structure (and boolean compare) into the definition of the class.
Not much of an answer...but problem solved.
",0,50156490
50152526,"
In idiomatic C++, an array arr of 5 ints is declared std::array<int, 5> arr; or std::vector<int> arr(5);. Swapping of values is std::swap. Functions should either alter their parameters and return void, or alter a copy and return that value.
You also don't loop through every element in your outer loop.
However, the easiest way to sort is to use <algorithm>'s std::sort, which takes a range as two Iterator parameters
",1,50152242
50152470,"
1) you can use c++ swap function instead using a temp variable
2) your for loops should look like this
The outer loop has to iterate through the whole array (from 0 to 4) and the inner has to iterate through the 'right side' of the array, because the left side is already sorted

so we can't pass array by value

https://stackoverflow.com/a/16137997/6521788
https://stackoverflow.com/a/16137995/6521788
You can just copy the values into a new array
",0,50152242
50152523,"
Basic answer: you cannot pass arrays by value in C++.
Solution 1: Make a copy of your C-style array before passing it to your function, and remove your return statement as it won't be needed.
Solution 2: Use std::array, which is a container which provides the same functionality as a basic array, and as a copy constructor and copy assignment operators.
Other remark: 
The STL does provide sort algorithms (std::sort), so in your future programmer's life do not implement sorting algorithms yourself, unless you do something really specific where performance matters.
",0,50152242
50158351,"
your question indicates that there might be quite a bit of confusion as to how one deals with pointers in C++. If my assumption is incorrect then just skip ahead(i will provide ""my solution""/correction at the end of this post).
To answer your first question: you can't pass C-style arrays per value in C++, nor by reference for that matter. Your only ""option"" would be looping through the pointer until '\n' is reached & store the contents in a new array created in your function.
which would be something along the lines of 
A couple of other things about pointers:
Pointer point to the first element in the memory pointed to & have no inherit size meaning
would not work inside your sort function(which could lead to problems if you dont know exactly how long the array you want to search is). a simple solution would be to pass the size of your array by value/reference to your function.
Another solution would be to loop through the array itself via something akin to
You can get a lot more information about pointers than i could ever give you by visiting the various tutorial sites out there. 
for example: https://www.tutorialspoint.com/cplusplus/cpp_pointers.htm
http://www.cplusplus.com/doc/tutorial/pointers/
But now back to your original question and hopefully an answer to it.
should be corrected to for(int i=0; i< 5-1; i++) 
the sorting function you are trying to implement is called bubblesort. for further information & how exactly bubblesort works please refer to https://de.wikipedia.org/wiki/Bubblesort 
should be corrected to for(int i=0; i< 5-1-i; i++) because the last elements are already in place.
should be corrected to if (arr[j]< arr[j+1]) because you want to compare(for example) the first element & the next element to get it in descending/ascending order. this gets done for every number pair in your array.
and finally:
should look something along the lines of: 
please note that you can also reformat it to:
as an example: if arr[j] = 5 and arr[j+1] = 6 then you store the value j+1(6) in temp, overwrite arr[j+1] with j(5) and lastly store 6 at j to get descending order(hope i got that right now, but you get the gist)
lastly; as others have correctly pointed out already, you can use std::swap instead of using key/temp variables.
",0,50152242
50106878,"
A vector of tuple can be sorted using nothing but STL if you want.
This is the example from here just modified with your values.  
How it works is a new tuple is constructed with emplace_back and added to the end of the vector.  You could use push_back(std::make_tuple(... if you want but that seems overly complicated.  Then you sort the vector as you would any other vector.  The default behavior of sort is ascending.  You can change the behavior of sort by adding you own comp.  The arguments of your comparing function will be 2 tuples.  The return type is the boolean result of your comparison.  Since tuples have all the comparisons (<,>, <=,etc) already, you don't need to redefine them.  You can use this to compare dissimilar things as well, it just gets more complicated.
And this will sort the vector in descending order.  You can replace myFunction with a lambda as well.
",3,50105690
50106549,"
I propose two solutions: the first using a custom structure using a custom < operator that uses std::tie to compare the three integers in order, and the second using std::tuple.
Output
I recommend you to read the std::sort documentation.
",1,50105690
50104768,"
The std::sort function expects you† to give it a function that tells it how to sort a range in ascending order, so by default it'll use something like std::less<int>().
By providing a function with the opposite effect (i.e. std::greater<int>()) you are turning that expectation literally on its head, resulting in a completely legal ""mirror-image"" of the default behaviour. That is, a reverse sort.
A different way of explaining it is that, at each step of its algorithm, when it wants to know whether one element A should go ""before"" another element B, it will ask std::greater<int>(), which will tell it: yes, one element A should go ""before"" another element B if A > B, and there you go.
This is contrary to the default behaviour which uses something like < instead:
† Of course, you can actually give it a function that defines any other order you like (subject to certain constraints), so there are plenty more options. Here I explore only the two most obvious sorting methodologies.
",2,50104725
50104810,"
The third argument to std::sort is a functor/function that returns true if the first argument is to be placed before the second element in the sort order.
std::greater<int>::operator()(...) returns true if the first argument is greater than the second argument.
Consequently, use of std::greater<int>() as the third argument to std::sort results in the collection of objects to be sorted in descending order.
",2,50104725
50104982,"
The documentation for std::sort (here amongst other places) says things like

Sorts the elements in the range [first, last) in ascending order.

This is a convenient simplification, but it's confusing when you don't want ascending order.
It's more useful to think that sort rearranges your range according so some function - let's call it pre - which says for any pair of elements, which one should come before (precede) the other.
That is, the function looks something like
The default behaviour, if you don't specify something else, is to use std::less, which will do roughly this:
and this default (where the smaller value always precedes the larger) gives you a result sorted in ascending order.
If you specify std::greater, you're saying the larger value should always precede the smaller (because if greater(a,b)==true, that means both that a>b and also that a will precede b in the output).
So, this is the same as saying the result is sorted in descending order.

NB. I called the comparison pre both because it tells you which elements should precede which, and also because it is a predicate (specifically a BinaryPredicate and even more specifically a Comparison).
",1,50104725
50090850,"
By choosing the first element of the array as the pivot, you hit the quicksort worst-case behavior when the array is already sorted.  So you get O(n2) behavior (and worse, O(n) stack space, which probably gives you a stack overflow).
To avoid that, choose a different pivot.  Normally one would choose the middle element as the pivot:
or a random element:
",2,50090491
50069452,"
Until C++11, the complexity is N.log(N) on average, and the worst case complexity depends on your standard library implementation. For later versions of the language, the standard requires the complexity to be exactly N.log(N).
From https://en.cppreference.com/w/cpp/algorithm/sort:

Complexity
O(N·log(N)), where N = std::distance(first, last) comparisons on average. (until C++11)
  O(N·log(N)), where N = std::distance(first, last) comparisons. (since C++11)

",3,50069329
50069429,"
Use std::sort with std::greater like this:
In your case it would be:
For your CStudent override operator > as like this:
Then call sort with lambda:
",1,50069263
50053353,"
The reason it doesn't work is because you are making modifications only to local variables (first and second) which are copies of values from the list.  You are not modifying the actual content of the list at all.
To make the code work, simply change your first and second variables into list iterators, and then dereference them whenever you want to access their values, eg:
For that matter, i can be replaced with an iterator, as well:
",0,50053290
50032433,"
You're incrementing index twice.
So you're only checking every other element of the array.
Get rid of the second index++; line.
",1,50032373
50032422,"
There is at least one logical error. index is being incremented twice per iteration of your inner loop.
",0,50032373
50001187,"
Before line 
there is unnecesary closing bracket. (sort is outside function body)
",0,49987578
50005684,"
this source is ok
thanks
",-1,49987578
49986518,"
Welcome to C++.  Since you want to list numbers by rank, read them as int not string. Forget about operator new. You will not need it for years, if ever. Use standard containers like std::vector, which take care of the memory allocation and de-allocation transparently.
",3,49982613
49983144,"
How about something like:
If you need to, you can convert the integers back into strings using targetStrings[i] = std::to_string(scoresInteger[i]).
Don't forget to delete [] targetScores later.
",0,49982613
49984890,"

My question now is why this is happening?

Because your scores are compared as strings and not as ints. Because of that ""3"" is greater that ""25""
Luckily you can pass a custom comparator (or lambda) to the std::sort to make it behave just as you want:
The compared strings in the above example are converted to ints and then compared, resulting in the desired sorting order.
Please note that I do not agree with the rest of your code and I think you should rethink the implementation, as it would be much easier, safer and more efficient to use std::vector<std::string> for your task.
",0,49982613
49955486,"
What's this? Why should the binary predicate look like this?
The predicate's parameter should have the type that key_type can convert to implicitly
And you shouldn't apply std::sort to std::map. One reason is this operation is redundant(see the reference below), another is the keys have const type.
http://en.cppreference.com/w/cpp/container/map
And another advice:
declare the predicate's parameter type as a reference to const
",0,49955374
49886378,"
You should use methods from standard template library(STL) in algorithm modules. There is a good method std::sort which can help you. You pass container data to it and the third parameter can accept the way to sort given container. Here you can use functional objects from functional module in STL. You need to look at std::less<> and std::greater<>. They will sort your array by ascending or descending. Also you can pass your own function to sort the way you need.
There is a useful method std::reverse, you can reverse order of your elements in container. For example if you need to sort in ascending and descending then you can sort by ascending at first and then call std::reverse to get descending result.
Short example with default init array data:
If you want me to show it in your code, then it looks like this:
And the result is:
May be you don't need tabp tabw arrays at all? Don't understand exactly their necessary, you can sort with a help of STL after input data with tab array, like this
",0,49886003
49855603,"
std::sort (and all standard library algorithms) expects a half-open range. The end iterator is a one-past end indicator (the open part). So [it, it + 1) is a range of just one element. In your case, it's just the first vector element.
And well, a one element range is already sorted.
",6,49855541
49855624,"
This range v.begin(),v.begin()+1 that can be mathematically written like [v.begin(), v.begin() + 1 ) contains only one element v[0] that is equal to 2. If you want to sort a range of 2 elements then you should write
that is equivalent to
",2,49855541
49855678,"
In order to sort first n elements you must indicate you call as follows:
Thus for 2 elements you must call:
This is because all STL algorithms takes open range [first, last).
",1,49855541
49855600,"
from std::sort
In case you are not familiar with the notation, ) means last is not included, you can find more information about that in this question.
",1,49855541
49850616,"
Here's one major problem:
First you make ary_ point to the same memory as newarr is pointing. You now have two pointers pointing to the same memory.
Then you free the memory that both pointers are pointing to.
If you attempt to dereference ary_ after that you will have undefined behavior.
Another problem is this:
Since ary_ is a pointer (I assume since you don't show us a Minimal, Complete, and Verifiable Example) then sizeof(ary_) gives you the size of the pointer and not what it points to.
You can easily solve both problems by stop using pointers and your own manual memory management, and instead use std::vector.
",3,49850517
49850749,"
For starters this using of the new operator
is wrong. The expression sizeof(ary_) is equal to the size of pointer that is usually either to 4 or 8 bytes depending on the used system. 
The same problem exists relative to the condition in the for statement
These statements
have a logical error.
I think you mean
Also it is unclear why the initial value of newcount is set to 1 instead of 0.
This call
can invoke undefined behavior.
And it is totally unclear what the function grow does. This makes the code confusing.
",1,49850517
49839897,"
Since you sort counties independently from states_array the sequence of both containers won't match. One possibility to solve is using
sort that with std::sort and output this within a loop
Next time please add a main function with example domain code (i.e. state and county objects) so people who would like to help can debug right away. Furthermore an explanation to the task is required. And welcome to SO!
",0,49839609
49839853,"
I'm not sure if I understand your problem correctly but I think std::multimap can help you here, Something like this :
I think this way your complexity would be O(nlog n) 
",0,49839609
49839828,"
I guess what you are trying to achieve is to print out names of counties sorted by their population.
First problem is in if(counties[] == states_array[i].c[j].population). You are not indexing any element in counties (counties[]). Therefore you can't compare this with int value you get from states_array[i].c[j].population. 
To fix this you have to enwrap the last loop in one more loop iterating over sorted counties:

Even though this idea is correct (only if each county has different population), this approach is very slow (sorting has a complexity of O(nlogn) + matching counties by population has complexity O(n^2), where n is the total number of counties). To make it faster you can make new vector<county>. Put all counties from all the states into this vector, sort it with respect to their population and print the names of sorted counties. To sort with respect to the population you have to use your own compare function. You can find more here: http://www.cplusplus.com/reference/algorithm/sort/ 
Edit: 
To have a correct program even in the case when two counties have the same population you should put all counties in the vector of counties and sort them.
",0,49839609
49838493,"
It seems to me that your algorithm is wrong. Try making a few examples and run them by hand.
Try this code instead:
This solution uses std::sort so complexity is O(n log n). But since you are only sorting the names by their first character, it can be optimized down to O(n) using counting sort.
",0,49838375
49835317,"
According to the documentation on cppreference, the comparator function requires a type signature like so:

bool cmp(const Type1 &a, const Type2 &b);
The types Type1 and Type2 must be such that an object of type RandomIt can be dereferenced and then implicitly converted to both of them. ​

The RandomIt iterators correspond to the top_k structure which when dereferenced has type pair <vector<string>, int>, while std::greater<int> has comparison function of bool operator()( const int& lhs, const int& rhs ). In other words, this does not work because pair <vector<string>, int> does not convert to int.
One solution is to provide your own comparator:
",1,49834979
49780314,"
You will need to use a custom compare function/functor to help you with that.
and use:
You'll also have to fix the code that prints the contents of foo.
",5,49780192
49780381,"
You initialized iter in your inner for loop: 
for ( iter = foo.begin() ; iter != foo.end() ; ++iter )
However, you try to access in the outer for loop where it points to nothing: 
for ( int i = 0 ; i < iter->first.size() ; ++i )
",2,49780192
49765523,"
You're doing an integer division and passing the result to ceil().  Hence, the ceil() call has no effect.
Try something like this instead:

That will not solve your real problem, though.  There are several errors in your algorithm.  Going with the implementation in Wikipedia this part:
should be something like this:
This part :
should be :
This :
should be :
and this :
should be:
You should note that mid is not the index of the middle element.  It is a size that you add to low or subtract from high.  It may be smaller than low.  Hence, the name mid is misleading.

Stitching it all together you get this:
",2,49765222
49762130,"
Your code seems to have a logic error in your inner while loop. You test s.top() before you test for s.empty(), which is the wrong order. s.top() is invalid if s.empty() is true. However, the exercise can be resolved relatively easily as described below.
You can retrieve the underlying container of a container adapter using the following helper:
Then, after populating the queue, you can copy the contents directly to the stack's underlying container, and sort it.
",1,49761880
49764001,"
You have to do what is essentially a selection sort: go through the queue N times, each time selecting the largest element to push onto the stack. The general idea is:
",0,49761880
49760406,"
It's probably a weakness of your library's std::less<std::wstring> (which is the default comparator for std::sort()).  For comparison, I made a portable version of your test:
Compiling with GCC 8, -O3 -march=native on Linux on an Intel i7-6700, I get best results with native or std::wmemcmp() and worst with std::wcscmp():
default  round 1: 1734.87
wcscmp round 1: 2315.48
wmemcmp round 1: 1699.22
default  round 2: 1727.92
wcscmp round 2: 2305.81
wmemcmp round 2: 1635.28
default  round 3: 1719.26
wcscmp round 3: 2286.19
wmemcmp round 3: 1638.17

",1,49752748
49726869,"
Check whether your library is using SSO (Small String Optimization) for the string implementation. 
If so,  the increased locality of reference can easily explain the difference. It also explains that the difference goes away when the strings get too large to benefit from SSO
Proof Of Concept: killSSO
Runing this benchmark with the killSSO line commented out prints: Live On Coliru
Uncommenting the line std::for_each(c.begin(), c.end(), kill_SSO{}); prints: Live On Coliru
Nonius Benchmarks
Using the Nonius micro-benchmark framework we get:
The results Interactive On Plot.ly

",4,49723522
49717531,"
Quick Answer: A left-value is something you can modify. Something that occupies a certain amount of memory. A right-value is something temporary, e.g. instant number, normal return value of a function, etc.
Your error cannot convert from 'float' to 'float &' is to pass a right-value  float to a function which takes a left-value reference (float&). That means your function will presumably change the parameter it takes. But right-value has no address, hence cannot be changed. That's why the compiler is refusing your codes.
Another glitch is that the sort function in your code should be outside the for loop.
",0,49717410
49719433,"
I found a couple of issues in your program:
1) Some simplification is required. You need not set the vehicle name if it is integrated with the constructor.
2) The total_distance member variable could be initialize to zero in the class definition itself.
3)You were trying to sort the vehicles before the total_distance for each vehicle was set. 
4) Use auto keyword to replace long type-names.
Try this ( I am using a dummy distance generator as your grid logic is not so clear):
",0,49717410
49705788,"

Regarding the printing of the first line, it might be that the first element, i.e. P_data[0] is wrongfully initialized (perhaps to random values) which would make the element have a random int as date and an empty string as exchange.
The error you're receiving is when giving binary_search(http://www.cplusplus.com/reference/algorithm/binary_search/) a value of 20140212 instead of a Data object which contains that date (I'm guessing you want to find the object which this date.

You should modify your search code to:
// Create a temp variable which target date
Data tmp;
tmp.date = 20140212;

// Search for it
bool yes = binary_search(P_data.begin()+1, P_data.end(), &tmp, comp2);

Also, you might want to consider changing date property to unsigned to avoid weird negative values.
",0,49705479
49705562,"
Can you please post ALL of your code?
Currently your structure's pointer isn't memory allocated, and we can't get the same result as you without all your code.

the error message show that
bool(const Data*, const Data*) can't convert arg1 'const int' to 'const Data*'

should appear cause you may pass an 'const int' instead of a 'const Data *' to your function.
",-1,49705479
49694858,"
You can customize the way the keys in set/map (and their multi variants) are sorted using a template parameter. This template parameter is not always given, because it has defaults. It is only required if there is not default sorting order or that order isn't right for the use case. However, this is also what you need to look at: It's the template parameter default and what that default means for pairs which determines how they are sorted.
Long story short, a lexical comparison is used, comparing the first and then the second element. Of course, this again used defaults, because the first half of a pair can be a pair itself etc.
",1,49694784
49695019,"
The template class std::pair has already the defined operator <. So you can sort containers that contain objects of the type std::pair.
From the C++ Standard (20.3.3 Specialized algorithms)

2 Returns: x.first < y.first || (!(y.first < x.first) && x.second <
  y.second).

Also you can consider two objects as members of an object of the type std::pair using function std::tie.
Here is a demonstrative program
Its output is
",3,49694784
49697612,"
As commented by Amdt Jonasson, the program needs to keep track of the run sizes and the end of data for each file. In your example it appears the initial run size is a fixed run size of 3 elements. A merge of two runs of size 3 will result in a single run of size 6 as shown in your steps. In this case, only a single instance of run size and the end of data in each file needs to be tracked.
If the sort is to be a stable sort (the original order preserved on equal keys), and the run size is variable, then an array of run counts for each file will be needed, or some way to denote the end of runs in the file, such as a text file, with a special character sequence used as a end of run indicator.
If the sort is not required to be stable, then an out of order sequence (smaller key value after a larger key value) can be used to indicate the end of a run. The risk here is that two or more runs will appear to be a single run if the runs happen to be in order, which will lose stability and unbalance the run count on the files.
This is a two way merge sort using 3 files. If you use a 4th file, then each merge of runs can alternate between 2 output files, eliminating the need split up the runs after each merge pass.
An alternative for doing a 2 way merge sort with 3 files is a polyphase merge sort, but it's complicated, probably beyond what would be expected for a class assignment, and more of a ""legacy"" algorithm used back in the days of tape based sorts.
",0,49693970
49679103,"
This is done for consistency with iterator semantics in all containers of the Standard C++ Library: begin() is always inclusive, while end() is always exclusive, because it ""points"" to the position immediately after the end of the container.
This is consistent with the behavior of pointers to array elements:
",4,49679038
49679741,"
Defining ranges this way makes it easy to work with sub-ranges. Here's a silly example:
There are two important points here. First, detecting an empty range is simple: begin == end. Second, splitting into two ranges is equally simple. Just generate a middle point mid and use it as the end of each range: [begin, mid) and [mid, end) are two ranges that cover all the elements in the first range.
Now try writing code that does the same thing but uses either double-inclusive or double-exclusive ranges. Contrast and compare.
",1,49679038
49679955,"

Why is the C++ sort range [first, last)?

This is true for all iterator ranges, so I guess you're asking why are iterator ranges represented as [first, last) in general.
To answer (or rather, respond to) the question: Why not? Do you think that there is a better alternative? What is that alternative?
Let's assume that you would like to represent a range as [first, last]. This is how iterators would need to be treated:

Represent range with length 1. Let it be iterator:
[first, last] has a more compact representation for single value. I can see why this would seem nice. But + 1 has a clear connection to the length of the range, which is nice too.

Represent range of length n:
Here's where the connection to the length shows its greatness. [first, last) is simpler.

Represent empty range:
This is really a big problem. [first, last] needs two different iterator values to represent an empty range. Consider a vector for example. You would need to use iterator to before first value, and iterator to after last value to represent it (since there are no values to point to).
",1,49679038
49669928,"
Here, the second leftIterator should be rightIterator.
",1,49669837
49653453,"
You can create a new array or vector of std::reference_wrapper and then std::sort that container to get a sorted ""view"" of the original array.
For example:
",0,49653214
49650220,"
Do it like this:
std::begin and std::end are free functions that, by default, just return x.begin()/x.end(), respectively, thus they work with standard containers - std::list, std::vector, std::array, etc. These functions are also specialized for plain old C arrays, enabling the aforementioned code.
You could also throw pointers directly into std::sort, since pointers are iterators:
However, this requires you to specify the size of the array (which can be done automatically, though), and breaks as soon as you change myArray to be, say, an std::vector.
Note that std::sort uses std::less if you don't specify the comparator, meaning that it sorts in ascending order by default. If you need descending order, you can specify std::greater instead:
",6,49650087
49642963,"
You can use std::stoi to compare integers not strings:
You might actually want to store ID as integer, not string.
If you ID can be, say ""123AB"", then you can extract number with:
",1,49642889
49607602,"
The problem is in the function that is trying to sort


std::sort() relies on the first two arguments being non-const iterators - i.e. that can be used to change the values they refer to.   It is, after all, rather tough to sort a container if the elements cannot be reassigned.
foods is a const reference to a FoodVector  (aka std::vector<std::shared_ptr<Food> >)  so the begin() and end() functions are const, and return a type std::vector<std::shared_ptr<Food> >::const_iterator.    That does not meet requirements of std::sort().
To fix the problem, either

remove the const qualifier from the first argument of the function greedy_max_protein().  Be aware this means that the function may change the elements of the passed FoodVector, and the caller will not be able to pass a const FoodVector;
Create a copy locally in the function and sort that.   This is appropriate if the working of the function needs a sorted vector, but the caller requires that the passed vector remains unchanged.

",1,49606934
49607598,"
I chopped down and isolated the problem.
Before removing the ""const"" I got the same error you were getting.
But this compiles.
",0,49606934
51252998,"
Assumptions:
I will assume the list of numbers is already in binary form (because we will need multiple passes through the data, and each time converting text to binary would take extra processing time). That would be a file of 1GB (125M * 64bit).
It is also not clear if the OS disk caching of that file would count for the memory limit. I will assume it's not, because reading a 1GB file cold from disk multiple times would already take more than 5 seconds.
Solution:
So let's start with a simple example of how this could be done (we will optimize and adjust this later):

First create a histogram of ranges of numbers (say groups of 1 million as an example, but this won't work yet - see below)
So create an uint32 array of size max value / 1 million (too big for now) where we will put the count of the buckets (0-999999, 1000000-1999999, and so on).
Loop through the list of numbers and each time increment the n-th value of the array (the bucket where the number belongs).
Now that we have an array with counts we can easily calculate in which bucket (or range) the median will be.
Loop through the list again and now only store the numbers that fit in that range in an array.
Sort the array and calculate which item is the median (also using the counts of all buckets).

Of course, we need to adjust the above a bit.
First, instead of using ranges of 1 million, it's better to use a power of two. That way we can simply use an and with a mask to get the position in the bucket/count list (instead of using a more expensive division).
Second, for using buckets with ranges of 1 million we would have to create an array that is way too big.
So the best option would be to do 3 passes: first with ranges of say 1e12, and then for the range the median is in, we loop again with ranges of 1e6 (but instead use powers of 2).
This way you would only have to sort the numbers belonging to one small bucket instead of the whole set of 125 million. Sorting takes O(n log n).

An example with the numbers given in the question:
Use buckets/ranges of 16 - first pass:
We can now calculate that the median must be in the bucket at array_pos 1.
Second pass - read values for bucket (16-31) - (again, if the bucket sizes are a power of two we can use some bitmasking to quickly check if the number is in the range):
Sort this small array and calculate the position of the median using the 2 counts (before and after).
",2,51251035
51252785,"
What you really need is a divide and conquer algorithm for such kinds of problems.
Have a look at External merge sort and distribution sort sections in External Sorting
The idea is to sort data in to multiple chunks and then merge those chunks again using divide and conquer approach.
It has a time complexity of O(n logn), which I think will pass the time limit.
These algorithms are quite famous and you can just google to get the implementation details.
",1,51251035
51255211,"
In my first answer I gave a solution to find the median in a list or set of binary numbers (with memory restriction), without having to sort the whole set.
Just for fun, let's look at a solution where the file contains numbers as text separated by a newline, and let's do it without converting the text to binary numbers (which can be expensive, and we can't hold them in memory).
Again, we'll use buckets (or bucket counts) but we start with grouping by number of digits.
Sample set:
First pass - group by number of digits (array_pos is number of digits this time):
So, the median must have 5 digits (before: 3 - after:4).
Second pass - (assuming all 5 digit numbers wouldn't fit in the 20MB), read all 5 digit numbers and group (count) them by the first digit (or first 2, 3 or 4, depending on the count):
(Actually this second pass could as well be done within the first pass because the arrays will be small in this case (depending on the number of digits we group on). We would just have to create an array for each 'number of digits').
Locate the group containing the median:
Last pass - read all 5 digit numbers having 5 as the first digit, sort them (can be alphabetically, still no need for conversion) and locate the median (again, we only have to sort a small subset of the data).
In the small example above there's only one, but we still have to get it in the file since we didn't store the results due to memory restrictions.
For performance reasons, functions like readline() or streaming should be avoided here - instead the file should be opened in binary mode. This way we can loop directly over the bytes and just reset the digit count when a newline is encountered.
Even better would be to use memory mapping, but I guess that would be cheating in this case (20GB limit).
",1,51251035
51254903,"
You can try median of medians algorithm.It is an in-place algorithm that has a time complexity of O(n).1.Read here2.
Wikipedia Article
",0,51251035
51229135,"

Can I have delcaration like vector < pair <int ,vector < int >> > vec in C++?

Yes, you can. Nothing wrong in this.
Regarding accessing the elements in the value-array, here,
You have for each key associated with a vector array. Accessing an array element with operator[] would be array[array_index] (or using a range based for loop or an iterator loop)
This is the second of the std::par. i,e. .second[array_index].
Since you have an array of above mentioned: vec[index_pair_array].second[array_index] would be the appropriate way of accessing each element in this 2D array.
Then you need this:
",0,51229027
51228168,"

Is there a way to make that without making any copy

This example of sorting 3 arrays according to one of the arrays, using a 4th generated array of indices that are sorted according to one of the 3 arrays may help. The key part of this is the in place reordering of all 4 arrays according to the array of indices. You'll need to modify this for your situation. I'm not sure why you are converting the array of indices to an array of numeric strings (via the itoa calls), using the indices directly works better for the example in this answer.
",1,51207436
51207495,"
While refering to standard is fine, understanding it can sometimes be quite hard...
Trying in simpler words:
If you want to sort elements, you need some kind of order relation that defines which of two elements shall come first (""be the smaller one""). Some data types come with a natural order, such as integral numbers, for instance: -12 < -10 - 0 - 10 < 12. std::sort (without comparison parameter) uses this natural order to sort elements ascending.
The third parameter gives you the possibility to tell std::sort explicitly how this order shall be defined, imagine the following:
Looks unnatural, doesn't it? std::sort interprets the comparison as ""less"", but we implemented a ""greater""! By doing so, the greater values then (as considered being ""smaller"") are sorted in front of smaller ones (considered being ""greater""), so we have achieved sorting in descending order...
So the comparison parameter passed to std::sort is used to either sort differently to what the natural order would be or to define explicitly an order for data types where such order does not exist.
Side note: The order relation does not necessarily have to be a total order; however, equivalent elements then can be sorted in arbitrary order (you could, though, use std::stable_sort instead to at least preserve their relative order before sorting):
",1,51206782
51206840,"
When in doubt, read the reference.
comp -

comparison function object (i.e. an object that satisfies the requirements of Compare) which returns ​true if the first argument is less than (i.e. is ordered before) the second.
The signature of the comparison function should be equivalent to the following:
bool cmp(const Type1 &a, const Type2 &b);
The signature does not need to have const &, but the function object must not modify the objects passed to it.
  The types Type1 and Type2 must be such that an object of type RandomIt can be dereferenced and then implicitly converted to both of them. ​ 

",5,51206782
51176872,"
Use a lambda to capture this:
",1,51176716
51178028,"

Why is the call to my function wrong? I have used the sort() function
  before, but not to strings. Is my 'helper()' function incorrect?

Because helper is member function of Solution. When you do this
you are basically doing this
The 3rd parameter to sort needs to be a standalone function, a predicate, a functor or a lambda. It cannnot be a non-static member of a class
This code, cleaned up, works. Note the statics
",0,51176716
51187832,"
Member functions have a hidden parameter that becomes this. You need either expose the state more widely, or write a capturing lambda
Also a Compare predicate must return false if you are comparing a value to itself, yours does not.
",0,51176716
51134951,"
Arrange the second set such that it is ordered in the same way as the first set.
More specifically, the first set goes from the greatest number (57.5276) to the second greatest number (55.3756) to the fourth greatest to the third greatest.
Arrange the second set in the same way. Greatest (57.1398), second greatest (55.004), fourth greatest (24.824), third greatest (57.1398) in that order. This would minimize the average difference between items of the same index.
Programatically a simple way to implement this would be to sort both sets, then to find the sorted index of each number in the first set and arrange the second set in that same order. 
",0,51134695
51135237,"
Matching ""closest"" should be specified a little better. That could be, e.g., ""minimum squared error"", ""minimum absolute error"", ""maximum correlation"", which all would give different results.
Depending on what is meant with ""closest"", you may have to go through all permutations of set2, which would be expensive. If you want to go with the ""sort both sets"" solution, then a possible way to achieve this in c++ while retaining the order of the first set is to create a vector of indices into set1 and sorting this based on the values in set1
You can then sort set2 and use the indices to recreate the order of set1 with the values of set2.
",0,51134695
50597785,"
Your assertions are incorrect on two counts:

std::sort is not guaranteed to preserve the order of elements that don't need sorting, if you get my meaning.
The behaviour of your comp function is undefined as it doesn't have an explicit return value on all control paths.

One remedy is to use std::stable_sort which will preserve the order of elements as best it can. The comparator function can be adjusted such that it's true if the first argument is negative and the second is positive (let's define 0 to be positive):
Another remedy is to use std::stable_partition.
",7,51127406
50603690,"

But I am unable to understand how it is working, Could someone explain ?

I try to explain how it's supposed to work, but actually, it does not work :)
This code tries to compare signs: checking whether sign of a is ""less"" than sign of b. Assuming that negative is ""less"" than positive. So, sign of -1 is less than sign of 1, and sign of -3 is not less than sign of -1. 
The problem here is that comparator should always conform with https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings. 
In short, strict weak ordering is: for any a and b, only one condition is true: a < b, or b < a, or b == a. There should be no case when more of one condition is true. 
When strict weak ordering is violated in production code, very bad things will happen: overtimes, failed deadlines, and even worse. 
Your sort() will fail on this array: { 1, 0, 2, 0, -3, 0,-1 } because strict weak ordering is violated: both comp(-1, 0) is true and comp(0, -1) is true. 
",0,51127406
51101850,"
I would say that this is a (reinvented perhaps) version of insertion sort. 
See this:
Insertion Sort on Wikipedia
",3,51101745
51118996,"
Your code is kind of like this in a long fashion
Doing an inplace insertion sort, which is O(N²).
Now lets look at your contribution
So is it worth it we are gaining the cost of std::upper_bound which is log N, each time the if's are correct, so 2 if's cost where its not the case. So on a randomly ordered list the cases where the if's help us will rapidly diminish as it would be 1/n for each, in the case of a nearly sorted list or a nearly reverse sorted list you would win some, but in all other case its just a waste of time.
",0,51101745
51087123,"
As others have mentioned it's not directly possible to sort map using the values. 
One way to sort the map using values is as follows.

Create a vector with map elements as a pair. ie, pair<Value, Key>. In your case this would be vector< pair<double, pair<int, int> > > 
Sort the vector (using a custom sort function), now you have your elements sorted by values.

See the following example. (compiled with -std=c++11 option)
Output
",0,51085004
51086699,"
You have just to write a custom comparator. Here you must build a full object because you will want to compare keys according to their value in a specific map. This should meet your requirements:
You can use it to build a specially ordered map from an original map:
You can iterate val_sorted, it is sorted by its values
Beware: never insert in val_sorted and element that would not exist in valore. The correct way to use it is to create one new instance each time the original map could have changed, or at least empty it and reload it again.
",1,51085004
51087553,"
As the below map contains first argument as pair of integers and second argument as double, it is not possible to sort based on first argument (pair of integers).
A custom function needs to be written for sorting based on the co-ordinates.
",0,51085004
51079361,"
With range-v3, you may do:
Demo
",0,51076958
51067058,"
Using a vector is unnecessary here. Determining whether a tree is a binary search tree does not require any extra memory apart from the stack for the recursive calls.
If you define a separate inorder tree traversal algorithm that makes the implementation almost trivial:

To convert a tree into a vector using inorder traversal you can use the following function:
",0,51066214
51051727,"
Consider using Boost.Multiprecision instead. Specifically, the cpp_int type, which is a representation of an arbitrary-sized integer value.
Theoretically this should work with the properly sized type uint512_t, found in the same namespace as cpp_int, but I don't have a C++ compiler to test with right now, so I can't verify. If it does work, you should prefer uint512_t, since it'll probably be faster than an arbitrarily-sized integer.
",2,51051579
51122118,"
If you just need multiplying with / dividing by two (2) then you can simply shift the bits in each byte that makes up the value.
So for multiplication you start at the left (I'm assuming big endian here). Then you take the most significant bit of the byte and store it in a temp var (a possible carry bit). Then you shift the other bits to the left. The stored bit will be the least significant bit of the next byte, after shifting. Repeat this until you processed all bytes. You may be left with a single carry bit which you can toss away if you're performing operations modulo 2^512 (64 bytes).
Division is similar, but you start at the right and you carry the least significant bit of each byte. If you remove the rightmost bit then you calculate the ""floor"" of the calculation (i.e. three divided by two will be one, not one-and-a-half or two).

This is useful if

you don't want to copy the bytes or
if you just need bit operations otherwise and you don't want to include a multi-precision / big integer library.

Using a big integer library would be recommended for maintainability.
",1,51051579
51049016,"
Because a queue doesn't provide iterators you can't use: is_sorted
Thus comparison would require copying the queue or sequentially pop'ing and comparing elements of the queue, then push'ing them back onto the queue. I've chosen to simply copy the queue for this example:
This example clearly incurs the cost of copying the queue which is clearly undesirable. This cost is incurred because a queue is the wrong tool for the job. Consider priority_queue or just a vector.
",2,51046932
51017627,"

It really hard to understand desirable order in this method. But I will try. You use


so I assume that pr should be before value in case value>=*pr. That means descending order, from max to min.

You want descending order. Then you need position when previous was bigger or equals and current element is less then value. So skip all until this position found and then insert.


And for ascending order - skip all until first that bigger and then insert:

You don't need to check ""if (value<0)"" - I think your logical mistake was made at this step. Also you don't need to check
in else-statement after
this is too much checking and can cause many mistakes... 

",1,51017063
51034598,"
I'm fairly certain, based on the hints you've given in your comments, this is what you want.  It doesn't need to treat the empty list or negative numbers special.  And if value doesn't get inserted within the for loop, it's assumed to be at the end.
This will reliably insert elements in descending order without having any special need to treat negative numbers special.
",1,51017063
51011585,"
This appears to be the original article
https://www.geeksforgeeks.org/rearrange-positive-negative-numbers-using-inbuilt-sort-function/
How it (sort of) works:  std::sort rearranges everything according to a comparitor. This comparitor is based on ""all negative numbers are exactly equal to each other. All positive numbers are exactly equal to each other. Negative numbers are smaller than positive numbers."" 
If you sort according to those rules, you are going to get all the negative numbers then all the positive numbers. The comparitor itself does not mess with their order, beyond looking at whether they are greater or less than zero. (And the data set conveniently doesn't have any zeroes.)
What's wrong:
1) The comparison function does not correctly handle 0. It gives wrong answers, and even worse, it gives answers which violate strict weak ordering. (see below)
2) std::sort is not a stable sort. It is not guaranteed to preserve order. They got lucky on one data set. If they had used std::stable_sort, and a correct comparison function, it would have been a ""built in function"" which met the requirements. But the comparison function alone can't make an algorithm stable. See What is the difference between std::sort and std::stable_sort? or just look near the top of the docs on http://www.cplusplus.com/reference/algorithm/sort/
3) They do fancy tricks to come up with a solution of complexity O(n log n), for a trivially easy O(n) problem. So besides being wrong on multiple points, it is inefficient for no good reason.
Perhaps they should have considered https://en.cppreference.com/w/cpp/algorithm/stable_partition if we're allowed to just rule out zeroes in the data.

Here is a definition of strict weak ordering (also linked by Some Programmer Dude)
https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings
Note that comp(0, anything) returns false, so 1 < 0 which makes it easy to break transitivity, in addition to being obviously wrong.
",3,51008911
51246277,"

But how come the order is maintained by this block :

The order is not ""maintained"" in the comparator. The comparator can only tell that after sorting, two elements a and b should be end up

a before b
a after b
a together with b (before the same elements, after the same elements)

What happens to elements that are not ordered by the comparator is only a function of the algorithm. For insertion in a multiset, the added element would end up anywhere (except when insert with hint is used).
",0,51008911
51049706,"
The comp function breaks strict weak ordering for
If a is 0 and b is +ve, then a is less than b, but false is returned, not true
Try
and plug that into std::stable_sort
",-1,51008911
50995076,"
Having const non-static member variables breaks assignment, because you cannot modify them.  Make subViews_ non-const and it should work.
",1,50995033
50972548,"
Use a lambda-expression! GCC 5.4 supports lambdas with -std=c++11 flag.
",3,50972181
50972485,"
",2,50972181
50901180,"
The algorithm is correct. You messed a bit with the braces.
Use tabulation properly so that it is easier to read and find such mistakes.
If your task has no limitations, remember about C++ built-in algorithms (std::sort for example)
",0,50901046
50892592,"
The short answer is that the c++ standard says so:

std::sort sorts the elements in the range [first, last) in ascending order
std::priority_queue provides lookup of the largest element (based on std::less)

So you need, to invert the comparison to obtain the same result.
Why std::priority_queue was chosen to expose the greater element, I don't know but I suspect it was inspired by section 5.2.3 of Knuth. (D. E. Knuth, The Art of Computer Programming. Volume 3: Sorting and Searching.) as stated in the notes of good old Stl SGI
",3,50892527
50915082,"
Rotating 3 adjacent elements will always cancel 2 inversions if present or it will introduce 2 inversions.
Consider this:
Has only 1 inversion, no matter how many times you rotate , you can never cancel that inversion without introducing other inversions as you will be always rotating 3 consecutive elements.
So just count the number of inversions and if its odd then the answer is NO, otherwise YES. There are efficient algorithms out there to count the number of inversions(like merge sort).
",2,50887816
50889140,"
This is the algorithm i designed which finds if the given algorithm can be sorted and if it can be sorted, it sorts the given array by performing the necessary 3 consecutive rotations.
",0,50887816
50818572,"
That does exactly for what you asked, still very suboptimal, but it works :) With any type of array. 
",1,50817300
50796950,"
The problem is not in iterating a 2D array. Provided the columns size is a constexpr value, pointers to arrays are nice iterators.
But all C++ sort (or mutating) algorithms require the underlying type to be move constructible and move assignable and an array is not assignable. But wrapping the underlying arrays can be enough:
Then, you can sort a C compatible 2D array with any C++ sort algo:
The overhead is a vector of structures containing a pointer and a bool, but what is sorted is actually the original 2D array.
Of course, as the C library is accessible from C++, qsort would certainly be easier for sorting a C compatible 2D array. But this way allows the use of stable_sort or partial_sort if they are relevant.
",2,50792843
50777833,"
Your problem lies here:
You are only swapping the first two elements of each row, not all four. The following change should make it work as intended:
",0,50777695
50777818,"
You can make your life simpler by using a std::vector<std::vectror<int>>.
Then you can use std::sort and lambda function to sort them.

If the array sizes are known at compile time, use of std::array is also a possibility.
or
std::sort can be used either of those arrays.

If you must use a 2D array, it's going be bit more involved since arrays cannot assigned. You can create an array of pointers that point to the elements of Array, sort the array of pointers using std::sort.
After that the sorted array can be accessed using ptrArray even though Array still remains in its original state.
",0,50777695
18291727,"
std::sort requires a sorter which satisfies the strict weak ordering rule, which is explained 
here
So, your comparer says that a < bwhen a == b which doesn't follow the strict weak ordering rule, it is possible that the algorithm will crash because it'll enter in an infinite loop.
",25,50777496
18292045,"
The answer for xorguy is pretty good.
I would just add some quote from the standard :

25.4 Sorting and related operations [alg.sorting]
For algorithms other than those described in 25.4.3 to work correctly, comp has to induce a strict weak ordering on the values.
The term strict refers to the requirement of an irreflexive relation (!comp(x, x) for all x), and the term weak to requirements that are not as strong as those for a total ordering, but stronger than those for a partial ordering.

So xorguy explains it very well : You comp function says that a < b when a == b which doesn't follow the strict weak ordering rule...
",10,50777496
50771973,"

std::lower_bound belongs to binary search algorithum family, where the elements are compared using operator< for
  the first version, and comp for the second. The elements in the range
  shall already be sorted according to this same criterion (operator< or comp), or at least partitioned with respect to val.

That means, you need to sort the vector as you mentioned in the way first, in order to act std::lower_bound as you expect.
Once you have sorted your vector of array in the way, you mentioned using a compare functor/ (I made it as a lambda), you can use std::lower_bound.
SEE LIVE HERE
Output: 

NOTE: In order to use std::lower_bound, you need to sort your vector according to the way you wanna apply lower bound first(which is the basic). 
However, in your sorting pattern, std::lower_bound does not know the second value of the pair(int) weather the array is properly sorted or not. In other words, even if you sort accordingly what you mentioned beforehand, std::lower_bound can not give you the desired result, as you sort the Pairs in such a way that Pair.first and Pair.second in opposite order. 
Therefore, I suggest you to use std::find_if, which will linearly search for elements and have to use the same compare funtor as the predicate. If the vector is sorted accordingly beforehand (as you mentioned), then it should give you a proper result. 
",1,50771818
50768070,"
I rewrote partition:
There's also a bug in insertionSort. It should be i <= end instead of i < end. Here's the fixed version:
",2,50767557
50767098,"

Where did I went wrong

Comparison function should have the signature similar to the following:
Therefore your comparison function could look like this:

it worked could please specify reason why it worked

It works because std::sort will take 2 vector elements and send them to the comparison function on each turn. The vector consists of std::strings, you could choose to pass them by value or reference or const reference but you cannot pass pointers like you tried (for that you would need std::vector<std::string *>, a bit pointless tbh)
",2,50766847
495056,"
It is not necessary to put the implementation in the header file, see the alternative solution at the end of this answer.
Anyway, the reason your code is failing is that, when instantiating a template, the compiler creates a new class with the given template argument. For example:
When reading this line, the compiler will create a new class (let's call it FooInt), which is equivalent to the following:
Consequently, the compiler needs to have access to the implementation of the methods, to instantiate them with the template argument (in this case int). If these implementations were not in the header, they wouldn't be accessible, and therefore the compiler wouldn't be able to instantiate the template.
A common solution to this is to write the template declaration in a header file, then implement the class in an implementation file (for example .tpp), and include this implementation file at the end of the header.
This way, implementation is still separated from declaration, but is accessible to the compiler.
Another solution is to keep the implementation separated, and explicitly instantiate all the template instances you'll need:
If my explanation isn't clear enough, you can have a look at the C++ Super-FAQ on this subject.
",1311,50759197
1272085,"
Plenty correct answers here, but I wanted to add this (for completeness):
If you, at the bottom of the implementation cpp file, do explicit instantiation of all the types the template will be used with, the linker will be able to find them as usual.
Edit: Adding example of explicit template instantiation. Used after the template has been defined, and all member functions has been defined.
This will instantiate (and thus make available to the linker) the class and all its member functions (only). Similar syntax works for template functions, so if you have non-member operator overloads you may need to do the same for those.
The above example is fairly useless since vector is fully defined in headers, except when a common include file (precompiled header?) uses extern template class vector<int> so as to keep it from instantiating it in all the other (1000?) files that use vector. 
",219,50759197
16493574,"
It's because of the requirement for separate compilation and because templates are instantiation-style polymorphism.
Lets get a little closer to concrete for an explanation. Say I've got the following files:

foo.h

declares the interface of class MyClass<T>

foo.cpp

defines the implementation of class MyClass<T>

bar.cpp

uses MyClass<int>


Separate compilation means I should be able to compile foo.cpp independently from bar.cpp. The compiler does all the hard work of analysis, optimization, and code generation on each compilation unit completely independently; we don't need to do whole-program analysis. It's only the linker that needs to handle the entire program at once, and the linker's job is substantially easier.
bar.cpp doesn't even need to exist when I compile foo.cpp, but I should still be able to link the foo.o I already had together with the bar.o I've only just produced, without needing to recompile foo.cpp. foo.cpp could even be compiled into a dynamic library, distributed somewhere else without foo.cpp, and linked with code they write years after I wrote foo.cpp.
""Instantiation-style polymorphism"" means that the template MyClass<T> isn't really a generic class that can be compiled to code that can work for any value of T. That would add overhead such as boxing, needing to pass function pointers to allocators and constructors, etc. The intention of C++ templates is to avoid having to write nearly identical class MyClass_int, class MyClass_float, etc, but to still be able to end up with compiled code that is mostly as if we had written each version separately. So a template is literally a template; a class template is not a class, it's a recipe for creating a new class for each T we encounter. A template cannot be compiled into code, only the result of instantiating the template can be compiled.
So when foo.cpp is compiled, the compiler can't see bar.cpp to know that MyClass<int> is needed. It can see the template MyClass<T>, but it can't emit code for that (it's a template, not a class). And when bar.cpp is compiled, the compiler can see that it needs to create a MyClass<int>, but it can't see the template MyClass<T> (only its interface in foo.h) so it can't create it.
If foo.cpp itself uses MyClass<int>, then code for that will be generated while compiling foo.cpp, so when bar.o is linked to foo.o they can be hooked up and will work. We can use that fact to allow a finite set of template instantiations to be implemented in a .cpp file by writing a single template. But there's no way for bar.cpp to use the template as a template and instantiate it on whatever types it likes; it can only use pre-existing versions of the templated class that the author of foo.cpp thought to provide.
You might think that when compiling a template the compiler should ""generate all versions"", with the ones that are never used being filtered out during linking. Aside from the huge overhead and the extreme difficulties such an approach would face because ""type modifier"" features like pointers and arrays allow even just the built-in types to give rise to an infinite number of types, what happens when I now extend my program by adding:

baz.cpp

declares and implements class BazPrivate, and uses MyClass<BazPrivate>


There is no possible way that this could work unless we either

Have to recompile foo.cpp every time we change any other file in the program, in case it added a new novel instantiation of MyClass<T>
Require that baz.cpp contains (possibly via header includes) the full template of MyClass<T>, so that the compiler can generate MyClass<BazPrivate> during compilation of baz.cpp.

Nobody likes (1), because whole-program-analysis compilation systems take forever to compile , and because it makes it impossible to distribute compiled libraries without the source code. So we have (2) instead.
",196,50759197
495048,"
Templates need to be instantiated by the compiler before actually compiling them into object code.  This instantiation can only be achieved if the template arguments are known. Now imagine a scenario where a template function is declared in a.h, defined in a.cpp and used in b.cpp. When a.cpp is compiled, it is not necessarily known that the upcoming compilation b.cpp will require an instance of the template, let alone which specific instance would that be. For more header and source files, the situation can quickly get more complicated.
One can argue that compilers can be made smarter to ""look ahead"" for all uses of the template, but I'm sure that it wouldn't be difficult to create recursive or otherwise complicated scenarios. AFAIK, compilers don't do such look aheads.  As Anton pointed out, some compilers support explicit export declarations of template instantiations, but not all compilers support it (yet?).
",68,50759197
495511,"
Actually, prior to C++11 the standard defined the export keyword that would make it possible to declare templates in a header file and implement them elsewhere.
None of the popular compilers implemented this keyword. The only one I know about is the frontend written by the Edison Design Group, which is used by the Comeau C++ compiler. All others required you to write templates in header files, because the compiler needs the template definition for proper instantiation (as others pointed out already).
As a result, the ISO C++ standard committee decided to remove the export feature of templates with C++11.
",56,50759197
495032,"
Although standard C++ has no such requirement, some compilers require that all function and class templates need to be made available in every translation unit they are used. In effect, for those compilers, the bodies of template functions must be made available in a header file. To repeat: that means those compilers won't allow them to be defined in non-header files such as .cpp files
There is an export keyword which is supposed to mitigate this problem, but it's nowhere close to being portable.
",32,50759197
16509701,"
Templates must be used in headers because the compiler needs to instantiate different versions of the code, depending on the parameters given/deduced for template parameters. Remember that a template doesn't represent code directly, but a template for several versions of that code. 
When you compile a non-template function in a .cpp file, you are compiling a concrete function/class. This is not the case for templates, which can be instantiated with different types, namely, concrete code must be emitted when replacing template parameters with concrete types.
There was a feature with the export keyword that was meant to be used for separate compilation.
The export feature is deprecated in C++11 and, AFAIK, only one compiler implemented it. You shouldn't make use of export. Separate compilation is not possible in C++ or C++11 but maybe in C++17, if concepts make it in, we could have some way of separate compilation.
For separate compilation to be achieved, separate template body checking must be possible. It seems that a solution is possible with concepts. Take a look at this paper recently presented at the 
standards commitee meeting. I think this is not the only requirement, since you still need to instantiate code for the template code in user code. 
The separate compilation problem for templates I guess it's also a problem that is arising with the migration to modules, which is currently being worked.
",26,50759197
495128,"
It means that the most portable way to define method implementations of template classes is to define them inside the template class definition.
",14,50759197
37189280,"
Even though there are plenty of good explanations above, I'm missing a practical way to separate templates into header and body.
My main concern is avoiding recompilation of all template users, when I change its definition.
Having all template instantiations in the template body is not a viable solution for me, since the template author may not know all if its usage and the template user may not have the right to modify it.
I took the following approach, which works also for older compilers (gcc 4.3.4, aCC A.03.13).
For each template usage there's a typedef in its own header file (generated from the UML model). Its body contains the instantiation (which ends up in a library which is linked in at the end).
Each user of the template includes that header file and uses the typedef.  
A schematic example:
MyTemplate.h:
MyTemplate.cpp:
MyInstantiatedTemplate.h:
MyInstantiatedTemplate.cpp:
main.cpp:
This way only the template instantiations will need to be recompiled, not all template users (and dependencies).
",11,50759197
7452293,"
That is exactly correct because the compiler has to know what type it is for allocation. So template classes, functions, enums,etc.. must be implemented as well in the header file if it is to be made public or part of a library (static or dynamic) because header files are NOT compiled unlike the c/cpp files which are. If the compiler doesn't know the type is can't compile it. In .Net it can because all objects derive from the Object class. This is not .Net.
",6,50759197
38604074,"
If the concern is the extra compilation time and binary size bloat produced by compiling the .h as part of all the .cpp modules using it, in many cases what you can do is make the template class descend from a non-templatized base class for non type-dependent parts of the interface, and that base class can have its implementation in the .cpp file. 
",6,50759197
43948426,"
A way to have separate implementation is as follows.
inner_foo has the forward declarations. foo.tpp has the implementation and include inner_foo.h; and foo.h will have just one line, to include foo.tpp.
On compile time, contents of foo.h are copied to foo.tpp and then the whole file is copied to foo.h after which it compiles. This way, there is no limitations, and the naming is consistent, in exchange for one extra file.
I do this because static analyzers for the code break when it does not see the forward declarations of class in *.tpp. This is annoying when writing code in any IDE or using YouCompleteMe or others.
",2,50759197
51412815,"
Just to add something noteworthy here. One can define methods of a templated class just fine in the implementation file when they are not function templates.

myQueue.hpp:

myQueue.cpp:
",2,50759197
38448106,"
The compiler will generate code for each template instantiation when you use a template during the compilation step. 
In the compilation and linking process .cpp files are converted to pure object or machine code which in them contains references or undefined symbols because the .h files that are included in your main.cpp have no implementation YET. These are ready to be linked with another object file that defines an implementation for your template and thus you have a full a.out executable.
However since templates need to be processed in the compilation step in order to generate code for each template instantiation that you do in your main program, linking won't help because compiling the main.cpp into main.o and then compiling your template .cpp into template.o and then linking won't achieve the templates purpose because I'm linking different template instantiation to the same template implementation! And templates are supposed to do the opposite i.e to have ONE implementation but allow many available instantiations via the use of one class.
Meaning typename T get's replaced during the compilation step not the linking step so if I try to compile a template without T being replaced as a concrete value type so it won't work because that's the definition of templates it's a compile time process, and btw meta-programming is all about using this definition.
",1,50759197
50712598,"
The easier way i found was:
",0,50693571
50672196,"
Reset i to 0 each time before the inner loop:
",1,50672144
50671657,"
It seems that the good old insertion sort will do better than O(N^2 lg N) in this case, because you don't need to sort elements from scratch for each  R.
Imagine you have a copy of the sorted first n elements of the array for n in 1..R-1. 
Just insert the R-th element in a copy of the sorted array of the R-1 first elements (that's O(R)) and you get your sorted array of the R first elements.
That's O(N^2) if you want the result for every R in 1..N, but that will be less than O(N^2) in practice, because you can produce sorted arrays on demand, starting from the last sorted array with less elements than R.
",2,50669556
50673043,"
We could take O(n log n) space to keep the partial results of a merge sort. Then the upper bound for returning the first R elements sorted would be akin to merging log n sorted lists. I found one reference for merging k sorted lists of total length n at O(n * log k), which would make ours O(n * log log n), but hopefully many of the queries would be even more efficient.
",2,50669556
50673581,"
You can try quicksort, but not do it entirely. I heard that Haskell does it in a similar way.
It's almost the usual quicksort, but you postpone work which can be postponed.
For the first element it will be just quickselect where you skip ranges irrelevant for the first element. But for every next element you should look for ranges which were not partitioned yet, but are needed for it and partition them.
Time for the first element will be O(n) (and you will unlikely get anything better), the entire time will be O(n * log n).
Additional memory for storing range positions seems to be O(log n), but I haven't thought about this enough to be sure.
Correction: if you need to output the entire subarray every time, that will make O(n^2), only if you output on number at a time - that will be O(n * log n).
",1,50669556
50635340,"
First I'll solve a related problem; generate merged intervals that cover the same area with no adjacency or overlap.
Walk the input array.  Start with the first element.  Record highwater (end of interval) and lowater (start of interval).
Proceed forward.  Each element, if it overlaps the interval, extend highwater.  If not, output highwater and lowater as an interval, then record a new high and lowater.
This takes O(n) time on input.
Every element of input must be read, because any of them could go from their start location to the end and change the result.  So this is O-optimal.

This merges intervals into the largest contiguous one you can make; you want to save all of the ""edges"" or ""seams"" in the original intervals.  To solve your spec, simply keep track of seams (in order) and break the generated intervals at those seams.  ""Lowater"" seams will always come with increasing values; highwater seams may not.  So an ordered set of seams should work.  This is O(nlgn) sadly due to the set.

live example.
",4,50634436
50634694,"
I came up with something like this, by adding just couple of if it is done in O(n) time. I'm just not sure about last elements, my output:
Maybe its something that would help:
Update 1
As pointed out in the comment above will not work with multiple overlapping intervals, so the above solution can be improved by swallowing intervals that are containing each other and run the same algorithm:
But this requires 2xO(n) space complexity and code is not nice.
So I just wonder would that not be enough:
For your data it gives output:[1 : 5], [7 : 19] but it get rid of overlaps.
",1,50634436
50548224,"
Arguments are copied by value unless a reference is passed. To modify the object you pass in, use a reference instead.
Pass a vector<int> &arr instead of a mere vector<int> arr. Note the &.
Another way, would be to return the sorted array and assign it to your old, unsorted array.

Some tips:

Prior to rand, call srand to initialize the PRNG with a seed. Since C++11, there is also <random>, which you should favor anyway.
std::endl flushes the stream buffer. '\n' does not, but has the same visual effect. Favor '\n' unless you actually want to flush the stream buffer. Especially in loops, where repeated flushing is superfluous and inefficient.
Use the appropriate size type for STL data structures. For std::vector, this is std::vector<T>::size_type a.k.a. std::size_t. The same as for arrays, BTW. Instead of int, use std::size_t. std::vector::size also returns a std::size_t, not an int.

",3,50548213
50547762,"

Output should be:

So basically you wanna sort objects w.r.t either y or x. 
One simple way of doing it is defining operator< for your class punto
Now you can simply use std::sort(), how you normally use it.

In order to sort w.r.t xs, you can write a lambda function which will use getters(which you need to define in the class punto) of your class.
Then you can do as follows:
SEE OUTPUT HERE

However, I didn't understand why you have created punto *p1; and every time you have push_back the content to the vector. 
One dangerous thing to note that, whatever you have created using new keyword, hasn't been deleted after, which is a serious memory leak issue in your problem.
You could have also use simply punto p1;  or use Smart Pointers, if you really wanna play with dynamic memory.
",2,50547667
50547879,"
You can use lambda-functions (since C++11) to make your code more laconic:
[x] means, that variable x is visible inside lambda function (see lambda-capture). 
",1,50547667
50547787,"
You can use std::sort to sort a std::vector. To sort a class  it needs to have a operator< defined or you need to supply a custom comparator.
In your case the variables x and y are also private, to work around that we can make friend functions that can compare the x and y and pass them in as comparators to std::sort.
",0,50547667
50547805,"
You could add getters for x & y to your punto class and then you can pass a custom comparator to std::sort:
",0,50547667
50545492,"
Looks like you have trouble understanding how arrays and loops work. At first, read this article about loops, then this one about multidimensional arrays. Now, as for your code:
What are you actually doing here is incriminating rows variable, which stores number of rows in your array[rows][columns]. As a result, your loop doesn't work properly. To traverse through the array, you need to incriminate i variable, so you can access elements of the array by index withing square brackets. 
For example: calling array[i], while i = 3, will return you the fourth element of the array. (as arrays start at 0)
Now, sorting. You are trying to use while (1) loop, which is infinite, and break, which won't ever execute properly.
Sorting of two dimensional array is actually sorting x single dimensional arrays. So, what you need to do is to implement simple bubble sort for single dimensional array and wrap it up additional for loop to traverse trough rows.
UPD:
To display array of max elements, at first create an array where you will keep your max values. For my snippet it is int array_max[rows]. It will record your max values as we find them. To do that, add this: (where you that cout was)
And now, to sort your new array and properly print it, try this:
And finally, add #include <ctime> to your project to get new random values each time you run your program.
",0,50543642
50498541,"
Others have pointed out that there are faster and cleaner ways to sort. But if you want to use your own selection sort, as you've written, then you just need to make a few changes to your code.
Separate the ""do I need to swap"" logic from the swapping logic itself. Then the code becomes much cleaner and it's more clear where to add the extra check.
I've only copied the inner loop here. You'd want to replace your existing inner loop with this one. I'm not clear on why you need swap_pos and min_pos, so I've left the semantics alone.
To more clearly illustrate the necessary logic changes, I've purposely avoided making major style changes or simple optimizations.
",1,50495527
50495687,"
Make a comparator function.
Add an operator< to your List:
And now use this operator to sort, using whichever algorithm strikes your fancy.
",6,50495527
50497878,"
You can pass a lambda to sort to do this:
Live Example
",1,50495527
50495717,"
Use tuple lexicographical compare operators
An easy way to not write this condition is to
Then std::tie can be used:
This works because std::tie creates a tuple of lvalue references to its arguments. (Which means std::tie requires variables. If You want to compare results from functions std::make_tuple or std::forward_as_tuple would be better)
And std::tuple has operators which 

Compares lhs and rhs lexicographically, that is, compares the first elements, if they are equivalent, compares the second elements, if those are equivalent, compares the third elements, and so on. 

And the above description is also the idea how to make a comparison of more than value.
",1,50495527
50483973,"
Populating another container is unavoidable. But you don't have to move or copy any of your own data. You can use std::list::splice to extract and reinsert the nodes you want to process into sorted order.
The function transfers the nodes you wish to sort into the sorter list (the first iterator argument is the position before which the nodes are inserted, in this case the end of the list).
The sorter list is sorted (obviously), and then the sorted content is transferred back into the source list, exactly into the original sub-range it originally populated.

As commented by @T.C. The next step is to generalize it. It can be made into a template much like this one:
The comparator is taken as an argument here as well, and sorter is constructed with a copy of the input's allocator for maximum genericity. The splicing back is done in a scope guard of our choosing to support the case where the compare function throws, so our bases are now covered. 
Here is a live example, with a naive and somewhat silly implementation of a scope guard, for exposition purposes.
",25,50483742
50512050,"

Is it possible to sort portion of a list (subset of a list) defined by iterators like std::sort does?

I assume you meant std::list::sort. Visual Studio 2015's implementation does this, and without having to populate another container. It is a top down merge sort that is less efficient than the prior bottom up merge sort, but it avoids allocating memory that the prior version did since the prior version allocated a small array of lists. Psuedo code would look something like this:
",0,50483742
50455740,"
As comments correctly state, there is no even remotely portable way of matching sorting on unordered_map. So, sorting is unspecified.
However, in the land of unspecified, sometimes for various reasons we can be cool with whatever our implementation does, even if unspecified and non-portable. So, could someone look into your map implementation and use the determinism it has there on the vector?
The problem with unordered_map is that it's a hash. Every element inserted into it will be hashed, with hash (mapped to the key space) used as an index in internal array. This looks promising, and it would be promising if not for collision. In case of key collision, the elements are put into the collision list, and this list is not sorted at all. So the order of iteration over collision would be determined by the order of inserts (reverse or direct). Because of that, absent information of order of inserts, it would not be possible to mimic the order of the unordered_map, even for specific implementation.
",3,50455424
50447522,"
Yes, it's tricky to do this using std::sort: you'd somehow have to fool your comparator into inserting the invariant number into the correct place, and that's difficult without examining the other elements beforehand.
A simple remedy is to use an insertion sort; omitting the out-of-place number (but recording the position) when you get to it, and inserting it manually at the end at that recorded position.
",1,50447484
50448022,"
As per @Bathsheba 's remedy mentioned in his answer, and fooling std::sort()'s predicate, one can achieve the solution something like follows: 
DEMO
",2,50447484
50450577,"
Given a vector.

Find the location of the element you want to leave.
Swap it out to the end.
Partial sort the vector (without the last element) - all elements before the selected location will be sorted, after that there will be a random order. 
Swap the element back into the found location
sort the rest of the vector

The code:

",1,50447484
50452959,"
Without swapping the element to the end :

Find the location of the element.
Partial sort the vector up to and excluding this location, using a comparator that makes this element greater than the other elements of the vector, so that the element does not appear in the partial sorted part.
Sort the rest of the vector from this location to the end, using a comparator that makes this element lesser than the other elements of the rest of the vector, this reput this element at this location.

Code : 
",0,50447484
50422482,"
I'm assuming that you do know about the STL sort function and are just experimenting with Insertion Sort.
Your logic for the most part is correct. The only problem I found was that you were leaving the a[n] 'hole' unfilled and in the worst case adding items in the a[a.size()].
Replacing with this solved the problem.
",1,50419654
50401097,"
You could do one of two things:

First take care of the ""NULL""s, then sort the other strings the naive way we regularly would 
Sort all string using the more complex ordering you defined

Handling ""NULL""s first
The standard library has a ""partition"" algorithm, which will move all elements matching a certain criterion to the end of the string.
Sort with a complex comparison
Note the difference between the comparison here and your comp() function. The comparator answers question ""should the first string I got come before the second string?"" - and your comp() function just doesn't give an answer that corresponds to your requirement.
",1,50398551
50401482,"
You can use partition algorithm: 
NOTE: If you need to maintain relative ordering use stable_partition instead.
",1,50398551
50400892,"
You can write your own version of function that puts some strings to the end i.e:
Then just:
",0,50398551
50395885,"
Use std::list::sort with a custom binary comparison function similar to:
Then:
",5,50395796
50395910,"
std::list::sort() can take a custom comparison function. Simply write:
This needs operator<(MyClass, MyClass) to be defined:
",1,50395796
50395927,"
That's way too much pointers you have, I must say. Having simply std::list< std::pair<MyClass,double>> myList; is perfectly fine and will save you a great deal of headache when the time comes to tracking down and destroying all the objects.
Now, sorting. Sure:
then call
",0,50395796
50491033,"
I implemented this with a vector, I save the position of the starting number then insert left is the number is lower or right if the number is greater. Then numbers go to left or right until they are greater or lower.
Hope this helps
",2,50391605
50394497,"
The first thing I noticed is even though there is a selected value, there is no corresponding selected index. So that had to be added and used.
Second thing is that the selected value is only a boundry. And each time the currently sorted value has to bubble it's way down.
So all in all this is just a standard insertion sort. (That is if I understood the algorithm correctly.)
Renamed the variables i and j to to_sort_idx and look_at_idx.
",3,50391605
50393342,"
The issue here is your algorithm is only making one pass at the array where integers are being swapped.  Because of the swapping of 93 to the back on the first pass, the second iteration looks at a[2] which is now 33 (not 58).  So you have essentially skipped over processing 58. This algorithm only partially sorts the array.  You would have to make multiple passes here to get what you want...
output: 11 13 32 33 41 58 58 63 87 93
",0,50391605
50367367,"
The problem is that you are comparing strings, that is, you compare them in alphabetical order. Let's see which comparisons will yield bad results:

2, 3, 4, 5, 6, 7, 8, 9 vs. 10
J vs A
Q vs K
K vs A

So you will need to write your comparison to check whether any of the values is 10, A or J. If it is 10, check whether the other is a number. If it is A, check whether the other is J or K. If it is K, check whether the other is Q or A. If any of those cases are met, then return the logical value which corresponds to your needs. Otherwise work as you did before:
",0,50366984
50367590,"
One thing you have going for you is that the first character of each string is unique.  This code is untested, but it should be close:
With the helper functions, the lambda is trivial:
As a side note, my guess is that you want to compare face values before Colours, but I'm sticking with your original logic for now.
",3,50366984
50367959,"
You can have a lookup of the face values of your cards, expressed as a std::map<std::string, int>. Rather than explicitly specifying the less than of two values, we can use the std::tuple less than, with std::tie.
",3,50366984
50367214,"
It is not sorting the way you want because 10 is less than 2 because 1 is less than 2. You might be better off using a class and a comparison operator:
Then you could do:
Note: Untested code, also needs appropriate constructors converters etc.
",0,50366984
50371985,"
How about enums for suit and value:
Then, if you want it, a method to print a Pair:
Then you can compare exactly as you originally wrote, since the Suit and Val enums are implicitly ordered:
Output:
Here is a minimal working example of the whole thing.
",0,50366984
50329572,"
You can sort the nested vectors without extra data copying by creating a custom wrapper matrix class and define your own iterator:
Then sort could be applied to MyMatrix as follows:
Running the above code will result in the following output:
",1,50327670
50328429,"
To store a matrix, the nesting of std::vector is not the best solution. As any row manages its own size, there is no unique column size intrinsically granted by the matrix class.
Assuming that OP is damned to use an existing type (which may not be changed), I wrote my sample based on this.
One solution (with least implementation effort) would be

to copy the matrix (std::vector<std::vector<std::string> >) into a temporary of type std::vector<std::string>
apply std::sort() to this temporary
assign the sorted vector to matrix again.

Considering that moving of elements may be expensive, an alternative could be

to build up an index-pair vector
std::sort() it with a custom less functor (which considers matrix elements).

Afterwards, the index-pair vector may be used to access the original matrix elements in sorted order.
The latter is shown in my sample code:
Output:
Input:
 5 2 1
 0 0 2
 1 4 3

Output:
 0 0 1
 1 2 2
 3 4 5

Life demo on coliru

The OP complained about creating a separate index vector. I suspected that a custom random access iterator might be a replacement (to sort the matrix directly). I must admit that I didn't do this before but, out of curiosity, I tried to puzzle this out:
Output:
Input:
 5 2 1
 0 0 2
 1 4 3

Output:
 0 0 1
 1 2 2
 3 4 5

Life demo on coliru
Notes:
I used the descriptions on cppreference.com

C++ concepts: RandomAccessIterator
C++ concepts: BidirectionalIterator
C++ concepts: ForwardIterator
C++ concepts: Iterator
std::iterator_traits

as a ""requirement-cheat-sheet"" and implemented everything described there. Some of the details, I decided by guess. (Especially, concerning the typedefs I'm not quite sure how to do them correct.)
",2,50327670
3846921,"
Just a warning. You should be carefull with the wording: if you identify the three ""main colors"" of your image,  you may get the following (code in Mahematica):
 
",1,3845411
3846112,"
Look up algorithms for image segmentation.
",0,3845411
3757295,"
If your set of keywords is fixed, a perfect hash can be built for O(1) lookup.  Check out gperf or cmph.  
",4,3757270
3757283,"
A ""trie"" will surely be the most efficient way.
",2,3757270
3757477,"
Whatever implementation of std::map you have will probably be sufficient.
",2,3757270
3764419,"
This is for a language, with a specific set of keywords that never change, and there aren't very many of them?
If so, it probably doesn't matter what you use. You will have bigger fish to fry.
However, since the list doesn't change, it would be hard to beat a hard coded search like this:
",2,3757270
3757789,"
For singe character keywords a lookup table would be perfect. For multicharacter (especially if the lengths differs): a hash table. If you need performance, you could even use source code generation to create the hash tables (using a simple hash function that is able or not to ignore case, depending on your syntax).
So I'd implement it with a LUT and a hash table: first you check the first character with the LUT (if it's a simple operator, it would start with a non-alpha-numeric value), and, if not found, check the hash table.
",0,3757270
3756651,"
Pseudocode:
",4,3756627
3756649,"
Just use fscanf and the string functions, everything you need is in stdio.h and string.h, both part of the standard C library.  I'm sorry, I'm not going to just give you a code sample, but check out cplusplus.com for information on things like strcmp, fscanf, and toupper (or tolower, depending, you can use these for case insensitivity)
",4,3756627
3725671,"
Note that ""_"" is a string literal, while '_' is a character literal. 
If you dereference an iterator into a string, what you get is a character. Of course, characters can only be compared to character literals",16,3725574
3725604,"
",9,3725574
3725590,"
string::find is your friend.
http://www.cplusplus.com/reference/string/string/find/
",8,3725574
3725594,"
Why dont you use the find method : http://www.cplusplus.com/reference/string/string/find/
",6,3725574
3725592,"
You can make use of the find function as:
Output:
",6,3725574
3628061,"
Do you mean the lower_bound/upper_bound functions? These perform a binary search and return the closest element above the value you're looking for.
Clarification: The global versions of lower/upper_bound only work if the range is sorted, as they use some kind of binary search internally. (Obviously, the lower/upper_bound methods in std::map always work). You said in your question that you were looking for some kind of binary search, so I'll assume the range is sorted.
Also, Neither lower_bound nor upper_bound returns the closest member. If the value X you're looking for isn't a member of the range, they will both return the first element greater then X. Otherwise, lower_bound will return the first value equal to X, upper_boundwill return the last value equals X.
So to find the closest value, you'd have to

call lower_bound
if it returns the end of the range, all values are less then X. The last (i.e. the highest) element is the closest one
it if returns the beginning of the range, all values are greater then X. The first (i.e. the lowest) element is the closest one
if it returns an element in the middle of the range, check that element and the element before - the one that's closer to X is the one you're looking for

",9,3628045
3628082,"
So you're looking for an element which has a minimal distance from some value k?
Use std::transform to transform each x to x-k. The use std::min_element with a comparison function which returns abs(l) < abs(r). Then add k back onto the result.
EDIT: Alternatively, you could just use std::min_element with a comparison function abs(l-k) < abs(r-k), and eliminate the std::transform.
EDIT2: This is good for unsorted containers. For sorted containers, you probably want nikie's answer.
",6,3628045
3628600,"
If the container is already sorted (as implied) you should be able to use std::upper_bound and the item directly before to figure out which is closest:
If the container is not sorted, use min_element with a predicate as already suggested.
",3,3628045
3628129,"
If your data is not sorted, use std::min_element with a comparison functor that calculates your distance.
",2,3628045
3230464,"
This library seems to do the trick:
""ANN is a library written in the C++ programming language to support both exact and approximate nearest neighbor searching in spaces of various dimensions. 
[...]
In the nearest neighbor problem a set P of data points in d-dimensional space is given. These points are preprocessed into a data structure, so that given any query point q, the nearest (or generally k nearest) points of P to q can be reported efficiently.""
",1,3230354
3230383,"
Depends on your data structure.  Primarily, are your objects already sorted / partitioned by distance?  I can't think of any distance heuristic... but you could certainly do this in parallel which should help.
",0,3230354
3131600,"
I don't know if there's an API for it, but if you do a Windows search for an unlikely string, say ""zxcvbnm"", then search the registry for it, then on XP you can see it under one of the folders in:
along with the rest of your recent search strings. I imagine this registry location may change between Windows versions though.
If you're targetting Windows 7 then this MSDN article looks like a good starting point.
",1,3127727
2993698,"
Boost.Filesystem is a great library. Here is a code I wrote while ago, you can change the search criteria easily once you know the library(you can query the size and the extension):
",6,2993680
2995977,"
ACE has a lot of cross-platform wrappers. In your particular case see ACE_Dirent or ACE_OS::scandir / ACE_OS::opendir / ACE_OS::readdir and friend functions. ACE is very powerful abstraction layer between operating systems. If you need such things then this is the way to go.
",1,2993680
2979234,"
Read this pdftotext
If you actually want to write code to do then you'll probably have to learn of to navigate the internals of a PDF file. There have been some answers on how to do that for example one pointing to this article which on the 2nd page has the code in C for a basic PDF parser
xtractpro
",2,2979195
2932390,"
You'll want to look at motion estimation, which is used in video coding to find the location of a block in a previously coded picture, that most closely resembles the block to be coded. 
(NOTE: I don't have enough reputation to post 2 links, so you'll have to look up motion estimation in wikipedia).
Some simple block matching algorithms can be found here. These work by only analyzing a subset of points in the search area.
If you want to find the specific point that minimizes your matching function, you'll have to do a full search. Full-search speedup is usually achieved by early termination - ending the evaluation of a point if it is already impossible for it to improve upon the previous best result. 
Early termination is also useful when examining only a subset of search points, though the speedup isn't as great as with full search.
",2,2914971
2927509,"
You may try to find approximate solution: Patch Match

This paper presents interactive image editing tools using a new randomized algorithm for quickly finding approximate nearest neighbor matches between image patches. Previous research in graphics and vision has leveraged such nearest-neighbor searches to provide a variety of high-level digital image editing tools. However, the cost of computing a field of such matches for an entire image has eluded previous efforts to provide interactive performance. Our algorithm offers substantial performance improvements over the previous state of the art (20-100x), enabling its use in interactive editing tools. 

",1,2914971
2927264,"
Answering to my own question.
Short answer:
I was able to drop alpha channel, so I've decided to use image pyramids (see pyramid and gaussian pyramid on the net). It gave huge speed improvement. 
Long answer:
My initial goal was texture synthesis. Alpha was used to generating pixels that weren't filled yet, and B represented a portion of already generated image. (I.e. A was sample pattern, and B was generated image)
After a bit of researching I've found that either there is no quick way to do a search in N-dimensional space (for example, 3x3 pixel area is basically an 24 component vector (center pixel excluded), while 7x7 wlil be 144-component, searching for such area will be 24-dimensional or 144-dimensional search). Well, there are ways (for example, paper named ""I-COLLIDE: an interactive and exact collision detection system for large-scale environments"" uses 3 sorted arrays (each sorted on different dimension) to do 3 dimensional search), but they obviously will work better for floats and lower number of dimensions.
Suggestion to use motion detection wasn't useful, because (it seems) motion detection assumes that pixels represent moving objects (not true in my case), and at least some optimization relies on that.
In the end I've found paper named ""Fast Texture Synthesis using Tree-structured Vector Quantization"" (Li-Yi Wei, Marc Levoy, Stanford University), which uses technique based on algorithm similar to the one I used. Image to be searched is downsampled several times (similar to mip-map generation), search performed on the lowest level first, and then on the next. It may not be the best way to do actual image search for other application, but it perfect for my purposes. The paper is relatively old but it works for me.
The same paper mentions a few techniques for accelerating search even further. One of them is ""Tree-structured vector quantization (TSVQ)"", although I can't give more info about it (haven't checked it - current texture generator works with acceptable speed on my hardware, so I probably won't look into further optimizations).
",1,2914971
2915025,"
One potential speedup might be to use binary operators. For example, you could march through A XOR B for subsequent, overlapping regions of A. The resulting region whose values are closest to 0 would be the portion of A that most closely resembles B. If you had to take the alpha mask into account assume A's alpha mask is all 1s and include it in the XOR- 32 bits per pixel instead of 24.
",0,2914971
2915128,"
I'd consider moving your early out on cur Difference into your inner loop so that it can short circuit well before the inner loop is done if the error is already too great.  Your trading ifs for some heavy math.  Also, the pixel scale value on the error could be a multiply instead of a divide (minor on new machines.)
Any chance of reading multiple pixels at a time or paralleling their processing?  
For threading, you could start threads per each external for loop iteration (breaking up into how ever many threads you want to use) to allow your CPUs to be more efficicent.  Syncing max error would be the only issue - which could be accomplished by storing the errors into an external table and comparing at the end to prevent memory contention.
Caching your structures to get rid of -> 's can help, but the compiler usually does this for you.
Just some thoughts to begin with.  Still looking...
",0,2914971
2927532,"
PDiff is an open source perceptual image difference tool that maybe has some helpful techniques for you.
",0,2914971
2861709,"
There is no direct way to do this.  You can add your urls to History using IUrlHistoryStg, and then they will show up if they match what the user types.
",1,2860691
2730132,"
If you wanted to go for something that is in the standard library, you could use std::set with the word as the key.  That would give you logarithmic search time.  
Since your dictionary is presumably static (i.e. created once and not modified), you could also use a std::vector, sort it using std::sort, and then use std::binary_search on the sorted vector to find a word.  This would also give logarithmic search time, and would possibly be more space efficient than a set.
If you want to implement your own data structure, a trie would be a good choice.
",23,2730117
2730223,"
std::set is a natural for this because it takes almost 0 work on top of using a vector.  Even so, I will teach you something you don't usually learn until your are a professional.  Don't optimized prematurely.  I bet on a moden computer that a linear dictionary lookup in a 40K string vector takes .001 seconds.
In a set, it's O(log n) and probably takes .00001 seconds.
Anything not in the STL is a total waste of time. Don't spend $10 of work on a 10 cent problem. 
",9,2730117
2730267,"
A trie or radix tree would be give you search times and insertion times that are linear in the length of the string you are searching for.
(Note that linear in the length of the string you are searching for is the best you can do with any search algorithm, because comparing or hashing strings is linear in the length of the string -- therefore the component of running time that's linear in the length of the string is usually left out of the running times for binary search, binary trees, or linear search.)
These solutions are probably overkill if you don't have them in your library already.
",6,2730117
2731065,"
I did some profiling and got the following results (MSVS 2008, /O2, release build, launching .exe separately).
EDIT - Now I realize I actually f*cked up my first test, because I didn't split the building and searching test. Though it didn't change the ""winners"", I made some new tests. So, here are the results when we split them.
First, if there are almost no bad search requests (4 million good search attempts).
This profiling shows that you should use ""normal"" container variations instead of ""multi"", and you should choose the unordered_set. It's great in building time and search operations time.
Here are the results for another case (guess, it's not about your app, but just for it to be), when the amount of bad searches equals the amount of good searches (and equals 2 million). The winner remains the same.
Also note, that for static dictionaries vector performs better (though need more time for initialization), than set, but well, it will suck if you have to add elements.
Testing code:
",6,2730117
2730281,"
What is the purpose of your data structure?  What sort of things do you want to do with it?

Check if a complete word like ""tempest"" is in the list?
Find all seven letter words starting and ending with ""t""?  
Find all seven letter words starting and ending with ""t"" that can be made with a given set of letters?

The first question is all you need if you're implementing some sort of referee for a group of human players, that is, some entity to check proposed words against the official dictionary.  Basic data structures like std::map, std::set, std::vector, already suggested by others, by themselves suffice for this purpose.
The second and third questions are the kind you need answered if you're writing a player.  Here you might want to consider 26 sets for each letter position, each set holding the words with a given letter in a given position.  You'll need extra code to compute intersections when needed, and maybe check words against the letters available on your rack.
Update: In a comment on the original question, the OP made it clear that he only has to check if a word is in the dictionary.  This is the first question I asked above, and any of the standard efficient data structures is fine.
",3,2730117
2730233,"
If the vector is sorted, you can use binary_search to test if a given word exists in the dictionary.
",2,2730117
2730278,"
Use a std::tr1::unordered_set, and that gives you constant time lookup. (Linear in the length of the string, as per my other answer.)
",2,2730117
2734060,"
I would echo Ken's suggestion of using a Trie, and further suggest that you could dramatically shrink the size of the trie by letting it be more like a finite-state-machine for common prefixes and suffixes. For example
""nation"",
""national"",
""nationalize"",
""nationalization"",
""nationalizing"",
""denationalize"",
could all share common structure. You would have to be concerned about dubious words, like
""nationalizationalizationalizing""
I used this ages ago in a spelling correction program.
",2,2730117
2731638,"
I suggest using the length of the word and the first letters as the first two items in the search.  Let the data be organized to support this algorithm.  
First, let us define a container for all the words that are the same length:  
This data structure shall be sorted, so that a binary search can be used.
Next, an index table will be created.  The index table will be of the form <word length, pointer to word container>:
And finally have an array of index tables, using the first letter of the word as an index:
The algorithm is then:
Calculate index into alpha_array:
index = word[0] - 'A'; 
Use index to get associated index table:
Index_Table& table = alpha_array[index]; 
Use length of the word as the key for the table lookup, to get word container:
Word_Container * p_word_container = table[word.length()]; 
Search container for exact word:  
There are more efficient, but complex, methods for searching a dictionary for a word.  The above algorithm has a benefit of a quick ""escape"" points where the word doesn't exist.  This concept can be extended to database tables.
",1,2730117
2583480,"
Python is unlikely to allow you to write the most efficient server possible. However, it may just be that it will be fast enough, because for most applications it is.
Therefore, one path you could take is starting with Python. It's a great language for prototyping, much better than C++ for the stage in which you're not even sure which architecture to adopt. As you finish the project, you can see if Python is efficient enough. If it isn't and there's no easy way to make it much faster (such as rewriting a small routine that takes up most of the work in C), you can rewrite it in C++ using the Python prototype as a basis.
",0,2582892
2582910,"
Twisted framework is a good starting point for develop backend servers. It is fast and scalable. 
",1,2582892
2594273,"
For search, http://github.com/tjake/Lucandra may be interesting prior art.
",0,2582892
2541998,"
From the SGI docs:

Note that this is not necessarily the information you are interested in! Usually, if you're testing whether an element is present in a range, you'd like to know where it is (if it's present), or where it should be inserted (if it's not present). The functions lower_bound, upper_bound, and equal_range provide this information. 

I think the reasoning behind this set of interfaces is that binary_search doesn't really indicate whether it'll return the start of the range of matches (assuming there are matches) or the end of the range, and you might want one or the other depending on whether you want to do something with data already in the container or add a new item (possibly to the end of the matching range). Or you might want to pass the whole range on to something else.  Hence the various more or less specific interfaces to perform a binary search.  
Unfortunately, you're not particularly likely to find the other ones if you're thinking, ""I need a binary search routine"".  
",5,2541977
2542000,"
I googled and found this
http://www.cplusplus.com/reference/algorithm/binary_search/... It might be an easy way to accomplish your goal 
",0,2541977
2480027,"
If you order your arrays beforehand, the search can be done much faster. You could start on your smaller array, then binary-search for expected numbers on each of them. This would be O(nklogM), n being the size of the smallest array, k being the numbers of arrays, M being the size of larger array
This could be done even faster if you use Hashmaps instead of arrays. This would let you search in O(n*k).
If using reverse functions (to search in earlier arrays) is not an option, then you should start on first array, and n = size of first array.
For simplicity, I'll start from first array
You can probably do some null checks and add some booleans in there to know if the sequence exist or not
",3,2479983
2480082,"
(Design patterns apply to class and API design to improve code quality, but they aren't for solving computational problems.)
Depending on the cases:

If the arrays comes in random order, and you have finite space requirement, then brute-force is the only solution. O(Nk) time (k = 3), O(1) space.
If the predicate is not invertible (e.g. SHA1(next_elem) xor SHA1(prev_elem) == 0x1234), then brute force is also the only solution.
If you can expense space, then create hash sets for v2 and v3, so you can quickly find the next element that satisfies the predicate. O(N + bk) time, O(kN) space. (b = max number of next_elem that satisfy the predicate given a prev_elem)
If the arrays are sorted and bounded, you can also use binary search instead of the hash table to avoid using space. O(N (log N)k-1 + bk) time, O(1) space.

(All of the space count doesn't take account to stack usage due to recursion.)
A general way that consumes up to O(Nbk) space is to build the solution by successively filtering, e.g.
",3,2479983
2480028,"
You could generate a seperate index that map an index from one array to the index of another.  From the index you can quickly see if an solution exists or not.
Generating the index would require a brute force approach but then you'd do it only one.  If you want to improve the array search, consider using a more appropriate data structure to allow for fast search (red-black trees for example instead of arrays).
",0,2479983
2480047,"
I would keep all vectors as heaps so I can have O(log n) complexity when searching for an element. So for a total of k vectors you will get a complexity like O(k * log n)
",0,2479983
2480122,"
If the predicates preserve the ordering in the arrays (e.g. with your example, if the values are all guaranteed non-negative), you could adapt a merge algorithm. Consider the key for each array to be the end-value (what you get after applying the predicate as many times as needed for all arrays).
If the predicate doesn't preserve ordering (or the arrays aren't ordered to start) you can sort by the end-value first, but the need to do that suggests that another approach may be better (such as the hash tables suggested elsewhere).
Basically, check whether the next end-value is equal for all arrays. If not, step over the lowest (in one array only) and repeat. If you get all three equal, that is a (possible) solution - step over all three before searching for the next.
""Possible"" solution because you may need to do a check - if the predicate function can map more than one input value to the same output value, you might have a case where the value found in some arrays (but not the first or last) is wrong.
EDIT - there may be bigger problems when the predicate doesn't map each input to a unique output - can't think at the moment. Basically, the merge approach can work well, but only for certain kinds of predicate function.
",0,2479983
2301172,"
You could change it to check from only where the last move was made.
Or - Checking all states:
Or if you do turn it into a bit by bit system - keep separate X and O boards for ease of updating.  Then you only need 9 bits for x, 9 bits for O, and your winning boards matches are much simpler.  (To find open spaces in this case, just bitwise or the x and o boards)
",3,2301125
2301164,"
You can remove the paranthesis because && has lower priority than ==
You can also define an inline function (or macro) to factor out equality
Note that a==b==c does not return what you need. For instance, 0==0==1 is true in many C-derived languages.
",1,2301125
2301151,"
You could loop it.  For instance to check all of the rows you might do:
And do something similar for the columns. Then you just need to check the diagonals separately.
",1,2301125
2301175,"
I don't know about ""better"", but you could break things up serially:
",1,2301125
2301224,"
Adapted from last week's Code Golf competition. Note that linear patterns along the board matrix begin at a given index and progress along equal intervals.
And if you represent player 1 with a 1, and player 2 with a 2, then those are independent bits and you can test for 3 in a row with bitwise AND.
",1,2301125
2301136,"
Yes, you could do this
Maybe even write a function
It has a hidden side though, it wont work if board[0][0],board[0][0],board[0][1] are equal to 0.
",0,2301125
2301834,"
You can store the indices that make up winning rows, and use a single loop:
I also support Jeff's suggestions of storing players' moves in separate values and using bitwise operations.
",0,2301125
2301252,"
Here is a complete solution, in the form of a check function that verifies if a player (1 or 2, standing for X and O) wins:
EDIT: I have preferred this approach (returning the number of the winning player) rather than simply verifying if there was a winner, as it seemed more practical for use.
Hope it helps!
",0,2301125
2253337,"

Don't change any state variables.  Your code should not include the operator ++ anywhere.  You are not trying to loop over a datastructure and change your local variables in some fashion - you are trying to generate an entirely new but smaller problem each time.  So, all those ++ operators - whether pre or post increment - are red flags.
You have more than one sub-problem. (...so single function recursion isn't ideal).
Let's look at this systematically.
Assume you have a working index_of and you just want to call it with input that's shorter than yours, and that both haystack and needle aren't empty yet.  Then one of two things may be:

The haystack starts with the same letter as the needle, and you just need to look a little deeper to verify this.
 - What happens if verification succeeds - what if it fails? is this an index_of subproblem?
...or the haystack starts off wrong, and you need to look deeper. 
 - Is looking deeper into the haystack an index_of subproblem?

Notice that if the haystack starts OK it doesn't necessarily mean that it starts with the full search string - and if it starts OK but does not start with the full search string, you really don't need to continue looking.  That means that the ""starts-with"" sub-problem is fundamentally different than the index-of sub-problem:

index_of: here, failure to find the search string at index 0 means you need to look further.
starts_with: here, failure to find the search string at index 0 means you need to stop.

It is possible to say startswith(haystack, needle):= 0==index_of(haystack, needle), but obviously index_of is a more complicated problem with a more expensive solution - so you shouldn't do that; it's also more confusing at first.
Identify your base cases - When either needle or haystack are empty, what does that mean?
Good names help clarify things, and recursion is hard to read at the best of times - Yacoby's reply for instance has some meaningful choices here.

Summary
I'm not going to solve your own puzzle for you, but a few tips in recap...

Avoid changing your local variables: you're trying to define a subproblem and then just call the right function for those newer, shorter parameters.  Don't use side-effects, they make things terribly complex.
Recursion doesn't necessarily mean just one function A calling A - it can be any cyclic call graph that eventually terminates; you may use more functions
If needle and haystack start with the same letter, that doesn't mean that the entire needle is at the start of the haystack - and if it is not, you still need to continue searching
This line is wrong: if (*s == '\0') { return 1; }

",9,2252996
2253120,"
This is how I would do it, which is simplify everything by moving it into different functions. Untested but it should hopefully give you an idea.
From the comments

you've got 2 const's in the get_substr_impl method....

Intentional. 

from the main method wouldn't i just call teh get_substr_impl with the same parameters given in get_substr?

I split it as get_substr_impl has an additional (required) argument int index that is required for the inner workings of the function and should always start at 0. While you could call get_substr_impl(""abc"", ""a"", 0);, it looks nicer and is more understandable to call get_substr(""abc"", ""a""); and it avoids errors (like calling get_substr_impl(""abc"", ""a"", 1);)
",4,2252996
2253046,"
First of all, you have two is in your code.  That shouldn't even compile.  
Also, index_of((i++), (s++)); is effectively the same as:
In other words, you calling index_of over & over with the same parameters it was called with the first time. (it'll never return to get to the ++i).
Also, purely stylistic, but since the return type is an int, you should return 0, and save NULL for use with pointers.
",3,2252996
2253116,"
The main problem here is that you are using post-increment, and result of (i++) is i . You have to use ++i
",0,2252996
2210275,"
You can reduce the size of the hash table by only storing hash values and file offsets in it.  If the attributes only have a fixed, relatively small number of values, you are more likely to be able to fit the whole hash table in memory.  You assign an id to each possible value of the attribute, and then for each id value store a big list of file offsets.
Of course the hash table is only going to be helpful if, within the same run of the program, you do several different searches.
The obvious solution would be to stuff the data in a database, but I assume that the OP is smart enough to have realized that already and has other reasons for specifically requesting a non-database solution to the problem.
",2,2210234
2210280,"
If you only search once, you can't do better than O(n).
If a hash index is too big to fit in memory, use an on-disk hash like dbm or gdbm.
EDIT: I'd like to point out that the Berkeley DB tool that KeithB suggested falls into this category on on-disk hashes.  Berkeley DB is not a SQL-using relational database.
",4,2210234
2210274,"
You could use Berkley DB to index this file.  Basically, go through the entire file once, and for each attribute found, store the file position of the attribute.  Berkley DB uses an efficient B-Tree implementation ,and does not require storing the entire index in memory, just the parts that are needed.
I've done this before with good success.
",3,2210234
2210276,"
Sounds like a job for a database system.

How can I possibly index the entire file on various attributes?

You are really left off to implementing a DB solution under the hood. Your best bets are probably some off-line search algorithms and maintaining an index file. 
You may also find Map-Reduce of interest.
",2,2210234
2210702,"
There is no efficient method for directly searching a text file of variable length lines.  Most efficient methods require an overhead to mutate the data into a form better suited to a more efficient search method.  This overhead may not be worthwhile for infrequent searches.  
Infrequent Searching
If the file is only searched once or not very frequently, I suggest a brute force line by line search.  Other methods may waste time setting up the data for a faster search. For example, using your program to find the first line containing one or more attributes.
Frequent searching
The program is required to search the file many times.  In this case, you may want to set up some data structures for better searching.  One technique is to create index files.  These files contain file positions of attributes, sorted by attribute.  Something like [attribute][first occurance][second occurance], etc.
Another alternative is to have your program convert the file into a format that a better tool can use, such as a spreadsheet or a database.  One example is Comma Separate Values, or some tools like to have the values separated by a '|'.
Changing the Generator
And yet, the program that generated the log file could be changed to generate spreadsheet or database friendly log files.  I did this with an embedded system.  I fed the data into the spreadsheet and used spreadsheet functions to analyze the data.  Much easier that writing a program to search (and analyze) the log file.
",2,2210234
2210287,"
Do the search in a separate thread, it may take a while but I think the trade off of building and then searching a hash table is not worth it in this case.
If the user was repeatedly searching for different attributes it may be worth while, but I doubt it.
For the searching try boost::regex or QRegExp.
For just searching a log file, I think you might be over-engineering this with a database or hash table.
",0,2210234
2210599,"
I would build an index using a b-tree or hash table.  I would store the index on disk.  If you are in control of updates to this file you can also update the index when the file is updated.  If you are not in control of updates then use a hash of the file to determine if it needs to be regenerated.
After thinking about this I realized that I commonly search log files with 600k+ lines (100M) using grep on the command line.  It is quite fast.  So, I don't think 100k is a problem unless your files have a lot more data.
You might also want to look into using log rotate if the log files are getting large.
",0,2210234
2210940,"
You could try a straightforward linear search of the file, but launch a worker thread to do your searching.  That way, you can spawn multiple worker threads and start them at different points in the file.  On a machine with multiple processors/cores, this parallelism should produce a performance boost over a plain, single-threaded linear search.
After you do a search, you may want to store the input parameters and the results of that search in a data file.  That way, if the search is repeated in the future, you can use this cached data and will only have to search through the part of the file modified since the last search.
",0,2210234
2211293,"
Don't worry.  Just scan it.
Seriously.  You say this file is 100K lines, which is indeed almost exactly the same size as the /var/log/messages on the computer I'm typing this on.  Well, this is a netbook, i.e. very slow by modern standards -- and yet a straightforward grep of my /var/log/messages is so quick that it is dwarfed by the amount of time taken to print the results to the screen.
So I really don't think you have anything to worry about -- particularly not if this is an interactive process that only runs searches when a human demands it, not some daemon that might be constantly searching for things in the background.  You've quite possibly already wasted more time worrying about this problem than you could ever hope to save by implementing an index!
",0,2210234
2211626,"
Come on, seriously guys. A database for log files?
Log files change all the time or at the least every day. So what you really probably want is to do some log file rotation of some kind, of which there's many premade and failing that could be done in a few hours if you know even a little perl. You probably really don't need C++ for this, either. It will just make dev time slower and the end result buggier.
",0,2210234
2177631,"
Finding all of the divisions shouldn't be hard with a custom grep search. You can easily distinguish that usage from other usages of the / and % character in C++.
Also, if you know what you are dividing, you could globally overload the / and % operator to have a __FILE__ and __LINE__ informing assertion. If using a makefile, it shouldn't be hard to include the custom operator code in all the linked files without touching the code.
",6,2177619
2177665,"
I think the most direct step, would be to try to catch the unhandled exception and generate a dump or printf stack information or similar.
Take a look at this question or just search in google for info relating to exception catching in your particular environment.
By the way, I think that the division could happen as a result of a call to an external library, so it's not 100% sure that you'll find the culprit just by greping your code.
",8,2177619
2178025,"
If I remember right, the ARM9 doesn't have hardware divide so it's going to be implemented in a function call the compiler makes whenever it has to perform a division.
See if your toolset implements the divide by zero handling in the same way as ARM's toolset does (it's likely that it does something at least similar).  If so, you can install a handler that gets called when the problem occurs and you can printf() registers and stack so that you can determine where the problem is occurring.  A possible similar alternative is that your small Linux distro is throwing a signal you can catch.
I'm not sure how you're getting your information that a divide by zero is occurring, but if it's because the runtime is spitting out a message to that effect, you always have the option of finding out where that is handled in the runtime, and replacing it with your own more informative message. However, I'd guess that there's a more 'architected' way to get your code to run (a signal handler or ARM's technique).
",8,2177619
2177655,"
You should use this as an excuse to invest in improving the debug-ability of your device - for both this problem and future issues. Even if you can't get live debugging, you should be able to find a way to generate and save off core dumps for post-mortem debugging (pinpointing the source or any unhandled exception immediately).
",6,2177619
2178073,"
PC-Lint might help, it's like Findbugs for C++.   It is a commercial product but there is a 30 money back guarantee.
",2,2177619
2181130,"
Handle the exception.
Usually the exception will be handed a structure that contains the address that caused the exception and other information.  You will probably have to become familiar with the microcontroller's datasheet or RTOS manual.
",2,2177619
2178305,"
Use the -save-temps for gcc and find the relevant assembly for division in the generated .s file.  If you're lucky it will be something fairly distinctive, possibly even a function call.  If it's a function call you can use weak linking to override it with your own checked version.  Otherwise locating the divisions in the assembly should give you a very good idea where they are in the C/C++ code and you can instrument them directly.
",1,2177619
2250302,"
usually you could modify/override the divide-by-zero exception handler  if you have access to the exception handler routines.
in case of ARM, the division is done by a library routine. and there are mechanisms to inform the user-code, when a divide by zero occurs.
see http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka4061.html
i would suggest to provide a __rt_raise()  as said in the page above.
__rt_raise(2,2) will get called when the divide routine detects a divide by zero.
so you can print the LR register.
and then use addr2line to crossref it against the source line
",1,2177619
2177662,"
The only way to find those conditions is the usual:

try to reproduce the problem without looking at the source (as the bug already happened you should have info on the part of the program that is affected)
if found, check the source for this point and fix it, otherwise:
2.1. grep for each / not followed by a * or / (grep ""/[^/*]"" i think)
2.2. find the conditions for which the code is executed and reproduce it

",0,2177619
2182600,"
The exception already has the address location of the offending divide by zero code. The CPU saves register contents when a exception occurs including the PC(program counter). Your OS should pass this information along (I assumes that is how you know it is divide by zero). Print the address and go look in your code. If you can print a stack trace it would be even easier to solve.
Another option would be to check the differences in your version control software between the last know working version and the first non working version. This should give you a limmited change set within which to search for the problem.
",0,2177619
1977612,"
Hash tables have basically O(1) lookup. This gives you O(m) to lookup m items; obviously you can't lookup m items faster than O(m) because you need to get the result out.
",5,1977576
1977600,"
If you're purely doing look-up (you don't require ordered elements) and can give up some memory, try unordered_map (it's TR1, also implemented in Boost), which has constant-time amortized look-up.
In a game engine, we tested std::map and unordered_map, and while map was faster for insertions (if I recall), unordered_map blew it out of the water for retrieval. We had greater than 1000 elements in the map, for scale, which is fairly low compared to some other tasks you may be doing.
If you require elements to be ordered, your next bet is std::map, which has the look-up times you've posted, and keeps the elements ordered. In general, it also uses less memory than an unordered_map.
",4,1977576
1977698,"
If your container is a vector and the elements are sorted, you can use std::lower_bound to search in O(log n) time. If your search items are also sorted, you can do a small optimization by always using the last found iterator as the start of the search for the next one, e.g.
",3,1977576
1977603,"
boost/tr1 unordered_map and unordered_set are containers backed by a hash table which gives you search in amortized contant time [ O(1) ]
Boost Unordered documentation.
",0,1977576
1977607,"
I suppose if you have a sorted container and a uniform distribution of items then the most efficient type of method would be a recursive bisection search with an execution path somewhat like a tree - calling itself twice whenever all the objects being searched for are in both halves of the bisection.
However, if you choose a container based on a hash-table (boost unordered set, I think?), or something similar, then lookup can be O(1), so searching in a loop really doesn't matter.
EDIT:
note that std::map and std::set are normally (always?) implemented using rb-trees, so are only log(n) for lookup.
",0,1977576
1977728,"
Are you sure that m log2(n) is actually going to be a problem?  If you are using a std::map that is even relatively large, the number of actually comparisons is still pretty small - if you are looking up 10,000 elements in a map of 1,000,000, the number of comparisons should be about 200,000 or about 20 comparisons per target element.  This really isn't bad if your key is just a simple integer.
If you were hashing something that didn't already have a nice key, then I would say go with boost::unordered_map.  I would implement it with std::map first, profile it, and then decide if you want to make the next jump to Boost.
",0,1977576
1980612,"
If you're frequently performing the same projections on your collection, such as extracting elements with a key of ""42"", you could consider maintaining these subsets in buckets. You'd internally maintain a hashmap from keys to vectors of elements with that key, and add elements to the appropriate bucket as well as your primary collection representing ""everything"". Extracting a subgroup of elements is constant time (because the respective collections have already been built), and the memory overhead of maintaining the buckets scales primarily with the number of unique keys in your dataset.
This technique is decidedly less effective if you have a large number of unique key values, and makes insertions and removals more expensive, but it's good for some situations- I thought it was at least worth mentioning.
",0,1977576
1819376,"
I don't think you can do an inplace limitation.
Store the resulting iterators of the matching widths query in another container and use that container to find the matching heights with remove_if.  Then use max_element to find the largest.
If you store the elements as pointers, you could use the same MIC to store the results.
",0,1818821
1819307,"
If I understand your problem correctly, there may be a simpler solution. Just put your MyRects into an STL-Set ordered by value (need to define comparison operator or custom comparison function). The you can create a custom predicate that and use that checks if a given MyRect is within a certain range. Then you use the STL-Algorithm find_if, and hand it the custom predicate. If you make sure that it traverses the sequence in decreasing order (e.g. by using reverse_iterator), it should return the MyRect you are looking for.
Hope that is understandable and applies to your problem.
",0,1818821
1804742,"
It's also possible to use it using OS system calls, readdir on linux for example. boost (and other libraries) will allow you to write portable code for several (all?) OSes.
Here u can find elaborate examples http://faq.cprogramming.com/cgi-bin/smartfaq.cgi?answer=1046380353&id=1044780608
",4,1804734
1804848,"
Yes, it's true: standard C++ does not have APIs for listing the content of a directory.
So you either do it through a library (Boost or others) or through the native calls for the operating system you're using (FindFirstFile/FindNextFile on Windows, opendir/readdir on Unix). Others answers have example code.
But if you just started learning C++ it is probably better to not struggle with these for now. Focus on learning standard C++ for the beginning. Writing the application you had in mind is an useful exercise but I would postpone it a little until after you are more familiar with standard C++.
",3,1804734
1804815,"
Boost isn't the only way of scanning directories but it's probably the easiest way to do it in a platform-neutral way - i.e. without using a platform-specific API (such as Win32).
Here's a simple example using boost:
",2,1804734
1783672,"
A trie is a data structure that can be used to quickly find words that match a prefix.
Edit: Here's an example showing how to use one to implement autocomplete http://rmandvikar.blogspot.com/2008/10/trie-examples.html
Here's a comparison of 3 different auto-complete implementations (though it's in Java not C++).  
When looking up keys, the trie is marginally faster than the Set implementation. Both the trie and the set are a good bit faster than the relational database solution.
The setup cost of the Set is lower than the Trie or DB solution. You'd have to decide whether you'd be constructing new ""wordsets"" frequently or whether lookup speed is the higher priority.
These results are in Java, your mileage may vary with a C++ solution.
",58,1783652
1785340,"
For large datasets, a good candidate for the backend would be Ternary search trees. They combine the best of two worlds: the low space overhead of binary search trees and the character-based time efficiency of digital search tries.
See in Dr. Dobbs Journal: http://www.ddj.com/windows/184410528
The goal is the fast retrieval of a finite resultset as the user types in. Lets first consider that to search ""computer science"" you can start typing from ""computer"" or ""science"" but not ""omputer"". So, given a phrase, generate the sub-phrases starting with a word. Now for each of the phrases, feed them into the TST (ternary search tree). Each node in the TST will represent a prefix of a phrase that has been typed so far. We will store the best 10 (say) results for that prefix in that node. If there are many more candidates than the finite amount of results (10 here) for a node, there should be a ranking function to resolve competition between two results.
The tree can be built once every few hours, depending on the dynamism of the data. If the data is in real time, then I guess some other algorithm will give a better balance. In this case, the absolute requirement is the lightning-fast retrieval of results for every keystroke typed which it does very well.
More complications will arise if the suggestion of spelling corrections is involved. In that case, the edit distance algorithms will have to be considered as well.
For small datasets like a list of countries, a simple implementation of Trie will do. If you are going to implement such an autocomplete drop-down in a web application, the autocomplete widget of YUI3 will do everything for you after you provide the data in a list. If you use YUI3 as just the frontend for an autocomplete backed by large data, make the TST based web services in C++, and then use script node data source of the autocomplete widget to fetch data from the web service instead of a simple list.
",19,1783652
7839288,"
Segment trees can be used for efficiently implementing auto complete
",6,1783652
4041464,"
If you want to suggest the most popular completions, a ""Suggest Tree"" may be a good choice:
Suggest Tree
",4,1783652
1784433,"
For a simple solution : you generate a 'candidate' with a minimum edit (Levenshtein) distance (1 or 2) then you test the existence of the candidate with a hash container (set will suffice for a simple soltion, then use unordered_set from the tr1 or boost).
Example:
You wrote carr and you want car.
arr is generated by 1 deletion. Is arr in your unordered_set ? No. crr is generated by 1 deletion. Is crr in your unordered_set ? No. car is generated by 1 deletion. Is car in your unordered_set ? Yes, you win.
Of course there's insertion, deletion, transposition etc... 
You see that your algorithm for generating candidates is really where you’re wasting time, especially if you have a very little unordered_set.
",2,1783652
1649213,"
If the vector is sorted and contains the value, std::lower_bound will give you an iterator to the first element with a given value and std::upper_bound will give you an iterator to one element past the last one containing the value. Compare the value with the returned element to see if it existed in the vector. Both these functions use binary search, so time is O(logN).
To compare on tracklet.end->t, use:
and pass compareTracklets as the fourth argument to lower_bound or upper_bound
",6,1649139
1649185,"
I'd just use find and find_end, and then do something more complicated only if testing showed it to be too slow.
If you're really concerned about lookup performance, you might consider a different data structure, like a map with timestamp as the key and a vector or list of elements as the value.
",5,1649139
1649153,"
A binary search seems like your best option here, as long as your vector remains sorted.  It's essentially identical, performance-wise, to performing a lookup in a binary tree-structure.
",1,1649139
1649716,"
dirkgently referred to a sweet optimization comparative. But I would in fact not use a std::vector for this.
Usually, when deciding to use a STL container, I don't really consider the performance aspect, but I do consider its interface regarding the type of operation I wish to use.
Really, if you want an ordered sequence, outside of a key/value setup, std::set is just easier to use than any other.

You don't have to worry about inserting at a 'bad' position
You don't have problems of iterators invalidation when adding / removing an element
You have built-in methods for searching

Of course, you also want your Comparison Predicate to really shine (hopes the compiler inlines the operator() implementation), in every case.
But really, if you are not convinced, try a build with a std::vector and manual insertion / searching (using the <algorithm> header) and try another build using std::set.
Compare the size of the implementations (number of lines of code), compare the number of bugs, compare the speed, and then decide.
Most often, the 'optimization' you aim for is actually a pessimization, and in those rares times it's not, it's just so complicated that it's not worth it.
Optimization:

Don't
Expert only: Don't, we mean it

",1,1649139
1649160,"

The vector is ordered in terms of time

The start time or the end time?
What is wrong with a naive O(n) search? Remember you are only searching and not sorting. You could use a sorted container as well (if that doesn't go against the basic design).
",0,1649139
1617904,"
Boost String Algorithms has an icontains() function template which may do what you need.
",1,1617896
1619214,"
You have to specify the language to do case insensitive comparison. For example in Turkish, 'i' is NOT the lower case letter corresponding to 'I'. If the language appears not to be specified, then the comparison is being done with an implicitly selected language.
",4,1617896
1617924,"
You should use the ICU library which provides support for Unicode regular expressions which follow the Unicode rules for case-insensitive matching. The library is available as  C/C++ and Java libraries. Many other languages such as Python support a wrapper for the ICU libraries.
",0,1617896
1619158,"
you could convert both needle and haystack to lowercase (or uppercase) then do the wcsstr().
",0,1617896
1562723,"
You can simplify it quite a bit. A lot of your checks and temporary variables are redundant. Here's a small function that performs your search. I've renamed most of the variables to be a little more precise what their roles are.
",0,1562572
1562628,"
As always when trying to optimize, you have to make a choice:
Do you want the cost during insertion, or during search ?
If you have few insertions, and a lot of search to do in the container, then you need a sorted container. Finding the maximum will be O(1) - i.e. just pick the last element.
If you have a lot of insertions and a few search, then you can stay with an unsorted container, and finding a maximum is O(n) - i.e. you have to check all values at least once to pick the the maximum.
",2,1562572
1562741,"
If you are willing to sacrifice some space, you could add additional arrays to keep track of the maximum distance seen so far for a particular column/row and the node that that distance corresponds to.  
",-1,1562572
1562773,"
Profile it.  Unless this is a major bottleneck, I'd favour clarity (maintainability) over cleverness.
Looping linearly over arrays is something that modern processors do rather well, and the O(N) approach often works just fine.
With thousands of nodes, I'd expect your old Pentium III to be able to a few gazillion a second! :)
",-1,1562572
1524755,"
You can use several options - if you know in advance where the assembly will be located, you can add that path to your application's configuration file:
If you want to search for the assembly at runtime, you can implement a handler for AppDomain::CurrentDomain->AssemblyResolve event:
and you can wire it using something like this:
Just make sure this is done before calling any methods that may use types from the assembly that has to be resolved.
",4,1503266
1503289,"
Is it not the standard .net assembly resolution strategy? See here for a detailed introduction.
",1,1503266
1446086,"
You could try to do a nm -aC <libname> first and grep by the static and global vars (IIRC they should be prefixed with a B/b or a T/t), then look for those vars in the source code. It may narrow down the haystack a little.
",4,1445679
1425683,"
You could use std::numeric_limits<size_t>::max() for elements that was not found. It is a valid value, but it is impossible to create container with such max index. If std::vector has size equal to std::numeric_limits<size_t>::max(), then maximum allowed index will be (std::numeric_limits<size_t>::max()-1), since elements counted from 0.
",15,1425349
1425365,"
Take a look at the answers provided for this question: Invalid value for size_t?. Also you can use std::find_if with std::distance to get the index.
",59,1425349
1425391,"
First of all, do you really need to store indices like this? Have you looked into std::map, enabling you to store key => value pairs?
Secondly, if you used iterators instead, you would be able to return std::vector.end() to indicate an invalid result. To convert an iterator to an index you simply use
",17,1425349
1426223,"
std::vector has random-access iterators. You can do pointer arithmetic with them. In particular, this my_vec.begin() + my_vec.size() == my_vec.end() always holds. So you could do 
As an alternative, there's always std::numeric_limits<vector<type>::size_type>::max() to be used as an invalid value. 
",6,1425349
1425384,"
In this case, it is safe to cast away the unsigned portion unless your vector can get REALLY big.
I would pull out the where.size() to a local variable since it won't change during the call.  Something like this:
",3,1425349
1425446,"
Something like this, I think. find_if_counted.hpp:
Example:
Though I feel like I'm doing something silly... :X Any corrections are welcome, of course.
",2,1425349
1429629,"
If a vector has N elements, there are N+1 possible answers for find.  std::find and std::find_if return an iterator to the found element OR end() if no element is found.  To change the code as little as possible, your find function should return the equivalent position:
I would still use std::find_if, though.
",2,1425349
1425381,"
You probably should not use your own function here.
Use find() from STL.
Example:

list L;
L.push_back(3);
L.push_back(1);
L.push_back(7);
list::iterator result = find(L.begin(), L.end(), 7);
assert(result == L.end() || *result == 7);
",1,1425349
39579291,"
Take a vector of integer and a key (that we find in vector )....Now we are traversing the vector until found the key value or last index(otherwise).....If we found key then print the position , otherwise print ""-1"".
",1,1425349
1424798,"
Try the Boost.Filesystem library.
",15,1424785
1424799,"
You can use SDK APIs Using FindFirstFile and FindNextFile. They are simple :)
MSDN Example: Listing the Files in a Directory
Apart from Boost suggested by @cjm, if you want to use MFC library:
Recursive file search using C++ MFC
",3,1424785
1425483,"
You can use MFC'c CFindFile. WTL has also a port of CFindFile, it's located in atlmisc.h
",0,1424785
1318433,"
There isn't a built-in function doing exactly that.
There is std::find which comes close, but since it doesn't return a bool it is a bit more awkward to use. 
You could always roll your own, to get syntax similar to JIa3ep's suggestion, but without using count (which always traverses the entire sequence):
Then you can simply do this to use it:
",8,1317948
1317957,"
Here an example using find:
",20,1317948
1318849,"
If the vector is ordered, you can also use std::binary_search.
",2,1317948
1317959,"
To get similar syntax as in OP's question:
",1,1317948
1318024,"
You could use std::set This has a find() method.
",0,1317948
1152567,"
There are no standard functions to do this in C++ - you need to roll your own. This apparent lack is because the concept of uppercase and lowercase, and indeed of words, is a lot more complicated than it might first seem. Your best bet is to use a regular expression library, such as the one that comes with Boost.
",3,1152552
1152568,"
For Java, see Pattern. You can use \b and \B to match word boundaries. Case sensitivity can be enabled/disabled using the CASE_INSENSITIVE flag.
",2,1152552
1152577,"
There's no single function that will do exactly that. It's still fairly trivial for simple cases: get the file in memory (e.g. std::vector<char> buff(file_begin_iter, file_end_iter);) and then find what you want. (std::search)
",1,1152552
1152758,"
In C++ you can use regular expressions in 
if your compiler is up to date. Regular expressions support match case by default. Using \b Word boundaries you should be able to find whole words only.
",0,1152552
1609661,"
In java:
http://java.sun.com/docs/books/tutorial/essential/regex/bounds.html
You can use the ""\b"" word boundary.
P.S.: when you compile it remeber scape the slash:
In ex.: To found the word 'dog' --> Pattern p = Pattern.compile(""\bdog\b"");
",0,1152552
1145881,"
begin() and end() on all STL containers provide access to elements of those collections. Type of those elements is known as value_type of the container. For std::map<Key, Value>, its value_type is std::pair<Key, Value>. Therefore, your find function is trying to find a pair<int, int> which is equal to 5. Since there's no operator== defined to compare pair<int, int> and int, you get the error.
The correct way to do this (so long as you want to avoid member find()) is to use std::find_if:
You could also overload operator== for pair and int to do what you want, but it's a very hackish way (because it will affect all your code, and because such a comparison has no meaning in general).
",8,1145849
1145859,"
find() requires a parameter that can be compared to *iterator. For your map, this will be pair<int,int>. You'll need to create a dummy pair, plus a comparison functor to compare the pairs.
",3,1145849
1145873,"
Just use m.find(5)
",2,1145849
1077271,"
For searching subdirectories in native code on Win32, you need to do it yourself, using FindFirstFile and then recursing into subdirectories.
The return value of FindFirstFile isn't a file handle - the file information is contained in the WIN32_FIND_DATA structure returned.  The handle is used in calls to FindNextFile to continue the search.  To get a full path name during your search, you'll need to keep track of what directory you are currently in and append the discovered directory names to the path.
SearchPath only searches in the PATH environment variable or the first parameter if present and doesn't search subdirectories.
",1,1077258
1077279,"
GetCurrentDirectory() should tell you the path:
http://msdn.microsoft.com/en-us/library/aa364934(VS.85).aspx
and the second argument of FindFirstFile():
http://msdn.microsoft.com/en-us/library/aa364418(VS.85).aspx
which is a WIN32_FIND_DATA Structure should tell you the name of the file:
http://msdn.microsoft.com/en-us/library/aa365740(VS.85).aspx
",0,1077258
917079,"
Assuming that your pStr is null terminated and that uiSize is the number of wchar_t of readable memory at pMem:
",2,916455
916529,"
Probably not the answer you were looking for, but perhaps the best solution here would be to properly initialise your strings and pointers. If your memory contains garbage, why not do the decent thing and set
If it really is just an arbitrary bit of buffer, you might be better off using something like memcmp and slide the memory buffer's pointer along N characters (where N is the number of characters you're interested in minus the length of the string you're comparing). That might not be the most efficient implementation, but should be a fairly robust approach I should think.
[Edit] Your question intrigued me enough to do a little experimentation. Given that you seem to be looking for more C-styled answer, here's a little snippet of code I came up with to elaborate on my memcmp suggestion:
That snippet compiled under Visual Studio 2008 as a Win32 console app. Gives me the following:
The FindStringInBuffer function is the bit you'll want and if you need to cope with wide characters, you'll need to do some conversion, but this should at least give you some ideas that you can proceed with. If you do come up with a wchar version, I'd be interested to see what the solution looks like (I've not dealt with them myself).
",6,916455
916558,"
There is, alas, still no standard ""safe"" string library I'm aware of. BSD has strnstr for this, but it's not in the glibc, or Microsofts libc as far as I know. I don't know of any ""good"" choice for this, other than a roll your own.
For reference, the Microsoft safe string library is listed at http://msdn.microsoft.com/en-us/library/wd3wzwts(VS.80).aspx and given in more detail (with migration guides) at http://msdn.microsoft.com/en-us/library/bb288454.aspx.
",2,916455
904654,"
You could make your linearSearch function to return the index of the search term in the array. Here is a sample program:
We use the strcmp() function to compare the strings. It returns zero if strings match and nonzero if they don't. To use it, you need to include the string.h header.
But, as others have suggested, you should use STL if you can. 
",2,904641
904651,"
I would recommend to learn about the C++ standard library, which would help you very much. For example,
Why implement linearSearch yourself? c++ already has std::find which does it for you!
Moreover, if you use a set instead of a vector, you can now use std::binary_search which is O(log n) instead of O(n), since a set is sorted.
",9,904641
904693,"
To declare an array of strings, use this syntax
This is an array of pointers to characters (""Hi"" evaluates to a const char* pointing at the 'H'). The compiler will figure out how many elements are needed to store your array (hence the []) in this case it will always be of size 3.
Overall, I agree with rlbond's answer - you should use the STL. 
",3,904641
904696,"
No, you don't need a two-dimensional array.
Here is a way to declare string arrays:
or
Right after experimenting with C++ you should learn to use STL.
",2,904641
904649,"
This article contains a string search function.  It should also give you insight into how to properly structure your character arrays.
",0,904641
904674,"
If you dont want to use strings, and stay with char arrays you can use strcmp to compare 2 words.
The thing to remember with strcmp is that it returns the index of where the word was found, so you if you want only to find words in the begining you do it like this:
Depending on what you are doing and how big your array is going to get, you should consider looking into having hashes of the strings to increase preformance.
",0,904641
758072,"
Use a breadth-first search. As you access a node that isn't equal to the query value, you push that node onto the back of the queue. Process nodes from the front of the queue first. The first match you find will be the one closest to the root.
",4,758041
758076,"
If you do it breadth-first-search style, i.e. first look at all the Bs, then all the Cs, etc., your match node will automatically be the closest.
",2,758041
758086,"
It seems as if you are interested in performing a BFS (Breadth Search First). The simplest way of implementing it is not by recursion but rather with a FIFO queue where you add the neighbor elements to the one you are testing at the end, and extract the first element from the queue to perform the next check.
The order of insertions would be [ A(1), B(2), B(3), C(3), ... ] and you will find B(3) before testing C(3).
",1,758041
758069,"
Sounds like you are asking for a Breadth-first search.
I think your question may be related to a homework assignment, so I won't divulge more details here.
",1,758041
698544,"
maybe std::lower_bound std::upper_bound will help you.
",12,698520
701141,"
Here is a generic solution using std::lower_bound:
You'll notice that I used Bidirectional Iterators, meaning that the function can only work with iterators that can be both incremented and decremented. A better implementation would only impose the Input Iterators concept, but for this problem this should be good enough.
Since you want the index and not an iterator, you can write a little helper function:
And now you end up with a code like this:
which gives the following results:
",5,698520
698552,"
Is the array guaranteed to be in ascending order?  If so, give std::lower_bound  a look.
",3,698520
699038,"
I think my example do exactly what you want :
(I use std::min_element and a functor)
",2,698520
701326,"
",0,698520
686144,"
std::find() should work:
",10,686131
686139,"
Use std::find() from the STL-algorithm-library, or the find()-method of your particular container.
",15,686131
686201,"
You can use STL algos on containers other than just STL containers.  For example, you can std::find() in a C-style array:
",5,686131
686200,"
I suppose you need the index and not the iterator.
",4,686131
686164,"
In addition to the STL possibility (std::find) already mentioned there is the POSIX function lsearch (with c semantics).
",3,686131
514250,"
From MSDN:
If you refer to the code fragment in that page:
You'll see that you can call FindFirstFileEx, where argv1 is a string (LPCSTR) pattern to look for, and &FindFileData is a data structure that contains file info of the found data.. hFind is the handle you use on subsequent calls with FindNextFile.. I think you can also add more search parameters by using the fourth and sixth parameter to FindFirstFileEx.
Good luck!
EDIT: BTW, I think you can check a file or dir's attributes by using GetFileAttributes() .. Just pass the filename found in FileFindData.. (filename can refer to a file's name or a directory name I think)
EDIT: MrVimes, here's what you could do (in pseudocode)
find the first file (match with *)

Check the file find data if it is ""."", "".."" (these are not really directories or files)


if check passed, check file find data if it has the attributes you are looking for (i.e. check filename, file attributes, even file creation time can be checked in the file find data, and what not) and do whatever with it


if check passed, do whatever you need to do with the file

if check failed, either call findnextfile or end, up to you


Something like that..
",3,514199
514212,"
I think you use FindFirstFile to find all files and ignore the ones whose WIN32_FIND_DATA values don't match your search criteria.
",0,514199
514275,"
Well you could use it to search for *.doc, *.txt and *.wri by passing those values as the name to search for:
To search by date is a little more complicated, but not overly so:
",0,514199
514286,"
You need to do two searches.  The first is just to find the subdirs, and you do that without any file spec.  The second search for the files uses the file spec.
",0,514199
218014,"
CString::Find() is what you want, one of the overloads does sub-string searching.
",9,218003
218010,"
string::find
",2,218003
218013,"
Have you tried CString::Find?
It's not STL or boost but since you have two CString's it seems the most reasonable method to use.
",2,218003
216813,"
There is a way - you use the Preprocessor's Token-Pasting Operator. This allows you to create a name based on a variable, so you'd specify:
and you'd be able to create variables named snapshot1, snapshot2 etc:
However, I'm not sure this is what you really want, I've maybe used this technique once in practise, and that was for a code generator.
",1,215961
216005,"
I think you're asking how do you create and keep lots of objects when you don't know how many there will be.
You need to create an array of the objects.  Then you can access them as snapshot[1], snapshot[2]... snapshot[i].
",4,215961
215970,"
You could use a queue from the standard template library, then create a function that creates a Snapshot object and puts in into the queue.  Give this function a static variable which gets incremented every time it is called and written into an id field of the snapshot.
http://www.csci.csusb.edu/dick/samples/stl.html
http://www.cppreference.com/wiki/stl/queue/start
",0,215961
215990,"
I think we need more information for this.  If you're simply popping these out of a queue, why do you care what they are named?  Objects in a queue are not normally numbered, unless you're implementing it in an array.
",0,215961
215995,"
Sorry, the whole queue thing kinda causes uneeded confusion. 
Let's take another example. So for this puzzle, the number of pieces in the puzzle are specified by the user. The way I am designing the program is that each Piece of the puzzle is it's own object.
So when I go about creating these Pieces, can I use some kind of variable naming schemes to go about naming these Pieces. so something like this just as an example...
",0,215961
216004,"
You cannot dynamically create variable names in C++, at least not without some (imaginary?) add-on.
edit: As an aside, I did an assignment that I assume is similar to yours in an AI class, where we covered basics like BFS, DFS, and A*.  Not once was it necessary to have uniquely named objects for the ""snapshots"", and I used queues.
edit2: and if you need to keep track of how many Snapshots you have, create a count variable that increments every time you create the object.
",0,215961
194509,"
A couple of thoughts.

You will have to open the file separately from each process, otherwise they will share a single file descriptor and thus have a shared position in the file (or not, see the comments, as this may be system specific...).
You may not see the speed increase you are hoping for due to disk access and/or cache miss patterns.

You might be able to beat both issues by memory mapping the file (well you still risk an increased cache miss rate)...

How badly do you need this? It runs a real risk of being premature optimization. I would recommend against touching the problem without a compelling need. Really.
",3,194499
194522,"
Consider why you think you need to parallelize this, and if you're going to see any actual performance benefit. You're likely to be limited by disk access time, and there's overhead to forking. Your best option might be to do a standard single-threaded search (probably with a regex).
",2,194499
194667,"
Assuming you really think this is necessary (or is this homework ?), a (relatively high-level) way to go could be:


compute the size of the file to search (e.g. with fopen, fseek(file, END), fclose)
associate to each process two offsets in the file: a search start offset, and a search end offset:
startIndex = indexOfProcess * fileSize / numberOfProcesses
endIndex = (indexOfProcess + 1) * fileSize / numberOfProcesses

You have to take into account the fact that the string to seach can span the slices for two or more processes by adding some overlap (which will be a function of the string size).
fork, open the file in each process (in read mode), fseek to the start index, search the string as if you had a single file of size (endIndex - startIndex), and dump the results to the screen (or, if you have more specific requirement, tell us about them).

",1,194499
194690,"
Either this is homework, or this is useless. The bottleneck is in disk bandwidth, not CPU power. You will only slow down by using simultaneous accesses.
",1,194499
7599525,"
Check boost::filesystem library on http://www.boost.org/doc/libs/1_47_0/libs/filesystem/v3/doc/index.htm, there you have a recursive_directory_iterator class.
",4,7599351
7599900,"
There isn't a C++ thing per se, but usually directory search is slow because of IO, and because you must stat each file (or whatever the OS equivalent is non-unix systems) to find out anything besides its name.  One way to make this faster would be to keep write a server that keeps the inodes and filenames in memory. Of course the difficulty is that the inode information is not static.  You would need to listen to file system changes to keep your cache up to date.  That is definitely possible in linux, but I have no experience with it on other systems. As you can see, another theme of this problem is that it is very system and possibly filesystem dependent.  Maybe a system-independent library like Boost::Filesystem can help, but I doubt it implements directory update callbacks.  
Maybe just install Google Desktop?
",1,7599351
7600719,"
Here's a windows solution (http://ideone.com/5dFVf)
This uses a breadth-first search, which takes a little more RAM and is slightly more complicated, but faster due to caching.
",0,7599351
7655306,"
Searching is an OS feature these days, and those who are trying to implement third party indexing are giving up.  Even Google Desktop is not being updated and most consider it dead:
https://superuser.com/questions/194082/is-google-desktop-search-a-dead-project
If you install a search server on someone's computer and get caught hogging disk and CPU--and you do not have a very, VERY good reason for doing so--you will not only waste a lot of time writing code and patching bugs but you will also alienate your users.
For most cross-platform apps, letting the users find the files in the Explorer/Finder/Nautilus and then making your app accept multi-file drag and drops is a better answer.  Also, most ""common dialogs"" for opening files provide built in search functionality now.
If you're trying to write a search-accelerated tool for a specific platform, hook into that platform's API, which may even permit you to supplement its index.  Here's Microsoft's Programmatic Search API:
http://msdn.microsoft.com/en-us/library/windows/desktop/bb266517(v=vs.85).aspx
OS/X has the spotlight API:
http://developer.apple.com/library/mac/#documentation/Carbon/Conceptual/SpotlightQuery/SpotlightQuery.html
I'm not quite sure if there's ""canon"" for search in the Linux world, but most all of the relevant versions of Ubuntu now ship with Tracker:
http://live.gnome.org/Tracker/Documentation
",0,7599351
7532003,"
If you do have Windows Desktop Search or Windows Search operating (or the target computer might have it, anyway), you can use ISearchFolderItemFactory (or ISearchDesktop, for WDS) to have it do a search for you.
If there's no pre-existing index, nearly the only way to do this is with FirstFirstFile, FindnextFile and FindClose. I generally recommend against the obvious recursive method of doing the search though -- a breadth-first search is usually at least as fast, and depending on the situation, can easily be twice as fast.
To do a breadth-first search, you maintain a collection (I usually use a priority queue, but a normal queue, stack, etc., will also work) of sub-directories you haven't searched yet. You start a search by entering the starting directory into the collection, and then having your search function do it's thing. Your search runs in a loop, continuing searching until the collection is empty. When it encounters a directory, it adds it to the collection.
",3,7531882
7531993,"
Perhaps not the answer you're looking for, but having an index of available files in the file system optimized for the search patterns you support would be fastest.
If you're using some API to do it, it simply depends on how well you write code, profile and improve it. :)
",2,7531882
7270565,"
you should store the pop()ed value, and the recursive call result, and push() the pop()ed value back, before returning.
your else should look something like that: [other than it, it looks fine]
(*)forgive me for not declaring temp and retVal, You can understand the general idea from this..

EDIT:
I decided to add a simple example what is happening, assume your stack is 
and you are call getNth(s,3): this what will happen to the stack
after 1st pop() and getNth(): [stop condition was not reached, so keep going]
2nd pop(),getNth(): [again, keep going]
now, when you check if s.top() == n, you realize they are! so you return n.
when coming back from the recursion, s.push(temp) is called, and temp==2, so we get:
and we return retVal again, now back from the recursion, we use s.push() again, and we get:
the original stack! and return the same returnVal, that was returned by the recursion!
NOTE: This is not your question, but the name of the function implies you don't want to return the value you were searching for, but rather the nth element in the stack, meaning, if your stack is:
getNth(2) will need to return 8, and NOT 2, as your question describes.
But I cannot possibly know that for sure, and if it is the case, I think you have enough tools to handle this question without too much problems!
good luck!

EDIT 2:
after the discussion in the comments, it is clear that the OP wanted something a bit different then what the original question describes, so therefore the extra edit:
Your solution is searching for an element and returns it, probably what you want to do is COUNT until these element, and then return, should be something like that [again, not declaring all variables, it won't compile, it's just a direction]:
",9,7270533
7208592,"
Because you pass resultNode into the function as a pointer by value, its original value never changes. Think of TreeNode* as literally nothing more than a number representing a memory address; when you reassign it:
This modifies the copy that searchNode has, but not the original pointer in the code which invokes searchNode. Take this simpler example:
resultNode's value doesn't change from NULL for the same reason that x doesn't change from 0 when the function Bar is invoked. To fix this issue, pass the pointer in as a pointer to a pointer, or a pointer by reference:
... or:
",2,7208535
7208626,"
Your resultNode pointer is being passed by value, not by reference. So when the function call completes the pointer on the calling side does not receive a value.
Your algorithm looks fine :)
",0,7208535
7198372,"
Yes. As long as none of your threads do a write
i.e. Construct the data structure in memory
Use as many threads to find/read as you require.
If the leaf needs altering put a mutex there.
",1,7198332
7169488,"
Quick example of what you want  to do.
String.find(): http://www.cplusplus.com/reference/string/string/find/ 
String.subStr(): http://www.cplusplus.com/reference/string/string/substr/
",1,7169320
7169544,"
It's not clear with which part of the problem you are stuck, so here is a starter for you.
To get the parts of the strings between ""given string"" and the final '/' (where present):
To insert these parts into a new set (output) to guarantee uniqueness you can use the following:
You may wish to pass given_string into get_pertinent_part(), in which case you'll need to convert it to a functor:
You can then call it this way:
To output the new set:
Sorting the results is left as an exercise.
",1,7169320
7169511,"
The easiest way I can think of, using the standard C functions, would be:
The first thing that occurs, is finding the substring, string1, in the string we are analyzing, being string2.  Once we found the starting point, and assuming it was there at all, we add the length of that substring to that starting point using pointer arithmatic, and then find the resulting string's length by subtracting the starting position from the ending position, which is found with strchr(position, '/').  Then we simply copy that substring into a buffer and it's there to print with cout.
I am sure there is a fancy way of doing this with std::string, but I'll leave that to anyone who can better explain c++ strings, I never did manage to get comfortable with them, haha
",0,7169320
7083037,"
The problem with the suffix tree approach is that you have to start the suffix search for each letter of the text to be searched. I think the  best way to go would be to arrange a search for each keyword in the text, but using some fast search method with precomputed values, such as Boyer-Moore.
EDIT: 
OK, You may be sure the trie may be faster. Boyer-Moore is very fast in the average case. Consider, for example, that strings have a mean length of m. BM can be as fast as O(n/m) for ""normal"" strings. That would make 100*O(n/m). The trie would be O(n*m) in mean (but it is true it can be much faster in real life), so if 100 >> m then the trie would win.
Now for random ideas on optimization. In some compression algorithms that have to do backward searchs, I've seen partial hash tables indexed by two characters of the string. That is, if the string to check is the sequence of characters c1,  c2, and c3, you can check wether:
then for c2 and c3, and so on. It is surprising how many cases you avoid by doing this simple check, as this hash will be true only each 100/65536 times (0.1%).
",4,7082860
7082927,"
This is what I would do.

Put all your keywords in a hash table of key-value pairs, with the number of occurences of the keyword as the value and the keyword as the (you guessed it) key.
check each word in the text blob against the hash table. if the word is in the hash table, increment the occurrence count associated with it.

This is a good way because hash table look up is (or should be) amortized O(1) time. The whole algorithm has linear complexity :).
EDIT: If your keywords can contain spaces, you would need to make a sort of DFA. Scan the file until you find a word which one of your key ""phrases"" starts with. If the second (or however many) next words are part of the ""key phrase"", then increment the occurence count.
",0,7082860
7083347,"
You seem to be groping your way towards http://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_string_matching_algorithm 
To quote:
The complexity of the algorithm is linear in the length of the patterns plus the length of the searched text plus the number of output matches. Note that because all matches are found, there can be a quadratic number of matches if every substring matches (e.g. dictionary = a, aa, aaa, aaaa and input string is aaaa).
",0,7082860
7104402,"
If it is a industrial application, use Boost Regex
It is tested, fast and chances are that it will save you a lot of pain.
",0,7082860
6966484,"
You know the number of elements and the data structure allows you to do a random access to any element:
",1,6966462
6966495,"
The functions seekg and tellg of C++ file streams will allow you to navigate though the file.
",1,6966462
6919649,"
If your goal is to find if there is a Human with a given name, then the following should work for sure:
",12,6919405
6919477,"
[Complete rewrite; disregard the comments]
The wording has been changed from C++03 to C++0x. In the latter, there is no more requirement for T to be less-than comparable, presumably to alleviate this unnecessary restriction.
The new standard only requires that comp(e, value) implies !comp(value, e). So as long as your comparator implements both directions, you should be able to legally search a string as the value with a comparator functor that implements both asymmetric comparisons (i.e. your ""Attempt 3"").
",5,6919405
6919617,"
I think what the standard is saying here is that the expression fucntor(a, b) needs to be a valid strict weak ordering, no matter if the algorithm decides to do something like functor(*begin, *(begin + 1)). Therefore, I think your comparator would need to supply an overload of operator()(Human, Human) in order to be conforming.
That said, I think this is one of those things not explicitly allowed by the standard, but for which few or no implementations exist which take advantage of the latitude offered by the standard.
",0,6919405
6919659,"
I don't see it requiring anywhere in the standard that the types of the values passed to the comparison function (or to the < operator) by binary_search must be the same. So, formally I think it is perfectly fine to use a comparator that works with two differently types values.
",0,6919405
6638285,"
This is a tall order, and you'll have to develop some of the logic yourself. However, here's a skeleton solution:
1) Write a function that ranks rules according to their relevance for a given set of data:
2) For each piece of data, create a sorted ranking of the rules. For instance, you could keep a bunch of iterators around. Then find the service that matches the most relevant rule set.
I'm supposing that all your rules are kept in RuleCollection rc;, some container of value type rules.
Edit: Fixed multimap element insertion -- multimap does not have a [] access operator for obvious reasons.
",2,6635025
6633308,"
First of all, if you are using a map, you cannot have multiple entries with the same key. E.g. you can't have both Accept-Language : RU and Accept-Language : ru-RU,ru;q=0.8,en-US;q=0.6,en;q=0.4 because they have the same key `Accept-Language'. Perhaps in your case you should use a vector of pairs, or a multimap.
Next, your question consists of 2 parts:

How to check, whether some element (such as string or pair)
matches a pattern. 
Assuming you have
such a check, how to apply it to
each element in a container.

The solutions to each part:

You can implement a function that takes a string, or a pair (depends on the type of container and stored element that you choose), and checks whether it matches your criteria. You can find the functions such as string::find_first_of to be useful for that matter. The regex libraries can be even more helpful, though they are not part of the STL.
You can apply this function on every element of your container using find_if algorithm.

",3,6632580
6584307,"
Each bit is independent, so in a preprocessing phase[*] you could classify each entry 32 (or however big your int is) times. Each classification stores 2 sets: those which match at that bit when key is 0 and those which match when key is 1.
That is, if value == 1 and mask == 0 at that bit, then that classification doesn't store that entry at all, since it doesn't match any value of key (in fact, no matter what scheme you use, such entries should be removed during any preprocessing stage, so no classification should store an entry if even one bit is like this). If both 0, store into both sets. Otherwise store into one of the two sets.
Then, given your key, you want to find a fast intersection of 32 sets.
Depending on the size of the original array, it may be that the best way to store each set is a giant bit array indicating whether each entry in the array is in the set or not. Then finding the intersection can be done a word at a time - & together 32 words, one from each bit array. If the result is 0, keep going. If the result is non-0, you have a match, and the bit that's set in the result tells you which entry is the match. This is still linear in the size of the array, of course, and in fact you're doing 31 & operations to check 32 entries for a match, which is about the same as the simple linear search through the original array. But there's less comparison and branching, and the data you're looking at is more compressed, so you might get better performance.
Or there might be a better way to do the intersection.
If keys tend to be re-used then you should cache the results of the lookup in a map from keys to entries. If the number of possible keys is reasonably small (that is, if significantly less than 2^32 keys are possible inputs, and/or you have a lot of memory available), then your preprocessing phase could just be:

take each entry in turn
work out which possible keys it matches
add it to the map for those keys

[*] Without any preprocessing, obviously all you can do is check every array member until either you find a match or else you've checked everything.
",4,6583835
6583857,"
Since you don't have extra information (for example, that the array is sorted) you need a linear search - traverse the array and check the condition - pseudocode:
",2,6583835
6583897,"

If you instead had a map of keys to Entries, then this would be really easy.
If your array were sorted by key, then you could do a lexicographic binary search with some small effort. [actually, maybe not!]
As it is, you're just going to have to traverse the array until you find what you're looking for. That is, iterate from start to end and stop when you find it.

As an aside, this is a great example of how a choice of data structure affects the availability of algorithms down the line. You can't just throw algorithms at a problem if you picked the wrong data structures in the first place!
",1,6583835
6583922,"
A linear search would of course work, but if you need many lookups with the same key, you could try sorting the range first according to (key & mask). If you only have a few, fixed keys, you could try using a boost.multi_index, with one index for each key value.
",0,6583835
6584113,"
If the mask varies arbitrarily for each entry, I don't see much
alternative to a linear search.  If there are significant constraints on
mask, such that only a few values are possible, it might be better to
use some sort of map for each value of mask, doing a linear search
to find the first map which contained the value you are looking for.
Alternatively, if the masks only concern a few bits, it may be worth
using a multimap, ordered by value masked with an and of all of
the masks, and indexed with key handled the same, then a linear
search using the full key to find the exact match. 
",0,6583835
6589118,"
If the number of zero bits in your mask is small, you could duplicate the entry for each ""don't-care"" bit in the mask. For example if value=0 and mask=0xfffe then you'd put an entry in the table for key=0 and key=1. For value=0 and mask=0xfeef, put 4 entries in the table: key=0x0000, key=0x0010, key=0x0100, and key=0x0110. Now you can sort the entries and use a binary search, or use a binary search structure such as std::map.
",0,6583835
6522448,"
There is no ublas-specific function (as far as I can tell), you will have to scan the matrix the usual way -- through iterators or through indexed access:
test: https://ideone.com/qhW9b
",1,6516958
6487893,"
Your requirement specification is unclear, for example - where does ""121"" appear in ""12121""... just at the first character (after which searching continues at the 4th), or at the 3rd as well?  The code below uses the former approach.
",2,6487693
6487928,"
This is one way to do part 1.  Not sure I would I describe it as high quality but maybe on the minimalist side. 
",1,6487693
6447881,"

Do I need to copy the whole file into a string in memory first?

No.

Or is there a more efficient way to do it, without the need for copying it into a string?

Of course; open the file with an std::ifstream (be sure to open in binary mode rather than text mode), create a pair of multi_pass iterators (from Boost.Spirit) around the stream, then search for the string with std::search.
",5,6447819
6447870,"
First of all, don't worry about corrupted characters. (But don't forget to open the file in binary mode either!) Now, suppose your search string is n characters long. Then you can search the whole file a block at a time, as long as you make sure to keep the last n-1 characters of each block to prepend to the next block. That way you won't lose matches that occur across block boundaries. So you can use that handy find function without having to read the whole file into memory at once.
",2,6447819
6447865,"
if you can mmap the file into memory, you can avoid the copy.
",0,6447819
6447837,"
There are a number of fast string search routines that perform much better than testing each and every character.  For example, when trying to find ""something"", only every 9th character needs to be tested.
Here's an example I wrote for an earlier question: code review: finding </body> tag reverse search on a non-null terminated char str
",1,6447688
6447815,"
For a 5-10MB file I would have a look at writev() if your system supports it.  Read the entire file into memory since it is small enough.  Scan for the bytes you want to drop.  Pass writev() the list of iovecs (which will just be pointers into your read buffer and lenghts) and then you can rewrite the entire modified contents in a single system call.
",0,6447688
6447880,"
First, if I understand your meaning in your ""How can I search efficiently"" subsection, you cannot just skip a few megabytes of data in the search if the target string might be in those first few megabytes.
As for loading the file into memory, if you do that, don't forget to make sure you have enough space in memory for the entire file. You will be frustrated if you go to use your utility and find that the 2GB file you want to use it on can't fit in the 1.5GB of memory you have left.
I am going to assume you will load into memory or memory map it for the following.
You did specifically say this was a binary file, so this means that you cannot use the normal C++ string searching/matching, as the null characters in the file's data will confuse it (end it prematurely without a match). You might instead be able to use memchr to find the first occurrence of the first byte in your target, and memcmp to compare the next few bytes with the bytes in the target; keep using memchr/memcmp pairs to scan through the entire thing until found. This is not the most efficient way, as there are better pattern-matching algorithms, but this is a sort of efficient way, I suppose.
To ""delete"" n bytes you have to actually move the data after those n bytes, copying the entire thing up to the new location.
If you actually copy the data from disk to memory, then it'd be faster to manipulate it there and write to the new file. Otherwise, once you find the spot on the disk you want to start deleting from, you can open a new file for writing, read in X bytes from the first file, where X is the file pointer position into the first file, and write them right into the second file, then seek into the first file to X+n and do the same from there to file1's eof, appending that to what you've already put into file2.
",0,6447688
6413570,"
Python, just read in line, split, chuck the first part, concat the hex into a string, and search. Something like this would work:
Or use a regex, but you get the basic idea.
",1,6413361
6413887,"
You could use a circular buffer.

Open the file
Read a line
Read address and discart it
Read first value and put it into the buffer
Read next value, and throw last value of the buffer (std::list could be good for that)
Check if buffer contains the pattern
Loop through 5 up to the end of the line
Loop through 2 up to the end of the file

",0,6413361
6515015,"
I just found a satisfactory answer:
SphinxQL is simply a language for querying Sphinx. 
SphinxAPI is a framework that allows you to compute results based on the queries.
The queries could still be via SphinxQL or they could be via the API's syntax...it doesn't matter...SphinxQL and the SphinxAPI are different objects that accomplish different things (as highlighted above)
",2,6331552
6339347,"
SphinxAPI is a legacy. That is why I'd rather go with a flow with a API than switch to SphinxQL in production. But for new projects SphinxQL is the only choice as it is evolve quicker and gets all features first. The next big thing that using SphinxQL you don't tie to developer of API for not officially supported languages or platform instead you could use any MySQL client \ library.
",1,6331552
6524765,"
Of course, while not very space efficient, you can of course precompute the matches for all 256 bit patterns.  You would have an array of 256 lists, each list would contain each code in the codebook with those bits set.
You can get the first match in 256 bytes (11 words of memory).
initialization:
Lookup:
",2,6270399
6524759,"
If you are only doing 8-bit lookups, it would be trivial to precalculate all your answers and then just store them in a 256 entry table.  That way you would get constant time queries, and the memory storage would only be on the order of 256 entries.
",1,6270399
6524569,"
One optimization could be to store your codes in different buckets depending on how many bits are set. When you're looking up codes you would just have to look through 1/2 of the codes (in average, if codes are distributed uniformly). This is a very simple optimization, but the complexity of the algorithm remains the same (O(n)). Sorting a single array based on the number of bits set would enable you to do similar optimizations without having to store the codes in buckets.
Sidenote: I think 200 is a very small number and I don't think you would see much change in performance from a linear approach no matter how you optimize this unless you do a lot of lookups. But I'm guessing that's not the point of this exercise...
",1,6270399
6458225,"
If I understand, you're saying that if response has ONLY bits 1,3,5 set, then you want all codes in codebook that have flags 1,3,5 set and you don't care about bits 2,4,6,7,8. 
If so, here's your pseudo code:
",0,6270399
6525551,"
I'm posting another answer because I got a new (and better suggestion):

Sort the codebook by value
For each code you're looking up, do first a binary lower bound search to find the first possible match (any value less than what you are looking up cannot be a match)
Search through the range from and including the first possible match until the last element to see if there are any matches.

The algorithm is still linear, but with an O(log N) lookup to cutoff (hopefully) most values. Lookup on small values would still be expensive, lookup on big values will be cheaper.
You could also maybe use a Bloom filter to do an initial search to cutoff most cases, and doing a linear search on the remaining. The filter may have false positives, so you would have to a linear search when the filter returns true. This datastructure requires you to have a good deal of independent hash functions (e.g. based on number of bits set, the product of all set bits, odd vs even, the number itself etc.). This could be a good optimization if you're expecting codes to be found only occasionally (if the filter returns false, the code is guaranteed to not be in the codebook). However, I suspect that this is more of theoretical interest than an actual optimization.
",0,6270399
6152230,"
I haven't done this, but Developing Filter Handlers for Windows Search on MSDN seems like a good starting point.
",2,6152126
6146459,"
This is a bit difficult to answer without knowing how you want to specify the data you want.
If you can specify the necessary data using regexes, Python will probably be about equally efficient, and a bit quicker to write -- but you may be able to do the job with something like grep even more easily.
If it'll take a lot more processing to figure out what data to display, Python may start to get quite a bit slower -- it can be quite fast as long as the Python part is mostly a fairly ""thin"" shell and most of the heavy lifting is done by various libraries. It can get quite a bit slower if you're doing serious/significant processing in Python itself.
If you write in in C++, you'll get more or less the opposite situation -- as long as you're reasonably careful, chances are pretty good that performance won't be an issue. The real question will be how much work it takes to produce what you want. Without knowing anything about what data you're looking for, how you want to display it, etc., it's nearly impossible to guess about that though.
edit based on comment: A pattern like Data = #### sounds like pretty much a classic case for a regular expression, for which grep will work just fine.
This is also something Python can probably do perfectly well, but if you did decide to do your own in C++, it could look something like this:
This assumes you're looking for the Data = # pattern happening somewhere in the line. If you want to only consider it a match if that's the whole line, change the regex_search to regex_match instead.
The other assumption is that you're using a relatively recent compiler that includes the standard regular expression classes. This is the case with VS 2010 and gcc 4.6 (if I recall correctly) but some older compilers may name it std::tr1::regex instead, and some that are older still won't have it at all.
",3,6146359
6146444,"
C++ will be faster (maybe, if you write it well), but, it will be harder, but easier to start since you know it.
Python will take some time to get used to, and it will probably run a wee bit slower, but, will be easier (once you learn the language).
This is a very easy problem solved numerous times, so, what language you pick really doesn't matter.
If you like a GUI, then look at GUI libraries.
",1,6146359
6146409,"
Python will be much better for this task:
The equivalent C++ is much more involved.
",-3,6146359
6145727,"
find_if is your friend. Here is an example:
then:
Of course, this is much nicer with C++0x...
",4,6145670
6145739,"
Step by step.

Construct a functor (function object) which takes during construction the value of the attribute you are searching by. Ensure that the operator() is implemented correctly to accept a pointer to the object in the vector.
in the operator check the attribute against the value, and return the matching state
call std::find_if with this function object.

EDITED: per @ildjarn's comment! :) now am definitely off to bed.. :)
",1,6145670
5998933,"
Your while loop seems ok,
but are you sure about the following line ?
shouldn't be the following instead ?
Because obviously you are running the whole table until the cycle is complete or until you find the good one [ ie: while( t[temp].data != s ...) ]. So I guess that you are searching for the good temp index but you don't use it after you while loop.
",1,5998388
5998448,"
Try changing
to
",0,5998388
6004800,"
I don't really have a ready C++ answer, but I had to do something similar in C# recently, and came up with the following:
Loop through the whole vector, checking the interesting path to see if it begins with an element.  The longest such match is the winner.  This would be an O(n) operation, depending upon the number of paths in the comparison set.
My refined version of the above became a little different, because I was going to be checking against a number of entries I'd already checked before.
So, I sorted the vector by descending length of path, so that the first match I come across would also be the best (giving me an average O(n/2) operation, I think), and stored results into a dictionary, so I wouldn't need to brute force the search again.
Hope this helps!
",1,5997723
5997837,"
You could use the Levenshtein distance
EDIT
Since I finally needed something similar myself, and this question remains open.  Here is some code I played around with.  Both straight up string distance and also applying the Levenshtein algorithm to the path tokens.
C++ Code
",1,5997723
9285256,"
Obviously, boost::path isn't a std::string, but probably has a member to get a std::string or similar object, so you'll just have to add that member to i->second and result->second
",0,5997723
5979848,"
There are two options:

If you need to run many queries:

Build the inverse map or use bidirectional map.
Find first larger element using upper_bound and

If you need element with longest common prefix, check this and previous (last smaller) element and choose the one with longer common prefix.
If you need element that is a prefix, scan back until you find an element that is a prefix.


If you need just one query, simple linear search will be quicker (building the inverse map takes O(n log(n)), while one iteration takes just O(n)), plus it's easier to implement. Simply iterate over the map, for each value calculate the prefix length and remember the best match so far (I wanted to suggest using std::max_element, but it implements maximum by comparison operator while you need maximum by metrics).

",2,5979442
5979510,"
If your map is defined like this:
...and the search term is defined like this:
...then you can get the value associated with this key like this:
",1,5979442
5979856,"
If I understand your question correctly, you want to search for keys by value (string), where the matching values are substrings of the provided search term.  I don't think there is an easy solution for this as a general problem (i.e. arbitrary strings and all their substrings).
However, the strings used as values in your example have a specific structure (i.e. file system paths).  You can exploit this structure to come up with a clean solution.  First, make a bi-directional map.  Then, implement the following lookup process:

If path is empty, fail.
Reverse lookup in the map based on the request path
If found, return associated value.
Pop the last component off the path.
Loop.

If the list is short, you might just want to loop over the list of (key,value) pairs and select the key where the value is the most similar (i.e. longest substring in common).
",1,5979442
5932472,"
As well as Soundex which was developed as far back as 1918 there are also Metaphone and Double Metaphone which were developed in the 1990s and 2000s respectively specifically to be be improvements over Soundex.
",7,5806735
5806801,"
You are looking for soundex: http://en.wikipedia.org/wiki/Soundex
The Wikipedia page list libraries for several programming languages. 
",5,5806735
5797568,"
You need to normalize both paths, then you do a simple substring comparison to see if your path in question starts with the normalized reference path.
Normalizing includes adding the current working directory to a relative path, case normalization if your file system is case-insensitive, probably resolving symbolic links and maybe even testing for hard links. If you want to allow the file itself to be a symbolic link you have to extract the path portion prior to normalization.
I've done this in linux using the realpath() function and it works very well, even if the reference path contains symlinks. Don't know how to do it with boost, though.
",1,5797356
5765847,"
You don't need boost at all.  Also, I don't see any instances of std::map even though you call them ""maps"".  I only see sets.
This is not a solution per se, but more a hint to figuring it out. You can loop over the elements of set<settings> Settings_Set with:
You should be able to piece it together from this and from one of the standard references on std::set: STL set reference
(Note I didn't use const_iterator intentionally, because I'm assuming you might be changing the values, as you said in your post.)
",3,5763710
5720004,"
Since you're already using boost, the boost.multi-index container library may be of use here. In particular, consider the examples in the Multiple sort tutorial section.
",1,5719914
5720067,"
With only 65 items in your container, a simple linear search may be fast enough for your needs. Use the name as the key for your map (or set) and use std::find when you need to search by id.
",0,5719914
5721816,"
As already mentioned Boost.MultiIndex is one way to approach a problem like this. It's very powerful and fast, but in most cases it just means slow compilation and complex code while not getting much other benefits.
65 items is not really much and as Mark Ransom mentioned a linear search could work well enough for what you're doing. This you need to measure.
Another way to do things is to have a std::vector hold the messages (65 messages) and then you can have two separate containers you use for lookup: first is id-to-index and second is name-to-index. The index is the position of the message in the vector. Something like this:
To manage the internal containers your insert must do the work to push_back in the messages vector and at the same time insert into the two maps the corresponding things to find the index in the vector from id and name.
This is just one way what the API would look like. You could also wrap the messages in boost::shared_ptr to get a bit different API. This is a bit outside the question of yours, because I also don't know how you intend to use the messages and their lifetimes.
I would say even if Boost.MultiIndex is a very cool container it should not be the first option. There are many ways to do this and it comes down the specific problems what makes most sense.
Hope you find what makes most sense to you.
",0,5719914
5683298,"
Download Windows SDK http://msdn.microsoft.com/en-us/windows/bb980924.aspx and you'll find some very good code samples - I especially found useful one for searching the registry. 
Be aware that the Search integration will work well for Vista and later versions of Windows. In theory, XP is also supported, but it is obviously an afterthought. 
",0,5681129
5678454,"
In case you try to enter names separated by whitespace you need to use std::getline instead of istream::operator>>.
",2,5678337
5680578,"
Since you also asked for general feedback.  Notice that your are potentially comparing the same strings twice for each iteration.  strcmp returns whether its less, equal or greater (-1,0,1).  You could get the return value and perform all futher comparisons with that...
",0,5678337
5660261,"
I don't understand your binary search either, and using global variables in addition to recursion leads to programs which are very hard to understand. It's better to go back the call stack again and ""unwind"" it properly. Look at the following example (untested):
",4,5660138
5660192,"
You can use the STL's built-in binary_search as follows:
If you're doing this to learn; there are a few things...

You don't need a while loop.  There are three cases to consider: the word comes before mid, at mid, or after mid.  Each of these three cases returns - so it's impossible to even reach the end of the loop body.
You use test when exactly, and do you need this variable?
You should consider carefully exactly which range of indexes still needs to be searched.  Are from and to inclusive or exclusive?  You need to be precise and consistent.
Consider that division of positive integers rounds down.  No matter what values they have, ensure that the recursive call calls a smaller range - to avoid infinite loops.  This will help avoid the need for your test variable (see David's comment below).
It's not good practice to use global variables; certainly not in otherwise pure functions - I'm assuming you're doing this for debugging purposes?
How large can to and from be?  In some cases, note that to+from may exceed 2^31-1.
It's typical in C++ to express these notions with iterators.  You don't have to, of course.
It's typical in C++ to pass large objects by const & where possible - that way, the recursive call doesn't need to copy the entire vector.  This is not important for correctness, but practically very important for efficient code.

",4,5660138
5660219,"
Pass vector<string> words as reference in your binsearch() function. Presently it keeps creating copies of vector<string> whenever the function is called which is not needed. Moreover in future if you want to update that vector<>, then passing by reference is the best way.
There should be return statement outside the while loop. That will be the final 'return`.
",1,5660138
5660470,"
One of the classical way to get rid of this : rewrite it without recursion.
For example, use a while loop, then as soon as you find the result, use a break to go out. You can have a look at following code (not compiled, just written quickly from your own code)
There is no elegant or portable way to jump out of a full call stack, it's at best fairly risky. Moreover, the derecursified function will be much quicker : it does not need to push stuff on stack and do a a function call
Edit

added missing return
concerning performances : just benchmark it. In this particular case, code complexity (for the human reader) is almost the same, but depending on the algo, it can be much more complex (or even impossible). 

",1,5660138
5661679,"
There are several things wrong with your code.  For starters,
it's not clear what to and from mean: are they inclusive, or
exclusive.  And if they're both inclusive (which your arguments
to the recursive calls seems to suggest), how do you detect the
end.  And what does test mean?  You seem to be using it as an
end criterion when you don't find the word, but I don't see how.
If I were writing this, I'd use a simple helper class to hold
the target and the word list (but you can just propagate them
down explicitly), and a wrapper function so that the client code
doesn't have to specify the to and from arguments.  There's
no need for a global variable, or any additional test.  And
I'd use the half open intervals that are idiomatic in C++: lower
bound inclusive, upper bound exclusive (so top == bottom
specifies an empty range, so I've finished without finding the
element):
Note that you can't do the comparison before testing that the
range isn't equal; it will cause an out of bounds access if all
of the elements are less than the target.
Also: I presume that you're doing this for pedagogical reasons.
Otherwise, you should just use the function in the standard
library.  And I wouldn't normally use recursion here: there's
a straightforward iterative solution:
(Finally, you'll notice that I've converted your parameters to
references.  It doesn't change anything in the logic of the
code, but if words is relatively large, it will make a very
significant impact on the performance.)
",1,5660138
5660212,"
You can use a longjmp, aka a ""non-local goto"", to exit the inner recursion immediately, but the question is whether this micro-optimization is worth the trouble.
A better option is to change the recursion into a loop. Since all the recursive calls are ""in tail position"" (are the argument to return), you can replace them with code that resets the parameter variables. Unfortunately, I don't understand your code, so I can't give you an example.
",0,5660138
16181198,"
This is a classic exercise in using recursion - sure, one can also do things nonrecursively, but it's very elegant to ""let the recursion manage one's bookkeeping."" For those whose knee-jerk reaction is ""do it iteratively"", I suggest doing the analogous exercise on a merge-sort or quicksort. Very similar recursive structure, but the bookkeeping there is greatly eased in a recursive context. And on modern CPUs the recursive code - surprise! - often runs as fast or faster, to boot.
Here is my recursive implementation, using the OP's problem context. Note there is no need to separately test the midpoint element: Within the context of the C++ ""less than"" paradigm for comparison predicates (where given <, one can infer equality via .not.(a.lt.b) .and. .not.(b.lt.a) ), an extra test for equality of the midpoint makes little sense, although in the special case of the string class with its many-valued compare result, it may yield a modest speedup to add special handling for the 0-return result. My sample version assumes only < (in the sense that if one really only had <, one would slightly rearrange the divide-and-conquer conditional to use that), which generalizes more easily to numeric and user-defined data types:
And here is a non-recursive version of the above, which corrects several problems with the sample code posted by user 'Bruce' and again uses no separate midpoint-value test:
I did a comparative timing of the above 2 implementations using a vector of 1 million quasi-random text snippets, code built using gcc 4.2 on MacOS ... the recursive version runs ~20% slower. For my hand-rolled merge-sort code, though, recursive is faster. YMMV.
",0,5660138
8302156,"
You need to add the correct registry keys for the IFilter to be registered. There are 2 main keys, one is to register the handler, and the other is to register the given file extension to use your handler. If you look at the FilterSample in the windows search SDK examples (http:// www.microsoft.com/download/en/details.aspx?displaylang=en&id=7388). 
To register the class do: http://msdn.microsoft.com/en-us/library/ms692540%28v=VS.85%29.aspx
To register it with a given file extension: http://msdn.microsoft.com/en-us/library/ms692488%28v=VS.85%29.aspx
Unfortunately, it will still index as English and use the English WordBreaker and English Stemmer and the english noise file (stop words) filtering which is in C:\windows\system32\noise.dat and \noise.enu.
I'll let you know if I figure out how to fix that part.
",0,5480974
5474730,"
should be
",0,5474699
5445338,"
The most obvious route is to use FindFirstFile and FindnextFile, along with SetCurrentDirectory. One obvious way to traverse the subdirectories is to make your directory traversal routine recursive.
",3,5445309
5445408,"
Just use boost's recursive_directory_iterator, and filter the files/directory you want.
",3,5445309
5445333,"
Just use a stack and implement Depth-First-Search (see wiki) http://en.wikipedia.org/wiki/Depth-first_search
This way you can (with a small as possible stack) traverse any tree like structure (and Windows' file system is tree-like).
",-1,5445309
5426249,"
The OOXML file formats are officially documented in ECMA-376. There's an equivalent ISO standard (29500, if memory serves), but I believe you have to pay to get it, and the two are identical1. As a warning, however, these are huge documents, and the file formats themselves are definitely non-trivial to deal with. Just getting at the raw text is a relatively easy task, but still not exactly trivial.
1 The ECMA standard was accepted by the ISO under its ""fast track"" program, where they accept an existing standard intact, even in some cases where it doesn't completely follow the normal ISO guidelines.
",1,5425934
5425984,"
.docx is zip with a bunch of XML files in it. It's documented at http://openxmldeveloper.org/articles/GuidedTourOfSpecPart1.aspx
",4,5425934
5445932,"
If writing your own OOXML parser is not an option, you could convert your docx files with docx2txt .
",0,5425934
5423719,"
All of the standard C++ classes return <container>.end() when a search result fails since end() doesn't actually point to an element in the container (it points ""past-the-end"" of the container).  I don't see a reason why another type would be necessary.
",6,5423708
5423754,"

i want a way to know that the search did not turn up a place in the list

std::find is helpful for the task. 
",3,5423708
5412407,"
You could you the ""last modified on"" property that files have (regardless of platform). 
Simply store historical values and check historical values against current values, every so often.
boost::filesystem has a great cross platform API for reading this value.
EDIT: Specifically look at:
http://www.pdc.kth.se/training/Talks/C++/boost/libs/filesystem/doc/operations.htm#last_write_time
",3,5412318
5226318,"
You could build a secondary array that consists of the first entry in each block then run binary search on that array. The indices for the array should corresponding directly with the block indices making it an O(1) lookup to get the corresponding block. 
It cuts the worst case from O(n) to O(logn) and is still relatively simple.
",4,5226241
5226312,"
Your idea, using a binary search, is correct. And you can avoid the linear scans alltogether by saving both the minimum and maximum value in each node. In your example the constructed binary-search-tree will look like this:
Having both the max and min values makes it efficient to compute the higher nodes. In your example, if you want to search for ""8"" you will go   ...->...->...->(1,16)->(1,8)->(4,8), so you found the correct block without seeking backward and in the most efficent (log(n)) correct way.
",4,5226241
5230549,"
It's a well-known problem, and there is a well-known data structure to solve it, employed mostly in databases :)
The idea is to use a B+ Tree.
The idea is to superpose a kind of Binary Search Tree (except that there'll more than 2 children per node) on top of the structure to search in.
",2,5226241
5226338,"
If you have any idea of key distribution you could improve a binary search by guesstimating the first location to check. As a sample, with a ""Name"" key and the value ""Bob"" you can approximate where ""B"" is located, either simply based on position in alphabet, or more complex with domain-specific knowledge of the key (distribution frequency of first character in english first names e.g.)
Either way, a binary search is the way to go, optionally with first-key-in-block preloading or caching-as-you-see-them.
",1,5226241
5682361,"
This sounds like a great job for a regular expression matcher or a deterministic finite automaton.  These are high-power tools designed to do just what you're asking, and if you have them at your disposal you shouldn't have much trouble doing this sort of search.  In C++, consider looking into the Boost.Regex libraries, which should have all the functionality you need to knock this problem down.
",3,5047299
5047315,"
What ultimately worked for me was a hybrid between the Boyer-Moore-Horspool algorithm (suggested by Jerry Coffin) and my own algorithm based on the structure of the tables and the data being stored.
Basically, the BMH algorithm caught most of the things I was looking for.  The obvious stuff.
But some tables did turn out to have odd formatting, and I had to implement a semi-intelligent search that would look at the data following each 0x55, and figure out whether or not it was it was likely to be good data, or just random junk.
Oddly enough, I ended up implementing it in PHP rather than C++, and dumping the results right into a MySQL database for querying.  The search process only took around 5 minutes or less, and the results were largely good.  I did end up with a lot of junk data, but it caught everything that I needed it to, and (as far as I'm aware) did not leave any good data behind.
",1,5047299
5047319,"

Load the whole thing? fseek? Buffer chunks, searching those one byte at a time?

If you can load the whole thing into memory, you should probably use the memory mapping features provided by your platform. This way, the operating system can decide if it should keep large portions of the file in physical memory (i.e. the system has lots of free RAM at the moment), or if it should work only in smaller chunks.
Of course, this only works if you can fit the file into working set.
",0,5047299
4827705,"
This is a classical case for a hash map. First, realize how many IDs you can actually have active at any one time. 2^64 is nonsense since then even the data structure just to hold these IDs and the pointers to the objects would already be at least 268'435'456 TB. Now, there's nothing wrong with using 64bit IDs, but figure out how many objects you will have active at any one time, choose a reasonable number like say 5'000 and use a hash map of say 10 times the number of objects. If your load factor is low enough and your hash function good enough you will get an amortized O(1) access time.
",3,4827503
4828378,"
Even if the number of active objects would be much larger, say 1 million, you can still use a relatively small hash map, for example a map of size 10000. Each element of the map points to a linked list of IDs. These lists are searched using simple linear searrch. If the hash function is well chosen, the IDs will be distributed evenly (or close to that) over the 10000 entries in the hash map. Thus each entry of the hash table will contain about 100 IDs. Linear searching such a list takes 50 comparisona on average.
In one of my apps the number of symbols was around 1000. I used just simple linear search. Performance analysis showed that 90% of CPU time was spent in the table lookup. Next I made a hash table of just 32 entries -> CPU load of the table lookup dropped to below 4%. Problem solved. Enlarging the hash table would have no noticeable impact on speed (less than 4%) so I left it at the size of 32.
Conclusion: you can use a hash table that is smaller than the number of elements. This requires an average number of comparisons of (Total number of IDs / size of hash table / 2) Choose the hash table size large enough to reduce CPU time for table lookup to a low fraction of total CPU time.
",2,4827503
4828456,"

""What are your ideas?""

I'd use std::map first and only think about implementing my own solution if the performance sucked.
http://www.cplusplus.com/reference/stl/map/
",1,4827503
4752466,"
The sub-expression: ((toFind - sortedArray[low]) * (high - low))
... can easily evaluate to something like:  ((99999-0) * (99999-0)) == 99999^2
... which is much larger than 2^31 (== the range of 32-bit signed integers).
Once it exceeds 2^31-1, the integer will overflow into negative numbers, hence your negative indices.  If it exceeds 2^32 (which it also could do), then (most likely, technically undefined) you'll lose the high-order bits and you'll end up with effectively random offsets, both positive and negative.
To avoid all of this, you need to do your math carefully to make sure none of your sub-expressions yield an integer overflow.  Usually the easiest way to do this is to convert to floating-point whose range is many orders of magnitude larger than 32-bit integers.  
In the final analysis, interpolation such as this for binary search is usually not worth it -- the expense of computing the interpolant is typically greater than the few extra iterations of the loop that it ""saves"".
",4,4752028
4752827,"
As the other answers have explained, you're trying to compute an expression of the form
but this goes wrong because A * B overflows. The suggestion to revise the expression to
won't work, because typically B is less than C and so the integer division will truncate to zero.
The suggestion to switch to floating-point would work, but would be costly. But you could use fixed point by transforming the expression to:
(where F is a carefully chosen power of two).
",4,4752028
4752042,"
The problem is with the expression that computes mid. The product can easily overflow even with 32 bits integers. Then it becomes negative. It would probably be better to perform division before product. 
Changing the mid computing to use 64 bits integers (at least for intermediate computings) fix problems.
Below is my modified version (int64_t is defined in <stdint.h>:
An even simpler fix would be to make it a dichotomic search instead of interpolation by just using: mid = (low + high) / 2. even if it converges slightly slower than interpolation, it avoids several operations including a product and a division thus making the inner loop faster. Not sure the potential faster convergence of interpolation compensates for that loss of simplicity.
I did some performance tests. The source of my test program is included in this question
Suprisingly (for me) using floats gives a more efficient program than using large integers. On my system binary search became faster for about 1000 items in the array. For arrays of size 100000 interpolation search is nearly two times faster than simple binary search.
",4,4752028
4707092,"
The regexp will perform better, but get rid of those '.*' parts. They complicate the code and don't serve any purpose. A regexp like this:
will search through the string in a single pass. The algorithm it builds from this regexp will look first for \y, then character 1 (g|b), then character 2 (g => go or b => be), character 3 (go => goo or be => bes|bet), character 4 (go => good or bes => best or bet => bett), etc. Without building your own state machine, this is as fast as it gets.
",3,4706654
4706662,"
Obviously not the second one (using 'find'), since you're running three comparisons (need to traverse the string at least 3 times) instead of one hopefully smart one. If the regex engine works at all like it should (and I suppose it does) then it will probably be at least three times faster.
",3,4706654
4706673,"
You won't know which is faster until you've measured, but the issues at stake are:

The regex implementation, esp. whether it needs to precompile (like Google RE2, POSIX regexes).
The implementation of string::find.
The length of the string you're searching in.
How many strings you're searching in.

My bets are on the regex, but again: you've got to measure to be sure.
",3,4706654
4659796,"
If your C++ Standard Library implementation supports it, consider using a std::unordered_set  or a std::hash_set.
You can also use std::set, though its overhead might be higher (it depends on the cost of generating a hash for the object versus the cost of comparing two of the objects several times).
If you do use a node based container like set or unordered_set, you also get the advantage that removal of elements is relatively cheap compared to removal from a vector.
",6,4659774
4659833,"

Tasks like this (set manipulations) are better left to what is MEANT to execute them - the database!
E.g. something along the lines of:

If you want an ALGORITHM, you can do this fast by retrieving both the list of emails AND a list of unsubscriptions as ORDERED lists. Then you can go through the e-mail list (which is ordered), and as you do it you glide along the unsubscribe list. The idea is that you move 1 forward in whichever list has the ""biggest"" current"" element. This algo is O(M+N) instead of O(M*N) like your current one
Or, you can do a hash map which maps from unsubscribed e-mail address to 1. Then you do find() calls on that map whcih for correct hash implementations are O(1) for each lookup.
Unfortunately, there's no Hash Map standard in C++ - please see this SO question for existing implementations (couple of ideas there are SGI's STL hash_map and Boost and/or TR1 std::tr1::unordered_map). 
One of the comments on that post indicates it will be added to the standard: ""With this in mind, the C++ Standard Library Technical Report introduced the unordered associative containers, which are implemented using hash tables, and they have now been added to the Working Draft of the C++ Standard.""

",5,4659774
4659824,"
Store your email adresses in a std::set or use std::set_difference().
",4,4659774
4659843,"
The best way to do this is within MySQL, I think. You can modify your users table schema with another column, a BIT column, for ""is unsubscribed"". Better yet: add a DATETIME column for ""date deleted"" with a default value of NULL.
If using a BIT column, your query becomes something like:
If using a DATETIME column, your query becomes something like:
",1,4659774
4435300,"
There is no one size fits all approach to this sort of problem.  But for this one I would try these:

If there are any unique messages associated with the operation, grep all the source files for that string.  A common pitfall of this technique is that messages might be assembled from pieces within the application, so it is often helpful to grep for a unique short phrase—or even a single word—to identify the source of the message.  Once the text is found, then finding what references it often requires more text searches.
Trace execution from an easy-to-find point, like the command processing and dispatch loop.  I'd look for a Tab key case and follow where it leads.
Look at source code directory and filenames for hints.  Software is often constructed rationally, with good engineers dividing and conquering in a sensible way.

",10,4435275
4435312,"
A test coverage tool is a good way to do this.  They tell you what part of an application
is exercised by a test.
Instrument the application to collect test coverage.  Execute the functionality you care about.  Record what is executed.  Execute something similar, but not the same as the functionality you want.   Record this.  Take the set difference over the coverage.  The diff selects code involved in the functionality of interest, excluding code which is common to similar functionality.
",6,4435275
4435479,"
Ask the Chromium team. They don't give points or bronze pixels but they're definitely the authority and right people to ask this sort of questions.
",0,4435275
4399946,"
There are 2 solutions :
length should get 20 as value
or
use ""<="" instead of ""<"" (in this case ""length"" should be named ""lastIndex"")
",3,4399850
4399895,"
Look at your search function, what value will index have when you try to find the 20th number?
",0,4399850
4399913,"
If you've got 20 numbers, then why do you set length to 19? That's very counter-intuitive.
",0,4399850
4400122,"
Classic Off-By-One issue. See @Kipotlov's answer for code corrections. 
",0,4399850
40450611,"
INDEX SEQUENTIAL SEARCH USING C
this code works for all the cases i.e if we are finding last element in an array 
this code will work... 
",0,4399850
4293390,"
The algorithm for this problem would be:
For each axis, step towards it until your position on the other axis is 0.
Pseudocode:
However, I don't understand why you need to search for a route - it's not that complicated.
",2,4237818
4237852,"
As ""thejh"" remarked there's no need for a search, but your assignment calls for one.
A reasonable approach is

Analyze. Is it all possible for arbitrary (x, y) starting position? Checking the allowed moves you see that they can be combined to yield 1-step horizontal moves, and 1-step vertical moves, so the answer to that is yes (for your hand-in provide the details of this).
Figure out what ""breadth-first search"" is. Wikipedia is your friend (although, if you have access to a university library, I really do recommend Patrick Henry Winston's old Artifical Intelligence, it's really good, very lucid explanations). Try it out with some simpler problem.
Do the assignment's problem in just about the same way. Ask here if you encounter any technical C++ problem.

Cheers & hth.,
",1,4237818
4237885,"
Here's my answer (really based off of thejh's answer) that uses a queue:
It's convoluted, but follows the directions.
",1,4237818
4599691,"
I'm going to go ahead and answer my own question for future reference.
Psuedocode:
It should also be noted that the execution time for this application grows very, very fast, so test it out with small coordinate values. For example, the coordinates (1,1) gives 7 levels of breadth and requires 16384 iterations.
",-2,4237818
4057372,"
You can do better than O(log n) if the values are integers, in which case the best worst-case running time you can achieve, in terms of n, is O(sqrt(log n)). Otherwise, there is no way to beat O(log n) unless there are patterns in the input sequence. There are two approaches used to beat O(log n) in the case of integers.
First, you can use y-fast trees which work by storing in a hash table all prefixes for which you are storing at least one integer with that prefix. This enables you to perform a binary search to find the length of the longest matching prefix. This enables you to find the successor of an element for which you are searching in time O(log w) where w is the number of bits in a word. There are some details to work though to make this work and use only linear space, but they aren't too bad (see the link below).
Second, you can use fusion trees, which use bit tricks to enable you to perform w^O(1) comparisons in just a constant number of instructions, yielding a running time of O(log n / log w).
The optimum tradeoff between these two data structures occurs when log w = sqrt(log n), giving a running time of O(sqrt(log n)).
For details on the above, see lectures 12 and 13 of Erik Demaine's course: http://courses.csail.mit.edu/6.851/spring07/lec.html
",35,4057258
4057310,"
One possibility is to treat it like finding the roots of a function.  Basically, finding:
Is equivalent to:
Then you could try something like Newton's method and so on.  These kinds of algorithms frequently converge faster than a binary search when they work, but I don't know of one that is guaranteed to converge for all input.
http://en.wikipedia.org/wiki/Root-finding_algorithm
",6,4057258
4057290,"
If the values in the list are evenly distributed then you could try a weighted split instead of a binary split, e.g. if the desired value is a third of the way from the current lower limit to the current value then you could try the element that is also a third of the way. This could suffer badly on lists where values are bunched up though.
",5,4057258
4057286,"
Yes and no.  Yes there are searches that are faster, on average, than a bisection search.  But I believe that they are still O(lg N), just with a lower constant.
You want to minimize the time taken to find your element.  Generally it is desirable to use fewer steps, and one way to approach this is to maximize the expected number of elements that will be eliminated at each step.  With bisection, always exactly half the elements are eliminated.  You can do better than this, IF you know something about the distribution of the elements.  But, the algorithm for choosing the partition element is generally more complicated than choosing the midpoint, and this extra complexity may overwhelm any time savings you expected to get from using fewer steps.
Really, in a problem like this it's better to attack second-order effects like cache locality, than the search algorithm.  For example, when doing a repeated binary search, the same few elements (first, second, and third quartiles) are used VERY frequently, so putting them in a single cache line could be far superior to random access into the list.
Dividing each level into say 4 or 8 equal sections (instead of 2) and doing a linear search through those could also be quicker than the bisection search, because a linear search doesn't require calculating the partition and also has fewer data dependencies that can cause cache stalls.
But all of these are still O(lg N).
",4,4057258
18617212,"
What about the following algo?
it is called Exponential Search and is one of the variations of binary search.
http://en.m.wikipedia.org/wiki/Exponential_search
Searching for element k in sorted array A of size n.
Lookup A[2^i] for i=0, 1, 2,... until you go beyond k's position in A. then do a binary search on the part of the array left (smaller) than i.
This algo will run on O(log idx) where idx is the index of k in A. (both stpes are in log idx).  In the worst case, the algo is in O(log idx), if k is amongst the largest elements of A or bigger than any element of A. The multiplicative constant is larger than for binary search but the algo would run faster for very large arrays and when looking for data that's towards the beginning of the array. 
I'D like to have some idea of the minimal size n where this algo becomes preferable to binary search, but I don't know.
",3,4057258
4057289,"
You can always put them in a hash table, then search will be O(1). It will be memory intensive though and if you keep adding items, the hash table might need to be re-bucketed. Re-bucketing is O(n) but it will get amortized to O(1). It essentially depends on whether you can afford that space and the potential cache misses.
",1,4057258
4057474,"
First of all, measure before doing optimization.
Do you really need to optimize that search?
If so, then secondly, think about algorithmic complexity first. E.g. can you use a tree (like a std::map, say) instead of an array? If so then it depends on the relative frequency of insertions/deletions versus searches, but the premise of having a sorted array at hand indicates that searches are frequent compared to data set changes, so that it would make sense to do some little additional work for insertions/deletions, making each search much faster  --  namely logarithmic time.
If you find that indeed the search times are a bottleneck that needs addressing, and no, no change of data representation is possible, and the list is short, then a linear search will generally be faster because it does less work per comparision.
Otherwise, if the list is longer, and no particular distribution of values is known or assumed, and the values can't be treated as numerical, and memory consumption should be constant (ruling out constructing a hash table, say), then binary search produces 1 bit of information per comparision and is probably the best you can do for the first search.
Cheers & hth.
",1,4057258
4057315,"
In binary search you split the list into two ""sublists"" and you only search the sublist that may contain the value. Depending on how large your array is, you could see a speedup if you split the array into more than two splices.
You can determine which region of the array you have to search, by keeping an index, that you search first. Like in a telephone book of a large city, where you can see from the outside, where you have to start to search. (I have trouble expressing my idea in text, and I did not find an english link yet that explains it better).
",0,4057258
4058907,"
If you have a huge amount of numbers to find, and by some fluke they are ALSO sorted, you could do it in O(n + m) where m is the number of numbers to find. Basically just your typical merge algorithm, with slight modification to record which value each checked number would be inserted before, if it was to be inserted into the array.
You can always trade off space... And time of other operations. Assuming all your elements are constant size p bits, you can make a massive array which stores, for each possible value you could look up, the index of the next bigger value currently stored. This array needs to be 2^p*lg(n) bits, where n is the number values stored. Each insertion or deletion is O(2^p) but typically around 2^p/n, because you have to go through updating all those indices.
But your lookup is now O(1)!
OK, OK, it's not really practical. But dividing the input into blocks in a similar fashion could possibly reduce the constant in front of your log. Possibly.
",0,4057258
44081315,"
Although in the general case you cannot do better than O(log N), you can at least optimize that, thus significantly reducing the constant of proportionality in front of O(log N).
If you have to perform multiple search on the same array, these can be vectorized using SIMD extensions, thus further cutting down on computation cost.
In particular, if you are dealing with arrays of floating point numbers which satisfy certain properties, than there are ways to construct a special index which then allows to search the array in O(1).
All of the above aspects are discussed with test results in:
Cannizzo, 2015, Fast and Vectorizable Alternative to Binary Search in O(1) Applicable to a Wide Domain of Sorted Arrays of Floating Point Numbers
The paper comes with source code on github.
",0,4057258
3984015,"
Try changing
to:
and
to
and most importantly you are doing nothing when you find the element !!
",2,3984009
3984023,"
My first reaction is to change the line
to
Also, don't you want to report if the sought element was found or not? To detect the case when the element is found, another if branch like the following
can be inserted. That can have a return element; or return midindex inside it coupled with a return failure; outside the loop.

EDIT: I made a casual attempt to write a version of binary search. I don't claim it to be correct, as binary search is (in)famous for getting incorrect. Some code with test cases and output is uploaded at codepad.
Snippet:
The main and test code:
",2,3984009
3984031,"
Binary search works nicely as a recursive algorithm.  Pass in the array and length, check the middle value, and recurse on the upper / lower half of the array, as appropriate.
",1,3984009
3984039,"
Consider carefully what is not right about int midindex=(array_size/2); when array_size = 1.  Then generalize to array_size = 3.  Then to any odd number.  This will require small run simulations in your head or on paper.
",0,3984009
3984046,"
You're close.  You want to do something like this:
so you can return the index of the element
",0,3984009
3860904,"
A prerequisite for binary search is that the array should be sorted.
To sort the string s you can do sort(s.begin(),s.end());
There are a few more bugs in your implementation:
Why?
When the key is greater than the middle element you need to narrow the search to the right half of the middle element and you do that changing the low(in your case m) to mid+1 (in your case k+1). Similarly the other case needs to be changed as well.
and
should be
Why?
Consider the case of searching char 'a' in the string ""a"". Both your m and n will be 0 and so will be k. In your case the while loop is not entered at all. So in general when the search narrows down to one element and that happens to be your key, your existing code will fail.
Tip:
Your variable name selection is not good. It better to use names such as low, high and mid. 
",15,3860896
10252703,"
You could write your search function in a way which accepts a predicate as a parameter.   A predicate is some kind of ""functionoid"" (meaning, anything which has the ability to be ""called"" like a function - it could be a function, or a lambda, or a function object..)
in the C++ standard library, predicates are used for many of the standard algorithms, so it's common that you'll see code (using standard containers) like this:
The way that C++ standard algorithms are implemented in this way is to accept a template argument representing the predicate, along the lines of
It's a technique from the functional programming school of thinking - passing a function to a function (Treating a function as a ""first class citizen"").
",2,10252538
10252734,"
You could have your search function take a ""match"" function as one its parameters, and call this match function on every movie to see whether the movie matches. You can then call your search function with different match functions.
Something like this:
You could then declare match functions like this:
and call it with specific queries like this:
(std::bind is a C++11 function from <functional>; you could equivalently use boost::bind or std::bind2nd)
Alternately, if you prefer a more C-style way of doing things, you could do something like this:
",2,10252538
10253212,"
Besides the option of passing a functor to check the match, there are other options. One such option would be taking a set of optional conditions to check (you can use boost::optional or a handcrafted approach, or use pointers. For example:
To simplify the function signature you can create a search_pattern type that encapsulates the fields that you want to test (example using a different approach: bools to determine optionality):
In this last case, you can actually move the test into the pattern object, and have a function:
bool pattern::matches( movie cosnt& m ) const {
   return (!check_year  || m.year == year )
        &&(!check_actor || m.actor == actor );
}
    void print_matching( node* list, pattern const & p ) {
       // iterate over the list:
       while (...) {
          if ( p.matches( list->data ) )
          {
              // Film matches, print it
          }
       }
    }
",2,10252538
10234216,"
Try searching %SYSTEM%\*.cpl.  On some systems, %CSIDL_CONTROLS%\*.cpl.
",0,10233812
10240432,"
You can enumerate all the control panel items and search for the one which you are looking for try this and this
",0,10233812
10221789,"
The find member function is probably the fastest way to find whether a key is already in the map. That said, if you don't need to iterate over items in the map in order, you might get better performance with an std::unordered_map instead.
",2,10221751
10221784,"
In a std::map or hashtable (std::unordered_map), the find function is very fast, as fast as using the [] subscripting operator.  In fact, it's faster when the element is not found, because it doesn't have to insert one.
",1,10221751
10221794,"
I don't think there is much difference in speed for various ways to check for existence of key. On the other hand: if your keys are integers and range is known, you might just use the array.
BTW:
I got interested about the speed of simple array, vector, map and unordered map. I have written simple program, that does 100000000 container[n]++, where n is a random number in range of 0 to 10000. The results:

array: 1.27s
vector: 1.36s
unordered map: 2.6s
map: 11.6s
The overhead of loop + index calculation in this simple case is ~0.8s.

So it all depends on how much time is spent elsewhere. If it's considerably more (per 100000000 iterations) then it does not matter much what you use. But if it's not, it can be quite a difference.
",1,10221751
10224022,"
you can use hash_map, it is the fastest data structures for your key-value type;
also you can use map,but it is slower than hash_map
",0,10221751
10051098,"
You have to replace 
by 
In your example you have low = 4 and high = 10. But then you want a random number between 0 and 6 and add 4. Not one between 0 and 10, since then you could get results up to 14. If you dont want to include the high bound (Interval [low,high[ instead of [low,high] ) you have to omit the +1 in the brackets.
Why
rand() returns a pretty big integer number. And we want get a random number in the interval [a,b] from that.
If we take rand()%5, we get a numer which is 0,1,2,3 or 4, so from the interval [0,4]. In general rand()%C gives a random number in the interval [0,C-1].
If we add a constant number, e.g. Rand()%C + D, the interval is shifted: [D,C-1 +D].
So back to the problem, we want the interval to be [a,b]. Therefor we want a=D for the lower bond and C-1+D = b for the upper. This we can transform to C = b-D+1 = b-a+1.
So we want to use rand()%(b-a+1) + a.
Hope this explains a bit how things work.
",4,10051071
10051095,"
You're pretty close, but try this:
rand()%(high-low)+low;
",1,10051071
10051097,"
First, don't call srand inside your loop. Just call it once when the program starts.
Second, that logic is wrong. It should be:
(This assumes high and low are inclusive. That is, if high is 10 and low is 1, then both 1 and 10 are acceptable guesses.)
",1,10051071
9888434,"
Use etags/ctags from the exuberant ctags project in conjunction with an editor (emacs, vim) that understands them, or GNU GLOBAL.
Oh, and if you happen to use automake it generates a target TAGS.  So no need for complicated manual calls to {c,e}tags.
",4,9888245
9888534,"
Use ctags/cscope + vim/emacs
you can google for their detail use.
if you use ctags + vim, you can :
1.go to the /usr/include directory, excute ctags -f tags1 -R . generate the tags 
2.generate tags for your code in your code directory ctags -f tags2 -R.
3.run :set path+=tags1,tags2 in your vim
4.under a function or marco try CTRL+] 
",1,9888245
9896895,"
Here is what you can do, assuming you use gcc, if not just modify it accordingly.
",1,9888245
9888551,"
You can use Eclipse CDT. For example here is described how to setup CDT project to navigate Linux kernel source - HowTo use the CDT to navigate Linux kernel source.
",0,9888245
9888618,"
vim + ctags is the way to go. You can jump to and definition of functions, global variables, macros, etc. etc.
FYI, browsing programs with tags
Also, if you want to quickly switch between .c and .h files, please refer to this blog
",0,9888245
9888751,"
you can use cscope or emacs/vim + xcscope.el to do that easily. I think it's batter than ctage and etage. 
",0,9888245
9889182,"
Provided the correct headers are included that directly or indirectly define what you look for, most IDEs have a jump-to-definition-functionality that works.
The tags-approaches are of course nice because they don't depend on correctly included headers.
",0,9888245
16856217,"
Is C++11 acceptable?
Or in C++03, first define a functor:
then call it like so:
This will only return the first match, but from your question, it looks like that's all you're expecting.
",6,9843278
9843380,"
You can use std::set<std::pair<std::string, std::string> > for this but you will need a custom
comparison object for this because the pair's relational operator takes both elements for this. That said, it seems as if you actually should use a std::map<std::string, std::string> instead.
",2,9843278
9845994,"
The definition of < for std::pair implements a lexicographical order and """" is the minimum element for strings. Combining this we get:
The trick is using lower_bound appropriately.

Returns an iterator pointing to the first element which does not compare less than value.


If it returns end(), then it did not find anything interesting.
Otherwise, it->first >= key so we get rid of the > case (of no interest to us)

I would point out though that this only returns the first element of the range. If you are interested in all elements, try:
This will return the full range of nodes in s whose first element is equal to key. You then just have to iterate over this range:
And you don't even have to worry whether the return of lower_bound or upper_bound was end or not.

if lower_bound returns end(), then so does upper_bound, and the loop is skipped
if lower_bound points to a node for which it->first > key, then upper_bound will point to that same node, and the loop is skipped

That is the power of ranges: no need to make special checks, the ranges just end up empty when there is no match, and so the loop over them... is skipped in a single check.
",1,9843278
9834123,"
equal_range requires a sorted range.
The order implied by your comparison function does not match the order that you sorted the range into - and so the call to equal_range has undefined behaviour.
For example - say your list contained {{.5, 0}, {.6, 0}} (these are sorted), and you then applied std::bind(comp({.5,.5},_1)) to each element.
comp({.5,.5},{.5,0}) would return true.
comp({.5,.5},{.6,0}) would return false.
Your sort order is saying: "".5 is less than .6"", but at the same time your comp function is saying "".6 is less than .5"" (because a there is a value which is less than .5 but not less than .6). This is contradictory, and the cause of your problems.
To actually find all the elements such that std::bind(comp({.5,.5}, _1)) returns true, you could use std::copy_if(data.begin(), data.end(), some_output_iterator, std::bind(comp(ref, std::placeholders::_1))) (although there are a variety of different ways of doing this, depending on your exact needs).
",2,9833945
9834443,"
Your comparison function does not satisfy the requirements of strict weak ordering, i.e. for two elements say a and b, if comp(a, b) == true then comp(b, a) should be false.
You maybe want something more like this:

which outputs:
",0,9833945
9834110,"
I think you should use fabs instead of abs in function comp().
",0,9833945
9699826,"
The comparison is incorrect. If you want to check if there is at least one element in the container instead of:
you should use:
because find returns test.end() when it founds no match.
If you want to check if more than one element exists use count:
",2,9699614
9699706,"
A problem could be:
instead of
Your version looks for elements of test inside of test, which will always return a valid iterator.
Other than that, when you find a string that is not present, you can just break from the loop, no need to continue searching, right?
",1,9699614
9699940,"
If you can sort the two vectors, you can use std::includes.
",1,9699614
9700417,"
Let me add a solution which doesn't include an explicit for, and supposing that:

There are no repeated items in test1.
You are looking for exactly the same string to be contained in test.
~                  

",1,9699614
9648848,"
Just add extra boolean  matrix, that tells that word is used. So before calling search, set that boolean on invalid and before going that direction, check if ""unused""
",0,9560247
9560306,"
Changing the function into this solved all my problems. Thanks for your comment, they inspired me.
",-1,9560247
9546045,"
You want to iterate over all points (x + i, y + j) around your unit at (x, y) such that
where R is the range of attack. (This is a disk in the L1-metric.) So, like this:
Alternatively, you can halve the outer loop by unrolling:
As @Alink says, you'll have to handle the map boundary in some way or another.
",5,9545934
9546298,"
On other answers (too long as comment):
Pathfinding is really wrong here. First of all, we have a grid with no restrictions and equal costs. Using any kind of pathfinding is neither necessary nor makes sense at all. I get that you are thinking ahead in a way that this exact property might change / usually is different for RTS games, but I really think we should stick to the exact problem if the author carried it out precisely and quite well.
Especially, A* is a terrible, terrible choice:
Dijkstra calculates shortest paths to all destinations from a given source node. A* uses the fact that you often have one distinct destination and a heuristic can be used to ""guide"" Dijkstra in the right direction. It makes you reach the interesting destination earlier and therefore you pay a small overhead. If you want to check areas ""around"" some source node (the unit here), this just counter-productive.
Bitmaps will have the problem of aligning them with the grid. Either way there surely are ways to optimize and check more they once field at once, but those are just optimizations, imho.
On the problem itself:
I have no experience with games at all, so this is w.r.t of the abstract problem you outline above. I have added some speculations on your RTS application but take them with a grain of salt.
Simply checking all fields around a unit, as suggested by Kerrek SB is pretty good. No unnecessary field is checked and all fields are accessed directly. I think I'd propose the same thing.
If the number of the checks from the question greatly dominates the number of unit movements (I doubt it, because of the ""real-time"" thing), it might be possible to precompute this problem for every unit and update it whenever a unit moves. I'll propose something that is more hungry for memory and most probably inferior to the straightfoward approach Kerrik SB proposed:
If a unit U moves to field F, it will:

notify all Unitis registered at F that they now can attack something
register itself at all the fields around F that it can now reach and
at the same time check if one of this fields is already occupied so that it could attack right away
remember all those fields to ""unregister"" once U moves away in the future

Consequently, each unit will know if it has something in range and does not have to recalculate that. Moving a unit will trigger recalculation only for that given unit and fields will simply notify only relevant other units. 
However, there is memory overhead. And ""real-time"" and plenty of units moving all the time will largely decrease benefits. So I have a strong feeling this isn't the best way to go, either. However, depending on your requirements it might also work very well. 
",2,9545934
9546078,"
Create a bitmap for the ranges of each unit, this will allow you to shape them in any shape you want.
Simplified example:
And so on...
then just check if the point lays on the bitmap (you have to figure that out yourself).
",1,9545934
9546041,"
I would use a pathfinding algorithm, especially since map squares can be occupied, you'll need a pathfinding algorithm sooner or later. A* would probably be the easiest one to implement for you and perform well enough for your given scenario. It is very well described on wikipedia, and googling it should return a lot of results for you as well as sample code.
You would basically calculate a path between each entity and another. If that path exceeds the given range for the unit, it is out of range. This could of course be optimized so that you will not continue checking once all the range is exhausted.
",0,9545934
9510029,"
Looks good performance-wise, except these tidbits:

Declare the function parameter as const string& (instead of just string), to avoid unnecessary copying.
You could extract the common subexpression current->child[((int)word[i]+(int)'a')] in front of the if, to avoid repetition and make the code slightly smaller, but any compiler worth its salt will do that optimization for you anyway.


""Style"" suggestions:

What if word contains character below 'a' (such as capital letter, digit, punctuation mark, new line etc...)? You'll need to validate input to avoid accessing the wrong memory location and crashing. Also shouldn't this be -(int)'a' instead of + (I'm assuming you just want to support a limited set of characters: 'a' and above)?
Declare wordLength as size_t (or better yet auto), but this is not important for strings of any practical length (might even hurt the performance slightly if size_t is greater than int). Ditto for i.

",2,9509629
9510008,"
Calling this function, string word will be copied,
type of function below will be faster.
or
",0,9509629
9502681,"
Your program has O(n^2) time complexity due to the nested loops. But this can be done in linear time:
You already know how to find the biggest element to the left of each element: Iterate over all the elements, keeping track of the current maximum. The biggest element to the left of each element is the current maximum when you reach that element.
To find the biggest element to the right of each element, you do the same thing in reverse: iterate the array from right to left, keeping track of the current maximum.
So you'd have two loops (left to right and right to left), but they wouldn't be nested within each other, so performance would be much better for large arrays.
",6,9502484
9502635,"
Use std::max_element and std::count. Or use std::for_each with custom class to find index yourself.

Won't work if all elements in array are negative. Use std::numeric_limits<int>::min() for initial value.
",2,9502484
9502709,"
To answer the issue of your program not working: findmax() returns a value that you store in maxr, but then you use maxr as an index, so you should have a function that returns the index of the maximum value instead of the value. 
Edit (as barnes53 points out): actually, in the findmax() function, max is used as index and as value.  At least ""if (tab[j]>max) max=j;"" must be ""if (tab[j]>tab[max]) max=j;"".  And it would have helped me if the function was called findIndexOfMax().
",2,9502484
9502820,"
An improvement to the accepted answer:
You can eliminate at least 25% (possibly 50%) of the comparisons by going halfway.
Start from the left and compute the ""left maximum"" as you go.  Start from the right and compute the ""right maximum"" as you go.
After meeting in the middle, compare the left maximum with the right maximum at the meeting point.  If they're equal, then you know the answer for the rest of the computations (you've saved 50% of the calculations).  If they're not equal, then you have to continue your calculations on the side that has the greater maximum of the two halves, up to the point where you reach the maximum on that side, and then you know the answer for the rest of that side.
",2,9502484
9502959,"
Here's an implementation of what interjay is talking about:
It sounds like you're limited on memory.  In that case, you can get rid of the maxl array if you just combine the first and third loop together, printing the max values as they are computed.  Let me know if its not obvious how to do that.
",1,9502484
9502818,"
stefaanv (approximately) identified your issue, so I'll just show an implementation that's not O(n^2).
Edit: for minimum memory use
",1,9502484
9429146,"
You're Doing It Wrong™.
Consider strPattern = refcstrRootDirectory + L""\\*.*"";. That *.* is there for a reason. It's where you specify the file pattern that you're looking for. If you want to look for *.doc files, say so: strPattern = refcstrRootDirectory + L""\\*."" + refcstrExtension;
Also, some style notes:

Drop the type prefixes. That's a convention used in weakly typed languages; C++ is strongly typed.
Define variables where you need them, not earlier:

std::wstring Pattern = RootDirectory + L""\\*.*"";
HFILE File = ::FindFirstFileW(Pattern.c_str(), &FileInformation);

There's no need to erase a string if you're assigning a new value. E.g. this works fine.

FilePath = RootDirectory + L""\\"" + FileInformation.cFileName;

Check what this does to files without extensions.
You're leaking a file handle in if(iRC) return iRC;. (C++ objects are cleaned automatically, but this is a C API).

",0,9414017
9392173,"
Well I think your args to std::search is problem 
should be 
as for line :  ifs.seekg(iit) in for loop isn't good , since seekg expects some offset of type streampos not an iterator. so it should be ifs.seekg(0)
",1,9390785
9392181,"
How about something like this:
",1,9390785
9369659,"
You have to link against the boost_system and the boost_filesystem libraries.  How to do this depends on your compiler/linker combination; for example, on my system I have to add the flags -lboost_system-mt -lboost_filesystem-mt.
Some remarks: On Windows, you usually want wstring (or other ""wide character"" object) to increase your chance of working with Unicode paths.  Second, you can make your code much shorter using find_if and recursive_directory_iterator:
My example uses the C++11 features auto and lambda, which are present in GCC 4.6.  If your compiler lacks these, you can easily replace the lambda by a predicate object and the auto by an explicit type specifier:
Another nice variant gets rid of the return value reference using Boost.Optional:
",10,9366040
9211267,"
C++11 comes with support for lambdas:
",1,9211235
9211661,"
If you cannot use C++11. Maybe you can use boost phoenix.
It would be like this:
Although I think in your very simple case bind from boost will also do it.
",2,9211235
9211391,"
Well if you have visual studio 2008 then you cannot use lambda function i guess
The proper way to do is following:
You can also use boost bind or std::tr1 bind to have lambda function like syntax.
As it appears from the msdn visual studio 2008 documentation that you can use std::bind() also
see: http://msdn.microsoft.com/en-us/library/bb982702(v=vs.90).aspx
so you can use :
",1,9211235
9160391,"
If s is a const string &, then s.begin(), and hence the return type of search, is string::const_iterator. This is not convertible to string::iterator, which is the type of i. 
This is as it should be, since otherwise that conversion would break const-correctness by allowing you to modify the string. You should change the type of i to string::const_iterator, or perhaps auto if you're using C++11.
",2,9160317
9160400,"
For a const string, begin() and end() return std::string::const_iterator not std::string::iterator. You can convert an iterator to a const_iterator, but not vice versa.
The quick solution would be to change your typedef:
",4,9160317
9160414,"
if you pass in a const iterator to std::search, then the return value is also a const iterator (it will be of the same type as the first iterator passed in)
change this:
to this:
",1,9160317
8997317,"
You can use lower_bound and upper_bound together.  Your example of testing for elements between 3 and 5, inclusive, could be written as follows:
You can make the range inclusive or exclusive on either end by switching which function you are using (upper_bound or lower_bound):
Logarithmic time is the best you can achieve for this, since the set is sorted and you need to find an element in the sorted range, which requires a dichotomic search.
",4,8997232
8997325,"
If you're certain that you're going to use a std::set, then I agree that its lower_bound method is the way to go. As you say, it will have logarithmic time complexity.
But depending what you're trying to do, your program's overall performance might be better if you use a sorted std::vector and the standalone std::lower_bound algorithm (std::lower_bound(v.begin(), v.end(), 3)). This is also logarithmic, but with a lower constant. (The downside, of course, is that inserting elements into a std::vector, and keeping it sorted, is usually much more expensive than inserting elements into a std::set.)
",0,8997232
8962447,"
Well, this would work, but it's going to be slow ... depending on how big your file is, and how long your program runs (i.e., if it's a persistent program running in the background or a service of some type), it would be a much better idea to memory-map the file, and/or read the entire file into a std::stringstream, and then scan the stored file in memory.  Again, this will all depend on how big your file is, and how persistent the reading program is.  If it's a huge file, and your program is only run once and then quit, then yes, your current method is okay.
",2,8962399
8962473,"
You could make it much more efficient by changing the for loop. As it is, it looks like you go through the entire file, even if you find the account number. Assuming that there are no duplicate numbers, you should set it up to terminate if it finds the the number.
",1,8962399
8962506,"
Depending on your use case, you might be better off using a database engine such as sqlite and let it take care of the searching for you. Sqlite exists as a C++ library that you can use in your program.
",1,8962399
8918808,"
The C++ stack does not support random access, so there is no direct way using a stack to check if an element is contained.  You can, however, make a copy of the stack and then continuously pop off that stack until the element is found.
Alternatively, if you do need to search the stack, you could consider instead using a deque, which does support random access.  For example, you could use the find algorithm on a deque to search for an element:
If you need frequent searches of the stack, consider keeping a parallel set along with the stack that stores the same elements as the stack.  This way, you can just use set::find to check (efficiently) whether the element exists.
Hope this helps!
",8,8918762
8918820,"
If you need to find an element in your container, by definition stack is the wrong container for your needs. With the extremely minimal amount of information you've provided either vector or deque sound like they would provide the interface you need (std::find(c.begin(), c.end(), item);).
",3,8918762
8919395,"
Since you wish to implement DFS and BFS, using std::stack (for DFS) and std::queue (for BFS) is indeed appropriate to keep not yet visited nodes, and you only need to use push() and pop() methods of these containers.
But stack and queue are not sufficient to keep visited nodes. My preference would be to use an associative container, e.g. std::set, better yet unordered_set if your C++ compiler has it, because searching an arbitrary value in an associative container is faster than in a sequence like vector or deque (unless data are sorted there). 
",0,8918762
39735177,"
If you need to search in the stack frequently, consider using a set alongside. Always keep the set updated too: if any element is popped from stack, erase it from the set , and on any push operation onto the stack, insert into the set too.
",0,8918762
8910121,"
For 8- and 16-bit values, you can just make a table of the count of each value; every time you write to a table entry that was previously zero, that's a different value found.  
For larger values, if you are not interested in counts above 100000, std::map is suitable, if it's fast enough. If that's too slow for you, you could program your own B-tree.
",7,8910000
8910135,"
I'm pretty sure you can do it by:

Create a Bloom filter
Run through the array inserting each element into the filter (this is a ""slow"" O(n), since it requires computing several independent decent hashes of each value)
Count how many bits are set in the Bloom Filter
Compute back from the density of the filter to an estimate of the number of distinct values. I don't know the calculation off the top of my head, but any treatment of the theory of Bloom filters goes into this, because it's vital to the probability of the filter giving a false positive on a lookup.

Presumably if you're simultaneously computing the top 10 most frequent values, then if there are less than 10 distinct values you'll know exactly what they are and you don't need an estimate.
I believe the ""most frequently used"" problem is difficult (well, memory-consuming). Suppose for a moment that you only want the top 1 most frequently used value. Suppose further that you have 10 million entries in the array, and that after the first 9.9 million of them, none of the numbers you've seen so far has appeared more than 100k times. Then any of the values you've seen so far might be the most-frequently used value, since any of them could have a run of 100k values at the end. Even worse, any two of them could have a run of 50k each at the end, in which case the count from the first 9.9 million entries is the tie-breaker between them. So in order to work out in a single pass which is the most frequently used, I think you need to know the exact count of each value that appears in the 9.9 million. You have to prepare for that freak case of a near-tie between two values in the last 0.1 million, because if it happens you aren't allowed to rewind and check the two relevant values again. Eventually you can start culling values -- if there's a value with a count of 5000 and only 4000 entries left to check, then you can cull anything with a count of 1000 or less. But that doesn't help very much.
So I might have missed something, but I think that in the worst case, the ""most frequently used"" problem requires you to maintain a count for every value you have seen, right up until nearly the end of the array. So you might as well use that collection of counts to work out how many distinct values there are.
",7,8910000
8914822,"
One approach that can work, even for big values, is to spread them into lazily allocated buckets.
Suppose that you are working with 32 bits integers, creating an array of 2**32 bits is relatively impractical (2**29 bytes, hum). However, we can probably assume that 2**16 pointers is still reasonable (2**19 bytes: 500kB), so we create 2**16 buckets (null pointers).
The big idea therefore is to take a ""sparse"" approach to counting, and hope that the integers won't be to dispersed, and thus that many of the buckets pointers will remain null.
Once you have gathered your data, then you can count the number of different values or find the top or bottom pretty easily.
A few notes:

the number of buckets is completely customizable (thus letting you control the amount of original memory)
the strategy of repartition is customizable as well (this is just a cheap hash table I have made here)
it is possible to monitor the number of allocated buckets and abandon, or switch gear, if it starts blowing up.
if each value is different, then it just won't work, but when you realize it, you will already have collected many counts, so you'll at least be able to give a lower bound of the number of different values, and a you'll also have a starting point for the top/bottom.

If you manage to gather those statistics, then the work is cut out for you.
",2,8910000
8915778,"
For 8 and 16 bit it's pretty obvious, you can track every possibility every iteration.
When you get to 32 and 64 bit integers, you don't really have the memory to track every possibility.
Here's a few natural suggestions that are likely outside the bounds of your constraints.
I don't really understand why you can't sort the array. RadixSort is O(n) and once sorted it would be one more pass to get accurate distinctiveness and top X information. In reality it would be 6 passes all together for 32bit if you used a 1 byte radix (1 pass for counting + 1 * 4 passes for each byte + 1 pass for getting values).
In the same cusp as above, why not just use SQL. You could create a stored procedure that takes the array in as a table valued parameter and return the number of distinct values and the top x values in one go. This stored procedure could also be called in parallel.
",0,8910000
8922101,"
I've just thought of an interesting solution. It's based on law of boolean algebra called Idempotence of Multiplication, which states that: 

X * X = X

From it, and using the commutative property of boolean multiplication, we can deduce that:

X * Y * X = X * X * Y = X * Y 

Now, you see where I'm going to?  This is how the algorithm would work (I'm terrible with pseudo-code):

make c = element1 & element2  (binary AND between the binary representation of the integers)
for i=3 until i == size_of_array
   make b = c & element[i];
   if b != c then diferent_values++;
   c=b;

In first iteration, we make (element1*element2) * element3. We could represent it as:

(X * Y) * Z

If Z (element3) is equal to X (element1), then: 

(X * Y) * Z = X * Y * X = X * Y 

And if Z is equal to Y (element2), then:

(X * Y) * Z = X * Y * Y = X * Y

So, if Z isn´t different to X or Y, then X * Y won't change when we multiply it for Z
This remains valid for big expressions, like:

(X * A * Z * G * T * P * S) * S = X * A * Z * G * T * P * S 

If we receive a value which is factor of our big multiplicand (that means that it has been already computed) then the big multiplicand won't change when we multiply it to the recieved input, so there's no new distinct value.  
So that's how it will go. Each time that a different value is computed then  the multiplication of our big multiplicand and that distinct value, will be different to the big operand. So, with b = c & element[i], if b!= c  we just  increment out distinct values counter.
I guess I'm no being clear enough. If that's the case, please let me know.  
",0,8910000
8903807,"
You will not have problems with that, as std::vector provides you the ""=="", ""<"" and "">"" operators:
http://en.cppreference.com/w/cpp/container/vector/operator_cmp
",14,8903737
8903886,"
The requirements for being a key in std::map are satisfied by std::vector, so yes you can do that. Sounds like a good temporary solution (easy to code, minimum of hassle) -- but you know what they say: ""there is nothing more permanent than the temporary"".
",6,8903737
8903924,"
That should work, as Renan Greinert points out, vector<> meets the requirements to be used as a map key.
You also say:

I'm looking at inserting each dataset into a map before storing it,
  but only if it was not found in the map to start with.

That's usually not what you want to do, as that would involve doing a find() on the map, and if not found, then doing an insert() operation. Those two operations would essentially have to do a find twice. It is better just to try and insert the items into the map. If the key is already there, the operation will fail by definition. So your code would look like this:
",2,8903737
8907210,"
Why do you need a std::map for that? Maybe I miss some point but what about using an std::vector together with the find algorithm as examplained here?
This means, that you append your unsigned ints to the vector and later search for it, e.g.
",0,8903737
8746346,"
Yes, find does the same linear search.
You could hide the loop and the double indirection by using find_if with a suitable predicate: bool operator()(Point* ptr) { return *ptr == point; }
If you want to avoid linear searches, you need to change the way the data is stored. For example keeping the vector sorted would allow std::binary_search, which is faster than std::find. That's sorted by the value pointed to, not sorted by pointer value, so you'd need to pass a comparator to std::sort etc. Or you could use an entirely different container: perhaps one of (unordered_)(multi)set.
",3,8746263
8623296,"
If the data is unsorted, there is no way to assure you can find the missing values without looking at each one. So, worst case would be O(n) to find them. To determine which are missing, you could do it in O(1) by computing the factorial of n and sum(1..n) and dividing out of the product and subtracting from the sum each term you encounter. At the end you'd know which are missing by solving for a + b = remaining sum and a * b = remaining product. This is a cheat though since you are essentially doing a preliminary O(n) computation or else a table-lookup which has a space impact.
",2,8623260
8623478,"
codekaizen's idea can be adapted to make it workable:
Compute U = the sum of all the elements, and V = the sum of squares of all the elements.
If a and b are the missing elements, we have
Substitute b = W - a in the second equation to get
This is a quadratic equation in a, which you can solve.
",0,8623260
8561876,"
One possibility is to represent ranges as a pair of values and define a suitable comparison function. The following should consider one range less than another if its bounds are smaller and there is no overlap. As a side effect, this comparison function doesn't let you store overlapping ranges in the set. 
To look up an integer n, it can be treated as a range [n, n] 
",5,8561113
8562565,"
The standard way to handle this is through so called interval trees. Basically, you augment an ordinary red-black tree with additional information so that each node x contains an interval x.int and the key of x is the low endpoint, x.int.low, of the interval. Each node x also contains a value x.max, which is the maximum value of any interval endpoint stored in the subtree rooted at x. Now you can determine x.max given interval x.int and the max values of node x’s children as follows:
x.max = max(x.int.high, x.left.max, x.right.max)
This implies that, with n intervals,  insertion and deletion run in O(lg n) time. In fact, it is possible to update the max attributes after a rotation in O(1) time. Here is how to search for an element i in the interval tree T 
The complexity of the search procedure is O(lg n) as well.
To see why, see CLRS Introduction to algorithms, chapter 14 (Augmenting Data Structures).
",4,8561113
8561461,"
You could put something together based on std::map and std::map::upper_bound:
Assuming you have
You could do the following:
I'm using C++11, if you use C++03, you'll need to replace ""auto"" by the proper iterator type.
EDIT: replaced pseudo-code inrange() by explicit expression in return statement.
",4,8561113
18246663,"
A good solution can be as the following. It is O(log(n)). 
A critical condition is non overlapping ranges.
",2,8561113
8561220,"
If you have ranges ri = [ai, bi]. You could sort all the ai and put them into an array and search for x having x >= ai and ai minimal using binary search.
After you found this element you have to check whether x <= bi.
This is suitable if you have big numbers. If, on the other hand, you have either a lot of memory or small numbers, you can think about putting those ranges into a bool array. This may be suitable if you have a lot of queries:
",1,8561113
8561179,"
Since the ranges are non-overlapping the only thing left to do is performing a search within the range that fit's the value. If the values are ordered within the ranges, searching is even simpler. Here is a summary of search algorithms.
With respect to C++ you also can use algorithms from STL or even functions provided by the containers, e. g. set::find.
",0,8561113
8561684,"
So, this assumes the ranges are continous (i.e range [100,1000] contains all numbers between 100 and 1000):
In C++03, you'd need a functor instead of a lambda function:
",0,8561113
8598534,"
This is a really cute little problem. If your graph is well connected a greedy approach might work quite well. As in: (1) set current position to be the node closest to the start of the path, (2) move to the adjacent node which is closest to the next point in the path until there is no closer point, (3) select next point in path and goto (2) if not finished.
If this algorithm gets stuck in cycles you will need A* search.
http://www.boost.org/doc/libs/1_47_0/libs/graph/doc/astar_search.html
",2,8553944
8524711,"
getAGrades requires two arguments - score and n.
When you call getAGrades, you only pass in one argument. You should also pass in an argument for n.
Your getAGrades function body also has some errors. Suppose you passed in an array [1,100]. In the first iteration of your for loop, it sees that score[0] == 1, so it returns false. It never gets to score[1] to see that it is above 90. For this reason, you should delay returning false until after you have iterated over the entire array.
One more thing - your cout statements occur after you return a value, so they never get executed. You should put them before the return statements.
",1,8524603
8524672,"
First of all, your question: The function getAGrades takes an int* score, and a int n.  The last thing you do before you return from main is call getAGrades(score);, but you don't give it a size.  You have to also pass the size: getAGrades(score, size).
Second: why does your compare function take void*?  That's dangerous for no reason.  Why aren't you using the type-safe std::sort with a safe comparison function?
Third: getAGrades returns right before each cout, so it will never ever display anything.  It should cout, and then return.
Edit: Keven also noticed that getAGrades returns when it finds a grade that isn't an A.  As he explained, such a function should return when it finds an A grade, or if it checked ALL of the grades without finding any.  Remove the ""No A Grades"" block to after the for loop.
Fourth: Your cin.ignore doesn't do anything useful, since you only have formatted input.  Also, use '\n' instead of 10, otherwise you're going to confuse people, and it's more portable.
Fifth: Prefer standard containers to allocating your own arrays.  Because your code leaks the score array.
",2,8524603
8524861,"
Use std::sort and std::vector.
I know it's not really the answer to this problem.
But when you want to use C++ you shouldn't try to use these C-functions like qsort.
With std::sort you can sort c arrays too.
qsort(score, size, sizeof(int), compare); becomes std::sort(score, score+size); (or std::sort(score, score+size, compare);)
C++ way (use of std::vector and std::sort, with fixed getAGrades function):
",1,8524603
8511886,"
(I have changed this answer since the asker clarified that his ranges do not overlap.)
If the set of ranges does not change, you can use a sorted vector and binary search, as suggested in ravenspoint's answer.
If the set of ranges changes over time, you might still use a sorted vector, or you might want to use a std::map.  You need to try both and see which one is faster in that case.
",4,8511821
8512496,"
vector< pair< int>> stored sorted so you can binary search perhaps?
",2,8511821
8511989,"
Assuming the ranges do not overlap:
Store each range in a simple structure
Store the ranges in a sorted vector, by low.
Find required range using binary search for largest low less than target.
",1,8511821
8513947,"
just dump all the values , starting and ending into a vector or array, and then sort it. since the ranges dont overlap, once the array is sorted, you will have start, stop,start,stop,etc.. then, you could use a binary search to find the index of the vector. then its just a question of whether its odd or even
assuming, you are getting the ranges from the stream
where binary search would be defined as 
hopefully I didn't screw up the binary search, but it is designed in such a way, that if the value is not found, the index of the next largest value is returned.
",0,8511821
8518744,"
why not use a B+ tree?
With B+ tree, the fan-out would be small and search would be fast too.
",0,8511821
8426270,"
Your general approach isn't bad.
However, you can prevent having to search for each permutation by rearranging your word so that all it's characters are in alphabetical order, then searching on a dictionary where each word is similarly re-arranged into alphabetical order and mapped to the original word.
I realise that might be a little hard to grasp as is, so here's an example. Say your word is leap. Rearrange this to aelp.
Now in your dictionary you might have the words plea and pale. Having done as suggested, your dictionary will (among other things) contain the following mappings:
So now, to find your anagrams you need only find entries for aelp (using, for example, a suffix-tree approach as suggested), rather than for all 4! = 24 permutations of leap.
",7,8426178
8426233,"
A quick alternative solution - all depends on the sizes of data structures in question.  
If the dictionary is reasonable small and the string is reasonably long, you can go over each entry in the dictionary and figure out if they are a permutation of the string. You can be smarter - you can sort the dictionary and skip certain entries. 
",2,8426178
8426286,"
You can build a map from a sorted list of characters to a list of words. 
For example, given these: 
you would sort them internally:
sort the result: 
In this small sample, we don't have a match, but for a particular word, you would sort it internally, and with this as key look into your map. 
",1,8426178
8426409,"
Why don't you use a hash map to store the dictionary words? So you get O(1) lookup time. And  if your input is in english, you can build another table to tell all the possible letters in your dictionary, using this table, you can filter some inputs at the beginning. Following is an example:
",1,8426178
8435172,"
You should put the words into a trie.  Then you can look up the word as you generate the permutations.  You can skip over whole blocks of permutations with the first part is not in the trie.
http://en.wikipedia.org/wiki/Trie
",1,8426178
8427237,"
Another simple solution could be as algorithm below,
1) Use ""next_permutation"" to find a unique permutation.
2) Use ""find/find_if"" to find it against a dictionary.
",0,8426178
8423277,"
You should try Boost Multi Index, which is meant for just this kind of thing.
",0,8423151
8423237,"
One array for the data, four hash tables (std::tr1::unordered_map) for the indexes.
",0,8423151
8395257,"
A simple way to do this would be to use a structure like this:
This structure would store one row of your .txt file and a pointer to the next row. This makes it a linked list. The table variable would point to the head of the list — the first row.
To store the list, you would go through the table and write each row to a new line with fprintf.
To search through the list, you would iterate through the table and compare the target string with the name member of each row (or whatever you call it). With a linked list you are, pretty much, limited to sequential search.
I presume that you covered user input and basic list algorithms in class. Feel free to ask, if you have any problems.
",3,8395132
8395744,"
You can review the following concepts in c++ and then tackle your problem

File Handling
Linked Lists : This wikipedia entry and its external links would help you learn the basic operations on linked lists.
Searching: You can implement a searching algorithm of your choice to find the required info. Basic search algorithm like linear search  would suffice.
Integrate these concepts and solve your problem!

You can use Don Reba's structure to implement the nodes of the linked list
",0,8395132
8394350,"
In your search() function, the do { } while; { } construct is flawed. It will compile but it doesn't do what you want. I made a few changes and rearranged your code so it makes more sense.
SO, is this too much homework help? Should I delete this?
",2,8394020
8394088,"
I find it interesting that you set last in both cases where you don't find a match.
The first thing you should do is think about what that means, nudge, nudge, wink, wink :-)
You should also pass the number of used elements to search as well, rather than the size of the array (since you may not be using the full array).
",2,8394020
8394083,"
I suppose that
should be
Binary search's input condition is that the searched-in array is sorted. Your array looks like this:
Since an empty string is not less than a non-empty string, friendArray[0..maxsize] is not sorted, while the array friendArray[0..sub] is.

EDIT: I also just noticed that your binary search algorithm is flawed. Look again at your source material (text book, wikipedia, whatever). Isn't first supposed to be updated inside your loop?
",1,8394020
8394096,"
Operator >> reads formatted data from the stream, i.e. discards white spaces. When you say cin >> name; and enter ""Elvis Presley"", only ""Elvis"" get stored in name.
What you need is getline(cin, name);
",1,8394020
8394092,"
Think what will happen if the length of your friends array would be 3. If I'm not mistaken there will be a problem.
Also it is recommended to use safer data types, like vector<string> for example, then you do not need to care about too much data in the input file. Also your life will get easier in the search function, since you can use iterators and do not need to pass the size of the array.
Take a look at what people say in the other answers about cin.
",1,8394020
8394324,"
This is one do-whie loop:
The code will basically loop forever (friends will never be true and first will never be > last), prompting you for a name  until you either kill the program or type in ""END"". 
This:
will not get a chance to execute until the loop condition is false (in this case, until you type in ""END""). 
",1,8394020
8394175,"
You say that all seems to be working except when you entered a name to be searched. Actually , you stepped into point.There is a mistake in your binary search code. And the first answer in this topic is toward this way.
If array is used in binary search , it must be split into two parts in each stage of search. 
For example  in a stage if current part is marked as follows : first - middle - last on the next stage the parts will be either between first - middle-1 or middle+1 - last.
So
must be
",0,8394020
8394230,"
You have an off-by-one error in your sort.
",0,8394020
8394093,"
The problem is in function search. move the } after cin>>name to the end of the function to look like:
",-1,8394020
8359636,"
Soundex along with its variants is the standard algorithm for this. It uses phonetic rules to transform the name into an alphanumeric code. Names with the same code are grouped together.
As far as implementing the search, I'd use a data structure that maps each soundex code to the list of names that have that code. Depending on the data structure used (a hash table or a tree), the lookup could be done in time that is either constant on logarithmic in the number of distinct soundex codes.
I am not sure what exactly you mean by cstring (Microsoft's CString?) but the standard std::string class will be perfectly fine for this problem and would be my preferred choice.
",15,8359595
9190100,"
Besides Soundex you'll find also the Metaphone or Double Metaphone phonetic algorithm, which seem to be an improvement for the English pronunciation and is a quite new algorithm. 
For the german pronunciation I use the ""Kölner Phonetik"".
Apache Commons Codec gives you a very simple Java implementation of those basic algorithms (Soundex, Metaphone, ...)
http://commons.apache.org/codec/
For example see the javadoc for the soundex:
http://commons.apache.org/codec/apidocs/org/apache/commons/codec/language/Soundex.html
Just by typing following code you the the phonetic value of your String:
And then you can simply do it for two strings and compare the phonetic values.
Hava a look at the following post if you're comparing two strings, because the equals() methods is just black and white, and maybe you'd like to know how many % it is matching:
How to compare almost similar Strings in Java? (String distance measure)
",22,8359595
8277596,"
You could extract a substring from the string starting from the last /, but to be most efficient (that is, to avoid making a needless copy of the data you want to print), you can use string::rfind as well as ostream::write:
If you needed to extract the file name and use it later instead of just print it immediately, then bert-jan's or xavier's answers would be good.
",4,8277581
8277606,"
Try 
",3,8277581
8277603,"
",0,8277581
8277729,"
You might use _splitpath() see http://msdn.microsoft.com/en-us/library/e737s6tf.aspx form MSDN. 
You can split paths into components with this STD RTL function. 
",0,8277581
8176901,"
Probably you would best create two functions. One to check if a pattern matches a string at some given position, and another one that uses the first function to check all positions in the input string.
The function that checks for a matching pattern would loop over all characters in the pattern, and for each of those characters check if it is either ? or is identical to the character at the corresponding position in the input string.
",2,8145552
8145614,"
I felt bad for only hinting on backtracking and recursion in a comment. Here's an explanation:
Strategy:
Focus on the tokens between wilcards (the wildcards are not what should be matched).

extract first token from pattern
exit with success for no (more) tokens
for each token match in input

match the remainder of the pattern against the remainder of the input
if no successful submatch, fail, otherwise done


There is recursion (the matching of the remainder class match(....) recursively).
There is backtracking (if the recursive match doesn't succeed, we try the next token submatch)
Sample (see https://ideone.com/yApYp)
Only using loops and std::string interface (well, and iostreams for displaying test output) :)
",2,8145552
8149855,"
Perhaps think of the wildcard character as matching every character until you reach the next character or the end of the string. So the algorithm would be: 
",0,8145552
8145602,"
Here is the function I came up with. Finally I found a way using limited knowledge of mine. It works, but probably performance is really bad.
Thanks for your all help, they inspired me even though I can't directly use them because of advanced-for me- techniques. 
",0,8145552
14377759,"
See my answer here, which should also be fast enough for most purposes (it avoids heap allocations as much as possible, and it's basically a nondeterministic finite-state automaton).
",0,8145552
23656733,"
On the past week I started to move my private & public repositories from bitbucket, and I remembered about this.
The open implementation of C++ wildcards. Native C/C++ & .NET
Now it separated into new project from my sandbox as lightweight, fast and powerful wildcards in addition to slow regex engine etc.
enum MetaSymbols
{
    MS_ANY      = _T('*'), // {0, ~}
    MS_SPLIT    = _T('|'), // str1 or str2 or ...
    MS_ONE      = _T('?'), // {0, 1}, ??? - {0, 3}, ...
    MS_BEGIN    = _T('^'), // [str... or [str1... |[str2...
    MS_END      = _T('$'), // ...str] or ...str1]| ...str2]
    MS_MORE     = _T('+'), // {1, ~}
    MS_SINGLE   = _T('#'), // {1}
    MS_ANYSP    = _T('>'), // as [^/]*  //TODO: >\>/ i.e. '>' + {symbol}
};

How to implement own, etc. Look here:

https://github.com/3F/regXwild

However, it also possible and for .NET users via Conari engine.
In general, see implementation for 'how it works' or use 'as is' (MIT license)
#include ""regXwildAPI.h""

using namespace net::r_eg::regXwild;

...
if(searchEssC(_T(""regXwild""), _T(""reg?wild""), true)) {
    // ...
}

searchEss(data, _T(""^main*is ok$""));
searchEss(data, _T(""^new*pro?ection""));
searchEss(data, _T(""pro*system""));
searchEss(data, _T(""sys###s""));
searchEss(data, _T(""new+7+system""));
searchEss(data, _T(""some project|open*and*star|system""));
...

Thus, I updated my old answer. Enjoy.
",0,8145552
8123373,"
Basically, you're asking if it's possible to check all elements for a
match, without checking all elements.  If there is some sort of external
metainformation (e.g. the data is sorted), it might be possible (e.g.
using binary search).  Otherwise, by it's very nature, to check all
elements, you have to check all elements. 
If you're going to do many such searches on the list, and the list
doesn't vary, you might consider calculating a second table with a good
hash code of the entries; again depending on the type of data being
looked up, it could be more efficient to calculate the hash code of the
index, and compare hash codes first, only comparing the strings if the
hash codes were equal.  Whether this is an improvement or not largely
depends on the size of the table and the type of data in it.  You might
also be able to leverage off knowledge about the data in the strings; if
they are all URL's, for example, mostly starting with ""http://www."",
starting the comparison at the tenth character, and only coming back to
compare the first 10 if all of the rest are equal, could end up a big
win.
With regards to finding substrings, you can use std::search for each
element:
Depending on the number of elements being searched and the lengths of
the strings involved, it might be more efficient to use something like
BM search, however, precompiling the search string to the necessary
tables before entering the loop.
",5,8122488
8122520,"
Use binary_search after sorting the vector

std::sort( serverList.begin() , serverList.end() )
std::lower_bound(serverList.begin() , serverList.end() , valuetoFind) to find first matching
Use std::equal_range if you want to find all matching elements

The lower_bound  & equal_range search because it is binary is logarithmic compared to your search that is O(N)
",8,8122488
8122847,"
If you make the container a std::map instead of a std::vector, the underlying data structure used will be one that is optimized for doing keyword searches like this.
If you instead use a std::multimap, the member function equal_range() will return a pair of iterators covering every match in the map. That sounds to me like what you want.
A smart commenter below points out that if you don't actually store any more infomation than the name (the search key), then you should probably instead use a std::multiset.
",2,8122488
8014894,"
I tried the following
And it did compile without error ...
",3,8014798
8014911,"
How about simply not caring about the return type? :)
",4,8014798
8014835,"
You have a const string, so it must be a const_iterator:
",1,8014798
8015071,"
Early implementations of string could easily have used char* as their iterator type, allowing this incorrect code snippet to compile properly. Most modern implementations of string::iterator have a proper class type and would not be convertible to char*.
The signature for std::search is:
As you can see, the return type is the same as the type of the first two iterators passed to the function. In your case string::iterator should have worked, unless there is some part of the code you did not show us that made quote const in which case you could use string::const_iterator.
",1,8014798
8014968,"
Per SGI documentation, the form of search you are using has the signature:
Since your FowardIterator1 type is std::string::iterator, your return type must be std::string::iterator as well.
",0,8014798
8008586,"
In both cases, I think you probably want to construct a patricia trie (also called radix tree). Most importantly, lookup time would be O(k), where k is the max length of a string in the trie.
",1,8008477
8008967,"
Note that Boyer-Moore is to search a text (several words) within a text.
If all you want is identifying some individual words, then it's much easier to:

put each searched word in a dictionary structure (whatever it is)
look-up each word of the text in the dictionary

This most notably mean that you read the text as a stream, and need not hold it all in memory at once (which works great with the typical example of a file cursor).
As for the structure of the dictionary, I would recommend a simple hash table. Works great memory-wise compared to tree structures.
",1,8008477
7975428,"
Recursion can be difficult to explain, but I'll try my best explaining how it applys in this situation.  Since you are able to recursively check weither each node exists, you will want to return the id as the return string.  This notifies up the recursive stack that a match has been found.  You then append the current node's id to the string and return it up the stack.  This in turn notifies up the stack that a match has been found, etc.  Here is my solution, which I've added multiple comments to better illustrate the point.
Most recursive functions follow a similar pattern.  If you still a little lost, I would recommend running it through a debugger so you can see exactly what is going on.
",0,7974995
7960286,"
I Belive that the following code give you a notion of what you should do (recursion):
",1,7960039
7960089,"
You should basically keep the node from which you arrived to the current, for each node you're going through. Then just pop them out and print them when you found the correct path.
If you keep them in a std::stack structure it will be easy for you to just pop them when you're going back after reaching leaves and not finding the needed id.
If you do it recursively then you just have the stack of your calls and it should be enough, if you convert them to loops (iteratively), then you need the std::stack to remember the states, but it's fairly simple, really.
",0,7960039
7960097,"
Rough outline of algorithm:
",0,7960039
7933489,"
I think.  It's hard to tell.  print other people in a paticular class when a course ID is inputed using this prototype: void printList (ostream& out, FlexArray<Student> majors, int cosID, string course);  Does this mean print all the students who are taking course, except for that who's COSID is the cosID parameter?
",2,7933411
7843111,"
When you say you want the ranking to be in linear time, I guess you only want to analyse each string in the set once. 
One relatively simple way to do that would be to calculate a score based on some rules you define. Of course, the more rules you have the longer it will all take, but as long as you implement the analysis well it shouldn't take long even for thousands of strings.
An example would be that you say exact matches gain a score of 100, while containing the search string n number of times achieves a score of 10n, and containing it within another word n times gets 5n, and so on. If you implement your rules in a fairly decoupled way, you could tweak your rules a few times and see how well they perform under real searches until you're happy with the accuracy of the search.
Once you have a set of scores, you can use some very fast sorting algorithm to sort your results for you in order of best score to worst. Of course, you would exclude results of a score less than x.
(Just as a side note, this technique would make it very easy to implement advanced search features, such as AND/OR/NOT, because you could split the analysis for search terms and combine their scores per result)
",1,7843050
7843182,"
There are different strategies and requirements to establish the ranking. 
http://wiki.apache.org/solr/SolrRelevancyCookbook 
http://lucene.apache.org/java/2_4_0/scoring.html#Algorithm
BTW Solr is an solution by itself, I am pretty sure you know that by this time already :-) 
Solr, Sunspot, SQlite, and Rails
",1,7843050
7720898,"
As there is no transform_if, a proper way to do this would be to to first copy_if the paths that have a non-zero-length get_pertinent_part result into another container, and then run the  transform on that new container.
Alternatively, you could write something like transform_if that compares the result of your transform function with a predicate. Here's my untested shot at it:
Then you could use that like
For even cooler syntax, check out boost's Range adaptors:
",4,7720743
7721181,"
You can use std::accumulate (not from <algorithm> but from <numeric>) to, well, accumulate the matches into your output.
Call as:
Note the use of std::ref (from <functional>). You don't want the output set to be moved around (plus the result of the call to std::accumulate is ignored so no changes will be visible). Alternatively, if you don't want a dependency on std::ref, you can use pointers.
edit: heh, revisiting this idea, this is arguably no better than using std::for_each and passing a reference to the ouput to the constructor of the functor. YMMV.
",2,7720743
7717353,"
A relatively simply C++11 implementation.  This could be modified to C++03 easily.  (caveat: have not compiled or tested this).
",1,7717182
7717352,"
This sounds like a great opportunity to use regex stuff in Boost/C++11
Something like
Sorry I can't provide the regex syntax... I need to study that more.
",1,7717182
7717473,"
The ordered containers have a set of methods that are quite useful in finding a range of iterators: lower_bound and upper_bound. In your case, you want to use:
",1,7717182
7633326,"
There are two issues concerning the spead: the time it takes to actually
read the data, and the time it takes to search.
Generally speaking, the fastest way to read a file is to mmap it (or
the equivalent under Windows).  This can get complicated if the entire
file won't fit into the address space, but you mention 10GB in the
header; if searching is all you do in the program, this shouldn't create 
any problems.
More generally, if speed is a problem, avoid using getline on a
string.  Reading large blocks, and picking the lines up (as char[])
out of them, without copying, is significantly faster.  (As a simple
compromize, you may want to copy when a line crosses a block boundary.
If you're dealing with blocks of a MB or more, this shouldn't be too
often; I've used this technique on older, 16 bit machines, with blocks
of 32KB, and still gotten a significant performance improvement.)
With regards to searching, if you're searching for a single, fixed
string (not a regular expression or other pattern matching), you might
want to try a BM search.  If the string you're searching for is
reasonably long, this can make a significant difference over other
search algorithms.  (I think that some implementations of grep will
use this if the search pattern is in fact a fixed string, and is
sufficiently long for it to make a difference.)
",2,7633077
7635393,"
Use multiple threads. Each thread can be responsible for searching through a portion of the file.  For example on a 4 core machine spawn 12 threads.  The first thread looks through the first 8%evening of the file, the second thread the second 8% of the file, etc.  You will want to tune the number of threads per core to keep the cpu max utilized. Since this is an I/O bound operation you may never reach 100% cpu utilization.
Feeding data to the threads will be a bottleneck using this design.  Memory mapping the file might help somewhat but at the end of the day the disk can only read one sector at a time.  This will be a bottleneck that you will be hard pressed to resolve.  You might consider starting one thread that does nothing but read all the data in to memory and kick off search threads as the data loads up.
",2,7633077
7633150,"
Since files are sequential beasts searching from start to end is something that you may not get around however there are a couple of things you could do.
if the data is static you could generate a smaller lookup file (alt. with offsets into the main file), this works good if the same string is repeated multiple times making the index file much smaller. if the file is dynamic you maybe need to regenerate the index file occassionally (offline) 
instead of reading line by line, read larger chunks from the file like several MB to speed up I/O.
",1,7633077
7633123,"
If you'd like to do use a library you could use xapian. 
You may also want to try tokenizing your text before doing the search and I'd also suggest you to try regex too but it will take a lot if you don't have an index on that text so I'd definitely suggest you to try xapian or some search engine.
",0,7633077
7633334,"
If your big text file does not change often then create a database (for example SQLite) with a table:
Read your file and insert a record in database for every word with something like this:
Create an index of words:
And then you can find line numbers for words fast using this index:
For added speed (because of smaller database size) and complexity you can use 2 tables: words(word_id integer primary key, word not null) and word_lines(word_id integer not null references words, line_number integer not null).
",0,7633077
7633389,"
I'd try first loading as much of the file into the RAM as possible (memory mapping of the file is a good option) and then search concurrently in parts of it on multiple processors. You'll need to take special care near the buffer boundaries to make sure you aren't missing any words. Also, you may want to try something more efficient than the typical strstr(), see these:
Boyer–Moore string search algorithm
Knuth–Morris–Pratt algorithm
",0,7633077
14124452,"
The C++ standard library has some abstract algorithms, which give C++ a kind of functional flavour, as I call it, which lets you concentrate more on the criteria of your search than on how you implement the search itself. This applies to a lot of other algorithms.
The algorithm you are looking for is std::find_if, a simple linear search through an iterator range.
In C++11, you can use a lambda to express your criteria:
When not having C++11 available, you have to provide a predicate (function object (=functor) or function pointer) which returns true if the provided instance is the one you are looking for. Functors have the advantage that they can be parameterized, in your case you want to parameterize the functor with the ID you are looking for.
This method returns an iterator pointing to the first element found which matches your criteria. If there is no such element, the end iterator is returned (which points past the end of the vector, not to the last element). So your function could look like this:
",17,14124395
14124411,"
Using std::find_if.
There's an example on the referenced page.
Here's a working example that more precisely fits your question:
And, if you have C++11 available, you can make this even more concise using a lambda:
",11,14124395
14124662,"
This isn't really an answer to your question. The other people who answered gave pretty good answers, so I have nothing to add to them.
I would like to say though that your code is not very idiomatic C++. Really idiomatic C++ would, of course, use ::std::find_if. But even if you didn't have ::std::find_if your code is still not idiomatic. I'll provide two re-writes. One a C++11 re-write, and the second a C++03 re-write.
First, C++11:
Second, C++03:
The standard way of going through any sort of C++ container is to use an iterator. It's nice that vectors can be indexed by integer. But if you rely on that behavior unnecessarily you make it harder on yourself if you should change data structures later.
",3,14124395
14124416,"
If the ids are sorted you may perform binary search(there is also a function binary_search in stl). If they are not nothing will perform better, but still you may write your code in a shorter way using stl(use find_if).
",2,14124395
14113232,"
This is a great use-case for a full-text search engine like Apache Lucene
",1,14112612
14113242,"
The easiest way to do this with MySQL is by using FULLTEXT search. It doesn't search, as you put it, the 'entire sql database,' but it can search a lot of columns.  This works pretty well.
The syntax is a little different from what you're used to.  This might do the trick for you.
I'll leave it to you to adapt that SQL statement to Java.
Here's the documentation.
http://dev.mysql.com/doc/refman/5.0/en/fulltext-search.html
",1,14112612
14000610,"
If I'm understanding your code correctly, you're performing a (recursive) brute-force search. This is not efficient, since you're given some information about your search space.
I think a good candidate here would be the A* algorithm. You could use the current greatest-chain size as the heuristic, or perhaps even the sum of the squares of the chain sizes.
",1,13998776
13999161,"
To improve your code, as you use vectors, you should use the [] operator, with a int counter instead of simple iterators, that are much much slower.
You can improve it even more by minimising the function calls i either of your loops, like previously stacking the values you will use.
Since you didn't explained what really was a T_VEC, i coudln't not wrote the complete iterator-free version, but this should already be a great plus regarding speed.
",-1,13998776
13975257,"
Check to make sure your strings really are equal, and there's not a hidden \r or \n or trailing spaces in one of them.
Also as mentioned in the comments, you probably want your loop termination condition to be cur != NULL and not cur->next != NULL.
",1,13975115
13975314,"
There are two possibilities:

You have no movies in your list whose title is mtitle.
You have a movie with that title, but it is the last movie in your list. Your while loop ends as soon as you get to the last movie (the one whose next == NULL) without checking it.

Without knowing the contents of your list we cannot know which is the case here.
",1,13975115
13922616,"
With QuickSelect it is not feasible to return the original index of the k-th statistic. The algorithm is in-place and it scrambles the array. You'd have to make a copy of the original array at the start (or track elements as they move, which also takes O(n) memory and is much more complicated.)
",2,13921809
13872212,"
I just read the wikipedia article.  Lets see if I can write an n dimensional range tree.  Because anything worth doing in 3 dimensions is worth doing in n.
So the basic part of an n-dimensional range tree is that it can be recursively defined in terms of lower dimensional range trees.
Some property classes to work with relatively generic value types.  Specialize element_properties<T> to set the scalar type of whatever your n-dimensional value is, and specialize get<i>(T const&) to get the ith dimension of your n-dimensional value.
which is pretty damn close to an n-dimensional range tree.  The 0 dimension tree naturally contains nothing.
Basic facilities to search (in one dimension at a time) have been added now.  You can manually do the recursions into lower dimensions, or it up so that the range_search always returns level 1 tree_node*s.
",3,13871394
13844370,"
You shouldn't have to implement anything, if the Qt documentation is valid. Just use std::binary_search with your list's .begin() and .end(), and if you need to implement a comparator, do so and pass it to the STL algorithm.
",6,13844200
13788993,"
Suffix tree is an efficient data structure for substrings search.
The idea is:
Create your suffix tree data structure, and from each leaf connect to the entry related to the book/s this suffix represents.
On query time - traverse the tree with the substring - and from the end point you reached (the longest match) - do some traversal (DFS for example) and retrieve all entries related to all suffixes that the query is a prefix of.

Of course, if you want only words and not all substrings, a map (tree/hash based) will probably be enough, and much easier to implement and use (The type should be map<string,list<book> > for example with the tree based approach, and it will map from each word to a list that contains all the books containing this word in the title).
You can also use a trie to implement the map.
",6,13788962
13789441,"
For substring matching there is a simple scheme: split out the full title in ""chunks"" and create your database in the following fashion:

each book is identified uniquely (ID/pointer)
each ""chunk"" points to a set of book identifiers

When the user queries the system, split her request in chunks the same way to identify the matching books.
With this simple scheme, you have 2 points of functional customization: how to derive the chunks and how to rank the books; and 1 point of technical customization: how to ""merge/join"" the sets of the different matching chunks, which hinges on the way you want to rank the books.

How to derive chunks ?

A simple (but efficient) way would be to split on words boundary: The C++ Programming Language becomes {the, c++, programming, language}.
Note: often times, some words are ignored (black-listed). For example, The probably appear in 80% of the titles so it's not useful to consider it most of the times.
Note: the search should probably be case insensitive.

How to rank books ?

A naive algorithm is to return all the matches. A better one is to rank them according to the number of chunks in the query that matched that ID. An even better one is to rank higher those titles in which the words appear in the same order than the query (longest submatch). And of course you should perhaps consider synonyms.
The ranking is probably the heart of the system, Google is popular because its ranking algorithm works well meaning that if finds what you want.

How to implement the merge/join ?

Unless you only want to return search results that match all chunks in the original query (which is useful, but annoying because of synonyms), then you should keep ordered sets and build their intersection for each chunk:

chunk1: {B1, B2, B7, B9, B15}
chunk2: {B1, B7, B8, B13, B15}
chunk3: {B1, B3, B4, B7, B9, B12, B13, B14, B15}

Then, intersect the sets of chunk1 and chunk2, leading to {B1, B7, B15} and intersect that with chunk3 (which does not change anything).
Note: beginning with the smaller sets allow you to keep smaller intermediate results which speeds up the result.
Note: when intersecting a small set with a much bigger set, linear walk of the bigger set might be much slower than binary search.
On the other hand, if you want to rank search results, then it's likely that you will need to keep as intermediary result a map ID -> score. That map may be either a binary search tree or a hash map (the latter being faster for very large collection but having some overhead for small ones in general).
Note that this ranking stuff is quite slow, in general, but easily parallelizable. That's what Google does with MapReduce.
",2,13788962
13776665,"
In an unsorted array where no information is known, you are going to have to do linear time search.
Linear time search checks each element once, so it's complexity is O(n). Comparing that to sorting. Sorting algorithms which must check each element more than once and have a complexity of O(n * log n). So to even get it sorted is slower than a sequential search. Even though binary search is O(log n) it's pretty useless when you just have arbitrarily ordered data.
If your going to search for stuff multiple times though, consider sorting first as it'll increase your efficiency in the long run.
",10,13776629
13776660,"
It's only going to be faster to sort before searching if you need to do multiple searches. If you only need to find a single element, then sorting will be slower, as sorting will necessarily have to inspect every element at some point anyway.
If you are doing multiple searches it may be worth sorting first, but the break-even point (between linear search, and a pre-sort + binary searching) will depend on the number of searches required, the number of elements, the sorting algorithm used, and the data being sorted.
",4,13776629
13679601,"
You are visiting all the nodes of the BST , irrespective of whether they lie in the range or not.
And printing only the required values.
A more refined algorithm would be :

Do inorder traversal of the BST.
Start from the root.
Process left subtree for inorder traversal only if the root of left subtree is smaller than 'lowValue'
Process right subtree only if root of right subtree is greater than 'highValue'
Else just return from the function.
This way you do a filtered inorder traversal,visiting only the required part of your BST .

",1,13679391
40354422,"
The answer to this question, is psuedo code, should have been this:
",1,13679391
13664808,"
Several people have made claims about the relevance of “sorted”, “distinct” and “aren't necessarily integers”.  In fact, proper selection of an efficient algorithm to solve this problem hinges on these characteristics.  A more efficient algorithm would be possible if we could know that the values in the array were both distinct and integral, while a less efficient algorithm would be required if the values might be non-distinct, whether or not they were integral.  And of course, if the array was not already sorted, you could sort it first (at average complexity O(n log n)) and then use the more efficient pre-sorted algorithm (i.e. for a sorted array), but in the unsorted case it would be more efficient to simply leave the array unsorted and run through it directly comparing the values in linear time (O(n)).  Note that regardless of the algorithm chosen, best-case performance is O(1) (when the first element examined contains its index value); at any point during execution of any algorithm we might come across an element where a[i] == i at which point we return true; what actually matters in terms of algorithm performance in this problem is how quickly we can exclude all elements and declare that there is no such element a[i] where a[i] == i.
The problem does not state the sort order of a[], which is a pretty critical piece of missing information.  If it’s ascending, the worst-case complexity will always be O(n), there’s nothing we can do to make the worst-case complexity better.  But if the sort order is descending, even the worst-case complexity is O(log n): since values in the array are distinct and descending, there is only one possible index where a[i] could equal i, and basically all you have to do is a binary search to find the crossover point (where the ascending index values cross over the descending element values, if there even is such a crossover), and determine if a[c] == c at the crossover point index value c.  Since that’s pretty trivial, I’ll proceed assuming that the sort order is ascending.  Interestingly if the elements were integers, even in the ascending case there is a similar “crossover-like” situation (though in the ascending case there could be more than one a[i] == i match), so if the elements were integers, a binary search would also be applicable in the ascending case, in which case even the worst-case performance would be O(log n) (see Interview question - Search in sorted array X for index i such that X[i] = i).  But we aren’t given that luxury in this version of the problem.
Here is how we might solve this problem:
Begin with the first element, a[0].  If its value is == 0, you’ve found an element which satisfies a[i] == i so return true.  If its value is < 1, the next element (a[1]) could possibly contain the value 1, so you proceed to the next index.  If, however, a[0] >= 1, you know (because the values are distinct) that the condition a[1] == 1 cannot possibly be true, so you can safely skip index 1.  But you can even do better than that:  For example, if a[0] == 12, you know (because the values are sorted in ascending order) that there cannot possibly be any elements that satisfy a[i] == i prior to element a[13].  Because the values in the array can be non-integral, we cannot make any further assumptions at this point, so the next element we can safely skip to directly is a[13] (e.g. a[1] through a[12] may all contain values between 12.000... and 13.000... such that a[13] could still equal exactly 13, so we have to check it).
Continuing that process yields an algorithm as follows:
This has pretty good performance if many of the values in a[] are greater than their index value, and has excellent performance if all values in a[] are greater than n (it returns false after only one iteration!), but it has dismal performance if all values are less than their index value (it will return false after n iterations).  So we return to the drawing board... but all we need is a slight tweak.  Consider that the algorithm could have been written to scan backwards from n down to 0 just as easily as it can scan forward from 0 to n.  If we combine the logic of iterating from both ends toward the middle, we get an algorithm as follows:
This has excellent performance in both of the extreme cases (all values are less than 0 or greater than n), and has pretty good performance with pretty much any other distribution of values.  The worst case is if all of the values in the lower half of the array are less than their index and all of the values in the upper half are greater than their index, in which case the performance degrades to the worst-case of O(n).  Best case (either extreme case) is O(1), while average case is probably O(log n) but I’m deferring to someone with a math major to determine that with certainty.
Several people have suggested a “divide and conquer” approach to the problem, without specifying how the problem could be divided and what one would do with the recursively divided sub-problems.  Of course such an incomplete answer would probably not satisfy the interviewer.  The naïve linear algorithm and worst-case performance of algorithm 2 above are both O(n), while algorithm 2 improves the average-case performance to (probably) O(log n) by skipping (not examining) elements whenever it can.  The divide-and-conquer approach can only outperform algorithm 2 if, in the average case, it is somehow able to skip more elements than algorithm 2 can skip.  Let’s assume we divide the problem by splitting the array into two (nearly) equal contiguous halves , recursively, and decide if, with the resulting sub-problems, we are likely to be able to skip more elements than algorithm 2 could skip, especially in algorithm 2’s worst case.  For the remainder of this discussion, let’s assume an input that would be worst-case for algorithm 2.  After the first split, we can check both halves’ top & bottom elements for the same extreme case that results in O(1) performance for algorithm2, yet results in O(n) performance with both halves combined.  This would be the case if all elements in the bottom half are less than 0 and all elements in the upper half are greater than n-1.  In these cases, we can immediately exclude the bottom and/or top half with O(1) performance for any half we can exclude.  Of course the performance of any half that cannot be excluded by that test remains to be determined after recursing further, dividing that half by half again until we find any segment whose top or bottom element contains its index value.  That’s a reasonably nice performance improvement over algorithm 2, but it occurs in only certain special cases of algorithm 2’s worst case.  All we’ve done with divide-and-conquer is decrease (slightly) the proportion of the problem space that evokes worst-case behavior.  There are still worst-case scenarios for divide-and-conquer, and they exactly match most of the problem space that evokes worst-case behavior for algorithm 2.
So, given that the divide-and-conquer algorithm has less worst-case scenarios, doesn’t it make sense to go ahead and use a divide-and-conquer approach?
In a word, no.  Well, maybe.  If you know up front that about half of your data is less than 0 and half is greater than n, this special case would generally fare better with the divide-and-conquer approach.  Or, if your system is multicore and your ‘n’ is large, it might be helpful to split the problem evenly between all of your cores, but once it’s split between them, I maintain that the sub-problems on each core are probably best solved with algorithm 2 above, avoiding further division of the problem and certainly avoiding recursion, as I argue below....
At each recursion level of a recursive divide-and-conquer approach, the algorithm needs some way to remember the as-yet-unsolved 2nd half of the problem while it recurses into the 1st half.  Often this is done by having the algorithm recursively call itself first for one half and then for the other, a design which maintains this information implicitly on the runtime stack.  Another implementation might avoid recursive function calls by maintaining essentially this same information on an explicit stack.  In terms of space growth, algorithm 2 is O(1), but any recursive implementation is unavoidably O(log n) due to having to maintain this information on some sort of stack.  But aside from the space issue, a recursive implementation has extra runtime overhead of remembering the state of as-yet-unrecursed-into subproblem halves until such time as they can be recursed into.  This runtime overhead is not free, and given the simplicity of algorithm 2’s implementation above, I posit that such overhead is proportionally significant.  Therefore I suggest that algorithm 2 above will roundly spank any recursive implementation for the vast majority of cases.
",8,13632801
13633012,"
In the worst case, you can't do any better than checking every element.  (Imagine something like a[i] = i + uniform_random(-.25, .25).)  You'll need some information on what your input looks like.
",4,13632801
13633873,"
Actually I would start from the last element, and do a basic check (for example, if you have 1000 elements, but highest is 100, you know you need only check 0..100). In a worst case scenario you still need to check every element, but it should be faster to find the areas where it may be possible. If it is as stated above (a[i] = i + [-0.25..0.25]), you are f($!ed and need to search every single element.
",1,13632801
13632899,"
For a sorted array, you can perform an interpolation search. Similiar to a binary search, but assuming an even distribution of values, can be faster.
",0,13632801
13633690,"
I think the main problem here is your conflicting statements:

a[i] == i
All the elements in the array are sorted and distinct , they need not be integer always.

If the array's value is equal to its accessing subscript that means it's an integer. If it's not an integer, and they're say.. char, what is considered ""sorted""? ASCII value ( A < B < C)? 
If it were an array of chars would we consider:
to be true if
i == 6510 && a[i] == 'A'
If I were in this interview I would be grilling the interviewer with follow up questions before answering. That said...
If all we know is what you stated, we can safely say that we can find the value in O(n) because that is the time to make one full pass of the array. With more details we can probably limit this to O(log(n)) with a binary search of the array.
",0,13632801
13657294,"
Noticed that all the elements in the array are sorted and distinct, so if we construct a new array b with b[i]=a[i]-i, elements in array b is also sorted, what we need to find is to find zeros in array b. I think binary search can solve the problem! Here is a link for count the number of occurrences in a sorted array. You can also do the similar Divide & Conquer technique on the original array without construct a auxiliary array! The time complexity is O(Logn)!
Hope it helps!
",0,13632801
13594568,"
I can see two good ways to do this.

If the points you are looking for are in some ordered axially aligned grid, then you can access the ones that are in a certain radius immediately. The way to do this is to get the x, y, z point and convert it to its grid position along with the radius to define the min and max grid positions for x, y, and z. You can then access those variables immediately. 
If the points are not in a form that's not axially aligned and ordered into a grid then you need to put it inot a form that will be quick to search. I would suggest the kd tree. It takes a searching operation from being O(n) to O(log(n). The way it does it is to split the point set in half along the mean and repeat untill you have a fast searchable tree:


The PCL (point cloud Library) will do this for your as well!
Here is a link:
http://pointclouds.org/
And a tutorial on kd trees with pcl:
http://pointclouds.org/documentation/tutorials/kdtree_search.php#kdtree-search
In fact it even shows you the code for a radius search from an entered point into a kd tree stored point cloud. Look at neighbours in radius search on the tutorial page i have provided.
Good Luck!
",2,13594285
13354588,"
You could provide a constructor to your struct Foo
you can now call:
or 
or
The suggested way is:
",3,13354556
13354639,"
In C++11, you can use the following:
Or in C++03:
",1,13354556
13354638,"
Have your custom_comp accept both foo and int as arguments.  This means it either needs to be a functor, or it could take foo_sort_helper arguments (which can be constructed from an int or a foo) and order those.
Or, to be explicit:
You see how I encapsulate how Foo is sorted in the FooSortHelper?  And by allowing it to be constructed from an int, I allow Foo to be compared against int seemlessly.
The alternative I mentioned is to create a class with operator() overloaded on each pair of Foo and int (all 4 of them).  I find the above easier.
If the type(s) you are sorting on is expensive to copy (such as std::string) the FooSortHelper can store a reference to said fields.
",0,13354556
13341127,"
You can use std::min_element with a suitable comparison function for this.
This assumes that list<Node*> is std::list<Node*>, in which case you should be aware that std::list itself is a linked list.
Other useful operations, based on your comments:
Remove a minimum value node from the list and delete it:
You may need to perform other operations, if your nodes depend on each other.
Sort the list:
",6,13341072
13341149,"
use std::min_element algirithm and overload Compare function
if you are using C++03:
if you are using C++11:
To sort the list, you can call OPEN.sort(compareF); to sort your list with compareF function
",2,13341072
13341260,"
Try adding this:
",1,13341072
13227913,"
You are dealing with a shortest path problem, which can be efficiently solved with BFS (if the graph is unweighted) or A* algorithm - if you have some ""knowledge"" on the graph and can estimate how much it will ""cost"" you to find a target from each node.
Your solution is very similar to BFS with one difference - BFS also maintains a visited set - of all the nodes you have already visited. The idea of this visited set is that you don't need to revisit a node that was already visited, because any path through it will be not shorter then the shortest path you will find during the first visit of this node.
Note that without the visited set - each node is revisited a lot of times, which makes the algorithm very inefficient.
Pseudo code for BFS (with visited set):
",1,13227154
13249555,"
Maybe you are looking something like flat_(multi)map/set from Boost.Container ?
",2,13223604
13249517,"
You should look into std::make_heap and associated functions, which manages a collection as a sorted heap. It fits almost perfectly your requirement of fast, unsorted inserts, and quick retrieval from a sorted collection. 
",0,13223604
13178237,"
The natural solution would be to first build an array with the cumulative sums. This would look like
and then use a binary search such as the lower_bound algorithm to find where to insert. That would be O(log(n)). Assuming that your number of slots is constant, this solution is also time-constant. But I guess you want the lookup to be O(1) in terms of the number of slots. In this case, you will have to make a full lookup table. Since the size of these numbers is relatively small, that is perfectly doable:
Using this, the slot number is simply lookup[number].
",0,13178180
13178328,"
If you really need constant time, create a second array that has a size that is the largest sum value that contains indexes into the original array. So new_array[189] = 4;
",1,13178180
13178266,"
I think the best you can get is to use the cumulative array and run in logarithmic time by using binary search. I am not sure if a solution with constant time is existing. Are you sure there is one?
",0,13178180
13178351,"
If you know that the number is always between 1 and the sum of all items in the array, then the trivial constant time algorithm is to build an array of [1..sum], each entry containing the proper slot for each number. Building the array, which you only have to do once, is O(N). Lookup is then O(1).
This assumes, of course, that you have enough memory for the array.
Other than that, I think the best you'll be able to do is O(log(N)) using binary search on the sums.
",0,13178180
13178373,"
assuming

The input number will always be in between 1 and sum of all the
  entries in array

",0,13178180
13149665,"
For starters, there's no way out of the main loop in Search if the number sought is not in the array.
Then you're using high before it's been given any value.
There may be other problems. How did you test this while you were developing it?
",1,13149569
13149661,"
N isn't initialized, so who knows what this statement:
will do?
",0,13149569
13109216,"
You should probably consider moving to a propper parser generator.
A good C++ library for such a task is boost spirit-qi, there is even an XML example.
http://www.boost.org/doc/libs/1_51_0/libs/spirit/doc/html/index.html
xml example
",1,13109195
13109399,"
It looks like you're calling SetFilePointer() for every single tag.  If you aren't doing any other reads or writes to the file in between calls to GetTag(), don't bother calling SetFilePointer() at all.  It's unnecessary, and it's possible that this call is reducing the amount of buffering done by the OS.
",0,13109195
12984758,"
to substitute look for replace method here. Also hide the Browser's TextEdit and create your own TextEdit. 
Tap signals of textChanged() and do things accordingly(like live-search) and other fancy tricks used by browsers of today. 
Have a look here BEFORE YOU PROCEED
",1,12984587
12984631,"
Try using regex for inserting the pluses between each word. However, that assumes that you can identify what the words are. Given that if they intend to search they will probably include spaces between the words you can probably just use regex to subsitute a '+' for every space.
",0,12984587
12809836,"
Note, that getline(myfile, line) might fail, thus it is incorrect to use value of line in that case:
should be:
To your questions 2 and 3: you should try something on your own before asking for help. If not a solution or not even an attempt, then you should have some ideas about it at least. Do you want to go through your text file every time you want to retrieve some data from it? Isn't it better to read it at once and store it in memory (maybe std::vector<Record> and then search for record in vector of records) ? Do you want to go through your file line by line and search some specific string within each line?... Just think more about it and you will find answers to your questions.
",1,12809613
12783452,"
Perl. It takes about three lines of code to search every file in a directory for a string. You can learn enough Perl to do that in half an hour.
",1,12777969
12777993,"
I would suggest installing Cygwin and using grep
",13,12777969
12778043,"
If you need to do this only manually, then just install any decent editor (my suggestion would be http://notepad-plus-plus.org/), and use its find-in-files function.
",5,12777969
12778085,"
How about using findstr command from command prompt.
",2,12777969
12778582,"
This works in Windows XP.  I don't know about the more current versions.
Click on the Windows Start Button
Click on Search
A new window will open.  On the bottom left, click on ""Click here to use Windows Search Companion""
Another window will open.
In the text box labeled ""A word or phrase in the file"" type in what you're looking for.
In the combobox labeled ""Look in"", at the very bottom, select ""browse..."" and select the folder with all the log files.
Click ""Search""
Wait for the results...
Note: there are 2 search programs.  The first one only finds things that have been indexed, which is why you should use the second search program instead.
Good luck!
",1,12777969
12825625,"
Consider VIM editor which is awesome when working with huge files. You can use it under Cygwin, and you can use on Windows. Use cheat sheets to learn it quickly.
",1,12777969
12587583,"
It looks like you don't understand how variables are stored in memory or how pointers work. In your _tmain() you have char * path pointing to a constant string literal, which you pass into GetFilesInFolders(), where it gets modified. Compilers tend to allow char *s to point at constant strings for backward compatibility with old C programs. You cannot modify these. You cannot append to them. The compiler (generally) puts these in a read-only segment. That's one reason why you're getting an exception.
Your whole GetFilesInFolders() is wrong. And as DarkFalcon pointed out, you haven't allocated any space anywhere for files, you have it pointing to a constant string literal.
Get ""The C++ Programming Language"" and read chapter 5.
",1,12587086
12587172,"
You assign a const char* to files, then attempt to append to it.
You cannot modify a constant string literal.
I would recommend that you turn on compiler warnings and make sure to look at them. This would warn you about assigning a const char* to a char*. To fix it, you might have changed files to be const, which would then cause your strcpy_s to no longer compile.
",2,12587086
12568987,"
Instead of changing directory via SetCurrentDirectory() use a recursive call on GetFiles(). This would require that the caller pass in a reference to an array (or std::vector<std::string>) for the list of files to be stored in instead of using the local array s.
",1,12568835
12569079,"
I think the easiest way to do it is by doing a recursive function.
This would roughly look like something like this in ""c"" pseudo code
",2,12568835
12569958,"
Doing a bit of searching through old posts, I guess I've mentioned doing a breadth-first search a number of times, but never really posted code to show how to do it. I guess I might as well do that.
",1,12568835
12570389,"
Why not use the boost recursive_directory_iterator.
Note: untested (but should look something like this).
",1,12568835
12568958,"
I'd have a look at the directory iterators of boost instead.
http://www.boost.org/doc/libs/1_51_0/libs/filesystem/doc/index.htm
There are examples covering what you are trying to do, and it will work for almost any OS you can think of.
Have a look at example 3. It shows how to loop over all contents of the directory. If you find a new directory you have not seen before, you just do the same on that. There are tests telling you if the file is regular, directory etc so give it a try.
",0,12568835
12463797,"
Just use a counter variable to keep track of the current line number.  Each time you call getline you... read a line... so just increment the variable after that.  
Also...
while(!fileInput.eof()) 
should be   
while(getline(fileInput, line))
If an error occurs while reading eof will not be set, so you have an infinite loop.  std::getline returns a stream (the stream you passed it) which can be implicitly converted to a bool, which tells you if you can continue to read, not only if you are at the end of the file.
If eof is set you will still exit the loop, but you will also exit if, for example, bad is set, someone deletes the file while you are reading it, etc.
",13,12463750
17158463,"
A modified version of the accepted answer. [A comment on the answer as a suggestion would have been preferable but I can't comment yet.]
The following code is untested but it should work
for loop makes it slightly smaller (but perhaps harder to read). And 0 in find should be unnecessary because find by default searches the whole string
",5,12463750
12354530,"
AFAIK, there is no other way to desactivate the behaviour you are complaining about other than using the form #include <foo.h> instead of #include ""foo.h"" in your code.
ISTR, but I've failed to find a reference, that the rationale for deprecating -I- without providing another mechanism for that aspect is that libraries commonly use the form #include ""foo.h"" to ensure they get their own internal header file foo.h and the use of -I- broke them in some cases if someone else happened to have a file similarly named earlier on the search path.
",8,12353429
11764443,"
Use a std::vector<set_type> to store the sets.  Insert all of the sets into the container.  Sort the container using std::sort.  Find elements using std::binary_search (or std::lower_bound if you need an iterator to the element).
The type you use for set_type depends on the number of elements in each set.  If the number of elements is known to be small, then std::array<T, N> would be sufficient; otherwise, consider std::vector<T>.
",4,11764399
11764461,"
If order matters, you're looking at sequences, not sets.  Terminology matters.
Since you're only considering about 1,000 sequences, it should be easy to just store them in a hashtable, with good performance.  I'd consider constructing a string to represent each sequence, say, by concatenating the string representation of each element, plus some sort of delimiter, and hashing that.
",5,11764399
11764420,"
define an order for the sets and then insert them into a tree. Or define a hashcode and a comparator and hashtable them. 
",0,11764399
11786961,"
In this case I would use a Hashtable. You would have accesstime in somethin of O(1) (well worst-case is O(n) but with a good Hashfunction this isn't a problem)
So if your Hashtabel is big enough and you don't have to worry about space this would definitely be the fastest way of search. (Consider Binary Search is in O(log(n)))
Hashtables are only available in the STL of the new C++0x standard. See STL::TR1
",0,11764399
11722757,"
Here's a little advice, but not much more than that:
If you want to find places by name, or name prefix, as you indicate that you wish to, then you would be ill-advised to set up a data structure which stores the data in a hierarchy of country, region, town as you suggest you might.  If you have an operation that dominates the use of your data structure you are generally best picking the data structure to suit the operation.  
In this case an alphabetical list of places would be more suited to your queries.  To each place not at the topmost level you would want to add some kind of reference to the name of its 'parent'.  If you have an alphabetical list of places you might also want to consider an index , perhaps one which points directly to the first place in the list which starts with each letter of the alphabet.
As you describe your problem it seems to have much more in common with storing words in a dictionary (I mean the sort of thing in which you look up words rather than any particular collection data-type in any specific programming language which goes under the same name) than with most of what goes under the guise of geo-coding.
My guess would be that a gazetteer including the names of all the world's towns, cities, regions and countries (and their coordinates) which have a population over, say, 1000, could be stored in a very simple data structure (basically a list) with an index or two for rapid location of the first A place-name, the first B, and so on.  With a little compression you could probably hold this in the memory of most modern desktop PCs.
",4,11722423
11722724,"
I think the best advice I can give is to use whatever language you are familiar with to get the results you want. Worry about performance once your code works. Then you can look at translating very specific pieces of functionality into C or C++ one at a time until you have the results you want.
",1,11722423
11731204,"
You should not worry about how the information is stored, except not to duplicate data.  
You should create one or more indices for the data.  The indicies are associative arrays / maps data structures that contain a key (the item you want to search) and a value (such as the record and other information associated with the key).  This will enable you with fast lookups without altering your data for each type of search.  
On the other hand, your case is an excellent fit for a data base.  I suggest you let the database manager your data (such as efficient lookups).  After all, that is what they live for.
See also: At what point is it worth using a database?
",1,11722423
11676495,"
Given that each line is of variable length there is no way to index to particular row without first parsing the entire file.
But I suspect your program will want to manipulate random rows and columns. So I'd start by parsing out the entire file. Put each row into its own data structure in an array, then index that row in the array.
You can use ""strtok"" to split the input up into rows, and then strtok again to split each row into fields.
",2,11675884
11677036,"
If I were to do this, I would first write a few functions that parse the entire file and store the data in an appropriate data structure (such as an array or std::map). Then I would use the data structure for the required operations (such as searching or editing). Finally, I would write the data structure back to a file if there are any modifications.
",0,11675884
11585465,"
Guessing that you are implementing these as an expanding array in that when you run out of room you reallocate the new array and then copy the elements over.
In this case your question comes down to how to implement a linear and binary search over this array?
In that case there are plenty of articles, samples, found online.
The advantage of linear search is the fact that for small arrays there is no speed different, and it will work on an unsorted array always, as long as the item you are looking for is in the array.
This is in contrast to the binary search of which is very fast for large arrays, but for small sized ones there is no real performance benefit over a linear search. This speed up comes at the cost of it having to be sorted to get this advantage.
",1,11584993
11462224,"
The key word is ""almost"". The worst-case behavior can be for a vanishingly small number of cases. Average behavior in real life and asymptotic behavior are also rather loosely coupled. The best case behavior of Boyer-Moore-Horspool is the same as for Boyer-Moore. The worst case for Boyer-Moore-Horspool is quite a bit worse than for Boyer-Moore. For typical use, Boyer-Moore-Horspool tends to be about the same as Boyer-Moore, but with a little better (lower) overhead and initialization costs.
Which one to use? It depends on your goals and what you expect in the way of patterns and text to be searched. Neither is particularly hard to implement, so why not do both and compare the results yourself. (See what happens when you admit that you're a student? You get an assignment! :))
",3,11462153
11424246,"
I would suggest Boost.Filesystem, which is a cross-platform libary abstracting filesystem operations such as querying for files properties, creating, copying and moving files. As a bonus, it is proposed for standardisation in a future version of the C++ ISO standard.
As a starting point, here is an example that will process every file in a given directory.
It show you that you can:

Iterate over every file in a directory
Query if a given path exist
Query if a given path point to a directory

Other function you could be interested in:

Query for the current working directory (boost::filesystem::current_path())

",1,11424198
11424281,"
There are some great libraries that make this very painless and cross platform.
Qt and Boost are some of the most well known.
Here are links to the documentation for the relevant classes that would do this for you:
Boost Filesystem and Qt QDir.
I prefer Qt, because the documentation has been very unified for a long time and I also really like the IDE.
",0,11424198
11407123,"
You can use selection algorithm to find the kth lowest element and then iterate and return it and all elements that are lower then it. More work has to be done if the list can contain duplicates (making sure you don't end up with more elements that you need).
This solution is O(n).
Selection algorithm is implemented in C++ as nth_element()
Another alternative is to use a max heap of size k, and iterate the elements while maintaining the heap to hold all k smallest elements.
When you are done - the heap contains k smallest elements.
This solution is O(nlogk)
",8,11407114
11407407,"
You could model your solution to match the nlargest() code in Python's standard library.

Heapify the first k values on a maxheap.
Iterate over the remaining n - k values.
Compare each to the element of the top of the heap.
If the new value is lower, do a heapreplace operation (which replaces the topmost heap element with the new value and then sifts it downward).

The algorithm can be surprisingly efficient.  For example, when n=100,000 and k=100, the number of comparisons is typically around 106,000 for randomly arranged inputs.  This is only slightly more than 100,000 comparisons to find a single minimum value.  And, it does about twenty times fewer comparisons than a full quicksort on the whole dataset.
The relative strength of various algorithms is studied and summarized at: http://code.activestate.com/recipes/577573-compare-algorithms-for-heapqsmallest
",10,11407114
11407136,"
Take a look at partial_sort algorithm from C++ standard library.
",2,11407114
11407146,"
You can use std::nth_element. This is O(N) complexity because it doesn't sort the elements, it just arranges them such that every element under a certain N is less than N.
",2,11407114
11412490,"
you can use selection sort, it takes O(n) to select first lowest value. Once we have set this lowest value on position 1 we can rescan the data set to find out second lowest value. and can do it until we have kth lowest value. in this way if k is enough smaller then n then we will have complexity kn which is equivalent to O(n)...
",0,11407114
11380551,"
You're passing the name of a template (cmp) in a context where C++ wants a value. Apart from the fact that you can't do this, it's a chicken-or-egg problem: what type is cmp? A function's type depends on its arguments, and this function can take arguments of any type. So what type does the compiler infer for the template argument Comparer? It would have to look at the body of the function to figure out that you expect int, and that's not always possible—the compiler doesn't always have access to the source code of templates.
You need to specifically select the type for the function template that you're passing. For example:
",5,11380521
11362616,"
Apply repeatedly std::string::find if you are using C++ strings, or std::strstr if you are using C strings; in both cases, at each iteration start to search n characters after the last match, where n is the length of your word.
(link)
",4,11362576
11362625,"
Use a loop which repeatedly calls std::string::find; on each iteration, you start finding beyond your last hit:
",2,11362576
11362680,"
",0,11362576
11334996,"
Similar to what bames53 posted; I used a vector as a buffer:
",5,11334739
11334800,"
If you don't mind loading the entire file into an in-memory array (or using mmap() to make it look like the file is in memory), you could then search for your character sequence in-memory, which is a bit easier to do:
.... then you can just call the above function on the in-memory data array:
",0,11334739
11334940,"
This program loads the entire file into memory and then uses std::search on it.
",0,11334739
11334989,"
You are looking for 4 bytes:
",0,11334739
11335132,"
Because you said you cannot search the entire file because of null terminator characters in the string, here's an alternative for you, which reads the entire file in and uses recursion to find the first occurrence of a string inside of the whole file.
If the file is not too large, your best solution would be to load the whole file into memory, so you don't need to keep reading from the drive. If the file is too large to load in at once, you would want to load in chunks of the file at a time. But if you do load in chucks, make sure you check to edges of the chunks. It's possible that your chunk happens to split right in the middle of the string you're searching for.
",0,11334739
11134799,"
Unless otherwise configured, you must bind using a valid account name and password for Microsoft Active Directory servers, otherwise it will return the operations error for all queries except a very small handful.
i.e. that:
Needs to be replaced with something like:
",4,11133752
11099817,"
I would suggest that you do create a suffix tree from the file. This will have linear complexity with respect to the size of your file and will solve the problem. You can modify the algorithm just a little bit to store how many times is a string met apart from the string itself. Here is a great post explaining how to create a suffix tree.
",5,11099739
11099839,"
Finding the most frequent one is quite easy, if you realize that the most frequent sequence is 4 characters long. It can be done in O(n) time, where n is the size of the input file.
You can build a std::map<string,int>, iterate character by character taking sequences of 4 characters at a time, and increment the value with the respective key in the map.
",1,11099739
10906882,"
Read the file into a string (assuming it's not huge).  You can then use string::find or std::algorithm.
[EDIT]
You can also search with the istreambug_iterators directly, but that leaves you with the same kind of iterator.
",4,10906475
10770883,"
That's not how you call a function.  You can't just copy the function definition line and replace one or two arguments.  Replace that line with:
Note: This won't address any problems in the algorithm itself, just the problem calling it.
",1,10770854
10721401,"
I think that the findText method is what you're looking for
",6,10721348
10570314,"
In C#, every Control has Controls property that returns a collection of child controls. You can iterate through all the ""children"" of a form and add their names to your listbox. In the opposite direction, when you've got a control name, you can find it using Controls.Find() method.
For CBuilder case, refer to the following thread:
BCB : how to iterate over controls on a form?
",2,10570252
10762575,"
It seems that you've implemented your binary numbers using arrays when it would be faster to implement them simply as numbers and query/modify them with bit masks and bit shifts. That would remove the need for you to use an iterative approach in get_c; your get_c function would be constant time instead of linear time.
",0,10565405
10556055,"
This declares a new variable named country of type fstream. Probably not what you want.
You should try:
instead. And you have the same issue with name.
Also:
better call break directly.
And:
should probably be: cin >> choice;
",4,10555967
10552039,"
I am assuming that competitors[i].country (name) is a char[].
You cannot compare char[] arrays using == (that will compare the base addresses of the array, not the content), you must strcmp(). Or, as this is C++, use std::string instead of char[] and use ==.
",2,10551977
10517414,"
I am guessing that Node::getItem() returns a DataType by value:
When you take the address of that return value, you are essentially taking the address of something that will immediately disappear (a temporary). I suspect that Node holds DataType objects internally, in which case Node::getItem() could return a pointer to one of these.
or return by reference:
",4,10517123
10517234,"
return &(r->getItem()); will return the memory adress to whatever r->getItem() returns, not the object itself.
If r->getItem() returns a pointer you will have to return (r->getItem());.
",0,10517123
10356534,"
Pass the count by reference int&.
",3,10356489
10356514,"
change 
to
and the same with the line containing p->right.
",2,10356489
10356559,"
I suspect that you want something like this:
You can use int in place of size_t if you prefer.
The reason is that each recursive call must return a count to its caller, for otherwise the caller cannot tell how many the recursive call has counted.  The outermost caller, of course, can just discard the count if uninterested.
Passing by reference is another way to do it, as another answer observes, though not my preferred way.  (I personally prefer to implement that strategy with explicit pointers.)
You ask whether making count a global variable would work.  The answer is that, yes, it would work for the restricted purpose of your limited exercise, but it would represent abysmal programming practice.  After all, what if you had several trees, each with its own count?
Update:  Thanks to @JerryCoffin for pointing out the former error in my code.  I have fixed it above.  What is more, I have tested it with the following:
The output is
So, it works.
",2,10356489
10356583,"
You'll have to pass the count variable by reference.
",1,10356489
10310380,"
1) The code in your first example fails to compile because of the following expression:
my_map[""one""] constructs a std::string from ""one"", and passes it to std::map::operator[]. map::operator[] ensures that a value is mapped to the supplied key (by associating the key with a default-constructed value if it is not already associated with a value) and returns a reference to that value.
This does not compile, because person does not have a default constructor (A ""default constructor"" is a constructor which takes no arguments).
There are several ways to fix this problem.
One way is the way that you took - removing the constructor. It works because if you do not supply any constructors, a default constructor will be implicitly defined.
Another way is to explicitly define a default constructor for person:
Another way is to not use operator[] at all, and to instead use map::insert, as follows:

2) The correct way to find an element in the map is (as you said) to use:
This does not inspect every element in the map - in fact it may only inspect O(log(map.size())) elements.
Your fears are totally unfounded, this is the correct way to find an element in the map, however the way in which you continue suggests a severe misunderstanding about what operator[] does.
You ask ""what is the probability that my_map[""unknown""].identifier == ""something"" will return true if ""unknown"" does not exist in the map?"".
The answer to this is that there is no chance whatsoever of this returning true, because if no value with the key std::string(""unknown"") exists in the map, then operator[] will associate std::string(""unknown"") with a default constructed person, and so identifier will be an empty string.
",8,10309828
10309845,"
First of all, since you have a constructor, you need to provide a default constructor. This is because C++ standard library containers use value semantics. So the map needs to be able to copy values, assign them, and default construct them. Since you provide a constructor, the compiler does not synthesize the default constructor. This is a default constructor that does nothing:
Particularly in the case of std::map, operator[] returns a reference to a default constructed value when an element with the key does not already exist in the map:
Second, concerning your question about searching the map, std::map, search has logarithmic complexity and is typically implemented as a self-balancing binary tree. So when you search you do not traverse the whole map. And since accessing via operator[] introduces new elements when the searched key doesn't exist, the form using find() is the canonical way to do it.
Since you mentioned hashing, C++11 provides std::unordered_map, and tr1 and boost have hash_map. These use hash functions perform the search is constant time. Whether it is worth using it or not depends on factors such as the size of your map. The constant time could be larger than the logarithmic time taken to search a small map.
Note",2,10309828
10308158,"
One improvement I would make that would probably improve elegance and efficiency simultaneously would be to 

Allocate an array of integers that will hold the indices of the substrings that match the given string.
Loop through the string and find all the matching substrings, and add each to the array, reallocating the array larger as needed (because you don't want to use the STL I presume; if you can, use std::vector std::list std::deque).
Allocate new memory for the modified string based on the length of the original string and how many substrings you found.
Iterate the old string and the array simultaneously, copying the non-matched parts from the old string to the new.
Fill in the holes you left with the replacement string.

Also, instead of allocating memory dynamically inside the function, I would change it to accept a caller-allocated buffer and maximum buffer size instead. This way the caller can be completely responsible for the lifetime of the memory (utilising automatic memory if they want/can) and you don't have to worry about calculating a buffer size (you rely on the caller for that).

EDIT:
Here is an example implementation I whipped up. Please let me know if anyone finds any errors, which is likely. (You might not want to read this if you want to figure it out yourself.)
And don't forget to delete[] the return value of that function.
I went for efficiency without doing maximum optimisations. For instance, you could have a while loop that executed while positions.empty() was false, and then when it becomes true, just exit the loop and do a straight strcpy for the rest because there are no more replacements to be made, which would let you avoid unnecessarily calling positions.empty() for every character even if there are no replacements to be made left, or at all. But I think that is a small nit, and the code conveys the point.
Also, I used std::list std::deque to remove all the array management code but that should be straighforward if you want to do it yourself.
As ildjarn mentioned in the comments, I changed from list to deque because I use the size member and, per his comment, it's not O(1) (usually it would be O(n)) on all pre-C++11 implementations, so deque with it's constant-time size will be more efficient.
",3,10307209
10308307,"
You can get rid of the first part of your code to calculate the count if you simply set the size of the newstring to be the maximum possible size after the solution. 
In particular:
Also, instead of calling strlen(from) multiple times, just assign it to a variable (e.g. srtlen_from) and just use that. 
",0,10307209
10308571,"
Here is a version I made which is pretty much using pointers only (error checking, etc. is omitted) (I have also noticed that it fails in certain cases):
",0,10307209
10323424,"
Self-unexplanatory: http://ideone.com/ew5pL
This is what ugly and bulky looks like - no C functions except an strlen and a memcpy at the end.
I think yours looks nice and compact.
",0,10307209
10306201,"
Use backslash for the path separator.  Regardless of the current language, backslash is documented as accepted in all cases.  It could be MFC is screwing things up...
Here are two links that should help.
http://msdn.microsoft.com/en-us/library/dd317748(v=vs.85).aspx
http://msdn.microsoft.com/en-us/library/aa365247%28VS.85%29.aspx#naming_conventions
",1,10306092
16199572,"
Each data-type will have to be compared differently, so without explicitly knowing the data-types you are out of luck. Strings are compared alphabetically, numbers are compared by value, and i'm not sure if you have any other custom data-types.
So you don't really have much of an option here besides going through each of the case-by-case scenarios. E.g. 
Here is a suggestion for making this code a bit more robust.
Instead of handling the search logic in each of the cases, you can simply return a function pointer than tells you how to compare two Persons. The actual function may be comparing by name, age, social security, or whatever, but your search function won't have to care about that once it has the function pointer that tells it how to compare two Person objects.
",0,16199386
16153844,"
You forgot the return statements. You should return the result of the recursive calls:
should be 
Otherwise your initial call will execute the rest of the body and always end up returning -1, unless you find the key before the first recursion.
By adding the return statement, you break the control flow of the recursive call (ie you don't return the ""not found"" value), and you will propagate the last return value all the way up in the call stack, until the first call, and finally return the value you want.
",5,16153784
16153991,"
It all works fine, but you don't return the correct value.
In the else-if-statements you call the function recursive, but the returned values are not passed through to the initial call!
Try:
and 
That should work.
-Edit: Well I guess I've been to slow ;)
",0,16153784
16153993,"
you should also add :
after  calculating endptr to avoid infinite loop incase of searching element not in array such as 21.. etc
",0,16153784
16102230,"
The example Example for Range Tree on Set-like Data is the example for the 2D-case. Turn the _2 into _3 in the typedefs and you have the 3D case.
",2,16081394
16071219,"
One way I can think of is like that: lets say i < j and F(i) < F(j) so we want to find F(i+1).
We know that F(i) < F(i+1) < F(j) so we can do binary search between [F(i),F(j)] - each time we guess F(i+1) and checks if it fits (no easy way around it I think) until you get the correct value.
Complexity - each iteration can take 2000 steps (worst case), and at worst it's going to take be log(4*10^9) iterations which is about 32 so it seems reasonable.  
",1,16071005
16050681,"
Your problem is in the lines where you are trying to add to invalidNumbers and attempts. The ++ postfix operator adds one to the number before it. You needn't say invalidNumbers = results++;; you merely need invalidNumbers++;, and the same applies for attempts. What your code was doing was setting invalidNumbers (and attempts) to the value of results and then adding one to results instead.
",1,16050627
15973377,"
Why is there a for loop? Would it not be easier to do something like:
I've not tested this code but hopefully it'll give you an idea of which way to go.
",0,15973056
15917280,"
I'm not 100% sure I understand your question, so please clarify if I get something wrong. I'm assuming the vector is a path, with each element giving the index of the element to move to. With that in mind, I'd try something like this:
Notes:

Using an unsigned integer for the indices would be a bit more natural to me.
vector::at() throws an exception on out-of-range.
I haven't looked up the exact syntax of how to get an element of the variant. With the version get<1>(*tit); I used above, I meant the one that retrieves the first element (i.e. the myStruct pointer). Further, it should be the one that returns a reference or throws in order to handle errors.
Consider replacing the range-checking with your own code in order to provide better diagnostics. I didn't do it to keep the structure of the algorithm clear.

",0,15907187
15886662,"
You have some fundamental errors in your code:
Code issues:
Meanwhile, The way you are trying to use binary search to find the occurrence of a given number is not quite right. It should be done as follows:
since you already sorted the array with insertion sort. What you need to do is the simply using binary search to find the first and last occurrence of the given integer, then the total number of occurrence is simple arithmetic between those two indices. 
For example, given array (sorted) as follows:
you would like to find 4, then you use binary search to find first appearance at index 3 and last appearance at index 7, the total number of appearance is then 7-3 +1 = 5.
The major code should be something like the following:
",1,15885752
15885906,"
change int A[] = {0}; to
or int A[20]={0}
currently you are not allocating memory for 20 integers but for 1.
Also chcnge your ifs to cover groups of instructions in {}
",2,15885752
15885926,"
You have to use {} to make your if statements
As it is written write now binary search will never reach
It will always return at
OR
Plus as suggested in the comments
should be
One more thing you have to accept what is returned from binarysearch
OK one more edit.
",1,15885752
15883798,"
If the array is unsorted, just use a single loop to compare each element to x. Unless there's something you're forgetting to tell us, I don't see any need for anything more complicated.
If the array is sorted, there are algorithms (e.g. binary search) that would have better asymptotic complexity. However, for a 20-element array a simple linear search should still be the preferred strategy.
",4,15883645
15883804,"
If your array is a sorted one you can use a divide to conquer strategy:
Efficient way to count occurrences of a key in a sorted array
",2,15883645
15884608,"
A divide and conquer algorithm is only beneficial if you can either eliminate some work with it, or if you can parallelize the divided work parts accross several computation units. In your case, the first option is possible with an already sorted dataset, other answers may have addressed the problem.
For the second solution, the algorithm name is map reduce, which split the dataset in several subsets, distribute the subsets to as many threads or processes, and gather the results to ""compile"" them (the term is actually ""reduce"") in a meaningful result. In your setting, it means that each thread will scan its own slice of the array to count the items, and return its result to the ""reduce"" thread, which will add them up to return the final result. This solution is only interesting for large datasets though.
There are questions dealing with mapreduce and c++ on SO, but I'll try to give you a sample implementation here:
Once the integers vector has been populated, you call the mapreduce function defined above, which should return the expected result. As you can see, the implementation is very specialized:

the map and reduce functions are specific to your problem,
the number of threads used for map is static,
I followed your style and used global variables,
for convenience, I used a boost::barrier for synchronization

However this should give you an idea of the algorithm, and how you could apply it to similar problems. 
caveat: code untested.
",1,15883645
15869042,"
The problem is that you're extracting strings, which by default will extract up until the next space. So at the first iteration, keyword is ""Julia"",""2. If you want to extract everything separated by commas, I suggest using std::getline with , as the delimeter:
This will look through all of the quoted strings. Now you can use std::string::find to determine if the input word is found within that quoted string:
Now this will loop through each quoted string until it gets to the one that contains word.
",1,15868969
15869007,"
You can use methods from std::string like find.
",3,15868969
15869010,"
Use this method of istream to get a whole line instead of just a single ""word"":
http://www.cplusplus.com/reference/istream/istream/getline/
Then use strstr, to find the location of a string (like Julia) in a string (the line of the file):
http://www.cplusplus.com/reference/cstring/strstr/
",0,15868969
15867938,"
You never return a value, except in the if (r.small == key) branch.
From 2–3 tree - Wikipedia, I would say your code should compare the key with the small and large key first and depending on the comparison return the result from retrieve(*r.left/middle/right, key).
Something along these lines (untested) 
",0,15867874
15868019,"
You need to first check if the key is found in the current node in either small or large, and if it is, return true. if it is not you need to recursively call retrieve on each of the contained nodes, and if any of them return true, return true.  If your function has not returned yet you need to return false.
",0,15867874
16533825,"
You need an initial test to see if the recursion should stop because you are at a least node.
",0,15867874
15854640,"
Computationally, if the vector is not sorted, you can't expect anything less than O(n), which may or may not meet your expectation. If it doesn't, you should change the data structure. If it does, you could use std::min_element, this way:
If the vector is sorted, on the other hand, you can use std::lower_bound() and std::upper_bound(), which have logarithmic complexity.
If you think complexity is an issue because of performance, do some measurements before deciding to change the data structure. Since vectors store their elements in a contiguous region of memory, a linear search resulting in high cache hit rate will often outperform a computationally more efficient algorithm on a data structure which allocates its element here and there in memory, resulting in frequent cache misses.
",10,15854542
15854874,"

Looks like linear search is your choice (at least for unsorted vector. It looks there is no point in sorting vector just for search.
In general everything depends on what do you mean under 'closest'. This 'closest' should be probably implemented as unary predicate. Predicate should return value like 0 if elements are equal and some value that is the bigger the less close element is from reference.
As I can see from <algorithm> most close algorithm to what you need is std::min_element but you need not only range parameters but also reference element (or predicate which determines 'how close' is your element to reference.
Probably you can receive some benefit from checking if elements are equal and if so, breaking the loop.

",1,15854542
15843518,"
If your two lists are sorted by time, you can walk through the lists efficiently:
",1,15843296
15843827,"
If the lists are sorted, surely you can use a binary search to find the ""window"" position? 
",0,15843296
15826934,"
If your platform is Win32, with C++ you can simply use Winapi functions
FindFirstFile
FindFirstFileEx
and then
FindNextFile
as filename you can give wildcards for known image formats such as jpg, jpeg, png, bmp etc.
If you want extra speed you can run functions on different threads then synchronize the results.
Edit:
For platform independent solution you can you use boost::filesystem class or Qt's  QDir
Sample code for searching files recursively with boost::filesystem
For a better implenetation I strongly offer you to read boost::filesystem documentation
For QDir Example
",3,15826836
15827176,"
For python, simply using the inbuilt functionality from the os module will be an adequate cross-platform solution. For C++, I'd suggest using boost filesystem, which will be by far the least painful solution. 
As for speed, well, it likely won't matter. Such functions will be completely I/O bound. You could theoretically thread this, but if it's on the same drive, it'll still be I/O bound. If it's on separate drives, it may give you some speed-up, although, as usual, profile before optimizing.
",2,15826836
15817553,"
std::unordered_map is implemented by means of a hash table, so it needs a hash function that can be applied to its key type. The default hash function is the std::hash template:
However, std::hash is not defined for std::set. Therefore you need to either provide a definition of std::hash<set<string>>, or else specify your own hash function using the third template parameter of unordered_map.
",3,15817465
15724731,"
Having reread the updated question, I think your goal is to test whether, for a given 5x5 board, there is any possible swap of two adjacent symbols that will produce a board with 3 or more identical symbols in a row or column.
If the previous attempts produced out-of-bounds errors, that would imply a bug in the implementation, not a bug in the algorithm. So using a different algorithm would do nothing to solve that problem, you still need to implement proper array boundary checks. There is no way around that, but on the plus side it is not particularly hard. Simply check each index on whether it is smaller than zero or larger than the array dimension size, before accessing the array. If it is, trace back the steps your program used to get to that value, and find the bug that must be there.
Of course, if the program produces the wrong results in addition to out-of-bounds errors, then your algorithm might also be wrong. 
Having said that, I am still not sure I understand the algorithms you describe, but they seem too complex for this problem. Unless you need to evaluate thousands of boards per second, a simple brute force algorithm will suffice. Just try out all possible swaps, and for each swap check if the board contains 3 or more identical symbols in a row or column.
Here is a description in pseudocode:
This is certainly not the fastest method, but for a 5x5 board everything else is overkill.
",3,15713452
15701826,"
You do not need the loop. Just do:
Here is a live example showing the result for the input string ""is"".
",1,15701784
15677096,"
Just to give you a hint to start. You could use the stl ifstream class, where you can also extract formatted data. The stl gives you a lot of means to achieve what you want.
",0,15675736
15623238,"
You need to use the regex based find and replace feature of VS2010, as documented here. 
To do so, ensure that regex expressions are enabled:

To enable regular expressions, expand Find options in the Find and Replace window, select Use, and then select Regular expressions. The triangular Expression Builder buttons next to the Find what and Replace with fields become available.

And then construct a regex that matches what you want to replace.
",0,15622854
15606820,"
You have to use the find method of std::string. This function return the start postion of string searched for in the string searched in. If no match was found it returns npos witch is actually just -1.
",1,15606745
15607062,"
You should use find, as A4L already mentioned. I just want to add that your use of cin.ignore will not work well if bad value entered. you need 
also. see this link for more details.
",1,15606745
24070340,"
How to search an array of strings example in C++:
This is the brute force search method.  Brute force means means we step through the entire string array and at each index of the array we search for our matching string.
Above code prints:
You should be verbalizing the above code from top to bottom in your head like this:
An array of string called data is initialized to contain 4 elements and given four values pidgeon, abcd, 1234 and %^&#.  An int variable called size is created which represents the number of elements in the string array.  A string variable called matchString is created which contains the string 'bc'.
The for loop index starts at position zero and increments by 1 until it reaches one less than the size of the array.  So the for loop goes through: 0, 1, 2, 3.  The first value of x is 0.  The if statement resolves data[0] to be pidgeon.  The find method is applied against that string and two parameters are passed in.  The string to be matched, and the position of the first character in the string to be considered in the search (0).  
if 'bc' exists within 'pidgeon' then it will return the position of the first character of the first match, otherwise it will print std::string:npos which is the maximum value for size_t designating not found.
bc does not exist in pidgeon so it skips the interior of the for loop.  The for loop continues to index position 1.  bc is contained in abcd.  So that string is printed.  When all the items are searched, the for loop ends and the program completes.
",0,15606745
15530492,"
In case of 50 on the first iteration your ind is 50. Then you ask whether the number is bigger than 50 and the answer for that is no. In this case you calculate h as ind-(ind/2) which is 25, then you compare it to ind and set max to 49, then continue the loop. But this is incorrect, because you throw away correct answer 50 by setting max to 49 in this case. 
",3,15530376
15530488,"
I see an assignment in an if statement (=).  Should be an equal-to token (==).
",2,15530376
15530516,"
Now that I've read your code, it almost makes sense.  But your usage of h is... wrong.  Here's a summary.  Think about this code on the first turn when the user's number is 50, and ind is 50.
",1,15530376
15533657,"
It's easy to make question-guess code, but on the other hand, it'd be boring if he'd ask you 50 times if your number is 50 starting from 0, so one side of making it more interesting is making a variable for jumps but keep record for Max & Min is important, also you can add Machine Learning over the jump variance to make it intelligent
",0,15530376
15324094,"
This works as expected:
If you create a small complete example like this, but where you get a failure, then it would make it much easier to determine what the problem is.
",3,15323934
15315859,"
There are numerous issues with your code.
This does not check to that left does not run beyond the end of the array.
This does not check to that right does not run before the start of the array.
This an infinite loop when 

left < right
A[left] >= pivot_value
A[right] <= pivot_value

select(A, len - pivot_rank, rank - pivot_rank );
This is not the correct partition to continue with.
",1,15315016
15180101,"
The find() method of std::string is a member function that is intended to find another std::string or a character array char* inside the std::string
So to answer your question if the haystack is a std::string you should be able to pass the char* arrays directly to the find methods.
If the haystack is not a std::string you can make a std::string out of it and then do the same.
",1,15180051
15180080,"
std::string is actually a typedef for std::basic_string<char>. You can use std::basic_string<BYTE> instead, and most (all?) std::string functionality, in particular .find(), will just work.
",1,15180051
15180081,"
If you don't want to use existing library functions, implement your favorite generic string matching algorithm, for example Knuth-Morris-Pratt, Boyer-Moore or Rabin-Karp.
",1,15180051
15124950,"
b has to be allocated. Try following:
I see what you meant. b will have magically length in first element. This was in Pascal/Delphi but not the case in C/C++.
",0,15124912
15124986,"
You are writing to heap memory that you never claimed.
This pointer, having never been initialized, points to an undefined memory address. Then when you use the indexing operator to assign your matches, you are writing to the subsequent bytes following the undefined memory address.
You need to allocate space for storing the results using the 'new[]' operator. Additionally, if you had correctly claimed the memory, you would be assigning the number of match results to the first element in the result array - something that doesn't seem to be your intention.
Take a look at dynamic memory allocation in C++ using the new [] operator.
",0,15124912
15125071,"
If you use std::vector anyway, why not to use it where it is needed the most? Also if you not suppose to modify array by that pointer express that by const pointer:
",0,15124912
15125058,"
This is not perfect but this is much closer to a correct implementation and you should be able to take it further with some work:
",0,15124912
14994945,"
Your function returns 0 as the answer. The if statement reads that as false, and thus doesn't output the answer. This is because, the value of a statement a=b is the value of the variable a after assignment.
View fixed version here - Checks if the return value is -1 explicitly.
Fix -   
",3,14994871
14969162,"
I will give you a clue for insertion() - assuming you have a book you want to insert
And for search() - assuming you are searching for a book with a particular ID
",0,14968703
14917460,"
For this answer I am assuming that you've made an informed decision to use a std::vector over the other containers available.

Do I really have to do a for-loop to loop through all the elements?

No, you do not have to roll a for-loop to find an element. The idiomatic way of finding an element in a container is to use an algorithm from the standard library. Whether you should roll your own really depends on the situation.
To help you decide...
Alternative 1:
std::find() requires a that there is a suitable equality comparator for your node data type, which may be as simple as this:
Then, given a required node, you can search for the element. This returns an iterator (or a pointer if you're using a plain old array). If you need the index, this requires a little calculation:
Alternative 2:
If creating a node is too expensive or you don't have an equality operator, a better approach would be to use std::find_if(), which takes a predicate (here I use a lambda because it's succinct, but you could use a functor like in this answer):

Or is there a quicker way?

Again, it depends. std::find() and std::find_if() run in linear time (O(n)), the same as your for-loop.
That said, using std::find() or std::find_if() won't involve random access or indexing into the container (they use iterators) but they may require a little bit of extra code compared with your for-loop.
Alternative 3:
If running time is critical and your array is sorted (say with std::sort()), you could perform a binary-search, which runs in logarithmic time (O(log n)). std::lower_bound() implements a binary search for the first element that is not less than the given value. It does not take a predicate unfortunately but requires a suitable less-than comparator for your node data type, such as:
The invocation is similar to std::find() and returns an iterator, but requires an extra check:
These functions from the Algorithms Library work with any container supplying an iterator, so switching to another container from std::vector would be quick and easy to test and to maintain.
The decision is yours!
[See a demonstration here.]
",3,14914985
14914999,"
You should use std::find. You can't get faster than linear complexity (O(n)) if you know nothing about the vector beforehand (like it being sorted).
",0,14914985
14915010,"
If you want to find elements in the container then vector is not the right data-structure. You should use an ordered container such as std::set or std::map. Since elements in these containers are kept ordered (sorted), we can find elements in O(log (n)) time as opposed to linear time for unordered containers.
",0,14914985
14915017,"
Use std::find :
Note that If you have sorted vector, you can make it faster.
",0,14914985
14915094,"
A neat solution would be to add an extra int index member to the node struct to provide data-to-index mapping when you have an instance of the struct. In such a case, you should probably wrap std::vector in a NodeVector class which will handle the updating of indices when, say, you remove an item (it's enough to subtract 1 from elements' indices which preceed the element being removed in such a case) etc. If the vector doesn't change the number of elements, that's not even an issue. Other than that, if you can't have an instance of the struct grow in size, use std::map. Iterating over the containter to find one item is not very smart, unless you need to do it very rarely and making anything complicated isn't worth the trouble.
",0,14914985
14786425,"
If you know the distribution, you can direct your search in a smarter way.
Here is the rough idea of this variant of binary search:
Assuming that your data is expected to be distributed uniformly on 0 to 100.
If you observe the value 0, you start at the beginning. If your value is 37, you start at 37% of the array you have. This is the key difference to binary search: you don't always start at 50%, but you try to start in the expected ""optimal"" position.
This also works for Gaussian distributed data, if you know the parameters (If you don't know them, you can still estimate them easily from the observed data). You would compute the Gaussian CDF, and this yields the place to start your search.
Now for the next step, you need to refine your search. At the position you looked at, there was a different value. You can use this to re-estimate the position to continue searching.
Now even if you don't know the distribution this can work very well. So you start with a binary search, and looked at objects at 50% and 25% already. Instead of going to 37.5% next, you can do a better guess, if your query values was e.g. very close to the 50% entry. Unless your data set is very ""clumpy"" (and your queries are not correlated to the data) then this should still outperform ""naive"" binary search that always splits in the middle.
http://en.wikipedia.org/wiki/Interpolation_search
The expected average runtime apparently is O(log(log(n)), from Wikipedia.
Update: since someone complained that with just 20 numbers things are different. Yes, they are. With 20 numbers linear search may be best. Because of CPU caching. Linear scanning through a small amount of memory - that fits into the CPU cache - can be really fast. In particular with an unrolled loop. But that case is quite pathetic and uninteresting IMHO.
",6,14786385
14786457,"
I believe best option for you is to use upper_bound - it will find the first value in the array bigger than the one you are searching for. 
Still depending on the problem you try to solve maybe lower_bound or binary_search may be the thing you need.
All of these algorithms are with logarithmic complexity.
",2,14786385
14786415,"
There is nothing will be better than binary search since your array is sorted.
Linear search is O(n) while binary search is O(log n)
Edit:
Interpolation search makes an extra assumption (the elements have to be uniformly distributed) and do more comparisons per iteration. 
You can try both and empirically measure which is better for your case
",2,14786385
14787909,"
In fact, this problem is quite interesting because it is a re-cast of an information theoretic framework.
Given 20 numbers, you will end up with 21 bins (including < first one and > last one).
For each incoming number, you are to map to one of these 21 bins.  This mapping is done by comparison.  Each comparison gives you 1 bit of information (< or >= -- two states).
So suppose the incoming number requires 5 comparisons in order to figure out which bin it belongs to, then it is equivalent to using 5 bits to represent that number.
Our goal is to minimize the number of comparisons!  We have 1 million numbers each belonging to 21 ordered code words.  How do we do that?
This is exactly an entropy compression problem. 
Let a[1],.. a[20], be your 20 numbers. 
Let p(n) = pr { incoming number is < n }.
Build the decision tree as follows.
and so on...
and by the time we're done, we end up with:
each one of these i gives us the comparison position.
so now our algorithm is as follows:
let u = input number.
so the i's define a tree, and the if statements are walking the tree.  we can just as well put it into a loop, but it's easier to illustrate with a bunch of if.
so for example, if you knew that your data were uniformly distributed between 0 and 2^63, and your 20 number were
then
ok so basically, the comparison would be as follows:
so note here, that I am not doing binary search! I am first checking the end point.  why?
there is 100*((2^63)-20)/(2^63) percent chance that it will be greater than a[20].  this is basically like 99.999999999999999783159565502899% chance!
so this algorithm as it is has an expected number of comparison of 1 for a dataset with the properties specified above! (this is better than log log :p)
notice what I have done here is I am basically using fewer compares to find numbers that are more probable and more compares to find numbers that are less probable.  for example, the number 18 requires 6 comparisons (1 more than needed with binary search); however, the numbers 20 to 2^63 require only 1 comparison.  this same principle is used for lossless (entropy) data compression -- use fewer bits to encode code words that appear often.
building the tree is a one time process and you can use the tree 1 million times later.
the question is... when does this decision tree become binary search?  homework exercise! :p the answer is simple.  it's similar to when you can't compress a file any more.
ok, so I didn't pull this out of my behind... the basis is here:
http://en.wikipedia.org/wiki/Arithmetic_coding
",2,14786385
14786433,"
You could perform binary search using std::lower_bound and std::upper_bound. These give you back iterators, so you can use std::distance to get an index.
",1,14786385
14716976,"
You should put the list of strings into an std::set. It's a data structure optimized for searching. Finding if a given element is in the set or not is an operation which is much faster than iterating all entries.
When you are already using C++11, you can also use the std::unordered_set which is even faster for lookup, because it's implemented as a hash table.
Should this be for school/university: Be prepared to explain how these data structures manage to be faster. When your instructor asks you to explain why you used them, ""some guys on the internet told me"" is unlikely to earn you a sticker in the class book.
",9,14716915
14717000,"
You could put the list of words in an std::unordered_set. Then, for each element in the vector, you just have to test if it is in the unordered_set in O(1). You would have an expected complexity of O(n) (look at the comment to see why it is only expected). 
",3,14716915
14717191,"
You could sort the vector, then you can solve this with one ""loop"" (taken that your dictionary is sorted too) which means O(n) not counting in the cost of the sort.
",2,14716915
14717548,"
So you have a vector of strings, with each string having one or more words, and you have a vector that's a dictionary, and you're supposed to determine which words in the vector of strings are also in the dictionary? The vector of strings is an annoyance, since you need to look at each word. I'd start by creating a new vector, splitting each string into words, and pushing each word into the new vector. Then sort the new vector and run it through the std::unique algorithm to eliminate duplicates. Then sort the dictionary. Then run both ranges through std::set_intersection to write the result.
",2,14716915
14647386,"
Do you mean search a word, or search a key?
If map_LongKey contains concatenated words, then searching for the first word of a concatenation will be unsuccessful.
If you are searching for something that is actually a key in one of the maps however, then the answer to (2) depends on many things - more info needed.
If speed is your concern, then search first in whichever map is most likely to contain the key.
If speed is not your concern, then structure your code for clarity - whether this involves merging the maps together or otherwise will depend on your situation.
",2,14647288
14647389,"
It depends on the likelyhood of a successful find in map_Shortkey - if it's quite likely, then you only spend 6 ""steps"" in this search [log2(n)], where a search in the map_LongKey list averages 10-13 ""steps"". 
If, on the other hand, it's unlikely you will find the thing you are looking for in map_shortKey, then the additional load on searching among another 50 elements in the large set isn't going to make much of a difference. 
Since we don't know the statistics of success, it's hard to say which is the better approach. 
",1,14647288
14647471,"
If you favor worst-case complexity and without knowing anything about your searches (e.g. the key is more likely to be found in one map than in the other), then I would go for approach 1).
Lookup in an std::map has logarithmic worst-case complexity, so in the first case you will end up with a worst-case complexity of log(n) + log(m) lookups (assuming your maps have n and m elements respectively). Thus, k lookups will cost you k * (log(n) + log(m)).
Insertion in a map also has logarithmic complexity, so in the second case you will force m insertions from one map into the other and then a lookup in a map with m + n elements. Thus, for k lookups (provided you are doing the insertion only the first time), you get m * log(n) + k * log(n + m) worst-case complexity. 
Thus, if you care about worst-case complexity, approach 1) is preferable as long as:
You can estimate k based on your workload, n and m based on the size of the input, and do the math to figure out what is best (and then double-check this by measuring).
",1,14647288
14595209,"
The beauty of breadth-first search is that it will automatically find the shortest path (you just need to keep track of where you came from when you visit a node).
With a breadth-first search, you always have the cheapest paths at the beginning of the queue and the expensive ones at the end. As soon as you hit your goal P, you are guaranteed that the path length is minimal.
An std::queue is an absolutely fine choice for implementing it.
In response to your comment: You have a queue of nodes / vertices (in your case, these are your cells). When you visit a node, you add all neighbours that you haven't previously visited to the queue. To keep track of which nodes you have visited and where your paths came from, keep an std::array/std::vector wherefrom; around, with one element for each of your nodes. Then (pseudocode!)
Once you hit your target node P, you can just backtrack through wherefrom to find the path.
",5,14595148
14595367,"
I would advise that you read up on Dijkstra's algorithm, and then progress to A* search.
Here is a simple way to solve this problem in C++:

Create a std::vector of ints (let's call it ""trail"") initialized to -1, with one element for each node in your map (size 25 in your example). This will be used to indicate which nodes have already been searched, and where they have been searched from. A node with a 'trail' value of -1 has not been searched, and a node with 'trail' value 8 has been searched from node 8. 
Create a std::queue of ints (let's call it ""search_queue""). Then push the ID of the node containing 'A', and mark its 'trail' value to itself. E.g. if 'A' is node 20, then set trail[20] to 20; This records that the trail started at that point.
Pop the front node from 'search_queue', and look at each its neighbors in turn, adding their id to the queue if their trail value is -1, and they are not restricted (do not contain '|').
Repeat step 3 until you find 'P' (you reached the goal!), or the queue runs empty (there is no valid path).
If you found 'P', then trace your path back to the beginning using your 'trail' vector -- each node will point to the previous node in the path, until you reach a node that points to itself. That is where you started, so you now have a complete path!

You don't have to calculate any distances, because the nature of breath-first-search guarantees that the first valid path that the algorithm finds will be the shortest one possible.
",2,14595148
14595327,"
I assume you have a two-dimensional array with A P O | values.  If unknown, you will need to find A using brute force searching.
For paths, the shortest path from A can be found by creating a set of 1-move positions (i.e. above, right, and possible above-right if diagonal moves are allowed).  As you do so, you want to track which positions have been visited to avoid returning to the same square, so you either need to do something to the original array (e.g. change visited positions from ""O"" to ""o"") or have another array just for this.  From the 1-move position, you can create the set of legal 2-move positions that haven't already been visited.  Keep going until you find ""P"".
Regarding choice of container: with the algorithm above you're not popping anything - can just use a vector.
As a optimisation, you may want to local P too and try a depth-first traversal of the most obvious paths between the two - in your illustated case [diagonally-up-right-]-else-up-else-right with ""up"" allowed until you reach the target row, and ""right"" until you reach the column.  Could do right-else-up too or instead.
",1,14595148
14595242,"
Once you have the map:
define the graph, 1 indicates if there is an edge:
where a_ij = 0 iff m_ij = | and elsewhere a_ij = 1
then run Dijkstra's algorithm or Bellman-ford algorithm.
If you insist to use BFS, here is an explanation why it works as well:
How does a Breadth-First Search work when looking for Shortest Path?
",0,14595148
14546414,"

Implement the comparison operator operator==(const Resistor&) of your Resistor class.
Use std::find to search the vector for the data by supplying a new Resistor instance created from the function arguments.

See http://www.cplusplus.com/reference/algorithm/find/
",1,14546346
14468017,"
Because you are using the index of the second element as a ""not found"" code:
You should return something that cannot be an index, for instance -1. Or better still, use std::find_if.
",6,14467976
14468022,"
The second element's  index is identical to the value which flags the ""not found"" condition.
Use an invalid index like -1 to flag the ""not found"" condition:
and then check for -1 in the calling function:
",2,14467976
14468085,"
do something like this... return any other integer like '-1' if not found
",0,14467976
14467795,"
From your description, the loading of data takes all that time because you're dealing with I/O, mirroring the inflated strings to hard disk. This will definitely be a bottleneck, mainly depending on the way you read and write data to the disk.
A possible improvement on execution time may be achieved using mmap with some LRU policy. I'm quite sure the idea of replicating data is to make the search faster, but since you're using -- as it seems to be -- only one machine, you're bottleneck will go dive from memory searching to I/O requests.
Another solution, which you may not be interested in -- it's sickly funny and disturbing as well (: --, is to split the data among multiple machines. Considering the way you've structured the data, the implementation itself may take a bit of time, but it would be very straightforward. You'd have:

each machine gets responsible by a set buckets, chosen using something close to hash_id(bucket) % num_machines;
insertions are performed locally, from each machine;
searches may be either interfaced by some type your query-application, or simply clustered into sets of queries -- if the application is not interative;
searches may even have the interface distributed, considering you may send start a request from a node, and forward requests to another node (also clustered requests, to avoid excessive I/O overhead).

Another good point is that, as you said, data is evenly distributed -- ALREADY \o/; this is usually one of the pickiest parts of a distributed implementation. Besides, this would be highly scalable, as you may add another machine whenever data grows in size.
",1,14467396
14468303,"
Instead of doing everything in one pass, solve the problem in 38 passes.
Read each of the 180,000 strings.  Find ""A""s in each string, and write out stuff only to the ""A"" hash table.  After you are done, write the entire finished result of the ""A"" hash table out to disk.  (have enough RAM to store the entire ""A"" hash table in memory -- if you don't, make smaller hash tables.  Ie, have 38^2 hash tables on pairs of starting letters, and have 1444 different tables.  You could even dynamically change how many letters the hash tables are keyed off of have based on how common a prefix they are, so they are all of modest size.  Keeping track of how long such prefixes are isn't expensive.)
Then read each of the 180,000 strings, looking for ""B"".  Etc.
My theory is that you are going slower than you could because of thrashing of your cache of your massive tables.
The next thing that might help is to limit how long the strings are you do a hash on, in order to shrink the size of your tables.
Instead of doing all 2278 substrings of length 3 to 70 of a string of length 70, if you limited the length of the hash to 10 characters there are only 508 substrings of length 3 to 10.  And there may not be that many collisions on strings of length longer than 10.  You could, again, have the length of the hashes be dynamic -- the length X hash might have a flag for ""try a length X+Y hash if your string is longer than X, this is too common"", and otherwise simply terminate the hashing.  That could reduce the amount of data in your tables, at the cost of slower lookup in some cases.
",1,14467396
14418321,"
The Java implementation in this answer finds the first occurrence of a key. There's a comment about how this could be changed to find the last occurrence, but the suggestion results in an infinite loop. The idea seems sound, though.
EDIT: After some research, I found a neat solution on The Algo Blog. Since the first found match is not necessarily the needed one, you need to keep track of the ""best"" match so far. When you do get a match, you store it and continue with the binary search on the right of that match (low = mid + 1).
This change keeps the O(log n) complexity. Still, the actual performance depends on the application. When the length of the array is much larger than the amount of duplications of the sought key, a linear search for the last occurrence may be faster. When there are a lot of duplications though, this modified binary search is probably preferable.
",6,14415408
14415588,"
Presumably you want an O(log N) solution?  (Otherwise you could just do a linear search.)
In C++, one possibility (out of several), is to use std::upper_bound.  This will give you an iterator to the first element greater than what you asked for, so then you need to check the previous element.  This is indeed O(log N).
I don't know if Java offers this a standard library method.  However, the pseudocode for upper_bound is given in the link above, and should be easy enough to reimplement.
",2,14415408
14415467,"
Well, thanks to all especially @Mattias, that algo sounds good. anyway i have done with my own, that seem me to give better result, but if some one can help me to measure out the complexity of both algos mine and @Mattias, or any one has some better solution, it welcome.....
anyhow here is the solution i found for the problem,
this is for first occurrence, i also update the same with one other similar post First occurrence in a binary search
",1,14415408
14415615,"
When you find the key. instead of returning it do sequential search on the array to get the last one. This will be O(N) solution. 
",0,14415408
14415532,"
In the binary search you compare your key to elements of the array data[i]. To get the last matching index you should change your compare function so that it gives inequality even if key is equal to data[i] and also to data[i+1].
",-2,14415408
14414997,"
This function display the line at the corresponding line number pass by parameter.
1/ Infile permits to open a file as in put streams : http://www.cplusplus.com/reference/fstream/ifstream/
2/ c_str() permits to pass to a string structure to a simple char* (a char array). It is the structure use in the language C, which explains why the method name is ""c_str"". In C++, we usually use string more than char* cause it is really simpler.
3/ Why currentlineno start at 1 ? The function read the file content before the given line number. The, read one more time to display the wanted line.
4/ ++x is pre-incrementation, x++ is post-incrementation.
When you use ++x, x is incremented before to use it, otherwise, with x++, x is incremented after.
5/ Look at operators : http://www.cplusplus.com/doc/tutorial/operators/
",0,14414845
14414950,"
1) What exactly in ""infile""?
ANS:: Construct object and optionally open file. Link
2) What does the built-in function c_str() do?
ANS:: It is needed to get a const char* representation of the text stored
inside a std::string class. Link
3) Why does the variable ""currentlineno"" start at 1? Couldn't the first line in a file start at 0?
ANS:: Depends on the second input parameter of the function DisplayResult.
4) What is the difference between ++x and x++? 
ANS:: See this. Probably you may have heard of Post-Increment and Pre-Increment.
5) What is the difference between the condition ""currentlineno < lineNumber"" and ""currentlineno != lineNumber"" ?
ANS:: Value of currentlineno should not exceed the value of lineNumber when condition is currentlineno < lineNumber. Value of currentlineno may exceed or may be less than the value of lineNumber but should not be equal to the value of lineNumber when condition is currentlineno != lineNumber.
",0,14414845
14415554,"
This function does not search for words.
It takes as input a file name and a line number. It tries to find and read that line.
The output starts with a line stating: ""The result from (fileName ), line #lineNumber: "" 
It is followed by a text indented by a tab and followed by the found line contents. This second line of output is left incomplete (not followed by a newline).
The found contents is empty, if the file has has less than the requested number of lines or if any of the lines before the requested line has more than 999 characters.
If the requested line has more than 999 characters it is truncated to 999 characters.
Other questions:
1) infile is a function-scope object of automatic storage duration and type std::basic_ifstream<char, std::char_traits<char>>, which is initialized for reading from the file named in fileName.
2) The member function c_str() built into the standard library string class returns a pointer to the string contents as a non-modifiable, nul-terminated character array, which is the format typically used in C for strings (type const char *). For historical reasons the file-based standard library streams take their file name arguments in this format.
3) Humans typically count line numbers starting with one. That is the convention used for the lineNumber parameter. The algorithm used must match this. The currentlineno local variable is used to mean 'the number of the next line to be read'. As such it must be initialized with 1. (This is somewhat confusing, considering the name of the variable.) Other implementations that initialize the line counter with 0 are possible - and indeed natural to most C++ programmers. 
4) See any textbook or online reference of C++. Look for ""pre-increment"" (++x) and ""post-increment"" (x++) operators. They have the same side effect (increment x), but differ in the value of the expression. If you don't use the result they are equivalent (for basic types). 
C++ programmers usually prefer pre-increment as it can generally be implemented more efficiently for user-defined types.
5) Even more basic textbook question. a < b tests for a less-than relationship, a != b tests for inequality. 
Note: All answers assume that the types used are from the standard C++ library, i.e that appropriate includes of the <string> and <iostream> headers and necessary using directives or declarations are used.
",0,14414845
14413959,"
A basic approach would be, as you suggest, to iterate through all your lines and then applying a line intersection algorithm.  Asymptotically this may be the best; after all your new line might well intersect all of the other lines.
In many line intersection algorithms we apply a bounding box test first.  Very roughly, making sure that the rectangles containing the two lines being compared overlap.  If they do not overlap the lines cannot intersect, although if they do a more comprehensive test would need to be applied.
The bounding box test is seing if the x-interval of the two boxes overlaps and the y-interval of the two boxes overlaps.  There are data structures that are specifically designed for efficient interval intersection checks.  Take a look at information on interval trees.  Such a structure would mean, in many cases, that you would be performing your bounding box test on fewer lines; the data structure discarding some lines (via their intervals) before the test needs applying.
",2,14413689
14370971,"
An array is a vectorial variable of a fixed size.
A Linked List has no specified size: each element of the list contains a pointer to the next element. That's why you need to iterate through it sequentially. The advantage here, is that the structure shall not be allocated in a sequential block of memory, and doesn't need to resize if you add more elements in it.
Also in an array, if you remove an element, you need to shift all previous elements. If you insert an element in the middle of an array, you need to shift elements to make space for the new one. In lists you just update the pointers:

On the other side, array can be accessed randomly and don't need sequential access: so they are faster to search for objects, to sort, etc.
",2,14370953
14370985,"
Having random access to a list element allows you to implement search algorithms such as a binary search, which would be impractical using a linked list.
",2,14370953
14369748,"
You mention that you had no trouble except with the list portion, so I'm only going to answer for that portion.
In order to answer this question, you need to understand how std::list is implemented.
Some quick searching brings up:

List containers are implemented as doubly-linked lists. 

From how I interpret it, Guaranteed Performance means the same thing as Worse-case Runtime Complexity.
For element lookup in a doubly-linked list, the worst-case scenario is that your list does not contain the item you are trying to lookup. In that case, you would have to compare every item in the list to the item you are searching for. So the worst-case runtime complexity of this operation is O(n), where n is the size of the list.
",2,14369499
14369750,"
From http://www.cplusplus.com/reference/list/list/

The main drawback of lists and forward_lists compared to these other
  sequence containers is that they lack direct access to the elements by
  their position; For example, to access the sixth element in a list one
  has to iterate from a known position (like the beginning or the end)
  to that position, which takes linear time in the distance between
  these. They also consume some extra memory to keep the linking
  information associated to each element (which may be an important
  factor for large lists of small-sized elements).

So, iterating through a std::list< > (looking up an element) is linear complexity.  Also, you cannot access elements by index.
",1,14369499
14370750,"
In case you want a more formal statement of what's supported, here's what the standard has to say. About the best searching we can do is with a binary search, such as std::lower_bound (§25.4.3.1/3):

Complexity: At most log2(last − first) + O(1) comparisons.

That only tells us the number of comparisons though. To move through the container, lower_bound uses std::advance. About an std::list we find (§23.3.5.1/1):

A list is a sequence container that supports bidirectional iterators [...]

So, how does std::advance work for a collection that provides bidirectional iterators?
(§24.4.4/1):

[...] for input, forward and bidirectional iterators they use ++ to provide linear time implementations.

So, to find anything in a list (by either value or position) we're going to be looking at linear complexity overall, with a logarithmic number of comparisons. To be honest, we're probably better off with std::find (§25.2.5/2):

Complexity: At most last - first applications of the corresponding predicate.

The choice between the two may not always be entirely obvious though -- traversing the list is obviously linear. std::find minimizes traversal, while std::lower_bound minimizes comparisons. If comparison is a lot more expensive than traversal, std::lower_bound will probably do better. If comparison is fairly cheap, std::find is probably better.
",1,14369499
14369871,"
I recommend that you read the following reference:
What are the complexity guarantees of the standard containers?
It has a chart of order complexity of many standard containers and one of the answers links to the STL complexity specifications. (http://www.sgi.com/tech/stl/complexity.html)
Since this is a class project, I recommend that you not only read these reference for your answer, but spend some time in the STL headers and get a feel for the implementation of these containers on your architecture. 
STL is a fantastic way to leverage the knowledge of true experts ... however it can also be the proverbial enough rope, if not given due diligence
",1,14369499
14302798,"
Put an else and your problem will disappear.
Because after temp = temp->right; you must check temp again but in your original code you immediately test temp->data which may not be a valid pointer.
",6,14302754
14305555,"
std::set
Use a std::set; it is basically STL's binary tree. If you want to search for something, you would use count, find or lower_bound.
Implementing basic data structures are good exercises, but in production, try to use STL first, as they are implemented by professionals with specific knowledge of the compiler/platform in question. Boost is another great set of data structures and common idioms.
",1,14302754
14256873,"
Wrapping comments (of me & @betabandido) into an answer:
You basically need to find 2 candidates, the closest ""upper"" element, and the closest ""lower"" element (assuming the element is not in the list). This can be achieved using Binary Search efficiently (O(logN))
By using std::lower_bound() you can get the higher element, and the lower is the element before it in the array.
Compare the two candidates - the one which is closest to the given float is your answer.
",4,14256457
14249229,"
One simple, fast algorithm is to iterate over all entries and set each region to zeroes when it is encountered. This takes O(N*M) runtime (each entry visited at most twice) and O(1) additional memory.
To set a region to zeroes, just note the column where it begins, then iterate to the rightmost column. Then iterate over the rows below from the left to right columns, setting each entry to zero.
Working code:
",4,14249153
14249211,"
The painting technique works well.  The idea is that you drop a paint bomb that completely covers an area.  Pseudocode:
And a paint bomb works like this:
",1,14249153
14249232,"
One way is to use the Flood Fill algorithm to detect contiguous areas, like this:
Assuming that the initial matrix has only positive numbers,

Prepare a counter, set it to -1
For each point in the matrix:
If the cell is zero or negative, skip it; otherwise
Flood fill starting at the cell with the negative value of the counter
Decrement the counter after the flood fill is over

When you reach the end of your matrix, counter will have the negative number equal to the number of contiguous numbered areas minus one, i.e. the result that you need is -(counter+1).
",1,14249153
14249256,"
I always liked the Union/Find algorithm for isolating groups.  But that's cos I had an old implementation kicking around that I had written years ago.  It's not a big deal to implement, but it might be more appropriate to use Flood Fill.
",1,14249153
14171038,"
This is pretty straight forward, first you need to iterate over all the files/folders recursively, filter the ones with the extension you are interested in (in this case .mp3 files), and then read the meta data to get the ID tags.
This is how you can do it:
Iterating over the files and folders:
C++ doesn't provide a standard way of doing this, so you have to look into the different possible solutions available for you.
If you are working with Windows, you can use the Win32 API:

FindFirstFile  
FindNextFile
FindClose

If you are working in Unix/Linux:

opendir
readdir
closedir

And if you want a cross platform solution you can look into boost filesystem module.
There are several implementations available over the internet using the former functions and methods.
Filtering the Files:
The general approach would be to split the string of the file path using the ""."" (dot) character as a separator and getting the last element (you will have to consider the case where the split is not successful due to the file not having dots).
Example (not tested):
Getting the meta data:
You can read about it here http://id3.org/

An ID3 tag is a data container within an MP3 audio file stored in a
  prescribed format. This data commonly contains the Artist name, Song
  title, Year and Genre of the current audio file.

Example:
This is a working implementation of some of the concepts explained above, this program iterate recursively over all the files and folders and print on the screen the ones with the .mp3 extension (It does not get the meta data information on the ID3 tag).
It uses Windows API, so if you are working with Linux or just want a cross platform solution, you will have to change the code.
",8,14170571
19448769,"
I'm not aware of a way to do this directly with a standard library, but you could make your own function and strstr pretty easily.
For your second question:

Also how to compare just 2 chars directly regarding to the locale? 

I'm not sure what you mean. Are you asking how to compare two characters directly? If so, you can just compare like any other values.
    if( str1[n] == str2[n] ) { ...do something... }
",0,19372108
19373052,"
You can use std::substr to limit your search area:
",0,19372108
19381942,"
I solved it like that
npos = -1
and to specify the start index pass to (buffer + startIndex) as the buffer to the second or the third method
",0,19372108
19370979,"
I can't see any way apart from brute force.
Search each row for a pair, then check the x[b][c] for that pair.
Let the array be NxN. Comparing each element of a row with each other element of the row takes
comparisons and you need to do it for all N rows giving O(N^3). If your talking total size (M=N^2) then its O(N^(3/2)).
",2,19370917
19371057,"
I'm pretty sure the brute force solution would be O(N^3)
A different solution (other than the trivial (0,0,0)) would be to put each pair in a hash table using its value as the key.  Then look for pairs that match your criterion within the duplicates.
",0,19370917
19234317,"


As soon as found > 0, then last_char >= x.length() and your at() call attempts to read out of bounds.
Note also that a space is not the only possible token delimiter. One routinely writes things like break;, or return;, or while(condition), or f(int[]), or this->member. All of these contain a keyword that is not surrounded by spaces.
And, a string that looks like a keyword may appear in a string literal, ""like this"".
",2,19234180
19231065,"
std::lower_bound and iterating forward (you might use std::upper_bound, too):
",1,19230612
19230804,"
You needed to build index not for each phrase, but for any sub-phrase. started from the word. For example, for dict-string ""New York"" you must keep index for two strings: ""New York"" and ""York"".
See my autocomplete demo, which illustrate this idea: 
http://olegh.cc.st/autocomplete.html
As you see, this subsystem quick work with dictionaries, largest than your 250K elements.
Of course, I do not use there binary search, since it is slow. I use hashing instead.
",0,19230612
19234251,"
An ordered vector (list) is certainly one way to store data, but keeping the items organized has an efficiency cost.  And you did not mention whether your array was static or dynamic.  But there are other data structures which allow storing sorted data and have very good lookup times.

Hash/Map - You could store your items as a hash/map and have very fast lookup, but finding the next and previous is problematic.
Binary Tree/N-ary Tree/B-Tree - very good dynamic insert/delete performance, and also good lookup times, and the tree is ordered, so find next/previous is stable.
Bloom filter - sometimes all you want to do is check whether an item is in your collection, and a bloom filter has very low false-positive, so it is a good choice.

Suppose you decompose your data into short subsequences (syllables), then you can have a tree of syllables, very fast lookup, and depending upon whether the tree is implemented as an ordered list or a hash/map, you may also be able to find next/previous.
",0,19230612
19172554,"
should be
Also
should be
My test code was:
",0,19172088
19159871,"
As a general rule, don't start breaking the string up into
smaller pieces (substrings) until you need to.  And start by
specifying exactly what is wanted: you speak of RHS and LHS, and
talk of ""get RHS value based on LHS argument"".  So: do you want
an exact match on the first field, a substring match on the
first field, or a substring match on the entire line?
At any rate: once you have the line in line, you can easily
separate it into the two fields:
What you do then depends on what your criterion is:
Of course, you'll need some additional error checking.  What
should you do if there isn't a comma in the line (e.g. pivot ==
line.end()), for example? Or what about extra spaces in the
line.  (Your example looks like numbers.  Should ""401"" match
only ""401"", or also ""+401""?)
Before going any further, you should very carefully specify
exactly what the code should do, for all possible inputs.  (For
most possible inputs, of course, the answer will probably be:
output an error message with the line number to std::cerr and
continue.  Being sure to return EXIT_FAILURE in such a case.)
",0,19159006
19159370,"
You can do the work of the code above with:
If you want to output just the RHS, you can:
If you are on a Windows platform without sed, grep, bash, etc. then you can easily access unix tools by installing cygwin.
",1,19159006
19040384,"
Instead of erasing elements in the middle of the vector (which is quite expensive), and then starting your search over, just compare the elements before and after the found item (because they should all be adjacent to eachother) until you find the all the items which match.
Or use std::equal_range, which does exactly that.
",4,19040294
19040388,"
This will be the culprit:
You are repeatedly removing items from your dictionary to naively use binary search to find all valid prefixes.  This adds huge complexity, and is unnecessary.
Instead, once you have found a match, step backwards until you find the first match, then step forwards, adding all matches to your queue.  Remember that because your dictionary is sorted and you are using only the prefixes, all valid matches will appear consecutively.
",2,19040294
19040442,"
dict.erase operation is linear in the size of dict: it copies the entire array from middle to end into the beginning of the array. This makes the ""binary search"" algorithm possible quadratic in the length of dict, with O(N^2) expensive memory copy operations.
",1,19040294
18955288,"
If you want a list of strings, Qt provides the QStringList class.
Once all strings are added, you can call the removeDuplicates function to satisfy your requirement of no duplicates.
To search for a string, call the filter function, which returns a list of strings containing the string, or regular expression passed to the function.
Here's an example, adapted from the Qt documentation: -
result is a QStringList containing ""Bill Murray"" and ""Bill Clinton""
If you just want to know if a string is in the list, use the contains function
Found will return true.
",2,18949961
18887313,"
You can use a map<string, Item> (you might want to remove name from the Item struct).
Then you can use it for instance like this:
",2,18887183
18855578,"
Your best bet is to profile your specific application with a variety of mechanisms and see which performs best.
I suspect that given it's unsorted a straight linear search will be best for you. If you're able to pre-sort the array once and it updates infrequently or never, you could pre-sort and then use a binary search.
",2,18855458
18855672,"
Try a linear search; try starting with one or more binary chop stages. The former involves more comparisons on average; the latter has more scope for cache misses and branch mispredictions, and requires that the arrays are pre-sorted. 
Only by measuring can you tell which is faster, and then only on the platform you measured on.
",1,18855458
18855767,"
If you have to do this search more than once, and the array doesn't change often/at all, sort it and then use a binary search.
",1,18855458
18801681,"
You may consider storing next pointers in vector (or array) of pointers:
Then in your search method you iterate over this vector:
}
",1,18801526
18774907,"
You are exiting your function on the first miss with the misplaced return false:
",6,18774858
18771327,"
When you modify an entry first you remove the existing entry and then you insert a new node, rather than actually modifying the old entry itself. Once you do that you call InsertNewNode but you don't check to see if the list is empty
Thus,
Change that line to:
",0,18770960
18748152,"
you can use ASCII values of characters to store as array index.
now your graph will be 2D matrix of nodes.
in c/c++ you can use yourChar - 'A' to get index.
A as 0, B as 1 and so on...
",0,18747996
18748499,"
If your are planning to go any further with graphs, take a look at the Boost Graph Library.
",0,18747996
18708966,"
Several obvious problems:

Arrays in C++ is 0-based, so your for loop is off-by-one. In your search function, for(int i = 1; i <= MaxSize; i++) should be for(int i = 0; i < MaxSize; i++). Similarly, in your read function, for(count = 1; count < MaxSize; count++) should be for(count = 0; count < MaxSize; count++) (If you want to skip index 0 because you are using it as a signal value, then you should set MaxSize to 13 and have the loop start at 1.)
Why are you assigning a boolean to MonthOfWeather? Do you mean MonthFound?
You read function is not setting the months correctly. WeatherArray[count].Month = WeatherArray[count].Month + 1; should be WeatherArray[count].Month = count; if you are using a 1-based loop or WeatherArray[count].Month = count + 1; if the loop is 0-based.
You calculated your total rainfall in the read function, but the result is stored in a local variable so it's lost when the read is done. Either make TotalRainfall a global variable or do your calculations in your search function.
There are a lot of redundant variable definitions: for example, your weather data array is a global so there is no reason to actually pass it around; exit_char is declared twice in your read function; the first five lines of your main() declared variables that you never used.

Also, your read function does not actually exit the program on failure - it even still attempts to read from the stream and then call your search function! If error-checking is a requirement, you should either have the read function return a boolean and check that the read function succeeded before calling your search function, or simply call std::exit after that cin >> exit_char;.
",1,18708817
18708899,"
So, one problem you have is that you have local variables that appear in multiple places, but appears like you expect them to actually contain the same information. 
For example, I see three different TotalRainFall. One in main, which is just there, not used for anything, one in ReadFile which is calculated, and one in WeatherMonthSearch, which is not set to anything. 
I suspect you want all three of these to actually do something. One way to achieve that would be to remove the local ones in ReadFile and WeatherMonthSearch, and instead pass in the one from main (as a reference into ReadFile). 
There's also a few places where you use variables without initializing them. Make it a habit to initialize EVERYTHING and EVERYWHERE!
Enable warnings in your compiler - if you have any form or reasonably new compiler (gcc or MS Visual Studio of recent vintage), it should tell you at least some of these things. 
",0,18708817
18599247,"
You have lot of typo in your code:
You hide the initialization of ascending_flag
Your length count seems incorrect.
Following should work (as long as there aren't two neighbours with same values).
",1,18598206
18607539,"
Here are some thoughts:  

If function is named ""findX()"", it should return X (say, pointer to the first element of the sequence or NULL, or index of the first element or -1). If function prints X, it should be named ""printX()"".
It's not clear whether you need ascending or strictly ascending sequence (i.e. is (1, 2, 2, 3) good for you or not).
You overcomplicate things. If you need first sequence, you just use reverse iterators and go from end to beginning, like this (I don't use iterators, but it should be clear how to include them):


",1,18598206
18598308,"
Well, for starters, your function will always return true.
should probably be 
",0,18598206
18531802,"
You want something like this:
to execute when you call get_classes.sh  'CBaseClass' src/
",0,18531500
18400929,"
Vectors can be accessed via [] as normal arrays. g is an array of vectors of ints, so can be accessed as 2D array. It contains info about edges in graph of cities, as an adjacency list

In make_graph() on list (vector) of x'th vertex, i'th one is pushed and vice versa, because the connection is in both ways.
In dfs() function for each adjacent vertex j on x'th list, x is marked as j's parent, because DFS starts from root (new HQ) and x is connected with j.
Line if (j == parent[x]) prevents from DFS-ing parent nodes (which still are on their children's lists).
",0,18398931
18384915,"
have you tried ctrl+shift+g ? that should find for all references to the selected identify.
",1,18384837
18359211,"
Just use upper_bound with the proper comparison function:

Your list is reversed (upper_bound usually expects increasing order) so you need to use > rather than <.
You want to include the searched element (while upper_bound usually excludes it) so you need to use >= rather than mere >.

. 
Now you only have to convert the resulting iterator to an index (after checking it is valid):
",3,18358840
18358974,"
Use the upper_bound() that takes a compare function as it's forth arg.
",0,18358840
18359198,"
For the iteration way, what I would probably do is start my search val values from the end of the array. ie:
One key to this loop is that once it encounters any value less than or equal to, it return the index, limiting it to the first case it finds.
It also checks to see if val is larger than the largest array index.
",0,18358840
18340994,"
The following should work:
Explanation:
^ - the start of the string
. - wild-card
.*? - zero or more (*) wild-cards (.), matched non-greedily (?), so you get the first match, not the last one
So you match everything from the start of the string to the digits.
Alternative using boost functionality:
regMatch.prefix() should return the required string.
",2,18340878
18283087,"
Just a guess, maybe the vectorName is not square, so change:
to
",1,18283040
18045666,"
Start in the top right position v of the matrix. If it's the item x you're looking for, you're done. If v is less than the item you're looking for, move down. If v is greater than the item you're looking for, move left. Repeat until you hit the ends of the matrix.
Proof of correctness:
If the top right item is equal to x, there is nothing to prove. Consider two cases
In this case, we know that all of the elements in the top row are less than x. Thus, we can ignore the entire top row and move down.
Therefore, we can go from
to
That is, we end up with a smaller problem.
The other case is
In this case, we know that all of the elements in the right column are greater than x. Thus, we can ignore the entire right column and move left.
to
Again, we end up with a smaller problem. By induction, we are done. This algorithm has time complexity O(m + n).
Edit:
Ted Hopp links to an absolutely beautiful extension of this idea that gives even better performance.
Here's the idea. In the algorithm that I gave above, the idea was that we could eliminate entire rows or columns from consideration at a time. The idea that he links to is to eliminate entire quadrants at time. The idea is simple
Binary search the middle row. This will give you the item, or a position that brackets the item you're looking for
Now here is the key insight. The entire upper-left quadrant, and the entire lower-right quadrant can be immediately eliminated from consideration; all the elements in the upper left are less than a, all the elements in the lower-right are greater than b.
Now recurse on the two remaining pieces. Additionally, you can do the same procedure on the middle row or the upper-left to lower-right diagonal depending on which will yield the biggest gains. 
",5,18045639
18045731,"
There's a very nice write-up here of algorithms to solve this problem. As the article describes, a simple binary search by row for each of the rows (or likewise for each column) gives an O(n log n) solution. However, a simple algorithm that starts at the top right and then proceeds linearly either to the left or down results in an O(n) algorithm. (That's right: linear search beats binary search!) However, even better results come from using binary partitioning of the matrix (based on the linear search) and results in an algorithm that in some cases has O((log n)2) (sub-linear) performance.
The best algorithm seems to be a divide-and-conquer approach: for an m × n matrix M with n (number of columns) < m (number of rows)* and target value v, search the middle row (call it row r) for the index c such that Mr, c ≤ v < the target value v is Mr, c+1. If v = Mr, c, then you're done. Otherwise, recursively apply the algorithm to the sub-matrices Mr+1, 0…Mm-1, c and M0, c+1…Mn-1, r. (These are the bottom-left matrix bounded by cell (r+1, c) and the top-right matrix bounded by cell (r-1, c+1).)
See the link for details about performance and the code itself.
* If n > m, search the middle column instead. If n = m, search the diagonal. The exact boundary for the sub-matrices in each case needs to be slightly adjusted from the above description; see the article.
",2,18045639
18045677,"
Typically the first index is ""row"" and the second is ""column"", and the column index should be contiguous memory, even if the rows are allocated in separate chunks, so from that perspective, it should be faster to search all columns of one row, then move to the next row and iterate over the columns there. 
Obviously, that supposes that all the items you are searching for are equally distributed, and the ""first item in each row is more likely to be the candidate you are looking for, and the last of each column least likely"". 
Also quite obvious, if each row contains values that are sorted, then you can binary search through the columns, as well as skip the entire row if the min and max values aren't covering the range you're searching for.
As with everything ""which is faster"", you really need to benchmark your solution to determine what is best in your particular situation. 
",0,18045639
18014769,"
My bad, I searched the error at the wrong end. My problem wasn't seekg, it was the getline function from ifstream using char[] instead of string, which was a surprise to me. If the array was choosen too small and the deliminating character wasn't found yet, bad things happened. 
The problem can be avoided by making sure that the array is as big as it needs to be, or by calling the global getline with string.
",1,18013996
17903186,"
Why it does not return (-4, 19) as the first result: You have the parameter type wrong in comp_lower. The bound parameter should be double, not unsigned.
Why it does not return (-3.5, 11) as the second result: Your code says double b = -3.0, even though your problem description states -3.9.
Still, this is not quite correct. Both lower_bound and upper_bound return the first element of a sequence that fulfills certain rule, so neither is directly suitable to the task of finding the upper limit you need. However, if you simply take the preceding element, you will get the correct result:
And, of course, you have to check if upper_bound has returned the first element of the sequence so that the iterator won't go out of bounds with the decrement.
",0,17903082
17849570,"
Since this process is going to be repeated multiple times, I would suggest you to sort the elements and store it in a vector along with index as a pair. And you could be able to find the essential index or indices easily given this vector.
Pair contains element and index in the original array. you could sort this vector according to the element value. 
",4,17849428
17748936,"
The easiest solution is to convert the input to lower case, and
use std::search: 
The ToLower class should be in your toolkit; if you do any
text processing, you'll use it a lot.  You'll notice the type
conversion; this is necessary to avoid undefined behavior due to
the somewhat special interface of ::tolower.  (Depending on
the type of text processing you do, you may want to change it to
use the ctype facet in std::locale.  You'd also avoid the
funny cast, but the class itself will have to carry some excess
bagage to keep a pointer to the facet, and to keep it alive.)
",1,17748121
17748204,"

copy your inputs and convert them to lower case (see How to convert std::string to lower case?)
perform usual search (http://www.cplusplus.com/reference/string/string/find/)

",3,17748121
17629269,"
This is a partial answer, primary focused on cleaning up the stream-reading logic. I cannot figure out what you are doing with enough clarity to offer any more help. (E.g., why are you outputting essay to outfile without having put anything in it.)
",0,17627386
17594285,"
",0,17553472
17432175,"
Probably easiest just to write the outer loop yourself:
Alternatively, you could write an iterator class that iterates over the whole matrix:
Now you can do:
",3,17431963
17432272,"
I am assuming you are storing your data in a two dimensional vector. 
You should be able to just iterate your matrix like this to obtain the largest element
",0,17431963
17266394,"
Obviously, you do indeed need a FindNextFile call, and repeat that using a loop of some sort, until it returns a ""no more files"" return code. 
To then search the entire disk, you will need to look for directories in the ""current directory"" (the root directory), and for every directory search into it - you can do that either by calling finddata recursively (adding the name of the directory as an argument to the function), or implement a stack in the code to track which directory you are in, and which one to ""walk back to"" for the next level. 
I'm intentionally NOT writing the code for you, but describing what you need to do, since you are the one learning programming. I did this sort of thing in 1985 or so.
",2,17266343
17267052,"
Recursivity is the way.
Here is a possible implementation (for inspiration, but do it your own way):
Usage :",1,17266343
17158183,"
I never used it myself and it might be out-of-date compared to recent C++ version features (last update is from 2011), but STXXL is meant to be a set of containers and algorithms built for very big amount of data.
It might fit your need.

The core of STXXL is an implementation of the C++ standard template
  library STL for external memory (out-of-core) computations, i. e.,
  STXXL implements containers and algorithms that can process huge
  volumes of data that only fit on disks. While the closeness to the STL
  supports ease of use and compatibility with existing applications,
  another design priority is high performance.
The key features of STXXL are:

Transparent support of parallel disks. The library provides implementations of basic parallel disk algorithms. STXXL is the only
  external memory algorithm library supporting parallel disks.
The library is able to handle problems of very large size (tested to up to dozens of terabytes).
Improved utilization of computer resources. STXXL implementations of external memory algorithms and data structures benefit from
  overlapping of I/O and computation.
Small constant factors in I/O volume. A unique library feature called ""pipelining"" can save more than half the number of I/Os, by
  streaming data between algorithmic components, instead of temporarily
  storing them on disk. A development branch supports asynchronous
  execution of the algorithmic components, enabling high-level task
  parallelism.
Shorter development times due to well known STL-compatible interfaces for external memory algorithms and data structures.
STL algorithms can be directly applied to STXXL containers; moreover, the I/O complexity of the algorithms remains optimal in most
  of the cases. 

For internal computation, parallel algorithms from the MCSTL or the
  libstdc++ parallel mode are optionally utilized, making the algorithms
  inherently benefit from multi-core parallelism.

",4,17157929
17157990,"
A hash map is one way you will have faster lookup than a sorted vector. You must have c++11 support to use it.
http://www.cplusplus.com/reference/unordered_map/unordered_map/
To preserve the order of the data the only way would be to maintain a vector beside it that stored the int's as well
Before you jump to using it you should consider how you are going to use this data structure (access pattern). Also consider what the data you will be getting is likely to be.
Here is boost's version of the same thing http://www.boost.org/doc/libs/1_53_0/doc/html/unordered.html
",1,17157929
17158130,"
I think what you should use is unordered_map  combined with maybe a doubly-linked list for the order.
So every time you add a new item to your database you add it first to the front (or the end) of the linked list, and then add it to the hashmap where the key is the value (the unsigned int) and the ""value"" (from the key/value pair) is the pointer to the the object in the linked list.
So now if you want a fast lookup you look in the hashmap, and if you want to iterate by order you use the linked list.
Of course when you want to remove an object you have to remove them from both, but complexity wise it's the same (O(1) amortized for everything).
This will of course increase your memory by 2 or 3 compared to just using a hashmap.
",0,17157929
17045555,"
Efficient algorithms (in terms of both, theoretical, asymptotical running time and practical efficiency) for your purpose are
http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm
and http://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm
Just like they operate on readable strings, they work on sequences of bytes. They will also work on sequences of bits (but in this case they usually are not the best options. you should avoid comparing bit by bit and might as well shift your pattern and compare. also your alphabet will contain only 0 and 1 which does not allow the string search algorithms to use their full potential), but regarding your question (and the possible hex representation), I do not think that this is what you want.
However, if you're reading the file from disk, and patterns are not too long, the execution time of your program will vastly be dominated by the time it takes to read from disk. In that case, the naive solution, as posted by Gam Erix, is perfectly fine and much easier to implement.
Another optimization for patterns smaller than a machine word: just interpret the pattern as larger type (uint64_t, for example) and use a single comparison for the whole pattern (you'll have to check bounds when you reach the end of your input sequence)
",0,17045296
17045350,"
just read each char and compare it to the first occurence you search for, if it matches, check if the next byte matches the next occurence, when you read a file in binary with fstream it reads the bytes.
",0,17045296
17052712,"
I doubt this is the most efficient or even fastest way, and I make no claims to having uber technique, but here's a way to scan for bit-patterns.
",0,17045296
16982960,"
If they keys are unique, use std::map or (C++11) std::unordered_map.
If the keys are not unique, use std::multimap or (C++11) std::unordered_multimap.
The latter have O(1) search and insert, but require that you provide a quality hashing algorithm (not easy to make) and possibly re-hash the map as it grows & shrinks.
Searching is provided by the containers.
Serialization is left as an excercise for the reader. 
",1,16982721
16982981,"
",0,16982721
16969762,"
If you want to avoid nested loops try something like this:
for (auto aIt = a.begin(), bIt = b.begin(); aIt != a.end() && bIt != b.end(); ++aIt, ++bIt)
",0,16969538
16969855,"
The pattern you probably want to implement is the following:
which let you verify some property on elements having the same rank in both lists, or  containers supporting the standard library ""iterable"" interface (so to speak). Note that you need your containers to return the elements always in a consistent order for the comparison to make sense.
",0,16969538
16969784,"
If you can sort list then sort both and compare by two pointers in the one loop ( O(N log N) ).
If there are small number of different values (for instance, if only 0 and 1 - it's just 2 different numbers), you can calc count of each number (number of 0 and 1 in example) and check result. ( O(N) )
If you can associate numbers (like index) with elements of list, you can effectively use std::bitset. It's more complicated, but has high performance. Look at this, operation AND.
Still, look at the std::set_intersection. It's very clear and simple, and in fact works with pointers too.
",0,16969538
17230838,"
I believe that what you are looking for is called ""Spelling Suggestion"". Here's a thread that might help you get what you need.
Does Google allow other people to use their ""Did you mean"" API?
",0,16921446
16675419,"
Suggested Approach

Implement a generic graph search algorithm


could use either IDFS or A* graph search

I would prefer the second

do this for a general directed graph

node type TNode
node successor function TNode => vector<TNode>


Define your Sudoku states


a state is a 9x9 array with a number 1, 2, ..., or 9 or a blank in each position

Define what a goal Sudoku state is


all 81 cells filled in
all 9 rows have numbers {1, 2, ..., 9} in them
all 9 columns have numbers {1, 2, ..., 9} in them
all 9 3x3 squares have numbers {1, 2, ..., 9} in them

Define your valid Sudoku state successor function


a state S can have number N added at row I, column J if:


cell (I,J) is empty
there is no other N in row I
there is no other N in column J
there is no other N in the 3x3 square containing (I,J)

the state successor function maps a state S to the vector of states that satisfy these rules

Apply your generic graph search algorithm (1) to the Sudoku state graph (2-4)
(optional) If you do choose to use A* graph search, you can also define a heuristic on your Sudoku state space to potentially drastically increase performance


how to design the heuristic is another whole problem, that's more of an art than a science


Current Approach
Your current approach mixes the specification of the graph to be searched and the implementation of the search algorithm. You're going to have a lot of difficulty if you mix those two. This problem naturally separates into two distinct pieces -- the algorithm and the graph -- so you can and should exploit that in your implementation. It will make it much simpler.
The other benefit you get if you go with this separation is that you will be able to reuse your graph search algorithm on a huge number of problems - very cool!
",20,16675248
16676012,"
The following assumes you are trying to solve a given board, not generate a puzzle.
Basic (simple) approach
Create a class whose objects can hold a board (here called board_t). This class may internally use array, but must support copying boards.
Have a function void solve(board_t const& board); which repeats the following for each number n:

Copies your input
Enters n in the first empty cell of the copied board
If the copied board is a solution, print the solution and return.
Else If the board is still viable (e.g. no conflicts):

call solve(copied_board)


Performance
This is a recursive backtracking solution, which performs horribly for hard problems. You can significantly speed it up by proper pruning or deductive steps (e.g. if you end up with 8 numbers in a row after inserting one, you can immediately enter the ninth without any kind of search).
Reasoning
While certainly not an impressive technique, it has a high probability of working correctly, since you will only ever be modifying a copy to add a single value. This prevents corruption of your data structures (one problem your idea has is that it will destroy the numbers it finds when backtracking, are not necessarily the ones you just inserted, but may be part of the initial puzzle).
Improving performance is quite simple, once you start picking more intelligent heuristics (e.g. instead of testing the square in order, you could pick the ones with the fewest remaining moves and try to get them out of the way - or do the reverse...) or start doing a bit of deduction and pruning.
Note: The Algorithm Design Manual uses a Soduko solver to show the impact of these techniques on backtracking.
",4,16675248
16685625,"
There is one very important modification to recursive algorithms: Use most constrained first approach. This means first to solve a cell with smallest number of possible candidates (when direct row/column/block conflicts are removed).
Another modification is: Change the board in-place; do not copy it. In each recursive call you modify only one cell on the board, and that cell used to be empty. If that call doesn't end up in a solved board somewhere down the recursive call tree, just clear the cell again before returning - this returns the board into original state.
You can find a very short and fast solution in C# on address: Sudoku Solver. It solves arbitrary sudoku board in about 100 steps only, all thanks to the most constrained first heuristic.
",1,16675248
39802377,"
This is a classic Constraint Satisfaction Problem. I recommend doing some research on the topic to figure out the successful strategy. You will need to use AC-3 ( Arc Consistency 3) algorithm along with the backtracking techniques to solve the problem. 
",0,16675248
16664035,"
This program is self-explaining. Hope it helps.
",0,16663406
16663511,"
The counts originally in the individual variables A,B,C,D,F and now saved into an array, ""results"".
where:
results[0] is A
results[1] is B
...
results[4] is F
",0,16663406
16419827,"
Everything related to the algorithm should be in the iterator, and not in the graph. More precisely, your iterator should not modify the state of the graph. Think about your iterator used on a const graph. Nothing prevents you from using few data structures in your iterator. A naive approach for instance will be to replace 
bool marked;  // for DFS
in your class vertex by a map in the iterator itself.
std::map<struct vertex*, bool> visited_vertices
",2,16419663
16408568,"
I can see a  problem, The Btree class is reinitalizing the constructor to BinaryTree
It should be:
The Derived class, by principle will call Base classes constructor.
Another one:
is being declared twice.
Another one:
Requires you to define a fillTree function in your Btree(Derived) class. Or have it as an absolute virtual function in the Derived class, but then that means the class must not be initiated, and should Inherited by another Dervied class which defines the virtual function.
This link might help
",0,16407802
16401282,"
Got it fixed i stupidly set the name outside the loop.
",1,16401091
16307167,"
How about:
",4,16307090
16272035,"
You need to to control NULL result in the sibling search:
",1,16271913
16272171,"
your problem was here, it t->siblingList != NULL you never got to t->FirstChild.
",1,16271913
16272039,"
The problem is in 
The return statement makes the function return in any case if there are siblings, independently if something was found or not.
On node 2, you will return having it 3 as a sibling, and the ""child"" descendance will never be attempted.
This way should be correct
",1,16271913
16257591,"
To me, it looks like you have quite a few problems in the code there, but also it's hard to be sure what your intention was when you were implementing the code (i.e. which problems are issues with C++ and which would be issues with ""design-level"" pseudo code). One problem in the code is that the delete parent only frees the space occupied by the object that parent refers to. So when you pop the stack, you may end up re-executing the if (parent->left) branch, and therefore deleteing the same object again. And you only ever seem to delete leaf nodes.
The biggest problem I have is that the design of your algorithm isn't clear. The usual way to get a stack-based version of a recursive algorithm going is to get a recursive version going first (at least on paper), then factor out the recursion. In this case, your standard post-order traversal, implemented as a call to do_action, below, with node = root, is along the lines of
In your case, action is delete the node. Now, you can implement this without explicit recursion (and as shown by the answer to Non recursive Depth first search algorithm this can be quite straightforward for some tree traversal problems). However it arguable as to why you would want to in this case? Recursive calling uses the program's own stack, whereas you want to implicitly recurse using your own data structure instead. It is only in the case of removing tail end recursion that the advantages are black and white, because here recursion is really eliminated, rather than simulated with a stack.
If you do go down the route of removing recursion, it seems like your code might get pretty ugly: see http://leetcode.com/2010/10/binary-tree-post-order-traversal.html and Non-recursive post order traversal. It's possible your implicitly recursive code would perform worse in time and/or space than your original, explicitly recursive one. It's certainly likely to be more buggy!
",0,16250042
16240730,"
Here you access s[k] only if s's length is less than or equal to k, which is the opposite of what you want. The condition should be s.length() > k.
",0,16240377
22150847,"
It's good that you're thinking about this, but:

in most operating systems and filesystem types, you can overwrite specific bytes in the file content, but there's no way to insert or erase data part way through the file such that later data is moved to create or fill a gap: this means that if you want to replace ""Sonya"" with ""Susan"" it can be done in-place, but if you change ""Sonya"" to ""Sue"" then all the rest of the file must be read and written 2 bytes further forward in the file (unless you decide it's ok to fill in the 2 unneeded characters with say spaces, but then you're still stuck if e.g. ""Tom"" is changed to ""Thomas"").
if you're determined to pursue this, you first need to know if the file is sorted on the key you need to search by:

if not then you'll have to read through the file at least until you find the data to be changed, and if the length of the new data doesn't perfectly match the length of the old data then you'll need to read and write out the updated content thereafter anyway
if so, then you could do a binary search through the file to find the record to be updated, but as the lines are of variable length you'd need a heuristic approach to recognising which line was name, which addresses, which bank account.  That's probably possible if the accounts are all single ""words"" comprised of uppercase letters and numbers.  It's a fairly tricky undertaking for a learner though - easier to do a binary search like that on a memory mapped file so you don't have to worry about data overlapping the edges of a fixed-sized buffer into which you're reading parts of the file.

for many small programs, it's perfectly fine and practical to do it the ""dumb"" way - load the data in to memory then operate on it there, just writing it out to avoid losing work if there's a crash, and before exiting if there's unwritten changes
for larger programs, you could move to a database

",1,22150525
22153118,"
The fastest method to search through a file is to read the entire file into memory and search memory.  
If the records in the file are of fixed size, you could use file positioning to mark where records start.  This could be used in an index table, such as std::map<key, file_position>.  You would search the container using the key, get the file position and read the record from the file position.  
If your record quantity is small, you may want to read the records into a std::vector.  Create index tables using std::map<key, vector_index> for each key you want to search with.  This is similar to how databases create search indices to speed up searches.  
Anything more complex than this, I suggest using a database.  
",0,22150525
22083216,"
You can apply standard algorithm std::find_if provided that the class has public accessor to data member fullName. For example
For example
",3,22082810
21977733,"
You could use lower_bound().
",2,21977703
21977782,"
You should use the lower_bound function.
",1,21977703
21977814,"
Why I used std::begin and std::end instead of the container one:

http://www.codeproject.com/Articles/570638/Ten-Cplusplus11-Features-Every-Cplusplus-Developer#beginend

",1,21977703
21977858,"
You can should method std::equal_range
For example
Or you can use std::lower_bound:
",1,21977703
21964270,"
The intention is a little confusing since you refer to '*' as a character wildcard, but you refer to regular expression matching (the actual regex character wildcard is '.').  I'll try to answer the question assuming intent is either to support full regular expression searching against a trie, or wildcard searches in a trie.
Regular Expression Matching in Trie
A trie is typically used to support fast O(m) operations.  It is not a generally efficient structure for processing regular expressions.
There are a couple algorithms for regular expression matching (DFA/NFA, and backtracking), and to support them within the trie search, you would effectively have to implement one modified to support iteration over sub-tries, and backtracking within the trie for the collection of states/matches the regular expression can match.  This would have lowest asymptotic complexity, potential to be most efficient.
However...
t nearly has the same asymptotic complexity to iterate over all strings in the trie, and test them against a regular expression match using std::regex and std::regex_match.  Additionally, it saves you from having to implement a regular expression engine, which is relatively complicated.
Wildcard Matching in Trie
Modifying your code to support wildcard searches, however, is very simple.  Instead of searching each level with the explicit character, you check the search character s[i] against the wildcard ('*', or '.'), and if it matches you can descend into any of the sub-tries, and increment i.  Although, there's the caveat that you will need to be able to escape whatever character you choose as the wildcard so it remains a valid character in the strings stored in the trie.
",0,21963190
21894598,"
when you return false from the right node, you well never even attempt the left node.
Try returning true instead;
",1,21894537
21894609,"
You should return the result of root->left->findValue(value); and root->right->findValue(value)
Currently you are calling the findValue function for those nodes, but not storing the value or returning it anywhere so the result is being lost.
",1,21894537
21875043,"
You can look for a 1 in the array, once it is found, record its location and skip through all the adjoining 1s. Once you hit a zero, you can continue doing the same thing over again (look for the next 1).
The edited code looks as follows. Also note some changes in the declaration. 
",1,21874856
21875032,"
You want to store indices, but you store array values instead.  Indices are integers, so your index vectors must be vector<int>, and instead of
you have to do 
",1,21874856
21875157,"
Most simple way :)
",0,21874856
21875184,"
You can consider following algorithm. It's in pseudo code - I'm not C++ fan, but rewrite it to any language should be trivial:
It loops thru the whole input and detects the edges of groups, storing them in result* arrays.
",0,21874856
21860847,"
I'm sorry to post a link only answer, but if you don't mind reading research paper, the definitive reference on string matching algorithms seems to me to be http://www-igm.univ-mlv.fr/~lecroq/string/ and the following research paper by Simone Faro and Thierry Lecroq where they compared the relative performance of no less that 85 different string matching algorithms. I'm pretty sure there is one fitting your need among them. 
",1,21845819
21845905,"
I would strongly suggest that you use CLucene (http://clucene.sourceforge.net/) which is a port from the Apache Lucene project. This will build you an inverted index and make text searching very fast. If changing languages is an option consider doing this in Java as the CLucene version is a bit out of date. It will be slower but has more features.
",0,21845819
21679762,"
You should probably just use std::find from <algorithm>, together with reverse iterators from the first index:
Note: If you want to ""project"" a reverse iterator to a (forward) iterator, use .base() on the reverse iterator.
See it Live On Coliru

Now, I don't really know what you needed the continue searching from the ""current"" position funcitonality for (I mean, find either returns the match, or rend(), so there would be nothing to continue for). However, otherwise, you could do stuff like (see it Live On Coliru as well :)
I made up fully silly examples of 'alternative' matching predicates. As you can see, it's all run-of-the-mill STL algorithm usage. This is possible due to algorithms being decoupled from containers by way of iterators.
Full Code
",1,21677550
21679819,"
Have you considered using upper_bound more or less like this?
",1,21677550
21659045,"
regex_search matches once (the first substring that match the regular expression). You need to loop.
Try following:
",3,21658860
21688442,"
If you are using a ""form component"", then I assume that you are using C++/CLI; which means you are using .NET.
In .NET there is RegEx classes and also normal string search functions. See:

.NET Framework Regular Expressions
String::IndexOf

If you want to use native C++, then you can use 
See also: 

<regex>

",1,21655443
21609228,"
You were almost there with your boost::multi_index attempt. The problem was that when you did the find using the ordered index, the iteration was also being ordered. Luckily the multi-index provides a project mechanism to switch between indexes. If I read the documentation correctly:
",6,21608112
21608331,"
I would use a multimap<Key,List<Item>::Iterator> paired with a List<Item>.  I would use the map for lookup and the List would hold the items in insertion order.  You will need to keep both containers up to date on all insertion/update/deletion scenarios.  If you could expound on your use case a better option may be available.   
This option would give you log(n) lookup while still allow constant time removal of the index and the item. This is similar to how I have implemented LRU caches in the past. 
Edit due to question
output
",1,21608112
21622935,"
Yeah, what Mark B offered is exactly correct. I just wanted to submit the right syntax for the benefit of possible future visitors.
I created a typedef:
and the syntax for finding the data according to id and changing index to insertion order:
",0,21608112
21557044,"
1)
You can use a TimePoint inside the map. Chrono has nanosecond resolution.
2)
You can use Tuples. But the way you did it is correct already, you only use two parameters so far (time_t, std::pair).
3)
See here, I would use a unordered map (EDIT: Looks like unordered maps cannot store time points (ideone.com/H6Yr7v). You have to use a map instead.)
EDIT: 
Since all my proposals use C++11, it is useless for Vecihi. But maybe someone else with C++11 capabilites has the same question, so I will not delete my answer.
",1,21556482
21557935,"
You can use boost steady_clock (which actually is using a PerformanceCounter on windoes)
The system_clock has a resolution of 100 nanoseconds (windows).
Utilizing timestamps and with the assumption the timestamps are added chronological to the container you could implement a hybrid solution: A sequential container holding the entries and a mapped view to ranges in that sequence:
Notes: 

The code requires boost or C++11 (C++11 if USE_BOOST is zero)
If the code is compiled with g++ below g++ 4.8.1 (I have g++ 4.7.2) and without boost the resolution of the steady_clock is microseconds, only. Boost seems to support nanoseconds, though

With this approach you keep the data sorted and have a reasonable performance to lookup a time-key. 
",1,21556482
21546487,"
What about
since he said that ""it must to be an integer""?
",3,21546269
21546343,"
You have two problems: The first is that std::string::find doesn't return a character, it returns a position. The second problem is that your inner loop will loop out of bounds for the string.
Also note that in the ASCII alphabet, there are special characters between the upper- and lower-case letters.
",0,21546269
21546869,"
If the id must be an integer it is better to verify that input is integer (as opposed to verifying that input has a letter). You never know what symbol may be typed. There are many symbols besides letters.
If id does not have many digits and can be placed to the integer data type you may want to do like this
",0,21546269
21548026,"
i would use regular expressions for that kind of check. It works just like that:
Hope that helps :)
Edit: If you want to modify your program to check if the id has a specific length you can use the following regular expressions:
This accepts 4 digits ids only.
If you want to check for a 4 to 8 digit id you use this regular expression:
",0,21546269
21538383,"
Try the following recursive function
As for your realization then it is wrong at least due to the first statements
Here find is called in vain. Its result is not used.
",0,21537631
21393647,"
Your interpretation is correct - the main disadvantage or using adjacency matrices is that, for most applications, you have to loop over the entire row, even when dealing with a sparse graph, in order to visit all adjacent nodes.
If you do not have a particular reason for using an adjacency matrix, then considering an adjacency list instead might be a good option.
It should be noted that nothing stops you from maintaining both data structures concurrently; even though I haven't seen many cases in which that was useful, you could certainly maintain the adjacency matrix for O(1) queries on whether an edge exists or not, and the adjacency list for linear queries over all the edges leaving a given node (linear on the number of those edges).
Depending on what information you need exactly, maintaining just the degree of each node (the number of edges incident to the node) might also help - this data ""comes for free"" if you implement an adjacency list, but you might find that you only need the degree after all.
",1,21393470
21384110,"
Since there is no ordering to the matirx, It is immpossible to confirm existence or non-existence of the index without explicitly checking every index at least once. 
By that logic, I am pretty sure this problem should have a lower bound of O(n^2)
",0,21383024
21258824,"
Inside a vector, using std::find, you'll need operator==
(which should logically be accompanied by operator!=; it's
very bad practice to provide just one, even if the standard
library doesn't require it).  Or you could use std::find_if,
and explicitly provide the comparison.  
If you want to sort the vector, and use std::lower_bounds on
it, or put the objects in std::set (or use them as a key to
std::map), you'll need operator< (which should imply the
operators <=, > and >= as well, to be coherent).  Again,
you can provide an explicit comparison instead.  !(a < b) &&
!(b < a) implies equality here, so if you're implementing all
six operators, you'll probably what that to also imply a == b.
For std::unordered_set (or as a key in unordered_map, you'll
need a hash function as well, which must be consistent with
operator==; i.e. if a == b, then hash(a) == hash(b); the
reverse obviously can't hold, but there should be a high
likelyhood that it does for any two arbitrary a and b.
For example, in your case, to match by name and surname, you
might define:
or if you want to keep the data sorted:
and for unordered containers:
(If you're using operator==, you will probably want to define
a specific instantiation of std::hash, so that the compiler
will pick it up by default; this is one of the rare times you
can, and indeed almost have to add something to namespace
std.)
Depending on the semantics of the class, it might make sense to
provide a set of these.
",1,21258627
21258735,"
If you're using std::vector, the best approach is probably to use std::find_if(). That will let you define a custom predicate which will be applied to each element, searching for whatever you need. The predicate can be any callable type; if you're using C++11 then a lambda is ideal.
Here's an example of using an inline lambda (I'm assuming the Name class is as you've described in your question):
You can also use stored lambdas or pre-defined functions/functors as the predicate.
",2,21258627
21213899,"
After finding the specific id and writing the new first name and last name, you need to skip the following two lines. This code works:
",0,21212678
21181358,"
I would do what @stefaanv said:
Edit: the above solution works if the information on each line is independent of the information on the other lines.  In your update, the information on the name lines is dependent on the information on the id lines.  So, to extend the above technique, you'll need to maintain state in the while loop that indicates when you've reached the end of one data block.
A slightly more elegant approach would be to store each data block in a struct, which allows you to use overloaded operators << & >>.  This makes the code for file reading & writing more clear - it's practically the same as the code for the ""data on each line is independent"" situation. 
",5,21180412
21182038,"
This should work. I used string::find to find the desired substring within each line, and string::replace to replace it if something has been found. 
Edit: I forgot about the case where the word occurs multiple times per line. Added a while to fix this.
",4,21180412
21173686,"
The reason I believe you have problems passing the root node pointer from the main to the insert function is because the root pointer is a private member of your Albero class. A private member of a class can only be accessed by other members within the (Albero) class.
link for more info : http://www.tutorialspoint.com/cplusplus/cpp_data_encapsulation.htm 
What you can simply do to fix the problem is to create another function that will call your insert function. 
Now you can just make multiple calls to insertStart()
",1,21170319
21001129,"
You don't need to put the pattern you're looking for into a container. A C string is enough.
Anyway, after this, it will contain an iterator into the vector v where that pattern begins (or v.end() if the pattern is not found). 
You can convert that into an index with std::distance(v.begin(), it) or just it - v.begin()
",6,20998972
20999016,"
You can use std::search to search for the first occurrence of the character sequence of interest. You would have to place that sequence in an array or container.
",5,20998972
20977670,"
You might have the option to use std::equal_range, std::lower_bound, or std::upper_bound. They are the built-in C++ binary searching functions.
",0,20975219
20924736,"
If you're talking about binary search then obvious the vector's pre-sorted, which means you want to find the first element above x-gamma, then if you actually want to use the values it's fastest to increment further while they're in range.  Check out lower_bound: http://en.cppreference.com/w/cpp/algorithm/lower_bound
If you just want to find the first and last, an alternative is to use upper_bound to binary search to its position, but that's likely slower than incrementing if there are a lot of elements and only a few match.
",1,20924682
20924744,"
Find the std::lower_bound, then the std::upper_bound, and you'll have your range.
From an iterator, you can obtain an index using std::distance (though stick with the iterator if you can!).
This assumes your data is sorted, but since you talk about binary searches that seems like a sensible assumption.
If it's not then you're going to have to examine every element anyway, in which case any approach is basically as good as another.
",2,20924682
20924760,"
In C++11:
Historically, you'd have to write your own predicate, and it would probably be simpler to use a regular for loop.
(Although, regarding your last sentence, if the vector is or can be sorted, then you can do a binary search with lower_bound and upper_bound as described in other answers).
",1,20924682
20868049,"
I'm afraid your code is invalid - the search algorithm requires forward iterators, but istreambuf_iterator is only an input iterator.
Conceptually that makes sense - the algorithm needs to backtrack on a partial match, but the stream may not support backtracking.
The actual behaviour is undefined - so the implementation is allowed to be helpful and make it seem to work, but doesn't have to.
I think you either need to copy the input, or use a smarter search algorithm (single-pass is possible) or a smarter iterator.
(In an ideal world at least one of the compilers would have warned you about this.)
",3,20864512
20864966,"
Generally, with Microsoft's compiler, if your program compiles and links a main() function rather than a wmain() function, everything defaults to char. It would be wchar_t or WCHAR if you have a wmain().  If you have tmain() instead, then you are at the mercy of your compiler/make settings and it's the UNICODE macro that determines which flavor your program uses.  But I doubt that char_t/wchar_t mismatch is actually the issue here because I think you would have got an warning or error if all four of the search parameters didn't use the same the same character width.
This is a bit of a guess, but try this:
",1,20864512
20600610,"
It doesn't sound like your solution will run in O(log n) for search2.  For example, if k1_1 is the lowest value and k1_2 is the largest, then your solution would require searching the whole tree for an entry with k2>=100.
Off the top of my head, what I would do is create two separate trees, one which contains entries with k2<100 and the other with k2>=100.  Search would require searching both trees, but is still O(log n) because this is just a constant factor.  You could then implement search2 in O(log n) by just searching the second tree.
",0,20600469
20557620,"
Your retrieval code looks fine, so I would check your tree building code.
Also, I wouldn't mix printf and cout.
and
will do just fine.
Other suggestions:
can be safely shortened to:
since you're not trying to store the pointer returned by c_str.  You will have to change your methods to take const char *key instead of char key[], however.
EDIT:  It appears your retrieval code and tree builder code have opposite senses for how left and right should work.  Tree builder:
This will recurse left if the node is less than the newPtr.  This is opposite of what the tree recursion does:
You need to flip one to match the other.  My preference would be to flip the builder, so that the left pointer is less than the parent, and the parent is less than the right node.
",1,20557062
20533204,"
You need some for-loops to populate your data array.  Something like this:
Note that if your data file has headers on it as your example does above, you'll need to read and discard those before this loop.  Something like string temp; std::getline(cin, temp); would do.
In the loops that compute items, taxes and money, you have row and column switched, I think.  If your first index is empl, which goes 0..4, then you ought to switch these like so:
I believe you need to make the same switch in the big loop that follows these as well.  
And finally, in these statements, you need to use ==, not = to compare values:
I haven't vetted the logic of your code to great detail, but if you fix these items, you'll be in better shape and can get to the next steps.
",0,20532331
20281744,"
If I understood, you have a struct A and an object list of A, so:
For the sorting of your list there are a lot of methods; for instance you can see here.
",0,20281362
20162348,"
You are ending the execution of the function by returning a value in both cases of the if statement. Returning a value will end the execution of the function, so you always end after reading the first line. My guess is you want to move the return 2; to the very end of your function.
Note that this way you also always return without ever calling myfile.close() which might cause problems elsewhere. While I don't understand the meaning of your return values 1 and 2, I suggest this:
",2,20162313
20150887,"
Try using
and see if it works or not
",4,20150754
20129914,"
Here's some pseudo-code for a method that checks for whether or not an element is in the stack:
It's critical that the source stack is passed by value, so that it isn't modified.  Also, realize that this solution probably isn't as efficient as using a different container than stack and simply calling a method which checks for a value.
",2,20129746
20089017,"
",0,20088263
20040961,"
Probably best to create a new map of ""artist -> song*"" and keep both maps up-to-date as you add/remove items.
",0,20040797
20034060,"
I think I can see why this is slow.
In your helper, you're visiting the neighbors like so:
but you're never using past results. You mark something as visited, but never check whether it is already visited.
",1,20033969
20002965,"
Couldn't you use a custom object for your link to another room? Eg:
This would keep cost and cell coupled with no worries. Only drawback is that you will store each cost twice (assuming it's symmetric) but this is true in many other approaches (matrix included).
",2,20002882
19966461,"
In your eclipse.ini file try to increase maximum Java heap space. That'll prevent out of memory errors.
",1,19966391
19842496,"
Sounds like you have some race condition. It's not clear exactly how you do it.
The usual way is to have the preparation singlethreaded, freeze the structure (pass it as const everywhere) and then all queries can run in parallel with no coordination because the structure is immutable.
Another way is to to a KD-tree or a Quad tree. You'll likely run int the same race issues you're seeing now. 
But in case you want to try it out, use random points, or if you can afford pick the optimal points for the splits (but shouldn't matter a lot in practice).
You'll have something along the lines of O(logNP + R) where R is the number of points in the result.
http://en.wikipedia.org/wiki/Kd_tree
http://en.wikipedia.org/wiki/Quadtree
",2,19840357
19842221,"
Sort the points according to x axis and y axis separately.
Get the subset of x and y that match the limits in the corresponding axis.
Pick the one that has fewer elements in the range. For all the elements in the range, pick the the ones that fall within limits of the other axis.
Preparation time nlogn.
Search time: Worst case n, but in practice much less than that.
Additionally you can make search time (logn)^2 or logn depending on how much memory you can have. 
If you have O(n^2) memory, you can sort the numbers in every range of x values according to y values. When you are doing the search, you have to find the range on x first and do a search on the sorted list corresponding to that range.
Alternatively, you can sort non overlapping ranges of lengths 2, 4, 8.. etc on the x-axis sorted list. When you get a x range, you have to search within the mini-sorted ranges (there are, worst case, logn ranges) that together make up the range (each search takes at most logn time). Effectively search time is (logn)^2.
",1,19840357
19854995,"
As @Sorin suggested, you better use geometric trees like KD-tree or R-tree. After your structure is prepared it remains constant and you can query it in parallel from different threads (of course, I assume, the structure is implemented in such a way it does not change its state during the query).
Many libraries provide such data, e.g. Boost.Geometry has rtree and OpenCV has KDtree, see details in https://stackoverflow.com/questions/1402014/kdtree-implementation-c.
As for data preparation, the typical approach is recursive and fits well with tree construction: split your data into two halves (say, those with X coord above some pivot and those below), build a tree for each part recursively, merge). 
The recursive calls can be assigned to separate threads. In fact,  fits perfectly with tbb::parallel_reduce and similar parallel patterns. When answering the question, I found some papers which follows this plan word-to-word. 
",0,19840357
19812117,"
You could std::sort() the containers an then use std::set_intersection() (I'm not entirely sure about the name of this algorithm). The complexity would be O(n ln n + m ln m) rather than O(n * m) with n and m being the size of the sequences.
",4,19811972
19812903,"
As you can see from the different answers, there are multiple approaches. Any of those can be correct depending on what your containers are and on if the ranges are sorted and of the typical size of the ranges and if sorting the ranges is an option. 

If both containers are sorted, std::set_intersection is the best way to go, it's complexity is O(n+m)
Sorting a container of size n has complexity O(n log(n)) in terms of comparisons and swaps. Sorting a list means swapping list nodes, which is cheap. Sorting a vector means actually swapping the elements, and the cost depends on the element type.
With one sorted and one unsorted container it is best to do a std::binary_search for each element of the unsorted range in the sorted range. The complexity of that would be O(n log(m)) with n being the size of the unsorted, m of the sorted range. Sorting the unsorted range first and using set_intersection afterwards would have a complexity of O(n log(n) + m) which is worse.
Having two unsorted containers, it pays out to have one of them sorted and then apply binary_search for the elements of the other one, giving a complexity of O((m+n) log(m)), so if both containers have the same type, sorting the smaller container is better.

",4,19811972
19812180,"
If you have two lists A (size n) and B (size m), then finding every element in B that exists in A is O(nm) using a nested loop.
I'd suggest using a hash set. If you build a hash set with the elements in B, you'll spend O(m) building the set and then O(n) looking up every element of A in hash_set(B). So complexity would be O(n+m)
",3,19811972
19812173,"
Maybe you can sort A and B in array firstly. Then count the same elements. It's O(n*log(n)),but need more space.
",0,19811972
19812233,"
If you're looking to optimize the solution, you should share some more information about the problem domain. For example, if you knew that all the items in the lists were integers between 1 and 100, you could have used a simple Booleans array[100], and finish the task by running once on A (raising the appropriate flags) and then once on B (testing the flags).
If the lists have arbitrary contents, you have to settle for a generic solution. The naive solution would be to have a double loop like you suggested, which is not necessarily that bad. You can make several practical optimizations:

The outer loop should be done on the shorter list (provided you know their length). This means that your inner loop can break as soon as you find your item (if you find it...).
If memory is not an issue, you can sort both lists, and then progress over both of them in parallel, moving forward on one list as long as the other list's item are bigger (like you do a sorted merge between them). This has an order of magnitude of O(NlogN+MlogM+max(N,M)), which is probably better than O(N*M), but also wasteful in terms of memory. 

",0,19811972
19612420,"
This loop (and the others)
finishes when j=8 evaluates to true. Which is always.
Did you mean:
",4,19612407
19612421,"
Your for loops are all wrong, e.g. you need to change:
to
and similarly for the others.
",2,19612407
19613939,"
Fixed your code:

for loops
yOrn , answer were not used, hence removed
removed ';' after #include 

here it is: 
I compiled and ran it - works perfectly ( at least I assume that is what you wanted to do).
",0,19612407
19575989,"
I am assuming that if you type in n characters, you want to only match candy elements that begin with those n characters, and not attempt to do any autocorrection or spell-checking or the like.  If these are correct assumptions, then let the STL do the work for you:
For example, if you have a candy named ""snickers"" and ""snack mix"", then if you enter ""sn"", it will return both of these, but if you enter ""sni"", you will only get ""snickers"".
",1,19575697
19575926,"
first, you need a threshold for how close the match has to be.  is 1 letter ok?
second, decide if it must match from the beginning, or beginning of a word  eg does do work for ""odor""?
Then if you don't want to use another library, loop through each char and continue until you reach the threshold or the end of the string
In other words, if the name is ""Long dude one""  and the search string is ""dude"", then start at name[0] and do a 4-iteration loop (four letters in dude) and check each one with the corresponding one from name.  If any letter does not match, exit that loop.   Then do the same thing starting from name[1] to name[4],  then from name[2] to name[5]  etc all the way until you are checking the last 4 letters of the search string "" one"" against dude.   However, you wouldn't get that far because on the 6th attempt, eg looping through name[5] to name[8] all 4 letters would match so you would  set match=true and exit.  
put that in a function and call it for each name.
",0,19575697
19576018,"
Assuming these types are of std::string:
If you wanted to do it case-insensitive, just convert both strings to either all upper or all lower case and then do the search on the modified strings.
",0,19575697
19576617,"
You can use member function compare the following way
",0,19575697
19556406,"
What you are doing is just printing the array backwards, isn't it? You can read up the binary search algorithm in http://en.wikipedia.org/wiki/Binary_search_algorithm. I don't see any reason why you say that it ""must"" be a recursive function. I would prefer a non-recursive function of a binary search, even though in the wikipedia link it also has the recursive approach.
",0,19556345
19556474,"
Binary search only works if your dataset is sorted; otherwise less-than and greater-than comparisons are completely useless because they don't tell you anything about where any other element is. So first you need to ensure that your dataset is sorted - that's a separate problem.
Once you have a sorted dataset, you're trying to come up with a function that follows this general form (pseudocode, not actual C++):
Make sure you deal with any edge cases that pop up. In particular, think about what happens if the needle is nowhere to be found in the haystack; can you add something that deals with this case?
",0,19556345
19501496,"
Look at the very last character on this line:
You have a misplaced ; there. Remove it and test again.
",7,19501413
19469801,"
Try this ...
Also try to debug and find if a key value is less than/ greater than the leaf node value then does this mean that it is the same for the substring as well. If not then you have to search both left and right sub trees. IF left sub tree returns false then search in right sub tree. Code below ...
",1,19469497
19409376,"
If the key was found key == temp->key will be true and temp != NULL will be false, so:
OR:
",1,19409310
19409425,"
Try this code:
EDIT 
You should use the list from stl and the find algorithm, if you aren't required to write your own container; They are tested and safe:
http://en.cppreference.com/w/cpp/container/list
http://en.cppreference.com/w/cpp/algorithm/find
",1,19409310
19409379,"
You don't need an if. Just return temp. If the correct key is present in the list, temp would be pointing to it, otherwise it's NULL.
",0,19409310
19409389,"
This will work for you
",0,19409310
19409401,"
You could do this:
But much simpler is just
since if temp is null, you want to return null anyway.
",0,19409310
19399401,"
Use a std::map<std::string, YourObjectType>. You can still iterate all objects. But they are sorted by the string now.
If you might have multiple objects with the same string, use a multimap instead.
",2,19399285
19402823,"
If you can't switch to any different structure/container, then there is no way to do this better than linear to size of list.
",0,19399285
19399444,"
Having 3000 you would like to use a unordered map instead of a linked list, which will give you average O(1) lookup, insertion, and deletion time.
",0,19399285
26215485,"
Constant time lookup with unordered_set.
There are also options of bitsets etc. Depends exactly how large is ""very large"" and the sparseness of the values stored compared to how many of them there actually are.
",0,26215420
26215942,"
seems unordered_set is suitable for your requirement.
PS: Pls remember all elements in this set are immutable
",0,26215420
26220745,"
The known best way to check if an element (number) is a member of a set (array) is to use bloom filters. It works well if set is changing over time or if there are set operations among sets. Bloom filters are easy to implement and good implementations are availble
If set is static (i.e. never change) the good way is to use perfect hash function. It will take time to build, but will outperform usual hash function provided by std::unordered_set
",0,26215420
26170755,"
Well, it's O(N). Search is always O(N) in a std::list, sorted or not.
Sorted collections help because you can know if you're too far, or not enough. But since you can't start anywhere but at one end of a list, it won't help.
",3,26170743
26170778,"
It depends how you search. Given std::list<T> x and a value v that is not in the list,

std::find(x.begin(), x.end(), value) is a linear search, so it will take x.size() comparisons and iteration steps, and
std::binary_search(x.begin(), x.end()) performs binary search with O(log(x.size())) comparisons, but it will still have to increment iterators linearly to address the target of each comparison (and same for std::lower_bound etc.). The behaviour is undefined for this invocation if the list is not in sorted order.

Generally, iterator incrementing has a non-trivial cost for node-based containers, since it involves pointer chasing and is non-local in memory. However, you need to consider the cost of your value type's comparison operation (which could be high, e.g. for very long, almost equal strings). Moreover, you may be able to address memory locality by allocating nodes from a dedicated arena.
",1,26170743
25919669,"
Change this:
to this:
When looking for 1, in the third pass searchEnd will be 3 and searchStart will be 0, so index will be 1. Since your value is on position 0, it will modify searchEnd to equal 0 in the first pass.
",0,25919489
25919621,"

42 won't be found on the first pass as it is in index 10, but you have searchEnd=19 and searchStart=0, so the first index is 9.
I think the real problem in that you bail out if index == searchStart or index == searchEnd without checking that searchKey == data[index] first.

",0,25919489
25836577,"
Combining those two answers and depending on the mat type (here CV_64F) you get:
(see find docs for more information). Of course first converting mat row to a vector and then using std::find on that vector is slower than using find directly on pointer to a row array. 
EDIT: After some more research, it is not quite hard to develop a generic version:
I tested it on more complex data types:
And what surprised me the output is:
The problem is with the cv::Scalar size structure. No matter of the version of the constructor we're using (ie oone, two, three or four arguments) the size is... constant. This is no so surprising cause this is still  the same structure, on my machine the size is 32 bytes (by default cv::Scalar is type of double so on my machine double is 8 bytes and 4 * 8 = 32). So the find goes strictly wrong, cause it assumes size of the element in the array as 32 bytes and it should be 3 bytes.
So don't use std::find with cv::Scalar! However it works with the primitive data types remarkable well and efficient. 
EDIT2 (after berak's comment): 
Yes, you can use cv::Vec3b with find and it seems working well although it have not done more testing than simply correct test:
(still you have to use Scalar in the Mat constructor, but it does not matter and the Mat is properly initialized). Now the output is as expected:
",4,25835587
25834554,"
Given that your phrase can only occur once per line and the number follows the phrase after a number of spaces you can read the file line by line and use std::string::find() to see of your phrase is somewhere in the line. That will return the position of the phrase. You can then work on checking the rest of the line immediately after the phrase to test the number for 1 or 0.
This code may not be exactly what you want (still not certain of the exact specs) but hopefully it should contain enough examples of what you can do to achieve your goal.
Hope this helps.
",2,25833927
25726821,"
You need to change the comparer functor of the find_if.
And use the find_if version like this:
The comparer functor of the find_if receive as parameter in the operator() an element of the container to find in. In this case twoD[0].begin() and twoD[0].end() give you access to the elements of the inner vector and the parameters receive is the type of the element storage in the inner vector node.
",2,25726530
25617522,"
The map should contain each key value only once.  This is why it can provide operator [] to uniquely address a perticular key.  
If you have several values for the same key, you should use multimaps instead. With multimaps, you'd have to use find() to access to the values.   
You can experiment with this small and very basic example:  
Both maps and multimaps are generally implemented as a binary search tree. So it'll be efficient for search. 
",0,25616638
25475596,"
Container list is not adopted for ordering storing of elements and for their direct access. Though standard class std::list has member functions sort nevertheless the search using bidirectional iterators (std::listhas bidirectional iterators) instead of random access iterators is not very effective..
It would be better if you would use some associative container as for example std::map or std::set (if you need unique elements) or std::multimap or std::multiset (if elements can be duplucated).
if the order of elements is not important then you could use some standard unordered container as std::unordered_map or std::unordered_set
",0,25475391
25475447,"
There is std::lower_bound() which finds a suitable position in any bidirectional sequence using O(log n) comparisons. Since linked lists don't support random access traversal is O(n). You can use std::binary_search() if you are only interested whether there is a suitable object but this algorithm isn't useful if you are interested in locating the object. Of course, a precondition for std::lower_bound() and std::binary_search() is that the sequence is sorted.
",3,25475391
25475411,"
I believe you are looking for the C++ <algorithm> library. It includes a function called binary_search.
An example of it is provided on the page and echoed here:
",2,25475391
25475437,"
If you are writing real C++ code you can use the algorithm standard library.
In it there is the find function which grant to you to look for a specific element defined between a range of element specified as a parameter.
You can find a real example in the same page.
",1,25475391
25247452,"
The interpolation search appears to be a good idea here. It usually has a small benefit, but in this case even a small number of iterations saved helps a lot since they're s slow (disk I/O).
However, real databases duplicate the actual key values in their indices. The space overhead for that is fully justified in the performance improvement. Btrees are a further improvement because they pack multiple related nodes in a single contiguous block of memory, further reducing disk seeks.
This is probably the correct solution for you as well. You should duplicate the keys to avoid disk I/O. You can probably get away by duplicating the keys in a separate structure and keeping that that fully in memory, if you can't alter the existing header.
A compromise is possible, where you just cache the top (2^N)-1 keys for the first N levels of binary search. That means you have to give up your interpolation for that part of the search, but as noted before interpolation is not a huge win anyway. The disk seeks saved will easily pay off. Even caching just the median key (N=1) will already save you one disk seek per lookup. And you can still use interpolation once you've run out of the cache.
In comparison, any attempt to fiddle with memory mapping parameters will give you a few percent speed improvement at best. ""On par with B-trees"" is not going to happen. If your algorithm needs those physical seeks, you lose. No magical pixie dust will fix a bad algorithm or a bad datastructure.
",6,25247069
25157414,"
Using your code, something like:
",2,25157241
25157437,"
First you need a variable to store the count, then you also need a variable to determine if you are counting currently:
",0,25157241
25131425,"
smatch object contains iterators into the string you searched with the regular expression. Said string is a temporary in your example, and is dead by the time you are trying to inspect the matches. All those iterators are dangling.
Make it
",4,25131334
25028901,"
I would advise keeping the original implementation of GetMyClass. I would add HasMyClass as a convenience function for those cases where that's the only information needed to fork.
You can implement HasMyClass by using GetMyClass. It's a trivial implementation.
If a function uses,
There will be two searches. This is a bad use of the functions but you can't stop them.
A better use of HasMyClass is:
",0,25028790
25028904,"

and is very sure there must be one

Gives already the answer: If you can not be sure, you can not handle the return value without checking.
But this kind of programming looks like an old posix interface where every retval must be checked. In c++ you have a lot more functionality from the stl without writing such code self. I would advice you to have a look in <algorithm>. Think about functor pattern, where you directly give the action to the search function. Take a look at for_each and others.
http://www.cplusplus.com/reference/algorithm/for_each/
http://www.cplusplus.com/reference/algorithm/copy_if/
Or simply all:
http://www.cplusplus.com/reference/algorithm/
I believe you can do a lot with stl functionality. Writing own search functions, accessing them, checking retvals and do something with the value/iterator must normally not be done by hand crafted code.
The second attempt could be throwing of exceptions like throw NotFound_t();
",0,25028790
25029051,"
Checking returned value for potential failure is common API design, so the programmers are supposed to be familiar with it and can use it with ease. If they forget to check it, they will know when they dereference it.
You can throw exception when none is found, but finding nothing in a container is usually not an exceptional thing, and it had better not throw.
By the way, your code is also dangerous, because the iterator ""temp"" could be invalid after your previous find. It could result from item being removed from the vector. Function with unclear side effects is very bad.
In sum, make your API familiar to people. Don't complicate the code just to make it look cute, like allowing people to not checking the return value for potential failure.
Edit
If your data could be nullptr, you can just define a data class to return, in which it could indicate failure state. If you are lazy, you could use std::pair to do this.
",0,25028790
25029027,"
A usual implementation is to change the interface to pass the pointer as a parameter and to return whether or not the object was found :
Usage example :
",0,25028790
25032426,"
To be honest, what these functions show is that you're just not achieving anything by wrapping STL methods. Those already have a well-established pattern to communicate ""not found"", and C++ programmers are already familiar with that. Your method is confusing even to you.
Instead, what you should do is provide decent predicates for use in std::find. 
",0,25028790
24992085,"
Since, indeed, there could be a need for backtracking, your options for streaming are limited or non-existent.
Boost Spirit ""solves"" the same issue by using the multi_pass_iterator<> adapter around input iterators. The adapter is able to maintain a buffer of previously read data for backtracking, freeing it as soon as it is no longer required (e.g. due to an expectation point).
If you shared some details about ""some cool regex"" then I could probably show you how to do this.
UPDATE Just found this library: https://github.com/openresty/sregex

libsregex - A non-backtracking regex engine library for large data streams

",1,24991808
26978943,"
If you're doing search for a different item in each thread, then rather than worrying for bank conflicts, you need to worry about thread divergence, as binary search requires branching. Some of that can be mitigated using the select function.
You could be better off using other algorithms, such as interpolation search, which can find the item in fewer hops (essentially the decision where to look next is more expensive than in binary search, but if your search data is in the global memory, you can hide a lot of processing (about 20 instructions) under the memory latency).
I was solving a similar problem recently: Binary search with hint.
A simplified algorithm looks like this:
This is using select() twice rather than branching. You can compare the performance by changing the #if 0 to #if 1. Note that e? a : b does imply a branch so using that does not help.
",1,24989455
24991459,"
If the pre-calculated list of ints is not changing (read-only data) and threads are not modifying it than it is perfectly fine to search with Binary Search without synchronization. Threads may become slow because of synchronization problems. Hash can be sometimes faster than the Binary Search but it is more useful for larger arrays. Try first with binary search.
Also you can see:
Is it wise to access read-only data from multiple threads simultaneously? 
",1,24989455
24994152,"
It sounds like you are doing the binary search in each kernel as part of other work. It's better to find the result of the search first and pass the result to the kernel as parameter. 
In general binary search is a logn algorithm and shouldn't be very slow unless you look for the value in really really large list. Still it's a waste of resources if you do the same search in each kernel. And if you want to parallelize the search itself it's still inefficient because you'd only have 2 cores executing kernels at each level/iteration of the algorithm. Add to this any other main program -> opencl overheads. It would be better to go with a linear search, splitting the whitelist on as many parts as the number of kernels. It might take longer to find the value in a single part of the list than a binary search but you'd have less overhead from passing values between the main program and the kernels.
",0,24989455
24418280,"
You are missing paranthesis around
It must be
And you might also want to return
",2,24418079
24095988,"
You might interpret the larger image as a string of bytes for applying a string-search algorithm like the 'Boyer–Moore string search algorithm' (http://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm) to find the first line of the smaller image. After finding that line, you match the following lines. 
However, if the smaller image is not found (not aligned to a byte boundary in the larger image), you have to repeat the search using a shifted smaller image (temporary ignoring the first and last byte), until you find a match or no further shift is plausible.
",2,24095738
23970773,"
Use lower_bound and decrement the returned iterator by one.
",5,23970751
23970882,"
You can use method lower_bound. For example
",3,23970751
23970810,"
Look into std::map::lower_bound(). Note that it will return an exact match if there is one. std::set has this as well.
",2,23970751
23789996,"
It sounds like linear scanning might be required, but you shouldn't really be losing your message positioning if the sending side of the connection is making its send()/write() calls in a sensible manner, you are reading in your buffers properly, and there isn't an indeterminate amount of ""dead"" space in the stream between messages.
If the protocol itself is sensible (there is at least a length field!), you should never lose track of message boundaries. Just read the marker/length pair, then read length payload bytes, and the next message should start immediately after this, so a linear scan shouldn't have to go anywhere ideally.
Also, don't bother copying explicitly, just cast:
",0,23789644
23773745,"
There are two problems here: how to split a file into tokens, and how to search for an element of a set, the standard library provides solutions for both.
If you need to know which words match, you can either use std::sets, or sort the vectors, and then use std::set_intersection to create a new range
",1,23773439
23659074,"
std::vector::at does not return an iterator, which is what you need for upper_bound. You can obtain an iterator to the required position and pass it like this:
or
",4,23659047
23555499,"
Try changing your function searchBoard to
",2,23555450
23555466,"
You should not declare a local, uninitialized board in searchBoard() which masked the global board.
",2,23555450
23437714,"
You're not returning anything here:
it should be:
You have the same error with right->search(target).
",8,23437673
23437721,"
When you call search() recursively, you're never returning the value. Therefore most of your results are simply being thrown away, and often your function will return an undefined value when it simply ""falls off the end.""
",2,23437673
23437728,"
You are missing return statements in your search function:    
Turning on/listening to compiler warnings would catch this sort of thing.
",2,23437673
23416091,"
basic_string::find finds a substring, per its documentation.
In this case you want an exact match; use basic_string::compare or == instead (the latter uses compare internally).
",1,23415963
23361062,"
Here is an example of how you would search for strings within strings
This should help you figure out exactly what you need to do
Notice how parameter pos is used to search for a second instance of the same search string. Output:
",0,23360904
23361045,"
How about:
or shorter:
",0,23360904
23339420,"
If I understand correctly, you are asking for ""variable variables"", like PHP's ""$$x"" syntax.  This isn't available in C++ because it needs to know what variable you are referring to at compile time, not run time.  
Your only alternatives are to use normal conditional statements (if, switch), or to store the data in a map (a.k.a. dictionary, associative array) instead of a fixed data structure.
",3,23339163
23281123,"
There is (likely [1]) no way you search a million URLS in a plain text-file in ""a few milliseconds"". You need to either load the entire file into memory (and when you do, you may just as well do that into some reasonable data structure, for example a std::map or std::unordered_map), or use some sort of indexing for the file - e.g have a smaller file with just the checksum and the place in the file that they are stored at. 
The problem with a plain textfile is that there is no way to know where anything is. One line can be 10 bytes, another 10000 bytes. This means that you literally have to read every byte up to the point you are interested in. 
Of course, the other option is to use a database library, SQLite etc (or proper a database server, such as MySQL) that allows the data to be stored/retrieved based on a ""query"". This hides all the index-generation and other such problems, and is already optimised both when it comes to search algorithms, as well as having clever caching and optimised code for reading/writing data to disk, etc. 
[1] If all the URLS are short, it's perhaps possible that the file is small enough to cache well, and code can be written to be fast enough to linearly scan through the entire file in a few milliseconds. But a file with, say, an average of 50 bytes for each URL will be 50MB. If each byte takes 10 clock cycles to process, we're already at 130ms to process the file, even if it's directly available in memory.
",1,23281015
23261998,"
Your main issue is you seem to want to step through the quote using i, but at the same time you are using it to index Words. A more logical way to do things is to check each word of the quote against the existing words you have already copied into Words, and either incrementing the count or inserting the word accordingly. You can also take advantage of the fact that there will be at most NumWords in Words and allocate enough memory at the start of the function:
In any case array / pointer shenanigans are hard to read and error-prone, there is hardly any code here (or your original code) that could be called ""c++"" aside from new, it's c with a dash of c++. The entire app can be more easily written in modern c++ like this:
And used like this: app < textfile.txt
",0,23260343
34957452,"
In C++11, you can use also std::any_of
",2,23174533
23174580,"
Your solution looks fine if you only want to know if there is an element satisfying your criteria present. I would use const references in the loop, because the loop should not change the elements of the vector:
If you want to use a standard library algorithm, you can try std::find_if:
Here, it is an iterator to the first element satisfying the condition, or equal to vec.end() if no element is found.
",9,23174533
23174763,"
In fact you can have your cake and eat it, if you are free to sort the vector of pairs based on the second field. 
In this case you end up reinventing what Boost calls flat_(multi_)map. The obvious benefit is that searching can be done in O(log(n)) instead of linear time.
See it Live On Coliru
Prints
",3,23174533
23174586,"
I think that you should use an std::map instead, which will provide a preffy efficient std::map::find member function:
This is as efficient as it goes for this kind of lookup (which is guaranteed to be O(log(N))).
",1,23174533
23137377,"
When the value is found the code must ensure that r is not incremented (see code below the if statement is used to check if value has been found). Also row is not assigned from r at the end of the search function. 
",0,23137174
23137258,"
You should pass the matrix by reference to input:
otherwise you are not populating the matrix.
I'd also recommend to transform this:
to:
And finally I'd suggest you to take a look at std::array and std::search.
",2,23137174
23137300,"
The simplest solution would be to not increment r if OK is true.
You could also replace the while loops with their for equivalents. 
That would prevent r being incremented if OK is true.
",0,23137174
23131873,"
My feeling is there is no optimized way to do such a broad search type, unfortunately. Your search space is large, and the number of searches is equally huge.
You're essentially looking for duplicates of every permutation of pos/length. Existing search algorithms are great for doing a single search within a big space, so at best they can help with a part of your algorithm. In other words, you are doing many many string searches, so you could try optimizing each single string search.
You could still try optimizing your existing algorithm. For example you might find that working with char* instead of string could help, because you can keep finer control over state. That would eliminate the need for substr which creates an unnecessary string object.
*Edit: mention how to incorporate existing string search algorithms.
",2,23130674
23132576,"
You might combine the search with Boyer-Moore-Search or keep track of common prefix sequences.
[1] Boyer-Moore
Note: The search might get improved by mapping results and performing a search if a prefix sequence exits (see code below).
[2] Common Prefix Sequences
A faster approach: Store the pointers with a common prefix sequence and match suffix characters following the prefix sequence:
Results
Both algorithms will produce the same result set, but the second will out perform the first by magnitudes.
",2,23130674
23132313,"
I agree with tenfour that there may not be an algorithm that will make you solve this problem a lot shorter. Below code is yours transformed to C, which, AFAICS with my crude measurement with linux' ""time"", is about 7 times faster than the C++ version:
Please note that the text in example is longer to be able to get some meaningful run times, a variable count is added to be able to print the number of matches and no clean up is done before exit. On my Ubuntu PC, C code takes ~2 seconds to complete, where C++ takes ~14 seconds.
",1,23130674
23132854,"
I fill a map of duplicates here and return max of them. I have added check for what has been already searched. This is very important as you don't want to search again for occurrences of ""a"" if you have already did it. For example:
My algorithm will count all duplicates of ""f"" on first hit of ""f""
and then skip it when it finds it again at index 4:
but it will evaluate then ""fc"" as this is not the same as ""fa"". Algorithm will search for ""fc"" only if ""f"" was found to be duplicated, as there is no chance for ""abc"" be duplicated if ""ab"" is not.
It will not count overlapped strings, i.e: ""altoal"" in ""paltoaltoalm"" won't be matched.
usage:
output:
3,5
4,1
5,1
5j,1
7,1
73,1
8,1
9,4
93,1
d,4
f,1
h,2
j,4
k,1
k9,1
m,2
",1,23130674
23132712,"
You can do something in order to speed up the algorithm by using binary search algorithms for insertion and retrival.
You can do it for instance by using a std::set or a std::map. 
You have either to store each substring into the set (if /*do something */ only needs the string) or to store the substring in a map as key. 
The complexity then would be ln(N) N^2. (Instead of being N^3) 
Consider this for instance: 
",1,23130674
23122874,"
I'm almost certain that it's not the most efficient way to go about it, but I found a way that works.
",0,23098396
23032053,"
This is laborous case work:

A < B and 0 and N-1 are joined by A -> trivial.
B < A and 0 and N-1 are joined by B -> trivial.
B < A and 0 and N-1 are joined by A ->
Do BFS on graph with only K edges.
A < B and 0 and N-1 are joined by B ->
You can check in O(N) time is there is a path with length 2*A (try every vertex in middle).
To check other path lengths following algorithm should do the trick:
Let X(d) be set of nodes reachable by using d shorter edges from 0. You can find X(d) using following algorithm: Take each vertex v with unknown distance and iterativelly check edges between v and vertices from X(d-1). If you found short edge, then v is in X(d) otherwise you stepped on long edge. Since there are at most K long edges you can step on them at most K times. So you should find distance of each vertex in at most O(N + K) time. 

",3,23089118
23031842,"
I propose a solution to a somewhat more general problem where you might have more than two types of edges and the edge weights are not bounded. For your scenario the idea is probably a bit overkill, but the implementation is quite simple, so it might be a good way to go about the problem.
You can use a segment tree to make Dijkstra more efficient. You will need the operations

set upper bound in a range as in, given U, L, R; for all x[i] with L <= i <= R, set x[i] = min(x[i], u)
find a global minimum

The upper bounds can be pushed down the tree lazily, so both can be implemented in O(log n)
When relaxing outgoing edges, look for the edges with cost B, sort them and update the ranges in between all at once.
The runtime should be O(n log n + m log m)  if you sort all the edges upfront (by outgoing vertex).
EDIT: Got accepted with this approach. The good thing about it is that it avoids any kind of special casing. It's still ~80 lines of code.
",2,23089118
23030895,"
In the case when A < B, I would go with kind of a BFS, where you would check where you can't reach instead of where you can. Here's the pseudocode:
This way you avoid iterating through the (many) cheap edges and only iterate through the relatively few expensive edges.
",1,23089118
23030616,"
As you have correctly noted, the problem comes when A > B and edge from 0 to n-1 has a cost of A.
In this case you can simply delete all edges in the graph that have a cost of A. This is because an optimal route shall only have edges with cost B.
Then you can perform a simple BFS since the costs of all edges are the same. It will give you optimal performance as pointed out by this link: Finding shortest path for equal weighted graph
Moreover, you can stop your BFS when the total cost exceeds A.
",0,23089118
23079112,"
I suggest NOT using the built in intrinsics and implicit vectors.  This only makes sense if you don't use the non GCC intrinsics (e.g. _mm_cmpeq_epi32) and only want to stick to GCC.  You can do what you want like this
You can probably find a more efficient version that avoids the packing but then you would have to use a different function than __builtin_ctz.
For 32-bit ints I suggest
",4,23077025
33048138,"
This is a complete solution for searching 64 bit values for a match.  In this case, the value (namehash) is a struct member.  This routine compares 8 64 bit values on each iteration and provides the matching struct index.  
IMPORTANT: The struct array length needs to be a multiple of 8, with at least 1 NULL trailing member
Alternatively, if only 2 64 bit comparisons are wanted per iteration, the above can be greatly simplified to:
",1,23077025
23078591,"
I can't find any instructions to convert 64-bit integer to a 32-bit integer, which is what you need to then use packssdw, etc. It gets quite long and messy, but should work:
So, I think the solution is to use a bitmask (bits 0, 1, 2, 3:
These go before the loop:
Inside loop:
Then we need to shuffle the high part to the low part of a new variable:
Now the low 64 bits [well, the low 4 bits, the rest are zero] of res is a bitmask of which one of the values that matches. 
(Now you can count trailing zeros like before).    
",0,23077025
23062037,"
This uses std::basic_string::find (ref) directly to find the starting position of the substring.
",3,23061887
23062053,"
The search function searches the first string a for any occurence of the elements of the second string b. As Your second string contains the elements a, b and c the code would return an iterator to the first position, then to the second, the third one,...
What You what to use is the find function. It returns an iterator to the element that equals the one that You were searching for. In Your case You're search the string a for the element abc. So You would have to call 
",1,23061887
23046590,"
The associative STL containers (map and unordered_map) are built around the most typical case of a single index.
If you wish to index on multiple fields, you have several solutions:

Simplest: use multiple containers, each indexed on its own field and keeping a copy of the record (update of records become a pain)
Bit harder: use multiple containers, each indexed on its own field and sharing records (std::shared_ptr<ContactInfo>)
Harder: same as the previous, but using a ""master"" container that owns the records for more efficiency (and less indirection)

In your case, I would start with (1) and move to (2) if you have to update the records.
Keep in mind, though, that update is a complicated task because each time you update a record it must be re-indexed on the updated fields. To simplify the look-up you can keep an iterator in each container referencing the item and use those to erase without paying a look-up: this iterator is returned by the call to insert when you put your item in map (or unordered_map).
",1,23044143
23045923,"
If you want to be able to do queries where you specify query values for multiple fields, then this is a painful problem to get optimal O(1) running time per query if the total number of fields is large. However it sounds like you only want to query based on one field value at a time. For this, just use a Hashmap or whatever you are using to index quickly by Name, and do the same thing for all the other fields. Since you need O(#records*#fields) storage to store your original data, and each Hashmap or sorted array or whatever you're using has size O(#records) and you have #fields of them if you do it for every field, the total amount of storage is asymptotically no larger than your original data storage size (of course, you'll need to store pointers to records in your search structures instead of the records themselves in order to get this storage bound).
",0,23044143
22997766,"
An alternative would be to use regular expressions for string search. Now there's a lot of info out there and I'll just be providing a simple example where you try to match a subrange of the records (addresses) with a word2Search (which I've hardcoded to avoid cluttering the example). 
I'm also using (a technique already mentioned in the comments) a preprocessing step where the array is sorted. Beware of two things : 

The sorting is done to enable a fast searching method, ie binary search (implemented with lower_bound upper_bound here)
If the word you are searching is not at the beginning of a record, there is no point in sorting the records since you won't be able to find a valid range (here it ite) to search into (eg if you search for the numbers, the sorting of the string would be done in lexicographical comparison between strings, so it wouldn't be any good for locating 555 among strings beginning with M J and so on)

Explanation in the comments:
",2,22994541
22996152,"
You really need to break each string into sortable components.  If you don't know about structures yet, you can use more arrays.  This would allow you to build ""index"" tables that would speed up the search.
The most efficient method determines on the quantity of the data and the organization of the data.  
For small sets of data, the time difference between the different search methods is usually negligible -- some other item in your program will take longer (such as input or output).  
With string data, most of the time is spent comparing each character of one string to another.  The other operations, such as moving indices around, are negligible.  
Since the comparison between search methods has already been performed, search the web for ""Performance string searching comparing"".
",2,22994541
22859678,"
or without c++11
or ugly looking but for all occasions ))
",5,22859245
22752100,"
Additionally, the leaf function returns true when currentNode is nullptr, assuming the check for nullptr in search is resolved.  Is this the behavior you want for a pointer pointing to a non-existent leaf?
",0,22751979
22752062,"
In your search function, you recourse on the child nodes without seeing if they're nullptr first... Then you try to de reference the data element still without checking for null.
",0,22751979
22655578,"
Finding the ""best"" word will always require some searching in the trie. But a trie isn't a terrible structure for doing this. 
However, you will have to do something like:

Pick a letter from your board. 
Find the node in the trie for the current ""word"". 
Pick another letter on the board. 
Repeat from step 2 until: no word can be found or out of letters on the board. 
Remember the ""score"" for the word you found. 
Repeat this process for all (unique?) starting letters on the board. 

You may want to check if your have ""tried this sequence before"", but I'm not sure that is much benefit. 
To make it reasonably fair on the competitor competing against the computer, you may want to limit the number of attempts the computer makes, simply because the human probably won't ever win against the computer in this case. 
",0,22654253
22655999,"
I've come up with an algorithm which performs O(n) operations throughout the entire game, where n is the size of the dictionary. It uses additional data structures though, and in all likelihood the simple bruteforce would suffice. If performance does turn out to be an issue, read on.
Consider the set of words that can be produced using the letters on the board. Words will get removed from this set throughout the game as letters are removed from the board.
The initial set of words can be determined by scanning through the dictionary. Words whose letters form a subset of the letters on the board are valid. There are many ways to test for this, such as comparing the sorted letters of the word to the sorted letters of the board or creating letter frequency tables and comparing them.
When a letter is removed, words in which the letter occurs the same number of times as it did on the board prior to the letter's removal have to be removed from the set. For example, if the board had two e's and one is removed, only words that have exactly two e's need to be removed from the set.
The set of words can be maintained efficiently using a linked list. For constant time access to the word with the highest score the list can be sorted at the start using an O(n) sorting algorithm such as pigeonhole sort. Deleting nodes from the list will not disturb the order.
For efficient deletion of all words with a certain letter frequency, references to the nodes of the linked list are stored in a two dimensional array. Entry (x, n) of the array contains references to all the nodes whose words have exactly n occurrences of letter x.
For example, references to the node containing the word ""eye"" will be stored at entries ('e', 2) and ('y', 1) of the array. When there are two e's on the board and one is removed, all the nodes in entry ('e', 2) are removed from the linked list. If a word has already been removed it is ignored.
Removing a node from the linked list is done in constant time, and each word can be removed at most once in the entire game (and may have at most 25 additional removal attempts), making the entire process O(n).
",0,22654253
22586805,"
Look into using iterators for this.
Example Code
",0,22586726
22515100,"
Try this:
",-2,22514933
24990473,"
You can use boost::file_system. Here is documentation: http://www.boost.org/doc/libs/1_55_0/libs/filesystem/doc/index.htm
EDIT: after some time, I've got that my ansver were sligtly out of topic. To check if file exists you can use special boost::filesystem function.
/EDIT
And directory iterator example: http://www.boost.org/doc/libs/1_55_0/libs/filesystem/doc/tutorial.html#Directory-iteration
It that example used std::copy, but you need filenames. So you can do something like this.
If you are not expirienced with boost - building it can be complicated.
You can obtain prebuilded boost binaries for your compiller and platform at boost.teeks99.com
Also, if you cant use boost for some reason, there is platform specific ways of iterating a directory, but I dont know on which platform you are, so I cant provide you an example.
",2,22514933
22421790,"
You can take the advantage of STL library. std::lower_bound or std::upper_bound comes to mind.
Both have logarithmic complexity on sorted containers with random iterators.
For example:
",5,22421736
22422017,"
I'm boldly assuming this isn't a homework problem... you need to find the indices of both endpoints however your code only has one ""mid"" variable. Assuming you reimplement the binary search for both endpoints correctly and you are worried about number of operations, you can re-order the conditional in the if statements so that they short-circuit on flag!=0 before checking two other conditions. ie:
is technically faster than
Next, division can be an expensive operation ... and you are dividing by 2. Use a bit shift instead:
Now throwing away the flag entirely, we might rewrite the code to look more like this:
",1,22421736
22421833,"
you can use floor(x)-ceil(y) to find it in O(log N) time .
below is code for finding ceil().. 
You can easily modify it to make floor() function .  
Another method is to use lower_bound() and upper_bound() as you are using c++ .
",0,22421736
22393554,"
Both ""program"" and ""What is stu-view?"" are quite short compared to the other strings. It's easier to transform ""program"" to ""What is stu-view?"" than to transform ""program"" to ""What is the most popular program at GBC?"" despite the fact that the word ""program"" is common.

What am I doing wrong?

I don't think you're doing something wrong. If you're not satisfied with the result, this means that your current formalism (minimizing the Levenshtein distance) is not the one you want.
You can go for more local solutions: e.g. Tokenizing the strings, compute pairwise Levenshtein distance between the words then merge the results (average, sup inf...)
Better solutions would require doing some bibliography (probably the unsupervised machine learning topic)
",3,22393079
22367861,"
",1,22362732
22363579,"
The problem based on the way you have described is straightforward to solve: read line by line, scan for a token named ""SetOfElements"" and treat the next line as the size of your 2D-array, and then read size number of lines and store them into your array.
But, your file's layout is confusing: your comment line (starting with #) says there are going to be 8 columns, but subsequent lines contain 14 columns. Is your program supposed to ignore the last 6 columns? Also, your elements seem to be mixture of ints and floats, unless the columns 1 through 8 are also floats that don't have a fractional part. 
If in fact, the data-type is mixed, and columns 1-8 have to read as ints and the remaining as floats, then your parser code is going to be complex otherwise, it should be simple getline... scan line... continue kind of algorithm.
Also, do your set delimiters change? The first set is identified by ""firstSetOfElements"" and the second set's id is ""secondSetOfElements"", it would be easier if they simply ""SetOfElements"", otherwise you would have construct the delimiter string before reading every new set of elements.
",1,22362732
22364747,"
This might give you a few ideas:
",1,22362732
22271404,"
",1,22270312
29398583,"
I can't add a comment but did you try giving each node its own int count?
example: 
Then incrementing that node's individual count when a search is conducted?
",0,29397793
39794822,"
It really depends on your expected usage patterns. You have three types of entities:

objects
groups
users

For simplifying things, let's concentrate just on the latter 2.

Are you optimizing the case where, given a group, you want to check if a specific user belongs to it?
Is removing a user from all groups efficiently important? Should it affect other users in a multithreading environment? Does it have to be atomic if so?
Are you optimizing for size or speed?

Depending on the answers (to these and probably many other questions), different solutions may work for you. 
For example, consider the following:
This uses an std::unordered_map to match each group to an std::unordered_set of users. It shows how to insert user 20 into group 3. It is very efficient in querying if user 20 belongs to group 3. It is very inefficient for answering what are the groups to which user 20 belongs.
Conversely, consider the following:
It uses a boost::multi_index::multi_index_container to simultaneously map a permission by both group and user. It therefore allows efficient access by both group and user; conversely, it is a more complex object, with higher space and time overheads.
",0,29305048
29275901,"
Your main() function is reading the contents of banned.txt into an array of 8 std::string named bannedWords.
The array bannedWords is not being used anywhere after that.   C++ doesn't work by magic, and compilers are not psychic so cannot read your mind in order to understand what you want your code to do.   If an array (or its elements) are not accessed anywhere, they will not be used to do what you want with them.
You need to pass strings from the bannedWords array to CheckWord().  For example;   
will attempt to pass the contents of the first string in bannedWords to CheckWord().
However, that will not compile either unless you make the second parameter of CheckWord() (named search) be const qualified.
Or, better yet, change the type of the second argument to be of type std::string.    If you do that, you can eliminate the usage of c_str() in the above.
I don't claim that is a complete solution to your problem - because there are numerous problems in your code, some related to what you've asked about, and some not. However, my advice here will get you started.
",0,29275302
29281302,"
Your question is really vague; it looks like you need to spend some time to pin down your program structure before you could ask for help here.
However, since we were all new once, here's a suggestion for a suitable structure:
(I'm leaving out the file handling bits because they're irrelevant to the essential structure) 
So now the entire file content is in the string ""fileContents"", and the 8 banned words are in ""bannedWords"". I suggest this approach because otherwise you're opening, reading, and closing the file for every word. Hardly a good design.
Now you've got to check each word against the file content. There's some more sophisticated ways to do this, but your simplest option is a loop.
Obviously you'll need to do the find a little differently if you want to count the number of occurrences, but that's another question.
",0,29275302
29295889,"
This corrects an error in the conditional portion of the for loop header which did not account for the index-shifting variable nShift.
",0,29270200
29257758,"
Based on Mohit's answer but re-uses pointers to possibly, get better performance (vs string.substr)
To print all:
",1,29256601
29256773,"
How about:
This creates all strings of size 3 and saves there position in a map.
Live demo link
Print only the items with 2 or more instances

As you don't want to use std::map, you can construct a trie as shown on this page written in C. Change your tree node to:
",1,29256601
29213431,"
Compiling your code with gcc I get the following segfault information:
If I go to those lines:
And 
Maybe it helps you to find something.
Check the content of the vector, and print the current iteration.
Just a note
should be
Edit:The problem is you specify the parameter as value instead of reference, when you access the first element at 
allsteps is empty, so *itr will be an invalid iterator and will segfault your code. 
",1,29212863
29212996,"
Have you tried setting break points and debugging the code?
",0,29212863
29214330,"
Change your code to pass allsteps by reference not by value:
not
",0,29212863
29204766,"
Binary Search works only when the data is sorted. A marginal improvement over binary search is interpolation search. However, the efficiency of Interpolation Search over Binary Search depends on the distribution of your data. If the data set is pretty uniformly distributed, then interpolation search can be favored. 
This link may help, 
http://blog.imaginea.com/interpolation-search-a-search-algorithm-better-than-binary-search/
",3,29204672
29186991,"
use stringstream:
",0,29186551
29186637,"
Regular expressions are fun and are usually not acceptable as homework solutions for introductory classes.
match[1] and match[2] are the numerical portion of the string that you are interested in. You'll probably want to pass them to stoi() if you need to manipulate them as integers.
Code
Output
",2,29186551
29140866,"
There is O(n) time solution, using selection algorithm.
Find the n+1th smallest element and the 2nth smallest element, these are the required elements that you seek.
Each invokation of selection algorithm is O(n) worst case (median of medians method), and you need 2 of those, so the complexity remains O(n).
So,

claim B is correct, and also claim A - both claims are satisfied by this algorithm, that has average+worst case time of O(n).
Claim C is wrong, because brute force solution of checking each pair
of elements and iterating the array for each pair requires O(n^3)
(polynomial) time, and O(1) space.
Claim D is wrong, since the algorithm we suggested runs in O(n) time, and yet solves this problem, so there is an algorithm which is NOT Omega(nlogn) for this problem.

",4,29140681
29140822,"
I'm not sure exactly what your question is, but as far as i can see, you'd need to sort the array O(n log n) and then you will easily partition it. 
So I guess claim D is correct?
",0,29140681
29142700,"
This is famous problem. If you know stl you can use nth_element. And you can see implementation in the <algorithm>.
",0,29140681
29106729,"
Breaks finding 1 in 3,4,5,1,2. Breaks finding a key that is not present, because the base case triggers only when the key is found, causing an infinite loop.
To fix, use the condition
Also note that comparing with last is superfluous if we take the ceiling of (i + j) / 2.
",3,29105151
29064514,"
Your understanding of the BFS appears to be correct. DFS is also correct (up to vertex v5).
In neither case would you arrive at v0 if you start at v1 as there is no directed edge leading into v0 in your diagram.
",1,29064346
28939655,"
something like this?
or does it need to be binary?
Hope this helps
",0,28938693
28939780,"
This should work for you and is pretty extensible and flexible:
",0,28938693
28939076,"
Using traditional binary search with minor modification:
",0,28938693
28863199,"
",0,28859522
28695959,"
std::fstream::good() checks whether the last I/O operation was successful, and, while it works in the way you implement it, it is not really what you want here. 
Use getline(file, stringToStoreInto) in place of the call to good() in the while loop, it will also return false when the end of the file has been reached. 
EDIT: To extract single whitespace-delimited elements (words) from the line you get from std::getline(), you can use an std::stringstream, initialize it with the line string, and then extract single words out of that stringstream into another ""word"" string using the >> operator.
So for your case, something like this would do:
Alternatively you can also instantiate the stringstream object once and call its str() method, one overload of which resets the stream while the other overload replaces its content. 
You can use the stringstream to extract multiple words, not just the first, just keep calling operator>> like you did before.
",0,28695797
28615065,"
Use std::count_if.
where DataType is the type of elements contained in Data.
Note that there are no real efficiency gains to be had unless Data satisfied some more conditions, for example, being sorted by ID. However, using a standard algorithm improves readability.
",1,28615000
28615086,"
With C++11 and lambdas could write a little more expresive as:
If you want to count the struct with ID:
If you want to known if there is at least one:
The other algorithms of the STD it's always good to have at hand, some are used only very few time, but could save a lot of debugging (with edge case) and performance problems if implemented by hand.
",1,28615000
28549711,"
Your algorithm is still a binary search.  You split the array into two partitions, then select a partition, based on the value of a letter.  
The requirements of a partitioned search is to have an ordered collection.  
Let's use your example.  
If you choose the midpoint at index 5, this yields the letter a.  Since you are searching for the letter c first, then d, the algorithm says that the letter c must lie in the partition 6..11.  Thus the basis of your issue.  
The algorithm will not find cd because there is no c in the partition 6..11.  
The algorithm assumes that the array is sorted and that for any given index, there will be one partition containing values less than array[index] and one partition containing values greater than array[index].
This assumption is demonstrated by the following code of yours:
No matter how you name your algorithm, if it assumes an ordering on the array (e.g. p[j] < t[mid]), the array must be ordered. 
You data is not ordered, so your algorithm fails the assumption, and thus the algorithm fails.  
Edit 1: 
Using Partitions
If you really must use a partitioning algorithm, you will need to build a set of partitions.
For example one partition starts at index 0 and proceeds until array[i] > array[i+1], this ends up at index 4.  The other partition is 5..11.  
(By the way, by determining the partitions, you have used more operations than a linear search.) 
At this point, how do you know which partition to choose?  
You don't.  The letter c, that you are searching for, lies between a and e in the first partition; and a through g in the second partition.  Pick a partition.  If not found in the partition, you will have to search the other partition. 
By performing a binary search on either partition, you have used more operations than a linear search.  
",0,28549462
28444528,"
There are several ways to implement this, here's the simplest (but the least efficient one):
I think you can figure out how to fill in the spots marked with comments. When the recursion unwinds and find_longest returns, a non-NULL best_match will point to the node with the longest word.
It's up to you to define what happens when there are two or more words with the same, longest length.
One other comment. Consider taking the code that iterates over the tree and putting it into a template function, parametrized by a lambda class, with the template class iterating over the entire tree, and invoking the lambda for each node representing a word. This way you will avoid duplicating the code that executes the recursion between your existing function that prints the tree, and this one.
",1,28443753
28281176,"
Allocating memory to read in the whole file just to find strings inside sounds like a very bad idea, and unnecessary. I'm pretty sure you also should be using neiter ios::ate (starting at end of file instead of at beginning) nor binary (it's a text file...).
I think this is a case of ""you don't have to write this, it has already been done""; just use a tool like grep, which should be available for virtually any operating system:
will do exactly what your program should do, would possibly be faster, and well-debugged. 
",4,28280975
28281482,"
If in the above code, if all you want to do is find ""PRIORITY_NAME"" on a line by line basis, then you can clear the stream after you are done with each line.
Just before the next iteration of the while loop, maybe a clear would help.
",0,28280975
28268362,"
I could not think of anything that would not be O(n), since the data is always unsorted. 
But, i can think of shortcuts, since you want a set of at least 3, and is binary data.
How it works:
It is a binary filter, it creates a mask of 3 bits, and continuous shift to left by 1 in every step of the loop.
So you have these numbers as filters:
Then it checks if the seed match with the result of a logical AND between the number tested and the seed itself (this filters all the numbers that don't match the filter).
If the seed and the AND match, it moves the seed to the result using a logical OR, and set a continuous to control the continuity of the sequence. The first time the result is not continuous, it breaks the loop.
In the end, you have the result and can calculate the index by:
You will need to scan your 50gb data in 32bits chunks (easy to adapt to 64bits, or even do vectorization of it).
",1,28265946
28268428,"
Well, you can't avoid going through the entire data at least once (you have to look at everything at least!), but you can avoid going through it multiple times if you e.g. run-length encode the data.
",0,28265946
27931321,"
Searching a linked list is linear so you need to iterate from beginning one by one so it is O(n). Linked lists are not the best if you will use it for searching, you can utilize more suitable data structures such as binary trees.
Ordering elements does not help much because still you need to iterate each element anyway.
Wikipedia article says: 

In an unordered list, one simple heuristic for decreasing average search time is the move-to-front heuristic, which simply moves an element to the beginning of the list once it is found. This scheme, handy for creating simple caches, ensures that the most recently used items are also the quickest to find again.
Another common approach is to ""index"" a linked list using a more
  efficient external data structure. For example, one can build a
  red-black tree or hash table whose elements are references to the
  linked list nodes. Multiple such indexes can be built on a single
  list. The disadvantage is that these indexes may need to be updated
  each time a node is added or removed (or at least, before that index
  is used again).

So in the first case you can slightly improve (by statistical assumptions) your search performance by moving items found previously closer to the beginning of the list. This assumes that previously found elements will be searched more frequently.
Second method requires to use other data structures.
If using linked lists is not a hard requirement, consider using hash tables, sorted arrays (random access) or balanced trees.
",5,27931175
27931244,"
Consider using array or std::vector as a storage instead of linked list, and use binary search to find particular string, or even better, std::set, if you don't need a numerical index. If for some reasons it is not possible to use other containers, there is not much possible to do - you may want to speed up the process of comparison by storing hash of the string along with it in node.
",3,27931175
27931365,"
I suggest hashing.
Since you've already got a linked list of your own), you can try chaining with linked lists for collision resolution.
",1,27931175
27931378,"
Rather than using a linear linked list, you may want to use a binary search tree, or a red/black tree.  These trees are designed on minimizing the traversals to find an item.  
You could also store ""short cut links"".  For example, if the list is of strings, you could have an array of links of where to start searching based on the first letter.  
For example, shortcut['B'] would return a pointer to the first link to start searching for strings starting with 'B'.
",1,27931175
27931500,"
The answer is no, you cannot improve the search without changing your data-structure.
As it stands, sorting the list will not give you a faster search for any random item.
It will only allow you to quickly decide if the given item is in the list by testing against the first item (which will be either the smallest or the largest entry) and this improvement is not likely to make a big difference.
So can you please edit your question and explain to us your constraints?

Can you use a completely different data structure, like an array or a tree? (as others have suggested)
If not, can you modify the way your linked list is linked?
If not, we will be unlikely to help you...

",0,27931175
27932431,"
The best option is to use faster data structure for storing strings:

std::map - red-black tree behind the scenes. Has O(logn) for search/insert/delete operations. Suitable if you want to store additional values with strings (for example - positions).
std::set - basically the same tree but without values. Best for case when you need only contains operation.
std::unordered_map - hash table. O(1) access.
std::unordered_set - hash set. Also O(1) access.

Note. But in all of these cases there is a catch. Complexity is calculated only based on n (count of strings). In reality string comparison is not free. So, O(1) becomes O(m), O(logn) becomes O(mlogn) (where m is maximal length of string). This does not matter in case of relatively short strings. But if this is not true consider using Trie. In practice trie can be even faster than hash table - each character of query string is accessed only once instead of multiple times. For hash table/set it's at least once for hash calculation and at least once for actual string comparison (depending on collision resolution strategy - not sure how it is implemented in C++).
",0,27931175
27852007,"
I don't know if there is a better way of doing it, but at least this seems to work:

I would add E (directed) edges between random vertices. This will generate several clusters of vertices.
Then, I need to connect those clusters to form a chain of clusters, so ensuring that from a cluster I can reach any other cluster. For this I can label a random vertex of each cluster as the ""master""vertex, and join the master vertices forming a loop. Thus, you have a strongly-connected directed graph composed of clusters (not vertices yet). The last master should be connected back to the first master, thus creating a loop.
Now, in order to turn it into a strongly-connected digraph composed of vertices I need to make each cluster a strongly-connected digraph by itself. But this is easy if I run a DFS starting at the master node of a cluster and each time I find a leaf I add an edge from that leaf to its master vertex. Note that the DFS must not traverse outside of the cluster.

I think this may work, though the topology will not be truly random, it will loop like a big loop composed of smaller graphs joined together. But depending on the algorithm you need to test, this may come in handy.
EDIT:

If after that you want to have a more random topology, you can add random edges between vertices of different clusters. That doesn't invalidate the rules and creates more complex paths for your algorithm to traverse.

",1,27851744
27851952,"
One approach would be to maintain a set of strongly connected components (starting with |V| single-vertex components), and in each iteration, merge some random subset of them into a single connected component by connecting a random vertex of each one to a random vertex of the next one, forming a cycle.
This will tend to generate very sparse graphs, so depending on your use case, you might want to toss in some extra random edges as well.
EDIT: Intuitively I think you'd want to use an exponential distribution when deciding how many components to merge in a single iteration. I don't have any real support for that, though.
",1,27851744
27808070,"
Firstly, don't use a map keyed on std::pair<double, double> if searching for inclusion is the main thing you want to do. That's just not an operation that makes sense with that data structure.
But if you insist, the code would look something like this (in C++11):
Pre-C++11, same idea, just slightly different loop syntax. Ideally, we'd use std::find_if, but it's a hassle to express the map's value_type. In C++14 though, no such hassle:
Or just:
",2,27807960
27808161,"
One approach could be not to use a std::map<std::pair<double, double>, std::string> but rather a std::map<double, std::pair<double, std::string>>: you'd use m.lower_bound(current_time) to find the start of a range of elements where current_time could fit. You'd then walk the iterator until it reaches the end, falls into the relevant range, or is beyond the end time:
Using the layout with a std::pair<double, double> a key has the awkward need to come up with a second time. You could use std::make_pair(current_time, current_time), though.
",2,27807960
27808100,"
I would recommend also looking into boost::icl
",0,27807960
27808828,"
If possible, don't use std::pair as the key.  It doesn't really make sense as a key because you end up with a situation where two overlapping ranges map to the same element.
Anyhow, here is how I would implement the solution to such a problem.  lower_bound/upper_bound are your friend here.  Also, you can avoid the reverse iterator tricks by keying the values on stop time.
",0,27807960
27677174,"
Declare operator < like
For example
",0,27677072
27509913,"
Not the most efficient way (especially for one word), but maybe this could give you direction:
",0,27508853
27505067,"
Your function always returns in the first loop iteration. If the first element is not the one to be searched, 0 is returned immediately. The loop never enters the second iteration.
",2,27504918
27505094,"
you must return not found if you dont found any thing, with this code, you will always return zero, if the first element is not what you are searching for. something like this :
",0,27504918
27505122,"
It is in your logic
Let's step through that. I'm going to give it [1, 2, 3, 4], 4, and 3.
So, you check the first one, and if that doesn't work, it will immediately fail.
So try this:
However, the better way would be to do something like this, and get rid of your global variable
Then if you get something != -1 you have found it.
",0,27504918
27505186,"
Your search function is not doing what you think it is doing: it will return 0 as soon as a[i]!=num, thus not considering the rest of the elements of the array.
You'd better use someting like this, with a (non-global) variable returned:
",0,27504918
27506716,"
The problem is with your else statement. If the the element is not found straight away, it will automatically return 0. Furthermore, you use the integer 0 to indicate that the element is not found, but what if the element is found at position 0 (i.e it is the first element of the array)? Then you will still say that the element is not found, even though it clearly it exists in the array. Here is how I would do it.
I hope you have learned about booleans (i.e true or false.) Since your function's main purpose is to search, it should return whether the element is found (true) or whether it is not found (false). Therefore, we loop through the array, and if we find it, we output the position of the element, and return true. Otherwise, if we exit the loop, this means the element has not been found, so we output that and return false. This gets rid of the global variable usage and the previous problems that I have mentioned. 
",0,27504918
27503396,"
Initial note: This answer assumes that the InsertNode function is initially called with root being the root of the tree, and node being the node to insert into the tree.

One problem is this statement:
Since the argument root is passed by value, which means that it is copied, the assignment will only change the local copy. Once the function returns the original pointer that you pass to the function will not have changed.
You need to pass the pointer by reference, meaning the root argument references the original variable passed in to the function, instead of it being copied. You do this by using an ampersand when declaring the argument:
The above means that root is a reference to a pointer to Node.
So the complete InsertNode declaration should look like

There are also other problems, for example these lines are not correct:
This is not correct because node->left should be NULL always, which makes you create a new node using the value from the root of the tree, and assign it to node->left, but you never insert node in the tree.
What you should instead do is simply
Of course you should do the same change for setting the right branch.

Combining the two solutions above, your function would look like
This function also solves a third problem with your current code: What if node->value is equal to root->value? The above function puts it in the right branch.
",2,27503278
27503457,"
When you are creating a tree, value are also assigned with each node. See following code:
",1,27503278
48211546,"
The below code is in Python and is used for insertion in a BST ::
",0,27503278
27431205,"
I'm quite certain the standard library doesn't include anything to do precisely what you're asking for.
To get what you want, you'll probably want to start from std::lower_bound or std::upper_bound, and convert the iterator it returns into an index, then complement the index of the value wasn't found.
",3,27431029
27431283,"
Clearly, this ""will return the bitwise complement"" is a big deal for you and I do not understand what you mean.  That said, lookup std::upper_bound and see if it does what you want.
",1,27431029
46824354,"
There is no simple STL method which returns index against a sorted vector as far as I know, however you can use sample function below:
",0,27431029
51125124,"
using STL we can find the index
",0,27431029
27418811,"
I can see two issues with your code. First, you are shadowing the stopTheProgram variable. You define it once just before the do/while loop and initialize it to 'n'; Then once inside the do/while you define another stopTheProgram. This is a problem because of scoping. Inside the do/while loop the input from the user is assigned to the local stopTheProgram (defined in the do/while) but that ceases to exits outside the loop. So the while loop expression is always evaluated using the globally scoped stopTheProgram, which is set to 'n'. So remove the second definition. Second is an issue with the expression that controls the while loop. It always evaluates true. Draw a truth table if you can't visualize it. If stopTheProgram = 'Y' then the stopTheProgram != ""Y"" || stopTheProgram != 'y' is  0 || 1 which is always true. If stopTheProgram = 'y' then stopTheProgram != ""Y"" || stopTheProgram != 'y' is  1 || 0 which is always true. This works:    while(!(stopTheProgram == 'Y' || stopTheProgram == 'y'))
",0,27415736
27296436,"
You need to compare the number against min.  You are just looking for the last number which is smaller than the following number, and 3<44.
",1,27296193
27296596,"
As Kenny said, you have to compare it against min. It will look like this:
",0,27296193
27296708,"
Just assume that your first element is the minimum and start to compare from the second element. If another element is lesser than the previously set element(initially first element), then set this element as new element.
and by the way, you can overload the index operator '[]' to set/get elements just like an array
",0,27296193
27287866,"
With binary images, you can use directly HU-Moments and Mahalanobis distance to find if image A is similar to image B. If the distance tends to 0, then the images are the same.
Of course you can use also Features detectors so see what matches, but for pictures like these, HU Moments or Features detectors will give approximately same results, but HU Moments are more efficient.
Using findContours, you can extract the black regions inside the white star and fill them, in order to have image A = image B.
Other approach: using findContours on your mask and apply the result to Image A (extracting the Region of Interest), you can extract what's inside the star and count how many black pixels you have (the mismatching ones).
",0,27287755
27459936,"
I have same requirement and I have tried the almost same way. As in the image, I want to match the castle. The castle has a different shield image and variable length clan name and also grass background(This image comes from game Clash of Clans). The normal opencv matchTemplate does not work. So I write my own.
I follow the ways of matchTemplate to create a result image, but with different algorithm.
The core idea is to count the matched pixel under the mask. The code is following, it is simple.
This works fine, but the time cost is high. As you can see, it costs 457ms. 
Now I am working on the optimization.
The source and template images are both CV_8U3C, mask image is CV_8U. Match one channel is OK. It is more faster, but it still costs high.
It says I have not enough reputations to post image....
http://i.stack.imgur.com/mJrqU.png
New added:
I success optimize the algorithm by using key points. Calculate all the points is cost, but it is faster to calculate only server key points. See the picture, the costs decrease greatly, now it is about 7ms. 
I still can not post image, please visit: http://i.stack.imgur.com/ePcD9.png
Please give me reputations, so I can post images. :)
",0,27287755
27246907,"
Here you opened the file.
Yet you read nothing ever.
So when you do stuff like
The table will by definition be empty since you still have to read anything from the records.dat file.
Remember: Programming is not magic. It may seem like that at first, but nothing ever happens unless the code was written (by anyone at all, not necessarily you)
",1,27246601
27247476,"
I see a number of issues with your code:

Your hash index size is 8? So why are you modding by 5?  That means cells 5, 6 and 7 will always be empty as they will be redirected to 0, 1 and 2.
Why in main() are you outputting after every record read? Why not do that at the end? (If you didn't insist on that awful bracing style it would be clearer what you are doing, although others will disagree with me on the style issue).
Your code of course leaks, isn't const-correct and could do in general with better structuring.
What does ""findRecord"" do with the input file? I can't see it reading it.
Why are you doing checks on key==0? Isn't that a valid key? 

",2,27246601
27210037,"
As per this page, http://www.cplusplus.com/reference/string/string/find/, and this http://www.cplusplus.com/reference/string/string/npos/, the find() method on the String returns -1 when there is no match.
if ( some_num ) is true whenever some_num is non-zero, including -1, where some_num is any expression.
Read the find documentation carefully to understand how it can be used to check for a match.
",0,27209991
27210146,"
1) The find function is not necessary.  All you need to do is use ==.
2) For the title, you should be testing the bookTitle array, not bookAuthor.
",0,27209991
26886536,"
If you mean for height here to represent the level of the tree that a node is on, using a global variable is going to give you pretty weird results. I also admit to not being entirely sure what you are doing with the variable u. 
That said, I think you should be okay with something like this:
Edit: I don't have the reputation to comment yet, so I'm limited to responding with edits. @ProgLearner, you don't need a separate variable u because your node pointer is a function argument, and so you'll have a fresh one with every call to the function. Similarly, as Jonathan Mee said, the h variable needs no external initialization because it's also local to the function. In cases where you don't supply any initial value (like when you call it on the root), it will default to -1. 
",2,26885942
26951358,"
I'm not sure why you want to do this, but these days Boost Interval Container library is pretty capable.
Assuming that you might have wanted to keep track of the total (sum) of mapped values for a specific point, you could simply apply a splitting Combining Style to your input data and profit:
Live On Coliru
This will tell us:
Notice how 

the consolidation very accurately reflects that the point [3,3] is the only only point that coincided with both [1,3] and [3,5] from the input data simultaneously, and as a result, we get halfopen intervals in the combined set ([1,3), [3,3] and (3,5]). 
Note also how the query for this one point correctly returns the sum of 10+6+9 for all the three intervals you were interested in.

What Use Is This?
So, you see I shifted the focus of the question from the ""How?"" to the ""What?"". It usually helps to state the goal of code instead of the particular mechanics.
Of course, if instead of the sum you'd have been interested in the average, the minimum or the maximum, you'd likely find yourself writing some custom combining strategy.
Bonus In case you wanted, here's how you can at least write the solution to the problem posed in the OP using Boost Icl: Live On Coliru. Though it's not particularly efficient, it's straight forward and robust. 
",1,26868266
26868898,"
I think that instead of iterators you could store (and use) corresponding keys of the map. If so then the code could look like
The output is
Take into account that it is supposed that key.first is less than or equal to key.second where key is the key of the map.
",0,26868266
26868877,"
There's no way to avoid a linear search from the start of the map, because if the first element is {0,INT_MAX} then it matches and the elements you want are not necessarily in a contiguous range, e.g. if you have {1,3},{2,2}{3,5} you only want the first and last elements when the key is 3.
You can stop searching when you reach an element with first greater than the key.
Something like this (untested):
You could turn it into a functor and use find_if but I'm not sure it's worth it.
If you just want one iterator returned per call:
",0,26868266
26871090,"
if you only need an iterator to the next value found in the map, you can use the std::find_if algorithm like this:
",0,26868266
26862669,"
There's no support for working with directories in the standard library. There's however an effort to incorporate Boost.Filesystem into the C++17 standard. For now, you can just use Boost directly.
update:
To compile the snippet, you need to have Boost installed (and compiled, Filesystem is not header-only). Follow the tutorials here. Then make sure to link with boost_filesystem:
And don't forget to create some .txt files in the same directory so that the program has something to chew on.
",1,26861172
26812564,"
First, in any of your loops, you don't change the value of i, so they are potentially infinite. 
Second, if I understand what you're trying to do, you have paired vectors and you search for an index on which the name is in the first vector and then use it to get the value from second vector. You can use std::find function for that:
Now, you can access the girlsfreq[frank] value. If the name is not present in the vector, the frank equals size of the vector, which you have to check for. Don't forget to add include:
",1,26812398
26812571,"
I am not able to reproduce your crash. Instead, I am able to reproduce an infinite loop. Taking a closer look to your while loops, it becomes evident: the value of i is never changing. If it cannot find a name match, it will keep incrementing the value of frank. So, a fix to this problem would be:
But it can be improved: you don't need that assignment. Also, you can use the advantage of the postfix increment:
Doing this, you also remove the necessity of name and name1.
",0,26812398
26812152,"
If vector size is 2, then min == mid == 0 and max == 1. And in the code you check element at mid - 1, that is -1, so your program exhibits undefined behaviour.
",1,26810907
26739047,"
You can test CppDepend, it has a powerful code query language(CQLinq) to query as you want your code, for example in your case you can execute query like this one:
",2,26737814
26613241,"
I think the algorithm you're looking for is called interpolation search, which is a variation on binary search that, instead of looking at the midpoint of the array, linearly interpolates between the array endpoints to guess where the key should be. On data that's structured the way that yours is, the expected runtime is O(log log n), exponentially faster than a standard binary search.
There is no standard implementation of this algorithm in C++, but (as a totally shameless plug) I happened to have coded this one up in C++. My implementation is available online if you're interested in seeing how it works.
Hope this helps!
",22,26613111
26571766,"
I would use a standard container, I would not use the object itself as a key. Code example:
",0,26571666
26571771,"
You could use a map<unsigned int, list<search_object*>> which holds a list of your objects for every search_field.
",0,26571666
26573326,"
With the right sort strategy before the search it can be done easily.
Output


std::upper_bound
    Returns an iterator pointing to the first element in the range [first,last) which compares greater than val.


",0,26571666
26565876,"
You're probably right: that loop is likely the problem.
It's because you erase from *j at the same time as iterating over it; erasing that element will invalidate an iterator to it.
Here is how to erase from a list whilst iterating over it.
As an aside, your code is very difficult to read.
",1,26565808
26323755,"
Entrian Source Search is a Visual Studio extension that does exactly what you're asking.  It searches all the files in any set of directories you give it, not just the files in the solution.  It builds a full-text index of the source, so searches are near-instant.
As an extreme example, my current project has in its index 18,314,927 lines of source code, totalling 645MB.  Searching for a semicolon finds 5,760,878 hits in 6.9 seconds.  Searching for anything with a sensible number of hits is instant.
(Full disclosure: it's a commercial product ($29) and I'm the author.  I wrote it because I work with large codebases and found Find In Files to be inadequate.)
",1,26317040
26321566,"
Sando Code Search Tool pre-indexes source code and promises near-instant search.
",0,26317040
26363806,"
I made Windows Search to index my entire codebase and used this vs extension to navigate to any text in my codebase. This has the added advantage of being able to search any string in a 'google search' sort of fashion.
",0,26317040
26313271,"
For example the member function can be defined like
or
or
and so on including standard algorithm std::count
",1,26313141
26313563,"
I don't understand why you're playing with objects in so simple case. If I were you, I'd write:
Or, if you prefer pointers:
Also, in each case I'd recomend you to write additional function to deal with std::string easily:
If some comments about code would be encouraged, please tell me what do you think I should comment.
",0,26313141
26252439,"
Something along the lines of
Demo. Templatizing this code is left as an exercise for the reader.
",0,26252048
26253360,"
Slightly more general than T.C.s version:
Demo. Note that you could still expand this by using a template parameter that is a pointer-to-member to a value_type's member.
",0,26252048
26247047,"
You're defining SIZE as 1000, and you're passing it to searchArray():
You are doing the following in searchArray():
Since size is 1000, you are setting ""first"" to 0 and ""last"" to 999.
Then, you're doing the following (leaving out some irrelevant stuff):
So, let's take out a piece of paper, and a pencil. Since ""first"" is 0, and ""last"" is 999, this sets ""middle"" to 449.
So, we have two problems here:
1) You're assigning using the ""="" operator, instead of comparing using ""=="", which appears to be your intent.
2) You are assigning a value to myArray[449][449][449]. Unfortunately, your array is much, much smaller:
Trying to access the 449th's element of the 449th array of ten elements, of the 449th array of ten arrays of ten elements, is not going to work very well. Even if you were comparing, or assigning something, either way this is undefined behavior, and an almost guaranteed crash.
",0,26246900
33481266,"
You have two different variables, both named val. The one inside the if statement is only in that scope.
Simple remove the declaration of the val variable inside the if, and only use assignment:
",3,33481203
33426270,"
Here is custom binary tree code example.
CTreeNode implementation
CBinaryTree declaration
CBinaryTree implementation
in your case
",1,33426037
33423465,"
First, your nodes need to hold the data:  
Then you can think to browsing through your tree to insert a new node.
In this example, I assume that you can insert several nodes with the same name.  
Here a live demo.  
Note that I have only answered your insertion question,  you still have to do a lot on your own (operator= and copy constructor need review, a destructor needs to be created, etc...)  
",0,33422724
33354738,"
Your while loop is incorect.  You should be testing that nodePtr is not NULL
Also this is a perfect reason to use nullptr instead of NULL when dealing with pointers.  If you had use nullptr then 
Would give you a compiler error as you cannot compare a double to nullptr
",1,33354700
33354815,"
I do not know how the corresponding class is defined but I think in any case the function should look the following way
It is difficult to compare exactly two floating numbers. You should use a method of comparison that for example takes into account an epsilon.
Take also into account that other functions as for example the function that adds nodes to the list can also be wrong.:)
",1,33354700
33354740,"
Your while loop condition should be:
Because of this error you are likely visiting a node who's pointer is NULL And by dereferencing this you are causing undefined behavior. 
",0,33354700
33354761,"
You don't show the ListNode type but I'm guessing the value is a double.

while (nodePtr->value != NULL)

Here you're checking if the double is not NULL (NULL is essentially 0). But you need to test nodePtr against NULL.
Note: Consider using nullptr instead of NULL, nullptr is the type safe value for a null pointer and would have produced a compilation error.

error: invalid operands of types 'double' and 'std::nullptr_t' to binary 'operator=='

",0,33354700
33339415,"
My approach would be something like this...
",0,33338942
33339067,"
Here's the approach I would take.
I would start by storing the index of the first array item (0), along with the absolute difference between that item and iSearchTarget.
Next, I would loop through the rest of the array and for any item that has a smaller absolute difference to iSearchTarget than the one currently stored, I would replace the index and difference with that new item.
When you are done, you will have the index of the closest item.
But sorry, I'm not writing the code for you.
",1,33338942
33339142,"
After each iteration while searching take another variable (min) which stores the absolute difference of the numbers
P.S. Its just an idea as how to proceed with the problem.Not the complete code
",0,33338942
33341563,"
With algorithm, it becomes:
Live Demo
",0,33338942
33029304,"
Through the magic of C++11 (and a very well-designed library), the answer is almost identical to your pseudo-code:
prints
",1,33028955
32980618,"
The standard specifies the complexity of the relevant functions. Get a copy, or read a good reference. (See e.g. http://en.cppreference.com/w/cpp/container/unordered_set/find.)
They're all pretty much what you'd expect.
",1,32980530
32707573,"
EDIT: The core of your difficulty here is found in your class structure. Think about your goal - you want to associate an h with an edge, correct? The word ""associate"" means that you need some sort of data structure in your class(es) that allows you to do just that.
There are a few structures to choose from: tuples and structs are two possibilities. If you store the structure in your list, you can enter all of edges, and then step through and enter all of the h values.
Another possibility is to use a union to allow you to store both types of values in the same list. This will be more difficult, but may accomplish your goal.
Beyond this, you will need to do the research yourself, here.
--
I know you're new here, so I'll let you know that very few people will just give you the correct code outright, especially on something this complex. Just a heads up.
Second, you're on rather shaky ground if you do not understand your own object structure. I'm having a hard time reading it myself, and I'm a professional. Please, for the love of all things digital, comment your code! What do your various one- or two-letter variables mean...or the ones with the longer but still elusive names? (Don't feel too bad about this...common habit among programmers. Ask anyone here.)
Getters and setters are not a complex matter. Getters simply return the value of a private variable in the class. A setter is a function that accepts an argument, and assigns that argument to a particular private variable in the class, usually after checking for errors.
The best advice I can give you right now is A) comment your code, and B) figure out your code's basic object structure. Literally write (on paper if you have to) the names of your objects, what is stored inside them, what's hidden and what's public, and what they're supposed to do. If you figure that out, you'll probably find your answer on your own. Otherwise, edit your question with that information. 
If I see that work - the intended class structure and some good comments - I'll edit with more details on how to fix your code. It's about doing the footwork yourself.
By the way, you have variables hanging out above your scope declarations (in this case, public:) in your headers, which is a no-no.
",0,32707406
32515182,"
It doesn't. You're outputting the value of the first element in your vector, not the searchKey you passed into it. 
You do realize that this loop will never get to i==1, right? No matter what, it's going to return while checking the myVec[0].
",1,32515045
32524758,"
comments already cover most of the issue.  I probably shouldn't reward such a badly-asked question with an answer, but I was curious about a couple things and tried them out.
On a standard install of 64bit Ubuntu 15.04:
Growing the stack to more than 64MiB will generate a segfault.  I could increase the stack limit if I really wanted to, but it would be better to change the program.
Your system seems to have a default stack limit of 2M (5072*8 is just under, 5082*8 is just over).

C++ doesn't support variable-length arrays the way ISO C99 does.  However, GNU C++ does support it.  It's not a good idea for big arrays.
The C++ way to do this would be with a std::vector, and emulate the 2D array by doing the index calculation yourself.  (Don't make a vector of vectors unless you need some rows longer than others)

When filling the array, if the inner loop is over columns (i.e. the inner loop varies the 2nd index), gcc can auto-vectorize it (use -march=native).  Just interchanging for lines, rather than changing the assignment, has the desired effect.
Unfortunately, it doesn't run faster for large problems, because memory is the bottleneck.  (imul with a throughput of one 64bit result per cycle can saturate main memory just fine.  You'd get a speedup if your matrix fit in cache.)

Of course, for this algorithm, actually storing the multiplication table in a 2D array is not useful at all.  Generate values on the fly and compare / increment.  If you want to be able to answer repeated queries about the frequency of other numbers, loop and increment hashtable[i*j].  Use a std::unordered_map for the hash table.
Since multiplication has special properties, you can take advantage of this to compute the number of ways that i*j can be equal to x.  Factor x into its prime factors, then count the ways these prime factors can be split into two groups.  Don't forget to account for duplicates, e.g. 2*2*2*7 has (2*2) * (2*7) as one of its possible arrangements, but it doesn't matter which of the three 2s is grouped with the 7.
The brute force method is useful for testing the factoring method, which I will leave as an exercise for the reader.
",0,32509690
32149927,"
In fact i don`t think you need 2D vector at all, you need just 1D. Witch for example would look like this [2,9,12,16,25], the upper bound of each pile, you can construct this really easy. Then for every juicy worm you do binary search in that manner that it returns index with value greater or equal to the value you are looking for. The index you got from the search is the pile you are looking for.
Some pseudo-code:
the index you get is with first value equal or greater than q, so the pile where is q.
and C++ code:
You have to add +1 to distance because the piles are numbered from 1. Work for the example, and looks pretty fast.
",6,32149680
32149718,"
The most obvious optimization opportunity is, instead of using a vector<vector<int>> use a vector<int> and manually adjust the 2D indices to 1D. You can write a simple wrapper class that does this for you.
The reason that that will be much faster is that then all the memory will be allocated as a single contiguous unit. If you have a vector of vectors, then each row will be somewhere else and you'll have lots of cache misses.
Here's a code example:
If you preallocate this with all the space that it will need, then it should use memory very efficiently.
Also, passing large function parameters by value instead of by reference is very wasteful, because it results in needless copies being made and destroyed. (Like WhozCraig pointed out.)
",2,32149680
31882496,"

searching through the index is my biggest problem as of now

And index is just a ""pointer"" to an item in the model. You can't search ""through"" it, because there is nothing ""in"" an index. It's just a pointer to exactly one item.
You should search through the model. The index(const QString & path) method does that for you. Given a path, it returns an index into the element at the end of the path. You can then iterate upwards to extend the items:
You can use this method with the last item removed from the path as well, since - presumably - the last item might not be valid, and thus fs->index might fail.
",1,31869003
31869317,"
Have you check here?
[Model/View Programming][Insert and delete rows in QTreeView]
http://doc.qt.io/qt-4.8/model-view-programming.html
QTreeView & QAbstractItemModel & insertRow
As base design principle, View only render the data.You should not expect to modify the data via View directly.
",-1,31869003
31860291,"
To be in O(log n), you may use the following:
Live Demo
but a linear search seems simpler
",0,31856107
31856366,"
There isn't anything in Boost or the C++ Standard Library. Two choices for an algorithm, bearing in mind that both vectors are sorted:

O(N): trundle through the sorted vector, considering the elements of your quantile vector as you go.
O(Log N * Log M): Start with the middle quantile. Call lower_bound. The result of this becomes the higher iterator in a subsequent lower_bound call on the set of quantiles below that pivot and the lower iterator in a subsequent lower_bound call on the set of quantiles above that pivot. Repeat the process for both halves.

For percentiles, my feeling is that (1) will be the faster choice, and is considerably simpler to implement.
",0,31856107
31667022,"
You could use std::find_if and provide a lambda as a predicate. It will be simpler and more flexible but I'm not sure it will necessarily be faster.
Live demo.
Alternatively, you could create a comparison operator with a key tuple or struct
and use std::find:
Live demo.
If you want faster search you might need to reconsider how you are storing the structs. Perhaps maintain indexes or keep the vector sorted but this may impact the performance of insertions.
",4,31666972
31667810,"
The first off, why put it in a vector?  I believe an urordered_map might be better off with the hash:
I think ^ is a good way of merging two hashes into one. Maybe google that part?
If you insist on a vector, maybe make a smart_ptr and store that in your vector then an unordered_map with the smart_ptr as a value.
PS:
OK xor is a crappy way to hash. use boost::hash_combine or this answer.
",0,31666972
31512562,"
No need to save values to a temporary array.
All you need to do is keep track of the largest length found (initially zero) and the location of its first element (initially NULL if you use a pointer to indicate that).
Then walk through the array until you find the value of interest.   Count the number of consecutive occurrences.   If that number exceeds the maximum length found, set the location to point at the first one found.
Repeat until end of array is reached.
Done.    If the largest length found is zero, it means there were no occurrences of the value sought.
No, I'm not going to write code for the above.  The description of the approach is enough.
There are also plenty of alternative options using standard algorithms
",2,31512069
31513015,"
Just for the record, another way is to use use std::search.
Prints out:
Even easier if your array is a standard container, like std::array or vector. 
",2,31512069
31651018,"
Your check() function will do many repetition work.
For grid
and word 'aabaa'
There are two ways to get 'aabaa' which are same after letter 'b' 
(top, right, top, right) or (right, top, top, right)
From this trait, we use an array a[position][n][m] to record whether for a specific word its prefix with length position can be got at grid [m, n]
For the previous example, 
follow such sequence
'aabaa' can be found in grind
So complexity will be N*M*K*S
S is the number of words in list
",0,31479226
31356258,"
It depends on how you are calculating variable r.
In your case 
So correct usage is while(l<=r)
If you calculate r as r = a.size(); correct usage is while(l<r)

In case the element is not found, is l guaranteed to be the position
  in which the element could be inserted so that the list still remains
  sorted ? 

You didn't sort your vector, for proper binary search, vector should be sorted before calling binary search.
And  header provide a std::binary_search, so instead reinventing the wheel you can use it as follows:
Binary search supposed to return value of index in vector, if it find. But there is no guarantee it should provide the next location for insertion.

Is this valid while using equal to or not using equal to ?

I explained it in first part of my answer.
",0,31356239
31345997,"
How about using a functor:
output
Live example: http://ideone.com/fSoG5B
",2,31345161
31284060,"
Change to
",0,31283913
31240889,"
You can create a function object type that handles heterogeneous comparisons:
Then you can call binary_search like this:
",3,31240390
31240771,"
You can do this by adding an implicit constructor to convert std::string to Record and an operator to convert Record to std::string.
or you can convert your existing constructor to this
But anyways you'll need to create a std::string object to search.
See http://ideone.com/0f16GE demo.
",0,31240390
31218029,"
you should use return recursive calls.You are making recursive calls but are not collecting the value returned from those recursive calls.You are assuming that subsequent calls(recursive) will return the answer to main but it is going to return the ans to the point where you are making the recursive call.At that point you should collect the answer and return it to main.   
Also it should be 
instead of
",4,31217897
30948922,"
Basic intrusive solutions are often overlooked here in search of elaborate data structures and algorithms, but generally are the fastest.
Assuming you have no choice but to keep the selection separate, if you want a really fast solution, store a boolean selection flag in each layer (could be a single bit). When you form a selection, in addition to forming a list, set those flags. Deselecting a layer not only removes it from your selection, but sets that selection flag to false.
Next, turn those strings used to indicate selected layers into indices into a random-access structure (ex: std::vector or even a plain old array if the size can be determined at compile time), like so (simplified):
... and turn shape.layer into an index (or pointer/iterator) to a layer. If you have no choice but to start with a layer string to identify which layer a shape belongs to because you are given string inputs initially (ex: from a file you are loading), then translate those strings into a layer index/pointer/iterator as you are creating the shapes from those string inputs. Use a hash table or at least std::set/map here (the string search on initial shape construction should be logarithmic or better) to convert those layer strings into layer indices/pointers/iterators.
If you need a layer selection list in addition to a layer selection state, then you can do this (pseudocode):
... Where your layer selection stores indices/pointers/iterators to layers. Both the select and deselect list insertion/removal can be done in constant-time (even during worst-case) without hashing overhead and while preserving insertion order if you get fancy with the layer selection and use a fixed allocator (this is a complex subject involving placement new, unions, and memory pools so I'll delve into it if desired, but omit it for the time being for brevity).
Now your main pseudocode code turns into something like this:
... or this if you use pointers/iterators:
It's hard to beat that in terms of performance as even the most optimal hash table cannot beat a simple indexed array access into memory you would still have to access in addition with the hash. Now if you can consolidate the idea of ""selected shapes"" and form selected shapes in advance through the process of selecting/deselecting layers, then you can do this:
... which could be even faster provided that the extra cost of forming the selected shapes list is compensated by reusing it repeatedly before it has to change. Note that you still want to convert those strings into indices in this case, because you don't want your ""selected shapes"" list to have to be anything more than a simple array. To form the selected shapes list:
... which is still even cheaper to form and access (due to spatial locality of a perfectly compact shape selection array) than a hash table thanks to that selection state we now store in layers.
This keeps everything cache-friendly and avoids expensive (relatively speaking) data structures like hash tables except during that initial string->index/pointer conversion part (which you only need to do when creating a shape from a string input). In this case, the only place that ever needs to do any kind of search (logarithmic or constant-time hash/trie) is when you convert those shape layer strings you get from user input into indices/pointers/iterators. Everything else is O(1) (even worst-case complexity) and doesn't even require hashing.
",1,30945464
30945712,"
I would suggest using a set instead of a list for the selected layers, that way a binary search can be performed to determine in shape.layer is in the selected layers, and insertion while preserving order is quick. Using a list would be inefficient for keeping the order required for binary search.
Another option is to figure out some hashing algorithm and just use a hash map.
",0,30945464
30809577,"
With stl, your code may be
",0,30805786
30806136,"
should just be
Because finding min and max values are independent.
For example, if minRow is 1000 and sum[i] is 2000 then 2000 is not eligible for min value. But it can be a candidate for max value.
",0,30805786
30806150,"
What looks like is happening is that in rowSum, When you're giving the row values to minRow and maxRow, you're using an else if() statement.
This is a problem because if the sums are in descending order, your program will constantly give minRow a new value, but never assign anything to maxRow.
Of course, this can give correct answers if the sums are in a particular order, but the results won't be consistent.
",0,30805786
30703542,"
You aren't returning a reference to the node you are looking for, you are returning a reference to found, which has automatic storage and will be destroyed when the function exits.
To fix this, you could make found a pointer, store the address of the node in it, then return *found; at the end of the function.
",3,30703440
30637328,"
This is probably best solved backwards. Define Path<End>::cost == 0 and reasoning backwards Path<State2,End>::cost==Path<End>::cost + 1 because there's a Step<State2,End>. 
Your PathFinder algorithm would need a list of all states to consider, though: it can't discover them given your definition of states and Step<>
",0,30635184
30545387,"
You should use a partitioning structure associated to your mesh, a bounding volume hierarchy is pretty simple to compute, lightweight and efficient (you may look at this page for various sorting algorithms). If your mesh is static, a kd-tree should be faster, but also more complex to build.
",0,30544272
30542016,"
I believe what you need to do here is override this method in your QItemDelegate subclass:
The problem with QItemDelegate's implementation of this method is at the end, where we see this method call (it's actually called in two places, but since they are identical calls I'm just showing it once):
It's that third argument that you'd want to change -- in QItemDelegate::drawDisplay(), it's hard-coded to always be an empty QVector, which means that all of the characters in the drawn text-string will be always have the same formatting.  If you could somehow get it to be called with a QVector<QTextLayout::FormatRange> that contained your per-substring formatting preferences instead, you would get the effect you want.
Of course, the devil is in the details.  If you don't mind hacking the Qt source code to fit your purpose, you could do that; but that would be an ugly solution since it would mean your program would no longer work correctly when compiled with a non-customized Qt release (and you'd have to re-patch every time you upgraded to a new Qt release).  
So instead you'd probably want to start by copying the contents of the QItemDelegate::drawDisplay() method over to your subclass's method, then modifying the copied version as necessary.  (Of course that has its own problems, since QItemDelegate::drawDisplay() references private member variables that your subclass doesn't have access to, but you can probably work around those.  You might also want to check with the Qt people to see if there are any legal problems with copying out a method body like that; I'm not sure if there are or not.  If you're not comfortable with copying it, you can at least look at it for inspiration about the sorts of things your implementation of drawDisplay() will probably also need to do)
",0,30520865
30521096,"
Essentially, I found that getting the QTableView to display rich text was a common use case that people on forums were trying to accomplish. Since this was a solved problem, I tried to see how I could leverage HTML.
First, I set up my custom delegate to handle rich text. Then I had an algorithm that went a bit like this:
This is, of course, extremely, painfully, unacceptably slow. It does work though, has the exact same effect as hitting ctrl + f. But, I cannot use it. Its a shame that Qt doesn't support something as basic as this. Oh well.
",0,30520865
53407928,"
My approach to that problem was to use the paint function from the delegate to render one or several positions from a cursor in a QTextDocument.
",0,30520865
30364478,"
How about this:
",1,30364406
30364488,"
Something like below would probably do the trick:    
",2,30364406
30364777,"
how about this.
",0,30364406
30367751,"
Using standard library:
Live Demo
",0,30364406
30292957,"
The algorithms is correct, or at least it gets quite close. There are minor technical issues. In step 4. one should save the proposition of a solution if it's better than the current one, and in step 7. return it, or say it was impossible to make a palindrome.
The main idea is to process words into cores and prefixes. If a core is a palindrome, then we need to match the prefix with other word. Trie serves as a ""database"" for processed strings, so with each new word, one can check all possible extensions. If words were kept separately one would need to compare prefixes of each word separately.
(Edit: I think there still is a small loophole, in case there are two words in a trie which starts the same, and the incoming one would make a palindrome with the shorter one, but not the longer, but I won't go into details. Handling it would complicate the algo but wouldn't affect complexity.)
It also is O(n*k). Adding and checking a prefix vs a trie takes number of steps proportional to the number of characters. So in this case this is bound by k. Just like tree operations are O(h) where h is the height of the tree. So in conclusion:

k steps.
takes k steps.
also takes at most k steps.
also takes less than k steps but we can bound it by k.
also takes k steps.

Steps 2 to 5 are done n-1 times.
Of course each step has a different dominant operation, so it is hard to specify the exact constant, but all of them are bound by k so the complexity is O(c*(n-1)*k) which essentially is O(n*k).
",2,30292434
37890310,"
There's a really interesting discussion of this in an article from Dr. Dobbs, way back in 2004.  The full explanation is a little long, but the general idea is:

Suppose you start with Lion, where the pivot is left of the actual word. I can calculate the center of the string, which is position two. The pivot is at zero, so the string is too heavy on the right, but at the moment, Lion qualifies as a partial palindrome. The ""dot"" at the pivot point matches the dot at the pivot point, so there is at least one correct character, albeit the same character. You now wish to prepend words that end with noil, attempting to convert the string to noil.Lion. I use  to mean any string of characters. If you're successful, then you need to locate words starting with  so that they can be appended to the string.

Note that he defines a partial palindrome as:

A string is a partial palindrome if, working from the pivot point outwards, either the left or right end of the string is encountered before a mismatch occurs.

",0,30292434
30112700,"
Your BinarySearch function can enter infinite loop in certain cases, e.g. in this case:
",0,30112462
29940363,"
First open an ifstream to open your file then check for the string:
",1,29940219
29837858,"
Looks like you're pretty close.  If you know how a linked list is searched, it is a similar process.
List:
A 2-3 tree is a bit more complex:
It looks from your code like you can handle this, no problem.
",0,29837749
29838001,"
You're off to a good start with your idea of storing the bishop positions in an array. This is a compact representation of a board state.
You'll have to correct your method of checking whether one bishop clashes with another. Bear in mind that two clashing bishops may be separated by a vertical distance dy and a horizontal distance dx such that dx == -dy. Therefore, you will want to compare the absolute values: the bishops clash if abs(dx) == abs(dy).
Now on to the general problem of counting the number of board states in which k bishops are arranged without clashing. You'll want to define a function that returns an integer value. Let's say that this function looks like
where currentBishops is a feasible placement of bishops and numRemaining is the number of bishops you haven't placed yet.
Then the solution to the problem is
where [] means that no bishops have been placed yet.
The count function can be implemented according to the following pseudocode.
In order to avoid an exponential explosion of recursive calls, you'll want to cache the result of each subproblem. This technique is called memoization, and you can implement it as follows.
The mapping of currentBishops should be one that doesn't care about the order in which you have placed the bishops. You can accomplish this by sorting the bishop positions or making a bitmap of the board when you compute the key for memo.
",1,29836750
29769300,"
Try the following
If you want to write the function yourself using loops then it can look the following way
The program output is
",6,29769248
29769501,"
}
}
",0,29769248
29648958,"
A fixed version of BinarySearch
But you may directly use std::lower_bound:
",0,29634947
29631901,"

int tmp = lastindex - firstindex;

Should be:
That is because you are looking for the middle of the indexes x and y which is (x+y)/2. 
Your code's behaviour should be unpredictable, possibly looping and causing segmentation fault.
",1,29631839
29632029,"
The midpoint between x and y is x + (y - x)/2, so you want
Using the slightly more complex expression instead of the obvious (x + y)/2 eliminates an overflow bug that is very common.
",1,29631839
29621651,"
You are allocating for an array. Check the notations.
Also you are using a keyword as a variable.(bool).
What have you done?
",1,29621581
29621728,"
Leetcode doesn't give exact code. It will have syntax errors or compilation erros. You have to fix them to make it work. In this case, following are the issues,
Another thing is that bool is a keyword, that is used to give true or false for variables. You have to use another variable.
",0,29621581
29608804,"
You have to iterate over elements of first list      and check is it there in second list using find function. if it finds the searching element ,  print it and break the loop.
if you just need to find first element of first container  in second container,
",2,29608520
29628712,"
You are searching for searchString as a literal string ""searchString"", not using the variable you read in the input from the user.
Should be changed to 
A few other things of note - 
You don't need the break after the return here, it will never get executed
Also if the searchString isn't found in your input file, the code will never stop executing, you need to break out of your for(;;;) loop when there is no more data to be read from the file.
",2,29605792
37998220,"
You have to decide at some point just how large you want your crawled list to become. Up to a few tens of millions of items, you can probably just store the URLs in a hash map or dictionary, which gives you O(1) lookup.
In any case, with an average URL length of about 80 characters (that was my experience five years ago when I was running a distributed crawler), you're only going to get about 10 million URLs per gigabyte. So you have to start thinking about either compressing the data or allowing re-crawl after some amount of time. If you're only adding 100,000 URLs per day, then it would take you 100 days to crawl 10 million URLs. That's probably enough time to allow re-crawl.
If those are your limitations, then I would suggest a simple dictionary or hash map that's keyed by URL. The value should contain the last crawl date and any other information that you think is pertinent to keep. Limit that data structure to 10 million URLs. It'll probably eat up close to 2 GB of space, what with dictionary overhead and such.
You will have to prune it periodically. My suggestion would be to have a timer that runs once per day and cleans out any URLs that were crawled more than X days ago. In this case, you'd probably set X to 100. That gives you 100 days of 100,000 URLs per day.
If you start talking about high capacity crawlers that do millions of URLs per day, then you get into much more involved data structures and creative ways to manage the complexity. But from the tone of your question, that's not what you're interested in.
",3,37998013
37998279,"
I think hashing your values before putting them into your binary searched list- this will get rid of the probable bottleneck of string comparisons, swapping to int equality checks. It also keeps the O(log2(n)) binary search time- you may not get consistent results if you use python's builtin hash() between runs, however- it is implementation-specific. Within a run, it will be consistent. There's always the option to implement your own hash which can be consistent between sessions as well.
",-1,37998013
37645360,"
The first thing you should do is define a data structure for the books. Something like:
Then you can overload the input and output operators 
and
Once you have this you can use any input stream or output stream (e.g. std::cout/std::cin or an ifstream) to read/write a book, e.g.
Actually your question is too broad and I can only give you some hints. You will have to learn all this from your lectures or some books. However, if I was a teacher, the above is the very first thing I would teach about C++. 
",0,37644954
37515207,"
If you don't have access to dynamic memory (so no heap at all) then your best chances are related to have this table sorted so that you can do a fast lookup in O(log(n)) through binary search.
If the table doesn't change too often and you don't need to resort it continuously then improvements should be significant.
Otherwise you should look into using a tree (to have O(log(n))) or and hash-map like structure which could reach O(1) but it really depends on your pattern of utilization of such data:

does the table need to be dynamic
how often you change it
how often you search for value
how large is it on the average case

Using a tree or an hash-map could be more tricky if you don't have access to dynamic memory though.
",1,37515143
37364652,"
Binary search only works on sorted arrays, and they need to be sorted by the same criteria which you use to compare them in your search. Your array starts out sorted by letter ascending, and your binary search searches by letter ascending, so this works. You then sort it by value, which scrambles the letters. You then do binary search by letter ascending again, which won't work because the array is no longer sorted by letter ascending.
",1,37364551
37360206,"
Here's my attempt at a fast solution -- on my 2.7GHz Mac mini it is able to find the locations of the 1000 ""substrings"" in 1357 milliseconds.  It does this by first building up an index of all the locations where each integer appears in the big vectors, so that for each of the substrings it doesn't have to search everywhere, but instead only in locations where that substring might actually start.  One caveat is that the index takes up quite a bit of extra RAM, and takes some time to build; so this may or may not be a practical solution, depending on your use case.  (but note that it only has to be built once, unless/until you move on to searching a different set of big vectors)
",1,37359299
37337716,"
After taking a closer look at reading text files in C++, I settled on this passable but most likely far from ideal solution:
This solution does include the heading and bottom line also, as I found that worked better. If anyone has a better solution I’m sure posterity would be grateful. 
",0,37333110
37227217,"
You are invoking undefined behavior because your for loop conditions are <=arraySize.  Change it to <arraySize.  On making this change, the code works perfectly for sample inputs.
By writing int arr[ arraySize ]; you are creating an array of 10 elements (i.e., from 0 to 9), while in the for loops, you start from 0 and move until 10.
Live Demo
",4,37227125
37221601,"
The algorithm you are proposing is not quite right - you should compare the range you are querying with the range of the node you are looking at, not the value of the node.
E.g., initially you should compare (-inf, 1) with (-5, 6), which is the data range of the tree (you can also use (-inf, inf) as the data range of the tree or any interval that encloses (-5, 6), for that matter), instead of the value 0. Recursively you should compare the query range with the range of the subtree rooted at the node you are querying at.
Also, the range update can be done while searching - when splitting at a node, the upper/lower bound of the left/right recursive call interval is the node value.
",2,37221232
37091020,"
The question is not entirely clear but what is stopping you from just doing:
Note that using <ctime> as above is not the best way to accurately time algorithms as the clock runs based on the processor cycle so can give different results based on whether it is at high or low loads. However, if accuracy is not a big issue then the above is ""fine"".
For a better timing facility look into the <chrono> header.
",0,37090937
37091666,"
@ArchbishopOfBanterbury thanks for your help! I did it like you suggested and it worked;
",0,37090937
36951003,"
To get a loop you should keep streams open instead of closing them after reading 20 lines.
As pseudo code that would be:
You would also need to pass correct, incorrect, counter by reference so that the GradeReturn can change their value and their by do the accumulation.
Like:
Further you shouldn't rely on being able to read exactly Nx20 lines from the files every time. A file could have, e.g. 108 (5x20 + 8) lines, so you code should be able to handle the with only 8 lines. In other words, don't hard code 20 in your function like while (counter < 20). Instead pass the number of lines to be handled and do while (counter < number_to_handle).
Something like this as pseudo code:
",0,36950902
36960930,"
One problem you have is you're trying to compare C-style strings with the == operator.  This will compare them essentially as if they were pointers to char, i.e. compare whether they point at the same location in memory, not compare the contents of the string.  I urge you to look up array-decay and c-string variables to understand more.
Specifically, if (PassFail(percent) == ""pass"") isn't going to do what you want it to.  strcomp doc, strncmp doc using std::string variables instead of c-style strings would all work, but it would be better simply to compare percent to a value, i.e. if(percent >= 0.70 directly instead of calling PassFail and comparing a string.
There are many other issues here also, you at one point call PassFail but do nothing with the return value.  The only side affect of PassFail is cout << endl, if that's what you intend, it's a poor decision and hard to read way to put a newline on the console.
Try asking your compiler for more warnings, that's often helpful in finding these types of issues.  -Wall -Wextra work for gcc, you may have to read your compiler manual...
",0,36950902
36826685,"
In normal circumstances that does not compile since you are declaring properly the linearSearch function, but not defining it. Besides, to call it use a pointer to the LSTArray, not LSTArray[].
Define linearSearch as:
And call it as:
You will also have lots of buffer overflows with LSS<something>[Length]; it's past the array size.
",0,36826075
36706186,"
No, just look at the array of length n, where all the numbers are -1 (your specified number). Now randomly select one position and substitute it with some other number. Basically your array looks like this:
Now there is no way you can deterministically find the position of your number 8 using O(log N) elements.

So no, in general case you can't do this. But if the number of specified elements is really tiny, I believe that you can modify binary search to handle this situation.
",5,36706120
36708559,"
It depends on whether you can afford O(N) extra storage, and an O(N) pre-processing step.
If you can, you can create an index of the meaningful elements (e.g., an array of pointers to the elements that aren't -1). That takes O(N) time/space, but once you have it, you can use if for a search of the real collection with O(log n) complexity, just like if you didn't have the ""dead"" entries at all.
",1,36706120
36706148,"
Yes. You will only add the complexity to search for -1, that will be less than O(log n).
You can use another array to map the position of -1 in the previous array.
",-1,36706120
36693351,"
If you want to use make_boyer_moore_searcher you should include the right headers, as explained in the reference page:
Then, as those not belongs to std, you should call them using:
In your code, also you are trying to use operator<< to print out an std::array of int (which you call string). You can overload it or use a loop instead:
With your data you should obtain:
",4,36692699
36693186,"
Remove make_boyer_moore_searcher and use just std::search. Test it
Edit:
In response to the comment, it is also possible to search a 2d array. In std::search elements are compared using operator==. So in this case you can make it work by changing the code to:
Test it
",3,36692699
36386747,"
Your student class represent a single student, I think it's better for the search function not to be a member of it, considering that you pass to it an array of student too:
Then you can call that with:
It would be even better to separate the output part and make the search function only return an index or a pointer to the element found (or not).
I agree with Ulrich Eckhardt about the included libraries.
I'd add that you should check somehow what the users input and I'd like to remember that's more correct to use:
",0,36385330
36253094,"
",0,36252290
36253174,"
A crude solution:
Example use:
",0,36252290
36181798,"
You can use the substring method:
http://www.cplusplus.com/reference/string/string/substr/
This way you select the part of the string between the position of the first question mark, and the position of the second question mark...
",1,36181288
36182078,"
",0,36181288
36182578,"
You can add any symbol of your choice in place of ?.
",0,36181288
36184016,"
You can decouple your finding algorithm, which is categorized as a stream compaction procedure, and your insertion , which is categorized as scatter procedure. However, you can merge the functionality of the two.
Assuming srcPtr is a pointer that its content resides inside the global memory and is already set to zero before the kernel launch.
A few things:

This kernel is just a suggestion on how you can do it. Here threads inside the warps collaborate on the task. You can extend the binary reduction and prefix sum over the thread-block.
I wrote this kernel inside the browser and haven't tested it. So be careful.
The whole design is not something new. Similar approaches have been implemented (for example this paper) and is mostly based on the work done by Mark Harris and Michael Garland.

",2,36164072
36125543,"
I don't know how you stored the IP addresses, but if you stored them as a String this is quite a slowdown.
As IPv4-addresses are 4 bytes, you could store the 'from' and 'to' addresses in a single 64 bit long variable.
If your list does not grow or has at least a limited size, you can store it in an array (long[]) for avoiding any object access overhead. Binary search should be fast enough for nearly all purposes (O(log n)).
But if your list is very long and the first byte of 'from' and 'to' are always the same, you can divide your ranges in 256 buckets in each all intervals with the corresponding first byte of the IP-address. In each bucket you can perform a binary search. This reduces the search by at most 8 compares (not much, but may be enough).
",0,36125377
36126048,"
My first suggestion is to use lower_bound on a ordered vector:
If you need more performance, you can implement a custom  binary search that compute the insertion point of a new element inside the vector. The insertion point is the position of searched section.
I edited my answer to add the custom search:
You need to handle the case of ip address lowest of all initial ip stored in the vector.
binary_insertion_point(initial_ip.begin(), initial_ip.end(), v, addr_comp());
",0,36125377
36223323,"
The best way is to chain 2 proxymodels.
I made something similar for table, but believe that for tree it will work the same way.
You create your class derived from QSortFilterProxyModel and implement filterAcceptsRow (here example with the usage of regexp):
Regexp you can set in one of your slot which handles search lineedit changing:
And in the tree code:
",2,36118911
36065973,"
It looks like your code is relying on short circuit evaluation. However, the way it works is that
first evaluates cond_a, only then cond_b in case this is needed. In this case, then, your code will only check whether the stack is empty after it checked the top, which is obviously a mistake. You should reverse the order of your two internal conditions.
",2,36063696
36000807,"
I would suggest you to implement TRIE instead of implementing binary search algorithm. For example: each letter will be node of TRIE. The time complexity to build TRIE is O(W*L). W is number of word. L is average length of the word.   When you find the word from TRIE it takes O(L).
",5,36000290
36000584,"
You can consider a simpler related idea: interpolation search: it parallels how humans search through a telephone book for a particular name, the key value by which the book's entries are ordered.

In each search step it calculates where in the remaining search space the sought item might be, based on the key values at the bounds of the search space and the value of the sought key, usually via a linear interpolation.
The key value actually found at this estimated position is then compared to the key value being sought. If it is not equal, then depending on the comparison, the remaining search space is reduced to the part before or after the estimated position. This method will only work if calculations on the size of differences between key values are sensible.

Under the assumption of a uniform distribution of the data on the linear scale used for interpolation, the performance can be shown to be O(log log n).

Practical performance of interpolation search depends on whether the reduced number of probes is outweighed by the more complicated calculations needed for each probe. It can be useful for locating a record in a large sorted file on disk, where each probe involves a disk seek and is much slower than the interpolation arithmetic.

But the same is true for maintaining adjuntive indices / buckets.
",2,36000290
36000600,"
What the others are suggesting, if you generalize, is construct a trie, and that's a good idea.
The advantage of a trie is you can use indexing for the first few letters, and that's faster than binary search.
Of course, you would unroll it.
Another idea you might consider is Bentley's unrolled binary search, which looks something like this:
where word is the word you're looking for, and dict is your sorted dictionary, and its size is 1<<17 strings.
It finds the dictionary entry you're looking for in 17 comparisons.
You probably have to pad out the dictionary to a power of two, by putting ""0x7f"" sentinel strings at the end.
An alternative is to make the indexing operation smarter, so any index over the size of the dictionary just gives you the sentinel string.
Keep in mind the comparisons are not expensive.
If two words differ in the first character, only the first character needs to be compared.
If they are the same in the first character, but differ in the second character, then only two characters need to be compared.
You don't compare the whole word until you're almost done.
",1,36000290
36000341,"
It would be the index of the first word that doesn't start with 'a'. Build a top-level index that gives the starting index of each character and use that to create the search ranges as needed.
",0,36000290
36000349,"
You could segment the word list into 'bins', every word in a particular bin starts with the same letter. Based on the first letter of the searching word, pick the appropriate bin to search within. This would only require a one-time preprocessing of the original list.
",0,36000290
36002302,"
You should use a Trie ADT to get good performance on search ops. Wherein, as soon as the user types 'X', all titles starting with 'X' are shown. This functionality would be very similar to what you see on Google, or YouTube, or Netflix. You can, obviously, put more/fewer constraints on the construction of the Trie to shape it however you please. Why Trie vs Array? Tries are faster. Read on to find out more.
Here is a Wikipedia article on Tries. An implementation of a Trie ADT in Java. An implementation of a T9 dictionary (like the good old days) in C.
",0,36000290
35790186,"
Set your pos operator to -1 rather than 0. 0 represents your first index and since you output that the element has not been found for pos == 0 condition, your code is failing. You should set pos to -1 initially and check that itself for not found condition, if an element is found at pos = 0, that means the element exists at the first index.
",3,35789980
35790241,"
First pos equal to 0 is correct value. Therefore set pos to -1 at the beginning and compare to -1 (or more commonly >= 0) when checking whether it was found.
Secondly, there are few items that should be changed because right now it's not that much binary search:

There is no reason to initialize mid before the loop, it's just temporary variable with the scope in loop block.
The condition for exiting the search is min > max, you don't need any additional counter, as it would run the loop always n times even if the value didn't exist. So change to while (min <= max) { ...
Last but not least, once you find the item, exit the loop immediately by break statement.

",3,35789980
35790253,"
I don't think a for-loop is the control structure to go for here, because you want to finish when you've either found the correct item or when imin and imax are non-sensical.
In the implementation given, you don't even stop the loop when you have found the item and just confirm the found item ""n-(number of iterations until item was found)"" times.
Furthermore, with C++ arrays and vectors being 0-based, having position == 0 as the marker for ""not found"" is a bad idea; you could instead use an item from http://en.cppreference.com/w/cpp/types/numeric_limits, or n (since the indices go from 0 to n-1).
In theory, you could use pointer arithmetic to make your array 1-based, and I am assuming you haven't; I wouldn't recommend it. However, you're code snipped is missing the actual definition of the list.
",3,35789980
35781021,"
I'm afraid Boost.MultiIndex is not good for this; take into account that each index (with or without a composite key) induces a linear order on the elements, whereas you want a 2D arrangement here. I suggest to take a look at Boost.Geometry's R-trees.
",1,35778119
35662160,"
Use strrchr() (reverse of strchr()).
Here's a manpage
",3,35662049
35662179,"
If you have something like const char *s, you can find the last character using strrchr
You can use res as a string, though it would share storage with s. You don't necessarily need to copy the result into a new string.  If the character is not present in s then you'll need to handle that case (check for null), in which case you wouldn't + 1 before checking.
",2,35662049
35662131,"
If you use a std::string then you can use std::basic_string::find_last_of like:
",0,35662049
35662147,"
Convert the character array to an std::string.  (Or read directly into a std::string).
Research the std::string::find_last_of method.  Also study the reverse iterators.
If you must use C-style character arrays, read up on the str*() functions. 
",0,35662049
35659899,"
The simplest idea would be to initialize the root node with the initial state. Then populate the next layer; write a procedure which generates the child nodes according to the blank space movement rules. You should be careful here; when the blank space is at the borders of the board, some movements would be invalid. In such a case, a sketch of A* algorithm can be drawn like that: Define your distance from the initial state as g(n). This may be the number of differently placed letters compared to the initial state, given the current state. Define a heuristic h(n), which gives your current distance from the goal state, which may be the number of differently placed letters compared to the goal state. Then in your current location in the tree, try to pick the next state, which minimizes f(n)=g(n)+h(n). I am not in a position to deeply analyze that right now, but I believe this approach may be much more efficient than brute force DFS or BFS approaches.
",3,35659570
35563789,"
As SergeyA mentioned in his answer, C++'s STL does not have polymorphic containers (opposing to Java or C# interfaces).
Regarding your requested function signature, look into STL <algorithm> header. There are lot of functions operating on some data, using two pointers (iterators) to the beginning and end of data block. For example,
searching for some value in [first, last).
If you really want to pass whole container to the function, you'll similarly write
",8,35563193
35563328,"
Luckily for us, there is no base class for standard library containers. The only place I know of where polymorphic inheritance is used in standard library is streams, and this is what earned them such a bad fame.
Standard containers are non-polymorphic, thus fast. You will have to make your function template to work with any container.
For example,
",3,35563193
35563728,"
Containers do not have base classes. They do not define an interface based on dynamic polymorphism. They define an interface based on static polymorphism. That is, they do implement certain methods in common, but they are not inherited from some prototype.
Therefore, you must use the standard C++ mechanism for static polymorphism: templates. The container itself must be a template parameter:
Of course, this will not prevent any user from passing types which are not vector, deque, or list. They could pass anything that fulfills the implicit static requirements that your IsFound function imposes.
You could pass a set for example, and it would probably work, to some degree. But it wouldn't be nearly as fast as calling set::find with the type.
",2,35563193
35265592,"
It depends a bit on which method you would like to search your model class with. Usually, I would implement a Qt::UserRole in your data() method. This role could either return your ID only or a pointer to your complete structure (using Q_DECLARE_METATYPE).
Then, you can either work your way through the model indices on your own, calling
or use methods like QT's match(.) and use Qt::UserRole there.
A third possibility would be to return the ID as if you would like to display it, but hiding the column in your view.
",1,35265467
35256221,"
I think you might want to use the std::distance on this one, i.e.
This way you can directly access the position of x in the input vector vec. If x is not in vec, the result will be equal to the distance between vec.begin() and vec.end().
",1,35255912
35167621,"
Try this function . i think it will work.
",0,35167360
34823364,"
Okay, so when you say two characters, I'm assuming that you are referring to delimiters. In this case you would have to use String.find() to find the position of the delimiters.  After finding the positions of the delimiters,  you can can use String.substr(index1,index2-index1) to return the substring.
Example:
",1,34822782
34343029,"
The reason for the about-constant execution times is that the compiler is able to optimize away parts of the code.
Specifically looking at this part of the code:
When compiling with g++5.2 and optimization level -O3, the compiler can optimize away the call to linearSearch() completely. This is because the result of the code is the same with or without that function being called.
The return value of linearSearch is not used anywhere, and the function does not seem to have side-effects. So the compiler can remove it.
You can cross-check and modify the inner loop as follows. The execution times shouldn't change:
What remains in the loop is the call to rand(), and this is what you seem to be measuring. When changing the data[i] == number to data.at(i) == number, the call to linearSearch is not side-effects-free as at(i) may throw an out-of-range exception. So the compiler does not completely optimize the linearSearch code away. However, with g++5.2, it will still inline it and not make a function call.
",3,34335447
34335767,"
clock() is measuring CPU time, maybe you want time(NULL)? check this issue
",0,34335447
34335914,"
The start should be before the for loop. In your case the start is different for each iteration, it is constant between the { ... }.
const clock_t start = clock();
 for (int i = 15000; i <= 5000000; i += 50000){
   ...
 }
",0,34335447
34292511,"
You cannot use binary search for unsorted array. Use linear search.
",3,34292458
34292499,"
Binary search only works on sorted inputs.
",1,34292458
34234632,"
Big O notation is considering the worst case. Let's say we need to remove all duplicates from the array A=[1..n]. The algorithm will start with the first element and check every remaining element - there are n-1 of them. Since all values happen to be different it won't remove any from the array.
Next, the algorithm selects the second element and checks the remaining n-2 elements in the array. And so on.
When the algorithm arrives at the final element it is done. The total number of comparisions is the sum of (n-1) + (n-2) + ... + 2 + 1 + 0. Through the power of maths, this sum becomes (n-1)*n/2 and the dominating term is n^2 so the algorithm is O(n^2).
",1,34234472
34234614,"
This algorithm is O(n^2). Because for each element in the array you are iterating over the array and counting the occurrences of that element.
As you see there are two nested loops in this algorithm which results in O(n*n).
Removed items doesn't affect the worst case. Consider an array containing unique elements. No elements is being removed in this array.
Note: A naive implementation of this algorithm could result in O(n^3) complexity.
",0,34234472
34234645,"
You started with first element you will go through all elements in the vector thats n-1 you will do that for n time its (n * n-1)/2 for worst case n time is the best case (all elements are 4)
",0,34234472
34055195,"
your current structure is assuming that the name starts at index 0 of the array. 
What I would recommend is check every char in the name array against the first char of the searched for name until you either hit the end of the name array or find a match. If you find a match then check the remaining chars in name array against the next char in the searched for string.
Because right now all you check for is if both strings start with the same letter.
To return the start pos of the name hold onto the index of the first match.
You can also use strcomp() if my suggestion was not at all what you were looking for.
",0,34055106
34032133,"
You have a memory corruption in insert1(). 
When you create a file name, you are adding 4 to the length of the name in order to be able to add "".txt"".  Unfortunately, you do not count the ending '\0' and this may cause a lot of collateral damage.  
Correct the length:  
I played a little bit arround with the corrected code, and it works as expected (I commented out a.activitiy() because it was not defined). 
Important remarks:
You are using variable length arrays (char file[len];).  This may work on some compiler but is no part of the C++ standard and is not portable. Better forget it.  Instead of using such char arrays and C style strxxx() functions, consider seriously using c++ std::string 
From the point of view of the design, it is not optimal to manage I/O or application commands in functions of the AVL class.  I/O is here more related to nodes and should be managed as member function of the node, or as overload of a standarad extractor. 
",0,34030382
34004183,"
You declared item as a std::string, and then you use item in the same scope as a type.
The simplest solution is to name your std::string variable something else other than item.
",0,34003471
33926955,"
LineNumbers is being modified by your loop going from 4, to 1, to -1.  The -1 makes your loop terminate too early so you don't pick up the first entry properly.
It seems like a homework problem, so I hope you can use this to direct yourself towards an answer.
",0,33926595
33927989,"
When using functions such as seekg, it is always best to open the file in binary mode, not text mode as your code is doing now.  In other words, you should be doing this:
The reason is that opening a file in text mode will allow end-of-line translations to be done.  This renders functions such as seekg, tellg, etc. anything between unstable (or lucky to work) at best, and in the worst case, useless for text processing.
When a file is opened in binary mode, the seekg and other family of functions  work as expected, since there are no end-of-line translations being done.  You will actually seek to the byte offset in the file that you specify, and not be thrown off by end-of-line translations.
Also, once you do this, the length of the data in the line includes not only the visible text, but also the invisible characters that make up the end-of-line sequence.  So your hand calculation of 57 is not going to be correct in binary mode -- it should be 58 or 59, depending on whether you are using Linux / Unix, or Windows, respectively.
",0,33926595
33941058,"
The problems relays on ANSII character Set. I set the project to Multi-Byte set and restructure the code to that selection.
",0,33901446
33813616,"
One possible solution is to use strncmp, which compares 2 strings up to the specified length to see if they are equal (stopping when end of either is reached or number of chars have been compared).
So, the code would be something like:
To improve the program, you can try not using a fixed size array, but read the data into a std::string.
",0,33813353
33787311,"
std::map is implemented as a R-B Binary Tree, so find is O(logN). There's no way to make this ""more efficient"". Searching by iteration is O(N) and incredibly inefficient, completely defeating the point of using a std::map in the first place.
I recommend you look up what a std::map is and how it compares to something like a std::vector.
",0,33787064
33712390,"
You can use the bounding boxes approach to narrow down the search. All you have to do extra is the following:

Find the closest bounding box (lets say it is the big one in your example)
Let r be the distance between the point and the closest bounding box and b the size of the bounding box. Find all bounding boxes that are closer than (r+b) from the point.
Use brute force to find the closest triangle among the remaining bounding boxes.

",2,33712140
33712399,"
I think you could use Binary Space Partitioning to handle the awkward cases like the one you described more effectively.
Essentially you'd have something similar to a k-d tree, where instead of having axis aligned splits, you could split along an arbitrary plane (commonly based on one of the existing edges in the scene).
The downside is that it will probably be slower to build the tree.
",0,33712140
33655174,"
I'm assuming by 'number' you mean find the index of this substring inside your original string?
Use:
Assuming that line2 is the string to be searched;
the find function of the std::string library returns the position of the first character of the substring that was found in your original string that was searched.
",0,33654854
33640236,"
You cannot do this:
empt is a local variable, which is destroyed after block finishes, so you have dangling pointers. One of possible solutions to keep a container of unnamed nodes somewhere in function (with proper lifetime) and add them:
and define:
in your class. You may use std::vector instead but you have to make sure that no reallocation occurs (enough size is reserved in advance)
",1,33640033
33634228,"
I guess CLucene is just dead.

Currently you can get CLucene in two flavors - one is the 0.9.21
  release, which has been proven to be stable over time, but is only
  compatible with Java Lucene 1.9.1. Another option is our current
  working copy on git, which conforms with Java Lucene 2.3.2

And according to this quote from sourceforge - you will never get MoreLikeThis feature, cause port of Lucene 1.x or 2.x is just too old.
Code: http://sourceforge.net/p/clucene/code/ci/master/tree/ (look at the commit date)
",2,33628342
42200731,"
You need a global regular expression based substitution. Here're three ways to do this without any explicit loops (sure there're ""implicit"" loops in regex replace codes):
Results:
std::regex needs C++11 features, and performs about twice slower than PCRE on simple patterns (see this answer), and I expect worse on more complicated ones, but doesn't require any additional libraries, as long as you use a C++11 compiler. PCRECPP is a PCRE C++ wrapper written by Google. PCRSCPP is my wrapper around PCRE that provides Perl-like regular expression based substitution capabilities, and hence is much more feature-rich than PCRECPP in this scope.
",4,42172674
42173730,"
Since you have the position and length you could use that to do the replacement, or if you just want to get rid of the error you can instantiate std::match_results with the non-const iterator (all the stdlib default instantiations use const).
",5,42172674
42152941,"
It's best to build algorithms from smaller building blocks. The standard <algorithm> library is a great source of such components. Even if you're not using that, the program should be similarly structured with subroutines.
For homework at least, the reasoning behind the program should be fairly ""obvious,"" especially given some comments.
Here's a version using <algorithm>, and std::unique_ptr instead of new, which you should never use. If it helps to satisfy the homework requirements, you might implement your own versions of the standard library facilities.
",0,42151244
42186760,"
There's no real answer because of the way the mode is defined. Occasionally you see in British high school leaving exams the demand to identify the mode from a small distribution which is clearly amodal, but has one bin with excess count.
You need to bin the data, choosing bins so that the data has definite peaks and troughs. The modes are then the tips of the peaks. However little subsidiary peaks on the way up to the top are not modes, they're a sign that your binning has been too narrow. It's easy enough to eyeball the modes, a bit more difficult to work it out in a computer algorithm which has to be formal. One test is to move the bins by half a bin. If a mode disappears, it's noise rather than a real mode.
",0,42151244
42052267,"
You should preprocess D. Try to insert all sequences of D into a prefix tree.
This way you can check if a sequence S of length n is in D in time O(n), which is optimal because at least you have to read S once.
",0,42051827
42011841,"
Your minimum variable is not initialised, which leads to undefined behaviour. It should be set to the first value in the vector:
Additionally, ending is off by one, which makes it pick 6 as the smallest value out of [6, 9, 8, 4].
So, ultimately, your code should look like this:
While irrelevant to the question, I advise you to use a tail call in recursiveMinimum, as explained here:
",2,42011527
42011925,"
The main issue is that you do not initialise minimum. Hence, comparison searchVector[start] < minimum might never become true, and minimum remains uninitialized.
As a quick fix, write int minimum = MAX_INT; instead of int minimum;. MAX_INT is the maximum positive integer value (defined in limits.h). So the values in your array will never be greater that this value, and your minimum search loop will work (unless there are other issues; but for that, please consult the debugger :-) )
",0,42011527
42010863,"
Since tuple generates a hash using all the objects its storing you cant do this with just the original map.  You could do:
Which you can use to store another map which you can use to lookup the tuple.
",2,42010548
42013635,"
You could make use of std::for_each to perform a linear search on your map.
The above code will print:
",0,42010548
41864141,"
Might be your problem, maybe not: This line is exacerbating floating point error: sum += v[i]-h; 
Floating points are only so accurate and compounding this error over a larger summation adds up. I would try using multiplication on h and subtracting that from the total sum of applicable lengths. Should be well within the range of the double precision format so I wouldn't worry about overrunning the format.
",0,41863976
41864773,"
Not sure to understand your algorithm but I think that can be done a lot simpler using a map instead a vector.
In the following example the map mp memorize how much (the value) strips are of a given lenght (the key).
An advantage of the map is ordered.
Next you can see how much you have to save (not to cat) and calculate the level of the cut starting from zero, adding 1 when appropriate and adding a fraction when neccessary.
Hope the following example can help
p.s.: observe that a is defined as an integer in the page that you link.
",0,41863976
41817821,"
The big data solution is to divide the rows of data into key and payload.  Instead of using the letter p for key's, consider using k.  That way, you can use p for payload.
The key contains the hash map, or multi-map if there are key duplicates 1.  These keys are indexed solely on the primary search key(s) Kn. 
The values of the hash map or hashed multi-map are positions into the payload file containing Pn.  Depending on the sparsity 2 of your payload data and other related factors, the positioning may be any of the following.

A range with a starting and ending byte or block index
An index into only fixed length records
The starting byte or block of a serialized object that self-disambiguates its length in some way

The details 3 of your expected distribution of search, insertion, deletion, and update operations and whether those operations will be done individually in real time or in bulk will determine what is the optimal protocol to use to add or remove a key and its associated payload.
When query speed is the most important factor, the entire key K and payload P may be regenerated periodically.  If a few nines are required for availability, your K and P may need to be double-buffered, similar to the use of multiple display buffers or ports in gaming display adapters.  (This is because the cost of devising and processing a reliable update mechanism may exceed the cost of doubling the storage capacities of the system.)
The key runs fastest and remains simple if it can be made lean enough to fit in memory.  Otherwise (in big queries) the keys would need to be distributed across the memory of multiple nodes of a cluster by some key division mechanism.  In this later case, the payload may also be distributed across RAID devices in a way that corresponds to key distribution.  If no cluster is available, as a last resort, the hash map can be implemented on disk 4.
In the search, once you identify your key, Kn, you can then retrieve your data range for Pn and construct the object (or objects in the case of a multi-map) from it.
Open the payload file for random access to P and call fseek, lseek, or lseek64, to location Pn 5.  These low level calls delegate the locating of the appropriate disk sector for any given Pn to the operating system, device driver, bus driver, disk firmware, and associated hardware.

[1] You can use templates for associative containers from your favorite library or use the std namespace's associative containers.
[2] Sparcity is the degree to which fields in your payload have values.
[3] Another detail is that, if you are building a library, you may wish to identify the difference (via types or status codes) between empty variable length values, unassigned values, unknown values, or indeterminant values.
[4] The design of on-disk hash containers is beyond what can be covered in a simple StackOverflow answer space.
[5] The man pages for these i/o calls and how to open a file descriptor or stream provide details of how to use random access i/o.  There is a plethora of examples online too.
",0,41817090
41786583,"
Yes, it's possible to do deletion on O(lg n) time on random element in a Heap.
How? Suppose this is your heap:
suppose you wanna remove 10, then (as this is a Min-Heap) you get the smallest child of 10 and put into his place, then you restart beginning from 10's smallest child (30) and brings 30's smallest child up (50).
If you heap is correctly built, then the properties will be held as this method runs. 
In fact, this is nothing more than a Heapify that doesn't start from the root.
",3,41785899
41787657,"
If I understand the question correctly, then you do not need to be able to look up items by value and you don't care what order they're in?
If that's the case then you should just put them in an array starting at the beginning.  If you have to delete an item in the middle, then just swap it with the item and the end and then delete it from there.
It's also easy to do this while iterating through the array.  When you delete an item you just don't increment the position, because the next item to visit was swapped into the place of the item you deleted.
",2,41785899
41676571,"
If you want to find all such triplets, nothing is asymptotically faster since the number of such triplets can be up to O(N^3).
UP: Hovewer, if you somehow have a guarantee that there're not so much such triplets (let's say you have T = o(N^3) of them), you can write a more efficient algorithm.
Let's iterate through all the elements of the array and try place current element in the middle of the triplet. To do so, we need to maintain two ordered sets of values: one of all the values to the left of current, and sencond - to the right. Here's the code:
The complexity of such solution is O(T + NlogN), which is much less than O(N^3) if T is small. The downside is that the triplets are processed in a different order.
",4,41676481
41457539,"
with the data structure of vector list, it's may very hard to have O(1) complexiy but O(n). because you must read the list at least once.  Bu if you do some pre process, and put them in map, you may get faster (almost O(1)) performance later in your program.
",0,41457344
41456252,"
Well, I saw you have a list and you are dealing with pointers.
If you want to do linear search in a record id, for example, you can do it like this:
you usually use object.attribute to access the attributes of common objects, but when you have a pointer to an object, you must do pointerToObject->attribute.
",0,41455928
41457387,"
You can write one if you want but there is no need to when there already exists libraries that do this for you. Since you are using a list structure I show this using a simple std::list. You could also change this to a std::vector and just do a simple for loop iteration using index notation since the speed of search through them is constant as opposed to linear. Here is one method of doing a search through a list linear.
Since linked lists are not associative they Must be traversed from beginning to end for every entry N in the list to either insert, find or delete. The time complexity here is linear. 
If you want faster time insertion time with large lists you can use <multiset> if there may be duplicate items or <set> if every known item is unique. These have instant insertion. If you want constant search and don't care about insertion time then <vector> is what you would want. 
",0,41455928
41459794,"
The normal answer would be: don't write a linear search yourself, it's called std::find_if. However, C++ expects that your datastructure exposes iterators. An iterator refers to a record (or the end of your list). You get the actual record by calling operator* on the record, and you get the next record by calling operator++.
Yes, this is similar to pointers. That's intentional; pointers are iterators for contiguous arrays.  That means you can call std::find_if on an array. But since you chose to implement a linked list instead of an array, you'd' need to implement your own iterator class.
",0,41455928
41428566,"
I am just giving a basic algorithm to do this.
1) Calculate the length of available float numbers. ( I assumed length is fixed ).
2) Have an array of the (length-1). with all zeros.
3) Then try to perform operation between the floating numbers.( Zero refers negative ).
4) If it was not matching to GOAL, then increment the number by assuming the array as binary one.
5) Repeat step 3 & 4 until it matches GOAL.
6) Even at end if it is not matched , there is no possibility.
Ex : Floating vector size is 5. Then the all the possible operations are
Step 2: 0000 -->  (1st - 2nd - 3rd - 4th - 5th)
Step 3: 0001 -->  (1st - 2nd - 3rd - 4th + 5th) (Incremented binary num)
Step 4: ((1st - 2nd - 3rd - 4th + 5th) != GOAL ) --> Increment and call Step3. So, 0010 
It will calculate via all the possibility.
",2,41427986
41428143,"
not sure if this conforms to your polynomial time requirement, but genetic algorithms tend to do pretty well in this kind of optimization.
also, as an implementation detail, since you are going to add up a large number of floating point numbers, you might want to look into Kahan summation to minimize floating point error.
",1,41427986
41428900,"
See if this is sufficient:
Now the above code sorts the array in descending order of the values given in the pairs. Note that it sorts based on absolute magnitude. So 10,8,-9 will be sorted as 10,-9,8. Since, after sorting the original positions change, keys are assigned to them, which are nothing but array index.
The solution array is the same as your solution vector.
If the sum is smaller than the goal, the absolute value of the current pair in the vector is added to the sum. Else the absolute value is subtracted.
",1,41427986
41430503,"
I don't see an elegant solution but... the following is based on a recursive function (a template function, so you can use it with double and long double without changes)
",1,41427986
41430509,"
We can think about a greedy algorithm, which gives a descent solution in O(n)  time. 
Algorithm : 
Let the array and goal be :
Now start iterating the vector from the first index, and greedily choose the sign, i.e. 
Now since we want the ValueTillNow to be as close to the Goal we will greedily choose ""+"" for first float. 
Now go similarly for rest index in array. Update ValueTillNow. Calculate the diff for two options i.e. ""+"" and ""-"" and choose the one with leads closer to GOAL. 
Time Complexity : O(n)
",1,41427986
41631247,"
Looks like an integer linear programming problem to me.
I would split this up in two linear integer programs, the first for going over GOAL, the second one for going under. Thus giving you the following two programs, where b_i = 0 stands for a - and b_i = 1 for a + in your ansatz.
Going over, thus minimizing:
Then apply the usual algorithms for solving the two LP and see wich solution fits better.
If you let the algorithms run to the bitter end, the problem is NP-hard. But there are algorithms that deliver reasonable solutions after a finite number of steps.
",1,41427986
41204492,"
You can achieve this by iterating over the elements of the image matrix and checking if the neighbouring elements correspond to the elements of the subimage you are looking for.
",0,41204398
40998118,"
You can swap ordinal and ID and store them in a map of maps:
This will allow you to find an element with ID given and minimum possible ordinal in O(log N) time:
After that, you can compare the ordinal of the object found to the threshold given.
UP: Of course, if your IDs are unique, there's no need in the nested map: you can just use std::unordered_map<int64, std::pair<int64, data_t>>.
",0,40997659
40997915,"
You could use Boost.Bimap if you want to index on values as well as keys. That way you can look up a pair in the map based on it's value. Without this or similar, this will have to be done by brute force (=> iterate over the map by hand).
Otherwise you could use std::find_if to help you find the pair with the ID you're looking for but it will be the same speed as iterating over the map.
",0,40997659
40998853,"
If the ordinal is strictly for maintaining the order and there won't be any gaps, I'd do something simple like this:
",0,40997659
40983126,"
I suggest you add some additional variables to make searching easier.  For example, create strings of the text in vertical and horizontal directions.  
By creating the strings for the vertical letters, the std::string::find can be used.  The vertical strings only need to be created once per puzzle.  
Tasks for the OP:  reverse search (see std::string methods), and diagonal string creation.
Edit 1: Search algorithm
Here is an algorithm that I use with searching these puzzles:
1. Extract first letter of key word.
2. Search text row for letter.
3. If letter is found, check neighboring letters for 2nd letter of key word.
3.1. If 2nd letter is found, continue in direction and search for remaining letters of keyword.  
This has served me well, especially for difficult to find words.  
",0,40982823
40946272,"
Well i think you can do something like this
The purpose of this is creating a map hold index of B. Then while iterating A you can increase the c value. So that after that you can check whether each element in C has value different than zero mean that A has hold the number of B.
You can use array instead of map if C starting from zero and increase by 1 for better performance. Make sure to check if a[i]  can throw out of bounds exception if you use array.
",0,40945950
40875881,"
Your code contains several mistakes. Let's examine them.
Here, you make no change on your array, because just the value of p[5][10] is changed. Furthermore, you access an invalid memory zone, because array indexes go from 0 to size - 1 in C++. So last index is p[4][9].
In C++, comparing two values needs two =, because only one is an affectation that results the if to be always true. A tip to remember : two values to compare need two =.
The same than before, you access invalid memory zone. And are you sure that j is valid, e.g less than 10 ? If not, you do double invalid access.
As search is an array of char, you do an input of only a single char there, which I think is not what you want and that can leads to segfault.
Your array is not good, a simple 1-dimension array is enough, not 2-dimensions. Furthermore, 42-54.. does a subtraction, and I think is not what you want.
There are others mistakes. But why not using C++ abstractions, like std::vector, or std::string ? Your life would get so much easier. But I guess you have an old teacher that never took time to learn C++ news, or that is not a good teacher...
As a beginner, I suggest you to read C++ Primer and Programming: Principles and Practice Using C++ to introduce you both programming and modern C++.
Good luck !
",2,40875220
40866103,"
Graph::DFSUtil should return a ""found"" flag, and a list of traversed nodes so far, which can be extended every time a ""found==true"" is detected.
",0,40865719
40855020,"
Basically you should iterate through each line of the file and check its contents. This can be done via ifstream like this:
The actual approach for matching the item depends on the complexity of the prefix.
For simple cases you could just use the string compare method. For example:
Or string::find and check the result for 0.
If the match conditions are more complex you could try using regular expressions. However, it depends on the actual format of the prefix expected from user.
You should also consider whether case sensitivity is an issue and either preprocess the compared strings with std::transform and toupper/tolower or write your own predicate to use with std::equal. For example:
As you can see there are many solutions for such a problem (and many more). Which one should be adopted depends on specific requirements and the handled cases for user input. 
",1,40854791
40854932,"
A solution using Boost
Traverse your file line by line.
Here is a snippet relying on std::ifstream and std::getline:
Predicate function boost::algorithm::starts_with
For a given line, use the Boost predicate function boost::algorithm::starts_with. if it returns true, then print the line.

Function starts_with
This predicate holds when the test string is a prefix of the Input. In
  other words, if the input starts with the test. When the optional
  predicate is specified, it is used for character-wise comparison.

A sample code to highlight this function:
",-1,40854791
40577629,"
You can look here and see that the complexity of find_if is linear.
It is because find_if is a generalized algorithm and it doesn't know a certain type of container it works with. So it can't use peculiarities of different containers to boost a search process and just checks all the elements to find the appropriate one. 
",2,40577569
40577613,"
Yes, linear it is.
From this ref:

Complexity
Up to linear in the distance between first and last: Calls pred for each element until a match is found.

where the prototype is:
And from another ref:

Complexity
At most last - first applications of the predicate

",3,40577569
40577610,"
Yes, it is linear in complexity.
The iterator argument is an InputIterator, which is unidirectional. The only conceivable implementation is to iterate forward over each element and check the predicate. Because the predicate is arbitrary, it is not possible to specialise the algorithm for different container types in order to improve algorithmic complexity.
",1,40577569
40474475,"
Start on the left of the list and compare the current number you see with the next one. Whenever the next is smaller than the current remove the current number from the list and count one up. After removing a number at index 'n' set your current number to index 'n-1' and go on.
Because you remove at most 'n' numbers from the list and compare the remaining in order, this Algorithmus in O(n).
I hope this helps. I must admit though that the task of finding numbers that are out of of order isn't all that clear.
",2,40474301
40474499,"
If O(n) space is no problem, you can first do a linear run (backwards) over the array and save the minimal value so far in another array. Instead of calling minimal you can then look up the minimum value in O(1) and your approach works in O(n).
Something like this:
Can be done in O(1) space if you do the first loop backwards because then you only need to remember the current minimum.
",0,40474301
40488255,"
Others have suggested some great answers, but I have an extra way you can think of this problem. Using a stack.
Here's how it helps: Push the leftmost element in the array onto the stack. Keep doing this until the element you are currently at (on the array) is less than top of the stack. While it is, pop elements and increment your counter. Stop when it is greater than top of the stack and push it in. In the end, when all array elements are processed you'll get the count of those that are out of order.
Sample run: 1 5 6 3 7 4 10
Step 1: Stack => 1
Step 2: Stack => 1 5
Step 3: Stack => 1 5 6
Step 4: Now we see 3 is in. While 3 is less than top of stack, pop and increment counter. We get: Stack=> 1 3 -- Count = 2
Step 5: Stack => 1 3 7
Step 6: We got 4 now. Repeat same logic. We get: Stack => 1 3 4 -- Count = 3
Step 7: Stack => 1 3 4 10 -- Count = 3. And we're done.
This should be O(N) for time and space. Correct me if I'm wrong.
",0,40474301
40230382,"
This is a good start. You started a loop to read the 1000 numbers into your array.
Don't you think this is a bit premature? You haven't yet finished the loop to read the 1000 numbers in the file, yet, and you're already searching the array, that hasn't been fully read yet. There's a very technical term for this logical mistake: ""putting the cart before the horse"". You need to finish the loop to read the 1000 numbers, first. And only then you can execute this second loop.
Ok, now let's back up a bit. You started the loop with i=1000. Now, right here, what is the very first value if i? It is 1000. Don't you see a problem here? The 1000 element array, ""linSearch"", as you know, contains values numbered 0 through 999. That's a 1000 elements total. With i starting off with a value of 1000, accessing the non-existent linSearch[1000] is undefined behavior, and a bug.
You could tweak the logic here, to get it right. But it's not even necessary to do that. You already have a perfectly working loop that reads the 1000 numbers from the file. And you know which number you want to search.
So, each time you read the next number from the file, if it's the number you're looking for, you just store its position. So, when all is said and done, the last position that's stored in that variable will be the position of the last occurrence of the number you're searching for. Simple logic. All you have to do is also set a flag indicating that the number you were searching for has been found.
And once you come to the decision to do that, you will find that it's no longer even needed to have any kind of an array in the first place. All you have to do is read the 1000 numbers from the file, one number at a time, check if each number is the one you're searching for, and if so, save its position. Then, at the end of the loop, compare notes.
",1,40230302
40230381,"
Since it's homework, I should probably be at least a little vague, and I definitely shouldn't use code.
You should not be nesting the 2nd loop within the first loop. It should be at the same indentation level as, and after the closing bracket for, the first loop.
Also, you shouldn't be searching back to 0 in almost all cases, but instead back to where you found the element in your linear search, or where you find it, and no further.
And yes, pay attention to what Beta wrote.
Also, shouldn't you break out of the loop each time you find what you're looking for?
",1,40230302
40159671,"
Well first I must say there isn't algorithm less than linear O(n) time complexity for your problem.
Of course you can try randomized algorithm like Las Vegas way of thinking. Pick a random spot from your array if lucky you found your char if not try again and store the wrong index.
Worst case is like linear search O(n) but purely lucky if you get it in few first tries it's way less. This kind of algorithm maybe is what you are looking for. On average it will find char maybe faster but remember if it still takes k tries when for sure k < n it is still linear time. O(k)
If you know more from your input maybe you can think of way to solve it differently.
Hope this helps 
",2,40145619
40134065,"
No need for loop
Have a look at other useful std::string methods like find_first_of, find_last_of, etc.
",1,40133811
40033632,"
If you find a period, then your next logical step would also be to search again, starting with the next character position.
However, if you review your code, you will not be able to find any place where it is actually searching again. There's no call to find() inside the while loop.
A while loop is not required at all. All you need to do is to call find() a second time, specifying pos+1 as the starting position for the second search, and check the results again. If you find another period, you can call it a wrap. Nothing is to be gained by searching for any remaining periods in the string. You have your answer.
",3,40033597
39956177,"
The problem is that you are iterating over a const std::vector<unsigned char>, but you try to assign an iterator from that to a non-const std::vector<unsigned char>::iterator.
A simple fix would be to declare the correct type for itr:
If you're using C++11, I would just use auto instead:
",2,39955819
39955887,"
Works fine with gcc-5.1, example here:
",2,39955819
39955998,"
Edit: The below is wrong.  The problem is that the code in the question doesn't actually show the problem.  TartanLlama has the right solution.
Edit2: Sigh: I was having a bad day when I wrote this.  There are times when the difference between char and unsigned char will cause problems - they are distinct types.  The reference to ""char defaults to signed on Windows"" however is misleading; it is true that whether char is signed or not is implementation defined (and on Windows it defaults to signed), but regardless of whether it is signed or unsigned, it is still a distinct type from either unsigned char or signed char.
Your problem is that std::string::begin returns an iterator to char, and your vector contains unsigned char.  I suspect you are on windows, where char defaults to signed.
The fix is to do a reinterpret cast (which in this case is safe):
",-1,39955819
39949668,"
Use std::lower_bound. Note that since your vector is ordered large-to-small, you should use rbegin() and rend() instead of begin() and end():
Demo.
",2,39949584
39888832,"
With STL it seems difficult.
You can use an interval tree:
http://en.wikipedia.org/wiki/Interval_tree

Specifically, it allows one to efficiently find all intervals that
  overlap with any given interval or point.

",1,39888704
39903868,"
I was going to simply reply with ""solved!"" but then I remembered about xkcd's Wisdom of the Ancients.
STL's set and multiset are tipically implemented as red-black trees. Interval trees can be implemented on top of red-black trees. This got me thinking STL's multiset could be used as a part of the solution. Multiset is necessary, instead of set, to handle key multiplicity.
So the first step is using multiset as a container for intervals. Internally, elements in multiset are sorted so we need to compare intervals. We can say an intervalBig is greater than another intervalSmall if intervalBig fully contains intervalSmall. 
By this point our solution is a multiset containing sorted intervals. Now we need a way to search this container. This is where STL's find_if comes into play. To get it working we just need our intervals to be able to compare themselves against each other.
To handle multiple solutions all that should be required is to iterate the previous solution given by find_if, since multiset is ordered.
Here is a solution in C++11:
This is effectively an interval tree in C++ with overlapping search. Search time should be O(logn) since multiset is ordered.
",0,39888704
39915410,"

I'm only worried about lookup, data is immutable after being acquired

I have 2 possible solutions on how to initially prepare the data so you can have a pretty fast lookup speed.
The first is using a the given position as key in a prepared std::map.
The second one should be slower in creation, yet provides direct access to the wanted data in an std::vector by calculating the index.
I haven't done any measurements in speed and both examples are not optimized in terms of memory management. 

Ex1:

Ex2:
",0,39888704
39820672,"
to search in this case use 
to get the index of interval you want to change and proceed. I solved a similar question on codeforces but in that i just wanted to tell the index where the number falls. 
",0,39820603
39821283,"
Here is a possible solution using std::lower_bound as @karan suggests; search is in log time but not the insertion if you use vectors.  
",0,39820603
39826638,"
Insertion into a sorted array data structure cannot be faster than O(N), so you'll need something else such as a tree, i.e. std::set or std::map. These classes have sorting and searching built-in. Their members lower_bound and upper_bound are suitable for finding intervals.
There are a few approaches to representing the intervals in the tree. You can define your own class interval or you can use std::pair. The easiest way is to use std::map<int, int> which is a tree of std::pair<int, int> sorted by the first member. I'll suggest a lookup table where the interval upper limits are the keys and the interval lower limits are the values.
map::upper_bound takes a number and returns (an iterator to) the first entry which is greater than it. This works well with half-open intervals: Instead of recording the closed interval [14, 25] which goes from 14 to 25 inclusive, use the half-open interval [14, 26) which goes from 14 to 26 non-inclusive. When you search for 25, upper_bound will see 26 and return the correct entry.
Keep in mind that this strategy won't check that the given number is greater than the lower bound of the range, so you'll check that manually after calling upper_bound.
http://coliru.stacked-crooked.com/a/bd30949018cb4a00
",0,39820603
39715706,"
You need to put the else part out side of while loop. Otherwise your function will only search for the first line.
",0,39715404
39716767,"
I was bored so I decided to do it too. I'll post mine, even though its already solved. (upvoted the question for the fun of solving ;) )
which is called under main(): 
Passing values by reference lets us make use of them in our original scope. Therefore the function can both give errors for debugging, and allow useful results for our scopes purpose.
Closing the fstream is not necessary, as leaving the scope will take care of that for us: see here
Hehe, almost like being at school ;)
",0,39715404
39467808,"
std::binary_search may help:
Demo
",3,39467350
39467487,"
I think using hash tables can improve the speed of comparison drastically. Also, if your program is multithreaded, you can find some useful hash tables in intel thread building blocks library. For example, tbb::concurrent_unordered_map has the same api as std::unordered_map
I hope it helps you.
",0,39467350
39503307,"
If you try to compare all the strings to each other you'll get in a O(N*(N-1)) problem.  The best thing, as you have stated the lists can grow large, is to sort them (qsort algorithm has O(N*log(N))) and then compare each element with the next one in the list, which adds a new O(N) giving up to O(N*log(N)) total complexity.  As you have the list already ordered, you can just traverse it (making the thing O(N)), comparing each element with the next.  An example, valid in C and C++ follows:
",0,39467350
39465152,"
My Final program after modifications. Thank you all for the help.
",0,39464546
39415575,"
If programming the solution in C++ is not a hard constraint, try find and grep

type f only search files
name only files ending with extension txt
size only files greater than 4096kb
replace ""whale"" with the desired regular expression.

",2,39415144
39446939,"
Don't just run your regex on chunks. You don't say which library you're using, but you want a library that you can stream the data to. The standard C++11 regex library apparently requires a bidirectional iterator as mentioned on C++ regular expression over a stream
However libsregex claims to offer a non-backtracking implementation, and has an API that you can call with each chunk, keeping the state from the previous chunk, allowing matches that span many chunks.
",1,39415144
39448681,"
Not portable, but load your file as a memory-mapped file. The target sequence for C++ regex'es can be an iterator pair, so you don't need to copy that file to a std::string. You therefore don't need to load the whole file in RAM at once.
Of course, if you have a really bad input, the backtracking might be horrible, but that is pretty much unavoidable. If your pattern is ab*c and you have 4GB worth of b followed by a d, then yes you'll have to backtrack all the way back to that first a. And your regex implementation might not be smart enough to notice that b* doesn't contain a.
",0,39415144
39322571,"
Because you have invoked undefined behavior by starting the search at index 10:
search(x, &list[10]) should be search(x, list).
...and what's with that whole else if in the loop. Why not just return -1 at the end of the function. And why have a match variable - if a match is found just return i.
",1,39322556
39302514,"
As @ PaulMcKenzie suggested, the error had occurred because I was writing under the std namespace, along with the algorithm header that includes std::binary_search.
",0,39302390
39285266,"
A much shorter answer:
The invariant is that end is always ""one past the end"" of the interval to search. 
Since the interval you want to search is beg .. mid-1, mid is the ""one past the end"" iterator.
",0,39284495
39284644,"
Let's say the numbers that you want to search in are in an array and they are:
At the start of the loop, start points to 11 and end points to 1 number past 99 and mid points to 33. In each iteration of the loop end points to 1 number past the numbers that will be used in the lookup.
Let's say you are searching for 26. If you use
end will point to 26 in the second iteration and 26 will never be found.
If you use
end will point to 33 in the second iteration and 26 will eventually be found.
",0,39284495
39284659,"
Let's run your code in a piece of paper and see what happens with both approaches; I will use this notation: 3.idx as the iterator that points to the element 3 from the input.
Let's run it:
Now with:
we would get:
STOP, did you see what happened? 
We didn't check if 2 was actually the key, but we should do so... ;)
",0,39284495
39150804,"
You can compare the return value with vec.end() to see if the find succeeded
",1,39150755
39127744,"
You should find the lower_bound of 0:
the resulting iterator will point to the earliest position where you can insert 0 without disrupting the ordering of elements. Similarly, upper_bound will return the right-most such iterator.
The runtime of the algorithm is O(logN)
",14,39127708
39092306,"
In your code, you have
where state inside of _rbfs is thus children.front().
And in _rbfs, you sometimes delete state. So children.front() can be deleted and then called with ->set_value. There's your problem.
Is there any reason why you calling delete at all?
",0,39092063
39055430,"
curiosity piqued, I wrote a test program (below) and ran it on my macbook.
It's suggesting that a naiive solution, based on a std::unordered_map (lookup time == constant time) is able to search an ip4 address table with 8 million entries 5.6 million times per second. 
This easily outperforms the requirements.
update: responding to my critics, I have increased the test space to the required 8m ip addresses. I have also increased the test size to 100 million searches, 20% of which will be a hit. 
With a test this large we can clearly see the performance benefits of using an unordered_map when compared to an ordered map (logarithmic time lookups).
All test parameters are configurable.
example results:
Test conditions:
Running on mains power.
",7,39054847
39054885,"
In these kinds of situations, the only practical way to determine the fastest implementation is to implement both approaches, and then benchmark each one.
And, sometimes, it's faster to do that than to try to figure out which one will be faster. And, sometimes, if you do that, and then proceed with your chosen approach, you will discover that you were wrong.
",0,39054847
39054924,"
It looks like your problem is not the performance cost of an if statement, but rather what data structure can give you an answer to the question “do you contain this element?” as fast as possible. If that is true, how about using a Bloom Filter?
Data structures that offer fast lookup (faster than logarithmic complexity) are hash tables, which, on average, have O(1) complexity. One such implementation is in Boost.Unordered.
",0,39054847
39055026,"
Of course you'd need to test with real data... but thinking to IPV4 I would try first a different approach:
In other words a master table of 65536 entries that are pointers to detail tables of 65536 entries each.
Depending on the type of data a different subdivision instead of 16+16 bits could work better (less memory).
It could also make sense to have detail pages to be directly IP entries instead of pointers to entries.
",0,39054847
38503782,"
Use std::lower_bound which returns first element that is greater or equal than input (I.e exactly what you need) or check its implementation if you want to implement it yourself. Your problem that you stop when you have found element, you should treat equal elements as if they were bigger.
",0,38503464
38503791,"
if you're using c++, you can use std::upper_bound method which will return exactly what you're willing to get (index of the first occurence of value greater than the given number)
",0,38503464
38419805,"
I'll try to rephrase the need: you want to store some data (bool visited) for every cell and for most of cells it will be the same (nor visited), so you want to save some memory.
Recently I heard about OpenVDB: http://www.openvdb.org/documentation/doxygen/
I haven't used it, but it looks like it matches the requirement - it stores sparse volumetric data and claims to be memory and time efficient.
",0,38410319
38413658,"
I think this should illustrate my idea of how you can solve your problem. You can also consider transferring the set to a vector once you are done with the initial processing (though strictly speaking both structures are similar in resepct to full iteration amortised speed)
",0,38410319
38419026,"
As you pointed out, Flood-Fill algorithm seems relevant to this problem.The problem you are facing is storing information about all the cubes whether they have been visited or not. 
You got two options : 

Keep Hash for each cubes , Space : 
O(1000^3) Time : O(1) : which u don't want
Maintain a list of visited cubes , Space : O(10000) Time : O( 100002 ) 
:  Everytime u need to check whether this cube has been visited just traverse the complete list of visited cubes.

That's just space-time trade off. 
P.S : I hope I got your problem correctly !  
",0,38410319
38044524,"
Was tempted to write just ""Yes"" in the answer and aim for the shorted accepted answer ever!
But to provide more information, under the most commonly used computation model in Algorithm analysis, any operations involving log(n) bits are assumed to be performed in O(1) time. What this effectively means is that unless your array is extremely large (e.g. 2^n) or the values themselves are extremely large, you are safe to assume that all operations can be performed in O(1) time.
As for your analysis regarding T(n/2), there's nothing else to say other than yes, that is correct, because you are simply halving the length of the array in each recursive call.
",1,38044395
38003169,"
All directories have these directories in them.
The '.' and '..' have special meaning ... if you don't need them, simply ignore.
Example: from Linux
",4,38003116
38003142,"
These are special linux link-like files that represent current and parent directory. Refer to this answer for more information.
",2,38003116
47508309,"
This is not trivial in C++. I concur with the suggestion to separate IO and the student type.
Also, separate the notion of a student record and a ""database"" of them (I'll use std::vector).
Parsing is the complicated part here. Some remarks are at your question, but let me extend the advice by showing how you would reasonably accurately parse it using just standard library features.
Live On Coliru
Prints
Or
Or
",1,47506505
47507676,"
First of all, It is not much clear what you are trying to achieve. Anyway I will try to highlight some points to you so that you can think over them and rewrite your code so that it makes sense to you (and everyone else).

In member function, search_by_name() you are taking input from user and comparing user-entered text with name member variable. If they match then you are unnecessarily reading 32 characters in sname buffer and doing nothing with it. Further you just print other member variables to standard output. So what was your purpose of using file I/O using c++ files streams? Same goes for function search_by_id().
You should ideally have provided constructor for Student class to initialize objects when you create them

Please consider above points and let us know if you still have more queries/questions.
",0,47506505
47355627,"
You are activating the eof flag when it get the last word, then, the function ReadWords::isNextWord() returns false and the loop is out and the last word is never printed.
 For example, when the word search is returned, you read the last one and enable the flag.
I recommend change the function isNextWord to
bool ReadWords::isNextWord() {return !(wordfile.eof()); }
",-1,47355384
47242374,"
Question you're looking for is : Longest Common contiguous subsequence
Solution using Dynamic programming :

Assuming I = len(V1) & J = len(V2)
Create a table len[I+1][J+1] to store common subsequence so far and track Longest subsequence so far in MaxCurrent 
Longest subsequence For ith element of V1 & jth element of V2so far is :

if V1[i-1] == V2[j-1] : (len[i-1][j-1] + 1) and update value in MaxCurrent
else 0

Max output is max (MaxCurrent, len[i][j])

Note : Base is len[0][j] = len[i][0] = 0
",0,47227622
47215541,"
It's not outputting anything because first == 0 and last == -1. Hence first <= last is never true and the loop body is never executed.
",2,47215459
47215610,"
you know what ? how can you even be using binary search if the array is not sorted properly to use binary search property ... and please , stop answering question like Jack meagher style, I hate answer that isn't directly addressing the problem , its kinda restating the question ...
",0,47215459
47216292,"
Simple
Change last = n - 1; to last = SIZE - 1;
Or calculate last = n - 1; after u have accepted the value of n
Also the array needs to be sorted!
",0,47215459
47216837,"
Figured it out. Now though the code was an example that I had found the for loop was not working correctly for me, so I got rid of it. And for iteration I implemented a do-while loop. However, the code the works now. 
",0,47215459
47134987,"
std::set is an ordered container. It's already sorted with the comparator you provided. Just use its own std::set::find member function.
With C++14 and above, you can even adjust the comparator in order to allow find to work with any type that is comparable to your elements, and respects the same order.
",7,47134953
46969498,"
The == operator compare two strings and return true if they are exacly equals.
If you want to use wildcards, I suggest to use QRegExp and use QRegExp::Wildcard as pattern syntax.
Example 1:
However, if you want to test only if a string contains a substring, I suggest to use bool QString::contains(const QString &str, Qt::CaseSensitivity cs) that can be faster.
Example 2:
See:

QRegExp
QRegExp::PatternSyntax
Wildcard Matching
QString::contains

",1,46968450
46912581,"
Company::getEmployees() returns by value, that means for comp->getEmployees().begin() and comp->getEmployees().end(), you'll get two iterators of two different temporary vectors which are copied respectively (and will be destroyed immediately with two dangled iterators left), the iterators don't belong to the same one vector at all.
If returning by value is your intent, then you should use a named variable, e.g.
or make getEmployees returning by reference if possible, .e.g
",2,46912498
46912588,"
getEmployees() return the vector by value.  That means it is a copy, not the actual vector that is stored in the class.  So when you do
The begin and end iterators belong to two different vectors that both go out of scope since they are temporary objects.
To use what you have you need to make getEmployees() return a reference to the vector.
",2,46912498
46955901,"
You may use
See the regex demo
Details

#include ""C:/Users - a literal string #include ""C:/Users
.* - any 0+ chars other than line break chars, as many as possible
\. - a dot
h"" - a literal h"" substring
$ - end of string/line (depends on where you use it and if you pass m modifier or not).

The (...) create a capturing group, and you may refer to this group from the replacement pattern using the $1 backreference.
",1,46902796
46915230,"
Thank you @Wiktor-Stribiżew !
For those who have a regular expression question Wiktor posted a very useful link to do your own testing, and try and solve the problem on your own.
(#include ""C:/Users.*.h"")$
Solves my searching problem.
I replaced my search with ""$1fixThis"" to give it a unique name so I could then do a basic search and replace to fix the quotes of my include paths.
",0,46902796
46892914,"
What if you kept one big string that has all of your strings in it, but with a specific delimiter?  find the index of your partial, substring from or to the index, then split on your delimiter.  You now have the index for the string.  Lather, rinse, repeat with the rest of the string (or use a regex to find all matches)
",1,46892663
46909843,"
Suffix trees and suffix arrays are useful when you want to quickly perform partial string matching.
",0,46892663
46809897,"
If you have a smaller file (like a few megabytes, or even a couple of hundred megabytes, depending on the amount of memory your system have) then read it all into memory, otherwise I recommend using memory mapped files. If the file is to big to be mapped you can use a sliding window or double-buffering algorithm to read blocks of the data from the file into memory.
Then to search for a specific sequence of bytes, you do a linear search through the contents of the file, looking for the first byte of the sequence you search for (in the case of 0x48656C6C6FA that's 0xFA) . If found then you attempt to match the second byte in the sequence (in the example that's 0xC6) to the next byte from the file, and so on until you have matched the whole sequence.
If the second (or continuing) byte doesn't match, you continue your search for the first byte.
This has O(n) complexity, where n is the number of bytes in the file. Unless you know beforehand that the data you search for is in a specific part of the file, that's the best you're going to get.

If the files exists on an SSD you can use threads to search, one thread per file. But not all 2900 files at once, that will swamp the processor. Instead have 4-8 threads doing the search (depending on the number of cores of your system), and as soon as one thread is finished with a file, then it takes the next.
Can't be used on a spinning-disk drive, as it will thrash the disk while the heads are seeking back and forth as the threads are trying to read.
",5,46809602
46810070,"
Speed: use a memory mapped file
Accuracy: use std::search using binary values.
e.g.
",3,46809602
46809931,"
For search strings as short as the ones you have (5 1/2 bytes apparently), the bottleneck will often be the disk I/O. I suspect that those 2900 files may be on a harddisk. That would translate to roughly 4 ms per file, which is quite decent.
Sure, the conversion to hex may be a bit clumsy, but given the 5 1/2 bytes (11 hex digits) it might not be entirely unreasonable. I.e. you might not get a major speed improvement if the HDD is the real bottleneck.
So to check, measure how much time you spend if you don't search in the 2900 fies, and just read them in. Don't even convert them to hex. No matter how smart the search algorithm, the time you'll need for disk I/O is a lower bound. If this isn't good enough, get a fast SSD.
",1,46809602
46810260,"
For a faster string search algorithm, take a look at the Boyer Moore search algorithm. Boost (and c++17) has such an implementation.
Also, avoid converting the file into hex (std::strings can contain '\0' characters).
And if you file IO is limiting, memory mapped files might be the way forward.. 
",1,46809602
47003807,"
While this is probably a storage bottleneck problem there are string search algorithms that can be significantly faster than linear, for example Boyer Moore (described at https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm ), they do require processing the search pattern and ave some memory overhead compared to a linear search.
The basic idea is to know how many characters can be skipped based on what you find at a given index. (i.E. start at fileData[patternLLen-1] and if the character isn't even in the search pattern you can next look at fileData[patternLen+patternLen-1] and so on.
The longer your pattern the more likely such an algorithm is to be an improvement over a straight linear search. The boost library already has implementations of several such improved string search algorithms (found in boost/algorithm\searching/).
",1,46809602
46699915,"
Your AddtoInv() function can be simplified to this:
That being said, getting crashes on delete, and weird results from showInv(), implies that you are not managing your pointers correctly.  Such as if you are destroying objects that are stilling being pointed to by the inv vector.  But you didn't show any of the code that is calling AddInv() or otherwise using the inventory, so we can't help you diagnose any issues you may have in that code.
",0,46699314
46391795,"

Linear search. This will take O(n). It should be good enough if the array size is in the range of thousands and millions.
If you do search operations more often. You might want to convert your array into a hashtable. Building the hashtable will take O(n) at first, then every search operation will take O(1). Solution 1 will take O(n) for every search operation you do.
If the array is really large you can utilize multiple threads to search the array concurrently. Divide the array into parts and each thread searches its part for the value.

",9,46391683
46391723,"
Just a standard linear search. Start from the start, and search till the end (in the worst case). 
If you have no guarantees about element ordering, you'll need to check every element. That means the best complexity you can hope for is O(n). Under these conditions, this would be the answer regardless of the size of the array. 
",2,46391683
46285172,"
Array start with 0 index.so make sure for N elements your loop must start with zero index.
Similarly, for same reason assign beg '0' value and end 'N-1' value.
",3,46284068
46284244,"

Arrays are 0-based.
Arrays are not variable-length in C++.
You have a wrong update here:
The end is non-inclusive.
You will also want to keep going until (beg<end) not beg<=mid - otherwise mid will simply equal both.

Here's C++ version that fixes all of the above and uses iterators instead of indexes. Iterators remove the ambiguity (base-0 vs base-1) and make it very explicit that a range is [begin, end), by contract.
Live ON Coliru
Prints
",1,46284068
46284181,"
Problem 1
Your program has undefined behavior due to accessing a using an out of bounds index in the following loop.
That loop needs to be changed to use a 0 based index.
Problem 2
For similar reasons, the initial value of beg needs to be 0, not 1.
Problem 3
You are comparing with values of a[mid] but you are outputting mid. The output also needs to be a[mid].
Problem 4
needs to be

With the above changes, the program works as expected in my environment. Here's the updated program:
See it working at https://ideone.com/wgF2IS.
",0,46284068
45997856,"
I have done this in C this way. I think you will understand my idea from the code. (Note by nos: this algorithm is known as Trie)
Max 16 iterations to find any unsigned long long key. This code is 100% working and was tested, except freeing memory from the top variable.
UPDATE. Declaring nodes as an array (suggestion by HolyBlackCat).
UPDATE. Increasing algorithm speed (suggestion by Serge Rogatch)
",3,45993688
46007762,"
As an interview question,  it is reasonable to consider the impacts of coding goals.
Consider 

hash suggested by @PaulMcKenzie
A Trie suggested by @Serge Rogatch and answered by @vadim_hr
Huge arrays char *even[18446744073709551615u/2+1]; char *odd[18446744073709551615u/2+1];

The requirements ""set should be O(1), get should be O(1)"" puts aside the hash solution as it is not truly O(1).  Still a hash can have excellent average speed and resource rating.
Yet there was no memory efficiency requirement, nor memory limit, nor set size (other than an implied < 100 million).
A naive implementation of #3 (Arrays) would certainly exceed real memory budgets, yet it is O(1), in theory.  Still not a real candidate even though it meets the stated requirements and within memory limits (which are theoretically unbounded).
The issue with a Trie is its bottom leafs are often a wide array of NULL pointers - making this approach memory intensive.  Yet if the set count (unknown) is small this is not a concern.


Put in mind that we might call set 100 million times

This point is not reflected in a trie implementation as that reminder is to also consider over-all efficiency.  A trie can be very memory inefficient with a high set count and slower, on average, than a dynamic hash - even with its O(1) get/set.
This is where the interview part comes in to not just provide a technical solution that meets the requirements, certainly a trie, but to presents its advantages (O(1) for get/set) and its short-comings (memory hog), average speed slow than a hash.  Thus to insure your customer (the interviewer in this case) is apprised of other reasonable solutions that may better meet the overall objectives.
",0,45993688
45929496,"
string::length is a function, so call it.
",1,45929475
45360464,"
compiled with g++ graph.cpp -std=c++11 -o graph.o -l boost_graph
produces the ouput
",2,45357757
45166896,"
Since the first loop condition is j < col, the right hand side of this condition is positive. i corresponds to the current row being checked, and hist[j] is the row of the queen on the j-th column. Thus this checks if the two points (hist[j], j) and (i, col) lie on either a ""forward-slash"" ( / ) or ""back-slash"" ( \ ), diagonal, by checking if the horizontal and vertical distances are equal. The abs is to allow both cases to be checked in one go.
",0,45165858
45065238,"
The best I could do (see results on quick-bench) was this,
Which is basically what geza described, but I added a special first iteration in order to align the data for the main loop. Loads that cross cache line boundaries (or page boundaries) are slower, this gets rid them. The overhead isn't worth it for small distances (with not enough slow loads), on the other hand it should be faster again for tiny distances (less than 4).
I've also tried flipping the condition (linSIMD5), using (a >= b) = !(b > a), with non-destructive AVX encoding that would allow merging the vcmpgtd and the load (reducing µops in the fused domain), but quick-bench doesn't do AVX so just ignore the result and try it yourself.
There's an AVX2 version at the bottom, I haven't tried or benchmarked it. It doesn't use the load/compare-merging trick (which may or may not help) but it would be easy to adapt.
",1,45051401
45057931,"
Use larger batches in the loop in the SIMD case.
For example, use compare on 4 SIMD registers, then put the resulting 16 compare result into one SIMD register. Then put a branch on this (and break from loop, if a match found). This way, you will have:

less branches
more possible parallelisation opportunity for compiler & CPU

After you break from loop, you need to find the index of the match among the 16 possible entries. You can do it with SIMD or whatever method you prefer.
This way should be faster than your current implementation (for large arrays).
",1,45051401
45020415,"
Your chain of if-then-else conditions builds a ""poor man's"" trie data structure. It is efficient, but it is probably an overkill in your situation.
A better approach is to use std::unordered_map, a hash-based container, which retrieves values associated with keys in O(k), where k is the size of the key (in your case, max length of the string).
Note that the time is not dependent on how many items you have in your map. This is different from std::map, which needs O(log2n * k) time, where n is the number of items in the map.
",1,45020315
45022218,"
How fast do you really need it to be?
The simplest way is to use an array, assuming that your enums are ordered 0 to n-1:
If you want to be fancy, you can build a custom hash function h that you verified to be injective on the domain of valid enums, then order the array with regards to h. Then the parsing of a string will be equivalent to hashing with h, doing a binary search, then 1 more strcmp with the target entry, if any.
",0,45020315
44704526,"
This is not a depth first search.
It is a recursive tree traversal... dive?
The logic of which move to make is built into the algorithm, and it cleverly uses recursion to handle each sub-tower transition.  There is no searching here.
The algorithm works in the following way

End of recursion:


when there is one disk remaining, move it to the destination peg
this is the end of each sub-tower move

Recursive logic:


move all disks above the one we are interested in to another peg
output the move command for the disk we are interested in
move all the disks we moved before on top of the disk we just moved.


The way it does this, is by the clever (and confusing) manipulation of the peg references.  it remaps which are the source and destination pegs when it makes the second recursive call.
Another thing to note: 
There is no persistent state in this algorithm. The only state each layer cares about is the state of n and only then if it is 1 or not.  On function entry, the state of the current layer (on start peg) and all layers above (also on start peg) is known and the state of any disks below the current is unneeded.
This is why nothing needs to actually be moved; as the state is known, the knowledge about the changes in state can be encoded into the algorithm  (and are, by the changed order of the pegs passed into the recursive calls). There is no need to base decisions off the current state, and so no need to effect a state.
",0,44701176
44703300,"
This isn't a depth-first search, because we know which move to make each time, so there's no choice. You can think about it that way. Nothing more than that.
Look, in the case of Depth first search, what do we do? We go deeper and try to find the correct way to go. But here, can you show me one move that was unnecessary? There isn't any. 
So this is a simple recursive approach, where we solve smaller instances of the problem, and then construct the solution for the larger one, simply, from the smaller ones' results. That's it.
",1,44701176
44563950,"
Your code works fine, but you don't check if the file could actually be opened.
Modify your code like this:
The reasons why the file could not be open may include:

the file does not exist
the file is not in the directory where the executable runs

",0,44563664
44564116,"
Make sure the file is opened and the line that is returned by getline has the correct value, also check that the file has UTF-8 encoding.
",0,44563664
44564297,"
",-1,44563664
44449731,"
To begin with, the first version does in the worst case n iterations, and, in each iteration, does a constant number of operations. The second version does in the worst case n / 2 iterations, and, in each iteration, also does a constant number of operations, but a larger constant. Thus, there is no reason to think that the first is O(n) and the second is O(n / 2).
In any case, O(n) = O(n / 2). By the definition of O, O(n) means that there is a constant c1 such that for every n > n1, 
f(n) < c1 n.
Similarly, O(n / 2) means that there is a constant c2 such that for every n > n2, 
f(n) < c2 n / 2 = (c2 / 2) n.
Since for any n > max(n1, n2) the inequality holds for c1 = c2 / 2, each of these two implies the other one.
",3,44449632
43980162,"
If your file is too big then just do it manually as you suggested yourself using binary search.
First, find out what's the file size, value of the first timeStamp and last timeStamp. And then simply position file read pointer to the middle of the file and then read char by char until you find { and from that point read your value and timeStamp. Then based on timeStamp that you read you can decide in what direction you need to continue your ""binary"" search.
",1,43979988
43980565,"
rapidjson supports sax parsing.  This doesn't load completely in memory and makes more sense than parsing text.
",1,43979988
43980078,"
Either parse the text file yourself (which could be faster if you can optimize for a very specific format), or search for a streaming JSON parsing library.  Then break out out of the parser when you find the element you want.
(Note that asking for a recommendation of such a library is explicitly off-topic for Stack Overflow).
",0,43979988
43713140,"
std::string has the capability to search for substrings with its member function .find(). 
With it, your entire function can be written in a couple of lines.
Here, std::string::npos is a sentinel value that is returned by find in case the string didn't contain the subsequence (otherwise it will return the index of the character where the subsequence starts).
If you have access to C++17, you can also use std::search which allows to specify the algorithm used. The linked reference has an example where a substring is searched for with the Boyer-Moore algorithm.
",1,43713067
43699904,"
Fairly common mistake with recursion:  You need to return or process something with the return value of the recursive call.  In your case, that's the call to searchNodeString in your i loop.  At that point you need to determine if you're done recursing (and can return right away), or you need to keep searching thru your values.
How do you handle not finding your val?
Also, your recursive call is wrong.  You don't want to change the value of subtree in your i loop (or anywhere else in the function).
",1,43699857
43652579,"
Read further in the OpenMP standard and use tasks for this. They suit recursive problems much better than using nested parallelism.
",0,43641214
43423675,"
You have multiple bugs in your implementation.
Your addWord function isn't correct.
This one should be better:
The other bug you totally missed: ""jean-pierre"" contains non a-z characters :) and your getIndex will fail for any char that's not within [a-z] range.
The other points:

do not hardcode values like 26, because if you need to update your
range from [a-z] code elsewhere will silently fail.
use assert to check input assumptions.

Something like this:
",0,43422341
43420792,"
You need to check your binary search implementation, as it's not correct. Here's improved version:
While learning it's better to code algorithms manually, but you should know that C++ provides implementation for common algorithms like binary search or quick/merge sort.
For example, you could define your value-pair struct vp that holds value and position in original array:
then you can sort array of value-pairs using std::sort:
then, you can use lower_bound or upper_bound to do binary search in your array of value-pairs:
But you'll need to interpret properly returned value to figure out if value was found in the array or not.
",0,43420250
43362816,"
You could use as surface blocks the following struct
Then you could mark occupied any squares with cracks in them by:
Also, you could create a ""territory"" around your crack, which would be full of blocks with 
i.e. pointers to the crack that causes it to be unavailable (or NULL if free)
Therefore when you start the game you can simply start constructing the territory for each crack, until a conflict happens(a territory is already occupied) in which case, you can move the crack away(don't forget to move its territory).
Therefore, you would simply have to check if a crack is in the territory of another one, and if it is you should move it (just search for empty squares around). When moved successfully to an empty square (or exceed move limit), you can now create its own territory. If while building the territory you come across a square with territory already, simply use the pointer to move it (and its territory). This would help you not need to compare each crack with all others, and make the process much more efficient. Also, if you don't want to move a crack more than once you could keep track of whether it has been moved with another boolean, and you can determine the best direction. Just throwing some thoughts out there. Hope this helps!
",0,43361993
42971854,"
Since you are doing enough insert, delete and search operation, I would recomment you to use Hashmap/Unorderedmap rather than only vector. We would be able to do those operations in O(1) time complexity.
Check for those examples:
http://www.cplusplus.com/reference/unordered_map/unordered_map/
",0,42971739
42972257,"
Do the same for the other functions just replace the function arguments with with the right fields from SPerson in the comparaisons at the line that contains the return keyword
",0,42971739
42971858,"
This looks good for you?
",0,42971739
42872965,"

I simply use std::find, but I can only return the first position.

Because you always start your search at the beginning of the container.
But std::find can search any range, not just a complete container; so instead, just start each new search where the last one stopped.
Here is an example based on your existing code:
Observations on this specific program:

start_it is the iterator where every search starts. It is initially begin(vec).
The loop continues as long as start_it has not arrived at end(vec).
If the vector is empty (begin(vec) == end(vec)), then the loop is never entered at all.
std::find returns an iterator the the found element or to end(vec).
If the element is not found, then the loop will end because start_it will be end(vec).
If it is found, then the next loop iteration will start the std::find search one element past the last result because of the ++start_it; line.
Because you will eventually arrive at end(vec) anyway, you need to explicitly remember if at least one search was successful, hence the boolean variable. That's because you want special handling for the case when nothing is found. If the goal was instead to simply print nothing if ""a"" is never found, then you would not need the boolean variable.

General coding-style observations:

auto is a great way to remove the need for spelling out complicated type declarations without sacrificing type safety.
Prefer the non-member functions begin and end to the member functions.
Do not use using namespace std;.
Include <string> if you use std::string, or else your code is platform-dependent for no good reason at all.
Use '\n' instead of std::endl.


Personally, I don't think a std::find/std::distance-based solution is a very good idea here. For the sake of code clarity, I'd probably use a plain old for loop like this:
Note that vec.size() can and should be replaced by size(vec) in C++17.
",2,42871932
42872014,"
this code works for me:
Edit: sorry didn't read the question carefully. ;)
Edit: thanks for the feedback, this is warning-removed my code!
",-2,42871932
42887412,"
I figured out the code. I need 2 more arrays:

prev: storing the previous positions of i indices on S. Initially prev[i] = prev[i - 1]. When we find a match at the i + length(T) position, we set prev[i + length(T) + 1] = i - 1 (i.e We point prev of a new position i to skip the entire string T).
jv: storing the value of j at each i position on S.

After deleting all T in S, we use prev to reconstruct the remaining string. The overall complexity is O(n m).
Here is the whole code:
",0,42818267
42789590,"

std::map or std::unordered_map or their multi-counterparts all are built up the same - they map a key (first template parameter) to a value (second one). If you want to get O(1) (unordered) or O(log(n)) (map) behaviour, you need to define as key that data type you want to get a value for.
As you want to find an integral value for a given string, the way to go in your case is std::unordered_map<std::string, int>.
A counter-example would be looking up names for error codes, there you typically have a specific error code returned by a function (or placed in errno) and want to get a string value for e. g. for printing the error to console. Then you'd have std::unordered_map<int, std::string> (provided you could not store the error strings in an array because of error codes being too far distributed...).
Edit:
Defining your own hash function is that kind of premature optimisation Konstantin mentions in his comment - std::string provides its own hash code function, which should fit well for most of the use cases. Only if you discover that your hashing gets too slow, try to find a faster way.
As all your strings are hard-coded, you might want to have a look at perfect hashing, e. g. in the gperf variant.
",1,42789296
42789792,"

Ans : Yes , you can use string as a key or a int using your own hashing function or you can use Rabin–Karp Algorithm.
Ans : Yes, you can but consider about the hashing collision.
Ans : std::unordered_map -Average Case - O(1) but in worst case O(n) 
You can use Rabin–Karp Algorithm.It takes  O(1) time.

",0,42789296
42604303,"
As stated in the comments of the question, I am not going to help you entirely as this is an assignment problem. Here is the starting point to do your work. Start looking to the clock() library function of c++ in the header time.h. That should do your work.
",0,42603965
42560321,"
You could use std::set_intersection:
See the reference
Please note that it is required that the two vectors are sorted using the same sort function prior to using std::set_intersection because it relies on comparing elements using operator<
Additionally you could use std::includes 
OUTPUT:
Here is the reference page
(the example above is direct from the reference)
Either one could do the job depending on what you are trying to do.
",3,42560182
42477766,"
Here map returns an iterator to it if found, otherwise it returns an iterator to map::end 
",2,42477384
42482454,"
There are multiple ways you can accomplish finding a key in a STL(Standard Template Library) Map. You can either use methods already provided by the STL library or you can use your own methods to get done the same task. I will try to provide few tips that will help you ease your solution.
1-)As already mentioned by the previous post, you can define an iterator of std::Map and assign result of the find function to an already defined iterator. However, sometimes declaring iterators can become messy. For example, if you ever happen to define a nested map object 
In such case when you want to define an iterator of above type, you will have to declare,
Having to spend such much effort just to be able to declare an iterator is insane and time consuming. Fortunately, C++11 came with the auto keyword which automatically deduces types at compile-time. This is the only place where I have found auto keyword to be most beneficial. With auto keyword, 
is all you need.
2-)Iterators gives you the illusion of pointers when pointers are used on one dimensional consecutive data types such as arrays. However, an STL container may not distribute data consecutively on the memory (linkedlist, binary trees are typical examples), rather they can be all over the heap and stack. To give the illusion of pointer arithmetic and use iterators are useful abstractions. 
Range-based loop from C++11 can be a good substitute for iterators. 
In this case kv will contain key-value pairs and be type of std::pair.
3-)You can use count method of std::Map the check whether a key exists within the map. Difference between count and find is count returns a numerical value whereas find returns an iterator.
",0,42477384
51266772,"
You can still use std::find from <algorithm> for that. An input iterator is a concept that is also modeled by by pointers, so you can use pointers as the arguments for std::find as follows:
",3,51266644
51278488,"
You can use the non member begin() and end from the STL:
It returns pointers to elements of the array, much like Ton van den Heuvel answer.
Also, don't forget std::array, which is a lightweight wrapper arount a simple array:
",1,51266644
51181132,"
In addition to my comments, the usual pattern for converting a number to base B is of the form:
Complete answer is then:
",1,51180011
51177920,"
As mentioned in the comments, ensure that you properly call str.substr(); you need to pass in the starting index of the substring and its length, not its ending index. 
So instead of:
Make sure you pass in the length:
",1,51177659
51106210,"
in 
you use i (int var) but you never define i = 0 and use i++. Var i contain ""random"" number and program fail at compering search[i] == line[i], becouse i is bigger than 20.
also, at the end of the line, there is no ',' but '\n'.
try this:
if you have question about code ask in comment.
",1,51105231
51064600,"
The construction of the std::regex object takes a lot of time because the regex input string is compiled during construction. So construct the std::regex objects in advance and keep them in your container of choice.
Calling std::regex_match on a precompiled std::regex object is very efficient.
Consider also passing the std::regex::optimize flag when constructing your std::regex object. This would mean even slower construction, but an even faster match performance.
",2,51064222
50927206,"
Use recursive_directory_iterator instead.
For reading the file, use std::ifstream. It has been updated to take a path object in C++17.
",2,50927152
50807283,"

I want to find position of the first ""3"" in the vector is 0 and
  popcurrent[0].bit[0][0] = 3 , I have problems. Specificaly I tried
  c++ search a vector for element first seen position with the following
  commands:

There are mainly two problems:
Problem - 1: std::lower_bound takes parameters first, last, which are  forward-iterator types which defining the partially-ordered range. In your case(popcurrent[0].bit.begin()), you are passing a iterator which has the pointed element as a vector of integers (remember std::vector<std::vector<int>> is an array of vectors(vector<int>) not integers) for which std::lower_bound, could not find any definition for operator<. This is the reason of your error, where compiler complaining that:
"" Hey, I don't have a specialisation for operator< your given range
 or vectors, to instantiate the template ""
Problem - 2: You can not use std::lower_bound here, as it needs a strictly sorted array to binary search the value which has been provided. As you provided an unsorted vectors to check, the result won't be correct. See above link to read more:

Solution:  You can use std::find_if which has a time complexity, up to linear in the distance between first and last iterator, according to the predicate provided, which will search for each element until a match is found. This could be an alternative if you do not want to sort each vector in the class, which is actually a 3-dimensional array of vectors. 
Following is a sample solution: SEE LIVE HERE
Output:
",1,50805299
50805647,"
I didn't notice it at first - there's too much irrelevant code - but the problem is quite simple: you're trying to find the first element of type std::vector<int> not less than value of type int.
popcurrent[0].bit.begin() points to the first element of std::vector<std::vector<int>>, that is a vector. There's no ""less than"" operator for comparing a vector of ints and an int.
",3,50805299
50775888,"
try using regular expressions. They can be kind of a pain in the ass, but pretty powerful once mastered. In your case i would recommend using regex_search(), like here:
If you want to make the exact matching user-specific you can also just ask for the number of digits in the number or the complete regular expression, etc.
Also noted:

the simple regular expression provided [0-9]{4} means: ""any character between 0 and 9 excactly 4 times in a sequence"". Have a look here for more information
in your question you mentioned, you wanted the compiler to do the matching. Regular expressions are not matched by the compiler, but at runtime. In that case you could also variable the input string and the regular expression.
using namespace std; makes the prefix std:: unnecessary for those variable declarations
std::getline(std::cin, pattern); could be replaced by cin >> pattern;

",0,50775666
50730434,"

Task - g: Output second sentence with the words reversed ( the last word goes
  first, second last second, and so on)

This could be done as follows: 

using std::stringstream and std::getline parse the words in second sentance.
store to a vector of string array. 
Then reverse print the vector of strings with spaces.

.
Output: 


Task - h and i:    

Output the total number of vowels in the first sentence
Output the total number of consonants in the second sentence


I will explain it for vowels:

Keep an array of char vector array for vowel in ascending order.
Using std::count_if() and a unary predicate (here I used a lambda with std::binary_search()) you can find the each char of the first sentence, in the vowel array. 
The same can be applied to find the total number of consonants in the second sentence

.
SEE OUTPUT LIVE
",0,50730219
50730412,"
One method for counting vowels is to make a string containing vowels:  
Next, for each character in your string, search for it in the vowels string:  
This can be applied to consonants as well.  
The code can be modified for those who are not allowed to use std::string.  
Another method is to use std::map.  
",-1,50730219
50729004,"
in theory: yes, but it will be quite inefficient.
i'd recommend to put the data in a sqlite database, that way you still have a single file, but can nicely query/search for entries.
",0,50728498
50729056,"
tl;dr: Yes, but it's often not worth it
You neglected to mention how the text file is sorted, exactly, and whether there are escaped characters, quotation marks, multi-octet characters etc. - these would all impact the answer.
But let's make the following assumptions:

Plain printable ASCII text, with no newlines in each string.
Newlines (i.e. 0xA characters) separate strings.

This is still not enough for a set of assumptions, because - maybe some of the strings are much longer than the others? In fact, what about the not-that-extreme case of n strings overall, but a few of them take up most of the characters? If you start sampling characters in the file, you'll need to go back and forth, linearly, at least to both edges of a single string (or forwarded until you hit a newline twice). 
So let's add more assumptions, although frankly - they're quite invalid:

You know the minimum Min and maximum Max string lengths.
The ratio R of minimum to maximum length is not very high

This makes it at least theoretically reasonable to start reading from some arbitrary point in the file, and look for a complete string. However, files are usually on disks; and disks are accessed by blocks. So for reading even a single character from the file you need to read a whole block of size B (think of B as, say, 1 KiB as a reasonable example). We'll assume Max < B, otherwise you're in the huge-strings case.
Another point to be made is that disk latencies are high. This is especially true for magnetic (or optical disks), where you can wait as much as 10 msec for a single read! If you read sequentially, there's no need to ""seek"" or lookup the position you're interested in, and you could make use of the disk's full bandwidth. This is less of a problem with SSDs, but it's still not negligible.
So, as you can see, there's quite a bit of overhead for your binary search. It may still be worth it your file is really really large relative to Min, Max, R and B. So in a file of several Gigabytes, I'd certainly consider it. Otherwise - probably not worth the bother.
",-1,50728498
50715211,"
Try this:

> Program to finding the vowels in a string
The best way of finding the vowels in a string is using a binary search. Here is the hint:

Make a vector of char array of vowels(in ascending order)
For each chars of the input string, std::binary_search in the
vowels array.
If binary_search returns true print the char of the string.

.SEE LIVE HERE 
Output: 

> Program to remove the vowels in a string
Use erase-remove idiom as follows, in case, your actual aim was to remove vowels from user input (str).
SEE LIVE HERE
Output: 

PS: And avoid using 
Why ? see this and this answers.
",3,50714940
50715587,"
Apart from the std::getline problem already answered:
OK, don't want to start any discussion about usage of goto, there are many ways to avoid it, e. g. by packing the inner for loop into a separate (inline) function. You can have it easier, though, as there already exists such a function; code gets even easier with a range-based for loop:
strchr (from cstring) returns a pointer to the first character in the string equal to the reference character - or nullptr if not found...
To really remove the vowels from the string in a modern C++ way, consider this:
",1,50714940
50715201,"
Your code probably should looks like (please see comments inline):
",0,50714940
50612830,"
""$"" is a C string because it uses double quotes, so it's similar to const char*. What you want is a character:
Where '$' uses single quotes and is a character, or char, which is an integer value. Here ""integer"" is not to be confused with the specific int type.
",1,50612799
50315238,"
As mentioned in comments it is OS dependent. For what I know the C Standard does not even mention directories.
If you want an efficient search technique you have to implement it yourself. If you write a lot you can sort of implement it using the OS to do lookup through directory hierarchies with O(n*log(n)) average complexity.
If primarily read-only it'd be near as simple and a lot faster putting the files in a single file, treating it as a virtual file system and have your application search through it using whatever search algorithm you choose. The speed comes from fewer OS and filesystem calls. Writing becomes bit of a bigger issue since the FILE* don't do insertions very well in-place without major relocation or memory.
",0,50312533
50206045,"
I don't know how ""basic"" you need, but to read and write files you need to include the header file ""fstream"". You can read and write files in a variety of ways. One way is to open a file and instead of using cin for input and cout for output you would use the name of the file stream that you opened the file in. Example:
Specifically for your question:

Ask the user for one of the columns (you don't need to ask for all of them. Name, condition, or symptom would work best). 
Open data file
Use getline(inFile, junk, '\n'); to skip first line (you don't want to search the column titles). junk is a string variable and inFile is your '.txt' file.
Read the next line in the file by using getline() again.
For every line, search the string that was read from the file, searchString, for the string that the user inputted, userInput, using found = searchString.find(userInput, 0). You would have to declare size_t found before the loop.
For every line, check if userInput was found in searchString using if(found != std::string::npos)
If found print `searchString to the screen using 'cout'
Repeat step 4-7 until the end of file is reached
Close the file

",0,50203812
50112364,"
You have an #include loop; BST.h includes Faculty.h, which includes BST.h. This can cause a lot of problems, including what you're seeing now; depending on include ordering, the definition of BST may not be available when Faculty needs to use it.
BST.h doesn't need to know anything about Person, Student, or Faculty. Removing those includes should resolve the current problem.
",0,50112264
49920119,"
Wrap your Nodes into a structure like this:
And define your openSet like:
Initialize an unsigned int counter to 0 before the while loop and make these changes:
And finally adapt lowestScore:
As suggested, you may want to switch your openSet to a std::priority_queue, which will retrieve minimal elements faster. You should be able to use the same comparison logic.
",1,49918408
49919232,"
There is a priority_queue in std.
Here is a reference: http://en.cppreference.com/w/cpp/container/priority_queue
I'm not sure if it is what you need: 
",2,49918408
49885554,"
There are many things I'd give you feedback on, but this isn't a code review site, it's for specific questions.  I'll point out briefly a few things I notice though:
1) don't include C headers; use c++ ones instead.  
2) what type is string?  
3) you compute length (incorrectly, assuming answer to question 2 is ""the standard c++ string class""), but you don't use it.
4) search() returns a bool but you don't return anything.  When you find the end of a word, you should return from the function.
5) search() calls checkNull() at the top of the for loop without ensuring that it's not null.  After this: crawl = crawl->getNode(key[i]); it could be null, but then you loop and go through the pointer without testing it.
6) setNode is a public function, and unconditionally overwrites whatever is in the slot for the given variable.  You can clobber an existing child if someone calls it with the same character twice and leak (and probably lose data in your tree.
7) search doesn't need to be a member of TrieNode.  In fact, it doesn't access any data through ""this"".  You probably don't want the TrieNode to be public at all, but an internal implenetation detail of Trie, which is where the search function should live, where the root should be stored and managed.
8) in c++ use nullptr instead of NULL
9) Looks like you need to debug search(), because it is not on the last letter when you check for end of word.
10) you need a destructor and need to deallocate your nodes.  Or store them in unique_ptr<> for automatic deletion when your object goes out of scope.
11) don't ""using namespace std;"" in headers.  It makes your headers toxic to include in my code.
",0,49884974
49886148,"
Your insert and search functions can be simplified a bit. 
Consider this.  (Read the comments in the below code, they illustrate what the code does)
Take advantage of the power of C++ std::string
Also your whole temp - 'a' logic is a bit iffy to me. I wouldn't much around with ASCII values unless I needed to
Why are you including a whole bunch of C headers? Just iostream should suffice to do what cstdio does. 
if(!ptr) is a much more natural way to check for NULL. 
In production don't use using namespace std; Instead just preface stuff like cout and endl with std::. The reason for this is to avoid polluting the standard namespace.
Read a good CPP OOP book :). It will help you a lot.
Also I lol'd at anna and anni. Your anna and anni must be proud to be in your trie :D
",0,49884974
49886366,"
The insert and search functions are a mess.
They use rather contrived ways to check the end of the string, duplicated unnecessarily and with a bug in one of the branches.
Here are simpler versions.
They use string size for the loop bounds, and the actions needed at the end of the loop are made after the loop, which is more natural.
I used the same style, but omitted the debug outputs for readability.
Also, the code did not actually use search as a function, it didn't return a value.
Instead, it relied on debug output to show the result.
This is now corrected.
A main function complementing these is as follows.
",0,49884974
49877866,"
I think what you want is something like:
I would further advise to make m and l parameters to the function: void countRepetition(const list<char>& l, vector<int>& m)
EDIT: (Thanks to papagaga)
With a map this can be solved even nicer:
",2,49877593
49878494,"
Also you can use simple algorithm for_each + map container to calculate unique appearances.
",1,49877593
49839507,"
If your graph never changes, a solution is to cut it into smaller graphs.

Calculate the shortest distance between the edges of each small graph and store the result (edge1, edge2, distance, internal shortest path).
When calculating the distance between 2 points, use the stored result when you reach a ""small graph"" edge.

I am confident that this is the kind of trick GoogleMaps and other path finder work.
The drawback is the initial cost (if your graph really never changes, you can store these ""mini"" shortests path a file or a database once and for all). You have to choose the size of your small graphs carefully since the accessing the stored result will have a (time) cost too (whether it is in large memory map or database). A balance must be found.
Another idea if the same path searches come back quite often is to store the most searched results.
",3,49839363
49840243,"
If you're using a priority queue and an adjacency list, your implementation's complexity is O((E + V) log V). This should be more than enough to compute any shortest path in a few milliseconds on your kind of graph, on any decent CPU.
You seem to have the priority queue part done right. But why use a map instead of an adjacency list? That seems overkill.
Your implementation hides some extra, unnecessary work:
This will create a copy of whatever nextNodes returns. This means that for each node, you will make a copy of all of its connected nodes, which is O(V^2) already. You might think that your QMap contains pointers to Node*, so no copying is being done. But you will copy the k pointers, one for each adjacent node, which is still bad.
You should use either a (const) reference:
Or a pointer:
This alone should help a lot. After that, I would switch to a linked list. A QMap is implemented using a red-black tree, so iterating it will be slower than iterating a linked list.
If your graph grows a LOT more, user6106573's suggestion is very good (but completely overkill for your current graph size). Another suggestion might be to settle for a shortest path that's not exactly the shortest: https://en.wikipedia.org/wiki/A*_search_algorithm - check the Bounded relaxation section. Again, this is not needed for your current graph size.
",3,49839363
49769328,"
With a true random number generator, the probability of drawing a particular number is not conditional on any previous numbers drawn. I'm sure you've attained the same number twice when rolling dice, for example.
rand(), which roughly approximates a true generator, will therefore give you back the same number; perhaps even consecutively: your use of % 10 further exacerbates this.
If you don't want repeats, then instantiate a vector containing all the numbers you want potentially, then shuffle them. std::shuffle can help you do that.
See http://en.cppreference.com/w/cpp/algorithm/random_shuffle
",2,49769166
49769264,"
When j=0, you'll be checking it with m={1, 2, 3}
But when j=1, you'll be checking it with just m={2, 3}. 
You are not checking it with the 0th index again. There, you might be getting repetitions.
Also, note to reduce the chances of getting repeated numbers, why not increase the size of random values, let's say maybe 100.
Please look at the following code to get distinct random values by constantly checking the used values in a std::set:
",1,49769166
49762057,"
You have to create and implement iterators for your wrapper that satisfy concept ForwardIterator. Details on how to do that can be found in answers to this subject How to correctly implement custom iterators and const_iterators?. Then provide methods of your wrapper that return first and behind the past iterator (usually they called begin() and end() and they better be but you can call them whatever way you want). 
Iterator can be implemented as std::pair<size_t,size_t> with positions in data plus reference to data itself with proper implementation of operator++.
Optionally for optimization you may want to make your iterator to satisfy RandomAccessIterator concept and std::lower_bound or std::upper_bound could be more efficient (depends on how you implement random access of course).
",1,49761529
49546687,"
You can search the file one char at a time, and match that against your search.
",0,49546402
49488765,"
You could do that simply by iterating through the vector and comparing for the attribute. I guess you are not looking for optimizing procedure for this. 
",-1,49488202
49488462,"
Based on Yola, here's a ready made code snippet  
",1,49488202
49512164,"
If your std::vector is sorted by sm_index then you can use a binary search to find elements matching sm_index. This will be faster than std::find_if.
The C++ standard library provides a few algorithms for doing binary search. std::equal_range can be used to find multiple elements with matching sm_index but if you only want to find one element that has the matching sm_index then you can use std::lower_bound:
Live demo.
",0,49488202
49438192,"
I don't really believe, that the teacher's approach is better. Every file access costs, and it costs much. A real improvement will be minimizing file accesses count. You waste a lot of time, when you read file line by line. You should create some buffer, f.e. 64kB. This will increase performance significantly.
To be specific: when I was working with files long time ago, I used naive approach to read data from it like from standard input:
Nope.
If you respect your time, don't do like this.
In perspective: 5 MB file using naive approach took me about 1-2 minutes to load. Then I've significantly reduced number of accesses and it took 5 seconds to load. This is just an example, but you can realize how big step it is.
",0,49438014
49436538,"
Binary search requires a sorted input, and you can check this easily with a pencil test:
Suppose you have a series of numbers like 1,5,8,10,12, and you are looking for 5; First guess, you split the series and test the number in the middle, i.e. 8. Since 5 is lower than 8, it is clear that you don't have to look for 5 in the half above the 8. Yet this assumption only holds if the series is sorted; otherwise the 5 might be in the upper part as well.
So sort your input, and then see if it works. Otherwise use a debugger :-)
",2,49436349
49436997,"
You will need to implement a comparison function (or code), that extracts the first name and last name (as separate variables) from the string.  
Once extracted, you can easily compare by first name or last name.
Ideally, you should have a structure that models the data, e.g. a first name field and a last name field.
",0,49436349
49115979,"
Unless there is some rule about the position of a particular element in a vector implying the position of another element, if present, the algorithm for the detection of presence must be O(N).
If the vector is sorted, for example, then a good positioning rule holds, and there are plenty of O(log(N)) algorithms out there: std::lower_bound is one such function.
",1,49115902
49116344,"
The vector container isn't optimized for lookups. What you need is probably need a set. I recommend you check the answer to this question.
",0,49115902
49127551,"
Considering your examples include verb and noun, you'll be trying to look up words in a (practically) fixed dictionary of sorts. There are many optimized containers for this purpose.
The Standard Library contains std::set<>, and a std::set<std::string> nouns will work. It has O(log N) lookup. Slightly more efficient, there's also std::unordered_map<>, which is still sufficient for your needs - you only need to know if a word occurs in the list of nouns, not what the next noun would be. 
Outside the Standard Library, there are more data structures. A trie aka prefix tree shares the prefixes of its entries, which is space-efficient. 
",0,49115902
49004051,"
It is undefined behaviour (see e.g. Why does flowing off the end of a non-void function without returning a value not produce a compiler error?).
The compiler appears to return temp by chance, likely because it is the first local variable declared inside the function. Returning temp would fix it.
",5,49003532
49004437,"
As far as I understand you want to return -1, if the target is not found and the index of the target otherwise. In 
you are returning INT_MIN, if the target is not found. You need to change it to 
Since your function returns an int value, it has to return something on each patch. You can fix it by adding the return at the end of the function:
BinarySearch returns the index of target in the current arr. Since the current arr often doesn't begin with index 0, you're adding and subtracting mid+1. You're also doing it, if the target was not found and BinarySearch returns -1. You have to fix the else part:
",0,49003532
52613933,"
that is the best I can do with std algorithms.
For optimization, using a circular buff might save a bit of work.
",1,48997403
48715785,"
Because you dereference the null pointer when you use construction temp ->next.
Before this put the if(temp) next do moving
",0,48715629
48678457,"
Please use ifstream.getlinegetline (char* buffer, int count ) to read the file line by line.
And if I have got you correctly in case of finding the count of ""AT"", go on finding char ""A"" and every time you come across ""A"", check if next character is ""T"" and increase the count.
",0,48677851
48390706,"
Uh oh, this looks like undefined behavior caused by Sequence Points (see this question for more information).
To quote the answer in that question,

the order of evaluation of operands of individual operators and subexpressions of individual expressions, and the order in which side effects take place, is unspecified.

You're trying to perform a set and a get on the same variable (one of the count's) in the same sequence point. Which will happen first (the set or the get) is undefined.
Split your cout's into two and everything should be solved.
",1,48390562
48378481,"
You are looking for min_element with custom comparer.
Demo
",1,48373625
48371387,"
If the container is sorted, you might use std::binary_search:

Checks if an element equivalent to value appears within the range [first, last).

So found is true if some_value is found and false in the other case.

If you are interested in getting an iterator which points to the element you are looking for, then consider using std::lower_bound:
",3,48371366
48324743,"
As I commented above, if the vector is not too big, you can use std::transform to store all scores first, then apply std::min_element.
However, if you want to take benefit of ""lazy evaluation"", and still want to use C++'s STL, there are some tricks to work it out. 
The point is std::accumulate can be regarded as a general reduce or fold operation (like foldl in haskell). With C++17's syntax sugar for std::tuple, we can write something like:
",3,48322854
48324546,"
Here's a function that does what you want--even going beyond the intuitive ""call score exactly once per element"" by realizing that there's nothing smaller than negative infinity!
",3,48322854
48323232,"
As suggested bu user @liliscent, one could:

generate a collection of precalculated scores,
find the minimum score from it,
and infer the position of the minimizing item from the position of the minimum score.

This is my reading of their suggestion:
With a live demo.
",1,48322854
48151861,"
Well, probably the third one, just because you don't end up hitting the memory allocator. Building a map/unordered_map every single time you call the function is going to take up most of the time of the first two versions. But calling lower_bound is likewise silly, and is going to lead to overly branchy code.
Instead, have the compiler deal with optimizing this for you:
I would be extremely surprised if any of your versions beat this one.
",2,48151779
48152016,"
If you know that the map is fixed and known at compile time you might consider a perfect hash approach, and use a generator like gperf.
Of course you'll better build the map (e.g. a std::map, or a std::unordered_map, or your own one) ahead of time (perhaps in your initialization routine).
In all cases, you need to benchmark. In most cases, for only a hundred entries, performance won't matter that much (since the data is likely to sit in some L1 or L2 cache).
In your MCVE example, you could even switch on the screen id (see Sneftel's answer)... And you might generate the C or C++ code of that switch...
Another approach (a bit silly, but could be made very efficient) might be to generate and JIT-compile some code based upon the map. You'll then use a JIT library like libgccjit to generate an efficient function from your map. Or generate some C or C++ code at runtime (perhaps using gperf for that) and compile it as a plugin then dlopen(3) it.
Or, as commented by Marc Glisse, use some vector. Most other approaches above could also fit if you need a fast, reverse, mapping (between names and ids).
PS. You really need to check that the speed of your ScreenID2Text function matters that much for the overall performance of your entire application (I guess it does not).
",1,48151779
48001256,"
I think you simply need to make the comparator compare only the length of the prefix against the elements like this:
Output:
To explain why this works imagine taking the vector and sorting it. Then imagine visiting every element and truncating them to the length of the prefix. You would be left with a sorted vector with no elements longer than the prefix. At that point a simple std::equal_range would do what you require. Thus, all we need to do is construct a comparator that behaves as if the container elements had been truncated to the length of the prefix and use that comparator in our std::equal_range search (or twin std::lower_bound/upper_bound search).
",2,48000091
47887135,"
""as quick as possible in realtime"" is already a contradiction. Realtime means as fast as the data arrives; no need to be faster than that. In fact, realtime often is slower than batch processing. 
Realtime also requires hard figures on time available and time taken, neither of which are available here.
Your header appears to <8 bytes, which is 1 cache line. KMP or similar algorithms are unlikely to be needed. Checking all bytes in a cache line for 0xFF is almost certainly faster than checking a single byte against 0xFF, 0xEE, 0xBB, 0xAA, 0x12 or 0x90.
Now, ""numerous modulo (for circular buffer index) operations slow down the speed drastically"" is a realistic problem. But that does have a straightforward solution. Make sure that the buffer size is a compile time constant, and a power of two. x%(1<<N) is equal to x & ((1<<N)-1)
",0,47879401
49929035,"
If its a a lot of data, or you expect to migrate the data to another computer, I'd go with Qt's built in SQL functionality. 
",1,47785585
47785759,"
Severel Month later I decided to work on this problem again and finally, I have a solution. It took me ~ 4 h to get everything working. I'm using now Toxi-Tagging with SQLite in Qt. I had this Idea from this post and looked also into other possibilities. Here is a page with multible options and a small comparison: Link
Here is my Solution:
Create the Database and add Values to it. Then you can do a simple substring search like this:
Sidenote: If your Tag list is really large it is probably beneficial to use FTS3 or FTS4. Here is more info. 
Create Database:
Adding Values to the Database:
",0,47785585
47721207,"
The else will always be activated if the element is not the first one in the array. you should delete it, and return -1 after the while.
This way, if you pass through the whole array and you don't find the required element, then you would return -1.
Edit
And as NathanOliver mentioned, found is useless because you are returning anyways when you find an element. So the code becomes:
",0,47721129
47721298,"
Try this:
",3,47721129
47721385,"
Try this code
",1,47721129
47708652,"
If I understand your problem correctly you need to find two positions in your array, the first of which all numbers are greater than or equal to 100 and the second of which all numbers are less than or equal to 1000.
The functions std::lower_bound and std::upper_bound do binary searches designed to find such a range.
For arrays, in C++ we usually use a std::vector and denote the beginning and end of ranges using a pair of iterators.
So something like this may be what you need:
You can iterate over that range like this:
You can create a new vector from the range (slow) like this:
",2,47708266
47708927,"
My first attempt.
Features:

logN time complexity
creates an array slice, no copying of data
second binary search minimises the search space on the basis of the first

possible improvements:

if n is small, the second binary search would be a pessimisation. Better to simply count forward up to n times.

 
",1,47708266
19255,"
Here is tree.hh  which is a bit close to what you want to do, though a bit
different.
Here is a piece of code extracted from its website.
Now what's different? Your implementation is simpler when it comes to 
append a node to the tree. 
Though your version is indiscutably simpler, the dev of this lib probably wanted to have some info accessible without browsing the tree, such as the size of the tree for instance.
I also assume he didn't want to store the root on all nodes for performance reason.
So if you want to implement it your way, I suggest you keep most of the logic and add the link to the parent tree in the iterator and rewrite append a bit.
",5,19193
19204,"
Why would you want to do that?  If this is for learning purposes then you can write your own tree data structure.  If this is for gaining the benefit of a data-structure holding arbitrary index types, optimized for searching and good at insertion then consider using a map.
A map is an associative container that has performance guarantees identical to those of a tree:  logarithmic searching, logarithmic insertion, logarithmic deletion, linear space.  Internally they are often implemented as red-black trees, although that is not a guarantee.  Still, as an STL user all you should care about is the performance guarantees of the STL algorithms and data-structures.  Whether they're implemented as trees or little green men shouldn't matter to you.
As a side note, there's no such thing as a root() function.  All STL containers have the begin() function implementing the conceptual beginning of a container.  The kind of iterator returned by that function depends on the characteristics of the container.
",3,19193
4689040,"
You need to create a simple text-based 'protocol' where your c++ backend can provide the data needed by the vb program to perform the population of the treeview control.  As it's a treeview you are looking at a hierarchical protocol, something like:
Where attrib is something used to control what information is 'stored' in each leaf of the treeview.  You might also want some way for the frontend to 'control' the backend, where the above response is the result of the command.
You need to use some form of interprocess communication (IPC) mechanism to get the information from the backend to the frontend.  For Windows (I'm assuming you're using Windows?) you can use Named Pipes to perform the communication.
",0,4688711
4549300,"
Generally, you store a pointer back to the parent only if you are going to be using algorithms that require it.  Otherwise, it is unnecessary overhead both in terms of the memory used to store the pointer and the extra complexity of updating those pointers when you insert a node or rebalance/reorganize the tree.
The typical algorithms used with trees (breadth-first and depth-first search and traversal) don't require parent pointers, which is why your average run-of-the-mill tree implementations generally don't include them.
Your ""highlight path from the root"" requirement might make parent pointers useful, although there are other ways to implement that.  In general, one should avoid putting redundant information into data structures until it is proven that they are necessary for performance reasons.
",10,4549227
4549404,"
To elaborate on Kristopher Johnson's reply: ""you should only keep a pointer to the parent of you need it"".
Remember that for many algorithms that traverse a tree/graph, during the traversal, you are traveling from the parent to the child, so you actually have the parent pointer in hand. You can use this parent pointer (for example passing it to a recursive function) instead of paying the costs of keeping it in your structure.
Another point: for general graphs this question is the same as ""should I store the in-edges (in addition to the out-edges) in my nodes?"". If you look at the boost graph library, you will find a template library that allows you this choice at compile time.
",3,4549227
4549396,"
The overhead of storing a parent pointer is relative to how often you update the tree/graph, and how many nodes are in it. The overhead of not storing a parent pointer for some algorithms depends on how often they're run. I can't tell you how often you update the map or how often you need a parent pointer, but my advice would be to implement both and run a profiler, or make some kind of logical decision based on which operations take more time.
",0,4549227
4549448,"
If it will be possible to change (extend) this structure in future (and for most of code it is possible), I would suggest to postpone adding this link until it will be clearly needed.
It's much simpler to add something than to remove when code is in use...
But it's still useful to have several potential extensions in mind when designing data structures...
",0,4549227
4424865,"
AFAIK, it contains helper stuff used for implementing std::set and std::map, which have (this is the only sane way to achieve the required big-O performance characteristics and provide the required functionality) a tree structure internally. I can't guess why <vector> would need it - were you just browsing around in the folder?
",5,4424818
4156507,"
Something like this is usually sufficient:
This allows you to change the underlying container type without changing code that iterates over a node's children.  
This does have the disadvantage that it leaks an implementation detail because code that uses your node::const_iterator know that it is a random access iterator (because std::vector:: const_iterator is a random access iterator), so you might have a hard time switching to a container that didn't support random access.  
If you want to be able to control the iterator category yourself, you'll probably want to create your own iterator class that provides the exact behavior you want to provide.
",4,4156451
4156542,"
This isn't a direct answer to your question, but rather, an alternative approach.  Rather than have the client code run the show, you could go for control inversion by registering a callback functor.  For instance:
Complete encaspulation achieved!
",4,4156451
4156509,"
For traversing the entire tree, you would have to create your own iterator class, for just traversing the children, you can safely return the vector iterators.
",0,4156451
4144208,"
C++ supports multiple inheritance, so you can have the union of (2) and (3), making sure that AbstractBase is always declared as a virtual base class.
Without knowing the real meaning and purpose of the various classes, it's difficult to offer any better advice.
",0,4144143
4144223,"
It's not clear from the description if this would work for you but typically classes with a common interface would define the interface in AbstractBase and then have concrete instances inherit directly from that (FirstItem, SecondItem).  
Why the extra indirection(s) in your examples?  What's expected to be in AbstractItem, FirstBase and SecondBase?
",0,4144143
4144404,"
For using different implementations of one interface, on could use:
the Bridge Design Pattern
You might couple this with a Factory Design Pattern so as to construct your two implementations differently.
However, it may look too simple for your classes architecture.
But as the comments under your answer say: it is difficult to imagine the job/role of your classes with such names. You should be more explicit, so as we can think of a precise design.
",0,4144143
4057326,"
You have the type name twice in the constructor call, try:
",1,4057320
4057592,"
Besides having 2 constructors on one line, you can not allocate the pointer to the variable. You either have to do this :
ForestNode *foo = new ForestNode;
or do this :
or this :
",1,4057320
4033867,"
You can take any implementation of a tree that allows a stateful allocator, and implement a custom allocator on top of your fixed size buffer.
Though the C++ standard doesn't guarantee support for stateful allocators, they work ""with most STL implementations most of the time"". Allocator state is usually only a problem when moving nodes between containers. 
If you can live with one instance, the buffer can also be a template parameter.
",0,4033730
3918881,"
I think it would be something like this.
",3,3918811
3919005,"
Suppose orgTree points to  root (2). For copying, we have to do the following:


create a node at copyTree, and the copy the value 2 into it
if orgTree->left != NULL, call copyInOrder( orgTree->left, copyTree->left );
if orgTree->right != NULL, call copyInOrder( orgTree->right, copyTree->right );

BTW, this type of traversal is known as pre-order traversal, in-order traversal is different.
",3,3918811
6199569,"
",3,3918811
3879062,"
May be this works:
or just add NULL check for NODE
",3,3878456
3878501,"
maybe you can pass in the value counter as reference? then increment it every time the function is called ? idk .. i am working on a program due tomorrow as well that needs this same function... 
",0,3878456
3879039,"
I finally got it! 
Thanks for your help though!
",0,3878456
3852345,"
If I understand your question, you can make a class that represents the box, such as:
Then, you can have a global vector to hold all the boxes:
You can then add a box like this:
And move an existing one like this:
I'm sorry I cannot answer your question completely, but I hope you know have an idea on how to accomplish your project.
EDIT: To achieve a tree structure, you could add these variables to the Box class:
This would allow you to keep track of the tree structure. Then doing something like:
would retrieve the second child of the first child of myBox. I hope this makes sense to you. 
",1,3852252
3847137,"
I think you have to handle symbolic links to directories differently. There could be the source for your endless loop:
Say /tmp/foo is a symbolic link to /tmp, then I think your program will go into endless loop when .==/tmp
",2,3847074
3843378,"
You can't change the object that a reference refers to1; once you initialize a reference, it always refers to the object with which it was initialized.
You should use pointers.  There is nothing wrong with using pointers for this (it's clean using pointers as well because parent nodes own their children, so cleanup and destruction is easy!)
(1) Well, you could explicitly call the object's destructor and then use placement new in the assignment operator implementation, but that's just a mess!
",4,3843373
3843384,"
You cannot assign to references. What you're trying to do can't be done... without a huge amount of bending.. (you'd essentially destroy a node and create a new one each time you want to modify it.)
There's a good reason why all those other people use pointers.
",2,3843373
3843465,"
References aren't just pointers with shorter syntax. They're another name for the actual object they refer to, even when used as the lhs of an assignment.
That is, ref = j has the same effect as i = j, or the same effect as *ptr = j, if you had first done int *ptr = &i;. It means, ""copy the contents of the object j, into whatever object ref refers to"".
For the full lifetime of ref, it will always refer to i. It cannot be made to refer to any other int, that is to say it cannot be ""re-seated"".
The same is true of reference data members, it's just that their lifetime is different from automatic variables.
So, when you write this.left = new_left, what that means is, ""copy the contents of the object new_left into whatever object this.left refers to"". Which (a) isn't what you mean, since you were hoping to re-seat this.left, and (b) even if it was what you meant, it's impossible, since this.left has reference members which themselves cannot be reseated.
It's (b) that causes the compiler error you see, although (a) is why you should use pointers for this.
",2,3843373
3843388,"
References in C++ don't work the same as references in other languages. Once a reference is set, at construction time, it can't be changed to anything else.
",1,3843373
3843530,"
My recommendation is to use boost's shared_ptr class instead of a reference. This will free you of the concern for managing the pointer's deallocation. You may also be interested in Boost's graph library.
",1,3843373
3742032,"
Whether the implementation maintains nodes that have been erased or not, it must call the contained object destructor when the node is erased. After that, it cannot possibly pass the object to a comparison function as that would cause undefined behavior, which would make it a non-conforming implementation.
",4,3741738
3741781,"
Answering for data structure implementation in general rather than for MSVC or std::map:
You seem to think that the user the container needs to be aware of the flag in order to ignore elements that have been removed.
If the implementation simply flags an element as no longer being included, it will do so as an implementation detail.  That means that from the point of view of any outside user of the container, that element will not be visible in the container at all.  In particular, any of the lookup methods on the container will notice the flag and ignore anything it's attached to.  As long is the implementation is correctly preserving the semantics, you really don't need to worry about whether it's using a flagging technique.
",4,3741738
3741790,"
I am not aware of any bugs in the Microsoft STL implementation that you have to worry about here.  It would be a bug for the class to access for comparison already-removed elements, though I can imagine how cleanup might happen out of band.
If you really need implementation details, take a look at the source code behind element removal in <map> and <xtree> from within your running code in the IDE.
",3,3741738
3697103,"

Sort by (x+y).
Starting at the beginning of the sorted list, grab a rectangle Q.
Compute (x+y+w+h) for that rectangle.
For each rectangle R in part of the list that follows rectangle Q, and has x+y for R <= (x+y+w+h) of Q, check to see if R is within the bounds of Q. If it is, set Q as the parent of R, overwriting any previously set parent.
Repeat for the list.

",2,3697076
3628523,"
Check out this page, it provides implementations (in C, C++, Java, etc.) for several variants (R*, R+, etc.).
",5,3628345
3538136,"
Looks like, for speed, you'll need a ""back-pointer"" from each child node to its parent node.  This way you can follow the chain of parent pointers given a pointer to any node all the way to the root, if that's what you need (I'm not sure how else you planned to find the root given just a pointer to an inner node, without backpointers?).  Of course, you'll need to adjust the back pointer, as well as the ""children"" std::vector, whenever you rearrange the tree -- an unfortunate consequence of the slight duplication of information (no more than, say, a doubly linked list presents;-), but a small price to pay for the ease and speed of such bidirectional navigation.
",1,3538109
3530512,"
This is what all garbage collectors struggle with. However, the best thing you can do (IMHO) is to pray for enough memory for the stack, and your prayers will be heard 99.99999% of the time. Should it not happen, just abort().
BTW if you are interested, there is a solution to traverse long (and deep) trees without allocating much memory.
",1,3530406
3532834,"
I just had this as an interview question.  
And I must admit this is one of the hardest things I had to solve on the fly.
Personally I don't think it's a good question as you may know the trick (if you have read Knuth) in which case it becomes trivial to solve but you can still fool the interviewer into making him/her think you have solved it on the fly.
This can be done assuming that the node stores child pointers in a static structure. If the node stores child pointers in a dynamic structure then it will not work, as you need to re-shape the tree on the fly (it may work but there is no guarantee).
Surprisingly the solution is O(n)
(Technically every node is visited exactly twice with no re-scanning of the tree).
This solution uses a loop (so no memory usage for stack) and does not dynamically allocate memeroy to hold nodes that need to be deleted.  So it is surprisingly effecient.
The above method will work as long as their is always a children[0] node (even if it is NULL). As long as you do not have to dynamically allocate space to hold children[0]. Alternatively just add one more pointer to the node object to hold the delete list and use this to turn the tree into a list.
",4,3530406
3530428,"
Why is the original code throwing an exception? I'm guessing you are doing something like using the same node object in multiple places in the tree. Stack overflows are rarely caused by normal expected situations. Stack overflows are not a problem, they are the symptom of a problem.
Rewriting the code differently won't fix that; you should just investigate & fix the error.
",0,3530406
3531084,"

Is it possible to write an exception free tree destruction? How?

Perhaps this (untested code):
",0,3530406
3515376,"
Is there any particular reason you are not just using linked lists for the children?  For example, here is a really basic example in pseudocode:
",1,3515243
3420334,"
Well, for starters it's not a copy constructor - the copy constructors have a very well defined syntax in C++, so a proper copy constructor would have the prototype TreeNode(TreeNode const &). Just to get the terminology right (and the compiler will still generate a copy constructor as it has no idea what the clone() function is supposed to do).
The expression in the if statement will both allocate a new TreeNode object and purports to check that the allocation succeeded (by checking that the resulting pointer isn't 0). Unfortunately that's pre-standard C++ and modern C++ implementations that are standard conforming will throw a std::bad_alloc exception instead, so the test will mainly give the user a warm fuzzy feeling that something is being done about memory allocation failure, even if it isn't.
In order to make the code work as expected on a standard-compliant compiler, you'll have to use nothrow new. From memory the line would read something like this:
All that said, unless TreeNode is part of an object hierarchy that relies on the presence of the clone() function I would do away with it and implement a proper C++ constructor instead. That way, the compiler and you are on the same page when it comes to duplicating objects, plus other programmers will find it a little easier to follow your code.
",10,3420297
3420323,"
I wouldn't call the method clone() a copy constructor. For example it is not a constructor in the first place just a method.
Implement a copy constructor in C++ like this (I left out all other members to keep it short):
Edit: The example given implements/suggests a shallow copy. This is what the compiler creates for you if you didn't implement a copy constructor. So if you are happy with a shallow copy then you may as well leave out the copy constructor.
Of you prefer a deep copy this constructor may look as follows:
By implementing the copy constructor you can also mix between deep-copy and shallow-copy if required.
",3,3420297
3420307,"
It's been a while but the if ( ) is checking if the the allocation is non-null. IE the ""new"" succeeded.
",0,3420297
3420382,"

What does if (TreeNode* tmp = new TreeNode) mean?

This is supposed to check the outcome of the allocation, ie. that it hasn't failed. However, this is a bad way of doing it, because:

as others pointed out, new TreeNode will throw an exception in new C++ compilers
Even if it hadn't thrown an exception, it is bad: when only some of the nodes fail to allocate, the caller of clone() won't have noticed anything, but will silently get only a part of the tree.
when considering standard behaviour, this method is exception-unsafe.

",0,3420297
3413182,"
The pointer_conflict exception documentation states (sic):
I think the conflict occurs where each is serialised by a ptr in BaseNode::serialize and via the direct object, the *Node expression, in Node::serialize. However since the base_object function takes a reference and not a ptr I'm not sure how you would avoid this.
One possibility is to not serialize the parent ptr. Instead, after deserialization, do a walk of the tree and fix up the parent ptrs to point to the node parent. E.g. add the following method to BaseNode :
Then just call root->fix ()
",0,3315963
3320539,"
The following solution for libkdtree++ & boost::serialization seems work:
",0,3315963
3178304,"
Try this:
",2,3176766
3176787,"
is my final code. And i'm pretty sure that it works... Previous code has some kind of logic error. Using global variable (i know it's not recommended) I figured it out.
",2,3176766
30010689,"
This is perhaps too late, however I believe, is good to point out here. What the aforementioned answers suggest over here solely relate to serializing a binary (search) tree. Imagine you wish to reconstruct the tree later given its serialized version. You have to mark up the leaves so that when you attempt to re-build the tree, it is clear which node is a child of another one. To achieve this, simply add NULL references to the array (or list) when you encounter a leaf node. Yet, when going one level up, add yet another NULL reference to the array. In other words, before returning from each recursion, simply add a NULL to the array that has been passed in to the method. This way, any move one level up will yield insertion of a NULL to the array. When reconstructing the list, add the elements to a stack as you read them from the array left-to-right. Once hitting a NULL reference, you pop() the topmost object from the stack and left the next peek() of the stack to point to it as one of its children. Continue to the next element within the array and repeat the same procedure. There are perhaps better ways to further optimize this approach but this is what was on top of my head to mention. Hope it helps.
",1,3176766
3131980,"
I don't like the allocator version, because allocators are supposed to allocate memory, not construct objects. So there's no guarantee that the number of requested allocations to the allocator matches the number of objects to be constructed; it would depend on the implementation whether you get away with it. 
The tree calls the copy constructor on an inserted or appended value after the allocator has allocated the memory for it, so you would be hard pressed to write something which worked with polymorphic objects - alloc_.allocate doesn't know the runtime type of x before the constructor is called (lines 886 on):
Also looking at the code it doesn't seem to use assignment at all, and your wrapper only supplies the default copy constructor, so I can't see any of your suggested mechanisms working - when a node is assigned to the same value as it already holds with this code called (lines 1000 on):
your smart pointer would destruct their referent when their destructor is called here; you may get away with it by passing a reference counted pointer instead (so x doesn't destroy its referent until it goes out of scope, rather than the position.node->data destructor destroying it).
If you want to use this tree, then I would either use it as an index into data owned elsewhere rather than the tree owning the data, or stick with the shared_ptr approach.
",1,3131671
3132195,"
[Edit] Shane has chosen to go with the boost::shared_ptr solution and has pointed out that he needs to store polymorphic base pointers. Should memory/processing efficiency ever become a concern (after profiling, of course), consider a base pointer wrapper with safe copying behavior (e.g., deep-copying the pointee through a clone method) and the fast swap idiom shown in #5. This would be similar to suggested solution #2, but safe and without making assumptions on the data type being used (ex: trying to use auto_ptr with containers).
I think you should consider option #5.

1: Use a tree of boost::shared_ptr,
  although this is more
  expensive/overkill than I'd like.

First of all, do you realize that any linked structure like std::list, std::set, std::map requires a separate memory allocation/deallocation per node but doesn't require copying nodes to do things like rebalance the tree? The only time the reference counter will amount to any processing overhead is when you insert to the tree.

2: Write a little pointer wrapper like
  the one I've written below. The idea
  being that it wraps a pointer, which
  when it goes out of scope, deletes its
  pointer. It's not ref counted, it's
  just guarantees the pointer
  destruction.

For this tree you might be able to get away with it since you have the tree implementation, but it's a heavy assumption. Consider at least making the pointer wrapper non-copyable so that you'll get a compiler error if you ever try to use it for something which does copy node elements.

3: Write my own allocator which
  allocates the node objects from a pool
  in the allocate() and deletes the
  pointed to memory in the deallocate().

If it's an STL-compliant memory allocator, it should not be making such assumptions about the memory contents in deallocate. Nevertheless, writing a fast memory allocator which can assume fixed allocation sizes can really speed up any linked structure. Writing a fast memory allocator that consistently outperforms malloc/free is non-trivial work, however, and there are issues to consider like memory alignment.

4: Specialise the code to make a tree
  of pointers, avoiding the initial
  allocation and copy construction, plus
  innately knowing how to delete the
  pointed-to data.

Making a wrapper for the tree is probably the most robust solution. You'll have full control over when to insert and remove elements (nodes) and can do whatever you like in the mean time.
Option #5: just store the element directly in the tree and focus on making the element fast.
This is your best bet if you ask me. Instead of map<int, ExpensiveElement*> or map<int, shared_ptr<ExpensiveElement> >, consider simply map<int, ExpensiveElement>.
After all, you obviously want the tree to be the memory manager (deleting a node deletes the element). That happens when we avoid the indirection of a pointer to the element already.
However, your concern seems to be the overhead of the copy-in policy of insert (copy ctor overhead on ExpensiveElement). No problem! Just use operator[] instead of insert:
Tada! No copying, no need to worry about proper destruction, and no memory allocation/deallocation overhead per element.
If default constructing ExpensiveElement won't suffice, then consider making default construction super cheap (practically free) and implement a swap method.
To make the default construction super cheap and allow for a swap method, you could implement a fast pimpl on ExpensiveElement. You can make it so the default ctor doesn't even allocate the pimpl, making it a null pointer, while the swap method swaps the two pimpls of ExpensiveElement. Now you have super cheap default construction and a way to swap properly constructed ExpensiveElements into the map, avoiding the redundancy of deep copies all together.
What if ExpensiveElement cannot have a default ctor?
Then make a wrapper which does. The approach can be similar to the pointer wrapper you suggested, except it will be a complete class with valid (safe) copying behavior. The copy ctor can deep copy the pointee, for example, if reference counting is undesired. The difference may sound subtle, but this way it's a very safe and complete solution which doesn't make assumptions about how the tree is implemented; safe and general like boost::shared_ptr but without the reference counting. Just provide a swap method as your one and only means to shallow swap data without requiring a deep copy and use it to swap things into the tree.
What if we need to store polymorphic base pointers?
See answer immediately above and modify the wrapper to call something like clone (prototype pattern) to deep copy the pointee.
",1,3131671
3131988,"
First of all, you could benefit from move semantics here. If you have access to C++0x.
Otherwise, the Boost Pointer Container library has solved the issue of the STL containers of pointers by... recoding it all.
Another issue with containers of pointers that you did not mention is the copy of the container. In your case the original container and its copy both point to the same objects, so changing one will not change the other.
You can of course alleviate this by writing a proxy class which wraps the pointer and provides deep copying semantic (clone method in the object wrapped). But you will then copy the data more often that if the container is pointer aware.... it's less work though.
Note that as well as providing deep-copying semantics, it provides deep-constness. This may or may not be to your taste.
It would also be good taste to provide equivalent to static_cast and dynamic_cast operations, this is left as an exercise to the reader ;)
",0,3131671
3132045,"
It seems that the cleanest solution would be a container adaptor in the style of Boost Pointer Container. This would smooth the syntax a lot as well. However writing such an adaptor is tedious and repetive as you would have to ""lift"" typedefs and repeat every member function of the class that is to be adapted. 
",0,3131671
3132894,"
It looks like option 1 is probably the best. shared_ptr is very common and most people should know how it works. Is there a problem with the syntax map_obj[key].reset(new ValueType);?
Unless you have measurement data that your wrapper for option 2 is a significant savings in use compared to shared_ptr, shared_ptr seems safer since people will know about its semantics right away.
Option three seems complex for what it provides. You need to implement the allocate/construct and deallocate/destruct pairs, and make sure that if a node is copied around it will not have deletion problems.
Option four is probably the second-best option. I wouldn't suggest using it unless profiling shows that the shared_ptr operations really are that expensive though, since this requires reinventing code that's already been written and debugged in the standard library.
",0,3131671
3192086,"
I'ved decided to go with option 1 (tree of shared_ptrs), mainly because it's using standard libraries, but also because the extra refcount per node won't break the bank. Thanks for the replies everyone :)
",0,3131671
3132014,"
1.

I already have option 1 working, but I'm not really happy with it, because I have to actually insert an empty ptr to begin with, then set() the pointer when the insert returns an iterator. This is because the tree uses copy construction, and hence the temporary object passed on the stack will ultimate delete the pointer when it goes out of scope. So I set the pointer upon return. It works, it's hidden, but I don't like it.

Until there is at least one copy of the same shared_ptr, pointed object won't be destroyed so there is no problem you writing about.
2.Your class is pointless. Use shared_ptr. 
3.The allocator would have to know what kind of object to create when asked for a piece of bytes, this is not well solution.
4.Too much complications.
I suggest solution 1.
",-1,3131671
3032625,"
One option is to allocate from a large buffer then deallocate that buffer all at once.
For example (untested):
If pointers to a std::vector's elements are stable, you can make things a bit simplier and just use a std::vector<CNode>.  This requires testing.
",1,3032571
3032604,"
Do you initialize the memory for the nodes themselves? From what I can see, your code only allocates memory for the pointers, not the actual nodes.
As far as your question goes, try to iterate over the tree in an iterative manner, not recursively. Recursion is bad, it's nice only when it's on the paper, not in the code, unfortunately.
",0,3032571
3032613,"
Have you considered just increasing your stack size? 
In visual studio you do it with /FNUMBER where NUMBER is stack size in bytes. You might also need to specify /STACK:reserve[,commit]. 
",0,3032571
3036966,"
You're going to do quite a few deletes. That will take a lot of time, because you will access memory in a very haphazard way. However, at that point you don't need the tree structure anymore. Hence, I would make two passes. In the first pass, create a std::vector<CNode*>, and reserve() enough space for all nodes in your tree. Now recurse over the tree and copy all CNode*'s to your vector. In the second step, sort them (!). Then, in the third step, delete all of them. The second step is technically optional but likely makes the third step a lot faster. If not, try sorting in reverse order.
",0,3032571
3037696,"
I think in this case a breadth-first cleanup might help, by putting all the back-tracking information into a deque rather than on the OS provided stack. It still won't pleasantly solve the problem of making it happen in the destructor though.
Pseudocode:
",0,3032571
2969079,"
I can't imagine why you'd want to, when you have a perfectly good iterative solution, but here you go ;)
I should add that if you really want to traverse the nodes of the tree recursively, then you could do a DFS with a level parameter, and output nodes only at level, then recurse up.   But that's just crazy talk, because you'd revisit nodes wayyyyy too many times... Just accept that BFS is an iterative algorithm. :)
",17,2969033
2969080,"
The BFS algorithm is not a recursive algorithm (as opposed to DFS).
One could try writing a recursive function that emulates the algorithm but that would end up quite bizzare. What would be the point in doing this ?
",10,2969033
2969314,"
You can use iterative deepening depth-first search, which effectively is a breadth-first algorithm that uses recursion. It's even better than BFS if you have a high branching factor, as it doesn't use much memory.
",6,2969033
15099210,"
This is not going to be satisfying to everyone -- I am sure. With all respect to everyone. To the people who ask what is the point? The point is that we believe that every iterative algorithm has also a (easy?) recursive solution. 
Here is a solution by ""sisis"" from stackoverflow.
It has certain amount of funninest in it, but it not clear that it violates any recursive rules. If it does not violate any recursive rules, then it should be accepted. IMHO.
",0,2969033
30021309,"
A Simple BFS and DFS recursion:
Just push/offer the root node of tree in stack/queue and call these functions!
}
}
",0,2969033
2770459,"
For either, returning 0 for a null pointer would end the recursion.
",1,2770428
2770504,"
Is this a question for homework? My answer assumes it is for homework.
Trees are a recursive data structure, so the algorithms that operate on them will often be recursive.  Recursive algorithms need a base case and an inductive case.  For trees, the base case will be what you do when you are visiting a leaf node (i.e. a node without children).  The inductive case will be what you do when you are visiting an internal node (i.e. a node with at least one child).
For calculating depth (or ""height"" of the tree):

Base case: What is the depth of a node without children?
Inductive case: Given that you have the depths of all of your children (which could be different), what is the depth of the current node you're visiting?

For calculating descendant count:

Base case: How many descendants does a node without children have?
Inductive case: Given that you know the descendant count of all of your children, what is the descendant count of the current node you're visiting?

I encourage you to ask clarifying questions.
",3,2770428
2744370,"
Imagine that at any point in a tic-tac-toe board, every single possible move is a branch.  The current state of the board is the root.  One move is a branch.  Now pretend (one at a time), that each branch becomes the current state.  Each possible move becomes a new branch.  The leaf of the tree is when the last move is made and the board is full.
The reason you need to have a tree, is that once it is built, you need to figure out which branch has the most leaves that are 'WIN' scenarios.  You build the branch of all possible outcomes, add up the total number of WINs, and then make the move that has the chance to end up with the most wins.
Make the tree something like this:
Now, you iterate through the list of branches in the tree, and for each branch, iterate through its branches.  This can be done with a recursive function:
Very pseudo-code.
",16,2744334
2744347,"
I don't think you need to keep a tree in memory. You simply need to implement a recursive function that works something like:
Then you simply recurse until you've reached a winning, losing or draw-state.
The call-stack would over time look like a tree if you drew it on paper. You should return the move that leads to a node at which the opponent (definitely / most likely) looses (even though he also plays using getBestMove)
For a state-space as little as tic-tac-toe however, you could simply do a full look-up-table with the best moves! :-)
",6,2744334
2744467,"
You might find this codeproject article interesting :
Solve Tic Tac Toe with the MiniMax algorithm
It's in C#, but it won't be any problem to adapt it in C++.
This article was also a good read for me when I tried to implement my first Tic-Tac-Toe game in C++ :
Minimax Explained
",3,2744334
2744436,"
If you want to generate the tree in memory (which is not necessary), perhaps an algorithm like the following could be used (pseudo-code):
where
",1,2744334
2648111,"
Whats the errno value of the failed fopen() call?  
Do you keep the files you have created open? If yes you are most probably exceeding the maximum number of open files per process.
",1,2648086
2648115,"
When you use directories as data structures, you delegate the work of maintaining that structure to the file system, which is not necessarily designed to do that.
Edit: Frank is probably right that you'v exceeded the number of available file descriptors. You can increase those, but that shows that you're also using internals of your ABI as a data structure. Slow and (as resources are exhausted) unstable.
Either code for a very specific OS installation, or use a SQL database.
",0,2648086
2648133,"
I have no idea why fopen wouldn't work. Look at errno.
However, storing everything in one directory is a bad idea. When you add a lot of files, it will get slow. Having a directory for every level of the tree will also be slow.
Instead, combine multiple levels into one directory. You could, for example, have one directory for every four levels of the tree. This would limit the number of directories, amount of nesting, and number of files per directory, giving very good performance.
",0,2648086
2648457,"
The limitation could come from:

stdio (C library). most 256 handles. Can be increased to 1024 (in VC, call _setmaxstdio)
OS kernel on the file hanldes per process (usually 1024).

",0,2648086
2389682,"
",0,2389583
2333621,"
If you're implementing a tree structure in C# (or Java, or many other languages) you'd use references instead of pointers. NB. references in C++ are not the same as these references.
The usage is similar to pointers for the most part, but there are advantages like garbage collection.
Points of interest:

No need to modify the type with * when declaring the members
No need to set them to null in a constructor (they're already null)
No special -> operator for member access
No need to write a destructor (although look up IDisposable)

",39,2333574
2333614,"
YES. There are pointers in C#.
NO. They are NOT safe.
You actually have to use keyword unsafe when you use pointers in C#. 
For examples look here and MSDN.
",29,2333574
2333585,"

Is there pointer in C# too?

Yes, declared using the syntax int* varName;.

Is using of that safe?

No pointers are not safe.
There are safe ways to construct a data structure without pointers. If the nodes are classes, then they'll automatically be reference types so you don't need any pointers. Otherwise, you can box them into a reference.
",18,2333574
2333836,"
Yes, there is a pointer:
IntPtr
Wikipedia: ""which is a safe managed equivalent to int*, and does not require unsafe code""
",4,2333574
2335868,"
There is a great series of Data Structures implemented in .Net 2 on MSDN.
Data Structures Part 1
They include sample code for things like Binary Search Tree, Graph, SkipList, NodeList, etc.  The code is quite complete and includes a number of pages of docs about why these structures work, etc.  
None of the ones from Microsoft use pointers.  In general you never NEED to use them in C#.  There are times when using them would be nice, or they are just the way you think from C++.  But you can usually find a way not to use them.
The biggest reasons why not to use unsafe code for pointers is that you lose Medium Trust compliance.  You can't run through mechanisms like click once, asp.net websites, and Silverlight doesn't allow them either.  Stick with refs and fully managed concepts to ensure your code can run in more places.
",2,2333574
2292811,"
The rank of the given key K is the number of keys which are less or equal to K.
E.g., let set s = {1, 3, 4, 6, 9}.
Then rank(1) = 1, rank(4) = 3, rank(9) = 5.
The STL function distance() can be used for computing the rank of an element x appearing in the set s.
rank = distance(s.begin(), s.find(x));
The problem is that its time complexity is O(n).
Note that proposed two maps (or sets) indexed by key and by rank is not correct solution.
The problem is that a change of one element affects ranks of many others.
E.g., adding element 0 to the set s above change the ranks of all existing elements:
s' = {0, 1, 3, 4, 6, 9}.
rank(1) = 2, rank(4) = 4, rank(9) = 6.
Thanks.
",5,2290429
4543691,"
I've implemented a ""ranked red-black tree"" which is similar to a red-black tree except each node stores the distance from the node that precedes it via an in-order traversal, rather than storing a key.
This does exactly what you want, except the ""rank"" of the first node is 0 and not 1 (you can add/subtract 1 if needed).
My solution is PUBLIC DOMAIN and is based on a public domain tutorial for a regular red-black tree. All operations -- including insert, remove, find, and determine rank have logarithmic time with respect to the number of elements in the data structure.
You can find it here:
http://code.google.com/p/options/downloads/list
You should get the latest version from the above link, currently (as of this writing) rrb_v4_release.cpp.
",2,2290429
33250302,"
you can use some other map like containers .
keep a size fields can make binary search tree easy to random access .
here is my implementation ...
std style , random access iterator ...
size balanced tree ...
https://github.com/mm304321141/zzz_lib/blob/master/sbtree.h
and B+tree ...
https://github.com/mm304321141/zzz_lib/blob/master/bpptree.h
",1,2290429
2290894,"
I would suppose that by rank you actually mean the distance from the root, since if it could be stored contiguously with the value you would not have to go to such length.
I think you could do it ""externally"", since in this case the rank can be extrapolated from the number of times the comparison predicate is used...
It counts the number of tests, but since std::map stops testing as soon as it gets the right key... it should be alright :) Though there is probably some offset to deduce there (1 or 2) to get the rank instead.
If you gave a better definition of rank I may work a bit more but I don't want to spend too much time in the wrong direction.
",0,2290429
2248150,"
Maps and sets have almost identical behavior and it's common for the implementation to use the exact same underlying technique.
The only important difference is map doesn't use the whole value_type to compare, just the key part of it.
",4,2248136
2248194,"
Usually you'll know right away which you need: if you just have a bool for the ""value"" argument to the map, you probably want a set instead.  
Set is a discrete mathematics concept that, in my experience, pops up again and again in programming.  The stl set class is a relatively efficient way to keep track of sets where the most common opertions are insert/remove/find.
Maps are used where objects have a unique identity that is small compared to their entire set of attributes.  For example, a web page can be defined as a URL and a byte stream of contents.  You could put that byte stream in a set, but the binary search process would be extremely slow (since the contents are much bigger than the URL) and  you wouldn't be able to look up a web page if its contents change.  The URL is the identity of the web page, so it is the key of the map.
",1,2248136
2248423,"
A map is usually implemented as a set< std::pair<> >.  
The set is used when you want an ordered list to quickly search for an item, basically, while a map is used when you want to retrieve a value given its key.
In both cases, the key (for map) or value (for set) must be unique.  If you want to store multiple values that are the same, you would use multimap or multiset.
",0,2248136
1922745,"
Another approach would be to serialize your pointers and restore them when loading. I mean:
Serializing:
Deserializing:
This way if you don't insert-remove new nodes you can allocate a vector once and use that memory, reducing your allocation to the maps ( as rpg said, it might be faster with lists or even vectors).
",3,1913767
1914498,"
First of all - profile your application so that you know what takes time - basing the suspicion on new because you've read somewhere it can be slow or on the iteration through the tree is not enough. 
It's possible it's the IO operations - maybe your file format is not correct/inefficient.
Maybe you just have a defect somewhere?
Or maybe there's a quadratic loop somewhere that you don't remember about causing the problems? :)
Measure what really takes time in your case and then approach the issue - it'll save you a lot of time and you'll avoid breaking your design/code to fix performance issues that don't exist before finding the real cause.
",4,1913767
1913807,"
I highly recommend the boost serialization library. It should work with the solutions you're using.
",1,1913767
1913825,"
The absolute fastest way of serialising/deserialising is writing a block of contiguous memory to disk as you say. If you changed your tree structure to create this (probably using a custom allocation routine) this would be very easy.
Unfortunately I'm not that familiar with QHash, but from looking at it it looks like a Hashtable rather than a tree. Have I misunderstood you? Are you using this to map duplicate nodes?
I'd use a profiler (I used to use Quantify, now called Rational PurifyPlus, but there are a lot listed here) to find where you are using time, but I'd guess it is either multiple memory allocations rather than a single allocation, or multiple reads rather than a single read. To solve both these problems you know in advance (because you store it) how many nodes you need, then write/read an array of nodes of the correct length, where each pointer is an index into the array, rather than a pointer in memory.
",1,1913767
1913833,"
Another solution would be to use your own memory allocator, which will use a continuous memory space. Then you'll be able to dump the memory as is and load it back. It's platform (i.e. big endian/little endian, 32bit/64bit) sensitive.
",0,1913767
1913870,"
As you said, allocating objects with new might be slow. That can be improved allocating an object pool and then using pre-allocated objects until the pool is exhausted. You might even be able to implement this to work in background by overloading the new/delete operators of the class in question.
",0,1913767
1914500,"
Your own memory allocation with an overloaded operator new() and delete() is a low-cost option (development time).
However, this only affects the memory allocation time, and not the Ctor times.
Your mileage may vary, but may worth a try.
",0,1913767
1920438,"
I'll expand my comment a bit: 
Since your profiling suggests that the QHash serialization takes the most time, I believe that replacing QHash with a QList would yield a significant improvement when it comes to deserialization speed.
The QHash serialization just outputs the key/value pairs, but the deserialization constructs a hash data structure!
Even if you said that you need the fast child lookup, I would recommend that you try replacing QHash with a QList > as a test. If there aren't many children for each node (say, less than 30), the lookup should still be fast enough even with a QList. If you find that QList is not fast enough, you could still use it just for (de)serializaton and later convert to a hash once the tree has been loaded.
",0,1913767
1878184,"
Have you considered something like a trie? Lookup is linear in key length, which in your case means essentially constant, and storage can be more compact due to nodes sharing common substrings.
Keep in mind, though, that if your data set is actually filling large amounts of your key space your bigger efficiency concern is likely to be caching and disk access, not lookups.
",2,1877823
1877847,"
Depending on how fast you need this to be you might just treat the whole thing as a single, in-memory table mmap-ed onto a file. Addressing is by direct computation. You can simply chain the free slots so you always know exactly where the next free one is. Most accesses will have a max of 1 or 2 disk accesses (depending on underlying filesystem requirements). Put a buttload of memory on the machine and you might not hit the disk at all.
I know this sounds pretty brute force, but you'd be amazed how fast it can be.
Update in response to: ""I'm not looking for a disk-persistable solution""
Well, if you truly are going to have as many as 2^32 items in this structure (times how big it is) then you either need enough memory on the machine to hold this puppy or the kernel will start to swap things in and out of memory for you. This still translates to hitting the disk. If you let it swap, don't forget to check the size of the swap area, there's a good chance you'll have to bump it. Using mmap (or something similar) is sort of like creating your own private swap area and it will probably have less impact on other processes running on the same system.
I'll note that once this thing exceeds your available physical memory (whether you are using swap space or mmap or B-trees or Black-Red or extensible hashing or whatever) it becomes critical to understand 
your access pattern. If you are hopscotching all over the place you're going to be hitting the disk a lot. One of the primary reasons for using a structure like a B-tree (or any one of several similar structures) is that the top level of the tree (containing the index) tends to stay in memory (because most paging algorithms use LRU) and you only eat a disk access when you touch a leaf page.
Bottom line: it either fits in memory or it doesn't. If it doesn't then your 10^-9 sec memory access turns into a 10^-3 disk access. I.e. 1 million times slower.
 TANSTAAFL!
",5,1877823
1877854,"
I would go for a red-black tree, because it balances the tree on insertion to ensure optimal insertion/deletion/retrieval. An AVL tree is an option, but it's slightly slower for insertions because it's more rigid about balancing on insertions.
http://en.wikipedia.org/wiki/Red-black_tree
http://en.wikipedia.org/wiki/AVL_tree
",2,1877823
1877867,"
My reflex would tell me to reach for a standard implementation, such as the one in stl. But suppose you have reasons to implement your own I would typically go for either Red-Black Trees, which performs well on all operations. Alternatively I would try splay trees which can be really fast but have amortized complexity, i.e. some individual operations might take a little longer.
Stay away from AVL trees as you need to do a lot of updates. AVL trees are good for when you have a lot of lookups but few updates as the updated can be fairly slow.
",1,1877823
1877997,"
Do you expect your tree to really hold 2^32-1 entries?  Even half that and I would definitely try this with SQLite.  You may be able to fit it all in memory, but if you page once, a database will be faster.  Database are meant to handle huge data sets efficiently, especially when the whole set won't fit in memory at once.
I you do intend to do this yourself, look at some database code and use a BTree.  A red-black will be faster with smaller datasets but with that much data your bottle neck isn't going to be processor speed but memory and harddrive speed.
All that said I can't imagine a map of pointers that large being useful.  You'll be pushing the limits of modern memory just storing the map.  You won't have anything left over for the map to point to.
",1,1877823
1889503,"
boost::unordered_map has amortized constant time insertions, deletions and lookups. It's the best data structure for what you described.
Its only downside is that it's, well, unordered as the name says.. And also if you're REALLY unlucky it could end up being linear time if every single hash clashes. However that can be easily avoided using boost's default boost::hash function. Additionally hashing integers is trivial; so that worst case scenario will not happen to you.
(Note: it's not a tree but a hash table, and you asked specifically for a ""Tree"".. Maybe you thought that the most efficient way was some sort of tree (it's not)?)
",0,1877823
1889566,"
Why a tree at all?
To me it seems you need a database. If you expect lower count of nodes, Hash Table could be enough.
I'm going to warn you about the memory. If you fill up whole tree (2^32 items) you will need 4 gigabytes for the values themselves another 8GB for the pointers. Consider the database, if this is likely.
",0,1877823
1889718,"
Each item is represented by a 32-bit identity, which is its key, and two pointers.  Are the pointers associated with the tree, or do they have to do with the identity?
If they're just part of implementing the tree, ditch them.  You don't need them.  Represent whether a number is there or not as a bit in a really big bitmap.  Finding the lowest unused bit isn't fast, but I don't think it can be.  It's only about 512M of main memory, which isn't that bad.
If the pointers are meaningful data, use an array.  You're going to have to allocate space for four giganodes plus pointers to make up the map anyway, so allocate space for four giganodes plus one indicator each for whether the node is active or not.  Use memset() to set the whole thing to zero, and keep a lowest-unused-node pointer.  Use that to add a node.  When you delete a node, mark it as unused, and use the pointers to maintain a two-way linked free list.  You'll have to find the next lower unused node, and that might take a while, but again I don't see how to keep this fast.  (If you just need an unused node, not the lowest one, just put the released node on the free list somewhere.)
This is likely to take about 64G or 96G of RAM, but that's less than a map solution.
",0,1877823
1794389,"
What do you need the tree for? There may already be something in the STL or Boost that satisfies your need. For example: the STL std::map<key,value> is usually implemented as a balanced binary tree.
There is also tree.hh which implements an STL-like n-way tree.
",1,1794233
1794294,"
Trees are subsets of graphs. There are plenty of graph libraries out there, such as Boost Graph Library. You will have to add your vertices as you want and then use any one of the many visitors to traverse your tree.
Alternatively, you could custom make one with standard containers (think of a root node as containing 2 children that have a value and may have 2 other children).
",2,1794233
1794377,"
ACE has an implementation of Red Black tree.  It is fairly easy to use.
link text
",1,1794233
1771251,"
It's not 100% clear what you're asking. The code
declares t to be a reference to a non-const pointer. So, the function insert may change the pointer object of the caller. Since pointers may be null the code probably uses a function called height as a shortcut to handle the special case of null pointers:
(just my guess of what height could look like)
Added after you editited your question:
It seems each node posesses a member called height which is kept in sync and reflects the maximum length of the path from the current node to a leaf. Since a null pointer doesn't point to a node, the subtree would be empty which explains the special case in height() that returns -1.
",1,1771156
1722519,"
I have used this example in the past to develop a project that required us to use a binomial tree model, however, this example is in C#.
http://www.codeproject.com/KB/recipes/binomialtree.aspx
",2,1722387
1673362,"
Yes, you can do this in a number of ways. Here are two common possibilities.
Old-style function pointers
Using functors
With a template member, works with function pointers
",14,1673329
1673371,"
Yes, you can use a function pointer as a parameter to in_order. You may also need to overload it, in case the passed functions' signatures don't match. For functions like print_node, declare in_order like this (provided its return type is void as well):
",1,1673329
1673660,"
I think you should use the visitor pattern instead.
http://en.wikipedia.org/wiki/Visitor_pattern
The base visitor class should have a virtual method to operate on a node. Pass the visitor as an argument to your in_order method.
Then derive your visitor as many times as you want for any operation you want to do.
",1,1673329
1672584,"
For now, you can always use BOOST_AUTO() in the place of C++0x's auto keyword to get intermediate results more easily.
",4,1666176
1666931,"
I don't understand your question. auto is going to be reused in C++0x for automatic type inference. 
I personally see this as a drawback for expression templates since they often relay on having a smaller life span than the objects they are built upon which can turn out to be false if the expression template is captured as I explain here.
",2,1666176
1413302,"
You can't allocate more than 2^32. But you can reallocate used handles if they are released and the problem is to keep track of the free handles.
A tree is a good way to store the free handles. Each node has a lowest and a highest handle, the left subtree contains the handles that are lesser than the lowest and the right subtree contains the handles that are greater than the highest.
An example is:
If a handle is released, it is stored in the tree. For example, if 10 is released, the tree looks like:
If handle 5 is released, you can chose to optimize the tree because 4 can be added to the 5-10 node as wel:
To:
The allocation of a handle, searches for a leaf node with 1 handle and removes it from the tree. If there are no leaves with 1 handle, just use a leaf and decrement the side that is not connected to the parent:
In the above example we allocate 1 and not 2 because if 3 is released, you can combine it with 4 and you want to keep the number of nodes as low as possible.
Below is a pseudocode algorithm. Some parts are left for the reader:
",3,1413193
1413532,"
If memory is not an issue, then you could maintain a list of free handles. When one is released, you add it back to the end of the free list.
At the beginning, you could add all the id to the free list, but it will be inefficient.
The optimization you could do is that you maintain a value that is the minimum id available, as well as the free list. So when the list is empty, you add a number of ids (starting from the minimum id value you are maintaining) to the free list and update the minimum id value.
",3,1413193
1417994,"
If this question is just ""how can I quickly, and safely, calculate a unique, not-currently-used, number"", then a bit-table would give you that.
For the order of 200K unique numbers, 200.000 / 8 = number of bytes needed = 25000, which is just shy of 25KB of memory to keep track of.
Of course, if you need to keep track of data associated with in-use handles, in memory, then you need something else.
Another solution, that would probably be quicker to get a new handle through, would be to keep a stack of unused handles. Each time you need a handle, pop one off the stack.
You could seed the stack with a set number, but the algorithm would also be so that if you try to pop a value off the empty stack, you simply generate a new one by incrementing an ever-increasing value.
Since you say you will have around 200K handles live at any given time, this stack should never grow larger than holding that many number of handles, so you could easily handle this with an array. A 200K 32-bit stack would consume 800.000 bytes, around 781KB of memory.
",0,1413193
1413714,"
Two things:
1: For most cases just represent the state of your program as a Model, and interact with it directly or through the MVC pattern.
2: If you really need a FSM, i.e. you want to randomly make a bunch of actions to your model, only some of which are allowed at certain times. Then....
Still keep the state of your program in a Model (or multiple Models depending on decomposition and complexity) and represent states and transitions like.
Where neighbors contains a dictionary of  of {Action: State}, so that you can do something like
Or even cooler, have an infinite loop randomly selecting an action from the neighbors, executing it, and moving state indefinitely. It's a great way to test your program.
",1,1409006
1409143,"
I'm not sure I follow all the details here.  However, it seems that you are describing an FSM (finite state machine) implementation where you have multiple state machines.  Sometimes, when a particular event (E1) occurs in a particular state (S1) of FSM F1, you need to enter a new FSM (call it F2) to simplify the processing overall).
If that's the case, then when E1 occurs in S1, you need to invoke an action routine that takes over the event reading and implements the F2 FSM.  When invoked, it starts processing in the start state of F2, and handles the relevant sub-events.  When it reaches its end state, the interpreter for F2 finishes.  It might return some information to the F1 action routine that was suspended while F2 ran, and the next state in F1 may be affected by that.
The rest of your description - stuff like 'override blocks' - won't make much sense to people without access to your implementation.
",1,1409006
1058422,"
This is an in-order traversal of an n-tree, but you hit every element, so it's O(n) (big-theta is more appropriate).
",9,1058410
1058436,"
It is a recursive function call. You shall need a bit of looking into recurrence relations to calculate the time complexity in Big O notation.  Your reasoning is correct in a general case. In this specific case, the answers have already been posted. 
EDIT: Refer this link for a discussion of Big-Oh for Recursive Functions.
",2,1058410
1058460,"
You can work this out by considering what happens to a tree with N nodes.
The function will be called once for every node in the tree so is both O(N) and Big-Theta(N).
Consider how it doesn't matter how wide the tree is verses how tall the tree is for the big O value, it still has the same number of visits to make.
That said the depth versus width does affect the space considerations of the function. 
If the tree is extremely wide (say the width is such that the depth is always constant for any N) then the stack space required for the traversal is constant.
If however the width was a fixed constant value > 1 then the stack space required is O(log(N)).
If you had the degenerate case where the width was 1 then the tree becomes a linked list and the space requirements are O(N).
Some languages/compilers will be able to optimize away the recursion so that the space requirements are actually constant (but this is dependent on what you are doing/returning during the traversal).
",2,1058410
1058430,"

In mathematics, computer science, and
  related fields, big O notation
  describes the limiting behavior of a
  function when the argument tends
  towards a particular value or
  infinity, usually in terms of simpler
  functions. Big O notation allows its
  users to simplify functions in order
  to concentrate on their growth rates:
  different functions with the same
  growth rate may be represented using
  the same O notation.

The rest here.
And regarding your example you definitely have O(n).
",1,1058410
1058431,"
This is O(n), where n is the total number of nodes in the tree
",0,1058410
1044227,"
The general case would be:
",4,1044202
1044242,"
This depends on how the child nodes are stored.  Lets assume for a second that they are stored in a vector.  You could then use the following to calculate their height.  
",1,1044202
1044260,"
For what it's worth (almost nothing), this problem renders beautifully in pure-functional languages like SML:
",1,1044202
1044220,"
if non-null:

find the height of each of the children
take the maximum
add 1

",0,1044202
1044218,"
Isn't it '1 + maximum height of sub-tree starting from any of the child nodes of the (current) root node'?
Note that the binary tree is just a special case of the multi-way tree where the child nodes are known to be the left child and the right child.  The result is zero if the root node pointer is null.
",0,1044202
469197,"
I suggest you instead output in Graphviz format (called DOT). This can give very pretty results, and it has had lots of effort spent on its layout routines. A more general-purpose XML visualizer might not have.
",3,469151
469178,"
Just what kind of visualization are you after? If you just want to be able to expand and collapse elements with syntax highlighting then any XML viewer/editor will give you that functionality (hell, even IE can do this natively).
Also, if you can convert to XML you might consider converting to HTML and just visualizing the data that way.
",0,469151
455651,"
The Algorithm Design Manual by Steve Skiena isn't exactly a barrel of laughs, but it's relatively light on the deeper mathematics and contains lots of what he calls ""War Stories"", which are illustrative examples from real world situations where algorithm work really paid off (or, sometimes, totally failed). He's also got his audio and video lectures online, and he's got a nice lecture style with bits of humor interspersed, so it might be what you are looking for.
",20,455627
456528,"
This too is not light either but it is pretty decent 
Algorithms and data structures by Robert Lafore
",2,455627
456553,"
There is nothing more readable and meaningful, in my opinion than http://www.amazon.com/Bundle-Algorithms-Parts-1-5-Fundamentals/dp/020172684X
It's 2 books, part 5 being graphs and is not as useful as the other book - unless of course, you want to use graphs to solve a problem. :)
",1,455627
6787191,"
How to Solve it By Computer by Dromey though not exactly an algorithms book takes the approach of re-discovering the process by which many data-structures and algorithms were arrived at over the years. This allows us to understand the flow of thought behind the code and some of the forces at work.
Related: This book follows in the foot-steps of another great book: How to Solve It by G. Polya which talks about how great mathematicians go about the problem-solving process.
",1,455627
455680,"
I'm currently using Larry Nyhoff's ADTs, Data Structures, and Problem Solving with C++.
It's not as light or enjoyable to read as a Head First series book, but it's really well detailed on binary trees, b trees, and graphs. Its code samples have been really helpful for completing my assignments. No higher math knowledge is required to understand the text (except, of course, on the chapter dedicated to algorithm analysis).
",0,455627
456545,"
Beginning Algorithms by Harris and Ross (a Wrox Press book) was one I liked, although its examples are presented in Java, not C++.  Might be a nice accompaniment to the text you're trudging through in class.
",0,455627
456563,"
I've heard good things about ""Introduction to algorithms, A creative approach - Udi Manber""
I can't verify it though since it's not available locally :(
http://www.amazon.com/Introduction-Algorithms-Creative-Udi-Manber/dp/0201120372
",-1,455627
351548,"
You can do it yourself, or you can do it with boost: http://www.boost.org/doc/libs/1_37_0/libs/serialization/doc/index.html. What you currently try is just view the map as a plain old datatype, which essentially means it's a C datatype. But it isn't, so it fails to save/load. boost serialization does it correctly. Have a look at it. If you don't want to use it, you can do something like this:
Note that the above needs some changes if the characters stored could be whitespace characters too. Because of that, it's probably the best to first convert to an int before writing out, and then reading as an int when loading. Actually, i recommend boost serialization, and boost iostreams (http://www.boost.org/doc/libs/1_37_0/libs/iostreams/doc/index.html), which includes a compression stream that transparently can compress your data too.
",4,351522
351541,"
You can't just serialize the binary values to disk in this way.  The in memory representation is not simply a contiguous block of memory, and even if it was it will likely contain pointers which are relative to the address of the block.
You need to iterate over the map and serialize out each item individually.  Then to bring them back in you reconstruct the map by reading the items off disk one by one and reinserting them into the map.
",3,351522
351535,"
Great question. Problem here is that the default containers don't support serialization - you have to write it yourself, it's a pain, but it's possible.
Here's how you could serialize a std::map to a textual format. You can adapt it to write to whatever binary format you need. Just replace the << operator with reads and writes.
",2,351522
205985,"
There are two reasons you could want to use a tree:
You want to mirror the problem using a tree-like structure:
For this we have boost graph library
Or you want a container that has tree like access characteristics
For this we have

std::map
std::set

Basically the characteristics of these two containers is such that they practically have to be implemented using trees (though this is not actually a requirement).
See also this question:
C tree Implementation
",171,205945
206011,"
Probably for the same reason that there is no tree container in boost. There are many ways to implement such a container, and there is no good way to satisfy everyone who would use it.
Some issues to consider:
 - Are the number of children for a node fixed or variable?
 - How much overhead per node? - ie, do you need parent pointers, sibling pointers, etc.
 - What algorithms to provide? - different iterators, search algorithms, etc.
In the end, the problem ends up being that a tree container that would be useful enough to everyone, would be too heavyweight to satisfy most of the people using it. If you are looking for something powerful, Boost Graph Library is essentially a superset of what a tree library could be used for.
Here are some other generic tree implementations:
 - Kasper Peeters' tree.hh
 - Adobe's forest
 - core::tree
",87,205945
206185,"
The STL's philosophy is that you choose a container based on guarantees and not based on how the container is implemented.  For example, your choice of container may be based on a need for fast lookups.  For all you care, the container may be implemented as a unidirectional list -- as long as searching is very fast you'd be happy.  That's because you're not touching the internals anyhow, you're using iterators or member functions for the access.  Your code is not bound to how the container is implemented but to how fast it is, or whether it has a fixed and defined ordering, or whether it is efficient on space, and so on.
",47,205945
15473485,"

""I want to store a hierarchy of objects as a tree""

C++11 has come and gone and they still didn't see a need to provide a std::tree, although the idea did come up (see here).  Maybe the reason they haven't added this is that it is trivially easy to build your own on top of the existing containers.  For example...
A simple traversal would use recursion...
If you want to maintain a hierarchy and you want it to work with STL algorithms, then things may get complicated.  You could build your own iterators and achieve some compatibility, however many of the algorithms simply don't make any sense for a hierarchy (anything that changes the order of a range, for example).  Even defining a range within a hierarchy could be a messy business.
",45,205945
5777853,"
If you are looking for a RB-tree implementation, then stl_tree.h might be appropriate for you too.
",41,205945
205980,"
the std::map is based on a red black tree. You can also use other containers to help you implement your own types of trees.
",11,205945
205959,"
In a way, std::map is a tree (it is required to have the same performance characteristics as a balanced binary tree) but it doesn't expose other tree functionality.  The likely reasoning behind not including a real tree data structure was probably just a matter of not including everything in the stl.  The stl can be looked as a framework to use in implementing your own algorithms and data structures.
In general, if there's a basic library functionality that you want, that's not in the stl, the fix is to look at BOOST.
Otherwise, there's a bunch of libraries out there, depending on the needs of your tree.
",8,205945
7599162,"
All STL container are externally represented as ""sequences"" with one iteration mechanism.
Trees don't follow this idiom.
",5,205945
205999,"
Because the STL is not an ""everything"" library. It contains, essentially, the minimum structures needed to build things.
",4,205945
7598648,"
This one looks promising and seems to be what you're looking for:
http://tree.phi-sci.com/
",4,205945
15230597,"
IMO, an omission.  But I think there is good reason not to include a Tree structure in the STL.  There is a lot of logic in maintaining a tree, which is best written as member functions into the base TreeNode object.  When TreeNode is wrapped up in an STL header, it just gets messier.
For example:
",2,205945
43431807,"
I think there are several reasons why there are no stl trees. Primarily Trees are a form of recursive data structure which, like a container (list, vector, set), has very different fine structure which makes the correct choices tricky. They are also very easy to construct in basic form using the STL.
A finite rooted tree can be thought of as a container which has a value or payload, say an instance of a class A and, a possibly empty collection of rooted (sub) trees; trees that empty of subtrees are though of as leaves. 
One has to think a little about iterator design etc. and which product and co-product operations one allows to define and be efficient between trees - and the original stl has to be well written - so that the empty set, vector or list container is really empty of any payload in the default case.  
Trees play an essential role in many mathematical structures (see the classical papers of Butcher, Grossman and Larsen; also the papers of Connes and Kriemer for examples of they can be joined, and how they are used to enumerate). It is not correct to think their role is simply to facilitate certain other operations. Rather they facilitate those tasks because of their fundamental role as a data structure. 
However, in addition to trees there are also ""co-trees""; the trees above all have the property that if you delete the root you delete everything.
Consider iterators on the tree, probably they would be realised as a simple stack of iterators, to a node, and to its parent, ... up to the root. 
However, you can have as many as you like; collectively they form a ""tree"" but  where all the arrows flow in the direction toward the root, this co-tree can iterated though iterators towards the trivial iterator and root; however it cannot be navigated across or down (the other iterators are not known to it) nor can the ensemble of iterators be deleted except by keeping track of all the instances. 
Trees are incredibly useful, they have a lot of structure, this makes it a serious challenge to get the definitively correct approach. In my view this is why they are not implemented in the STL. Moreover, in the past, I have seen people get religious and find the idea of a type of container containing instances of its own type challenging - but they have to face it - that is what a tree type represents - it is a node containing a possibly empty collection of (smaller) trees. The current language permits it without challenge providing the default constructor for container<B> does not allocate space on the heap (or anywhere else) for an B, etc. 
I for one would be pleased if this did, in a good form, find its way into the standard.
",2,205945
18077568,"
All STL containers can be used with iterators. You can't have an iterator an a tree, because you don't have ''one right'' way do go through the tree.
",-8,205945
181802,"
I don't know about your requirements, but wouldn't you be better off with a graph (implementations for example in Boost Graph) if you're interested mostly in the structure and not so much in  tree-specific benefits like speed through balancing? You can 'emulate' a tree through a graph, and maybe it'll be (conceptually) closer to what you're looking for.
",23,181630
181649,"
Take a look at this.
The tree.hh library for C++ provides an STL-like container class for n-ary trees, templated over the data stored at the nodes. Various types of iterators are provided (post-order, pre-order, and others). Where possible the access methods are compatible with the STL or alternative algorithms are available.
HTH
",18,181630
181644,"
I am going to suggest using std::map instead of a tree.
The complexity characteristics of a tree are:
Insert:       O(ln(n))
Removal:  O(ln(n))
Find:         O(ln(n))
These are the same characteristics the std::map guarantees.
Thus as a result most implementations of std::map use a tree (Red-Black Tree) underneath the covers (though technically this is not required).
",8,181630
181696,"
If you don't have (key, value) pairs, but simply keys, use std::set. That uses the same Red-Black tree as std::map.
",3,181630
181777,"
Ok folks, I found another tree library; stlplus.ntree. But haven't tried it out yet.
",3,181630
39624561,"
Let suppose the question is about balanced (in some form, mostly red black tree) binary trees, even if it is not the case.
Balanced binaries trees, like vector, allow to manage some ordering of elements without any need of key (like by inserting elements anywhere in vector), but :

With optimal O(log(n)) or better complexity for all the modification of one element (add/remove at begin, end and before & after any iterator)
With persistance of iterators thru any modifications except direct destruction of the element pointed by the iterator.

Optionally one may support access by index like in vector (with a cost of one size_t by element), with O(log(n)) complexity. If used, iterators will be random.
Optionally order can be enforced by some comparison func, but persistence of iterators allow to use non repeatable comparison scheme (ex: arbitrary car lanes change during traffic jam).
In practice, balanced binary tree have interface of vector, list, double linked list, map, multimap, deque, queue, priority_queue... with attaining theoretic optimal O(log(n)) complexity for all single element operations.
<sarcastic> this is probably why c++ stl does not propose it </sarcastic>
Individuals may not implement general balanced tree by themselves, due to the difficulties to get correct management of balancing, especially during element extraction.
There is no widely available implementation of balanced binary tree because the state of the art red black tree (at this time the best type of balanced tree due to fixed number of costly tree reorganizations during remove) know implementation, slavishly copied by every implementers’ from the initial code of the structure inventor, does not allow iterator persistency. It is probably the reason of the absence of fully functionnal tree template.
",-1,181630
7509944,"
This change to root is lost as soon as the function ends, it does not modify the root passed as argument but its own copy of it.
",4,7509921
7510170,"
Take note that when u insert the node, use pointer to pointer (pointer alone is not enough):
So, here is the fixed code:
And in main:
",2,7509921
29568587,"
Your logic is correct!
The only issue is that when you create a local variable, even if it is a pointer, its scope is local to the function. In your main:
function call sends a copy of the root which is a pointer to treeNode (not the address of root). Please note that
gets a treeNode pointer as an argument (not the address of the pointer). Attention: This function call may look like ""call by pointer"" (or reference) but it is actually ""call by value"". The root you define in the main function and the root inside the insert method have different addresses in the stack (memory) since they are different variables. The former is in main function stack in the memory while the latter is in insert method. Therefore once the function call  insert finishes executing, its stack is emptied including the local variable root. For more details on memory refer to: stacks/heaps.
Of course the data in the memory that you allocated using:
still stays in the heap but you have lost the reference to (address of) it once you are out of the insert function. 
The solution is either passing the address of original root to the function and modifying it (as K-ballo and dip has suggested) OR returning the modified local root from the function. For the first approach please refer to the code written by dip in his/her answer. 
I personally prefer returning the modified root from the function since I find it more convenient especially when implementing other common BST algorithms. Here is your function with a slight modification of your original code:
The function call in main will be:
Hope that helps!
",0,7509921
7489040,"
A std::set container is ordered according to a comparison object that is given at construction time. When std::lower_bound is called, there is no way to check that it was passed a matching comparison object, so the implementation can't know whether to use the standard algorithm or one specialized to sets, as the latter is only valid when using the comparison object used for the set's ordering (or one which gives the same results).
The two example prototypes you added won't work:

Specializing std::lower_bound to work on std::set iterators:
This won't work for the reason given above: There is no way to check if the given comparison object matches the one given in the set's constructor. Your prototype only checks that the type of the comparison object matches, but there can be different comparison objects of the same type.
Making std::set::lower_bound take a template argument:
This may make it incompatible with the set's comparison object, since that object's operator() will usually not be templated, and expects only arguments of type T.

",4,7488896
7343140,"
From the docs you should be using a leaf_iterator rather than an iterator, the output you're seeing is from an in order traversal, you want to do a leaf traversal I'm guessing.
btw, thanks for posting this I was just starting in a search for a tree container
hth
",2,7343045
7343225,"
What's happening is that the iterator class is actually just a typedef for the pre_order_traversal class.  So when you set the result of gameTree.beginLeaf() (which returns a leaf_iterator) to an iterator, it invokes the copy constructor of pre_order_iterator because there's a constructor defined for pre_order_traversal(const iterator_base&) (iterator_base is the superclass for all other iterators, including the leaf_iterator), so this creates a new pre_order_iterator from the leaf_iterator.  Then when you use that iterator, it does a depth-first traversal rather than iterating through the leaves.  If you switch to leaf_iterator instead of iterator, the problem will disappear.
This is also why the direct form mentioned in a comment below (where the value is not assigned to an iterator) works properly.
",2,7343045
7343062,"
I don't know what tree<> is, nor do I know the semantics of append_child, but from what I see, 32, 64, 21 and 24 are all below the root of the hierarchy (children and grandchildren of 14); I don't see a problem.
Why exactly should 64 be skipped, but not 24?
",1,7343045
7262910,"
One way to think about this problem is to use the fact that an inorder walk of the tree will produce all of the elements in sorted order.  If you can detect deviations from the sorted order during this walk, you can try to locate the two elements that are in the wrong place.
Let's see how to do this for a simple sorted array first, then will use our algorithm to build something that works on trees.  Intuitively, if we start off with a sorted array and then swap two (non-equal!) elements, we will end up with some number of elements in the array being out of place.  For example, given the array
If we swap 2 and 4, we end up with this array:
How would we detect that 2 and 4 were swapped here?  Well, since 4 is the greater of the two elements and was swapped downward, it should be greater than both of the elements around it.  Similarly, because 2 was swapped up, it should be smaller than both of the elements around it.  From this, we could conclude that 2 and 4 were swapped.
However, this doesn't always work correctly.  For example, suppose that we swap 1 and 4:
Here, both 2 and 1 are smaller than their neighboring elements, and both 4 and 3 are larger than theirs.  From this we can tell that two of these four somehow were swapped, but it's not clear which ones we should interchange.  However, if we take the largest and the smallest of these values (1 and 4, respectively), we end up getting the pair that was swapped.
More generally, to find the elements that were swapped in the sequence, you want to find

The greatest local maximum in the array.
The smallest local minimum in the array.

These two elements are out of place and should be swapped.
Now, let's think about how to apply this to trees.  Since an inorder walk of the tree will produce the sorted sequence with the two elements out of order, one option would be to walk the tree, recording the inorder sequence of elements we've found, then using the above algorithm.  For example, consider your original BST:
If we linearize this into an array, we get
Notice that 16 is greater than its surrounding elements and that 12 is less than its.  This immediately tells us that 12 and 16 were swapped.
A simple algorithm for solving this problem, therefore, would be to do an inorder walk of the tree to linearize it into a sequence like a vector or deque, then to scan that sequence to find the largest local maximum and the smallest local minimum.  This would run in O(n) time, using O(n) space.  A trickier but more space-efficient algorithm would be to only keep track of three nodes at a time - the current node, its predecessor, and its successor - which reduces the memory usage to O(1).
Hope this helps!
",8,7260292
7260686,"
I guess your getMin et getMax works witht the hypotheses that the tree is a BST, so 
(or the equivalent code with a loop). 
If so, your code examines at most three values in the tree. Even if getMax and getMin traversed the full tree to get the actual max/min, you would still base your test on just two comparisons. If you want to check that your tree satisfy the BST property, it is obvious that you have to examine all the values. Its enough to compare each node with its parent.
Edit : that was  wrong, see comment. I believe this one is ok. 
Calling from root with null bounds
",0,7260292
7267357,"
the tree traversal done by templatetypedef works if you are sure there is only one swap. Otherwise I suggest a solution based on your initial code:
It is slower, but it prints all the swaps it identifies. Can be changed to print all violations (e.g. if (max_left > tree->data) print violation). You can improve the performance if you can add two fields to the TreeNode with the max and min precomputed for that subtree.
",0,7260292
7257501,"
What requirements do you have that rule out std::map? As far as I can see it will work well here:
",2,7257218
7257318,"
If you want a tree-like structure, use the Boost Graph Library.
If you want a file system abstraction (with access to the file system in question, not some snapshot in memory you seem to be describing), use Boost.Filesystem
",2,7257218
7211832,"
You can maintain a stack to the current node while you are traversing the tree
When you traverse to a new node, add it to the stack, and then you have your ancestry.
When you finish processing a node, pop it from the stack.
** Edit **
Elaboration for the alignment comment:
when creating children, do it this way:
",4,7211806
7211958,"
If I remember my data structures homework correctly:
What you do is store the balance factor in the node itself as an int that's either:

-1: the node's left subtree is a level higher than the right one (left-heavy)
0 the node is balanced; or 
1 the right subtree is higher (right-heavy). 

You insert(Node subtree) function returns a boolean, which is true if the insertion made the height of subtree increased. You update the balance factor and rebalance the tree as you return from the recursive insert() calls.
This is probably best explained with a few examples:
If the current node is at balance factor -1, you're inserting into the right subtree, and insert(rchild) returns true, you:

update the balance factor of the current node to 0 - the left subtree was higher before the insertion, and the right subtree's height increased, so they're the same height now; and
return false - the shallower tree's height increased, so the current node's height stays the same


If you're inserting into either subtree, and insert(…) returns false:

the balance factor of the current node is unchanged - the subtree heights are the same as before, and so is the balance
return false - the subtree heights haven't changed, so neither has the current node height


If the current node's balance factor is 0, you're inserting into the left subtree, and insert(lchild) returns true:

the balance factor changes to -1 - the subtrees were the same height before the insertion, and the insertion made the left one higher
return true

(Analogously, if inserting into the right subtree, the balance factor will change to 1.)

If the current node's balance factor is -1, you're inserting into the left subtree, and insert(lchild) returns true:
The balance factor would change to -2, which means you have to rebalance the node by doing the appropriate rotation. I'll admit I'm drawing a blank at what each of the four rotations will do to the balance factor and what insert(current) will return, hopefully the previous examples explain the approach to tracking the nodes' balance sufficiently.
",3,7211806
7211894,"
Using double pointers (or references to pointers as you asked for C++) should completely eliminate the need for parent pointers.
",3,7211806
51808344,"
As there's no complete implementation for this question I've decided to add one. It could be done by using a recursive insert returning a current node. So, here's the code:
",2,7211806
40220111,"
The way I coded it is, as you're searching the tree for the element to delete, temporarily change the child link that you traverse (left or right) to be a link in a stack of traversed nodes (effectively a temporary parent pointer).  Then pop each node from this stack, restore the child pointer, and rebalance.
For a C++ encoding, see the remove member function (currently at line 882) in https://github.com/wkaras/C-plus-plus-intrusive-container-templates/blob/master/avl_tree.h .
For a C encoding, see the function whose name is generated by the macro invocation L__(remove) in http://wkaras.webs.com/gen_c/cavl_impl_h.txt .
I don't think having a parent pointer is of any use for inserting.
If you want to delete a node identified by a node pointer rather than a unique key, then it will perhaps be faster I think with parent pointers.
",0,7211806
7137901,"
Looks like you're not actually returning the value of your recursion call:
for that matter not really much need for the variable as it is, what about:

oh, and just as a mention: I would consider using the non-recursive version of this instead; it's also pretty simple:
",6,7137848
7013572,"
Ok, this took a while but I figured out how to get the information from the tree. You cannot directly return the information, it can only be returned through the variable it was given in.
In root the TTree class stores the address to the varriable used for input into it. Using GetEntry() will fill the same variable with the information stored in the TTree.
You can also use tTShowerHeader->Print() to display the number of entires for each branch.
",1,7010587
7012209,"
You are calling tTShowerHeader->GetBranch(""fProjName"")-> and it compiles. That means that return type of tTShowerHeader->GetBranch() is a pointer.
Moreover, you are calling GetClassName() on that pointer and it compiles, so it's a pointer to a class type.
Even more, the std::string does not have a GetClassName() method, so it's not a std::string*. Indeed, it seems it is TBranch *. You must find appropriate method that will give you the text.
PS: Unlearn to use C-style cast in C++. C-style cast is evil, because it will do different things depending on what the type happens to be. Use the restricted static_cast, dynamic_cast, const_cast or function-style casts instead (and reinterpret_cast if you really need that, but that should be extremely rare).
",2,7010587
19988622,"
The solution follows below. 
Imagine you have a ROOT file and you want to save an std::string to it.
To access it:
To print to standard output:
Hope this helps.
",2,7010587
6895219,"
The tree for alpha-beta pruning is usually implicit. It is a way of preventing your AI search algorithm from wasting time on bad solutions. Here is the pseudocode from Wikipedia:
The function recursively evaluates board positions. The ""node"" is the current position, and where it says ""for each child of node"" is where you generate new board positions resulting from each possible move at the current one. The depth parameter controls how far ahead you want to evaluate the tree, for analyzing moves to an unlimited depth might be impractical.

Still, if you have to build a tree of some given depth before pruning it for educational purposes, the structure for a tree with nodes that can have variable numbers of children is very simple and could look something like this:
Here children is a Node array with childCount members. Leaf nodes would have childCount=0. To construct the tree, you would search the availabile board positions like this:
",2,6894566
6850115,"
Ah yes, multiple problems.
1. container There is no standard container for that, you could roll your own, but that's quite a lot of work to make it complete. The best thing I found is the Tree Container Library - free and very well documented. I haven't put it under heavy load, but it ""looks good"" to be an efficient implementation.
2. polymorphic containers - that is, containers with different types as elements - are a bit of a pain in C++. However, since you already have a shared base class, you have quite some options.

[edit] virtual methods in CParentis.
static_cast: you store the items as CParentis * (or better, smart pointer). If for an CParentis * you know what type it actually is, you can cast to it using a static_cast
dynamic_cast: same as above, but dynamic_cast will use runtime type information and you can ""probe"" for the different types. However, it can be comapredly slow depending on class heirarchy and compiler (game developers hate it because under most compilers it can't handle thousands of objects durign rendering a scene) 
boost::any : That's a fabulous piece of code from boost that lets you store any type, and find out ask for it later. Like dynamic_cast, but doesn't need a shared base class. Requires an additional allocaiton, though - might be a problem for millions of objects.
boost::variant: Like boost:any, but for a predefined set of types, woth less overhead.

If you go with the static_cast route, you would need to add an type identifier to your class (or use typeof). However, a switch over types to enable specific handling is a code smell, since it scales badly with number of classes / number of objects involved. Better-scaling solutions are a shared abstract base class (when operations are known in advance) or the visitor pattern (when you need to throw on other operations later).
Last, the smallest: never call that a tree if there's a comp sci major in the room. Hel'll bash you over the head with his e-book reader, explain that it's a directed acyclig graph, and then complain you broke his toy (At least, that's what I imagine our comp sci guy doing if he had an e-book reader...)
",3,6849843
6850170,"
Note that there's no mention of CPrimus etc. Indeed, this structure can hold anything derived from CParentis, including instances of not yet written classes.
You can also use std::whatever_smart_pointer_you_like<...> instead of bare pointers, and whatever container is convenient instead of a vector.
If you can modify CParentis, you may equip it with a std::vector<CParentis*> and do away with Node.
",2,6849843
6850072,"
you need to store pointers (or better smart pointers) to CParentis in your tree (obvious of course). 
Now, about tree implementation. First, check this possible duplicate: What's a good and stable C++ tree implementation?. 
Then, there's a STL-like tree implementation here: http://tree.phi-sci.com/
",0,6849843
6756604,"
Using std::set<T>::upper_bound() simply finds the lexicographical sorted sorted index that is the mathematical upper bound in the tree data-structure that std::set uses.  In this case ""/etc"" was the upper bound to ""home/benjamin"" since if you count through the alphabet, ""home/benjamin"" will come before ""home/benjamin/documents"" and right after ""/etc"". Therefore in the sorted tree, you would find that ""/etc"" was the least upper bound for your search parameter ""home/benjamin"".  If you wanted to get ""/"" as the result, you would have to find the greatest upper bound in the data-structure, not the least upper bound. By ""greatest"", I'm talking in the mathematical sense, where a sorted tree will create a topological sort that has N number of upper-bounds for a given search string, if those upper bounds exist.  The std::set<T>::upper_bound() method finds the least of these upper-bounds, meaning it finds the first possible upper-bound from a lexicographical sort (since that is the method it's using to sort a std::string).  With your ""/home/benjamin"" case, you are looking for the greatest upper-bound that includes a root directory that is a ""special"" directory.  But unfortunately applying that criteria to your other cases will break some of them (i.e., it will always return ""/"").  That means you are going to have to create a custom version of an upper_bound() type function for your needs that does not work strictly by a lexicographical sorting of the elements to find the upper-bound.  In fact I wouldn't even use an upper_bound search.
A better approach would be to use std::string::find_last_of(), and use that to parse your directories by the / character.  Doing so, you can parse and basically ""peel"" back the directory paths until you find a perfect match in your std::set.  So for instance:
",5,6756476
6704525,"
Try Eclipse CDT. It has Include Browser.
",2,6704436
6704523,"
Try Doxygen with Graphviz installed. If doxygen is configured properly, it will return each included file for each source.
",1,6704436
6545705,"
The problem is that you're using a vector, which internally (re-)allocates storage as needed.
So, when pushing back into a vector, it could very well be that the whole internal data is copied to some other memory location - making all pointers that still point to the old locations invalid.
An easy ""fix"" would be to reserve a certain amount of space for the vector, so you can at least store a certain amount of nodes in it without re-allocation.
For example by adding this at the start of your RootedTree constructors :
Note that that is not a robust solution (if you try to put more than 64 nodes in the vector, you're still likely to have the same problem) - but it'll confirm the above analysis.
",1,6545352
6545896,"
You have to decide what kind of structure you want to represent your binary tree. 
Either of

a vector
pointers

Not both!
So your options are 

Removing all pointer related stuff and stick with the vector, treat the Node at index i as the parent to the Nodes at i*2, i*2 + 1. and the opposite for the child -> parent relationship. 
Stop using the vector. Have a root node Node * root inside your RootedTree class. 

They two approaches have different strengths and weaknesses, in particular, the array case lets you get rid of all the pointers, in the pointer case you don't have to worry about the performance of reallocations, and trickier manipulations like deletion is a lot easier. 
",0,6545352
6506580,"
You don't need to lock every node you visit. You can do something like this. Lock a node when you're about to do an insertion. Do your insertion and unlock. If another thread happens to need to insert at the same point it and the node is locked it should wait before traversing down any further. Once the node is unlocked it can then continue traversing the updated part of the tree.
",1,6506513
6506770,"
Another straightforward way is to have 1 lock for the complete tree.
You have a more serialized access to the tree, but you only have one mutex and you lock only once.
If the serialization is an issue, you use a read/write lock. so at least reading can be done in parallel.
",1,6506513
6506884,"
Use a read-write lock. Locking on individual nodes will become exceptionally difficult if you later decide to switch your tree implementation. Here's a little demo code using pthreads:
",1,6506513
7071434,"
Lock the whole tree.  There's no other way that will not get you into trouble sooner or later.  Of course, if there's a lot of concurrent reads and writes, you will get a lot of blocking and slow everything down horribly.
Java introduced a concurrent skip list in version 1.6.  Skip lists work like trees, but are (supposedly) a bit slower.  However, they are based on singly linked lists, and therefore can theoretically be modified without locking using compare-and-swap.  This makes for superb multi-threaded performance.
I googled ""skip list"" C++ compare-and-swap and came up with some interesting info but no C++ code.  However, Java is open source, so you can get the algorithm if you are desperate enough.  The Java class is: java.util.concurrent.ConcurrentSkipListMap.
",1,6506513
6471162,"
In C++, templates can be instantiated on more than just types. They can be instantiated on specific values, if the programmer so desires. In template<int N> class Foo, N is treated as a constant, if you will: instantiate this template and make the constant N have this value.
Arrays, for example, should be of fixed-size (that's how they are, by definition, expected to behave). Therefore, they should be templated with a given constant size. In the upcoming C++ standard, you can instantiate an array by doing std::array<int, 7>; this is an object of type array-of-ints-of-size-seven — yes, the size is a characteristic of the type of an array.
In a nutshell, C++ also allows you to instantiate templates with values, not just with types, because certain types should be defined by a constant value. In the example I gave, the size of the array is a characteristic of the type, not of the object.
",1,6470084
6470204,"
One reason for specifying the value of something using template arguments (rather than a constructor argument) is that it allows the value to be inherited by derived classes.
Also, some constant variables inside a class cannot be initialized using a constructor argument... here's an ad hoc example to show you what I mean.
",1,6470084
6470168,"
Your understanding is partly wrong.

By specifying a particular variable type (in this case int for N) arn't we going against the main purpose of templates? 

No, because these non-type template parameters now allows you to be more specific. Lets take std::array<T,N> from C++0x as an example. It is basically a full-blown static-array like int arr[10]; but with container interface and iterators, aka a way more generic solution. 

Why would we do this? Isn't it better to include the N variable in the constructor?

If you left out the N, aka the size, then it would be nothing more than a std::vector<T> and you'd have to dynamically allocate the array internally. Non-type template parameters help immensly shifting load from run-time to compile-time, like with the std::array if you know the number of elements beforehand.
",1,6470084
6470169,"
The purpose of templates is more general than just allowing types to be substituted. Sometimes there are efficiencies to be gained by knowing an integer value at compile time. The template system was designed to be flexible enough to allow this kind of usage.
",0,6470084
6402831,"
You've asked exactly the same question before:
 Enormous Increase In the Use Of Memory

rtrnmap= (rtrnmap.find(cFvalue) != rtrnmap.end()); does not make sense.
You were told to pass data through references
You were told to add logging information and see how many iterations are performed.

A few comments:

It is a bad idea to have a map with a double as key as you may find yourself unable to retrieve an element due to a tiny difference in the double.
Add only a few elements in the collection and manually go through all the functions in the debugger. You'll get to ""see"" what gets executed and can immediately see if the actual execution flow matches your expectations

And please don't double post your questions (even if you use different users).
EDIT:
We all assumed a proper destructor. Make sure you deallocate any memory you explicitly allocate with new or new[] with delete or delete[] as appropriate.
",1,6402598
6395436,"
If you're running out of memory you have a very deep tree or your Cluster objects are large or both.  Try creating another tree data structure of doubles with the same topology as your Cluster tree and call it RSS tree to hold the RSS values.  Calculate the bottom nodes' rss values and then recursively fill out the rest of the values in the RSS tree.  This way you aren't holding the cluster objects in memory while you do the rss calculation.
",1,6394984
6355714,"
The tree object is really a node in the tree, where children points to the nodes at the next level, which will have pointers to their children, etc. 
Together they form a subtree (or the whole tree, if it is the root node).
",2,6355334
6350071,"
If I understand your question, you're wondering what the Single_linked_list class template parameter means.
Your statement:

in c++ [the *] is the way of specifying that it is to be a pointer, pointing the start of the linked_list with all the children

is worth discussion.  The Single_linked_list template class manages instances of the type given as the template parameter.  The template parameter does not change how the list is used.  The managed type identified by the template parameter may be built-in - like a pointer - or could be a class.  Whatever the template parameter, I would assume that access to the start of the linked list and functions to traverse the list will be accessed by calling methods on children e.g.
The first part of your statement quoted above is correct: the * specifies a pointer type.  The second part of your statement is where I disagree: the template parameter is not related to the idea of the start of the linked_list.
I hope you find my answer valuable.
",0,6349287
6161104,"
I have done this in ideone, and it seems to work: (no segfaults)
",2,6161032
6161390,"
There is no need to malloc the structs if you are only going to push them into a list by value (instead of pointers).  The code could be rewritten to something like this:
Although, for a tree, you would usually have pointers to the left/right nodes, so the structure would be something like:
",1,6161032
6155971,"
You could do something like that:
Implement the tree as a QTreeWidget
Then implement items binded to a mystruct instance
Later on create one YourTreeWidget, and add one item for each of the mystruct instance your have in your array.
Don't forget to format your QTreeWidget correctly according to the data you put in your items.
Again it a simple solution, but I think your can do complexe stuff with that. 
NOTE: when I said 

Do you have to interact a lot with struct 

I meant do you need custom selection, custom edition, custom display ... 
",0,6154474
6192488,"
Being a bioinformatician, my pick would be SeqAn (check out the sequence index section). It implements a lazy suffix tree and an enhanced suffix array (an equivalent data structure), both of which have good cache behaviour.
",8,6123212
6193396,"
Having actually used and then forgotten PATL, I'd like to tuck in a link in an answer.
http://code.google.com/p/patl/
It's got a couple really distinct features, and is generally pleasant reading as well.
",2,6123212
6193591,"
Most likely this is a tutorial but IMO worth reading and with source code: http://marknelson.us/1996/08/01/suffix-trees.
",1,6123212
5964057,"
Check this one out: http://svn.pointclouds.org/pcl/trunk/octree/ 
Updated link: https://github.com/PointCloudLibrary/pcl/tree/master/octree
",8,5963954
8423694,"

http://nomis80.org/code/octree.html
This is my favorite. It is GPL and has it's own homepage, so it's meant to be used by others. It has Doxygen documentation, and the authors are taking questions.
http://www.flipcode.com/archives/Octree_Implementation.shtml
This one is not templated. It has more comments in the code than every other I've seen, so that might be more useful if you are trying to find out how octrees work.

",13,5963954
13301051,"
Also recently released: http://www.openvdb.org/
A volume hierarchy format by Dreamworks.
",9,5963954
5893400,"
The problem is in construct_tree. The calls to it are:
The problem is, every call to construct_tree creates a new node that is added to your tree, even when num is out of range.
",4,5893351
5893495,"
Ted is right. Try changing construct_tree as follows :- 

node *tmp = null;
if(num < SIZE)
{
     tmp= new node();
     ......
}
return tmp;
",2,5893351
5893519,"
You have another problem. Your algorithm for ordering the tree is highly dependent on the order in which you visit the data. Try your solution on 
",1,5893351
5861072,"
Instead of trying to manually implement the recursive algorithm (using stack) just write it recursive. much easier and comprehend-able. And it's as simple as visit left, node, right.
(since it's homework I won't go into more details).
",0,5860785
31010805,"
",0,5860785
12786316,"
I had a similar question on an interview and could find a solution. To traverse using recursion is simple. To write an iterator for breadth-first traverse is simple. But write an iterator for inorder traverse was for me a brain teaser. So after some research on the Net I've found a good solution among others that too verbose and relatively complicate. My language is C# but I hope it wouldn't be hard to translate it into any other one. BinaryTreeNode class has Data, Left, Right properties and is omitted here.
",-1,5860785
6604738,"
If I understand what you're asking, I think you want to use the no_xml_declaration flag.
This suppresses the XML declaration, though for some versions of Xerces-C it results in a spurious newline at the beginning which you'll need to remove.
http://www.codesynthesis.com/pipermail/xsd-users/2009-December/002625.html
For anyone else referencing this question later, you also need to invoke xsdcxx with --generate-serialization. By default only parse methods are emitted.
",0,5843780
11258190,"
Yes, it is possible. If you want to be able to serialize only the address element, you need to pass the --root-element option to the CodeSynthesis XSD command. In Ubuntu you would write
If you on the other hand just need to the value of the address, you could skip serialization altogether and just use the generated get function address()
",0,5843780
5840319,"
This is a very generic answer, but have you tried to explicitly manage your stack through something like a heap allocated queue or a stack?  Basically don't use actually function calls, just push and pull things off your own stack/queue.  They cover non-recursive graph traversal algorithms here (both depth first, and breadth first search).
",2,5839694
5840244,"
Optimize your code, meaning only keep those nodes you need. For example only keep leaf nodes (I mean the ones you haven't yet expaneded).
And yes you can search the tree while building it, write a function to measure the distance between your current state and your goal state, its called heuristic. There's also a better algorithm that solves 8puzzle, it's called A*, I suggest you google it.
",0,5839694
5811386,"
The standard fix is to lazily fix nodes.  Have an access method that looks at the plane you're pointing to, and then sees whether it has been pointed elsewhere.  If it has, recursively search until you find where it is, and fix up all of the objects back to the current one, and then hand back the right plane.
This is a lot more expensive than following a pointer, but in practice this isn't nearly as expensive as you would think since most of the time the final object is in the first or second place that you look.  
",2,5808948
5810699,"
VTK has a similar point handle class vtkIncrementalOctreePointLocator. I think the ideal point to merge the insert point.
E.g.:
So my opinion: if the class too big, it is easier to rebuild it.
",0,5808948
5797803,"
It seems more reasonable to keep the data in some opaque data structure pointed by node, and to keep external pointers to this structures instead of nodes. 
Basicly it means adding a level of indirection between the tree and actual data.
",0,5797769
5798197,"
I'm not sure if this is exactly what you're trying to do, but to keep track of items added to tree/heap data structures, the following has worked for me in the past:
Store two ""index"" vectors in addition to the underlying tree data:
So, to find the index in the tree of the ith item, use item_to_tree[i]. To find the item at a particular jth tree index, use tree_to_item[j]. This is similar to storing explicit pointers, as you've done, but by making use of indices you can essentially get a bi-directional map with O(1) lookup.  
Obviously, within the tree operations, you have to make sure that the mappings stay consistent. I've not thought about this for an RB tree, but definitely for other tree-like structures this just adds some O(1) complexity to each operation.
In the case of the ith item ""removed"" from the tree, tree_to_item no longer contains the ith item index, and I usually set item_to_tree[i] = -1, or some ""empty"" flag.
Hope this helps.
",0,5797769
