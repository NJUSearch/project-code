"language","question","description","code"
"Java","100_doors","There are 100 doors in a row that are all initially closed.\\nYou make 100 passes by the doors.\\nThe first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).\\nThe second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.\\nThe third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.\\n\\nAnswer the question:   what state are the doors in after the last pass?   Which are open, which are closed?\\n\\nAlternate:\\nAs noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.\\nOpening only those doors is an   optimization   that may also be expressed;\\nhowever, as should be obvious, this defeats the intent of comparing implementations across programming languages.\\n\\n","class HundredDoors {\\n    public static void main(String[] args) {\\n        boolean[] doors = new boolean[101];\\n\\n        for (int i = 1; i < doors.length; i++) {\\n            for (int j = i; j < doors.length; j += i) {\\n                doors[j] = !doors[j];\\n            }\\n        }\\n\\n        for (int i = 1; i < doors.length; i++) {\\n            if (doors[i]) {\\n                System.out.printf(\""Door %d is open.%n\"", i);\\n            }\\n        }\\n    }\\n}"
"Java","100_doors","There are 100 doors in a row that are all initially closed.\\nYou make 100 passes by the doors.\\nThe first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).\\nThe second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.\\nThe third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.\\n\\nAnswer the question:   what state are the doors in after the last pass?   Which are open, which are closed?\\n\\nAlternate:\\nAs noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.\\nOpening only those doors is an   optimization   that may also be expressed;\\nhowever, as should be obvious, this defeats the intent of comparing implementations across programming languages.\\n\\n","class HundredDoors {\\n    public static void main(String[] args) {\\n        for (int i = 1; i <= 10; i++)\\n            System.out.printf(\""Door %d is open.%n\"", i * i);\\n    }\\n}"
"Java","100_doors","There are 100 doors in a row that are all initially closed.\\nYou make 100 passes by the doors.\\nThe first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).\\nThe second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.\\nThe third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.\\n\\nAnswer the question:   what state are the doors in after the last pass?   Which are open, which are closed?\\n\\nAlternate:\\nAs noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.\\nOpening only those doors is an   optimization   that may also be expressed;\\nhowever, as should be obvious, this defeats the intent of comparing implementations across programming languages.\\n\\n","import java.util.stream.Collectors;\\nimport java.util.stream.IntStream;\\n\\nclass HundredDoors {\\n    public static void main(String args[]) {\\n        String openDoors = IntStream.rangeClosed(1, 100)\\n                .filter(i -> Math.pow((int) Math.sqrt(i), 2) == i)\\n                .mapToObj(Integer::toString)\\n                .collect(Collectors.joining(\"", \""));\\n        System.out.printf(\""Open doors: %s%n\"", openDoors);\\n    }\\n}\\n"
"Java","15_Puzzle_Game","\\nImplement the Fifteen Puzzle Game.\\n\\nThe   15-puzzle   is also known as:\\n\\n\\nWe fist define a generic package Generic_Puzzle. Upon instantiation, it can take any number of rows, any number of columns for a rows*columns-1 game. Instead of plain numbers, the tiles on the board can have arbitrary names (but they should all be of the same length). The package user can request the name for the tile at a certain (row,column)-point, and the set of possible moves. The user can move the empty space up, down, left and right (if possible). If the user makes the attempt to perform an impossible move, a Constraint_Error is raised.\\nThe package implementation is as follows.\\nThe main program reads the level from the command line. A larger level implies a more difficult instance. The default level is 10, which is fairly simple. After randomizing the board, the user can move the tiles.\\n","package fifteenpuzzle;\\n\\nimport java.awt.*;\\nimport java.awt.event.*;\\nimport java.util.Random;\\nimport javax.swing.*;\\n\\nclass FifteenPuzzle extends JPanel {\\n\\n    private final int side = 4;\\n    private final int numTiles = side * side - 1;\\n\\n    private final Random rand = new Random();\\n    private final int[] tiles = new int[numTiles + 1];\\n    private final int tileSize;\\n    private int blankPos;\\n    private final int margin;\\n    private final int gridSize;\\n    private boolean gameOver;\\n\\n    private FifteenPuzzle() {\\n        final int dim = 640;\\n\\n        margin = 80;\\n        tileSize = (dim - 2 * margin) / side;\\n        gridSize = tileSize * side;\\n\\n        setPreferredSize(new Dimension(dim, dim + margin));\\n        setBackground(Color.WHITE);\\n        setForeground(new Color(0x6495ED)); // cornflowerblue\\n        setFont(new Font(\""SansSerif\"", Font.BOLD, 60));\\n\\n        gameOver = true;\\n\\n        addMouseListener(new MouseAdapter() {\\n            @Override\\n            public void mousePressed(MouseEvent e) {\\n                if (gameOver) {\\n                    newGame();\\n\\n                } else {\\n\\n                    int ex = e.getX() - margin;\\n                    int ey = e.getY() - margin;\\n\\n                    if (ex < 0 || ex > gridSize || ey < 0 || ey > gridSize) {\\n                        return;\\n                    }\\n\\n                    int c1 = ex / tileSize;\\n                    int r1 = ey / tileSize;\\n                    int c2 = blankPos % side;\\n                    int r2 = blankPos / side;\\n\\n                    int clickPos = r1 * side + c1;\\n\\n                    int dir = 0;\\n                    if (c1 == c2 && Math.abs(r1 - r2) > 0) {\\n                        dir = (r1 - r2) > 0 ? 4 : -4;\\n                        \\n                    } else if (r1 == r2 && Math.abs(c1 - c2) > 0) {\\n                        dir = (c1 - c2) > 0 ? 1 : -1;\\n                    }\\n\\n                    if (dir != 0) {\\n                        do {\\n                            int newBlankPos = blankPos + dir;\\n                            tiles[blankPos] = tiles[newBlankPos];\\n                            blankPos = newBlankPos;\\n                        } while (blankPos != clickPos);\\n                        tiles[blankPos] = 0;\\n                    }\\n                    \\n                    gameOver = isSolved();\\n                }\\n                repaint();\\n            }\\n        });\\n\\n        newGame();\\n    }\\n\\n    private void newGame() {\\n        do {\\n            reset();\\n            shuffle();\\n        } while (!isSolvable());\\n        gameOver = false;\\n    }\\n\\n    private void reset() {\\n        for (int i = 0; i < tiles.length; i++) {\\n            tiles[i] = (i + 1) % tiles.length;\\n        }\\n        blankPos = tiles.length - 1;\\n    }\\n\\n    private void shuffle() {\\n        // don't include the blank space in the shuffle, leave it\\n        // in the home position\\n        int n = numTiles;\\n        while (n > 1) {\\n            int r = rand.nextInt(n--);\\n            int tmp = tiles[r];\\n            tiles[r] = tiles[n];\\n            tiles[n] = tmp;\\n        }\\n    }\\n\\n    /*  Only half the permutations of the puzzle are solvable.\\n\\n        Whenever a tile is preceded by a tile with higher value it counts\\n        as an inversion. In our case, with the blank space in the home\\n        position, the number of inversions must be even for the puzzle\\n        to be solvable.\\n\\n        See also:\\n        www.cs.bham.ac.uk/~mdr/teaching/modules04/java2/TilesSolvability.html\\n     */\\n    private boolean isSolvable() {\\n        int countInversions = 0;\\n        for (int i = 0; i < numTiles; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (tiles[j] > tiles[i]) {\\n                    countInversions++;\\n                }\\n            }\\n        }\\n        return countInversions % 2 == 0;\\n    }\\n\\n    private boolean isSolved() {\\n        if (tiles[tiles.length - 1] != 0) {\\n            return false;\\n        }\\n        for (int i = numTiles - 1; i >= 0; i--) {\\n            if (tiles[i] != i + 1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private void drawGrid(Graphics2D g) {\\n        for (int i = 0; i < tiles.length; i++) {\\n            int r = i / side;\\n            int c = i % side;\\n            int x = margin + c * tileSize;\\n            int y = margin + r * tileSize;\\n\\n            if (tiles[i] == 0) {\\n                if (gameOver) {\\n                    g.setColor(Color.GREEN);\\n                    drawCenteredString(g, \""\\u2713\"", x, y);\\n                }\\n                continue;\\n            }\\n\\n            g.setColor(getForeground());\\n            g.fillRoundRect(x, y, tileSize, tileSize, 25, 25);\\n            g.setColor(Color.blue.darker());\\n            g.drawRoundRect(x, y, tileSize, tileSize, 25, 25);\\n            g.setColor(Color.WHITE);\\n\\n            drawCenteredString(g, String.valueOf(tiles[i]), x, y);\\n        }\\n    }\\n\\n    private void drawStartMessage(Graphics2D g) {\\n        if (gameOver) {\\n            g.setFont(getFont().deriveFont(Font.BOLD, 18));\\n            g.setColor(getForeground());\\n            String s = \""click to start a new game\"";\\n            int x = (getWidth() - g.getFontMetrics().stringWidth(s)) / 2;\\n            int y = getHeight() - margin;\\n            g.drawString(s, x, y);\\n        }\\n    }\\n\\n    private void drawCenteredString(Graphics2D g, String s, int x, int y) {\\n        FontMetrics fm = g.getFontMetrics();\\n        int asc = fm.getAscent();\\n        int des = fm.getDescent();\\n\\n        x = x + (tileSize - fm.stringWidth(s)) / 2;\\n        y = y + (asc + (tileSize - (asc + des)) / 2);\\n\\n        g.drawString(s, x, y);\\n    }\\n\\n    @Override\\n    public void paintComponent(Graphics gg) {\\n        super.paintComponent(gg);\\n        Graphics2D g = (Graphics2D) gg;\\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\\n                RenderingHints.VALUE_ANTIALIAS_ON);\\n\\n        drawGrid(g);\\n        drawStartMessage(g);\\n    }\\n\\n    public static void main(String[] args) {\\n        SwingUtilities.invokeLater(() -> {\\n            JFrame f = new JFrame();\\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\\n            f.setTitle(\""Fifteen Puzzle\"");\\n            f.setResizable(false);\\n            f.add(new FifteenPuzzle(), BorderLayout.CENTER);\\n            f.pack();\\n            f.setLocationRelativeTo(null);\\n            f.setVisible(true);\\n        });\\n    }\\n}"
"Java","2048","Implement a 2D sliding block puzzle game where blocks with numbers are combined to add their values.\\nThe rules are that on each turn the player must choose a direction (up, down, left or right) and all tiles move as far as possible in that direction, some more than others. Two adjacent tiles (in that direction only) with matching numbers combine into one bearing the sum of those numbers. A move is valid when at least one tile can be moved, if only by combination. A new tile with the value of 2 is spawned at the end of each turn at a randomly chosen empty square, if there is one. To win the player must create a tile with the number 2048. The player loses if no valid moves are possible.\\nThe name comes from the popular open-source implementation of this game mechanic, 2048.\\nRequirements:\\nto the right should result in\\nand not\\nto the right should result in\\nand not\\n\\n","import java.awt.*;\\nimport java.awt.event.*;\\nimport java.util.Random;\\nimport javax.swing.*;\\n\\npublic class Game2048 extends JPanel {\\n\\n    enum State {\\n        start, won, running, over\\n    }\\n\\n    final Color[] colorTable = {\\n        new Color(0x701710), new Color(0xFFE4C3), new Color(0xfff4d3),\\n        new Color(0xffdac3), new Color(0xe7b08e), new Color(0xe7bf8e),\\n        new Color(0xffc4c3), new Color(0xE7948e), new Color(0xbe7e56),\\n        new Color(0xbe5e56), new Color(0x9c3931), new Color(0x701710)};\\n\\n    final static int target = 2048;\\n\\n    static int highest;\\n    static int score;\\n\\n    private Color gridColor = new Color(0xBBADA0);\\n    private Color emptyColor = new Color(0xCDC1B4);\\n    private Color startColor = new Color(0xFFEBCD);\\n\\n    private Random rand = new Random();\\n\\n    private Tile[][] tiles;\\n    private int side = 4;\\n    private State gamestate = State.start;\\n    private boolean checkingAvailableMoves;\\n\\n    public Game2048() {\\n        setPreferredSize(new Dimension(900, 700));\\n        setBackground(new Color(0xFAF8EF));\\n        setFont(new Font(\""SansSerif\"", Font.BOLD, 48));\\n        setFocusable(true);\\n\\n        addMouseListener(new MouseAdapter() {\\n            @Override\\n            public void mousePressed(MouseEvent e) {\\n                startGame();\\n                repaint();\\n            }\\n        });\\n\\n        addKeyListener(new KeyAdapter() {\\n            @Override\\n            public void keyPressed(KeyEvent e) {\\n                switch (e.getKeyCode()) {\\n                    case KeyEvent.VK_UP:\\n                        moveUp();\\n                        break;\\n                    case KeyEvent.VK_DOWN:\\n                        moveDown();\\n                        break;\\n                    case KeyEvent.VK_LEFT:\\n                        moveLeft();\\n                        break;\\n                    case KeyEvent.VK_RIGHT:\\n                        moveRight();\\n                        break;\\n                }\\n                repaint();\\n            }\\n        });\\n    }\\n\\n    @Override\\n    public void paintComponent(Graphics gg) {\\n        super.paintComponent(gg);\\n        Graphics2D g = (Graphics2D) gg;\\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\\n                RenderingHints.VALUE_ANTIALIAS_ON);\\n\\n        drawGrid(g);\\n    }\\n\\n    void startGame() {\\n        if (gamestate != State.running) {\\n            score = 0;\\n            highest = 0;\\n            gamestate = State.running;\\n            tiles = new Tile[side][side];\\n            addRandomTile();\\n            addRandomTile();\\n        }\\n    }\\n\\n    void drawGrid(Graphics2D g) {\\n        g.setColor(gridColor);\\n        g.fillRoundRect(200, 100, 499, 499, 15, 15);\\n\\n        if (gamestate == State.running) {\\n\\n            for (int r = 0; r < side; r++) {\\n                for (int c = 0; c < side; c++) {\\n                    if (tiles[r][c] == null) {\\n                        g.setColor(emptyColor);\\n                        g.fillRoundRect(215 + c * 121, 115 + r * 121, 106, 106, 7, 7);\\n                    } else {\\n                        drawTile(g, r, c);\\n                    }\\n                }\\n            }\\n        } else {\\n            g.setColor(startColor);\\n            g.fillRoundRect(215, 115, 469, 469, 7, 7);\\n\\n            g.setColor(gridColor.darker());\\n            g.setFont(new Font(\""SansSerif\"", Font.BOLD, 128));\\n            g.drawString(\""2048\"", 310, 270);\\n\\n            g.setFont(new Font(\""SansSerif\"", Font.BOLD, 20));\\n\\n            if (gamestate == State.won) {\\n                g.drawString(\""you made it!\"", 390, 350);\\n\\n            } else if (gamestate == State.over)\\n                g.drawString(\""game over\"", 400, 350);\\n\\n            g.setColor(gridColor);\\n            g.drawString(\""click to start a new game\"", 330, 470);\\n            g.drawString(\""(use arrow keys to move tiles)\"", 310, 530);\\n        }\\n    }\\n\\n    void drawTile(Graphics2D g, int r, int c) {\\n        int value = tiles[r][c].getValue();\\n\\n        g.setColor(colorTable[(int) (Math.log(value) / Math.log(2)) + 1]);\\n        g.fillRoundRect(215 + c * 121, 115 + r * 121, 106, 106, 7, 7);\\n        String s = String.valueOf(value);\\n\\n        g.setColor(value < 128 ? colorTable[0] : colorTable[1]);\\n\\n        FontMetrics fm = g.getFontMetrics();\\n        int asc = fm.getAscent();\\n        int dec = fm.getDescent();\\n\\n        int x = 215 + c * 121 + (106 - fm.stringWidth(s)) / 2;\\n        int y = 115 + r * 121 + (asc + (106 - (asc + dec)) / 2);\\n\\n        g.drawString(s, x, y);\\n    }\\n\\n\\n    private void addRandomTile() {\\n        int pos = rand.nextInt(side * side);\\n        int row, col;\\n        do {\\n            pos = (pos + 1) % (side * side);\\n            row = pos / side;\\n            col = pos % side;\\n        } while (tiles[row][col] != null);\\n\\n        int val = rand.nextInt(10) == 0 ? 4 : 2;\\n        tiles[row][col] = new Tile(val);\\n    }\\n\\n    private boolean move(int countDownFrom, int yIncr, int xIncr) {\\n        boolean moved = false;\\n\\n        for (int i = 0; i < side * side; i++) {\\n            int j = Math.abs(countDownFrom - i);\\n\\n            int r = j / side;\\n            int c = j % side;\\n\\n            if (tiles[r][c] == null)\\n                continue;\\n\\n            int nextR = r + yIncr;\\n            int nextC = c + xIncr;\\n\\n            while (nextR >= 0 && nextR < side && nextC >= 0 && nextC < side) {\\n\\n                Tile next = tiles[nextR][nextC];\\n                Tile curr = tiles[r][c];\\n\\n                if (next == null) {\\n\\n                    if (checkingAvailableMoves)\\n                        return true;\\n\\n                    tiles[nextR][nextC] = curr;\\n                    tiles[r][c] = null;\\n                    r = nextR;\\n                    c = nextC;\\n                    nextR += yIncr;\\n                    nextC += xIncr;\\n                    moved = true;\\n\\n                } else if (next.canMergeWith(curr)) {\\n\\n                    if (checkingAvailableMoves)\\n                        return true;\\n\\n                    int value = next.mergeWith(curr);\\n                    if (value > highest)\\n                        highest = value;\\n                    score += value;\\n                    tiles[r][c] = null;\\n                    moved = true;\\n                    break;\\n                } else\\n                    break;\\n            }\\n        }\\n\\n        if (moved) {\\n            if (highest < target) {\\n                clearMerged();\\n                addRandomTile();\\n                if (!movesAvailable()) {\\n                    gamestate = State.over;\\n                }\\n            } else if (highest == target)\\n                gamestate = State.won;\\n        }\\n\\n        return moved;\\n    }\\n\\n    boolean moveUp() {\\n        return move(0, -1, 0);\\n    }\\n\\n    boolean moveDown() {\\n        return move(side * side - 1, 1, 0);\\n    }\\n\\n    boolean moveLeft() {\\n        return move(0, 0, -1);\\n    }\\n\\n    boolean moveRight() {\\n        return move(side * side - 1, 0, 1);\\n    }\\n\\n    void clearMerged() {\\n        for (Tile[] row : tiles)\\n            for (Tile tile : row)\\n                if (tile != null)\\n                    tile.setMerged(false);\\n    }\\n\\n    boolean movesAvailable() {\\n        checkingAvailableMoves = true;\\n        boolean hasMoves = moveUp() || moveDown() || moveLeft() || moveRight();\\n        checkingAvailableMoves = false;\\n        return hasMoves;\\n    }\\n\\n    public static void main(String[] args) {\\n        SwingUtilities.invokeLater(() -> {\\n            JFrame f = new JFrame();\\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\\n            f.setTitle(\""2048\"");\\n            f.setResizable(true);\\n            f.add(new Game2048(), BorderLayout.CENTER);\\n            f.pack();\\n            f.setLocationRelativeTo(null);\\n            f.setVisible(true);\\n        });\\n    }\\n}\\n\\nclass Tile {\\n    private boolean merged;\\n    private int value;\\n\\n    Tile(int val) {\\n        value = val;\\n    }\\n\\n    int getValue() {\\n        return value;\\n    }\\n\\n    void setMerged(boolean m) {\\n        merged = m;\\n    }\\n\\n    boolean canMergeWith(Tile other) {\\n        return !merged && other != null && !other.merged && value == other.getValue();\\n    }\\n\\n    int mergeWith(Tile other) {\\n        if (canMergeWith(other)) {\\n            value *= 2;\\n            merged = true;\\n            return value;\\n        }\\n        return -1;\\n    }\\n}"
"Java","24_game","\\nThe 24 Game tests one's mental arithmetic.\\n\\nWrite a program that randomly chooses and displays four digits, each from 1 ──► 9 (inclusive) with repetitions allowed.\\nThe program should prompt for the player to enter an arithmetic expression using just those, and all of those four digits, used exactly once each. The program should check then evaluate the expression.\\nThe goal is for the player to enter an expression that (numerically) evaluates to 24.\\n\\n\\n\\n\\nThis is a fully-worked sample of the game in 8th, showing error-detection and user-restriction techniques:\\nSee 24 game/ABAP\\ngame24.adb:\\n","import java.util.*;\\n\\npublic class Game24 {\\n    static Random r = new Random();\\n\\n    public static void main(String[] args) {\\n\\n        int[] digits = randomDigits();\\n        Scanner in = new Scanner(System.in);\\n\\n        System.out.print(\""Make 24 using these digits: \"");\\n        System.out.println(Arrays.toString(digits));\\n        System.out.print(\""> \"");\\n\\n        Stack<Float> s = new Stack<>();\\n        long total = 0;\\n        for (char c : in.nextLine().toCharArray()) {\\n            if ('0' <= c && c <= '9') {\\n                int d = c - '0';\\n                total += (1 << (d * 5));\\n                s.push((float) d);\\n            } else if (\""+/-*\"".indexOf(c) != -1) {\\n                s.push(applyOperator(s.pop(), s.pop(), c));\\n            }\\n        }\\n        if (tallyDigits(digits) != total)\\n            System.out.print(\""Not the same digits. \"");\\n        else if (Math.abs(24 - s.peek()) < 0.001F)\\n            System.out.println(\""Correct!\"");\\n        else\\n            System.out.print(\""Not correct.\"");\\n    }\\n\\n    static float applyOperator(float a, float b, char c) {\\n        switch (c) {\\n            case '+':\\n                return a + b;\\n            case '-':\\n                return b - a;\\n            case '*':\\n                return a * b;\\n            case '/':\\n                return b / a;\\n            default:\\n                return Float.NaN;\\n        }\\n    }\\n\\n    static long tallyDigits(int[] a) {\\n        long total = 0;\\n        for (int i = 0; i < 4; i++)\\n            total += (1 << (a[i] * 5));\\n        return total;\\n    }\\n\\n    static int[] randomDigits() {        \\n        int[] result = new int[4];\\n        for (int i = 0; i < 4; i++)\\n            result[i] = r.nextInt(9) + 1;\\n        return result;\\n    }\\n}"
"Java","24_game/Solve","Write a program that takes four digits, either from user input or by random generation, and computes arithmetic expressions following the rules of the 24 game.\\nShow examples of solutions generated by the program.\\n\\n\\nWill generate all possible solutions of any given four numbers according to the rules of the 24 game.\\nNote: the permute function was locally from here\\nSample Runs:\\nExamples:\\nOutput is in RPN.\\n","import java.util.*;\\n\\npublic class Game24Player {\\n    final String[] patterns = {\""nnonnoo\"", \""nnonono\"", \""nnnoono\"", \""nnnonoo\"",\\n        \""nnnnooo\""};\\n    final String ops = \""+-*/^\"";\\n\\n    String solution;\\n    List<Integer> digits;\\n\\n    public static void main(String[] args) {\\n        new Game24Player().play();\\n    }\\n\\n    void play() {\\n        digits = getSolvableDigits();\\n\\n        Scanner in = new Scanner(System.in);\\n        while (true) {\\n            System.out.print(\""Make 24 using these digits: \"");\\n            System.out.println(digits);\\n            System.out.println(\""(Enter 'q' to quit, 's' for a solution)\"");\\n            System.out.print(\""> \"");\\n\\n            String line = in.nextLine();\\n            if (line.equalsIgnoreCase(\""q\"")) {\\n                System.out.println(\""\\nThanks for playing\"");\\n                return;\\n            }\\n\\n            if (line.equalsIgnoreCase(\""s\"")) {\\n                System.out.println(solution);\\n                digits = getSolvableDigits();\\n                continue;\\n            }\\n\\n            char[] entry = line.replaceAll(\""[^*+-/)(\\\\d]\"", \""\"").toCharArray();\\n\\n            try {\\n                validate(entry);\\n\\n                if (evaluate(infixToPostfix(entry))) {\\n                    System.out.println(\""\\nCorrect! Want to try another? \"");\\n                    digits = getSolvableDigits();\\n                } else {\\n                    System.out.println(\""\\nNot correct.\"");\\n                }\\n\\n            } catch (Exception e) {\\n                System.out.printf(\""%n%s Try again.%n\"", e.getMessage());\\n            }\\n        }\\n    }\\n\\n    void validate(char[] input) throws Exception {\\n        int total1 = 0, parens = 0, opsCount = 0;\\n\\n        for (char c : input) {\\n            if (Character.isDigit(c))\\n                total1 += 1 << (c - '0') * 4;\\n            else if (c == '(')\\n                parens++;\\n            else if (c == ')')\\n                parens--;\\n            else if (ops.indexOf(c) != -1)\\n                opsCount++;\\n            if (parens < 0)\\n                throw new Exception(\""Parentheses mismatch.\"");\\n        }\\n\\n        if (parens != 0)\\n            throw new Exception(\""Parentheses mismatch.\"");\\n\\n        if (opsCount != 3)\\n            throw new Exception(\""Wrong number of operators.\"");\\n\\n        int total2 = 0;\\n        for (int d : digits)\\n            total2 += 1 << d * 4;\\n\\n        if (total1 != total2)\\n            throw new Exception(\""Not the same digits.\"");\\n    }\\n\\n    boolean evaluate(char[] line) throws Exception {\\n        Stack<Float> s = new Stack<>();\\n        try {\\n            for (char c : line) {\\n                if ('0' <= c && c <= '9')\\n                    s.push((float) c - '0');\\n                else\\n                    s.push(applyOperator(s.pop(), s.pop(), c));\\n            }\\n        } catch (EmptyStackException e) {\\n            throw new Exception(\""Invalid entry.\"");\\n        }\\n        return (Math.abs(24 - s.peek()) < 0.001F);\\n    }\\n\\n    float applyOperator(float a, float b, char c) {\\n        switch (c) {\\n            case '+':\\n                return a + b;\\n            case '-':\\n                return b - a;\\n            case '*':\\n                return a * b;\\n            case '/':\\n                return b / a;\\n            default:\\n                return Float.NaN;\\n        }\\n    }\\n\\n    List<Integer> randomDigits() {\\n        Random r = new Random();\\n        List<Integer> result = new ArrayList<>(4);\\n        for (int i = 0; i < 4; i++)\\n            result.add(r.nextInt(9) + 1);\\n        return result;\\n    }\\n\\n    List<Integer> getSolvableDigits() {\\n        List<Integer> result;\\n        do {\\n            result = randomDigits();\\n        } while (!isSolvable(result));\\n        return result;\\n    }\\n\\n    boolean isSolvable(List<Integer> digits) {\\n        Set dPerms = new HashSet<>(4 * 3 * 2);\\n        permute(digits, dPerms, 0);\\n\\n        int total = 4 * 4 * 4;\\n        List oPerms = new ArrayList<>(total);\\n        permuteOperators(oPerms, 4, total);\\n\\n        StringBuilder sb = new StringBuilder(4 + 3);\\n\\n        for (String pattern : patterns) {\\n            char[] patternChars = pattern.toCharArray();\\n\\n            for (List<Integer> dig : dPerms) {\\n                for (List<Integer> opr : oPerms) {\\n\\n                    int i = 0, j = 0;\\n                    for (char c : patternChars) {\\n                        if (c == 'n')\\n                            sb.append(dig.get(i++));\\n                        else\\n                            sb.append(ops.charAt(opr.get(j++)));\\n                    }\\n\\n                    String candidate = sb.toString();\\n                    try {\\n                        if (evaluate(candidate.toCharArray())) {\\n                            solution = postfixToInfix(candidate);\\n                            return true;\\n                        }\\n                    } catch (Exception ignored) {\\n                    }\\n                    sb.setLength(0);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    String postfixToInfix(String postfix) {\\n        class Expression {\\n            String op, ex;\\n            int prec = 3;\\n\\n            Expression(String e) {\\n                ex = e;\\n            }\\n\\n            Expression(String e1, String e2, String o) {\\n                ex = String.format(\""%s %s %s\"", e1, o, e2);\\n                op = o;\\n                prec = ops.indexOf(o) / 2;\\n            }\\n        }\\n\\n        Stack<Expression> expr = new Stack<>();\\n\\n        for (char c : postfix.toCharArray()) {\\n            int idx = ops.indexOf(c);\\n            if (idx != -1) {\\n\\n                Expression r = expr.pop();\\n                Expression l = expr.pop();\\n\\n                int opPrec = idx / 2;\\n\\n                if (l.prec < opPrec)\\n                    l.ex = '(' + l.ex + ')';\\n\\n                if (r.prec <= opPrec)\\n                    r.ex = '(' + r.ex + ')';\\n\\n                expr.push(new Expression(l.ex, r.ex, \""\"" + c));\\n            } else {\\n                expr.push(new Expression(\""\"" + c));\\n            }\\n        }\\n        return expr.peek().ex;\\n    }\\n\\n    char[] infixToPostfix(char[] infix) throws Exception {\\n        StringBuilder sb = new StringBuilder();\\n        Stack<Integer> s = new Stack<>();\\n        try {\\n            for (char c : infix) {\\n                int idx = ops.indexOf(c);\\n                if (idx != -1) {\\n                    if (s.isEmpty())\\n                        s.push(idx);\\n                    else {\\n                        while (!s.isEmpty()) {\\n                            int prec2 = s.peek() / 2;\\n                            int prec1 = idx / 2;\\n                            if (prec2 >= prec1)\\n                                sb.append(ops.charAt(s.pop()));\\n                            else\\n                                break;\\n                        }\\n                        s.push(idx);\\n                    }\\n                } else if (c == '(') {\\n                    s.push(-2);\\n                } else if (c == ')') {\\n                    while (s.peek() != -2)\\n                        sb.append(ops.charAt(s.pop()));\\n                    s.pop();\\n                } else {\\n                    sb.append(c);\\n                }\\n            }\\n            while (!s.isEmpty())\\n                sb.append(ops.charAt(s.pop()));\\n\\n        } catch (EmptyStackException e) {\\n            throw new Exception(\""Invalid entry.\"");\\n        }\\n        return sb.toString().toCharArray();\\n    }\\n\\n    void permute(List<Integer> lst, Set res, int k) {\\n        for (int i = k; i < lst.size(); i++) {\\n            Collections.swap(lst, i, k);\\n            permute(lst, res, k + 1);\\n            Collections.swap(lst, k, i);\\n        }\\n        if (k == lst.size())\\n            res.add(new ArrayList<>(lst));\\n    }\\n\\n    void permuteOperators(List res, int n, int total) {\\n        for (int i = 0, npow = n * n; i < total; i++)\\n            res.add(Arrays.asList((i / npow), (i % npow) / n, i % n));\\n    }\\n}"
"Java","4-rings_or_4-squares_puzzle","Replace       a, b, c, d, e, f,   and\\n  g        with the decimal\\ndigits   LOW   ───►   HIGH\\nsuch that the sum of the letters inside of each of the four large squares add up to\\nthe same sum.\\nShow all output here.\\n\\n\\n\\nAs with the REXX solution, we use explicit loops to generate the permutations.\\n","import java.util.Arrays;\\n\\npublic class FourSquares {\\n    public static void main(String[] args) {\\n        fourSquare(1, 7, true, true);\\n        fourSquare(3, 9, true, true);\\n        fourSquare(0, 9, false, false);\\n    }\\n\\n    private static void fourSquare(int low, int high, boolean unique, boolean print) {\\n        int count = 0;\\n\\n        if (print) {\\n            System.out.println(\""a b c d e f g\"");\\n        }\\n        for (int a = low; a <= high; ++a) {\\n            for (int b = low; b <= high; ++b) {\\n                if (notValid(unique, a, b)) continue;\\n\\n                int fp = a + b;\\n                for (int c = low; c <= high; ++c) {\\n                    if (notValid(unique, c, a, b)) continue;\\n                    for (int d = low; d <= high; ++d) {\\n                        if (notValid(unique, d, a, b, c)) continue;\\n                        if (fp != b + c + d) continue;\\n\\n                        for (int e = low; e <= high; ++e) {\\n                            if (notValid(unique, e, a, b, c, d)) continue;\\n                            for (int f = low; f <= high; ++f) {\\n                                if (notValid(unique, f, a, b, c, d, e)) continue;\\n                                if (fp != d + e + f) continue;\\n\\n                                for (int g = low; g <= high; ++g) {\\n                                    if (notValid(unique, g, a, b, c, d, e, f)) continue;\\n                                    if (fp != f + g) continue;\\n\\n                                    ++count;\\n                                    if (print) {\\n                                        System.out.printf(\""%d %d %d %d %d %d %d%n\"", a, b, c, d, e, f, g);\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if (unique) {\\n            System.out.printf(\""There are %d unique solutions in [%d, %d]%n\"", count, low, high);\\n        } else {\\n            System.out.printf(\""There are %d non-unique solutions in [%d, %d]%n\"", count, low, high);\\n        }\\n    }\\n\\n    private static boolean notValid(boolean unique, int needle, int... haystack) {\\n        return unique && Arrays.stream(haystack).anyMatch(p -> p == needle);\\n    }\\n}"
"Java","9_billion_names_of_God_the_integer","This task is a variation of the short story by Arthur C. Clarke.\\n(Solvers should be aware of the consequences of completing this task.)\\nIn detail, to specify what is meant by a   “name”:\\n\\nDisplay the first 25 rows of a number triangle which begins:\\nWhere row   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n   corresponds to integer   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n,   and each column   \\n\\n\\n\\nC\\n\\n\\n{\\displaystyle C}\\n\\n   in row   \\n\\n\\n\\nm\\n\\n\\n{\\displaystyle m}\\n\\n   from left to right corresponds to the number of names beginning with   \\n\\n\\n\\nC\\n\\n\\n{\\displaystyle C}\\n\\n.\\nA function   \\n\\n\\n\\nG\\n(\\nn\\n)\\n\\n\\n{\\displaystyle G(n)}\\n\\n   should return the sum of the   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n-th   row.\\nDemonstrate this function by displaying:   \\n\\n\\n\\nG\\n(\\n23\\n)\\n\\n\\n{\\displaystyle G(23)}\\n\\n,   \\n\\n\\n\\nG\\n(\\n123\\n)\\n\\n\\n{\\displaystyle G(123)}\\n\\n,   \\n\\n\\n\\nG\\n(\\n1234\\n)\\n\\n\\n{\\displaystyle G(1234)}\\n\\n,   and   \\n\\n\\n\\nG\\n(\\n12345\\n)\\n\\n\\n{\\displaystyle G(12345)}\\n\\n.\\nOptionally note that the sum of the   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n-th   row   \\n\\n\\n\\nP\\n(\\nn\\n)\\n\\n\\n{\\displaystyle P(n)}\\n\\n   is the     integer partition function.\\nDemonstrate this is equivalent to   \\n\\n\\n\\nG\\n(\\nn\\n)\\n\\n\\n{\\displaystyle G(n)}\\n\\n   by displaying:   \\n\\n\\n\\nP\\n(\\n23\\n)\\n\\n\\n{\\displaystyle P(23)}\\n\\n,   \\n\\n\\n\\nP\\n(\\n123\\n)\\n\\n\\n{\\displaystyle P(123)}\\n\\n,   \\n\\n\\n\\nP\\n(\\n1234\\n)\\n\\n\\n{\\displaystyle P(1234)}\\n\\n,   and   \\n\\n\\n\\nP\\n(\\n12345\\n)\\n\\n\\n{\\displaystyle P(12345)}\\n\\n.\\n\\nIf your environment is able, plot   \\n\\n\\n\\nP\\n(\\nn\\n)\\n\\n\\n{\\displaystyle P(n)}\\n\\n   against   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n   for   \\n\\n\\n\\nn\\n=\\n1\\n…\\n999\\n\\n\\n{\\displaystyle n=1\\ldots 999}\\n\\n.\\n\\n","import java.math.BigInteger;\\nimport java.util.*;\\nimport static java.util.Arrays.asList;\\nimport static java.util.stream.Collectors.toList;\\nimport static java.util.stream.IntStream.range;\\nimport static java.lang.Math.min;\\n\\npublic class Test {\\n\\n    static List<BigInteger> cumu(int n) {\\n        List cache = new ArrayList<>();\\n        cache.add(asList(BigInteger.ONE));\\n\\n        for (int L = cache.size(); L < n + 1; L++) {\\n            List<BigInteger> r = new ArrayList<>();\\n            r.add(BigInteger.ZERO);\\n            for (int x = 1; x < L + 1; x++)\\n                r.add(r.get(r.size() - 1).add(cache.get(L - x).get(min(x, L - x))));\\n            cache.add(r);\\n        }\\n        return cache.get(n);\\n    }\\n\\n    static List<BigInteger> row(int n) {\\n        List<BigInteger> r = cumu(n);\\n        return range(0, n).mapToObj(i -> r.get(i + 1).subtract(r.get(i)))\\n                .collect(toList());\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(\""Rows:\"");\\n        for (int x = 1; x < 11; x++)\\n            System.out.printf(\""%2d: %s%n\"", x, row(x));\\n\\n        System.out.println(\""\\nSums:\"");\\n        for (int x : new int[]{23, 123, 1234}) {\\n            List<BigInteger> c = cumu(x);\\n            System.out.printf(\""%s %s%n\"", x, c.get(c.size() - 1));\\n        }\\n    }\\n}"
"Java","99_Bottles_of_Beer","Display the complete lyrics for the song:     99 Bottles of Beer on the Wall.\\n\\nThe lyrics follow this form:\\n 99 bottles of beer on the wall\\n99 bottles of beer\\nTake one down, pass it around\\n98 bottles of beer on the wall\\n 98 bottles of beer on the wall\\n98 bottles of beer\\nTake one down, pass it around\\n97 bottles of beer on the wall\\n... and so on, until reaching 0.\\nGrammatical support for \""1 bottle of beer\"" is optional.\\nAs with any puzzle, try to do it in as creative/concise/comical a way\\nas possible (simple, obvious solutions allowed, too).\\n\\n\\n\\nSee 99 Bottles of Beer/EsoLang\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nor (With ABAP 7.40)\\nSee 99 Bottles of Beer/Lisp\\nwith 1 task to print out the information and 99 tasks to specify the number of bottles\\nImplementation in Apache Ant, due to the limitations of Ant, this requires ant-contrib for arithmetic operations and a dummy target to keep Ant from detecting the loop.\\n\\nNote that the output label text is not displayed until the entire lyrics text has been built and there is some delay between button press and display.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\nOutput can be sent directly to a label with this preferred method as there is no noticeable delay between button press and output.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\n\\n\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Shell\\nSee 99 Bottles of Beer/Shell\\nIf you don't want so many beers, here you can specify the starting amount. \\nFor example, just a sixpack:\\n","import java.text.MessageFormat;\\n\\npublic class Beer {\\n    static String bottles(int n) {\\n        return MessageFormat.format(\""{0,choice,0#No more bottles|1#One bottle|2#{0} bottles} of beer\"", n);\\n    }\\n\\n    public static void main(String[] args) {\\n        String bottles = bottles(99);\\n        for (int n = 99; n > 0; ) {\\n            System.out.println(bottles + \"" on the wall\"");\\n            System.out.println(bottles);\\n            System.out.println(\""Take one down, pass it around\"");\\n            bottles = bottles(--n);\\n            System.out.println(bottles + \"" on the wall\"");\\n            System.out.println();\\n        }\\n    }\\n}"
"Java","99_Bottles_of_Beer","Display the complete lyrics for the song:     99 Bottles of Beer on the Wall.\\n\\nThe lyrics follow this form:\\n 99 bottles of beer on the wall\\n99 bottles of beer\\nTake one down, pass it around\\n98 bottles of beer on the wall\\n 98 bottles of beer on the wall\\n98 bottles of beer\\nTake one down, pass it around\\n97 bottles of beer on the wall\\n... and so on, until reaching 0.\\nGrammatical support for \""1 bottle of beer\"" is optional.\\nAs with any puzzle, try to do it in as creative/concise/comical a way\\nas possible (simple, obvious solutions allowed, too).\\n\\n\\n\\nSee 99 Bottles of Beer/EsoLang\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nor (With ABAP 7.40)\\nSee 99 Bottles of Beer/Lisp\\nwith 1 task to print out the information and 99 tasks to specify the number of bottles\\nImplementation in Apache Ant, due to the limitations of Ant, this requires ant-contrib for arithmetic operations and a dummy target to keep Ant from detecting the loop.\\n\\nNote that the output label text is not displayed until the entire lyrics text has been built and there is some delay between button press and display.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\nOutput can be sent directly to a label with this preferred method as there is no noticeable delay between button press and output.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\n\\n\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Shell\\nSee 99 Bottles of Beer/Shell\\nIf you don't want so many beers, here you can specify the starting amount. \\nFor example, just a sixpack:\\n","public class Beer {\\n    public static void main(String[] args) {\\n        int bottles = 99;\\n        StringBuilder sb = new StringBuilder();\\n        String verse1 = \"" bottles of beer on the wall\\n\"";\\n        String verse2 = \"" bottles of beer.\\nTake one down, pass it around,\\n\"";\\n        String verse3 = \""Better go to the store and buy some more.\"";\\n\\n        while (bottles > 0)\\n            sb.append(bottles).append(verse1).append(bottles).append(verse2).append(--bottles).append(verse1).append(\""\\n\"");\\n\\n        System.out.println(sb.append(verse3));\\n    }\\n}"
"Java","99_Bottles_of_Beer","Display the complete lyrics for the song:     99 Bottles of Beer on the Wall.\\n\\nThe lyrics follow this form:\\n 99 bottles of beer on the wall\\n99 bottles of beer\\nTake one down, pass it around\\n98 bottles of beer on the wall\\n 98 bottles of beer on the wall\\n98 bottles of beer\\nTake one down, pass it around\\n97 bottles of beer on the wall\\n... and so on, until reaching 0.\\nGrammatical support for \""1 bottle of beer\"" is optional.\\nAs with any puzzle, try to do it in as creative/concise/comical a way\\nas possible (simple, obvious solutions allowed, too).\\n\\n\\n\\nSee 99 Bottles of Beer/EsoLang\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nor (With ABAP 7.40)\\nSee 99 Bottles of Beer/Lisp\\nwith 1 task to print out the information and 99 tasks to specify the number of bottles\\nImplementation in Apache Ant, due to the limitations of Ant, this requires ant-contrib for arithmetic operations and a dummy target to keep Ant from detecting the loop.\\n\\nNote that the output label text is not displayed until the entire lyrics text has been built and there is some delay between button press and display.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\nOutput can be sent directly to a label with this preferred method as there is no noticeable delay between button press and output.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\n\\n\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Shell\\nSee 99 Bottles of Beer/Shell\\nIf you don't want so many beers, here you can specify the starting amount. \\nFor example, just a sixpack:\\n","public class Beer {\\n    public static void main(String args[]) {\\n        song(99);\\n    }\\n\\n    public static void song(int bottles) {\\n        if (bottles >= 0) {\\n            if (bottles > 1)\\n                System.out.println(bottles + \"" bottles of beer on the wall\\n\"" + bottles + \"" bottles of beer\\nTake one down, pass it around\\n\"" + (bottles - 1) + \"" bottles of beer on the wall.\\n\"");\\n            else if (bottles == 1)\\n                System.out.println(bottles + \"" bottle of beer on the wall\\n\"" + bottles + \"" bottle of beer\\nTake one down, pass it around\\n\"" + (bottles - 1) + \"" bottles of beer on the wall.\\n\"");\\n            else\\n                System.out.println(bottles + \"" bottles of beer on the wall\\n\"" + bottles + \"" bottles of beer\\nBetter go to the store and buy some more!\"");\\n            song(bottles - 1);\\n        }\\n    }\\n}"
"Java","99_Bottles_of_Beer","Display the complete lyrics for the song:     99 Bottles of Beer on the Wall.\\n\\nThe lyrics follow this form:\\n 99 bottles of beer on the wall\\n99 bottles of beer\\nTake one down, pass it around\\n98 bottles of beer on the wall\\n 98 bottles of beer on the wall\\n98 bottles of beer\\nTake one down, pass it around\\n97 bottles of beer on the wall\\n... and so on, until reaching 0.\\nGrammatical support for \""1 bottle of beer\"" is optional.\\nAs with any puzzle, try to do it in as creative/concise/comical a way\\nas possible (simple, obvious solutions allowed, too).\\n\\n\\n\\nSee 99 Bottles of Beer/EsoLang\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nor (With ABAP 7.40)\\nSee 99 Bottles of Beer/Lisp\\nwith 1 task to print out the information and 99 tasks to specify the number of bottles\\nImplementation in Apache Ant, due to the limitations of Ant, this requires ant-contrib for arithmetic operations and a dummy target to keep Ant from detecting the loop.\\n\\nNote that the output label text is not displayed until the entire lyrics text has been built and there is some delay between button press and display.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\nOutput can be sent directly to a label with this preferred method as there is no noticeable delay between button press and output.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\n\\n\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Shell\\nSee 99 Bottles of Beer/Shell\\nIf you don't want so many beers, here you can specify the starting amount. \\nFor example, just a sixpack:\\n","import java.awt.BorderLayout;\\nimport java.awt.event.ActionEvent;\\nimport javax.swing.JButton;\\nimport javax.swing.JFrame;\\nimport javax.swing.JOptionPane;\\nimport javax.swing.JTextArea;\\n\\npublic class Beer extends JFrame {\\n    private int x;\\n    private JTextArea text;\\n\\n    public static void main(String[] args) {\\n        new Beer().setVisible(true);\\n    }\\n\\n    public Beer() {\\n        x = 99;\\n        \\n        JButton take = new JButton(\""Take one down, pass it around\"");\\n        take.addActionListener(this::onTakeClick);\\n        \\n        text = new JTextArea(4, 30);\\n        text.setText(x + \"" bottles of beer on the wall\\n\"" + x + \"" bottles of beer\"");\\n        text.setEditable(false);\\n        \\n        setLayout(new BorderLayout());\\n        add(text, BorderLayout.CENTER);\\n        add(take, BorderLayout.PAGE_END);\\n        pack();\\n        setLocationRelativeTo(null);\\n        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\\n    }\\n\\n    private void onTakeClick(ActionEvent event) {\\n        JOptionPane.showMessageDialog(null, --x + \"" bottles of beer on the wall\"");\\n        text.setText(x + \"" bottles of beer on the wall\\n\"" + x + \"" bottles of beer\"");\\n        if (x == 0) {\\n            dispose();\\n        }\\n    }\\n}"
"Java","A+B","A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.\\n\\nGiven two integers,   A and B.\\nTheir sum needs to be calculated.\\n\\nTwo integers are written in the input stream, separated by space(s):\\n\\nThe required output is one integer:   the sum of A and B.\\n\\n\\n","import java.util.*;\\n\\npublic class Sum2 {\\n    public static void main(String[] args) {\\n        Scanner in = new Scanner(System.in); // Standard input\\n        System.out.println(in.nextInt() + in.nextInt()); // Standard output\\n    }\\n}"
"Java","A+B","A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.\\n\\nGiven two integers,   A and B.\\nTheir sum needs to be calculated.\\n\\nTwo integers are written in the input stream, separated by space(s):\\n\\nThe required output is one integer:   the sum of A and B.\\n\\n\\n","import java.io.*;\\nimport java.util.*;\\n\\npublic class SumDif {\\n   StreamTokenizer in;\\n   PrintWriter out;\\n\\n   public static void main(String[] args) throws IOException {\\n      new SumDif().run();\\n   }\\n\\n   private int nextInt() throws IOException {\\n      in.nextToken();\\n      return (int)in.nval;\\n   }\\n\\n   public void run() throws IOException {\\n      in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); // Standard input\\n      out = new PrintWriter(new OutputStreamWriter(System.out)); // Standard output\\n      solve();\\n      out.flush();\\n   }\\n\\n   private void solve() throws IOException {\\n      out.println(nextInt() + nextInt());\\n   }\\n}"
"Java","A+B","A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.\\n\\nGiven two integers,   A and B.\\nTheir sum needs to be calculated.\\n\\nTwo integers are written in the input stream, separated by space(s):\\n\\nThe required output is one integer:   the sum of A and B.\\n\\n\\n","import java.io.*;\\nimport java.nio.charset.Charset;\\n\\npublic class AplusB {\\n    public static void main(String[] args) throws IOException {\\n        StreamTokenizer in = new StreamTokenizer(new InputStreamReader(System.in, Charset.defaultCharset()));\\n        in.nextToken();\\n        int a = (int) in.nval;\\n        in.nextToken();\\n        int b = (int) in.nval;\\n\\n        try (Writer out = new OutputStreamWriter(System.out, Charset.defaultCharset())) {\\n            out.write(Integer.toString(a + b));\\n        }\\n    }\\n}\\n"
"Java","Abbreviations,_automatic","The use of   abbreviations   (also sometimes called synonyms, nicknames, AKAs, or aliases)   can be an\\neasy way to add flexibility when specifying or using commands, sub─commands, options, etc.\\n\\nIt would make a list of words easier to maintain   (as words are added, changed, and/or deleted)   if\\nthe minimum abbreviation length of that list could be automatically (programmatically) determined.\\n\\nFor this task, use the list (below) of the days-of-the-week names that are expressed in about a hundred languages   (note that there is a blank line in the list).\\nCaveat:   The list (above) most surely contains errors (or, at the least, differences) of what the actual (or true) names for the days-of-the-week.\\n\\nTo make this Rosetta Code task page as small as possible, if processing the complete list, read the days-of-the-week from a file (that is created from the above list).\\n\\nNotes concerning the above list of words\\n\\n\\n\\n","import java.io.IOException;\\nimport java.nio.file.Files;\\nimport java.nio.file.Path;\\nimport java.nio.file.Paths;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\n\\npublic class Abbreviations {\\n    public static void main(String[] args) throws IOException {\\n        Path path = Paths.get(\""days_of_week.txt\"");\\n        List<String> readAllLines = Files.readAllLines(path);\\n        for (int i = 0; i < readAllLines.size(); i++) {\\n            String line = readAllLines.get(i);\\n            if (line.length() == 0) continue;\\n\\n            String[] days = line.split(\"" \"");\\n            if (days.length != 7) throw new RuntimeException(\""There aren't 7 days on line \"" + (i + 1));\\n\\n            Map temp = new HashMap<>();\\n            for (String day : days) {\\n                Integer count = temp.getOrDefault(day, 0);\\n                temp.put(day, count + 1);\\n            }\\n            if (temp.size() < 7) {\\n                System.out.print(\"" ∞  \"");\\n                System.out.println(line);\\n                continue;\\n            }\\n\\n            int len = 1;\\n            while (true) {\\n                temp.clear();\\n                for (String day : days) {\\n                    String sd;\\n                    if (len >= day.length()) {\\n                        sd = day;\\n                    } else {\\n                        sd = day.substring(0, len);\\n                    }\\n                    Integer count = temp.getOrDefault(sd, 0);\\n                    temp.put(sd, count + 1);\\n                }\\n                if (temp.size() == 7) {\\n                    System.out.printf(\""%2d  %s\\n\"", len, line);\\n                    break;\\n                }\\n                len++;\\n            }\\n        }\\n    }\\n}"
"Java","ABC_Problem","\\nYou are given a collection of ABC blocks   (maybe like the ones you had when you were a kid).\\nThere are twenty blocks with two letters on each block.\\nA complete alphabet is guaranteed amongst all sides of the blocks.\\nThe sample collection of blocks:\\n\\nWrite a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks.\\n\\nThe rules are simple:\\n\\n\\nThe program uses one ASSIST macro (XPRNT) to keep the code as short as possible.\\n","import java.util.Arrays;\\nimport java.util.Collections;\\nimport java.util.List;\\n\\npublic class ABC {\\n\\n    public static void main(String[] args) {\\n        List<String> blocks = Arrays.asList(\\n                \""BO\"", \""XK\"", \""DQ\"", \""CP\"", \""NA\"",\\n                \""GT\"", \""RE\"", \""TG\"", \""QD\"", \""FS\"",\\n                \""JW\"", \""HU\"", \""VI\"", \""AN\"", \""OB\"",\\n                \""ER\"", \""FS\"", \""LY\"", \""PC\"", \""ZM\"");\\n\\n        for (String word : Arrays.asList(\""\"", \""A\"", \""BARK\"", \""BOOK\"", \""TREAT\"", \""COMMON\"", \""SQUAD\"", \""CONFUSE\"")) {\\n            System.out.printf(\""%s: %s%n\"", word.isEmpty() ? \""\\\""\\\""\"" : word, canMakeWord(word, blocks));\\n        }\\n    }\\n\\n    public static boolean canMakeWord(String word, List<String> blocks) {\\n        if (word.isEmpty())\\n            return true;\\n\\n        char c = word.charAt(0);\\n        for (int i = 0; i < blocks.size(); i++) {\\n            String b = blocks.get(i);\\n            if (b.charAt(0) != c && b.charAt(1) != c)\\n                continue;\\n            Collections.swap(blocks, 0, i);\\n            if (canMakeWord(word.substring(1), blocks.subList(1, blocks.size())))\\n                return true;\\n            Collections.swap(blocks, 0, i);\\n        }\\n\\n        return false;\\n    }\\n}"
"Java","Abstract_type","Abstract type is a type without instances or without definition.\\nFor example in object-oriented programming using some languages, abstract types can be partial implementations of other types, which are to be derived there-from. An abstract type may provide implementation of some operations and/or components. Abstract types without any implementation are called interfaces. In the languages that do not support multiple inheritance (Ada, Java), classes can, nonetheless, inherit from multiple interfaces. The languages with multiple inheritance (like C++) usually make no distinction between partially implementable abstract types and interfaces. Because the abstract type's implementation is incomplete,  OO languages normally prevent instantiation from them (instantiation must derived from one of their descendant classes).\\nThe term abstract datatype also may denote a type, with an implementation provided by the programmer rather than directly by the language (a built-in or an inferred type). Here the word abstract means that the implementation is abstracted away, irrelevant for the user of the type. Such implementation can and should be hidden if the language supports separation of implementation and specification. This hides complexity while allowing the implementation to change without repercussions on the usage. The corresponding software design practice is said to follow the information hiding principle.\\nIt is important not to confuse this abstractness (of implementation) with one of the abstract type. The latter is abstract in the sense that the set of its values is empty. In the sense of implementation abstracted away, all user-defined types are abstract.\\nIn some languages, like for example in Objective Caml which is strongly statically typed, it is also possible to have abstract types that are not OO related and are not an abstractness too. These are pure abstract types without any definition even in the implementation and can be used for example for the type algebra, or for some consistence of the type inference. For example in this area, an abstract type can be used as a phantom type to augment another type as its parameter.\\nTask: show how an abstract type can be declared in the language. If the language makes a distinction between interfaces and partially implemented types illustrate both.\\n\\nInterfaces in ABAP are classes with the following restrictions:\\n1. All methods must be abstract instance methods (Static methods aren't allowed).\\n2. Variables must be static final. The values may be computed at run time.\\n3. No static initialiser blockers. No static initialiser helper methods.\\nWhile ActionScript does not support explicit abstract classes, it does have interfaces. Interfaces in ActionScript may not implement any methods and all methods are public and implicitly abstract. Interfaces can extend other interfaces, and interfaces may be multiply inherited.\\nAbstract types can also be simulated using the built-in flash.utils.getQualifiedClassName() function in the constructor to check that the runtime type is an inhertied class, and throwing exceptions from \""abstract\"" methods which can be overridden by inheritors to disable them. If any inheriting class does not implement an abstract method, the error will not be thrown until the non-implemented method is called.\\nInheriting this class:\\nInterfaces in Ada may have no components or implemented operation except for ones implemented as null operations. Interfaces can be multiply inherited.\\nInterfaces can be declared synchronized or task when intended implementations are to be provided by protected objects or tasks. For example:\\nAbstract types may provide components and implementation of their operations. Abstract types are singly inherited.\\nHere Node is an abstract type that is inherited from Limited_Controlled and implements a node of a  doubly linked list. It also implements the interface of a queue described above, because any node can be considered a head of the queue of linked elements. For the operation Finalize an implementation is provided to ensure that the element of a list is removed from there upon its finalization. The operation itself is inherited from the parent type Limited_Controlled and then overridden. The operations Dequeue and Enqueue of the Queue interface are also implemented.\\nUsing records for storing the interface methods and instance arguments (which are similar to Haskell type classes) for overloading:\\nThere is dog and cat is objects of different types for which the interface method is implemented.\\nAn abstract class contains functions that have no body defined. You cannot instantiate a class that contains abstract functions.\\nInterfaces in Aikido define a set of functions, operators, classes, interfaces, monitors or threads (but no variables) that must be implemented by a class implementing the interface.\\nIn AmigaE, abstract methods are supported but interfaces are not.\\nprints to the console:\\nred orange\\n\\nBBC BASIC is a procedural language with no built-in OO features. The CLASSLIB library implements simple Object Classes with multiple inheritance; an abstract class may be created without any instantiation, the sole purpose of which is for other classes to inherit from it. At least one member or method must be declared, but no error will be generated if there is no implementation:\\nDoing abstract types in C is not particularly trivial as C doesn't really support classes. The following series will show an abstract type, followed by a realizable class that provides the abstract interface, and finally followed by an example of usage.\\nThe header file for the abstract class, interfaceAbs.h\\nThat will define the abstract class. The next section declares a public interface for a class providing the interface of the abstract class. This class is Silly and\\nthe code is in file silly.h. Note the actual structure of the class is not provided\\nhere. We don't want it visible.\\nOk. Now it is necessary to provide the implementation of the realizable class.\\nThis code should be in silly.c.\\nThat last macro, ABSTRACT_METHODS may need a little explanation. First note that macros do a string substitution of the parameter values into the arguments of the defined macro, with a little hitch. In the macro definition the ' ## ' expression is special. Here cName ## _Iface gets converted to Silly_Iface, as 'Silly' replaces cName. So the macro call declares an instance of the class record, and defines a constructor named Silly_Instance, which takes a Silly structure as an arguments\\nand uses the class record it previously set up as well.\\nThe methods MyMethod1, MyMethod2, and MyMethod3 are called through the abstract class interface and do not need to be visible outside this file. Hence, they are declared static.\\nNow all's left is some example code that uses all this stuff.\\nYou can declare a virtual function to not have an implementation (called \""pure virtual function\"") by the following \""= 0\"" syntax after the method declaration. A class containing at least one pure virtual function (or inheriting one and not overriding it) cannot be instantiated.\\nBecause C++ allows multiple inheritance of classes, no distinction is made between interfaces and abstract classes.\\nIn Caché, abstract and data type classes cannot be instantiated directly - there must be a 'concrete subclass' that extends them as well as the '%RegisteredObject' class in order to instantiate an object, see example below.\\nData type classes differ because they cannot contain properties, see example below.\\nBoth class types can contain implementation code. Caché allows multiple inheritance of classes, so no distinction is made between abstract classes and interfaces.\\n","public abstract class Abs {\\n    public abstract int method1(double value);\\n    protected abstract int method2(String name);\\n    int add(int a, int b) {\\n        return a + b;\\n    }\\n}"
"Java","Abstract_type","Abstract type is a type without instances or without definition.\\nFor example in object-oriented programming using some languages, abstract types can be partial implementations of other types, which are to be derived there-from. An abstract type may provide implementation of some operations and/or components. Abstract types without any implementation are called interfaces. In the languages that do not support multiple inheritance (Ada, Java), classes can, nonetheless, inherit from multiple interfaces. The languages with multiple inheritance (like C++) usually make no distinction between partially implementable abstract types and interfaces. Because the abstract type's implementation is incomplete,  OO languages normally prevent instantiation from them (instantiation must derived from one of their descendant classes).\\nThe term abstract datatype also may denote a type, with an implementation provided by the programmer rather than directly by the language (a built-in or an inferred type). Here the word abstract means that the implementation is abstracted away, irrelevant for the user of the type. Such implementation can and should be hidden if the language supports separation of implementation and specification. This hides complexity while allowing the implementation to change without repercussions on the usage. The corresponding software design practice is said to follow the information hiding principle.\\nIt is important not to confuse this abstractness (of implementation) with one of the abstract type. The latter is abstract in the sense that the set of its values is empty. In the sense of implementation abstracted away, all user-defined types are abstract.\\nIn some languages, like for example in Objective Caml which is strongly statically typed, it is also possible to have abstract types that are not OO related and are not an abstractness too. These are pure abstract types without any definition even in the implementation and can be used for example for the type algebra, or for some consistence of the type inference. For example in this area, an abstract type can be used as a phantom type to augment another type as its parameter.\\nTask: show how an abstract type can be declared in the language. If the language makes a distinction between interfaces and partially implemented types illustrate both.\\n\\nInterfaces in ABAP are classes with the following restrictions:\\n1. All methods must be abstract instance methods (Static methods aren't allowed).\\n2. Variables must be static final. The values may be computed at run time.\\n3. No static initialiser blockers. No static initialiser helper methods.\\nWhile ActionScript does not support explicit abstract classes, it does have interfaces. Interfaces in ActionScript may not implement any methods and all methods are public and implicitly abstract. Interfaces can extend other interfaces, and interfaces may be multiply inherited.\\nAbstract types can also be simulated using the built-in flash.utils.getQualifiedClassName() function in the constructor to check that the runtime type is an inhertied class, and throwing exceptions from \""abstract\"" methods which can be overridden by inheritors to disable them. If any inheriting class does not implement an abstract method, the error will not be thrown until the non-implemented method is called.\\nInheriting this class:\\nInterfaces in Ada may have no components or implemented operation except for ones implemented as null operations. Interfaces can be multiply inherited.\\nInterfaces can be declared synchronized or task when intended implementations are to be provided by protected objects or tasks. For example:\\nAbstract types may provide components and implementation of their operations. Abstract types are singly inherited.\\nHere Node is an abstract type that is inherited from Limited_Controlled and implements a node of a  doubly linked list. It also implements the interface of a queue described above, because any node can be considered a head of the queue of linked elements. For the operation Finalize an implementation is provided to ensure that the element of a list is removed from there upon its finalization. The operation itself is inherited from the parent type Limited_Controlled and then overridden. The operations Dequeue and Enqueue of the Queue interface are also implemented.\\nUsing records for storing the interface methods and instance arguments (which are similar to Haskell type classes) for overloading:\\nThere is dog and cat is objects of different types for which the interface method is implemented.\\nAn abstract class contains functions that have no body defined. You cannot instantiate a class that contains abstract functions.\\nInterfaces in Aikido define a set of functions, operators, classes, interfaces, monitors or threads (but no variables) that must be implemented by a class implementing the interface.\\nIn AmigaE, abstract methods are supported but interfaces are not.\\nprints to the console:\\nred orange\\n\\nBBC BASIC is a procedural language with no built-in OO features. The CLASSLIB library implements simple Object Classes with multiple inheritance; an abstract class may be created without any instantiation, the sole purpose of which is for other classes to inherit from it. At least one member or method must be declared, but no error will be generated if there is no implementation:\\nDoing abstract types in C is not particularly trivial as C doesn't really support classes. The following series will show an abstract type, followed by a realizable class that provides the abstract interface, and finally followed by an example of usage.\\nThe header file for the abstract class, interfaceAbs.h\\nThat will define the abstract class. The next section declares a public interface for a class providing the interface of the abstract class. This class is Silly and\\nthe code is in file silly.h. Note the actual structure of the class is not provided\\nhere. We don't want it visible.\\nOk. Now it is necessary to provide the implementation of the realizable class.\\nThis code should be in silly.c.\\nThat last macro, ABSTRACT_METHODS may need a little explanation. First note that macros do a string substitution of the parameter values into the arguments of the defined macro, with a little hitch. In the macro definition the ' ## ' expression is special. Here cName ## _Iface gets converted to Silly_Iface, as 'Silly' replaces cName. So the macro call declares an instance of the class record, and defines a constructor named Silly_Instance, which takes a Silly structure as an arguments\\nand uses the class record it previously set up as well.\\nThe methods MyMethod1, MyMethod2, and MyMethod3 are called through the abstract class interface and do not need to be visible outside this file. Hence, they are declared static.\\nNow all's left is some example code that uses all this stuff.\\nYou can declare a virtual function to not have an implementation (called \""pure virtual function\"") by the following \""= 0\"" syntax after the method declaration. A class containing at least one pure virtual function (or inheriting one and not overriding it) cannot be instantiated.\\nBecause C++ allows multiple inheritance of classes, no distinction is made between interfaces and abstract classes.\\nIn Caché, abstract and data type classes cannot be instantiated directly - there must be a 'concrete subclass' that extends them as well as the '%RegisteredObject' class in order to instantiate an object, see example below.\\nData type classes differ because they cannot contain properties, see example below.\\nBoth class types can contain implementation code. Caché allows multiple inheritance of classes, so no distinction is made between abstract classes and interfaces.\\n","public interface Inter {\\n    int method1(double value);\\n    int method2(String name);\\n    int add(int a, int b);\\n}"
"Java","Abundant,_deficient_and_perfect_number_classifications","These define three classifications of positive integers based on their   proper divisors.\\nLet   P(n)   be the sum of the proper divisors of   n   where the proper divisors are all positive divisors of   n   other than   n   itself.\\n\\n6   has proper divisors of   1,   2,   and   3.\\n1 + 2 + 3 = 6,   so   6   is classed as a perfect number.\\n\\nCalculate how many of the integers   1   to   20,000   (inclusive) are in each of the three classes.\\nShow the results here.\\n\\n\\n","import java.util.stream.LongStream;\\n\\npublic class NumberClassifications {\\n \\n    public static void main(String[] args) {\\n        int deficient = 0;\\n        int perfect = 0;\\n        int abundant = 0;\\n \\n        for (long i = 1; i <= 20_000; i++) {\\n            long sum = properDivsSum(i);\\n            if (sum < i)\\n                deficient++;\\n            else if (sum == i)\\n                perfect++;\\n            else\\n                abundant++;\\n        }\\n        System.out.println(\""Deficient: \"" + deficient);\\n        System.out.println(\""Perfect: \"" + perfect);\\n        System.out.println(\""Abundant: \"" + abundant);\\n    }\\n \\n    public static long properDivsSum(long n) {\\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n != i && n % i == 0).sum();\\n    }\\n}"
"Java","Accumulator_factory","A problem posed by Paul Graham is that of creating a function that takes a single (numeric) argument and which returns another function that is an accumulator. The returned accumulator function in turn also takes a single numeric argument, and returns the sum of all the numeric values passed in so far to that accumulator (including the initial value passed when the accumulator was created).\\n\\nThe detailed rules are at http://paulgraham.com/accgensub.html and are reproduced here for simplicity (with additions in small italic text).\\n\\nCreate a function that implements the described rules.\\n\\nIt need not handle any special error cases not described above. The simplest way to implement the task as described is typically to use a closure, providing the language supports them.\\nWhere it is not possible to hold exactly to the constraints above, describe the deviations.\\n\\n","public class Accumulator\\n    //implements java.util.function.UnaryOperator<Number> // Java 8\\n{\\n    private Number sum;\\n\\n    public Accumulator(Number sum0) {\\n	sum = sum0;\\n    }\\n\\n    public Number apply(Number n) {\\n	// Acts like sum += n, but chooses long or double.\\n	// Converts weird types (like BigInteger) to double.\\n	return (longable(sum) && longable(n)) ?\\n	    (sum = sum.longValue() + n.longValue()) :\\n	    (sum = sum.doubleValue() + n.doubleValue());\\n    }\\n\\n    private static boolean longable(Number n) {\\n	return n instanceof Byte || n instanceof Short ||\\n	    n instanceof Integer || n instanceof Long;\\n    }\\n\\n    public static void main(String[] args) {\\n	Accumulator x = new Accumulator(1);\\n	x.apply(5);\\n	new Accumulator(3);\\n	System.out.println(x.apply(2.3));\\n    }\\n}\\n"
"Java","Accumulator_factory","A problem posed by Paul Graham is that of creating a function that takes a single (numeric) argument and which returns another function that is an accumulator. The returned accumulator function in turn also takes a single numeric argument, and returns the sum of all the numeric values passed in so far to that accumulator (including the initial value passed when the accumulator was created).\\n\\nThe detailed rules are at http://paulgraham.com/accgensub.html and are reproduced here for simplicity (with additions in small italic text).\\n\\nCreate a function that implements the described rules.\\n\\nIt need not handle any special error cases not described above. The simplest way to implement the task as described is typically to use a closure, providing the language supports them.\\nWhere it is not possible to hold exactly to the constraints above, describe the deviations.\\n\\n","import java.util.function.UnaryOperator;\\n\\npublic class AccumulatorFactory {\\n\\n    public static UnaryOperator<Number> accumulator(Number sum0) {\\n	// Allows sum[0] = ... inside lambda.\\n	Number[] sum = { sum0 };\\n\\n	// Acts like n -> sum[0] += n, but chooses long or double.\\n	// Converts weird types (like BigInteger) to double.\\n	return n -> (longable(sum[0]) && longable(n)) ?\\n	    (sum[0] = sum[0].longValue() + n.longValue()) :\\n	    (sum[0] = sum[0].doubleValue() + n.doubleValue());\\n    }\\n\\n    private static boolean longable(Number n) {\\n	return n instanceof Byte || n instanceof Short ||\\n	    n instanceof Integer || n instanceof Long;\\n    }\\n\\n    public static void main(String[] args) {\\n	UnaryOperator<Number> x = accumulator(1);\\n	x.apply(5);\\n	accumulator(3);\\n	System.out.println(x.apply(2.3));\\n    }\\n}"
"Java","Ackermann_function","The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.\\n\\nThe Ackermann function is usually defined as follows:\\n\\n","import java.math.BigInteger;\\n\\npublic static BigInteger ack(BigInteger m, BigInteger n) {\\n    return m.equals(BigInteger.ZERO)\\n            ? n.add(BigInteger.ONE)\\n            : ack(m.subtract(BigInteger.ONE),\\n                        n.equals(BigInteger.ZERO) ? BigInteger.ONE : ack(m, n.subtract(BigInteger.ONE)));\\n}"
"Java","Ackermann_function","The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.\\n\\nThe Ackermann function is usually defined as follows:\\n\\n","@FunctionalInterface\\npublic interface FunctionalField> {\\n  public Object untypedField(FIELD field);\\n\\n  @SuppressWarnings(\""unchecked\"")\\n  public default <VALUE> VALUE field(FIELD field) {\\n    return (VALUE) untypedField(field);\\n  }\\n}"
"Java","Ackermann_function","The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.\\n\\nThe Ackermann function is usually defined as follows:\\n\\n","import java.util.function.BiFunction;\\nimport java.util.function.Function;\\nimport java.util.function.Predicate;\\nimport java.util.function.UnaryOperator;\\nimport java.util.stream.Stream;\\n\\npublic interface TailRecursive {\\n  public static  Function new_(Function toIntermediary, UnaryOperator<INTERMEDIARY> unaryOperator, Predicate<INTERMEDIARY> predicate, Function toOutput) {\\n    return input ->\\n      $.new_(\\n        Stream.iterate(\\n          toIntermediary.apply(input),\\n          unaryOperator\\n        ),\\n        predicate,\\n        toOutput\\n      )\\n    ;\\n  }\\n\\n  public static  BiFunction new_(BiFunction toIntermediary, UnaryOperator<INTERMEDIARY> unaryOperator, Predicate<INTERMEDIARY> predicate, Function toOutput) {\\n    return (input1, input2) ->\\n      $.new_(\\n        Stream.iterate(\\n          toIntermediary.apply(input1, input2),\\n          unaryOperator\\n        ),\\n        predicate,\\n        toOutput\\n      )\\n    ;\\n  }\\n\\n  public enum $ {\\n    $$;\\n\\n    private static  OUTPUT new_(Stream<INTERMEDIARY> stream, Predicate<INTERMEDIARY> predicate, Function function) {\\n      return stream\\n        .filter(predicate)\\n        .map(function)\\n        .findAny()\\n        .orElseThrow(RuntimeException::new)\\n      ;\\n    }\\n  }\\n}"
"Java","Ackermann_function","The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.\\n\\nThe Ackermann function is usually defined as follows:\\n\\n","import java.math.BigInteger;\\nimport java.util.Stack;\\nimport java.util.function.BinaryOperator;\\nimport java.util.stream.Collectors;\\nimport java.util.stream.Stream;\\n\\npublic interface Ackermann {\\n  public static Ackermann new_(BigInteger number1, BigInteger number2, Stack<BigInteger> stack, boolean flag) {\\n    return $.new_(number1, number2, stack, flag);\\n  }\\n  public static void main(String... arguments) {\\n    $.main(arguments);\\n  }\\n  public BigInteger number1();\\n  public BigInteger number2();\\n\\n  public Stack<BigInteger> stack();\\n\\n  public boolean flag();\\n\\n  public enum $ {\\n    $$;\\n\\n    private static final BigInteger ZERO = BigInteger.ZERO;\\n    private static final BigInteger ONE = BigInteger.ONE;\\n    private static final BigInteger TWO = BigInteger.valueOf(2);\\n    private static final BigInteger THREE = BigInteger.valueOf(3);\\n    private static final BigInteger FOUR = BigInteger.valueOf(4);\\n\\n    private static Ackermann new_(BigInteger number1, BigInteger number2, Stack<BigInteger> stack, boolean flag) {\\n      return (FunctionalAckermann) field -> {\\n        switch (field) {\\n          case number1: return number1;\\n          case number2: return number2;\\n          case stack: return stack;\\n          case flag: return flag;\\n          default: throw new UnsupportedOperationException(\\n            field instanceof Field\\n              ? \""Field checker has not been updated properly.\""\\n              : \""Field is not of the correct type.\""\\n          );\\n        }\\n      };\\n    }\\n\\n    private static final BinaryOperator<BigInteger> ACKERMANN = \\n      TailRecursive.new_(\\n        (BigInteger number1, BigInteger number2) ->\\n          new_(\\n            number1,\\n            number2,\\n            Stream.of(number1).collect(\\n              Collectors.toCollection(Stack::new)\\n            ),\\n            false\\n          )\\n        ,\\n        ackermann -> {\\n          BigInteger number1 = ackermann.number1();\\n          BigInteger number2 = ackermann.number2();\\n          Stack<BigInteger> stack = ackermann.stack();\\n          if (!stack.empty() && !ackermann.flag()) {\\n            number1 = stack.pop();\\n          }\\n          switch (number1.intValue()) {\\n            case 0:\\n              return new_(\\n                number1,\\n                number2.add(ONE),\\n                stack,\\n                false\\n              );\\n            case 1:\\n              return new_(\\n                number1,\\n                number2.add(TWO),\\n                stack,\\n                false\\n              );\\n            case 2:\\n              return new_(\\n                number1,\\n                number2.multiply(TWO).add(THREE),\\n                stack,\\n                false\\n              );\\n            default:\\n              if (ZERO.equals(number2)) {\\n                return new_(\\n                  number1.subtract(ONE),\\n                  ONE,\\n                  stack,\\n                  true\\n                );\\n              } else {\\n                stack.push(number1.subtract(ONE));\\n                return new_(\\n                  number1,\\n                  number2.subtract(ONE),\\n                  stack,\\n                  true\\n                );\\n              }\\n          }\\n        },\\n        ackermann -> ackermann.stack().empty(),\\n        Ackermann::number2\\n      )::apply\\n    ;\\n\\n    private static void main(String... arguments) {\\n      System.out.println(ACKERMANN.apply(FOUR, TWO));\\n    }\\n\\n    private enum Field {\\n      number1,\\n      number2,\\n      stack,\\n      flag\\n    }\\n\\n    @FunctionalInterface\\n    private interface FunctionalAckermann extends FunctionalField<Field>, Ackermann {\\n      @Override\\n      public default BigInteger number1() {\\n        return field(Field.number1);\\n      }\\n\\n      @Override\\n      public default BigInteger number2() {\\n        return field(Field.number2);\\n      }\\n\\n      @Override\\n      public default Stack<BigInteger> stack() {\\n        return field(Field.stack);\\n      }\\n\\n      @Override\\n      public default boolean flag() {\\n        return field(Field.flag);\\n      }\\n    }\\n  }\\n}"
"Java","Active_Directory/Connect","The task is to establish a connection to an Active Directory or Lightweight Directory Access Protocol server.\\nWith OpenLDAP:\\n\\n\\nBased on dopenldap.\\nThis needs a test case. Is there a LDAP server available?\\nFor Active Directory we use the library System.DirectoryServicesFor your average LDAP server we use System.DirectoryServices.ProtocolFor a minimal example we make an anonymous connect to the local machine on the well-known LDAP port 389\\nlet ldapServer = new System.DirectoryServices.Protocols.LdapDirectoryIdentifier(\""127.0.0.1\"")let connect = new System.DirectoryServices.Protocols.LdapConnection(ldapServer)connect.Bind()\\nGo[edit]\\nLibrary: go-ldap-client\\n\\nThere are a large number of third-party LDAP libraries for Go. This uses one of the simpler ones and the code below is largely taken from the example on its main page.\\n\\npackage main import (    \""log\""    \""github.com/jtblin/go-ldap-client\"") func main() {    client := &ldap.LDAPClient{        Base:         \""dc=example,dc=com\"",        Host:         \""ldap.example.com\"",        Port:         389,        UseSSL:       false,        BindDN:       \""uid=readonlyuser,ou=People,dc=example,dc=com\"",        BindPassword: \""readonlypassword\"",        UserFilter:   \""(uid=%s)\"",        GroupFilter:  \""(memberUid=%s)\"",        Attributes:   []string{\""givenName\"", \""sn\"", \""mail\"", \""uid\""},    }    defer client.Close()    err := client.Connect()    if err != nil {         log.Fatalf(\""Failed to connect : %+v\"", err)    }    // Do something}\\nHaskell[edit]\\nExample uses the ldap-client package:\\n\\n{-# LANGUAGE OverloadedStrings #-} module Main (main) where import           Data.Foldable (for_)import qualified Data.Text.Encoding as Text (encodeUtf8)import           Ldap.Client (Attr(..), Filter(..))import qualified Ldap.Client as Ldap (Dn(..), Host(..), search, with, typesOnly) main :: IO ()main = do    entries <- Ldap.with (Ldap.Plain \""localhost\"") 389 $ \\ldap ->        Ldap.search ldap (Ldap.Dn \""o=example.com\"") (Ldap.typesOnly True) (Attr \""uid\"" := Text.encodeUtf8 \""user\"") []    for_ entries $ \\entry ->        print entry\\nJava[edit]\\nThis code uses the Apache Directory third-party library.\\n\\nimport java.io.IOException;import org.apache.directory.api.ldap.model.exception.LdapException;import org.apache.directory.ldap.client.api.LdapConnection;import org.apache.directory.ldap.client.api.LdapNetworkConnection; public class LdapConnectionDemo {     public static void main(String[] args) throws LdapException, IOException {        try (LdapConnection connection = new LdapNetworkConnection(\""localhost\"", 10389)) {            connection.bind();            connection.unBind();        }    }}\\nKotlin[edit]\\n import org.apache.directory.api.ldap.model.exception.LdapExceptionimport org.apache.directory.ldap.client.api.LdapNetworkConnectionimport java.io.IOExceptionimport java.util.logging.Levelimport java.util.logging.Logger class LDAP(map: Map<String, String>) {    fun run() {        var connection: LdapNetworkConnection? = null        try {            if (info) log.info(\""LDAP Connection to $hostname on port $port\"")            connection = LdapNetworkConnection(hostname, port.toInt())             try {                if (info) log.info(\""LDAP bind\"")                connection.bind()            } catch (e: LdapException) {                log.severe(e.toString())            }             try {                if (info) log.info(\""LDAP unbind\"")                connection.unBind()            } catch (e: LdapException) {                log.severe(e.toString())            }        } finally {            try {                if (info) log.info(\""LDAP close connection\"")                connection!!.close()            } catch (e: IOException) {                log.severe(e.toString())            }        }    }     private val log = Logger.getLogger(LDAP::class.java.name)    private val info = log.isLoggable(Level.INFO)    private val hostname: String by map    private val port: String by map} fun main(args: Array<String>) = LDAP(mapOf(\""hostname\"" to \""localhost\"", \""port\""  to \""10389\"")).run() \\nNetRexx[edit]\\nUses the Apache LDAP API, connecting to a local ApacheDS LDAP directory server.\\n\\n/* NetRexx */options replace format comments java crossref symbols binary import org.apache.directory.ldap.client.api.LdapConnectionimport org.apache.directory.ldap.client.api.LdapNetworkConnectionimport org.apache.directory.shared.ldap.model.exception.LdapExceptionimport org.slf4j.Loggerimport org.slf4j.LoggerFactory class RDirectoryLDAP public   properties constant    log_ = LoggerFactory.getLogger(RDirectoryLDAP.class)   properties private static    connection = LdapConnection null   method main(args = String[]) public static    ldapHostName = String \""localhost\""    ldapPort = int 10389     if log_.isInfoEnabled() then log_.info(\""LDAP Connection to\"" ldapHostName \""on port\"" ldapPort)    connection = LdapNetworkConnection(ldapHostName, ldapPort)     do      if log_.isTraceEnabled() then log_.trace(\""LDAP bind\"")      connection.bind()       if log_.isTraceEnabled() then log_.trace(\""LDAP unbind\"")      connection.unBind()    catch lex = LdapException      log_.error(\""LDAP Error\"", Throwable lex)    catch iox = IOException      log_.error(\""I/O Error\"", Throwable iox)    finally      do      if connection \\= null then connection.close()      catch iox = IOException        log_.error(\""I/O Error on connection.close()\"", Throwable iox)      end    end     return \\nSample log4j.xml configuration file:\\n\\n<?xml version=\""1.0\"" encoding=\""UTF-8\"" ?><!DOCTYPE log4j:configuration SYSTEM \""log4j.dtd\""><log4j:configuration xmlns:log4j='http://jakarta.apache.org/log4j/'>  <appender name=\""stdout\"" class=\""org.apache.log4j.ConsoleAppender\"">    <param name=\""Target\"" value=\""System.out\"" />    <layout class=\""org.apache.log4j.PatternLayout\"">      <param name=\""ConversionPattern\"" value=\""[%d{HH:mm:ss}] %-5p [%c] - %m%n\"" />    </layout>  </appender>   <!-- with these we'll not get innundated when switching to DEBUG -->  <logger name=\""org.apache.directory.shared.ldap.name\"">    <level value=\""warn\"" />  </logger>  <logger name=\""org.apache.directory.shared.codec\"">    <level value=\""warn\"" />  </logger>  <logger name=\""org.apache.directory.shared.asn1\"">    <level value=\""warn\"" />  </logger>   <root>    <level value=\""info\"" />    <appender-ref ref=\""stdout\"" />  </root></log4j:configuration> \\nOutput:\\n\\n[08:40:05] INFO  [RDirectoryLDAP] - LDAP Connection to localhost on port 10389\\n\\nPerl[edit]\\nLDAP Modules\\n\\n use Net::LDAP; my $ldap = Net::LDAP->new('ldap://ldap.example.com') or die [email protected];my $mesg = $ldap->bind( $bind_dn, password => $bind_pass ); \\nPHP[edit]\\nPHP LDAP Reference\\n\\n<?php$ldap = ldap_connect($hostname, $port);$success = ldap_bind($ldap, $username, $password);\\nPicoLisp[edit]\\n(unless (=0 (setq Ldap (native \""libldap.so\"" \""ldap_open\"" 'N \""example.com\"" 389)))   (quit \""Can't open LDAP\"") ) (native \""libldap.so\"" \""ldap_simple_bind_s\"" 'I Ldap \""user\"" \""password\"")\\nPython[edit]\\nWorks with: Python version 2.6\\nLibrary: python-ldap\\npython-ldap Documentation\\n\\nimport ldap l = ldap.initialize(\""ldap://ldap.example.com\"")try:    l.protocol_version = ldap.VERSION3    l.set_option(ldap.OPT_REFERRALS, 0)     bind = l.simple_bind_s(\""[email protected]\"", \""password\"")finally:    l.unbind() \\nRacket[edit]\\nThis version uses the ldap package, and was tested against OpenLDAP (with real values):\\n\\n#lang racket(require net/ldap)(ldap-authenticate \""ldap.somewhere.com\"" 389 \""uid=username,ou=people,dc=somewhere,dc=com\"" password)\\nTranslation of: C\\nThis is a direct translation of the C code -- I have no idea how to try it out since I don't have a working ldap server... So take it as a stub that waits for someone who can try it to do so. (And it's a low level thing anyway, there's an ldap package for Racket which I can't try for a similar reason.)\\n\\n#lang racket (require ffi/unsafe ffi/unsafe/define) (define-ffi-definer defldap (ffi-lib \""libldap\""))(defldap ldap_init (_fun _string _int -> _pointer))(defldap ldap_unbind (_fun _pointer -> _void))(defldap ldap_simple_bind_s (_fun _pointer _string _string -> _int))(defldap ldap_err2string (_fun _int -> _string)) (define name ...)(define password ...)(define ld (ldap_init \""ldap.somewhere.com\"" 389))(ldap_simple_bind_s ld name password) (ldap_unbind ld)\\nRing[edit]\\n see system(\""dir\"") + nl \\nRuby[edit]\\nSimilar to Tcl, assume the AD server talks LDAP.\\nThere are many Ruby LDAP packages ([1]) -- this solution uses Net::LDAP (\""Pure Ruby LDAP Tools\"" on RubyForge, gem name \""ruby-net-ldap\"")\\n\\nLibrary: RubyGems\\nrequire 'rubygems'require 'net/ldap'ldap = Net::LDAP.new(:host => 'ldap.example.com', :base => 'o=companyname')ldap.authenticate('bind_dn', 'bind_pass')\\nRun BASIC[edit]\\nprint shell$(\""dir\"") ' shell out to the os and print it\\nScala[edit]\\nimport java.io.IOException import org.apache.directory.api.ldap.model.exception.LdapExceptionimport org.apache.directory.ldap.client.api.{LdapConnection, LdapNetworkConnection} object LdapConnectionDemo {  @throws[LdapException]  @throws[IOException]  def main(args: Array[String]): Unit = {    try {      val connection: LdapConnection = new LdapNetworkConnection(\""localhost\"", 10389)      try {        connection.bind()        connection.unBind()      } finally if (connection != null) connection.close()    }  }}\\nsmart BASIC[edit]\\nsmart BASIC uses three separate commands to list the current directory, folder and files respectively.\\n\\nPRINT \""Current directory: \"";CURRENT_DIR$()PRINTPRINT \""Folders:\""PRINTDIR \""/\"" LIST DIRS a$,cFOR n = 0 TO c-1PRINT ,a$(n)NEXT nPRINTPRINT \""Files:\""PRINTDIR \""/\"" LIST FILES a$,cFOR n = 0 TO c-1PRINT ,a$(n)NEXT n\\nTcl[edit]\\nThis does not use SSPI/Kerberos yet, so your AD would need to allow simple ldap access.\\n\\npackage require ldapset conn [ldap::connect $host $port]ldap::bind $conn $user $password\\nVBScript[edit]\\nCreating the normal connection to AD\\n\\nSet objConn = CreateObject(\""ADODB.Connection\"")Set objCmd = CreateObject(\""ADODB.Command\"")objConn.Provider = \""ADsDSOObject\""objConn.Open\\nThere are a large number of third-party LDAP libraries for Go. This uses one of the simpler ones and the code below is largely taken from the example on its main page.\\nExample uses the ldap-client package:\\nThis code uses the Apache Directory third-party library.\\nUses the Apache LDAP API, connecting to a local ApacheDS LDAP directory server.\\nSample log4j.xml configuration file:\\nOutput:\\nLDAP Modules\\nPHP LDAP Reference\\npython-ldap Documentation\\nThis version uses the ldap package, and was tested against OpenLDAP (with real values):\\nThis is a direct translation of the C code -- I have no idea how to try it out since I don't have a working ldap server... So take it as a stub that waits for someone who can try it to do so. (And it's a low level thing anyway, there's an ldap package for Racket which I can't try for a similar reason.)\\nSimilar to Tcl, assume the AD server talks LDAP.\\nThere are many Ruby LDAP packages ([1]) -- this solution uses Net::LDAP (\""Pure Ruby LDAP Tools\"" on RubyForge, gem name \""ruby-net-ldap\"")\\nsmart BASIC uses three separate commands to list the current directory, folder and files respectively.\\nThis does not use SSPI/Kerberos yet, so your AD would need to allow simple ldap access.\\nCreating the normal connection to AD\\n","import java.io.IOException;\\nimport org.apache.directory.api.ldap.model.exception.LdapException;\\nimport org.apache.directory.ldap.client.api.LdapConnection;\\nimport org.apache.directory.ldap.client.api.LdapNetworkConnection;\\n\\npublic class LdapConnectionDemo {\\n\\n    public static void main(String[] args) throws LdapException, IOException {\\n        try (LdapConnection connection = new LdapNetworkConnection(\""localhost\"", 10389)) {\\n            connection.bind();\\n            connection.unBind();\\n        }\\n    }\\n}"
"Java","Active_Directory/Search_for_a_user","Make sure you Connect to Active Directory\\n\\nBased on dopenldap.\\nEiffel does not have the notion of \""return\"", but \""Result\"". A consequence of this is that Eiffel routines are Single-entry-Single-exit, which means less bugs. In the example (below), the Result is of type BOOLEAN.\\nMoreover, strings in Eiffel are objects and cannot be directly passed to the Windows OS. As such, they need to undergo a format change through the facilities of a WEL_STRING, which makes the appropriate structure conversion.\\nBecause Active Directory is a Windows OS facility, in Eiffel we must use the WEL (Windows Eiffel Library) components. Thus, the code above is not cross-platform. Moreover, the call to `cwel_is_credential_valid' is shown below:\\n\\nThere are a large number of third-party LDAP libraries for Go. This uses one of the simpler ones and the code below is largely taken from the example on its main page.\\nExample uses the ldap-client package:\\nThe following code uses the Apache Directory project, version 1.0.0.\\nUsing LDAP connecting to a local ApacheDS LDAP directory server.\\nThis program drives the ldapsearch command and captures the output into an external data queue via ooRexx rxqueue facility. The contents of the queue are then read into program variables for further processing.\\nOutput:\\nTest:\\nUses the Apache LDAP API, connecting to a local ApacheDS LDAP directory server.\\nOutput:\\npython-ldap Documentation\\nUsing LDAP connecting to a local ApacheDS LDAP directory server.\\nA little contrived; this REXX program drives the ldapsearch command.\\nOutput:\\nAssume AD server talks LDAP.\\nOne can do it with the low level Connect to Active Directory based handle with this code:\\nThis is just the basic setup.\\nNow do the actual search.\\nIf we have only a single result its easy:\\nLooping over the result set to output some values.\\nIf you're bored you can also use this instead:\\nUsing LDAP connecting to a local ApacheDS LDAP directory server.\\nA shell script to drive the ldapsearch command.\\nOutput:\\nThe search string and execution of the string\\nDoing something with a single result (this will output the returned users full DN)\\nDoing something with multiple results (this will output each returned users full DN)\\n","import java.io.IOException;\\nimport org.apache.directory.api.ldap.model.cursor.CursorException;\\nimport org.apache.directory.api.ldap.model.cursor.EntryCursor;\\nimport org.apache.directory.api.ldap.model.entry.Entry;\\nimport org.apache.directory.api.ldap.model.exception.LdapException;\\nimport org.apache.directory.api.ldap.model.message.SearchScope;\\nimport org.apache.directory.ldap.client.api.LdapConnection;\\nimport org.apache.directory.ldap.client.api.LdapNetworkConnection;\\n\\npublic class LdapSearchDemo {\\n\\n    public static void main(String[] args) throws IOException, LdapException, CursorException {\\n        new LdapSearchDemo().demonstrateSearch();\\n    }\\n\\n    private void demonstrateSearch() throws IOException, LdapException, CursorException {\\n        try (LdapConnection conn = new LdapNetworkConnection(\""localhost\"", 11389)) {\\n            conn.bind(\""uid=admin,ou=system\"", \""********\"");\\n            search(conn, \""*mil*\"");\\n            conn.unBind();\\n        }\\n    }\\n\\n    private void search(LdapConnection connection, String uid) throws LdapException, CursorException {\\n        String baseDn = \""ou=users,o=mojo\"";\\n        String filter = \""(&(objectClass=person)(&(uid=\"" + uid + \"")))\"";\\n        SearchScope scope = SearchScope.SUBTREE;\\n        String[] attributes = {\""dn\"", \""cn\"", \""sn\"", \""uid\""};\\n        int ksearch = 0;\\n\\n        EntryCursor cursor = connection.search(baseDn, filter, scope, attributes);\\n        while (cursor.next()) {\\n            ksearch++;\\n            Entry entry = cursor.get();\\n            System.out.printf(\""Search entry %d = %s%n\"", ksearch, entry);\\n        }\\n    }\\n}"
"Java","Active_object","In object-oriented programming an object is active when its state depends on clock. Usually an active object encapsulates a task that updates the object's state. To the outer world the object looks like a normal object with methods that can be called from outside. Implementation of such methods must have a certain synchronization mechanism with the encapsulated task in order to prevent object's state corruption.\\nA typical instance of an active object is an animation widget. The widget state changes with the time, while as an object it has all properties of a normal widget.\\nThe task\\nImplement an active integrator object. The object has an input and output. The input can be set using the method Input. The input is a function of time. The output can be queried using the method Output. The object integrates its input over the time and the result becomes the object's output. So if the input is K(t) and the output is S, the object state S is changed to S + (K(t1) + K(t0)) * (t1 - t0) / 2, i.e. it integrates K using the trapeze method. Initially K is constant 0 and S is 0.\\nIn order to test the object:\\nVerify that now the object's output is approximately 0 (the sine has the period of 2s). The accuracy of the result will depend on the OS scheduler time slicing and the accuracy of the clock.\\nSample output:\\nOutput:\\nUses POSIX threads.\\noutput\\nOutput:\\noutput\\n","/**\\n * Integrates input function K over time\\n * S + (t1 - t0) * (K(t1) + K(t0)) / 2\\n */\\npublic class Integrator {\\n\\n    public interface Function {\\n        double apply(double timeSinceStartInSeconds);\\n    }\\n\\n    private final long start;\\n    private volatile boolean running;\\n\\n    private Function func;\\n    private double t0;\\n    private double v0;\\n    private double sum;\\n\\n    public Integrator(Function func) {\\n        this.start = System.nanoTime();\\n        setFunc(func);\\n        new Thread(this::integrate).start();\\n    }\\n\\n    public void setFunc(Function func) {\\n        this.func = func;\\n        v0 = func.apply(0.0);\\n        t0 = 0;\\n    }\\n\\n    public double getOutput() {\\n        return sum;\\n    }\\n\\n    public void stop() {\\n        running = false;\\n    }\\n\\n    private void integrate() {\\n        running = true;\\n        while (running) {\\n            try {\\n                Thread.sleep(1);\\n                update();\\n            } catch (InterruptedException e) {\\n                return;\\n            }\\n        }\\n    }\\n\\n    private void update() {\\n        double t1 = (System.nanoTime() - start) / 1.0e9;\\n        double v1 = func.apply(t1);\\n        double rect = (t1 - t0) * (v0 + v1) / 2;\\n        this.sum += rect;\\n        t0 = t1;\\n        v0 = v1;\\n    }\\n\\n    public static void main(String[] args) throws InterruptedException {\\n        Integrator integrator = new Integrator(t -> Math.sin(Math.PI * t));\\n        Thread.sleep(2000);\\n\\n        integrator.setFunc(t -> 0.0);\\n        Thread.sleep(500);\\n\\n        integrator.stop();\\n        System.out.println(integrator.getOutput());\\n    }\\n}\\n"
"Java","Addition_chains","An addition chain of length r for n is a sequence 1 = a(0) < a(1) < a(2) ... < a(r) = n , such as a(k) = a(i) + a(j) ( i < k and j < k , i may be = j) . Each member is the sum of two earlier members, not necessarily distincts.\\nA Brauer chain for n is an addition chain where a(k) = a(k-1) + a(j) with j < k. Each member uses the previous member as a summand.\\nWe are interested in chains of minimal length L(n).\\nTask\\nFor each n in {7,14,21,29,32,42,64} display the following : L(n), the count of Brauer chains of length L(n), an example of such a Brauer chain, the count of non-brauer chains of length L(n), an example of such a chain. (NB: counts may be 0 ).\\nExtra-credit: Same task for n in {47, 79, 191, 382 , 379, 12509}\\nReferences\\nExample\\n","public class AdditionChains {\\n    private static class Pair {\\n        int f, s;\\n\\n        Pair(int f, int s) {\\n            this.f = f;\\n            this.s = s;\\n        }\\n    }\\n\\n    private static int[] prepend(int n, int[] seq) {\\n        int[] result = new int[seq.length + 1];\\n        result[0] = n;\\n        System.arraycopy(seq, 0, result, 1, seq.length);\\n        return result;\\n    }\\n\\n    private static Pair check_seq(int pos, int[] seq, int n, int min_len) {\\n        if (pos > min_len || seq[0] > n) return new Pair(min_len, 0);\\n        else if (seq[0] == n) return new Pair(pos, 1);\\n        else if (pos < min_len) return try_perm(0, pos, seq, n, min_len);\\n        else return new Pair(min_len, 0);\\n    }\\n\\n    private static Pair try_perm(int i, int pos, int[] seq, int n, int min_len) {\\n        if (i > pos) return new Pair(min_len, 0);\\n\\n        Pair res1 = check_seq(pos + 1, prepend(seq[0] + seq[i], seq), n, min_len);\\n        Pair res2 = try_perm(i + 1, pos, seq, n, res1.f);\\n\\n        if (res2.f < res1.f) return res2;\\n        else if (res2.f == res1.f) return new Pair(res2.f, res1.s + res2.s);\\n        else throw new RuntimeException(\""Try_perm exception\"");\\n    }\\n\\n    private static Pair init_try_perm(int x) {\\n        return try_perm(0, 0, new int[]{1}, x, 12);\\n    }\\n\\n    private static void find_brauer(int num) {\\n        Pair res = init_try_perm(num);\\n        System.out.println();\\n        System.out.println(\""N = \"" + num);\\n        System.out.println(\""Minimum length of chains: L(n)= \"" + res.f);\\n        System.out.println(\""Number of minimum length Brauer chains: \"" + res.s);\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] nums = new int[]{7, 14, 21, 29, 32, 42, 64, 47, 79, 191, 382, 379};\\n        for (int i : nums) {\\n            find_brauer(i);\\n        }\\n    }\\n}"
"Java","AKS_test_for_primes","The AKS algorithm for testing whether a number is prime is a polynomial-time algorithm based on an elementary theorem about Pascal triangles.\\nThe theorem on which the test is based can be stated as follows:\\nare divisible by   \\n\\n\\n\\np\\n\\n\\n{\\displaystyle p}\\n\\n.\\n\\nUsing   \\n\\n\\n\\np\\n=\\n3\\n\\n\\n{\\displaystyle p=3}\\n\\n:\\n\\nAnd all the coefficients are divisible by 3,   so 3 is prime.\\n\\n\\n\\n\\n\\n","public class AksTest {\\n    private static final long[] c = new long[64];\\n\\n    public static void main(String[] args) {\\n        for (int n = 0; n < 10; n++) {\\n            coeff(n);\\n            show(n);\\n        }\\n\\n        System.out.print(\""Primes:\"");\\n        for (int n = 1; n < c.length; n++)\\n            if (isPrime(n))\\n                System.out.printf(\"" %d\"", n);\\n\\n        System.out.println();\\n    }\\n\\n    static void coeff(int n) {\\n        c[0] = 1;\\n        for (int i = 0; i < n; c[0] = -c[0], i++) {\\n            c[1 + i] = 1;\\n            for (int j = i; j > 0; j--)\\n                c[j] = c[j - 1] - c[j];\\n        }\\n    }\\n\\n    static boolean isPrime(int n) {\\n        coeff(n);\\n        c[0]++;\\n        c[n]--;\\n\\n        int i = n;\\n        while (i-- != 0 && c[i] % n == 0)\\n            continue;\\n        return i < 0;\\n    }\\n\\n    static void show(int n) {\\n        System.out.print(\""(x-1)^\"" + n + \"" =\"");\\n        for (int i = n; i >= 0; i--) {\\n            System.out.print(\"" + \"" + c[i] + \""x^\"" + i);\\n        }\\n        System.out.println();\\n    }\\n}"
"Java","Align_columns","Given a text file of many lines, where fields within a line\\nare delineated by a single 'dollar' character, write a program\\nthat aligns each column of fields by ensuring that words in each\\ncolumn are separated by at least one space.\\nFurther, allow for each word in a column to be either left\\njustified, right justified, or center justified within its column.\\nUse the following text to test your programs:\\nNote that:\\n\\n","import java.io.IOException;\\nimport java.nio.charset.StandardCharsets;\\nimport java.nio.file.Files;\\nimport java.nio.file.Paths;\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nimport org.apache.commons.lang3.StringUtils;\\n\\n/**\\n * Aligns fields into columns, separated by \""|\""\\n */\\npublic class ColumnAligner {\\n    private List words = new ArrayList<>();\\n    private int columns = 0;\\n    private List<Integer> columnWidths = new ArrayList<>();\\n\\n    /**\\n     * Initialize columns aligner from lines in a single string\\n     * \\n     * @param s\\n     *            lines in a single string. Empty string does form a column.\\n     */\\n    public ColumnAligner(String s) {\\n        String[] lines = s.split(\""\\\\n\"");\\n        for (String line : lines) {\\n            processInputLine(line);\\n        }\\n    }\\n\\n    /**\\n     * Initialize columns aligner from lines in a list of strings\\n     * \\n     * @param lines\\n     *            lines in a single string. Empty string does form a column.\\n     */\\n    public ColumnAligner(List<String> lines) {\\n        for (String line : lines) {\\n            processInputLine(line);\\n        }\\n    }\\n\\n    private void processInputLine(String line) {\\n        String[] lineWords = line.split(\""\\\\$\"");\\n        words.add(lineWords);\\n        columns = Math.max(columns, lineWords.length);\\n        for (int i = 0; i < lineWords.length; i++) {\\n            String word = lineWords[i];\\n            if (i >= columnWidths.size()) {\\n                columnWidths.add(word.length());\\n            } else {\\n                columnWidths.set(i, Math.max(columnWidths.get(i), word.length()));\\n            }\\n        }\\n    }\\n\\n    interface AlignFunction {\\n        String align(String s, int length);\\n    }\\n\\n    /**\\n     * Left-align all columns\\n     * \\n     * @return Lines, terminated by \""\\n\"" of columns, separated by \""|\""\\n     */\\n    public String alignLeft() {\\n        return align(new AlignFunction() {\\n            @Override\\n            public String align(String s, int length) {\\n                return StringUtils.rightPad(s, length);\\n            }\\n        });\\n    }\\n\\n    /**\\n     * Right-align all columns\\n     * \\n     * @return Lines, terminated by \""\\n\"" of columns, separated by \""|\""\\n     */\\n    public String alignRight() {\\n        return align(new AlignFunction() {\\n            @Override\\n            public String align(String s, int length) {\\n                return StringUtils.leftPad(s, length);\\n            }\\n        });\\n    }\\n\\n    /**\\n     * Center-align all columns\\n     * \\n     * @return Lines, terminated by \""\\n\"" of columns, separated by \""|\""\\n     */\\n    public String alignCenter() {\\n        return align(new AlignFunction() {\\n            @Override\\n            public String align(String s, int length) {\\n                return StringUtils.center(s, length);\\n            }\\n        });\\n    }\\n\\n    private String align(AlignFunction a) {\\n        StringBuilder result = new StringBuilder();\\n        for (String[] lineWords : words) {\\n            for (int i = 0; i < lineWords.length; i++) {\\n                String word = lineWords[i];\\n                if (i == 0) {\\n                    result.append(\""|\"");\\n                }\\n                result.append(a.align(word, columnWidths.get(i)) + \""|\"");\\n            }\\n            result.append(\""\\n\"");\\n        }\\n        return result.toString();\\n    }\\n\\n    public static void main(String args[]) throws IOException {\\n        if (args.length < 1) {\\n            System.out.println(\""Usage: ColumnAligner file [left|right|center]\"");\\n            return;\\n        }\\n        String filePath = args[0];\\n        String alignment = \""left\"";\\n        if (args.length >= 2) {\\n            alignment = args[1];\\n        }\\n        ColumnAligner ca = new ColumnAligner(Files.readAllLines(Paths.get(filePath), StandardCharsets.UTF_8));\\n        switch (alignment) {\\n        case \""left\"":\\n            System.out.print(ca.alignLeft());\\n            break;\\n        case \""right\"":\\n            System.out.print(ca.alignRight());\\n            break;\\n        case \""center\"":\\n            System.out.print(ca.alignCenter());\\n            break;\\n        default:\\n            System.err.println(String.format(\""Error! Unknown alignment: '%s'\"", alignment));\\n            break;\\n        }\\n    }\\n}"
"Java","Aliquot_sequence_classifications","An aliquot sequence of a positive integer K is defined recursively as the first member\\nbeing K and subsequent members being the sum of the Proper divisors of the previous term.\\n\\nShow all output on this page.\\n\\n\\nAssumes LONG INT is at least 64 bits, as in Algol 68G.\\n","import java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.stream.LongStream;\\n\\npublic class AliquotSequenceClassifications {\\n\\n    private static Long properDivsSum(long n) {\\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0 && n != i).sum();\\n    }\\n\\n    static boolean aliquot(long n, int maxLen, long maxTerm) {\\n        List<Long> s = new ArrayList<>(maxLen);\\n        s.add(n);\\n        long newN = n;\\n\\n        while (s.size() <= maxLen && newN < maxTerm) {\\n\\n            newN = properDivsSum(s.get(s.size() - 1));\\n\\n            if (s.contains(newN)) {\\n\\n                if (s.get(0) == newN) {\\n\\n                    switch (s.size()) {\\n                        case 1:\\n                            return report(\""Perfect\"", s);\\n                        case 2:\\n                            return report(\""Amicable\"", s);\\n                        default:\\n                            return report(\""Sociable of length \"" + s.size(), s);\\n                    }\\n\\n                } else if (s.get(s.size() - 1) == newN) {\\n                    return report(\""Aspiring\"", s);\\n\\n                } else\\n                    return report(\""Cyclic back to \"" + newN, s);\\n\\n            } else {\\n                s.add(newN);\\n                if (newN == 0)\\n                    return report(\""Terminating\"", s);\\n            }\\n        }\\n\\n        return report(\""Non-terminating\"", s);\\n    }\\n\\n    static boolean report(String msg, List<Long> result) {\\n        System.out.println(msg + \"": \"" + result);\\n        return false;\\n    }\\n\\n    public static void main(String[] args) {\\n        long[] arr = {\\n                11, 12, 28, 496, 220, 1184, 12496, 1264460,\\n                790, 909, 562, 1064, 1488};\\n\\n        LongStream.rangeClosed(1, 10).forEach(n -> aliquot(n, 16, 1L << 47));\\n        System.out.println();\\n        Arrays.stream(arr).forEach(n -> aliquot(n, 16, 1L << 47));\\n    }\\n}"
"Java","Almost_prime","A   k-Almost-prime   is a natural number   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n   that is the product of   \\n\\n\\n\\nk\\n\\n\\n{\\displaystyle k}\\n\\n   (possibly identical) primes.\\n\\n1-almost-primes,   where   \\n\\n\\n\\nk\\n=\\n1\\n\\n\\n{\\displaystyle k=1}\\n\\n,   are the prime numbers themselves.\\n2-almost-primes,   where   \\n\\n\\n\\nk\\n=\\n2\\n\\n\\n{\\displaystyle k=2}\\n\\n,   are the   semiprimes.\\n\\nWrite a function/method/subroutine/... that generates k-almost primes and use it to create a table here of the first ten members of k-Almost primes for   \\n\\n\\n\\n1\\n<=\\nK\\n<=\\n5\\n\\n\\n{\\displaystyle 1<=K<=5}\\n\\n.\\n\\n\\n","public class AlmostPrime {\\n    public static void main(String[] args) {\\n        for (int k = 1; k <= 5; k++) {\\n            System.out.print(\""k = \"" + k + \"":\"");\\n\\n            for (int i = 2, c = 0; c < 10; i++) {\\n                if (kprime(i, k)) {\\n                    System.out.print(\"" \"" + i);\\n                    c++;\\n                }\\n            }\\n\\n            System.out.println(\""\"");\\n        }\\n    }\\n\\n    public static boolean kprime(int n, int k) {\\n        int f = 0;\\n        for (int p = 2; f < k && p * p <= n; p++) {\\n            while (n % p == 0) {\\n                n /= p;\\n                f++;\\n            }\\n        }\\n        return f + ((n > 1) ? 1 : 0) == k;\\n    }\\n}"
"Java","Amicable_pairs","Two integers \\n\\n\\n\\nN\\n\\n\\n{\\displaystyle N}\\n\\n and \\n\\n\\n\\nM\\n\\n\\n{\\displaystyle M}\\n\\n are said to be amicable pairs if \\n\\n\\n\\nN\\n≠\\nM\\n\\n\\n{\\displaystyle N\\neq M}\\n\\n and the sum of the proper divisors of \\n\\n\\n\\nN\\n\\n\\n{\\displaystyle N}\\n\\n (\\n\\n\\n\\n\\ns\\nu\\nm\\n\\n(\\n\\np\\nr\\no\\np\\nD\\ni\\nv\\ns\\n\\n(\\nN\\n)\\n)\\n\\n\\n{\\displaystyle \\mathrm {sum} (\\mathrm {propDivs} (N))}\\n\\n) \\n\\n\\n\\n=\\nM\\n\\n\\n{\\displaystyle =M}\\n\\n as well as \\n\\n\\n\\n\\ns\\nu\\nm\\n\\n(\\n\\np\\nr\\no\\np\\nD\\ni\\nv\\ns\\n\\n(\\nM\\n)\\n)\\n=\\nN\\n\\n\\n{\\displaystyle \\mathrm {sum} (\\mathrm {propDivs} (M))=N}\\n\\n.\\n\\n1184 and 1210 are an amicable pair, with proper divisors:\\n\\nCalculate and show here the Amicable pairs below 20,000; (there are eight).\\n\\n\\n","import java.util.Map;\\nimport java.util.function.Function;\\nimport java.util.stream.Collectors;\\nimport java.util.stream.LongStream;\\n\\npublic class AmicablePairs {\\n\\n    public static void main(String[] args) {\\n        int limit = 20_000;\\n\\n        Map map = LongStream.rangeClosed(1, limit)\\n                .parallel()\\n                .boxed()\\n                .collect(Collectors.toMap(Function.identity(), AmicablePairs::properDivsSum));\\n\\n        LongStream.rangeClosed(1, limit)\\n                .forEach(n -> {\\n                    long m = map.get(n);\\n                    if (m > n && m <= limit && map.get(m) == n)\\n                        System.out.printf(\""%s %s %n\"", n, m);\\n                });\\n    }\\n\\n    public static Long properDivsSum(long n) {\\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0).sum();\\n    }\\n}"
"Java","Anagrams","When two or more words are composed of the same characters, but in a different order, they are called anagrams.\\nUsing the word list at   http://www.puzzlers.org/pub/wordlists/unixdict.txt,\\nfind the sets of words that share the same characters that contain the most words in them.\\nOrdered words\\nPalindrome detection\\nSemordnilap\\nAnagrams\\nAnagrams/Deranged anagrams\\n","import java.net.*;\\nimport java.io.*;\\nimport java.util.*;\\n \\npublic class WordsOfEqChars {\\n    public static void main(String[] args) throws IOException {\\n        URL url = new URL(\""http://www.puzzlers.org/pub/wordlists/unixdict.txt\"");\\n        InputStreamReader isr = new InputStreamReader(url.openStream());\\n        BufferedReader reader = new BufferedReader(isr);\\n\\n        Map anagrams = new HashMap();\\n        String word;\\n        int count = 0;\\n        while ((word = reader.readLine()) != null) {\\n            char[] chars = word.toCharArray();\\n            Arrays.sort(chars);\\n            String key = new String(chars);\\n            if (!anagrams.containsKey(key))\\n                anagrams.put(key, new ArrayList<String>());\\n            anagrams.get(key).add(word);\\n            count = Math.max(count, anagrams.get(key).size());\\n        }\\n\\n        reader.close();\\n\\n        for (Collection<String> ana : anagrams.values())\\n            if (ana.size() >= count)\\n                System.out.println(ana);\\n    }   \\n}"
"Java","Anagrams","When two or more words are composed of the same characters, but in a different order, they are called anagrams.\\nUsing the word list at   http://www.puzzlers.org/pub/wordlists/unixdict.txt,\\nfind the sets of words that share the same characters that contain the most words in them.\\nOrdered words\\nPalindrome detection\\nSemordnilap\\nAnagrams\\nAnagrams/Deranged anagrams\\n","import java.net.*;\\nimport java.io.*;\\nimport java.util.*;\\nimport java.util.concurrent.*;\\nimport java.util.function.*;\\n\\npublic interface Anagram {\\n  public static  Supplier<OUTPUT> tryWithResources(Callable<AUTOCLOSEABLE> callable, Function function, Supplier<OUTPUT> defaultSupplier) {\\n    return () -> {\\n      try (AUTOCLOSEABLE autoCloseable = callable.call()) {\\n        return function.apply(autoCloseable).get();\\n      } catch (Throwable throwable) {\\n        return defaultSupplier.get();\\n      }\\n    };\\n  }\\n\\n  public static  Function function(Supplier<OUTPUT> supplier) {\\n    return i -> supplier.get();\\n  }\\n\\n  public static void main(String... args) {\\n    Map anagrams = new ConcurrentSkipListMap<>();\\n    int count = tryWithResources(\\n      () -> new BufferedReader(\\n        new InputStreamReader(\\n          new URL(\\n            \""http://www.puzzlers.org/pub/wordlists/unixdict.txt\""\\n          ).openStream()\\n        )\\n      ),\\n      reader -> () -> reader.lines()\\n        .parallel()\\n        .mapToInt(word -> {\\n          char[] chars = word.toCharArray();\\n          Arrays.parallelSort(chars);\\n          String key = Arrays.toString(chars);\\n          Collection<String> collection = anagrams.computeIfAbsent(\\n            key, function(ArrayList::new)\\n          );\\n          collection.add(word);\\n          return collection.size();\\n        })\\n        .max()\\n        .orElse(0),\\n      () -> 0\\n    ).get();\\n    anagrams.values().stream()\\n      .filter(ana -> ana.size() >= count)\\n      .forEach(System.out::println)\\n    ;\\n  }\\n}"
"Java","Anagrams/Deranged_anagrams","Two or more words are said to be anagrams if they have the same characters, but in a different order.\\nBy analogy with derangements we define a deranged anagram as two words with the same characters, but in which the same character does not appear in the same position in both words.\\nUse the word list at unixdict to find and display the longest deranged anagram.\\nOrdered words\\nPalindrome detection\\nSemordnilap\\nAnagrams\\nAnagrams/Deranged anagrams\\n","import java.io.File;\\nimport java.io.IOException;\\nimport java.nio.file.Files;\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Comparator;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\n \\npublic class DerangedAnagrams {\\n \\n    public static void main(String[] args) throws IOException {\\n        List<String> words = Files.readAllLines(new File(\""unixdict.txt\"").toPath());\\n        printLongestDerangedAnagram(words);\\n    }\\n \\n    private static void printLongestDerangedAnagram(List<String> words) {\\n        words.sort(Comparator.comparingInt(String::length).reversed().thenComparing(String::toString));\\n\\n        Map map = new HashMap<>();\\n        for (String word : words) {\\n            char[] chars = word.toCharArray();\\n            Arrays.sort(chars);\\n            String key = String.valueOf(chars);\\n\\n            List<String> anagrams = map.computeIfAbsent(key, k -> new ArrayList<>());\\n            for (String anagram : anagrams) {\\n                if (isDeranged(word, anagram)) {\\n                    System.out.printf(\""%s %s%n\"", anagram, word);\\n                    return;\\n                }\\n            }\\n            anagrams.add(word);\\n        }\\n        System.out.println(\""no result\"");\\n    }\\n\\n    private static boolean isDeranged(String word1, String word2) {\\n        for (int i = 0; i < word1.length(); i++) {\\n            if (word1.charAt(i) == word2.charAt(i)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
"Java","Angle_difference_between_two_bearings","Finding the angle between two bearings is often confusing.[1]\\n\\nFind the angle which is the result of the subtraction b2 - b1, where b1 and b2 are the bearings.\\nInput bearings are expressed in the range   -180   to   +180   degrees.\\nThe result is also expressed in the range   -180   to   +180   degrees.\\n\\nCompute the angle for the following pairs:\\n\\nAllow the input bearings to be any (finite) value.\\n\\n\\n","public class AngleDifference {\\n\\n    public static double getDifference(double b1, double b2) {\\n        double r = (b2 - b1) % 360.0;\\n        if (r < -180.0)\\n            r += 360.0;\\n        if (r >= 180.0)\\n            r -= 360.0;\\n        return r;\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(\""Input in -180 to +180 range\"");\\n        System.out.println(getDifference(20.0, 45.0));\\n        System.out.println(getDifference(-45.0, 45.0));\\n        System.out.println(getDifference(-85.0, 90.0));\\n        System.out.println(getDifference(-95.0, 90.0));\\n        System.out.println(getDifference(-45.0, 125.0));\\n        System.out.println(getDifference(-45.0, 145.0));\\n        System.out.println(getDifference(-45.0, 125.0));\\n        System.out.println(getDifference(-45.0, 145.0));\\n        System.out.println(getDifference(29.4803, -88.6381));\\n        System.out.println(getDifference(-78.3251, -159.036));\\n\\n        System.out.println(\""Input in wider range\"");\\n        System.out.println(getDifference(-70099.74233810938, 29840.67437876723));\\n        System.out.println(getDifference(-165313.6666297357, 33693.9894517456));\\n        System.out.println(getDifference(1174.8380510598456, -154146.66490124757));\\n        System.out.println(getDifference(60175.77306795546, 42213.07192354373));\\n    }\\n}"
"Java","Animate_a_pendulum","One good way of making an animation is by simulating a physical system and illustrating the variables in that system using a dynamically changing graphical display.\\nThe classic such physical system is a simple gravity pendulum.\\nFor this task, create a simple physical model of a pendulum and animate it.\\nThis does not use a GUI, it simply animates the pendulum and prints out the positions. If you want, you can replace the output method with graphical update methods.\\nX and Y are relative positions of the pendulum to the anchor.\\npendulums.ads:\\npendulums.adb:\\nexample main.adb:\\n","import java.awt.*;\\nimport javax.swing.*;\\n\\npublic class Pendulum extends JPanel implements Runnable {\\n\\n    private double angle = Math.PI / 2;\\n    private int length;\\n\\n    public Pendulum(int length) {\\n        this.length = length;\\n        setDoubleBuffered(true);\\n    }\\n\\n    @Override\\n    public void paint(Graphics g) {\\n        g.setColor(Color.WHITE);\\n        g.fillRect(0, 0, getWidth(), getHeight());\\n        g.setColor(Color.BLACK);\\n        int anchorX = getWidth() / 2, anchorY = getHeight() / 4;\\n        int ballX = anchorX + (int) (Math.sin(angle) * length);\\n        int ballY = anchorY + (int) (Math.cos(angle) * length);\\n        g.drawLine(anchorX, anchorY, ballX, ballY);\\n        g.fillOval(anchorX - 3, anchorY - 4, 7, 7);\\n        g.fillOval(ballX - 7, ballY - 7, 14, 14);\\n    }\\n\\n    public void run() {\\n        double angleAccel, angleVelocity = 0, dt = 0.1;\\n        while (true) {\\n            angleAccel = -9.81 / length * Math.sin(angle);\\n            angleVelocity += angleAccel * dt;\\n            angle += angleVelocity * dt;\\n            repaint();\\n            try { Thread.sleep(15); } catch (InterruptedException ex) {}\\n        }\\n    }\\n\\n    @Override\\n    public Dimension getPreferredSize() {\\n        return new Dimension(2 * length + 50, length / 2 * 3);\\n    }\\n\\n    public static void main(String[] args) {\\n        JFrame f = new JFrame(\""Pendulum\"");\\n        Pendulum p = new Pendulum(200);\\n        f.add(p);\\n        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\\n        f.pack();\\n        f.setVisible(true);\\n        new Thread(p).start();\\n    }\\n}"
"Java","Animation","\\nAnimation is integral to many parts of GUIs, including both the fancy effects when things change used in window managers, and of course games.   The core of any animation system is a scheme for periodically changing the display while still remaining responsive to the user.   This task demonstrates this.\\n\\nCreate a window containing the string \""Hello World! \"" (the trailing space is significant).\\nMake the text appear to be rotating right by periodically removing one letter from the end of the string and attaching it to the front.\\nWhen the user clicks on the (windowed) text, it should reverse its direction.\\n\\nanimation.adb:\\n(NB: implicitly, through GTK, it uses also Pango library)\\nmodule.ceylon\\nrun.ceylon\\nClojure is a JVM language so this example uses Swing, and illustrates Clojure's platform integration.\\nThe ltk package provides a lisp interface to Tk for creating graphical interfaces. Assuming ltk has been installed somewhere the following will work as per the Tcl example.\\nText-only version (no Java dependency; no clicking, use reverse() and stop() to control):\\n\\nAny mouse button on the text will change the direction.\\nTo exit, push the window's closing cross. (255 + 107 is the combination that is passed to INKEY$ by that button.)\\nClick here for image of running code\\nRun within interpreter GHCi:\\nThe following code uses features exclusive to Unicon.\\nThe following code uses features exclusive to Icon.\\nThis image is a VI Snippet, an executable image of LabVIEW code. The LabVIEW version is shown on the top-right hand corner. You can download it, then drag-and-drop it onto the LabVIEW block diagram from a file browser, and it will appear as runnable, editable code.\\n\\nAny Button can use a blink, a timer which return a changed value, true or false, but here we didn't use it (so we didn't Read from event's stack of values. We can place Stack statement to view this stack in console).\\nWe can use console as window too. Although we don't have events for this window, we can read mouse button. Also we use split screen so first line (line 0) has the title, and all other lines are cleared before we print on it, every 200ms\\nWe use form layer as console (we can't use input statements for those layers). We setup a thread to change form layer, at an interval of 200ms.\\nWhen a thread created saves the current layer, to use it in each iteration.\\nFirst, create a textbox, and by right-clicking it, and selecting component properties, change its name to \""Text\"". Then, create 2 buttons, changing the caption on one to \""Reverse\"", and the other to \""Forward\"". In the edit click action of each respective button, you will put:\\nand:\\nThen in the startup actions, accessed by clicking the 2 gears, add this:\\nCreates a window with a rotating label and 2 buttons to change the direction.\\nExample can be compiled by FreePascal/Lazarus.\\nDid all in one file, normally you have the project-file, the form-unit- and the form-resource-file.\\nA plain text version. The following script works in an XTerm window.\\nThe standard PicoLisp GUI is HTTP based. Connect your browser to\\nhttp://localhost:8080 after starting the following script.\\nThe scrolling text is displayed in a button. Clicking on the button\\nreverses the scroll direction.\\nThis solution works on ErsatzLisp, the Java version of PicoLisp.\\nSWI-Prolog has a grapghic interface XPCE.\\nBefore, load the QB.EXE with /L QB.QLB key, or QBX.EXE with /L QBX.QLB key, or just /L key any of them. That's the easiest way to get the mouse in DOS.\\nPressing to change direction should be on the text. To exit push the right button anywhere.\\nThe basic principle is:create a window with a label in it, then add a handler to the label for rotating the string, and another for changing direction on a click. Use of the tag function allows you to store the text flow direction as an attribute of the label.\\nThis REXX version only works with REXX/Personal or REXX/PC.\\nOutput:\\nScratch is event and animation oriented, so this is a natural task for this language. This solution is hosted at the scratch website, where one can see it in action and read its code.\\nSolution Summary and Comments\\nThe solution consists of two blocks of code. The main block initializes variables upon invocation and sets up a loop to display the crawling \""Hello World! \"" message. The crawl is accomplished by manipulation of the list containing the message as individual characters. The other block of code is attached to the scratch sprite, and all it does is change the direction of the text crawl when the sprite is clicked.\\nI tried a couple of techniques for introducing a delay into the text crawl loop. The command \""Say message for 2 seconds\"" resulted in poor performance; the application's response to clicks was spotty. Using the timer and waiting for it to exceed 2 seconds before resetting it and advancing the crawl worked much better. (I also tried waiting for the timer to equal 2 seconds, and unsurprisingly this resulted in an application freeze-up.)\\n\\nThis program can be concatenated onto a single line using ! as the concatenator:\\nMr. Kibernetik, the creator of smart Basic, offered this ultra-compact one-line version:\\nand smart Basic Forum member sarossell found a way to shorten even that! See if you can spot what is changed.\\nThis animation is defined as a smooth movement rather than by moving whole characters, because that is more natural in SVG (without scripting); by characters would require 13 different text elements displayed in sequence.\\n(Does not work in Safari 4.0.2 because it apparently does not implement toggled animations correctly (see spec). Dreadful workaround: set the two animations to id=\""a\"" begin=\""0s;all.click\"" end=\""all.mousedown\"" and begin=\""a.end\"" end=\""all.click\"", respectively.)\\nThe requirements contain \""When the user clicks on the text…\"". The TI-89 does not have a graphical cursor, so just for the sake of overdoing it, and to have a little more complex animation (overlapping objects), this program implements one. Use the arrow keys and ENTER to control the cursor.\\nIt is not possible to detect mouse clicks while a macro is running. Therefore, the direction is controlled with Caps Lock key.\\nThis example shows code that is hidden by the IDE. (Form creation is done graphically within the IDE, not at runtime.)\\nReplaces the detection of mouse click by pressing a key (Spectrum does not detect this device by default).\\n","import java.awt.event.MouseAdapter;\\nimport java.awt.event.MouseEvent;\\nimport java.awt.event.WindowAdapter;\\nimport java.awt.event.WindowEvent;\\nimport java.util.Timer;\\nimport java.util.TimerTask;\\nimport javax.swing.JFrame;\\nimport javax.swing.JLabel;\\nimport javax.swing.WindowConstants;\\n\\npublic class Rotate {\\n\\n    private static class State {\\n        private final String text = \""Hello World! \"";\\n        private int startIndex = 0;\\n        private boolean rotateRight = true;\\n    }\\n\\n    public static void main(String[] args) {\\n        State state = new State();\\n\\n        JLabel label = new JLabel(state.text);\\n        label.addMouseListener(new MouseAdapter() {\\n            @Override\\n            public void mouseClicked(MouseEvent event) {\\n                state.rotateRight = !state.rotateRight;\\n            }\\n        });\\n\\n        TimerTask task = new TimerTask() {\\n            public void run() {\\n                int delta = state.rotateRight ? 1 : -1;\\n                state.startIndex = (state.startIndex + state.text.length() + delta) % state.text.length();\\n                label.setText(rotate(state.text, state.startIndex));\\n            }\\n        };\\n        Timer timer = new Timer(false);\\n        timer.schedule(task, 0, 500);\\n\\n        JFrame rot = new JFrame();\\n        rot.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\\n        rot.add(label);\\n        rot.pack();\\n        rot.setLocationRelativeTo(null);\\n        rot.addWindowListener(new WindowAdapter() {\\n            @Override\\n            public void windowClosed(WindowEvent e) {\\n                timer.cancel();\\n            }\\n        });\\n        rot.setVisible(true);\\n    }\\n\\n    private static String rotate(String text, int startIdx) {\\n        char[] rotated = new char[text.length()];\\n        for (int i = 0; i < text.length(); i++) {\\n            rotated[i] = text.charAt((i + startIdx) % text.length());\\n        }\\n        return String.valueOf(rotated);\\n    }\\n}"
"Java","Anonymous_recursion","While implementing a recursive function, it often happens that we must resort to a separate   helper function   to handle the actual recursion.\\nThis is usually the case when directly calling the current function would waste too many resources (stack space, execution time), causing unwanted side-effects,   and/or the function doesn't have the right arguments and/or return values.\\nSo we end up inventing some silly name like   foo2   or   foo_helper.   I have always found it painful to come up with a proper name, and see some disadvantages:\\nSome languages allow you to embed recursion directly in-place.   This might work via a label, a local gosub instruction, or some special keyword.\\nAnonymous recursion can also be accomplished using the   Y combinator.\\n\\nIf possible, demonstrate this by writing the recursive version of the fibonacci function   (see Fibonacci sequence)   which checks for a negative argument before doing the actual recursion.\\n\\n","public static long fib(int n) {\\n    if (n < 0)\\n        throw new IllegalArgumentException(\""n can not be a negative number\"");\\n\\n    return new Object() {\\n        private long fibInner(int n) {\\n            return (n < 2) ? n : (fibInner(n - 1) + fibInner(n - 2));\\n        }\\n    }.fibInner(n);\\n}"
"Java","Anonymous_recursion","While implementing a recursive function, it often happens that we must resort to a separate   helper function   to handle the actual recursion.\\nThis is usually the case when directly calling the current function would waste too many resources (stack space, execution time), causing unwanted side-effects,   and/or the function doesn't have the right arguments and/or return values.\\nSo we end up inventing some silly name like   foo2   or   foo_helper.   I have always found it painful to come up with a proper name, and see some disadvantages:\\nSome languages allow you to embed recursion directly in-place.   This might work via a label, a local gosub instruction, or some special keyword.\\nAnonymous recursion can also be accomplished using the   Y combinator.\\n\\nIf possible, demonstrate this by writing the recursive version of the fibonacci function   (see Fibonacci sequence)   which checks for a negative argument before doing the actual recursion.\\n\\n","import java.util.function.Function;\\n\\n@FunctionalInterface\\ninterface SelfApplicable<OUTPUT> {\\n    OUTPUT apply(SelfApplicable<OUTPUT> input);\\n}\\n\\nclass Utils {\\n    public static  SelfApplicable, Function>, Function>> y() {\\n        return y -> f -> x -> f.apply(y.apply(y).apply(f)).apply(x);\\n    }\\n\\n    public static  Function, Function>, Function> fix() {\\n        return Utils.y().apply(Utils.y());\\n    }\\n\\n    public static long fib(int m) {\\n        if (m < 0)\\n            throw new IllegalArgumentException(\""n can not be a negative number\"");\\n\\n        return Utils.fix().apply(\\n                f -> n -> (n < 2) ? n : (f.apply(n - 1) + f.apply(n - 2))\\n        ).apply(m);\\n    }\\n}"
"Java","Anti-primes","The anti-primes\\n(or highly composite numbers)\\nare the natural numbers with more factors than any smaller than itself.\\nGenerate and show here, the first twenty anti-primes.\\n \\n","public class Antiprime {\\n\\n    static int countDivisors(int n) {\\n        if (n < 2) return 1;\\n        int count = 2; // 1 and n\\n        for (int i = 2; i <= n/2; ++i) {\\n            if (n%i == 0) ++count;\\n        }\\n        return count;\\n    }\\n\\n    public static void main(String[] args) {\\n        int maxDiv = 0, count = 0;\\n        System.out.println(\""The first 20 anti-primes are:\"");\\n        for (int n = 1; count < 20; ++n) {\\n            int d = countDivisors(n);\\n            if (d > maxDiv) {\\n                System.out.printf(\""%d \"", n);\\n                maxDiv = d;\\n                count++;\\n            }\\n        }\\n        System.out.println();\\n    }\\n}"
"Java","Append_a_record_to_the_end_of_a_text_file","Many systems offer the ability to open a file for writing, such that any data written will be appended to the end of the file. Further, the file operations will always adjust the position pointer to guarantee the end of the file, even in a multitasking environment.\\nThis feature is most useful in the case of log files, where many jobs may be appending to the log file at the same time, or where care must be taken to avoid concurrently overwriting the same record from another job.\\n\\nGiven a two record sample for a mythical \""passwd\"" file:\\nResulting file format: should mimic Linux's /etc/passwd file format with particular attention to the \"",\"" separator used in the GECOS field. But if the specific language has a particular or unique format of storing records in text file, then this format should be named and demonstrated with an additional example.\\nExpected output:\\nFinally: Provide a summary of the language's \""append record\"" capabilities in a table. eg.\\nAlternatively: If the language's appends can not guarantee its writes will always append, then note this restriction in the table. If possible, provide an actual code example (possibly using file/record locking) to guarantee correct concurrent appends.\\n\\nOutput:","import static java.util.Objects.requireNonNull;\\n\\nimport java.io.IOException;\\nimport java.nio.file.Files;\\nimport java.nio.file.Path;\\nimport java.nio.file.Paths;\\nimport java.nio.file.StandardOpenOption;\\nimport java.util.Arrays;\\nimport java.util.Collections;\\nimport java.util.List;\\nimport java.util.stream.Collectors;\\nimport java.util.stream.Stream;\\n\\npublic class RecordAppender {\\n    static class Record {\\n        private final String account;\\n        private final String password;\\n        private final int uid;\\n        private final int gid;\\n        private final List<String> gecos;\\n        private final String directory;\\n        private final String shell;\\n\\n        public Record(String account, String password, int uid, int gid, List<String> gecos, String directory, String shell) {\\n            this.account = requireNonNull(account);\\n            this.password = requireNonNull(password);\\n            this.uid = uid;\\n            this.gid = gid;\\n            this.gecos = requireNonNull(gecos);\\n            this.directory = requireNonNull(directory);\\n            this.shell = requireNonNull(shell);\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return account + ':' + password + ':' + uid + ':' + gid + ':' + String.join(\"",\"", gecos) + ':' + directory + ':' + shell;\\n        }\\n\\n        public static Record parse(String text) {\\n            String[] tokens = text.split(\"":\"");\\n            return new Record(\\n                    tokens[0],\\n                    tokens[1],\\n                    Integer.parseInt(tokens[2]),\\n                    Integer.parseInt(tokens[3]),\\n                    Arrays.asList(tokens[4].split(\"",\"")),\\n                    tokens[5],\\n                    tokens[6]);\\n        }\\n    }\\n\\n    public static void main(String[] args) throws IOException {\\n        List<String> rawData = Arrays.asList(\\n                \""jsmith:x:1001:1000:Joe Smith,Room 1007,(234)555-8917,(234)555-0077,[email protected]:/home/jsmith:/bin/bash\"",\\n                \""jdoe:x:1002:1000:Jane Doe,Room 1004,(234)555-8914,(234)555-0044,[email protected]:/home/jdoe:/bin/bash\"",\\n                \""xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,[email protected]:/home/xyz:/bin/bash\""\\n        );\\n\\n        List<Record> records = rawData.stream().map(Record::parse).collect(Collectors.toList());\\n\\n        Path tmp = Paths.get(\""_rosetta\"", \"".passwd\"");\\n        Files.createDirectories(tmp.getParent());\\n        Files.write(tmp, (Iterable<String>) records.stream().limit(2).map(Record::toString)::iterator);\\n\\n        Files.write(tmp, Collections.singletonList(records.get(2).toString()), StandardOpenOption.APPEND);\\n\\n        try (Stream<String> lines = Files.lines(tmp)) {\\n            lines.map(Record::parse).forEach(System.out::println);\\n        }\\n    }\\n}"
"Java","Apply_a_callback_to_an_array","Take a combined set of elements and apply a function to each element.\\n\\n","public class ArrayCallback7 {\\n\\n    interface IntConsumer {\\n        void run(int x);\\n    }\\n\\n    interface IntToInt {\\n        int run(int x);\\n    }\\n\\n    static void forEach(int[] arr, IntConsumer consumer) {\\n        for (int i : arr) {\\n            consumer.run(i);\\n        }\\n    }\\n\\n    static void update(int[] arr, IntToInt mapper) {\\n        for (int i = 0; i < arr.length; i++) {\\n            arr[i] = mapper.run(arr[i]);\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\\n\\n        forEach(numbers, new IntConsumer() {\\n            public void run(int x) {\\n                System.out.println(x);\\n            }\\n        });\\n\\n        update(numbers, new IntToInt() {\\n            @Override\\n            public int run(int x) {\\n                return x * x;\\n            }\\n        });\\n\\n        forEach(numbers, new IntConsumer() {\\n            public void run(int x) {\\n                System.out.println(x);\\n            }\\n        });\\n    }\\n}"
"Java","Apply_a_callback_to_an_array","Take a combined set of elements and apply a function to each element.\\n\\n","import java.util.Arrays;\\n\\npublic class ArrayCallback {\\n\\n    public static void main(String[] args) {\\n        int[] myIntArray = {1, 2, 3, 4, 5};\\n\\n        int sum = Arrays.stream(myIntArray)\\n                .map(x -> {\\n                    int cube = x * x * x;\\n                    System.out.println(cube);\\n                    return cube;\\n                })\\n                .reduce(0, (left, right) -> left + right); // <-- could substitute .sum() for .reduce(...) here.\\n        System.out.println(\""sum: \"" + sum);\\n    }\\n}"
"Java","Apply_a_digital_filter_(direct_form_II_transposed)","Digital filters are used to apply a mathematical operation to a sampled signal. One of the common formulations is the \""direct form II transposed\"" which can represent both infinite impulse response (IIR) and finite impulse response (FIR) filters, as well as being more numerically stable than other forms. [1]\\nFilter a signal using an order 3 low-pass Butterworth filter. The coefficients for the filter are a=[1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17] and b = [0.16666667, 0.5, 0.5, 0.16666667]\\nThe signal that needs filtering is the following vector: [-0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412, -0.662370894973, -1.00700480494, -0.404707073677 ,0.800482325044, 0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195, 0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293, 0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589]\\nGiven the number of values a coefficient or signal vector can have and the number of digits, this implementation reads data from a file and prints it to the console if no output file is specified or writes to the specified output file. Usage printed on incorrect invocation.\\nInput file, 3 lines containing first ( a ) and second ( b ) coefficient followed by the signal, all values should be separated by a single space:\\nInvocation and output for writing to file :\\nOutput file :\\nThis uses the C++11 method of initializing vectors. In g++, use the -std=c++0x compiler switch.\\n","public class DigitalFilter {\\n    private static double[] filter(double[] a, double[] b, double[] signal) {\\n        double[] result = new double[signal.length];\\n        for (int i = 0; i < signal.length; ++i) {\\n            double tmp = 0.0;\\n            for (int j = 0; j < b.length; ++j) {\\n                if (i - j < 0) continue;\\n                tmp += b[j] * signal[i - j];\\n            }\\n            for (int j = 1; j < a.length; ++j) {\\n                if (i - j < 0) continue;\\n                tmp -= a[j] * result[i - j];\\n            }\\n            tmp /= a[0];\\n            result[i] = tmp;\\n        }\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        double[] a = new double[]{1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17};\\n        double[] b = new double[]{0.16666667, 0.5, 0.5, 0.16666667};\\n\\n        double[] signal = new double[]{\\n            -0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412,\\n            -0.662370894973, -1.00700480494, -0.404707073677, 0.800482325044,\\n            0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195,\\n            0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293,\\n            0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589\\n        };\\n\\n        double[] result = filter(a, b, signal);\\n        for (int i = 0; i < result.length; ++i) {\\n            System.out.printf(\""% .8f\"", result[i]);\\n            System.out.print((i + 1) % 5 != 0 ? \"", \"" : \""\\n\"");\\n        }\\n    }\\n}"
"Java","Arbitrary-precision_integers_(included)","Using the in-built capabilities of your language, calculate the integer value of:\\n\\n\\n\\n","import java.math.BigInteger;\\n\\nclass IntegerPower {\\n    public static void main(String[] args) {\\n        BigInteger power = BigInteger.valueOf(5).pow(BigInteger.valueOf(4).pow(BigInteger.valueOf(3).pow(2).intValueExact()).intValueExact());\\n        String str = power.toString();\\n        int len = str.length();\\n        System.out.printf(\""5**4**3**2 = %s...%s and has %d digits%n\"",\\n                str.substring(0, 20), str.substring(len - 20), len);\\n    }\\n}"
"Java","Archimedean_spiral","The Archimedean spiral is a spiral named after the Greek mathematician Archimedes.\\n\\nAn Archimedean spiral can be described by the equation:\\nwith real numbers a and b.\\n\\nDraw an Archimedean spiral.\\n\\n\\n","import java.awt.*;\\nimport static java.lang.Math.*;\\nimport javax.swing.*;\\n\\npublic class ArchimedeanSpiral extends JPanel {\\n\\n    public ArchimedeanSpiral() {\\n        setPreferredSize(new Dimension(640, 640));\\n        setBackground(Color.white);\\n    }\\n\\n    void drawGrid(Graphics2D g) {\\n        g.setColor(new Color(0xEEEEEE));\\n        g.setStroke(new BasicStroke(2));\\n\\n        double angle = toRadians(45);\\n\\n        int w = getWidth();\\n        int center = w / 2;\\n        int margin = 10;\\n        int numRings = 8;\\n\\n        int spacing = (w - 2 * margin) / (numRings * 2);\\n\\n        for (int i = 0; i < numRings; i++) {\\n            int pos = margin + i * spacing;\\n            int size = w - (2 * margin + i * 2 * spacing);\\n            g.drawOval(pos, pos, size, size);\\n\\n            double ia = i * angle;\\n            int x2 = center + (int) (cos(ia) * (w - 2 * margin) / 2);\\n            int y2 = center - (int) (sin(ia) * (w - 2 * margin) / 2);\\n\\n            g.drawLine(center, center, x2, y2);\\n        }\\n    }\\n\\n    void drawSpiral(Graphics2D g) {\\n        g.setStroke(new BasicStroke(2));\\n        g.setColor(Color.orange);\\n\\n        double degrees = toRadians(0.1);\\n        double center = getWidth() / 2;\\n        double end = 360 * 2 * 10 * degrees;\\n        double a = 0;\\n        double b = 20;\\n        double c = 1;\\n\\n        for (double theta = 0; theta < end; theta += degrees) {\\n            double r = a + b * pow(theta, 1 / c);\\n            double x = r * cos(theta);\\n            double y = r * sin(theta);\\n            plot(g, (int) (center + x), (int) (center - y));\\n        }\\n    }\\n\\n    void plot(Graphics2D g, int x, int y) {\\n        g.drawOval(x, y, 1, 1);\\n    }\\n\\n    @Override\\n    public void paintComponent(Graphics gg) {\\n        super.paintComponent(gg);\\n        Graphics2D g = (Graphics2D) gg;\\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\\n                RenderingHints.VALUE_ANTIALIAS_ON);\\n\\n        drawGrid(g);\\n        drawSpiral(g);\\n    }\\n\\n    public static void main(String[] args) {\\n        SwingUtilities.invokeLater(() -> {\\n            JFrame f = new JFrame();\\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\\n            f.setTitle(\""Archimedean Spiral\"");\\n            f.setResizable(false);\\n            f.add(new ArchimedeanSpiral(), BorderLayout.CENTER);\\n            f.pack();\\n            f.setLocationRelativeTo(null);\\n            f.setVisible(true);\\n        });\\n    }\\n}"
"Java","Arithmetic_coding/As_a_generalized_change_of_radix","Create a program which implements the arithmetic coding as a generalized change of radix.\\nShow the results, in base 10, for all the following strings:\\n\\nVerify the implementation by decoding the results back into strings and checking for equality with the given strings.\\n","import java.math.BigInteger;\\nimport java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.Objects;\\n\\npublic class ArithmeticCoding {\\n    private static class Triple {\\n        A a;\\n        B b;\\n        C c;\\n\\n        Triple(A a, B b, C c) {\\n            this.a = a;\\n            this.b = b;\\n            this.c = c;\\n        }\\n    }\\n\\n    private static class Freq extends HashMap {\\n        //\""type alias\""\\n    }\\n\\n    private static Freq cumulativeFreq(Freq freq) {\\n        long total = 0;\\n        Freq cf = new Freq();\\n        for (int i = 0; i < 256; ++i) {\\n            char c = (char) i;\\n            Long v = freq.get(c);\\n            if (v != null) {\\n                cf.put(c, total);\\n                total += v;\\n            }\\n        }\\n        return cf;\\n    }\\n\\n    private static Triple arithmeticCoding(String str, Long radix) {\\n        // Convert the string into a char array\\n        char[] chars = str.toCharArray();\\n\\n        // The frequency characters\\n        Freq freq = new Freq();\\n        for (char c : chars) {\\n            if (!freq.containsKey(c))\\n                freq.put(c, 1L);\\n            else\\n                freq.put(c, freq.get(c) + 1);\\n        }\\n\\n        // The cumulative frequency\\n        Freq cf = cumulativeFreq(freq);\\n\\n        // Base\\n        BigInteger base = BigInteger.valueOf(chars.length);\\n\\n        // LowerBound\\n        BigInteger lower = BigInteger.ZERO;\\n\\n        // Product of all frequencies\\n        BigInteger pf = BigInteger.ONE;\\n\\n        // Each term is multiplied by the product of the\\n        // frequencies of all previously occurring symbols\\n        for (char c : chars) {\\n            BigInteger x = BigInteger.valueOf(cf.get(c));\\n            lower = lower.multiply(base).add(x.multiply(pf));\\n            pf = pf.multiply(BigInteger.valueOf(freq.get(c)));\\n        }\\n\\n        // Upper bound\\n        BigInteger upper = lower.add(pf);\\n\\n        int powr = 0;\\n        BigInteger bigRadix = BigInteger.valueOf(radix);\\n\\n        while (true) {\\n            pf = pf.divide(bigRadix);\\n            if (pf.equals(BigInteger.ZERO)) break;\\n            powr++;\\n        }\\n\\n        BigInteger diff = upper.subtract(BigInteger.ONE).divide(bigRadix.pow(powr));\\n        return new Triple<>(diff, powr, freq);\\n    }\\n\\n    private static String arithmeticDecoding(BigInteger num, long radix, int pwr, Freq freq) {\\n        BigInteger powr = BigInteger.valueOf(radix);\\n        BigInteger enc = num.multiply(powr.pow(pwr));\\n        long base = 0;\\n        for (Long v : freq.values()) base += v;\\n\\n        // Create the cumulative frequency table\\n        Freq cf = cumulativeFreq(freq);\\n\\n        // Create the dictionary\\n        Map dict = new HashMap<>();\\n        for (Map.Entry entry : cf.entrySet()) dict.put(entry.getValue(), entry.getKey());\\n\\n        // Fill the gaps in the dictionary\\n        long lchar = -1;\\n        for (long i = 0; i < base; ++i) {\\n            Character v = dict.get(i);\\n            if (v != null) {\\n                lchar = v;\\n            } else if (lchar != -1) {\\n                dict.put(i, (char) lchar);\\n            }\\n        }\\n\\n        // Decode the input number\\n        StringBuilder decoded = new StringBuilder((int) base);\\n        BigInteger bigBase = BigInteger.valueOf(base);\\n        for (long i = base - 1; i >= 0; --i) {\\n            BigInteger pow = bigBase.pow((int) i);\\n            BigInteger div = enc.divide(pow);\\n            Character c = dict.get(div.longValue());\\n            BigInteger fv = BigInteger.valueOf(freq.get(c));\\n            BigInteger cv = BigInteger.valueOf(cf.get(c));\\n            BigInteger diff = enc.subtract(pow.multiply(cv));\\n            enc = diff.divide(fv);\\n            decoded.append(c);\\n        }\\n        // Return the decoded output\\n        return decoded.toString();\\n    }\\n\\n    public static void main(String[] args) {\\n        long radix = 10;\\n        String[] strings = {\""DABDDB\"", \""DABDDBBDDBA\"", \""ABRACADABRA\"", \""TOBEORNOTTOBEORTOBEORNOT\""};\\n        String fmt = \""%-25s=> %19s * %d^%s\\n\"";\\n        for (String str : strings) {\\n            Triple encoded = arithmeticCoding(str, radix);\\n            String dec = arithmeticDecoding(encoded.a, radix, encoded.b, encoded.c);\\n            System.out.printf(fmt, str, encoded.a, radix, encoded.b);\\n            if (!Objects.equals(str, dec)) throw new RuntimeException(\""\\tHowever that is incorrect!\"");\\n        }\\n    }\\n}"
"Java","Arithmetic_evaluation","Create a program which parses and evaluates arithmetic expressions.\\n\\nFor those who don't remember, mathematical precedence is as follows:\\n\\n\\nPratt parser\\n","import java.util.Stack;\\n\\npublic class ArithmeticEvaluation {\\n\\n    public interface Expression {\\n        BigRational eval();\\n    }\\n\\n    public enum Parentheses {LEFT}\\n\\n    public enum BinaryOperator {\\n        ADD('+', 1),\\n        SUB('-', 1),\\n        MUL('*', 2),\\n        DIV('/', 2);\\n\\n        public final char symbol;\\n        public final int precedence;\\n\\n        BinaryOperator(char symbol, int precedence) {\\n            this.symbol = symbol;\\n            this.precedence = precedence;\\n        }\\n\\n        public BigRational eval(BigRational leftValue, BigRational rightValue) {\\n            switch (this) {\\n                case ADD:\\n                    return leftValue.add(rightValue);\\n                case SUB:\\n                    return leftValue.subtract(rightValue);\\n                case MUL:\\n                    return leftValue.multiply(rightValue);\\n                case DIV:\\n                    return leftValue.divide(rightValue);\\n            }\\n            throw new IllegalStateException();\\n        }\\n\\n        public static BinaryOperator forSymbol(char symbol) {\\n            for (BinaryOperator operator : values()) {\\n                if (operator.symbol == symbol) {\\n                    return operator;\\n                }\\n            }\\n            throw new IllegalArgumentException(String.valueOf(symbol));\\n        }\\n    }\\n\\n    public static class Number implements Expression {\\n        private final BigRational number;\\n\\n        public Number(BigRational number) {\\n            this.number = number;\\n        }\\n\\n        @Override\\n        public BigRational eval() {\\n            return number;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return number.toString();\\n        }\\n    }\\n\\n    public static class BinaryExpression implements Expression {\\n        public final Expression leftOperand;\\n        public final BinaryOperator operator;\\n        public final Expression rightOperand;\\n\\n        public BinaryExpression(Expression leftOperand, BinaryOperator operator, Expression rightOperand) {\\n            this.leftOperand = leftOperand;\\n            this.operator = operator;\\n            this.rightOperand = rightOperand;\\n        }\\n\\n        @Override\\n        public BigRational eval() {\\n            BigRational leftValue = leftOperand.eval();\\n            BigRational rightValue = rightOperand.eval();\\n            return operator.eval(leftValue, rightValue);\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \""(\"" + leftOperand + \"" \"" + operator.symbol + \"" \"" + rightOperand + \"")\"";\\n        }\\n    }\\n\\n    private static void createNewOperand(BinaryOperator operator, Stack<Expression> operands) {\\n        Expression rightOperand = operands.pop();\\n        Expression leftOperand = operands.pop();\\n        operands.push(new BinaryExpression(leftOperand, operator, rightOperand));\\n    }\\n\\n    public static Expression parse(String input) {\\n        int curIndex = 0;\\n        boolean afterOperand = false;\\n        Stack<Expression> operands = new Stack<>();\\n        Stack<Object> operators = new Stack<>();\\n        while (curIndex < input.length()) {\\n            int startIndex = curIndex;\\n            char c = input.charAt(curIndex++);\\n\\n            if (Character.isWhitespace(c))\\n                continue;\\n\\n            if (afterOperand) {\\n                if (c == ')') {\\n                    Object operator;\\n                    while (!operators.isEmpty() && ((operator = operators.pop()) != Parentheses.LEFT))\\n                        createNewOperand((BinaryOperator) operator, operands);\\n                    continue;\\n                }\\n                afterOperand = false;\\n                BinaryOperator operator = BinaryOperator.forSymbol(c);\\n                while (!operators.isEmpty() && (operators.peek() != Parentheses.LEFT) && (((BinaryOperator) operators.peek()).precedence >= operator.precedence))\\n                    createNewOperand((BinaryOperator) operators.pop(), operands);\\n                operators.push(operator);\\n                continue;\\n            }\\n\\n            if (c == '(') {\\n                operators.push(Parentheses.LEFT);\\n                continue;\\n            }\\n\\n            afterOperand = true;\\n            while (curIndex < input.length()) {\\n                c = input.charAt(curIndex);\\n                if (((c < '0') || (c > '9')) && (c != '.'))\\n                    break;\\n                curIndex++;\\n            }\\n            operands.push(new Number(BigRational.valueOf(input.substring(startIndex, curIndex))));\\n        }\\n\\n        while (!operators.isEmpty()) {\\n            Object operator = operators.pop();\\n            if (operator == Parentheses.LEFT)\\n                throw new IllegalArgumentException();\\n            createNewOperand((BinaryOperator) operator, operands);\\n        }\\n\\n        Expression expression = operands.pop();\\n        if (!operands.isEmpty())\\n            throw new IllegalArgumentException();\\n        return expression;\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] testExpressions = {\\n                \""2+3\"",\\n                \""2+3/4\"",\\n                \""2*3-4\"",\\n                \""2*(3+4)+5/6\"",\\n                \""2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10\"",\\n                \""2*-3--4+-.25\""};\\n        for (String testExpression : testExpressions) {\\n            Expression expression = parse(testExpression);\\n            System.out.printf(\""Input: \\\""%s\\\"", AST: \\\""%s\\\"", value=%s%n\"", testExpression, expression, expression.eval());\\n        }\\n    }\\n}"
"Java","Arithmetic-geometric_mean","\\nWrite a function to compute the arithmetic-geometric mean of two numbers.\\n[1]\\nThe arithmetic-geometric mean of two numbers can be (usefully) denoted as \\n\\n\\n\\n\\na\\ng\\nm\\n\\n(\\na\\n,\\ng\\n)\\n\\n\\n{\\displaystyle \\mathrm {agm} (a,g)}\\n\\n, and is equal to the limit of the sequence:\\nSince the limit of \\n\\n\\n\\n\\na\\n\\nn\\n\\n\\n−\\n\\ng\\n\\nn\\n\\n\\n\\n\\n{\\displaystyle a_{n}-g_{n}}\\n\\n tends (rapidly) to zero with iterations, this is an efficient method.\\nDemonstrate the function by calculating:\\n\\n\\n","/*\\n * Arithmetic-Geometric Mean of 1 & 1/sqrt(2)\\n * Brendan Shaklovitz\\n * 5/29/12\\n */\\npublic class ArithmeticGeometricMean {\\n\\n    public static double agm(double a, double g) {\\n        double a1 = a;\\n        double g1 = g;\\n        while (Math.abs(a1 - g1) >= 1.0e-14) {\\n            double arith = (a1 + g1) / 2.0;\\n            double geom = Math.sqrt(a1 * g1);\\n            a1 = arith;\\n            g1 = geom;\\n        }\\n        return a1;\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(agm(1.0, 1.0 / Math.sqrt(2.0)));\\n    }\\n}"
"Java","Arithmetic-geometric_mean/Calculate_Pi","Almkvist Berndt 1988 begins with an investigation of why the agm is such an efficient algorithm, and proves that it converges quadratically. This is an efficient method to calculate \\n\\n\\n\\nπ\\n\\n\\n{\\displaystyle \\pi }\\n\\n.\\nWith the same notations used in Arithmetic-geometric mean, we can summarize the paper by writing:\\n\\n\\n\\n\\nπ\\n=\\n\\n\\n\\n4\\n\\n\\na\\ng\\nm\\n\\n(\\n1\\n,\\n1\\n\\n/\\n\\n\\n\\n2\\n\\n\\n\\n)\\n\\n2\\n\\n\\n\\n\\n1\\n−\\n\\n∑\\n\\nn\\n=\\n1\\n\\n\\n∞\\n\\n\\n\\n2\\n\\nn\\n+\\n1\\n\\n\\n(\\n\\na\\n\\nn\\n\\n\\n2\\n\\n\\n−\\n\\ng\\n\\nn\\n\\n\\n2\\n\\n\\n)\\n\\n\\n\\n\\n\\n{\\displaystyle \\pi ={\\frac {4\\;\\mathrm {agm} (1,1/{\\sqrt {2}})^{2}}{1-\\sum \\limits _{n=1}^{\\infty }2^{n+1}(a_{n}^{2}-g_{n}^{2})}}}\\n\\n\\nThis allows you to make the approximation, for any large   N:\\n\\n\\n\\n\\nπ\\n≈\\n\\n\\n\\n4\\n\\n\\na\\n\\nN\\n\\n\\n2\\n\\n\\n\\n\\n1\\n−\\n\\n∑\\n\\nk\\n=\\n1\\n\\n\\nN\\n\\n\\n\\n2\\n\\nk\\n+\\n1\\n\\n\\n(\\n\\na\\n\\nk\\n\\n\\n2\\n\\n\\n−\\n\\ng\\n\\nk\\n\\n\\n2\\n\\n\\n)\\n\\n\\n\\n\\n\\n{\\displaystyle \\pi \\approx {\\frac {4\\;a_{N}^{2}}{1-\\sum \\limits _{k=1}^{N}2^{k+1}(a_{k}^{2}-g_{k}^{2})}}}\\n\\n\\nThe purpose of this task is to demonstrate how to use this approximation in order to compute a large number of decimals of \\n\\n\\n\\nπ\\n\\n\\n{\\displaystyle \\pi }\\n\\n.\\nSee Talk:Arithmetic-geometric mean\\ni<7 produces:\\ni<8 produces:\\n","import java.math.BigDecimal;\\nimport java.math.MathContext;\\nimport java.util.Objects;\\n\\npublic class Calculate_Pi {\\n    private static final MathContext con1024 = new MathContext(1024);\\n    private static final BigDecimal bigTwo = new BigDecimal(2);\\n    private static final BigDecimal bigFour = new BigDecimal(4);\\n\\n    private static BigDecimal bigSqrt(BigDecimal bd, MathContext con) {\\n        BigDecimal x0 = BigDecimal.ZERO;\\n        BigDecimal x1 = BigDecimal.valueOf(Math.sqrt(bd.doubleValue()));\\n        while (!Objects.equals(x0, x1)) {\\n            x0 = x1;\\n            x1 = bd.divide(x0, con).add(x0).divide(bigTwo, con);\\n        }\\n        return x1;\\n    }\\n\\n    public static void main(String[] args) {\\n        BigDecimal a = BigDecimal.ONE;\\n        BigDecimal g = a.divide(bigSqrt(bigTwo, con1024), con1024);\\n        BigDecimal t;\\n        BigDecimal sum = BigDecimal.ZERO;\\n        BigDecimal pow = bigTwo;\\n        while (!Objects.equals(a, g)) {\\n            t = a.add(g).divide(bigTwo, con1024);\\n            g = bigSqrt(a.multiply(g), con1024);\\n            a = t;\\n            pow = pow.multiply(bigTwo);\\n            sum = sum.add(a.multiply(a).subtract(g.multiply(g)).multiply(pow));\\n        }\\n        BigDecimal pi = bigFour.multiply(a.multiply(a)).divide(BigDecimal.ONE.subtract(sum), con1024);\\n        System.out.println(pi);\\n    }\\n}"
"Java","Arithmetic/Complex","A   complex number   is a number which can be written as:\\n\\n\\n\\n\\na\\n+\\nb\\n×\\ni\\n\\n\\n{\\displaystyle a+b\\times i}\\n\\n\\n(sometimes shown as:\\n\\n\\n\\n\\nb\\n+\\na\\n×\\ni\\n\\n\\n{\\displaystyle b+a\\times i}\\n\\n\\nwhere   \\n\\n\\n\\na\\n\\n\\n{\\displaystyle a}\\n\\n   and   \\n\\n\\n\\nb\\n\\n\\n{\\displaystyle b}\\n\\n  are real numbers,   and   \\n\\n\\n\\ni\\n\\n\\n{\\displaystyle i}\\n\\n   is   √ -1 \\n\\nTypically, complex numbers are represented as a pair of real numbers called the \""imaginary part\"" and \""real part\"",   where the imaginary part is the number to be multiplied by \\n\\n\\n\\ni\\n\\n\\n{\\displaystyle i}\\n\\n.\\n\\n\\nBy definition, the   complex conjugate   of\\n\\n\\n\\n\\na\\n+\\nb\\ni\\n\\n\\n{\\displaystyle a+bi}\\n\\n\\nis\\n\\n\\n\\n\\na\\n−\\nb\\ni\\n\\n\\n{\\displaystyle a-bi}\\n\\n\\n\\nSome languages have complex number libraries available.   If your language does, show the operations.   If your language does not, also show the definition of this type.\\n\\n","public class Complex {\\n    public final double real;\\n    public final double imag;\\n\\n    public Complex() {\\n        this(0, 0);\\n    }\\n\\n    public Complex(double r, double i) {\\n        real = r;\\n        imag = i;\\n    }\\n\\n    public Complex add(Complex b) {\\n        return new Complex(this.real + b.real, this.imag + b.imag);\\n    }\\n\\n    public Complex mult(Complex b) {\\n        // FOIL of (a+bi)(c+di) with i*i = -1\\n        return new Complex(this.real * b.real - this.imag * b.imag,\\n                this.real * b.imag + this.imag * b.real);\\n    }\\n\\n    public Complex inv() {\\n        // 1/(a+bi) * (a-bi)/(a-bi) = 1/(a+bi) but it's more workable\\n        double denom = real * real + imag * imag;\\n        return new Complex(real / denom, -imag / denom);\\n    }\\n\\n    public Complex neg() {\\n        return new Complex(-real, -imag);\\n    }\\n\\n    public Complex conj() {\\n        return new Complex(real, -imag);\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return real + \"" + \"" + imag + \"" * i\"";\\n    }\\n\\n    public static void main(String[] args) {\\n        Complex a = new Complex(Math.PI, -5); //just some numbers\\n        Complex b = new Complex(-1, 2.5);\\n        System.out.println(a.neg());\\n        System.out.println(a.add(b));\\n        System.out.println(a.inv());\\n        System.out.println(a.mult(b));\\n        System.out.println(a.conj());\\n    }\\n}"
"Java","Arithmetic/Integer","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\nGet two integers from the user,   and then (for those two integers), display their:\\n\\nDon't include error handling.\\nFor quotient, indicate how it rounds   (e.g. towards zero, towards negative infinity, etc.).\\nFor remainder, indicate whether its sign matches the sign of the first operand or of the second operand, if they are different.\\n\\n","import java.util.Scanner;\\n\\npublic class IntegerArithmetic {\\n    public static void main(String[] args) {\\n        // Get the 2 numbers from command line arguments\\n        Scanner sc = new Scanner(System.in);\\n        int a = sc.nextInt();\\n        int b = sc.nextInt();\\n\\n        int sum = a + b;        // The result of adding 'a' and 'b' (Note: integer addition is discouraged in print statements due to confusion with string concatenation)\\n        int difference = a - b; // The result of subtracting 'b' from 'a'\\n        int product = a * b;    // The result of multiplying 'a' and 'b'\\n        int division = a / b;   // The result of dividing 'a' by 'b' (Note: 'division' does not contain the fractional result)\\n        int remainder = a % b;  // The remainder of dividing 'a' by 'b'\\n\\n        System.out.println(\""a + b = \"" + sum);\\n        System.out.println(\""a - b = \"" + difference);\\n        System.out.println(\""a * b = \"" + product);\\n        System.out.println(\""quotient of a / b = \"" + division);   // truncates towards 0\\n        System.out.println(\""remainder of a / b = \"" + remainder);   // same sign as first operand\\n    }\\n}"
"Java","Arithmetic/Rational","Create a reasonably complete implementation of rational arithmetic in the particular language using the idioms of the language.\\n\\nDefine a new type called frac with binary operator \""//\"" of two integers that returns a structure made up of the numerator and the denominator (as per a rational number).\\nFurther define the appropriate rational unary operators abs and '-', with the binary operators for addition '+', subtraction '-', multiplication '×', division '/', integer division '÷', modulo division, the comparison operators (e.g. '<', '≤', '>', & '≥') and equality operators (e.g. '=' & '≠').\\nDefine standard coercion operators for casting int to frac etc.\\nIf space allows, define standard increment and decrement operators (e.g. '+:=' & '-:=' etc.).\\nFinally test the operators:\\nUse the new type frac to find all perfect numbers less than 219 by summing the reciprocal of the factors.\\n\\n\\nThe generic package specification:\\nThe package can be instantiated with any integer type. It provides rational numbers represented by a numerator and denominator cleaned from the common divisors. Mixed arithmetic of the base integer type and the rational type is supported. Division to zero raises Constraint_Error. The implementation of the specification above is as follows:\\nThe implementation uses solution of the greatest common divisor task. Here is the implementation of the test:\\nThe perfect numbers are searched by summing of the reciprocal of each of the divisors of a candidate except 1. This sum must be 1 for a perfect number.\\n","public class BigRationalFindPerfectNumbers {\\n    public static void main(String[] args) {\\n        int MAX_NUM = 1 << 19;\\n        System.out.println(\""Searching for perfect numbers in the range [1, \"" + (MAX_NUM - 1) + \""]\"");\\n\\n        BigRational TWO = BigRational.valueOf(2);\\n        for (int i = 1; i < MAX_NUM; i++) {\\n            BigRational reciprocalSum = BigRational.ONE;\\n            if (i > 1)\\n                reciprocalSum = reciprocalSum.add(BigRational.valueOf(i).reciprocal());\\n            int maxDivisor = (int) Math.sqrt(i);\\n            if (maxDivisor >= i)\\n                maxDivisor--;\\n\\n            for (int divisor = 2; divisor <= maxDivisor; divisor++) {\\n                if (i % divisor == 0) {\\n                    reciprocalSum = reciprocalSum.add(BigRational.valueOf(divisor).reciprocal());\\n                    int dividend = i / divisor;\\n                    if (divisor != dividend)\\n                        reciprocalSum = reciprocalSum.add(BigRational.valueOf(dividend).reciprocal());\\n                }\\n            }\\n            if (reciprocalSum.equals(TWO))\\n                System.out.println(String.valueOf(i) + \"" is a perfect number\"");\\n        }\\n    }\\n}"
"Java","Array_concatenation","Show how to concatenate two arrays in your language.\\n\\nIf this is as simple as array1 + array2, so be it.\\n\\n","public static Object[] concat(Object[] arr1, Object[] arr2) {\\n    Object[] res = new Object[arr1.length + arr2.length];\\n\\n    System.arraycopy(arr1, 0, res, 0, arr1.length);\\n    System.arraycopy(arr2, 0, res, arr1.length, arr2.length);\\n\\n    return res;\\n}"
"Java","Array_length","Determine the amount of elements in an array.\\n\\nAs an example use an array holding the strings 'apple' and 'orange'.\\n\\n\\n","public class ArrayLength {\\n    public static void main(String[] args) {\\n        System.out.println(new String[]{\""apple\"", \""orange\""}.length);\\n    }\\n}"
"Java","Arrays","This task is about arrays.\\nFor hashes or associative arrays, please see Creating an Associative Array.\\nFor a definition and in-depth discussion of what an array is, see Array.\\n\\nShow basic array syntax in your language.\\nBasically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and\\ndynamic arrays, pushing a value into it).\\nPlease discuss at Village Pump:   Arrays.\\nPlease merge code in from these obsolete tasks:\\n\\n\\nDynamic (resizable) arrays are possible to implement, but are error-prone since bounds checking must be done by the programmer.\\nArrays are declared using JSON syntax, and are dynamic (but not sparse)\\nThere are no real arrays in ABAP but a construct called internal tables.\\n","int[] array = new int[10]; //optionally, replace \""new int[10]\"" with a braced list of ints like \""{1, 2, 3}\""\\narray[0] = 42;\\nSystem.out.println(array[3]);"
"Java","Arrays","This task is about arrays.\\nFor hashes or associative arrays, please see Creating an Associative Array.\\nFor a definition and in-depth discussion of what an array is, see Array.\\n\\nShow basic array syntax in your language.\\nBasically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and\\ndynamic arrays, pushing a value into it).\\nPlease discuss at Village Pump:   Arrays.\\nPlease merge code in from these obsolete tasks:\\n\\n\\nDynamic (resizable) arrays are possible to implement, but are error-prone since bounds checking must be done by the programmer.\\nArrays are declared using JSON syntax, and are dynamic (but not sparse)\\nThere are no real arrays in ABAP but a construct called internal tables.\\n","List<Integer> list = new ArrayList<Integer>();   // optionally add an initial size as an argument\\nlist.add(5);   // appends to the end of the list\\nlist.add(1, 6);   // inserts an element at index 1\\nSystem.out.println(list.get(0));"
"Java","Assertions","Assertions are a way of breaking out of code when there is an error or an unexpected input.\\nSome languages throw exceptions and some treat it as a break point.\\n\\nShow an assertion in your language by asserting that an integer variable is equal to 42.\\n\\nUsing pragma Assert:\\nThe behavior of pragma is controlled by pragma Assertion_Policy. Another way is to use the predefined package Ada.Assertions:\\nThe procedure Assert propagates Assertion_Error when condition is false.\\nExecuting the program will produce on standard error:\\nThe \""Revised Report on the Algorithmic Language - ALGOL 68\"" suggest that\\nASSERT may be made available by a particular implementation, quote: \""Pragmats may\\n... convey to the implementation some piece of information affecting some aspect\\nof the meaning of the program which is not defined by this Report,...\""\\nExample given[1]:\\nThis works with neither ELLA ALGOL 68 nor ALGOL 68G.\\nThe standard alternative would be to implement the assertions\\nas an exception as per the Exceptions sample code.\\nIn ELLA ALGOL 68 the ASSERT is implemented as an operator in the environment prelude:\\nAnd can be \""USEd\"" as follows:\\nAssertions were added to the 1972 version of Algol W. If the tested condition is false, the program terminates. In the following, the write does not get executed.\\nAsserts that the specified condition is true. If it is not, a fatal error is returned that causes code execution to halt.\\nAsserts that the first two arguments are the same. If they are not, a fatal error is returned that causes code execution to halt.\\nAsserts that the first two arguments are different. If they are the same, a fatal error is returned that causes code execution to halt.\\nYou can’t catch an assertion failure using a try/catch block even though it is logged as an exception.\\nAWK doesn't have a built-in assert statement. It could be simulated using a user-defined assert() function defined as below. The BEGIN section shows some examples of successful and failed \""assertions\"".\\nThe above example produces the output below, and sets the program's exit code to 1 (the default is 0)\\n","public class Assertions {\\n\\n    public static void main(String[] args) {\\n        int a = 13;\\n\\n        // ... some real code here ...\\n\\n        assert a == 42;\\n        // Throws an AssertionError when a is not 42.\\n\\n        assert a == 42 : \""Error message\"";\\n        // Throws an AssertionError when a is not 42,\\n        // with \""Error message\"" for the message.\\n        // The error message can be any non-void expression.\\n    }\\n}"
"Java","Assertions_in_design_by_contract","According to   Wikipedia;   assertions can function as a form of documentation:   they can describe the state the code expects to find before it runs (its preconditions), and the state the code expects to result in when it is finished running (postconditions);   they can also specify invariants of a class.\\n\\nShow in the program language of your choice an example of the use of assertions as a form of documentation.\\n\\nAlgol W has assertions. Although pre and post conditions are not built in to the language, assertions can be used to simulate them.\\n","(...)\\nint feedForward(double[] inputs) {\\n    assert inputs.length == weights.length : \""weights and input length mismatch\"";\\n\\n    double sum = 0;\\n    for (int i = 0; i < weights.length; i++) {\\n        sum += inputs[i] * weights[i];\\n    }\\n    return activate(sum);\\n}\\n(...)"
"Java","Associative_array/Creation","The goal is to create an associative array (also known as a dictionary, map, or hash).\\n\\nRelated tasks:\\n\\n\\n8th has 'maps' as built-in data types, and can use JSON to describe them:\\nAlternatively, they can be created in code:\\nBecause ActionScript does not have associative arrays in the normal sense, Object objects are used instead and keys are simply properties on those objects.\\nNote: The Object only supports String keys. To use an object as a key, try the flash.utils.Dictionary class.\\nAikido provides a native map for associative arrays. You can create them using a map literal and you can insert and remove items on the fly.\\nAime records are heterogenous associative arrays. No creation procedure is required, declaration is fine.\\n","Map map = new HashMap();\\nmap.put(\""foo\"", 5);\\nmap.put(\""bar\"", 10);\\nmap.put(\""baz\"", 15);\\nmap.put(\""foo\"", 6);"
"Java","Associative_array/Creation","The goal is to create an associative array (also known as a dictionary, map, or hash).\\n\\nRelated tasks:\\n\\n\\n8th has 'maps' as built-in data types, and can use JSON to describe them:\\nAlternatively, they can be created in code:\\nBecause ActionScript does not have associative arrays in the normal sense, Object objects are used instead and keys are simply properties on those objects.\\nNote: The Object only supports String keys. To use an object as a key, try the flash.utils.Dictionary class.\\nAikido provides a native map for associative arrays. You can create them using a map literal and you can insert and remove items on the fly.\\nAime records are heterogenous associative arrays. No creation procedure is required, declaration is fine.\\n","public static Map map = new HashMap(){{\\n   put(\""foo\"", 5);\\n   put(\""bar\"", 10);\\n   put(\""baz\"", 15);\\n   put(\""foo\"", 6);\\n}};"
"Java","Associative_array/Creation","The goal is to create an associative array (also known as a dictionary, map, or hash).\\n\\nRelated tasks:\\n\\n\\n8th has 'maps' as built-in data types, and can use JSON to describe them:\\nAlternatively, they can be created in code:\\nBecause ActionScript does not have associative arrays in the normal sense, Object objects are used instead and keys are simply properties on those objects.\\nNote: The Object only supports String keys. To use an object as a key, try the flash.utils.Dictionary class.\\nAikido provides a native map for associative arrays. You can create them using a map literal and you can insert and remove items on the fly.\\nAime records are heterogenous associative arrays. No creation procedure is required, declaration is fine.\\n","map.get(\""foo\""); // => 6\\nmap.get(\""invalid\""); // => null"
"Java","Associative_array/Creation","The goal is to create an associative array (also known as a dictionary, map, or hash).\\n\\nRelated tasks:\\n\\n\\n8th has 'maps' as built-in data types, and can use JSON to describe them:\\nAlternatively, they can be created in code:\\nBecause ActionScript does not have associative arrays in the normal sense, Object objects are used instead and keys are simply properties on those objects.\\nNote: The Object only supports String keys. To use an object as a key, try the flash.utils.Dictionary class.\\nAikido provides a native map for associative arrays. You can create them using a map literal and you can insert and remove items on the fly.\\nAime records are heterogenous associative arrays. No creation procedure is required, declaration is fine.\\n","for (String key: map.keySet()) \\n   System.out.println(key);"
"Java","Associative_array/Creation","The goal is to create an associative array (also known as a dictionary, map, or hash).\\n\\nRelated tasks:\\n\\n\\n8th has 'maps' as built-in data types, and can use JSON to describe them:\\nAlternatively, they can be created in code:\\nBecause ActionScript does not have associative arrays in the normal sense, Object objects are used instead and keys are simply properties on those objects.\\nNote: The Object only supports String keys. To use an object as a key, try the flash.utils.Dictionary class.\\nAikido provides a native map for associative arrays. You can create them using a map literal and you can insert and remove items on the fly.\\nAime records are heterogenous associative arrays. No creation procedure is required, declaration is fine.\\n","for (int value: map.values())\\n   System.out.println(value);"
"Java","Associative_array/Creation","The goal is to create an associative array (also known as a dictionary, map, or hash).\\n\\nRelated tasks:\\n\\n\\n8th has 'maps' as built-in data types, and can use JSON to describe them:\\nAlternatively, they can be created in code:\\nBecause ActionScript does not have associative arrays in the normal sense, Object objects are used instead and keys are simply properties on those objects.\\nNote: The Object only supports String keys. To use an object as a key, try the flash.utils.Dictionary class.\\nAikido provides a native map for associative arrays. You can create them using a map literal and you can insert and remove items on the fly.\\nAime records are heterogenous associative arrays. No creation procedure is required, declaration is fine.\\n","for (Map.Entry entry: map.entrySet())\\n   System.out.println(entry.getKey() + \"" => \"" + entry.getValue());"
"Java","Associative_array/Iteration","Show how to iterate over the key-value pairs of an associative array, and print each pair out.\\nAlso show how to iterate just over the keys, or the values, if there is a separate way to do that in your language.\\n\\n\\n","Map map = new HashMap();\\nmap.put(\""hello\"", 1);\\nmap.put(\""world\"", 2);\\nmap.put(\""!\"", 3);\\n\\n// iterating over key-value pairs:\\nfor (Map.Entry e : map.entrySet()) {\\n    String key = e.getKey();\\n    Integer value = e.getValue();\\n    System.out.println(\""key = \"" + key + \"", value = \"" + value);\\n}\\n\\n// iterating over keys:\\nfor (String key : map.keySet()) {\\n    System.out.println(\""key = \"" + key);\\n}\\n\\n// iterating over values:\\nfor (Integer value : map.values()) {\\n    System.out.println(\""value = \"" + value);\\n}"
"Java","Associative_array/Iteration","Show how to iterate over the key-value pairs of an associative array, and print each pair out.\\nAlso show how to iterate just over the keys, or the values, if there is a separate way to do that in your language.\\n\\n\\n","Map map = new HashMap<>();\\nmap.put(\""hello\"", 1);\\nmap.put(\""world\"", 2);\\nmap.put(\""!\"", 3);\\n\\n// iterating over key-value pairs:\\nmap.forEach((k, v) -> {\\n    System.out.printf(\""key = %s, value = %s%n\"", k, v);\\n});\\n\\n// iterating over keys:\\nmap.keySet().forEach(k -> System.out.printf(\""key = %s%n\"", k));\\n\\n// iterating over values:\\nmap.values().forEach(v -> System.out.printf(\""value = %s%n\"", v));"
"Java","Atomic_updates","\\nDefine a data type consisting of a fixed number of 'buckets', each containing a nonnegative integer value, which supports operations to:\\nIn order to exercise this data type, create one set of buckets, and start three concurrent tasks:\\n\\nThe display task need not be explicit; use of e.g. a debugger or trace tool is acceptable provided it is simple to set up to provide the display.\\nThis task is intended as an exercise in atomic operations.   The sum of the bucket values must be preserved even if the two tasks attempt to perform transfers simultaneously, and a straightforward solution is to ensure that at any time, only one transfer is actually occurring — that the transfer operation is atomic.\\n\\n","import java.util.Arrays;\\nimport java.util.concurrent.ThreadLocalRandom;\\n\\npublic class AtomicUpdates {\\n\\n    private static final int NUM_BUCKETS = 10;\\n\\n    public static class Buckets {\\n        private final int[] data;\\n\\n        public Buckets(int[] data) {\\n            this.data = data.clone();\\n        }\\n\\n        public int getBucket(int index) {\\n            synchronized (data) {\\n                return data[index];\\n            }\\n        }\\n\\n        public int transfer(int srcIndex, int dstIndex, int amount) {\\n            if (amount < 0)\\n                throw new IllegalArgumentException(\""negative amount: \"" + amount);\\n            if (amount == 0)\\n                return 0;\\n\\n            synchronized (data) {\\n                if (data[srcIndex] - amount < 0)\\n                    amount = data[srcIndex];\\n                if (data[dstIndex] + amount < 0)\\n                    amount = Integer.MAX_VALUE - data[dstIndex];\\n                if (amount < 0)\\n                    throw new IllegalStateException();\\n                data[srcIndex] -= amount;\\n                data[dstIndex] += amount;\\n                return amount;\\n            }\\n        }\\n\\n        public int[] getBuckets() {\\n            synchronized (data) {\\n                return data.clone();\\n            }\\n        }\\n    }\\n\\n    private static long getTotal(int[] values) {\\n        long total = 0;\\n        for (int value : values) {\\n            total += value;\\n        }\\n        return total;\\n    }\\n\\n    public static void main(String[] args) {\\n        ThreadLocalRandom rnd = ThreadLocalRandom.current();\\n\\n        int[] values = new int[NUM_BUCKETS];\\n        for (int i = 0; i < values.length; i++)\\n            values[i] = rnd.nextInt() & Integer.MAX_VALUE;\\n        System.out.println(\""Initial Array: \"" + getTotal(values) + \"" \"" + Arrays.toString(values));\\n\\n        Buckets buckets = new Buckets(values);\\n        new Thread(() -> equalize(buckets), \""equalizer\"").start();\\n        new Thread(() -> transferRandomAmount(buckets), \""transferrer\"").start();\\n        new Thread(() -> print(buckets), \""printer\"").start();\\n    }\\n\\n    private static void transferRandomAmount(Buckets buckets) {\\n        ThreadLocalRandom rnd = ThreadLocalRandom.current();\\n        while (true) {\\n            int srcIndex = rnd.nextInt(NUM_BUCKETS);\\n            int dstIndex = rnd.nextInt(NUM_BUCKETS);\\n            int amount = rnd.nextInt() & Integer.MAX_VALUE;\\n            buckets.transfer(srcIndex, dstIndex, amount);\\n        }\\n    }\\n\\n    private static void equalize(Buckets buckets) {\\n        ThreadLocalRandom rnd = ThreadLocalRandom.current();\\n        while (true) {\\n            int srcIndex = rnd.nextInt(NUM_BUCKETS);\\n            int dstIndex = rnd.nextInt(NUM_BUCKETS);\\n            int amount = (buckets.getBucket(srcIndex) - buckets.getBucket(dstIndex)) / 2;\\n            if (amount >= 0)\\n                buckets.transfer(srcIndex, dstIndex, amount);\\n        }\\n    }\\n\\n    private static void print(Buckets buckets) {\\n        while (true) {\\n            long nextPrintTime = System.currentTimeMillis() + 3000;\\n            long now;\\n            while ((now = System.currentTimeMillis()) < nextPrintTime) {\\n                try {\\n                    Thread.sleep(nextPrintTime - now);\\n                } catch (InterruptedException e) {\\n                    return;\\n                }\\n            }\\n\\n            int[] bucketValues = buckets.getBuckets();\\n            System.out.println(\""Current values: \"" + getTotal(bucketValues) + \"" \"" + Arrays.toString(bucketValues));\\n        }\\n    }\\n}"
"Java","AudioAlarm","AudioAlarm is a program that asks the user to enter a certain number, representing a number of seconds. After the user enters the number, the program will ask the user to enter the name of an MP3 audio file (without the .mp3 file extension). The program will then display a (usually blank) page. After the time (indicated by the number) is up, a sound (indicated by the MP3 file) will go off. Useful for timers and alarm clocks. The app must be installed in its own folder, preferrably with a name like AudioAlarm. To install a sound on the app, just copy the MP3 to the app folder you set up. Then, when the app asks you for the filename, you just type in the name without an extension.\\nUses Run for maximum compatibility\\n","import com.sun.javafx.application.PlatformImpl;\\nimport java.io.File;\\nimport java.util.Scanner;\\nimport java.util.concurrent.TimeUnit;\\nimport java.util.concurrent.atomic.AtomicBoolean;\\nimport javafx.scene.media.Media;\\nimport javafx.scene.media.MediaPlayer;\\n\\npublic class AudioAlarm {\\n\\n    public static void main(String[] args) throws InterruptedException {\\n        Scanner input = new Scanner(System.in);\\n\\n        System.out.print(\""Enter a number of seconds: \"");\\n        int seconds = Integer.parseInt(input.nextLine());\\n\\n        System.out.print(\""Enter a filename (must end with .mp3 or .wav): \"");\\n        String audio = input.nextLine();\\n\\n        TimeUnit.SECONDS.sleep(seconds);\\n\\n        Media media = new Media(new File(audio).toURI().toString());\\n        AtomicBoolean stop = new AtomicBoolean();\\n        Runnable onEnd = () -> stop.set(true);\\n\\n        PlatformImpl.startup(() -> {}); // To initialize the MediaPlayer.\\n\\n        MediaPlayer player = new MediaPlayer(media);\\n        player.setOnEndOfMedia(onEnd);\\n        player.setOnError(onEnd);\\n        player.setOnHalted(onEnd);\\n        player.play();\\n\\n        while (!stop.get()) {\\n            Thread.sleep(100);\\n        }\\n        System.exit(0); // To stop the JavaFX thread.\\n    }\\n}"
"Java","Average_loop_length","Let f be a uniformly-randomly chosen mapping from the numbers 1..N to the numbers 1..N (note: not necessarily a permutation of 1..N; the mapping could produce a number in more than one way or not at all). At some point, the sequence 1, f(1), f(f(1))... will contain a repetition, a number that occurring for the second time in the sequence.\\n\\nWrite a program or a script that estimates, for each N, the average length until the first such repetition.\\nAlso calculate this expected length using an analytical formula, and optionally compare the simulated result with the theoretical one.\\n\\nThis problem comes from the end of Donald Knuth's Christmas tree lecture 2011.\\nExample of expected output:\\n\\n","import java.util.HashSet;\\nimport java.util.Random;\\nimport java.util.Set;\\n\\npublic class AverageLoopLength {\\n\\n    private static final int N = 100000;\\n\\n    //analytical(n) = sum_(i=1)^n (n!/(n-i)!/n**i)\\n    private static double analytical(int n) {\\n        double[] factorial = new double[n + 1];\\n        double[] powers = new double[n + 1];\\n        powers[0] = 1.0;\\n        factorial[0] = 1.0;\\n        for (int i = 1; i <= n; i++) {\\n            factorial[i] = factorial[i - 1] * i;\\n            powers[i] = powers[i - 1] * n;\\n        }\\n        double sum = 0;\\n        //memoized factorial and powers\\n        for (int i = 1; i <= n; i++) {\\n            sum += factorial[n] / factorial[n - i] / powers[i];\\n        }\\n        return sum;\\n    }\\n\\n    private static double average(int n) {\\n        Random rnd = new Random();\\n        double sum = 0.0;\\n        for (int a = 0; a < N; a++) {\\n            int[] random = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                random[i] = rnd.nextInt(n);\\n            }\\n            Set<Integer> seen = new HashSet<>(n);\\n            int current = 0;\\n            int length = 0;\\n            while (seen.add(current)) {\\n                length++;\\n                current = random[current];\\n            }\\n            sum += length;\\n        }\\n        return sum / N;\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(\"" N    average    analytical    (error)\"");\\n        System.out.println(\""===  =========  ============  =========\"");\\n        for (int i = 1; i <= 20; i++) {\\n            double avg = average(i);\\n            double ana = analytical(i);\\n            System.out.println(String.format(\""%3d  %9.4f  %12.4f  (%6.2f%%)\"", i, avg, ana, ((ana - avg) / ana * 100)));\\n        }\\n    }\\n}"
"Java","Averages/Arithmetic_mean","Write a program to find the mean (arithmetic average) of a numeric vector.\\nIn case of a zero-length input, since the mean of an empty set of numbers is ill-defined, the program may choose to behave in any way it deems appropriate, though if the programming language has an established convention for conveying math errors or undefined values, it's preferable to follow it.\\n","public static double avg(double... arr) {\\n    double sum = 0.0;\\n    for (double x : arr) {\\n        sum += x;\\n    }\\n    return sum / arr.length;\\n}"
"Java","Averages/Mean_angle","When calculating the average or mean of an angle one has to take into account how angles wrap around so that any angle in degrees plus any integer multiple of 360 degrees is a measure of the same angle.\\nIf one wanted an average direction of the wind over two readings where the first reading was of 350 degrees and the second was of 10 degrees then the average of the numbers is 180 degrees, whereas if you can note that 350 degrees is equivalent to -10 degrees and so you have two readings at 10 degrees either side of zero degrees leading to a more fitting mean angle of zero degrees.\\nTo calculate the mean angle of several angles:\\n\\n(Note that, since the mean is the sum divided by the number of numbers, and division by a positive real number does not affect the angle, you can also simply compute the sum for step 2.)\\nYou can alternatively use this formula:\\n","import java.util.Arrays;\\n\\npublic class AverageMeanAngle {\\n\\n    public static void main(String[] args) {\\n        printAverageAngle(350.0, 10.0);\\n        printAverageAngle(90.0, 180.0, 270.0, 360.0);\\n        printAverageAngle(10.0, 20.0, 30.0);\\n        printAverageAngle(370.0);\\n        printAverageAngle(180.0);\\n    }\\n\\n    private static void printAverageAngle(double... sample) {\\n        double meanAngle = getMeanAngle(sample);\\n        System.out.printf(\""The mean angle of %s is %s%n\"", Arrays.toString(sample), meanAngle);\\n    }\\n\\n    public static double getMeanAngle(double... anglesDeg) {\\n        double x = 0.0;\\n        double y = 0.0;\\n\\n        for (double angleD : anglesDeg) {\\n            double angleR = Math.toRadians(angleD);\\n            x += Math.cos(angleR);\\n            y += Math.sin(angleR);\\n        }\\n        double avgR = Math.atan2(y / anglesDeg.length, x / anglesDeg.length);\\n        return Math.toDegrees(avgR);\\n    }\\n}"
"Java","Averages/Mean_time_of_day","A particular activity of bats occurs at these times of the day:\\nUsing the idea that there are twenty-four hours in a day,\\nwhich is analogous to there being 360 degrees in a circle,\\nmap times of day to and from angles;\\nand using the ideas of Averages/Mean angle\\ncompute and show the average time of the nocturnal activity\\nto an accuracy of one second of time.\\n","public class MeanTimeOfDay {\\n    \\n    static double meanAngle(double[] angles) {\\n        int len = angles.length;\\n        double sinSum = 0.0;\\n        for (int i = 0; i < len; i++) {\\n            sinSum += Math.sin(angles[i] * Math.PI / 180.0);\\n        }\\n \\n        double cosSum = 0.0;\\n        for (int i = 0; i < len; i++) {\\n            cosSum += Math.cos(angles[i] * Math.PI / 180.0);\\n        }\\n\\n        return Math.atan2(sinSum / len, cosSum / len) * 180.0 / Math.PI;\\n    }\\n\\n    /* time string assumed to be in format \""hh:mm:ss\"" */\\n    static int timeToSecs(String t) {\\n        int hours = Integer.parseInt(t.substring(0, 2));\\n        int mins  = Integer.parseInt(t.substring(3, 5));\\n        int secs  = Integer.parseInt(t.substring(6, 8));\\n        return 3600 * hours + 60 * mins + secs;\\n    }\\n\\n    /* 1 second of time = 360/(24 * 3600) = 1/240th degree */\\n    static double timeToDegrees(String t) {\\n        return timeToSecs(t) / 240.0;\\n    }\\n\\n    static String degreesToTime(double d) {\\n        if (d < 0.0) d += 360.0;\\n        int secs  = (int)(d * 240.0);\\n        int hours = secs / 3600;\\n        int mins  = secs % 3600;\\n        secs = mins % 60;\\n        mins /= 60;\\n        return String.format(\""%2d:%2d:%2d\"", hours, mins, secs);\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] tm = {\""23:00:17\"", \""23:40:20\"", \""00:12:45\"", \""00:17:19\""};\\n        double[] angles = new double[4];\\n        for (int i = 0; i < 4; i++) angles[i] = timeToDegrees(tm[i]);        \\n        double mean = meanAngle(angles);\\n        System.out.println(\""Average time is : \"" + degreesToTime(mean));\\n    }\\n}"
"Java","Averages/Median","Write a program to find the   median   value of a vector of floating-point numbers.\\nThe program need not handle the case where the vector is empty, but must handle the case where there are an even number of elements.   In that case, return the average of the two middle values.\\nThere are several approaches to this.   One is to sort the elements, and then pick the element(s) in the middle.\\nSorting would take at least   O(n logn).   Another approach would be to build a priority queue from the elements, and then extract half of the elements to get to the middle element(s).   This would also take   O(n logn).   The best solution is to use the   selection algorithm   to find the median in   O(n)   time.\\nQuickselect_algorithm\\n","// Note: this function modifies the input list\\npublic static double median(List<Double> list) {\\n    Collections.sort(list);\\n    return (list.get(list.size() / 2) + list.get((list.size() - 1) / 2)) / 2;\\n}"
"Java","Averages/Median","Write a program to find the   median   value of a vector of floating-point numbers.\\nThe program need not handle the case where the vector is empty, but must handle the case where there are an even number of elements.   In that case, return the average of the two middle values.\\nThere are several approaches to this.   One is to sort the elements, and then pick the element(s) in the middle.\\nSorting would take at least   O(n logn).   Another approach would be to build a priority queue from the elements, and then extract half of the elements to get to the middle element(s).   This would also take   O(n logn).   The best solution is to use the   selection algorithm   to find the median in   O(n)   time.\\nQuickselect_algorithm\\n","public static double median2(List<Double> list) {\\n    PriorityQueue<Double> pq = new PriorityQueue<Double>(list);\\n    int n = list.size();\\n    for (int i = 0; i < (n - 1) / 2; i++)\\n        pq.poll(); // discard first half\\n    if (n % 2 != 0) // odd length\\n        return pq.poll();\\n    else\\n        return (pq.poll() + pq.poll()) / 2.0;\\n}"
"Java","Averages/Mode","Write a program to find the mode value of a collection.\\nThe case where the collection is empty may be ignored. Care must be taken to handle the case where the mode is non-unique.\\nIf it is not appropriate or possible to support a general collection, use a vector (array), if possible. If it is not appropriate or possible to support an unspecified value type, use integers.\\n","import java.util.*;\\n\\npublic class Mode {\\n    public static <T> List<T> mode(List coll) {\\n        Map seen = new HashMap();\\n        int max = 0;\\n        List<T> maxElems = new ArrayList<T>();\\n        for (T value : coll) {\\n            if (seen.containsKey(value))\\n                seen.put(value, seen.get(value) + 1);\\n            else\\n                seen.put(value, 1);\\n            if (seen.get(value) > max) {\\n                max = seen.get(value);\\n                maxElems.clear();\\n                maxElems.add(value);\\n            } else if (seen.get(value) == max) {\\n                maxElems.add(value);\\n            }\\n        }\\n        return maxElems;\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(mode(Arrays.asList(1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17))); // prints [6]\\n        System.out.println(mode(Arrays.asList(1, 1, 2, 4, 4))); // prints [1, 4]\\n    }\\n}"
"Java","Averages/Pythagorean_means","Compute all three of the Pythagorean means of the set of integers 1 through 10 (inclusive).\\nShow that \\n\\n\\n\\nA\\n(\\n\\nx\\n\\n1\\n\\n\\n,\\n…\\n,\\n\\nx\\n\\nn\\n\\n\\n)\\n≥\\nG\\n(\\n\\nx\\n\\n1\\n\\n\\n,\\n…\\n,\\n\\nx\\n\\nn\\n\\n\\n)\\n≥\\nH\\n(\\n\\nx\\n\\n1\\n\\n\\n,\\n…\\n,\\n\\nx\\n\\nn\\n\\n\\n)\\n\\n\\n{\\displaystyle A(x_{1},\\ldots ,x_{n})\\geq G(x_{1},\\ldots ,x_{n})\\geq H(x_{1},\\ldots ,x_{n})}\\n\\n for this set of positive integers.\\n\\n","import java.util.Arrays;\\nimport java.util.List;\\n\\npublic class PythagoreanMeans {\\n    public static double arithmeticMean(List<Double> numbers) {\\n        if (numbers.isEmpty()) return Double.NaN;\\n        double mean = 0.0;\\n        for (Double number : numbers) {\\n            mean += number;\\n        }\\n        return mean / numbers.size();\\n    }\\n\\n    public static double geometricMean(List<Double> numbers) {\\n        if (numbers.isEmpty()) return Double.NaN;\\n        double mean = 1.0;\\n        for (Double number : numbers) {\\n            mean *= number;\\n        }\\n        return Math.pow(mean, 1.0 / numbers.size());\\n    }\\n\\n    public static double harmonicMean(List<Double> numbers) {\\n        if (numbers.isEmpty() || numbers.contains(0.0)) return Double.NaN;\\n        double mean = 0.0;\\n        for (Double number : numbers) {\\n            mean += (1.0 / number);\\n        }\\n        return numbers.size() / mean;\\n    }\\n\\n    public static void main(String[] args) {\\n        Double[] array = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\\n        List<Double> list = Arrays.asList(array);\\n        double arithmetic = arithmeticMean(list);\\n        double geometric = geometricMean(list);\\n        double harmonic = harmonicMean(list);\\n        System.out.format(\""A = %f  G = %f  H = %f%n\"", arithmetic, geometric, harmonic);\\n        System.out.format(\""A >= G is %b, G >= H is %b%n\"", (arithmetic >= geometric), (geometric >= harmonic));\\n    }\\n}"
"Java","Averages/Pythagorean_means","Compute all three of the Pythagorean means of the set of integers 1 through 10 (inclusive).\\nShow that \\n\\n\\n\\nA\\n(\\n\\nx\\n\\n1\\n\\n\\n,\\n…\\n,\\n\\nx\\n\\nn\\n\\n\\n)\\n≥\\nG\\n(\\n\\nx\\n\\n1\\n\\n\\n,\\n…\\n,\\n\\nx\\n\\nn\\n\\n\\n)\\n≥\\nH\\n(\\n\\nx\\n\\n1\\n\\n\\n,\\n…\\n,\\n\\nx\\n\\nn\\n\\n\\n)\\n\\n\\n{\\displaystyle A(x_{1},\\ldots ,x_{n})\\geq G(x_{1},\\ldots ,x_{n})\\geq H(x_{1},\\ldots ,x_{n})}\\n\\n for this set of positive integers.\\n\\n","\\n   public static double arithmAverage(double array[]){\\n       if (array == null ||array.length == 0) {\\n         return 0.0;\\n      }\\n      else {\\n         return DoubleStream.of(array).average().getAsDouble();\\n      }\\n   }\\n\\n    public static double geomAverage(double array[]){\\n      if (array == null ||array.length == 0) {\\n         return 0.0;\\n      }\\n      else {\\n         double aver = DoubleStream.of(array).reduce(1, (x, y) -> x * y);\\n         return   Math.pow(aver, 1.0 / array.length);\\n      }\\n   }\\n\\n     public static double harmAverage(double array[]){\\n         if (array == null ||array.length == 0) {\\n         return 0.0;\\n      }\\n      else {\\n         double aver = DoubleStream.of(array)\\n                  // remove null values\\n                  .filter(n -> n > 0.0)\\n                  // generate 1/n array\\n                  .map( n-> 1.0/n)\\n                  // accumulating\\n                  .reduce(0, (x, y) -> x + y);\\n                  // just this reduce is not working- need to do in 2 steps\\n                 // .reduce(0, (x, y) -> 1.0/x + 1.0/y);\\n         return   array.length / aver ;\\n      }\\n   }\\n  "
"Java","Averages/Root_mean_square","Compute the   Root mean square   of the numbers 1..10.\\n\\nThe   root mean square   is also known by its initials RMS (or rms), and as the quadratic mean.\\nThe RMS is calculated as the mean of the squares of the numbers, square-rooted:\\n\\n\\n","public class RootMeanSquare {\\n\\n    public static double rootMeanSquare(double... nums) {\\n        double sum = 0.0;\\n        for (double num : nums)\\n            sum += num * num;\\n        return Math.sqrt(sum / nums.length);\\n    }\\n\\n    public static void main(String[] args) {\\n        double[] nums = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\\n        System.out.println(\""The RMS of the numbers from 1 to 10 is \"" + rootMeanSquare(nums));\\n    }\\n}"
"Java","Averages/Simple_moving_average","Computing the simple moving average of a series of numbers.\\nCreate a stateful function/class/instance that takes a period and returns a routine that takes a number as argument and returns a simple moving average of its arguments so far.\\nA simple moving average is a method for computing an average of a stream of numbers by only averaging the last   P   numbers from the stream,   where   P   is known as the period.\\nIt can be implemented by calling an initialing routine with   P   as its argument,   I(P),   which should then return a routine that when called with individual, successive members of a stream of numbers, computes the mean of (up to), the last   P   of them, lets call this   SMA().\\nThe word   stateful   in the task description refers to the need for   SMA()   to remember certain information between calls to it:\\n\\nStateful   also means that successive calls to   I(),   the initializer,   should return separate routines that do   not   share saved state so they could be used on two independent streams of data.\\nPseudo-code for an implementation of   SMA   is:\\n","import java.util.LinkedList;\\nimport java.util.Queue;\\n\\npublic class MovingAverage {\\n    private final Queue<Double> window = new LinkedList<Double>();\\n    private final int period;\\n    private double sum;\\n\\n    public MovingAverage(int period) {\\n        assert period > 0 : \""Period must be a positive integer\"";\\n        this.period = period;\\n    }\\n\\n    public void newNum(double num) {\\n        sum += num;\\n        window.add(num);\\n        if (window.size() > period) {\\n            sum -= window.remove();\\n        }\\n    }\\n\\n    public double getAvg() {\\n        if (window.isEmpty()) return 0.0; // technically the average is undefined\\n        return sum / window.size();\\n    }\\n\\n    public static void main(String[] args) {\\n        double[] testData = {1, 2, 3, 4, 5, 5, 4, 3, 2, 1};\\n        int[] windowSizes = {3, 5};\\n        for (int windSize : windowSizes) {\\n            MovingAverage ma = new MovingAverage(windSize);\\n            for (double x : testData) {\\n                ma.newNum(x);\\n                System.out.println(\""Next number = \"" + x + \"", SMA = \"" + ma.getAvg());\\n            }\\n            System.out.println();\\n        }\\n    }\\n}"
"Java","AVL_tree","\\nIn computer science, an AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; at no time do they differ by more than one because rebalancing is done ensure this is the case. Lookup, insertion, and deletion all take O(log n) time in both the average and worst cases, where n is the number of nodes in the tree prior to the operation. Insertions and deletions may require the tree to be rebalanced by one or more tree rotations.\\nAVL trees are often compared with red-black trees because they support the same set of operations and because red-black trees also take O(log n) time for the basic operations. Because AVL trees are more rigidly balanced, they are faster than red-black trees for lookup-intensive applications. Similar to red-black trees, AVL trees are height-balanced, but in general not weight-balanced nor μ-balanced; that is, sibling nodes can have hugely differing numbers of descendants.\\n\\nImplement an AVL tree in the language of choice, and provide at least basic operations.\\n\\nThis implementation uses the type system to enforce the height invariants, though not the BST invariants\\nSee AVL tree/C\\nSee AVL_tree/C_sharp.\\n","public class AVLtree {\\n\\n    private Node root;\\n\\n    private static class Node {\\n        private int key;\\n        private int balance;\\n        private int height;\\n        private Node left;\\n        private Node right;\\n        private Node parent;\\n\\n        Node(int key, Node parent) {\\n            this.key = key;\\n            this.parent = parent;\\n        }\\n    }\\n\\n    public boolean insert(int key) {\\n        if (root == null) {\\n            root = new Node(key, null);\\n            return true;\\n        }\\n\\n        Node n = root;\\n        while (true) {\\n            if (n.key == key)\\n                return false;\\n\\n            Node parent = n;\\n\\n            boolean goLeft = n.key > key;\\n            n = goLeft ? n.left : n.right;\\n\\n            if (n == null) {\\n                if (goLeft) {\\n                    parent.left = new Node(key, parent);\\n                } else {\\n                    parent.right = new Node(key, parent);\\n                }\\n                rebalance(parent);\\n                break;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private void delete(Node node) {\\n        if (node.left == null && node.right == null) {\\n            if (node.parent == null) {\\n                root = null;\\n            } else {\\n                Node parent = node.parent;\\n                if (parent.left == node) {\\n                    parent.left = null;\\n                } else {\\n                    parent.right = null;\\n                }\\n                rebalance(parent);\\n            }\\n            return;\\n        }\\n\\n        if (node.left != null) {\\n            Node child = node.left;\\n            while (child.right != null) child = child.right;\\n            node.key = child.key;\\n            delete(child);\\n        } else {\\n            Node child = node.right;\\n            while (child.left != null) child = child.left;\\n            node.key = child.key;\\n            delete(child);\\n        }\\n    }\\n\\n    public void delete(int delKey) {\\n        if (root == null)\\n            return;\\n\\n        Node child = root;\\n        while (child != null) {\\n            Node node = child;\\n            child = delKey >= node.key ? node.right : node.left;\\n            if (delKey == node.key) {\\n                delete(node);\\n                return;\\n            }\\n        }\\n    }\\n\\n    private void rebalance(Node n) {\\n        setBalance(n);\\n\\n        if (n.balance == -2) {\\n            if (height(n.left.left) >= height(n.left.right))\\n                n = rotateRight(n);\\n            else\\n                n = rotateLeftThenRight(n);\\n\\n        } else if (n.balance == 2) {\\n            if (height(n.right.right) >= height(n.right.left))\\n                n = rotateLeft(n);\\n            else\\n                n = rotateRightThenLeft(n);\\n        }\\n\\n        if (n.parent != null) {\\n            rebalance(n.parent);\\n        } else {\\n            root = n;\\n        }\\n    }\\n\\n    private Node rotateLeft(Node a) {\\n\\n        Node b = a.right;\\n        b.parent = a.parent;\\n\\n        a.right = b.left;\\n\\n        if (a.right != null)\\n            a.right.parent = a;\\n\\n        b.left = a;\\n        a.parent = b;\\n\\n        if (b.parent != null) {\\n            if (b.parent.right == a) {\\n                b.parent.right = b;\\n            } else {\\n                b.parent.left = b;\\n            }\\n        }\\n\\n        setBalance(a, b);\\n\\n        return b;\\n    }\\n\\n    private Node rotateRight(Node a) {\\n\\n        Node b = a.left;\\n        b.parent = a.parent;\\n\\n        a.left = b.right;\\n\\n        if (a.left != null)\\n            a.left.parent = a;\\n\\n        b.right = a;\\n        a.parent = b;\\n\\n        if (b.parent != null) {\\n            if (b.parent.right == a) {\\n                b.parent.right = b;\\n            } else {\\n                b.parent.left = b;\\n            }\\n        }\\n\\n        setBalance(a, b);\\n\\n        return b;\\n    }\\n\\n    private Node rotateLeftThenRight(Node n) {\\n        n.left = rotateLeft(n.left);\\n        return rotateRight(n);\\n    }\\n\\n    private Node rotateRightThenLeft(Node n) {\\n        n.right = rotateRight(n.right);\\n        return rotateLeft(n);\\n    }\\n\\n    private int height(Node n) {\\n        if (n == null)\\n            return -1;\\n        return n.height;\\n    }\\n\\n    private void setBalance(Node... nodes) {\\n        for (Node n : nodes) {\\n            reheight(n);\\n            n.balance = height(n.right) - height(n.left);\\n        }\\n    }\\n\\n    public void printBalance() {\\n        printBalance(root);\\n    }\\n\\n    private void printBalance(Node n) {\\n        if (n != null) {\\n            printBalance(n.left);\\n            System.out.printf(\""%s \"", n.balance);\\n            printBalance(n.right);\\n        }\\n    }\\n\\n    private void reheight(Node node) {\\n        if (node != null) {\\n            node.height = 1 + Math.max(height(node.left), height(node.right));\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        AVLtree tree = new AVLtree();\\n\\n        System.out.println(\""Inserting values 1 to 10\"");\\n        for (int i = 1; i < 10; i++)\\n            tree.insert(i);\\n\\n        System.out.print(\""Printing balance: \"");\\n        tree.printBalance();\\n    }\\n}"
"Java","Babbage_problem","Charles Babbage, looking ahead to the sorts of problems his Analytical Engine would be able to solve, gave this example:\\nHe thought the answer might be 99,736, whose square is 9,947,269,696; but he couldn't be certain.\\n\\nThe task is to find out if Babbage had the right answer — and to do so, as far as your language allows it, in code that Babbage himself would have been able to read and understand.\\nAs Babbage evidently solved the task with pencil and paper, a similar efficient solution is preferred.\\nFor these purposes, Charles Babbage may be taken to be an intelligent person, familiar with mathematics and with the idea of a computer; he has written the first drafts of simple computer programmes in tabular form. [Babbage Archive Series L].\\n\\nThe aim of the task is to write a program that is sufficiently clear and well-documented for such a person to be able to read it and be confident that it does indeed solve the specified problem.\\n\\nAn assembler program always seems a bit tricky for non system engineer because it deals directly with the operating system and with the hardware instructions. Here we have a 32-bit computer with 16 32-bit registers. The caller (the operating system to keep it simple) is calling you giving your location address stored in register-15 and has stored in register-14 his return address. To save each program context, register-13 points to a 18 word save area. Do not spend time in understanding the context saving and restoring in the prologue and epilogue part of the program. What you have to know, “360” architecture uses 32-bit signed binary arithmetic, so here the maximum integer value is 2^31-1 (2147483647). Therefore the solution must be less than 2147483647. The multiplication and the division use a pair of registers; coding “MR 4,2” means multiply register-5 by register-2 and place result in the (register-4,register-5) pair; the same way “DR 4,2” means divide the (register-4,register-5) pair by register-2 and place the quotient in register-5 and the reminder in register-4. We use in the below program this intermediate 64-bit integers to find a solution with a value up to 2^31-1 even when we have to compute the square of this value.\\n","public class Test {\\n\\n    public static void main(String[] args) {\\n\\n        // let n be zero\\n        int n = 0;\\n\\n        // repeat the following action\\n        do {\\n\\n            // increase n by 1\\n            n++;\\n\\n        // while the modulo of n times n is not equal to 269696\\n        } while (n * n % 1000_000 != 269696);\\n\\n        // show the result\\n        System.out.println(n);\\n    }\\n}"
"Java","Bacon_cipher","This task is to implement a program for encryption and decryption of plaintext using the simple alphabet of the Baconian cipher or some other kind of representation of this alphabet (make anything signify anything).\\nThe Baconian alphabet:\\n\\nTested with Agena 2.9.5 Win32\\n","import java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.Objects;\\n\\npublic class BaconCipher {\\n    private static final Map codes;\\n\\n    static {\\n        codes = new HashMap<>();\\n        codes.putAll(Map.of(\\n            'a', \""AAAAA\"", 'b', \""AAAAB\"", 'c', \""AAABA\"", 'd', \""AAABB\"", 'e', \""AABAA\"",\\n            'f', \""AABAB\"", 'g', \""AABBA\"", 'h', \""AABBB\"", 'i', \""ABAAA\"", 'j', \""ABAAB\""\\n        ));\\n        codes.putAll(Map.of(\\n            'k', \""ABABA\"", 'l', \""ABABB\"", 'm', \""ABBAA\"", 'n', \""ABBAB\"", 'o', \""ABBBA\"",\\n            'p', \""ABBBB\"", 'q', \""BAAAA\"", 'r', \""BAAAB\"", 's', \""BAABA\"", 't', \""BAABB\""\\n        ));\\n        codes.putAll(Map.of(\\n            'u', \""BABAA\"", 'v', \""BABAB\"", 'w', \""BABBA\"", 'x', \""BABBB\"", 'y', \""BBAAA\"",\\n            'z', \""BBAAB\"", ' ', \""BBBAA\"" // use ' ' to denote any non-letter\\n        ));\\n    }\\n\\n    private static String encode(String plainText, String message) {\\n        String pt = plainText.toLowerCase();\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : pt.toCharArray()) {\\n            if ('a' <= c && c <= 'z') sb.append(codes.get(c));\\n            else sb.append(codes.get(' '));\\n        }\\n        String et = sb.toString();\\n        String mg = message.toLowerCase();  // 'A's to be in lower case, 'B's in upper case\\n        sb.setLength(0);\\n        int count = 0;\\n        for (char c : mg.toCharArray()) {\\n            if ('a' <= c && c <= 'z') {\\n                if (et.charAt(count) == 'A') sb.append(c);\\n                else sb.append(((char) (c - 32))); // upper case equivalent\\n                count++;\\n                if (count == et.length()) break;\\n            } else sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n\\n    private static String decode(String message) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : message.toCharArray()) {\\n            if ('a' <= c && c <= 'z') sb.append('A');\\n            if ('A' <= c && c <= 'Z') sb.append('B');\\n        }\\n        String et = sb.toString();\\n        sb.setLength(0);\\n        for (int i = 0; i < et.length(); i += 5) {\\n            String quintet = et.substring(i, i + 5);\\n            Character key = codes.entrySet().stream().filter(a -> Objects.equals(a.getValue(), quintet)).findFirst().map(Map.Entry::getKey).orElse(null);\\n            sb.append(key);\\n        }\\n        return sb.toString();\\n    }\\n\\n    public static void main(String[] args) {\\n        String plainText = \""the quick brown fox jumps over the lazy dog\"";\\n        String message = \""bacon's cipher is a method of steganography created by francis bacon. \"" +\\n            \""this task is to implement a program for encryption and decryption of \"" +\\n            \""plaintext using the simple alphabet of the baconian cipher or some \"" +\\n            \""other kind of representation of this alphabet (make anything signify anything). \"" +\\n            \""the baconian alphabet may optionally be extended to encode all lower \"" +\\n            \""case characters individually and/or adding a few punctuation characters \"" +\\n            \""such as the space.\"";\\n        String cipherText = encode(plainText, message);\\n        System.out.printf(\""Cipher text ->\\n\\n%s\\n\"", cipherText);\\n        String decodedText = decode(cipherText);\\n        System.out.printf(\""\\nHidden text ->\\n\\n%s\\n\"", decodedText);\\n    }\\n}"
"Java","Balanced_ternary","Balanced ternary is a way of representing numbers. Unlike the prevailing binary representation, a balanced ternary integer is in base 3, and each digit can have the values 1, 0, or −1.\\n\\nDecimal 11 = 32 + 31 − 30, thus it can be written as \""++−\""\\nDecimal 6 = 32 − 31 + 0 × 30, thus it can be written as \""+−0\""\\n\\nImplement balanced ternary representation of integers with the following:\\n\\nTest case With balanced ternaries a from string \""+-0++0+\"", b from native integer -436, c \""+-++-\"":\\n\\nNote: The pages generalised floating point addition and generalised floating point multiplication have code implementing arbitrary precision floating point balanced ternary.\\n\\nSee also:\\nSpecifications (bt.ads):\\nImplementation (bt.adb):\\nTest task requirements (testbt.adb):\\nOutput:\\nOutput:\\nOutput\\noutput:\\n","\\n/*\\n * Test case \\n * With balanced ternaries a from string \""+-0++0+\"", b from native integer -436, c \""+-++-\"":\\n * Write out a, b and c in decimal notation;\\n * Calculate a × (b − c), write out the result in both ternary and decimal notations. \\n */\\npublic class BalancedTernary \\n{\\n	public static void main(String[] args)\\n	{\\n 		BTernary a=new BTernary(\""+-0++0+\"");\\n		BTernary b=new BTernary(-436);\\n		BTernary c=new BTernary(\""+-++-\"");\\n		\\n		System.out.println(\""a=\""+a.intValue());\\n		System.out.println(\""b=\""+b.intValue());\\n		System.out.println(\""c=\""+c.intValue());\\n		System.out.println();\\n		\\n		//result=a*(b-c)\\n		BTernary result=a.mul(b.sub(c));\\n		\\n		System.out.println(\""result= \""+result+\"" \""+result.intValue());\\n	}\\n	\\n	\\n	public static class BTernary\\n	{\\n		String value;\\n		public BTernary(String s)\\n		{\\n			int i=0;\\n			while(s.charAt(i)=='0')\\n				i++;\\n			this.value=s.substring(i);\\n		}\\n		public BTernary(int v)\\n		{\\n			this.value=\""\"";\\n			this.value=convertToBT(v);\\n		}\\n		\\n		private String convertToBT(int v)\\n		{\\n			if(v<0)\\n				return flip(convertToBT(-v));\\n			if(v==0)\\n				return \""\"";\\n			int rem=mod3(v);\\n			if(rem==0)\\n				return convertToBT(v/3)+\""0\"";\\n			if(rem==1)\\n				return convertToBT(v/3)+\""+\"";\\n			if(rem==2)\\n				return convertToBT((v+1)/3)+\""-\"";\\n			return \""You can't see me\"";\\n		}\\n		private String flip(String s)\\n		{\\n			String flip=\""\"";\\n			for(int i=0;i0)\\n				return v%3;\\n			v=v%3;\\n			return (v+3)%3;\\n		}\\n		\\n		public int intValue()\\n		{\\n			int sum=0;\\n			String s=this.value;\\n			for(int i=0;ib.length()?a:b;\\n			String shorter=a.length()>b.length()?b:a;\\n			\\n			while(shorter.length()that.intValue())\\n				return 1;\\n			else if(this.equals(that))\\n				return 0;\\n			 return -1;\\n		}\\n		\\n		public String toString()\\n		{\\n			return value;\\n		}\\n	}\\n}\\n"
"Java","Barnsley_fern","A Barnsley fern is a fractal named after British mathematician Michael Barnsley and can be created using an iterated function system (IFS).\\n\\nCreate this fractal fern, using the following transformations:\\nStarting position: x = 0, y = 0\\n\\nThis implementation requires the WinBGIm library. Iteration starts from (0,0) as required by the task however before plotting the point is translated and scaled as negative co-ordinates are not supported by the graphics window, scaling is necessary as otherwise the fern is tiny even for large iterations ( > 1000000).\\nThis code uses the opticl package for generating an image and saving it as a PNG file.\\nHint: After putting a TPaintBox on the main form align it to alClient. Client width / heigth of the main form should be no less than 640 x 480.\\n","import java.awt.*;\\nimport java.awt.image.BufferedImage;\\nimport javax.swing.*;\\n\\npublic class BarnsleyFern extends JPanel {\\n\\n    BufferedImage img;\\n\\n    public BarnsleyFern() {\\n        final int dim = 640;\\n        setPreferredSize(new Dimension(dim, dim));\\n        setBackground(Color.white);\\n        img = new BufferedImage(dim, dim, BufferedImage.TYPE_INT_ARGB);\\n        createFern(dim, dim);\\n    }\\n\\n    void createFern(int w, int h) {\\n        double x = 0;\\n        double y = 0;\\n\\n        for (int i = 0; i < 200_000; i++) {\\n            double tmpx, tmpy;\\n            double r = Math.random();\\n\\n            if (r <= 0.01) {\\n                tmpx = 0;\\n                tmpy = 0.16 * y;\\n            } else if (r <= 0.08) {\\n                tmpx = 0.2 * x - 0.26 * y;\\n                tmpy = 0.23 * x + 0.22 * y + 1.6;\\n            } else if (r <= 0.15) {\\n                tmpx = -0.15 * x + 0.28 * y;\\n                tmpy = 0.26 * x + 0.24 * y + 0.44;\\n            } else {\\n                tmpx = 0.85 * x + 0.04 * y;\\n                tmpy = -0.04 * x + 0.85 * y + 1.6;\\n            }\\n            x = tmpx;\\n            y = tmpy;\\n\\n            img.setRGB((int) Math.round(w / 2 + x * w / 11),\\n                    (int) Math.round(h - y * h / 11), 0xFF32CD32);\\n        }\\n    }\\n\\n    @Override\\n    public void paintComponent(Graphics gg) {\\n        super.paintComponent(gg);\\n        Graphics2D g = (Graphics2D) gg;\\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\\n                RenderingHints.VALUE_ANTIALIAS_ON);\\n\\n        g.drawImage(img, 0, 0, null);\\n    }\\n\\n    public static void main(String[] args) {\\n        SwingUtilities.invokeLater(() -> {\\n            JFrame f = new JFrame();\\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\\n            f.setTitle(\""Barnsley Fern\"");\\n            f.setResizable(false);\\n            f.add(new BarnsleyFern(), BorderLayout.CENTER);\\n            f.pack();\\n            f.setLocationRelativeTo(null);\\n            f.setVisible(true);\\n        });\\n    }\\n}"
"Java","Base64_encode_data","Convert an array of bytes or binary string to the base64-encoding of that string and output that value. Use the icon for Rosetta Code as the data to convert.\\n","import java.io.ByteArrayInputStream;\\nimport java.io.IOException;\\nimport java.io.InputStream;\\nimport java.net.URL;\\nimport java.net.URLConnection;\\nimport java.util.Arrays;\\n\\npublic class Base64 {\\n\\n    private static final char[] alpha = \""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"".toCharArray();\\n\\n    static String base64(InputStream is) throws IOException {\\n        StringBuilder sb = new StringBuilder();\\n        int blocks = 0;\\n\\n        while (true) {\\n            int c0 = is.read();\\n            if (c0 == -1)\\n                break;\\n            int c1 = is.read();\\n            int c2 = is.read();\\n\\n            int block = ((c0 & 0xFF) << 16) | ((Math.max(c1, 0) & 0xFF) << 8) | (Math.max(c2, 0) & 0xFF);\\n\\n            sb.append(alpha[block >> 18 & 63]);\\n            sb.append(alpha[block >> 12 & 63]);\\n            sb.append(c1 == -1 ? '=' : alpha[block >> 6 & 63]);\\n            sb.append(c2 == -1 ? '=' : alpha[block & 63]);\\n\\n            if (++blocks == 19) {\\n                blocks = 0;\\n                sb.append('\\n');\\n            }\\n        }\\n\\n        if (blocks > 0)\\n            sb.append('\\n');\\n\\n        return sb.toString();\\n    }\\n\\n    private static void assertBase64(String expected, byte[] bytes) throws IOException {\\n        String actual = base64(new ByteArrayInputStream(bytes));\\n        if (!actual.equals(expected)) {\\n            throw new IllegalStateException(String.format(\""Expected %s for %s, but got %s.\"",\\n                    expected, Arrays.toString(bytes), actual));\\n        }\\n    }\\n\\n    private static void testBase64() throws IOException {\\n        assertBase64(\""\"", new byte[]{});\\n        assertBase64(\""AA==\\n\"", new byte[]{0});\\n        assertBase64(\""AAA=\\n\"", new byte[]{0, 0});\\n        assertBase64(\""AAAA\\n\"", new byte[]{0, 0, 0});\\n        assertBase64(\""AAAAAA==\\n\"", new byte[]{0, 0, 0, 0});\\n        assertBase64(\""/w==\\n\"", new byte[]{-1});\\n        assertBase64(\""//8=\\n\"", new byte[]{-1, -1});\\n        assertBase64(\""////\\n\"", new byte[]{-1, -1, -1});\\n        assertBase64(\""/////w==\\n\"", new byte[]{-1, -1, -1, -1});\\n    }\\n\\n    public static void main(String[] args) throws IOException {\\n        testBase64();\\n\\n        URLConnection conn = new URL(\""http://rosettacode.org/favicon.ico\"").openConnection();\\n        conn.addRequestProperty(\""User-Agent\"", \""Mozilla\""); // To prevent an HTTP 403 error.\\n        try (InputStream is = conn.getInputStream()) {\\n            System.out.println(base64(is));\\n        }\\n    }\\n}"
"Java","Base64_encode_data","Convert an array of bytes or binary string to the base64-encoding of that string and output that value. Use the icon for Rosetta Code as the data to convert.\\n","import java.nio.file.*;\\nimport java.util.Base64;\\n\\npublic class Base64Task {\\n\\n    public static void main(String[] args) throws Exception {\\n        byte[] bytes = Files.readAllBytes(Paths.get(\""favicon.ico\""));\\n        String result = Base64.getEncoder().encodeToString(bytes);\\n        System.out.println(result);\\n    }\\n}"
"Java","Benford's_law","\\nBenford's law, also called the first-digit law, refers to the frequency distribution of digits in many (but not all) real-life sources of data.\\nIn this distribution, the number 1 occurs as the first digit about 30% of the time, while larger numbers occur in that position less frequently: 9 as the first digit less than 5% of the time. This distribution of first digits is the same as the widths of gridlines on a logarithmic scale.\\nBenford's law also concerns the expected distribution for digits beyond the first, which approach a uniform distribution.\\nThis result has been found to apply to a wide variety of data sets, including electricity bills, street addresses, stock prices, population numbers, death rates, lengths of rivers, physical and mathematical constants, and processes described by power laws (which are very common in nature). It tends to be most accurate when values are distributed across multiple orders of magnitude.\\nA set of numbers is said to satisfy Benford's law if the leading digit \\n\\n\\n\\nd\\n\\n\\n{\\displaystyle d}\\n\\n  (\\n\\n\\n\\nd\\n∈\\n{\\n1\\n,\\n…\\n,\\n9\\n}\\n\\n\\n{\\displaystyle d\\in \\{1,\\ldots ,9\\}}\\n\\n) occurs with probability\\nFor this task, write (a) routine(s) to calculate the distribution of first significant (non-zero) digits in a collection of numbers, then display the actual vs. expected distribution in the way most convenient for your language (table / graph / histogram / whatever).\\nUse the first 1000 numbers from the Fibonacci sequence as your data set. No need to show how the Fibonacci numbers are obtained.\\nYou can generate them or load them from a file; whichever is easiest.\\nDisplay your actual vs expected distribution.\\n\\nFor extra credit: Show the distribution for one other set of numbers from a page on Wikipedia. State which Wikipedia page it can be obtained from and what the set enumerates. Again, no need to display the actual list of numbers or the code to load them.\\n\\n\\n","import java.math.BigInteger;\\nimport java.util.Locale;\\n\\npublic class BenfordsLaw {\\n\\n    private static BigInteger[] generateFibonacci(int n) {\\n        BigInteger[] fib = new BigInteger[n];\\n        fib[0] = BigInteger.ONE;\\n        fib[1] = BigInteger.ONE;\\n        for (int i = 2; i < fib.length; i++) {\\n            fib[i] = fib[i - 2].add(fib[i - 1]);\\n        }\\n        return fib;\\n    }\\n\\n    public static void main(String[] args) {\\n        BigInteger[] numbers = generateFibonacci(1000);\\n\\n        int[] firstDigits = new int[10];\\n        for (BigInteger number : numbers) {\\n            firstDigits[Integer.valueOf(number.toString().substring(0, 1))]++;\\n        }\\n\\n        for (int i = 1; i < firstDigits.length; i++) {\\n            System.out.printf(Locale.ROOT, \""%d %10.6f %10.6f%n\"",\\n                    i, (double) firstDigits[i] / numbers.length, Math.log10(1.0 + 1.0 / i));\\n        }\\n    }\\n}"
"Java","Bernoulli_numbers","Bernoulli numbers are used in some series expansions of several functions   (trigonometric, hyperbolic, gamma, etc.),   and are extremely important in number theory and analysis.\\nNote that there are two definitions of Bernoulli numbers;   this task will be using the modern usage   (as per   The National Institute of Standards and Technology convention).\\nThe   nth   Bernoulli number is expressed as   Bn.\\n\\n\\nThe Akiyama–Tanigawa algorithm for the \""second Bernoulli numbers\"" as taken from wikipedia is as follows:\\n\\nUses Algol 68G's LONG LONG INT which has allows for large numbers of digits.\\n","import org.apache.commons.math3.fraction.BigFraction;\\n\\npublic class BernoulliNumbers {\\n\\n    public static void main(String[] args) {\\n        for (int n = 0; n <= 60; n++) {\\n            BigFraction b = bernouilli(n);\\n            if (!b.equals(BigFraction.ZERO))\\n                System.out.printf(\""B(%-2d) = %-1s%n\"", n , b);\\n        }\\n    }\\n\\n    static BigFraction bernouilli(int n) {\\n        BigFraction[] A = new BigFraction[n + 1];\\n        for (int m = 0; m <= n; m++) {\\n            A[m] = new BigFraction(1, (m + 1));\\n            for (int j = m; j >= 1; j--)\\n                A[j - 1] = (A[j - 1].subtract(A[j])).multiply(new BigFraction(j));\\n        }\\n        return A[0];\\n    }\\n}"
"Java","Bilinear_interpolation","Bilinear interpolation is linear interpolation in 2 dimensions, and is typically used for image scaling and for 2D finite element analysis.\\nOpen an image file, enlarge it by 60% using bilinear interpolation, then either display the result or save the result to a file.\\nSeems to have some artifacting in the output, but the image is at least recognizable.\\nThis uses the module from the Grayscale Image task.\\n(and also just using\\ndraw.BiLinear\\nfrom the golang.org/x/image/draw pacakge).\\nFile:J bilinear interpolant.jpg\\nLet n mean shape function, C mean constants, i mean interpolant, and the three digits meaning dimensionality, number of corners, and (in base 36) the number of nodes we construct various linear and quadratic interpolants in 1, 2, and 3 dimensions as\\n","import javax.imageio.ImageIO;\\nimport java.awt.image.BufferedImage;\\nimport java.io.File;\\nimport java.io.IOException;\\n\\npublic class BilinearInterpolation {\\n    /* gets the 'n'th byte of a 4-byte integer */\\n    private static int get(int self, int n) {\\n        return (self >> (n * 8)) & 0xFF;\\n    }\\n\\n    private static float lerp(float s, float e, float t) {\\n        return s + (e - s) * t;\\n    }\\n\\n    private static float blerp(final Float c00, float c10, float c01, float c11, float tx, float ty) {\\n        return lerp(lerp(c00, c10, tx), lerp(c01, c11, tx), ty);\\n    }\\n\\n    private static BufferedImage scale(BufferedImage self, float scaleX, float scaleY) {\\n        int newWidth = (int) (self.getWidth() * scaleX);\\n        int newHeight = (int) (self.getHeight() * scaleY);\\n        BufferedImage newImage = new BufferedImage(newWidth, newHeight, self.getType());\\n        for (int x = 0; x < newWidth; ++x) {\\n            for (int y = 0; y < newHeight; ++y) {\\n                float gx = ((float) x) / newWidth * (self.getWidth() - 1);\\n                float gy = ((float) y) / newHeight * (self.getHeight() - 1);\\n                int gxi = (int) gx;\\n                int gyi = (int) gy;\\n                int rgb = 0;\\n                int c00 = self.getRGB(gxi, gyi);\\n                int c10 = self.getRGB(gxi + 1, gyi);\\n                int c01 = self.getRGB(gxi, gyi + 1);\\n                int c11 = self.getRGB(gxi + 1, gyi + 1);\\n                for (int i = 0; i <= 2; ++i) {\\n                    float b00 = get(c00, i);\\n                    float b10 = get(c10, i);\\n                    float b01 = get(c01, i);\\n                    float b11 = get(c11, i);\\n                    int ble = ((int) blerp(b00, b10, b01, b11, gx - gxi, gy - gyi)) << (8 * i);\\n                    rgb = rgb | ble;\\n                }\\n                newImage.setRGB(x, y, rgb);\\n            }\\n        }\\n        return newImage;\\n    }\\n\\n    public static void main(String[] args) throws IOException {\\n        File lenna = new File(\""Lenna100.jpg\"");\\n        BufferedImage image = ImageIO.read(lenna);\\n        BufferedImage image2 = scale(image, 1.6f, 1.6f);\\n        File lenna2 = new File(\""Lenna100_larger.jpg\"");\\n        ImageIO.write(image2, \""jpg\"", lenna2);\\n    }\\n}"
"Java","Binary_digits","Create and display the sequence of binary digits for a given   non-negative integer.\\nThe results can be achieved using built-in radix functions within the language   (if these are available),   or alternatively a user defined function can be used.\\nThe output produced should consist just of the binary digits of each number followed by a   newline.\\nThere should be no other whitespace, radix or sign markers in the produced output, and leading zeros should not appear in the results.\\n\\n","public class Main {\\n    public static void main(String[] args) {\\n        System.out.println(Integer.toBinaryString(5));\\n        System.out.println(Integer.toBinaryString(50));\\n        System.out.println(Integer.toBinaryString(9000));\\n    }\\n}"
"Java","Binary_search","A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a \""divide and conquer\"" algorithm.\\nAs an analogy, consider the children's game \""guess a number.\"" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.\\nAs the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.\\n\\nGiven the starting point of a range, the ending point of a range, and the \""secret value\"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.\\nThere are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.\\nAll of the following code examples use an \""inclusive\"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using \""exclusive\"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):\\nThe algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the \""insertion point\"" for it (the index that the value would have if it were inserted into the array).\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nMake sure it does not have overflow bugs.\\nThe line in the pseudo-code above to calculate the mean of two integers:\\ncould produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.\\nOne way to fix it is to manually add half the range to the low number:\\nEven though this is mathematically equivalent to the above, it is not susceptible to overflow.\\nAnother way for signed integers, possibly faster, is the following:\\nwhere  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.\\n\\n\\n\\n","public class BinarySearchIterative {\\n\\n    public static int binarySearch(int[] nums, int check) {\\n        int hi = nums.length - 1;\\n        int lo = 0;\\n        while (hi >= lo) {\\n            int guess = (lo + hi) >>> 1;  // from OpenJDK\\n            if (nums[guess] > check) {\\n                hi = guess - 1;\\n            } else if (nums[guess] < check) {\\n                lo = guess + 1;\\n            } else {\\n                return guess;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] haystack = {1, 5, 6, 7, 8, 11};\\n        int needle = 5;\\n        int index = binarySearch(haystack, needle);\\n        if (index == -1) {\\n            System.out.println(needle + \"" is not in the array\"");\\n        } else {\\n            System.out.println(needle + \"" is at index \"" + index);\\n        }\\n    }\\n}"
"Java","Binary_search","A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a \""divide and conquer\"" algorithm.\\nAs an analogy, consider the children's game \""guess a number.\"" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.\\nAs the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.\\n\\nGiven the starting point of a range, the ending point of a range, and the \""secret value\"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.\\nThere are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.\\nAll of the following code examples use an \""inclusive\"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using \""exclusive\"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):\\nThe algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the \""insertion point\"" for it (the index that the value would have if it were inserted into the array).\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nMake sure it does not have overflow bugs.\\nThe line in the pseudo-code above to calculate the mean of two integers:\\ncould produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.\\nOne way to fix it is to manually add half the range to the low number:\\nEven though this is mathematically equivalent to the above, it is not susceptible to overflow.\\nAnother way for signed integers, possibly faster, is the following:\\nwhere  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.\\n\\n\\n\\n","public class BinarySearchRecursive {\\n\\n    public static int binarySearch(int[] haystack, int needle, int lo, int hi) {\\n        if (hi < lo) {\\n            return -1;\\n        }\\n        int guess = (hi + lo) / 2;\\n        if (haystack[guess] > needle) {\\n            return binarySearch(haystack, needle, lo, guess - 1);\\n        } else if (haystack[guess] < needle) {\\n            return binarySearch(haystack, needle, guess + 1, hi);\\n        }\\n        return guess;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] haystack = {1, 5, 6, 7, 8, 11};\\n        int needle = 5;\\n\\n        int index = binarySearch(haystack, needle, 0, haystack.length);\\n\\n        if (index == -1) {\\n            System.out.println(needle + \"" is not in the array\"");\\n        } else {\\n            System.out.println(needle + \"" is at index \"" + index);\\n        }\\n    }\\n}"
"Java","Binary_search","A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a \""divide and conquer\"" algorithm.\\nAs an analogy, consider the children's game \""guess a number.\"" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.\\nAs the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.\\n\\nGiven the starting point of a range, the ending point of a range, and the \""secret value\"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.\\nThere are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.\\nAll of the following code examples use an \""inclusive\"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using \""exclusive\"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):\\nThe algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the \""insertion point\"" for it (the index that the value would have if it were inserted into the array).\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nMake sure it does not have overflow bugs.\\nThe line in the pseudo-code above to calculate the mean of two integers:\\ncould produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.\\nOne way to fix it is to manually add half the range to the low number:\\nEven though this is mathematically equivalent to the above, it is not susceptible to overflow.\\nAnother way for signed integers, possibly faster, is the following:\\nwhere  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.\\n\\n\\n\\n","import java.util.Arrays;\\n\\nint index = Arrays.binarySearch(array, thing);\\nint index = Arrays.binarySearch(array, startIndex, endIndex, thing);\\n\\n// for objects, also optionally accepts an additional comparator argument:\\nint index = Arrays.binarySearch(array, thing, comparator);\\nint index = Arrays.binarySearch(array, startIndex, endIndex, thing, comparator);"
"Java","Binary_search","A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a \""divide and conquer\"" algorithm.\\nAs an analogy, consider the children's game \""guess a number.\"" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.\\nAs the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.\\n\\nGiven the starting point of a range, the ending point of a range, and the \""secret value\"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.\\nThere are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.\\nAll of the following code examples use an \""inclusive\"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using \""exclusive\"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):\\nThe algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the \""insertion point\"" for it (the index that the value would have if it were inserted into the array).\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nMake sure it does not have overflow bugs.\\nThe line in the pseudo-code above to calculate the mean of two integers:\\ncould produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.\\nOne way to fix it is to manually add half the range to the low number:\\nEven though this is mathematically equivalent to the above, it is not susceptible to overflow.\\nAnother way for signed integers, possibly faster, is the following:\\nwhere  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.\\n\\n\\n\\n","import java.util.Collections;\\n\\nint index = Collections.binarySearch(list, thing);\\nint index = Collections.binarySearch(list, thing, comparator);"
"Java","Binary_strings","Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks.\\nThis task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them. If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language.\\nIn particular the functions you need to create are:\\n\\nPossible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.\\n\\nAda has native support for single dimensioned arrays, which provide all specified operations. String is a case of array. The array of bytes is predefined in Ada in the package System.Storage_Elements (LRM 13.7.1). Storage_Element is substitute for byte.\\nStorage_Array is \""binary string\"" used for memory representation. For stream-oriented I/O communication Ada provides alternative \""binary string\"" called Stream_Element_Array (LRM 13.13.1). When dealing with octets of bits, programmers are encouraged to provide a data type of their own to ensure that the byte is exactly 8 bits length. For example:\\nAlternatively:\\nNote that all of these types will have all operations described above.\\nOutput:\\nOutput:\\nString creation (garbage collection will handle its destruction)\\nusing the string as an atom and casting a character list to a string\\nString assignment\\ncomparing two string\\ncopy a string\\nstring replacement isn't covered by the ansi standard probably best to use (replace-all) or cl-ppcre\\n\\njoining strings works in the same way as appending bytes\\nBlackBox Component Builder\\nExecute: ^Q NpctBinaryString.Do\\nOutput:\\nDéjà Vu has a blob type, which is much like Python 3's bytearray. They are used for dealing with binary data in the standard library, and works basically like a list, except it can only have integer numbers from 0 to 255 as elements, pushing and popping is not supported, and can be resized to any size in a single step.\\n(Since the task is not a specific program, the code here consists of example REPL sessions, not a whole program.)\\nIn E, binary data is represented as ELists (implemented as arrays or ropes) of integers; a String is strictly a character string. ELists come in Flex (mutable) and Const (immutable) varieties.\\nTo work with binary strings we must first have a byte type; this is a place where E shows its Java roots (to be fixed).\\nAs E is a memory-safe garbage-collected language there is no explicit destruction. It is good practice to work with immutable ConstLists when reasonable, however; especially when passing strings around.\\nNote: Elixir data types are immutable.\\n","import java.io.ByteArrayOutputStream;\\nimport java.nio.charset.StandardCharsets;\\nimport java.util.Arrays;\\n\\npublic class MutableByteString {\\n\\n    private byte[] bytes;\\n    private int length;\\n\\n    public MutableByteString(byte... bytes) {\\n        setInternal(bytes);\\n    }\\n\\n    public int length() {\\n        return length;\\n    }\\n\\n    public boolean isEmpty() {\\n        return length == 0;\\n    }\\n\\n    public byte get(int index) {\\n        return bytes[check(index)];\\n    }\\n\\n    public void set(byte[] bytes) {\\n        setInternal(bytes);\\n    }\\n\\n    public void set(int index, byte b) {\\n        bytes[check(index)] = b;\\n    }\\n\\n    public void append(byte b) {\\n        if (length >= bytes.length) {\\n            int len = 2 * bytes.length;\\n            if (len < 0)\\n                len = Integer.MAX_VALUE;\\n            bytes = Arrays.copyOf(bytes, len);\\n        }\\n        bytes[length] = b;\\n        length++;\\n    }\\n\\n    public MutableByteString substring(int from, int to) {\\n        return new MutableByteString(Arrays.copyOfRange(bytes, from, to));\\n    }\\n\\n    public void replace(byte[] from, byte[] to) {\\n        ByteArrayOutputStream copy = new ByteArrayOutputStream();\\n        if (from.length == 0) {\\n            for (byte b : bytes) {\\n                copy.write(to, 0, to.length);\\n                copy.write(b);\\n            }\\n            copy.write(to, 0, to.length);\\n        } else {\\n            for (int i = 0; i < length; i++) {\\n                if (regionEquals(i, from)) {\\n                    copy.write(to, 0, to.length);\\n                    i += from.length - 1;\\n                } else {\\n                    copy.write(bytes[i]);\\n                }\\n            }\\n        }\\n        set(copy.toByteArray());\\n    }\\n\\n    public boolean regionEquals(int offset, MutableByteString other, int otherOffset, int len) {\\n        if (Math.max(offset, otherOffset) + len < 0)\\n            return false;\\n        if (offset + len > length || otherOffset + len > other.length())\\n            return false;\\n        for (int i = 0; i < len; i++) {\\n            if (bytes[offset + i] != other.get(otherOffset + i))\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    public String toHexString() {\\n        char[] hex = new char[2 * length];\\n        for (int i = 0; i < length; i++) {\\n            hex[2 * i] = \""0123456789abcdef\"".charAt(bytes[i] >> 4 & 0x0F);\\n            hex[2 * i + 1] = \""0123456789abcdef\"".charAt(bytes[i] & 0x0F);\\n        }\\n        return new String(hex);\\n    }\\n\\n    public String toStringUtf8() {\\n        return new String(bytes, 0, length, StandardCharsets.UTF_8);\\n    }\\n\\n    private void setInternal(byte[] bytes) {\\n        this.bytes = bytes.clone();\\n        this.length = bytes.length;\\n    }\\n\\n    private boolean regionEquals(int offset, byte[] other) {\\n        int len = other.length;\\n        if (offset < 0 || offset + len < 0)\\n            return false;\\n        if (offset + len > length)\\n            return false;\\n        for (int i = 0; i < len; i++) {\\n            if (bytes[offset + i] != other[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    private int check(int index) {\\n        if (index < 0 || index >= length)\\n            throw new IndexOutOfBoundsException(String.valueOf(index));\\n        return index;\\n    }\\n}"
"Java","Binary_strings","Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks.\\nThis task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them. If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language.\\nIn particular the functions you need to create are:\\n\\nPossible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.\\n\\nAda has native support for single dimensioned arrays, which provide all specified operations. String is a case of array. The array of bytes is predefined in Ada in the package System.Storage_Elements (LRM 13.7.1). Storage_Element is substitute for byte.\\nStorage_Array is \""binary string\"" used for memory representation. For stream-oriented I/O communication Ada provides alternative \""binary string\"" called Stream_Element_Array (LRM 13.13.1). When dealing with octets of bits, programmers are encouraged to provide a data type of their own to ensure that the byte is exactly 8 bits length. For example:\\nAlternatively:\\nNote that all of these types will have all operations described above.\\nOutput:\\nOutput:\\nString creation (garbage collection will handle its destruction)\\nusing the string as an atom and casting a character list to a string\\nString assignment\\ncomparing two string\\ncopy a string\\nstring replacement isn't covered by the ansi standard probably best to use (replace-all) or cl-ppcre\\n\\njoining strings works in the same way as appending bytes\\nBlackBox Component Builder\\nExecute: ^Q NpctBinaryString.Do\\nOutput:\\nDéjà Vu has a blob type, which is much like Python 3's bytearray. They are used for dealing with binary data in the standard library, and works basically like a list, except it can only have integer numbers from 0 to 255 as elements, pushing and popping is not supported, and can be resized to any size in a single step.\\n(Since the task is not a specific program, the code here consists of example REPL sessions, not a whole program.)\\nIn E, binary data is represented as ELists (implemented as arrays or ropes) of integers; a String is strictly a character string. ELists come in Flex (mutable) and Const (immutable) varieties.\\nTo work with binary strings we must first have a byte type; this is a place where E shows its Java roots (to be fixed).\\nAs E is a memory-safe garbage-collected language there is no explicit destruction. It is good practice to work with immutable ConstLists when reasonable, however; especially when passing strings around.\\nNote: Elixir data types are immutable.\\n","import static org.hamcrest.CoreMatchers.is;\\n\\nimport java.nio.charset.StandardCharsets;\\nimport org.junit.Assert;\\nimport org.junit.Test;\\n\\npublic class MutableByteStringTest {\\n\\n    @Test\\n    public void testReplaceEmpty() {\\n        MutableByteString str = new MutableByteString(\""hello\"".getBytes(StandardCharsets.UTF_8));\\n        str.replace(new byte[]{}, new byte[]{'-'});\\n\\n        Assert.assertThat(str.toStringUtf8(), is(\""-h-e-l-l-o-\""));\\n    }\\n\\n    @Test\\n    public void testReplaceMultiple() {\\n        MutableByteString str = new MutableByteString(\""hello\"".getBytes(StandardCharsets.UTF_8));\\n        str.replace(new byte[]{'l'}, new byte[]{'1', '2', '3'});\\n\\n        Assert.assertThat(str.toStringUtf8(), is(\""he123123o\""));\\n    }\\n\\n    @Test\\n    public void testToHexString() {\\n        MutableByteString str = new MutableByteString(\""hello\"".getBytes(StandardCharsets.UTF_8));\\n\\n        Assert.assertThat(str.toHexString(), is(\""68656c6c6f\""));\\n    }\\n\\n    @Test\\n    public void testAppend() {\\n        MutableByteString str = new MutableByteString(\""hello\"".getBytes(StandardCharsets.UTF_8));\\n        str.append((byte) ',');\\n        str.append((byte) ' ');\\n        str.append((byte) 'w');\\n        str.append((byte) 'o');\\n        str.append((byte) 'r');\\n        str.append((byte) 'l');\\n        str.append((byte) 'd');\\n\\n        Assert.assertThat(str.toStringUtf8(), is(\""hello, world\""));\\n    }\\n    @Test\\n    public void testSubstring() {\\n        MutableByteString str = new MutableByteString(\""hello, world\"".getBytes(StandardCharsets.UTF_8));\\n\\n        Assert.assertThat(str.substring(0, 5).toStringUtf8(), is(\""hello\""));\\n        Assert.assertThat(str.substring(7, 12).toStringUtf8(), is(\""world\""));\\n    }\\n\\n    @Test\\n    public void testRegionEquals() {\\n        MutableByteString str = new MutableByteString(\""hello\"".getBytes(StandardCharsets.UTF_8));\\n\\n        Assert.assertThat(str.regionEquals(0, new MutableByteString(new byte[]{'h'}), 0, 1), is(true));\\n        Assert.assertThat(str.regionEquals(0, new MutableByteString(new byte[]{'h'}), 0, 2), is(false));\\n    }\\n}"
"Java","Birthday_problem","This page uses content from Wikipedia.\\nThe current wikipedia article is at Birthday Problem.\\nThe original RosettaCode article was extracted from the wikipedia article № 296054030 of 21:44, 12 June 2009 .\\nThe list of authors can be seen in the page history.\\nAs with Rosetta Code,\\nthe pre 5 June 2009 text of Wikipedia is available under the GNU FDL.\\n(See links for details on variance)\\n\\nIn probability theory, the birthday problem, or birthday paradox This is not a paradox in the sense of leading to a logical contradiction, but is called a paradox because the mathematical truth contradicts naïve intuition: most people estimate that the chance is much lower than 50%. pertains to the probability that in a set of randomly chosen people some pair of them will have the same birthday. In a group of at least 23 randomly chosen people, there is more than 50% probability that some pair of them will both have been born on the same day. For 57 or more people, the probability is more than 99%, and it reaches 100% when the number of people reaches 366 (by the pigeon hole principle, ignoring leap years). The mathematics behind this problem leads to a well-known cryptographic attack called the birthday attack.\\n\\nUsing simulation, estimate the number of independent people required in a groups before we can expect a better than even chance that at least 2 independent people in a group share a common birthday. Furthermore: Simulate and thus estimate when we can expect a better than even chance that at least 3, 4 & 5 independent people of the group share a common birthday. For simplicity assume that all of the people are alive...\\n\\n\\n\\nThis solution assumes a 4-year cycle, with three 365-day years and one leap year.\\n","import static java.util.Arrays.stream;\\nimport java.util.Random;\\n\\npublic class Test {\\n\\n    static double equalBirthdays(int nSharers, int groupSize, int nRepetitions) {\\n        Random rand = new Random(1);\\n\\n        int eq = 0;\\n\\n        for (int i = 0; i < nRepetitions; i++) {\\n            int[] group = new int[365];\\n            for (int j = 0; j < groupSize; j++)\\n                group[rand.nextInt(group.length)]++;\\n            eq += stream(group).anyMatch(c -> c >= nSharers) ? 1 : 0;\\n        }\\n\\n        return (eq * 100.0) / nRepetitions;\\n    }\\n\\n    public static void main(String[] a) {\\n\\n        int groupEst = 2;\\n\\n        for (int sharers = 2; sharers < 6; sharers++) {\\n            // Coarse.\\n            int groupSize = groupEst + 1;\\n            while (equalBirthdays(sharers, groupSize, 100) < 50.0)\\n                groupSize++;\\n\\n            // Finer.\\n            int inf = (int) (groupSize - (groupSize - groupEst) / 4.0);\\n            for (int gs = inf; gs < groupSize + 999; gs++) {\\n                double eq = equalBirthdays(sharers, groupSize, 250);\\n                if (eq > 50.0) {\\n                    groupSize = gs;\\n                    break;\\n                }\\n            }\\n\\n            // Finest.\\n            for (int gs = groupSize - 1; gs < groupSize + 999; gs++) {\\n                double eq = equalBirthdays(sharers, gs, 50_000);\\n                if (eq > 50.0) {\\n                    groupEst = gs;\\n                    System.out.printf(\""%d independent people in a group of \""\\n                            + \""%s share a common birthday. (%5.1f)%n\"",\\n                            sharers, gs, eq);\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n}"
"Java","Bitcoin/address_validation","\\nWrite a program that takes a bitcoin address as argument,\\nand checks whether or not this address is valid.\\nA bitcoin address uses a base58 encoding, which uses an alphabet of the characters 0 .. 9, A ..Z, a .. z, but without the four characters:\\n\\nWith this encoding, a bitcoin address encodes 25 bytes:\\n\\nTo check the bitcoin address, you must read the first twenty-one bytes, compute the checksum, and check that it corresponds to the last four bytes.\\nThe program can either return a boolean value or throw an exception when not valid.\\nYou can use a digest library for SHA-256.\\n\\n\\n","import java.math.BigInteger;\\nimport java.security.MessageDigest;\\nimport java.security.NoSuchAlgorithmException;\\nimport java.util.Arrays;\\n\\npublic class BitcoinAddressValidator {\\n\\n    private static final String ALPHABET = \""123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"";\\n\\n    public static boolean validateBitcoinAddress(String addr) {\\n        if (addr.length() < 26 || addr.length() > 35)\\n            return false;\\n        byte[] decoded = decodeBase58To25Bytes(addr);\\n        if (decoded == null)\\n            return false;\\n\\n        byte[] hash1 = sha256(Arrays.copyOfRange(decoded, 0, 21));\\n        byte[] hash2 = sha256(hash1);\\n\\n        return Arrays.equals(Arrays.copyOfRange(hash2, 0, 4), Arrays.copyOfRange(decoded, 21, 25));\\n    }\\n\\n    private static byte[] decodeBase58To25Bytes(String input) {\\n        BigInteger num = BigInteger.ZERO;\\n        for (char t : input.toCharArray()) {\\n            int p = ALPHABET.indexOf(t);\\n            if (p == -1)\\n                return null;\\n            num = num.multiply(BigInteger.valueOf(58)).add(BigInteger.valueOf(p));\\n        }\\n\\n        byte[] result = new byte[25];\\n        byte[] numBytes = num.toByteArray();\\n        System.arraycopy(numBytes, 0, result, result.length - numBytes.length, numBytes.length);\\n        return result;\\n    }\\n\\n    private static byte[] sha256(byte[] data) {\\n        try {\\n            MessageDigest md = MessageDigest.getInstance(\""SHA-256\"");\\n            md.update(data);\\n            return md.digest();\\n        } catch (NoSuchAlgorithmException e) {\\n            throw new IllegalStateException(e);\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        assertBitcoin(\""1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\"", true);\\n        assertBitcoin(\""1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62j\"", false);\\n        assertBitcoin(\""1Q1pE5vPGEEMqRcVRMbtBK842Y6Pzo6nK9\"", true);\\n        assertBitcoin(\""1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62X\"", false);\\n        assertBitcoin(\""1ANNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\"", false);\\n        assertBitcoin(\""1A Na15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\"", false);\\n        assertBitcoin(\""BZbvjr\"", false);\\n        assertBitcoin(\""i55j\"", false);\\n        assertBitcoin(\""1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62!\"", false);\\n        assertBitcoin(\""1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62iz\"", false);\\n        assertBitcoin(\""1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62izz\"", false);\\n        assertBitcoin(\""1Q1pE5vPGEEMqRcVRMbtBK842Y6Pzo6nJ9\"", false);\\n        assertBitcoin(\""1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62I\"", false);\\n    }\\n\\n    private static void assertBitcoin(String address, boolean expected) {\\n        boolean actual = validateBitcoinAddress(address);\\n        if (actual != expected)\\n            throw new AssertionError(String.format(\""Expected %s for %s, but got %s.\"", expected, address, actual));\\n    }\\n}"
"Java","Bitmap","Show a basic storage type to handle a simple RGB raster graphics image,\\nand some primitive associated functions.\\nIf possible provide a function to allocate an uninitialised image,\\ngiven its width and height, and provide 3 additional functions:\\n(If there are specificities about the storage or the allocation, explain those.)\\nThese functions are used as a base for the articles in the category raster graphics operations, \\nand a basic output function to check the results\\nis available in the article write ppm file.\\nActionScript 3 has a BitmapData class (in the flash.display package) which can be used for storage and handling of bitmap images.\\nTo display these images, the Bitmap class can be used.\\nThe package interface:\\nThe implementation of:\\nThis can be used like:\\nNote: short and shorten need to be tuned (added or removed)\\nto match the underlying graphic hardware colour depth.\\n","import java.awt.Color;\\nimport java.awt.Graphics;\\nimport java.awt.Image;\\nimport java.awt.image.BufferedImage;\\n\\npublic class BasicBitmapStorage {\\n\\n    private final BufferedImage image;\\n\\n    public BasicBitmapStorage(int width, int height) {\\n        image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\\n    }\\n\\n    public void fill(Color c) {\\n        Graphics g = image.getGraphics();\\n        g.setColor(c);\\n        g.fillRect(0, 0, image.getWidth(), image.getHeight());\\n    }\\n\\n    public void setPixel(int x, int y, Color c) {\\n        image.setRGB(x, y, c.getRGB());\\n    }\\n\\n    public Color getPixel(int x, int y) {\\n        return new Color(image.getRGB(x, y));\\n    }\\n\\n    public Image getImage() {\\n        return image;\\n    }\\n}"
"Java","Bitmap","Show a basic storage type to handle a simple RGB raster graphics image,\\nand some primitive associated functions.\\nIf possible provide a function to allocate an uninitialised image,\\ngiven its width and height, and provide 3 additional functions:\\n(If there are specificities about the storage or the allocation, explain those.)\\nThese functions are used as a base for the articles in the category raster graphics operations, \\nand a basic output function to check the results\\nis available in the article write ppm file.\\nActionScript 3 has a BitmapData class (in the flash.display package) which can be used for storage and handling of bitmap images.\\nTo display these images, the Bitmap class can be used.\\nThe package interface:\\nThe implementation of:\\nThis can be used like:\\nNote: short and shorten need to be tuned (added or removed)\\nto match the underlying graphic hardware colour depth.\\n","import static org.junit.Assert.assertEquals;\\n\\nimport java.awt.Color;\\nimport org.junit.Test;\\n\\npublic class BasicBitmapStorageTest {\\n\\n    @Test\\n    public void testHappy() {\\n        int width = 640;\\n        int height = 480;\\n\\n        BasicBitmapStorage bbs = new BasicBitmapStorage(width, height);\\n        bbs.fill(Color.CYAN);\\n        bbs.setPixel(width / 2, height / 2, Color.BLACK);\\n        Color c1 = bbs.getPixel(width / 2, height / 2);\\n        Color c2 = bbs.getPixel(20, 20);\\n\\n        assertEquals(Color.BLACK, c1);\\n        assertEquals(Color.CYAN, c2);\\n    }\\n}"
"Java","Bitmap/Bresenham's_line_algorithm","Using the data storage type defined on the Bitmap page for raster graphics images, draw a line given two points with Bresenham's line algorithm.\\n\\nThe test program's\\nsample output\\n16 bit Intel 8086\\80486 Assembly for dos, see x86 assembly language.\\nTo run this code you will need to use Dos emulator.\\n\\nInstead of swaps in the initialisation use error calculation for both directions x and y simultaneously:\\nPort of the C version.\\nThis code uses the Image defined in Bitmap Task.\\nTo run the demo code compile with -version=bitmap_bresenhams_line_algorithm_main.\\n","import java.awt.Color;\\nimport java.awt.Dimension;\\nimport java.awt.Graphics;\\nimport javax.swing.JFrame;\\nimport javax.swing.JPanel;\\nimport javax.swing.SwingUtilities;\\nimport javax.swing.WindowConstants;\\n\\npublic class Bresenham {\\n\\n    public static void main(String[] args) {\\n        SwingUtilities.invokeLater(Bresenham::run);\\n    }\\n\\n    private static void run() {\\n        JFrame f = new JFrame();\\n        f.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\\n        f.setTitle(\""Bresenham\"");\\n\\n        f.getContentPane().add(new BresenhamPanel());\\n        f.pack();\\n\\n        f.setLocationRelativeTo(null);\\n        f.setVisible(true);\\n    }\\n}\\n\\nclass BresenhamPanel extends JPanel {\\n\\n    private final int pixelSize = 10;\\n\\n    BresenhamPanel() {\\n        setPreferredSize(new Dimension(600, 500));\\n        setBackground(Color.WHITE);\\n    }\\n\\n    @Override\\n    public void paintComponent(Graphics g) {\\n        super.paintComponent(g);\\n\\n        int w = (getWidth() - 1) / pixelSize;\\n        int h = (getHeight() - 1) / pixelSize;\\n        int maxX = (w - 1) / 2;\\n        int maxY = (h - 1) / 2;\\n        int x1 = -maxX, x2 = maxX * -2 / 3, x3 = maxX * 2 / 3, x4 = maxX;\\n        int y1 = -maxY, y2 = maxY * -2 / 3, y3 = maxY * 2 / 3, y4 = maxY;\\n\\n        drawLine(g, 0, 0, x3, y1); // NNE\\n        drawLine(g, 0, 0, x4, y2); // ENE\\n        drawLine(g, 0, 0, x4, y3); // ESE\\n        drawLine(g, 0, 0, x3, y4); // SSE\\n        drawLine(g, 0, 0, x2, y4); // SSW\\n        drawLine(g, 0, 0, x1, y3); // WSW\\n        drawLine(g, 0, 0, x1, y2); // WNW\\n        drawLine(g, 0, 0, x2, y1); // NNW\\n    }\\n\\n    private void plot(Graphics g, int x, int y) {\\n        int w = (getWidth() - 1) / pixelSize;\\n        int h = (getHeight() - 1) / pixelSize;\\n        int maxX = (w - 1) / 2;\\n        int maxY = (h - 1) / 2;\\n\\n        int borderX = getWidth() - ((2 * maxX + 1) * pixelSize + 1);\\n        int borderY = getHeight() - ((2 * maxY + 1) * pixelSize + 1);\\n        int left = (x + maxX) * pixelSize + borderX / 2;\\n        int top = (y + maxY) * pixelSize + borderY / 2;\\n\\n        g.setColor(Color.black);\\n        g.drawOval(left, top, pixelSize, pixelSize);\\n    }\\n\\n    private void drawLine(Graphics g, int x1, int y1, int x2, int y2) {\\n        // delta of exact value and rounded value of the dependent variable\\n        int d = 0;\\n\\n        int dx = Math.abs(x2 - x1);\\n        int dy = Math.abs(y2 - y1);\\n\\n        int dx2 = 2 * dx; // slope scaling factors to\\n        int dy2 = 2 * dy; // avoid floating point\\n\\n        int ix = x1 < x2 ? 1 : -1; // increment direction\\n        int iy = y1 < y2 ? 1 : -1;\\n\\n        int x = x1;\\n        int y = y1;\\n\\n        if (dx >= dy) {\\n            while (true) {\\n                plot(g, x, y);\\n                if (x == x2)\\n                    break;\\n                x += ix;\\n                d += dy2;\\n                if (d > dx) {\\n                    y += iy;\\n                    d -= dx2;\\n                }\\n            }\\n        } else {\\n            while (true) {\\n                plot(g, x, y);\\n                if (y == y2)\\n                    break;\\n                y += iy;\\n                d += dx2;\\n                if (d > dy) {\\n                    x += ix;\\n                    d -= dy2;\\n                }\\n            }\\n        }\\n    }\\n}"
"Java","Bitmap/Flood_fill","Implement a flood fill.\\nA flood fill is a way of filling an area using color banks to define the contained area or a target color which \""determines\"" the area (the valley that can be flooded; Wikipedia uses the term target color). It works almost like a water flooding from a point towards the banks (or: inside the valley): if there's a hole in the banks, the flood is not contained and all the image (or all the \""connected valleys\"") get filled.\\nTo accomplish the task, you need to implement just one of the possible algorithms (examples are on Wikipedia). Variations on the theme are allowed (e.g. adding a tolerance parameter or argument for color-matching of the banks or target color).\\nTesting: the basic algorithm is not suitable for truecolor images; a possible test image is the one shown on the right box; you can try to fill the white area, or the black inner circle.\\n\\nThe procedure has the following parameters. Picture is the image to change. From is the point to start at. Fill is the color to fill with. Replace is the color to replace. Distance defines the range of color around Replace to replace as well. The distance is defined as a maximum of the differences of stimuli. The following code snippet reads the test file, fills the area between two circles red, and writes the result:\\nThis is limited to %StackSize% pixels.\\nBBC BASIC has a built-in flood fill statement, but to satisfy the terms of the task it is not used in this example.\\nThe sys/queue.h is not POSIX. (See FIFO)\\nThe pixelcount could be used to know the area of the filled region. The internal parameter tolerance can be tuned to cope with antialiasing, bringing \""sharper\"" resuts.\\n(Comments show changes to fill the white area instead of the black circle)\\nInput is the image, the starting node (x, y), the target color we want to fill, and the replacement color that will replace the target color. It implements a 4-way flood fill algorithm.\\nInterface\\nImplementation\\nThis implementation matches exact colours only. Since the example image has grey pixels around the edges of the circles, these will remain grey after the interiors are filled.\\nThis version uses the bitmap module from the Bitmap Task, matches exact colours only, and is derived from the Go version (to avoid stack overflow because unlike Go the D stack is not segmented).\\nUsing the image type from Basic bitmap storage#E.\\nIn \""PC.LIB\"" library there is a FILL procedure that do the job, but the example program implements the algorithm in ERRE language using an iterative method. This program is taken from the distribution disk and works in 320x200 graphics.\\nNote: I haven't an \""Upload files\"" item, so I can't show the resulting image!\\nUsing an emulated stack. EMT's recursive stack space is limited. For the notebook with images see this page.\\nUsing pure FBSL's built-in graphics functions:\\nOutput: \\nThis simple recursive algorithm uses routines from Basic bitmap storage.\\nHere the target color paradigm is used. Again the matchdistance parameter can be tuned to ignore small differences that could come because of antialiasing.\\nUsage example excerpt (which on the test image will fill with green the inner black circle):\\nAn addition to code from the bitmap task:\\nAnd a test program. Works with code from read ppm and write ppm to pipe tasks. For input, it uses a version of the test file converted by the Go solution to \""Read an image through a pipe\"". For output it uses the trick from \""PPM conversion through a pipe\"" to write the .png suitable for uploading to RC.\\nThis code uses the Bitmap and Bitmap.RGB modules defined here.\\nHicEst color fill is via the decoration option of WRITE()\\nSolution:\\nUses getPixels and setPixels from Basic bitmap storage.\\nExample Usage:\\nThe following draws the same image as for the Tcl example image below.\\nUses definitions from Basic bitmap storage, Bresenham's line algorithm and Midpoint circle algorithm.\\nAlternative findcontig:\\nThe following alternative version of findcontig is less concise but is leaner, faster, works for n-dimensions and is not restricted to numerical arrays.\\nInput is the image, the starting node (x, y), the target color we want to fill, and the replacement color that will replace the target color. It implements a 4-way flood fill algorithm. For large images, the performance can be improved by drawing the scanlines instead of setting each pixel to the replacement color, or by working directly on the databuffer.\\nAnd here is an example of how to replace the white color with red from the sample image (with starting node (50, 50)):\\nInspired to  Python version.\\nLingo has built-in flood fill for image objects, so a custom implementation would be pointless:\\n","import java.awt.Color;\\nimport java.awt.Point;\\nimport java.awt.image.BufferedImage;\\nimport java.util.Deque;\\nimport java.util.LinkedList;\\n\\npublic class FloodFill {\\n  public void floodFill(BufferedImage image, Point node, Color targetColor, Color replacementColor) {\\n    int width = image.getWidth();\\n    int height = image.getHeight();\\n    int target = targetColor.getRGB();\\n    int replacement = replacementColor.getRGB();\\n    if (target != replacement) {\\n      Deque<Point> queue = new LinkedList<Point>();\\n      do {\\n        int x = node.x;\\n        int y = node.y;\\n        while (x > 0 && image.getRGB(x - 1, y) == target) {\\n          x--;\\n        }\\n        boolean spanUp = false;\\n        boolean spanDown = false;\\n        while (x < width && image.getRGB(x, y) == target) {\\n          image.setRGB(x, y, replacement);\\n          if (!spanUp && y > 0 && image.getRGB(x, y - 1) == target) {\\n            queue.add(new Point(x, y - 1));\\n            spanUp = true;\\n          } else if (spanUp && y > 0 && image.getRGB(x, y - 1) != target) {\\n            spanUp = false;\\n          }\\n          if (!spanDown && y < height - 1 && image.getRGB(x, y + 1) == target) {\\n            queue.add(new Point(x, y + 1));\\n            spanDown = true;\\n          } else if (spanDown && y < height - 1 && image.getRGB(x, y + 1) != target) {\\n            spanDown = false;\\n          }\\n          x++;\\n        }\\n      } while ((node = queue.pollFirst()) != null);\\n    }\\n  }\\n}"
"Java","Bitmap/Flood_fill","Implement a flood fill.\\nA flood fill is a way of filling an area using color banks to define the contained area or a target color which \""determines\"" the area (the valley that can be flooded; Wikipedia uses the term target color). It works almost like a water flooding from a point towards the banks (or: inside the valley): if there's a hole in the banks, the flood is not contained and all the image (or all the \""connected valleys\"") get filled.\\nTo accomplish the task, you need to implement just one of the possible algorithms (examples are on Wikipedia). Variations on the theme are allowed (e.g. adding a tolerance parameter or argument for color-matching of the banks or target color).\\nTesting: the basic algorithm is not suitable for truecolor images; a possible test image is the one shown on the right box; you can try to fill the white area, or the black inner circle.\\n\\nThe procedure has the following parameters. Picture is the image to change. From is the point to start at. Fill is the color to fill with. Replace is the color to replace. Distance defines the range of color around Replace to replace as well. The distance is defined as a maximum of the differences of stimuli. The following code snippet reads the test file, fills the area between two circles red, and writes the result:\\nThis is limited to %StackSize% pixels.\\nBBC BASIC has a built-in flood fill statement, but to satisfy the terms of the task it is not used in this example.\\nThe sys/queue.h is not POSIX. (See FIFO)\\nThe pixelcount could be used to know the area of the filled region. The internal parameter tolerance can be tuned to cope with antialiasing, bringing \""sharper\"" resuts.\\n(Comments show changes to fill the white area instead of the black circle)\\nInput is the image, the starting node (x, y), the target color we want to fill, and the replacement color that will replace the target color. It implements a 4-way flood fill algorithm.\\nInterface\\nImplementation\\nThis implementation matches exact colours only. Since the example image has grey pixels around the edges of the circles, these will remain grey after the interiors are filled.\\nThis version uses the bitmap module from the Bitmap Task, matches exact colours only, and is derived from the Go version (to avoid stack overflow because unlike Go the D stack is not segmented).\\nUsing the image type from Basic bitmap storage#E.\\nIn \""PC.LIB\"" library there is a FILL procedure that do the job, but the example program implements the algorithm in ERRE language using an iterative method. This program is taken from the distribution disk and works in 320x200 graphics.\\nNote: I haven't an \""Upload files\"" item, so I can't show the resulting image!\\nUsing an emulated stack. EMT's recursive stack space is limited. For the notebook with images see this page.\\nUsing pure FBSL's built-in graphics functions:\\nOutput: \\nThis simple recursive algorithm uses routines from Basic bitmap storage.\\nHere the target color paradigm is used. Again the matchdistance parameter can be tuned to ignore small differences that could come because of antialiasing.\\nUsage example excerpt (which on the test image will fill with green the inner black circle):\\nAn addition to code from the bitmap task:\\nAnd a test program. Works with code from read ppm and write ppm to pipe tasks. For input, it uses a version of the test file converted by the Go solution to \""Read an image through a pipe\"". For output it uses the trick from \""PPM conversion through a pipe\"" to write the .png suitable for uploading to RC.\\nThis code uses the Bitmap and Bitmap.RGB modules defined here.\\nHicEst color fill is via the decoration option of WRITE()\\nSolution:\\nUses getPixels and setPixels from Basic bitmap storage.\\nExample Usage:\\nThe following draws the same image as for the Tcl example image below.\\nUses definitions from Basic bitmap storage, Bresenham's line algorithm and Midpoint circle algorithm.\\nAlternative findcontig:\\nThe following alternative version of findcontig is less concise but is leaner, faster, works for n-dimensions and is not restricted to numerical arrays.\\nInput is the image, the starting node (x, y), the target color we want to fill, and the replacement color that will replace the target color. It implements a 4-way flood fill algorithm. For large images, the performance can be improved by drawing the scanlines instead of setting each pixel to the replacement color, or by working directly on the databuffer.\\nAnd here is an example of how to replace the white color with red from the sample image (with starting node (50, 50)):\\nInspired to  Python version.\\nLingo has built-in flood fill for image objects, so a custom implementation would be pointless:\\n","import java.io.IOException;\\nimport java.awt.Color;\\nimport java.awt.Point;\\nimport java.awt.image.BufferedImage;\\nimport java.io.File;\\nimport javax.imageio.ImageIO;\\n\\npublic class Test {\\n  public Test() throws IOException {\\n    BufferedImage image = ImageIO.read(new File(\""Unfilledcirc.png\""));\\n    new FloodFill().floodFill(image, new Point(50, 50), Color.WHITE, Color.RED);\\n    ImageIO.write(image, \""png\"", new File(\""output.png\""));\\n  }\\n\\n  public static void main(String[] args) throws IOException {\\n    new Test();\\n  }\\n}"
"BASIC","100_doors","There are 100 doors in a row that are all initially closed.\\nYou make 100 passes by the doors.\\nThe first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).\\nThe second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.\\nThe third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.\\n\\nAnswer the question:   what state are the doors in after the last pass?   Which are open, which are closed?\\n\\nAlternate:\\nAs noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.\\nOpening only those doors is an   optimization   that may also be expressed;\\nhowever, as should be obvious, this defeats the intent of comparing implementations across programming languages.\\n\\n","\\n 100 :\\n 110  REM  100 DOORS PROBLEM\\n 120 :\\n 130  DIM D(100)\\n 140  FOR P = 1 TO 100\\n 150  FOR T = P TO 100 STEP P\\n 160  D(T) =  NOT D(T): NEXT T\\n 170  NEXT P\\n 180  FOR I = 1 TO 100\\n 190  IF D(I) THEN  PRINT I;\"" \"";\\n 200  NEXT I\\n"
"BASIC","100_doors","There are 100 doors in a row that are all initially closed.\\nYou make 100 passes by the doors.\\nThe first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).\\nThe second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.\\nThe third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.\\n\\nAnswer the question:   what state are the doors in after the last pass?   Which are open, which are closed?\\n\\nAlternate:\\nAs noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.\\nOpening only those doors is an   optimization   that may also be expressed;\\nhowever, as should be obvious, this defeats the intent of comparing implementations across programming languages.\\n\\n","# 100 doors problem\\ndim d(100)\\n\\n# simple solution\\nprint \""simple solution\""\\ngosub initialize\\nfor t = 1 to 100\\n   for j = t to 100 step t\\n      d[j-1] = not d[j-1]\\n   next j\\nnext t\\ngosub showopen\\n\\n# more optimized solution\\nprint \""more optimized solution\""\\ngosub initialize\\nfor t = 1 to 10\\n      d[t^2-1] = true\\nnext t\\ngosub showopen\\nend\\n\\ninitialize:\\nfor t = 1 to d[?]\\n   d[t-1] = false	 # closed\\nnext t\\nreturn\\n\\nshowopen:\\nfor t = 1 to d[?]\\n   print d[t-1]+ \"" \"";\\n   if t%10 = 0 then print\\nnext t\\nreturn"
"BASIC","100_doors","There are 100 doors in a row that are all initially closed.\\nYou make 100 passes by the doors.\\nThe first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).\\nThe second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.\\nThe third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.\\n\\nAnswer the question:   what state are the doors in after the last pass?   Which are open, which are closed?\\n\\nAlternate:\\nAs noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.\\nOpening only those doors is an   optimization   that may also be expressed;\\nhowever, as should be obvious, this defeats the intent of comparing implementations across programming languages.\\n\\n","10 DIM D(100)\\n20 FOR I=1 TO 100\\n30 FOR J=I TO 100 STEP I\\n40 D(J) = NOT D(J)\\n50 NEXT J\\n60 NEXT I\\n70 FOR I=1 TO 100\\n80 IF D(I) THEN PRINT I,\\n90 NEXT I"
"BASIC","100_doors","There are 100 doors in a row that are all initially closed.\\nYou make 100 passes by the doors.\\nThe first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).\\nThe second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.\\nThe third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.\\n\\nAnswer the question:   what state are the doors in after the last pass?   Which are open, which are closed?\\n\\nAlternate:\\nAs noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.\\nOpening only those doors is an   optimization   that may also be expressed;\\nhowever, as should be obvious, this defeats the intent of comparing implementations across programming languages.\\n\\n","100 PROGRAM \""100doors.bas\""\\n110 NUMERIC D(1 TO 100)\\n120 FOR I=1 TO 100\\n130   LET D(I)=0\\n140 NEXT\\n150 FOR I=1 TO 100\\n160   FOR J=I TO 100 STEP I\\n170     LET D(J)=NOT D(J)\\n180   NEXT \\n190 NEXT\\n200 FOR I=1 TO 100\\n210   IF D(I) THEN PRINT I\\n220 NEXT"
"BASIC","100_doors","There are 100 doors in a row that are all initially closed.\\nYou make 100 passes by the doors.\\nThe first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).\\nThe second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.\\nThe third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.\\n\\nAnswer the question:   what state are the doors in after the last pass?   Which are open, which are closed?\\n\\nAlternate:\\nAs noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.\\nOpening only those doors is an   optimization   that may also be expressed;\\nhowever, as should be obvious, this defeats the intent of comparing implementations across programming languages.\\n\\n","100 PROGRAM \""100doors.bas\""\\n110 LET NR=1:LET D=3\\n120 DO\\n130   PRINT NR\\n140   LET NR=NR+D:LET D=D+2\\n150 LOOP WHILE NR<=100"
"BASIC","100_doors","There are 100 doors in a row that are all initially closed.\\nYou make 100 passes by the doors.\\nThe first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).\\nThe second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.\\nThe third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.\\n\\nAnswer the question:   what state are the doors in after the last pass?   Which are open, which are closed?\\n\\nAlternate:\\nAs noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.\\nOpening only those doors is an   optimization   that may also be expressed;\\nhowever, as should be obvious, this defeats the intent of comparing implementations across programming languages.\\n\\n","REM \""100 Doors\"" program for QB64 BASIC (http://www.qb64.net/), a QuickBASIC-like compiler.\\nREM Author: G. A. Tippery\\nREM Date: 12-Feb-2014\\nREM\\nREM   Unoptimized (naive) version, per specifications at http://rosettacode.org/wiki/100_doors\\n\\nDEFINT A-Z\\nCONST N = 100\\nDIM door(N)\\n\\nFOR stride = 1 TO N\\n    FOR index = stride TO N STEP stride\\n        LET door(index) = NOT (door(index))\\n    NEXT index\\nNEXT stride\\n\\nPRINT \""Open doors:\""\\nFOR index = 1 TO N\\n    IF door(index) THEN PRINT index\\nNEXT index\\n\\nEND"
"BASIC","100_doors","There are 100 doors in a row that are all initially closed.\\nYou make 100 passes by the doors.\\nThe first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).\\nThe second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.\\nThe third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.\\n\\nAnswer the question:   what state are the doors in after the last pass?   Which are open, which are closed?\\n\\nAlternate:\\nAs noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.\\nOpening only those doors is an   optimization   that may also be expressed;\\nhowever, as should be obvious, this defeats the intent of comparing implementations across programming languages.\\n\\n","DIM doors(0 TO 99)\\nFOR pass = 0 TO 99\\n	FOR door = pass TO 99 STEP pass + 1\\n		PRINT doors(door)\\n		PRINT NOT doors(door)\\n		doors(door) = NOT doors(door)\\n	NEXT door\\nNEXT pass\\nFOR i = 0 TO 99\\n	PRINT \""Door #\""; i + 1; \"" is \"";\\n	IF NOT doors(i) THEN\\n		PRINT \""closed\""\\n	ELSE\\n		PRINT \""open\""\\n	END IF\\nNEXT i"
"BASIC","100_doors","There are 100 doors in a row that are all initially closed.\\nYou make 100 passes by the doors.\\nThe first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).\\nThe second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.\\nThe third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.\\n\\nAnswer the question:   what state are the doors in after the last pass?   Which are open, which are closed?\\n\\nAlternate:\\nAs noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.\\nOpening only those doors is an   optimization   that may also be expressed;\\nhowever, as should be obvious, this defeats the intent of comparing implementations across programming languages.\\n\\n","DIM doors(0 TO 99)\\nFOR door = 0 TO 99\\n	IF INT(SQR(door)) = SQR(door) THEN doors(door) = -1\\nNEXT door\\nFOR i = 0 TO 99\\n	PRINT \""Door #\""; i + 1; \"" is \"";\\n	IF NOT doors(i) THEN\\n		PRINT \""closed\""\\n	ELSE\\n		PRINT \""open\""\\n	END IF\\nNEXT i"
"BASIC","100_doors","There are 100 doors in a row that are all initially closed.\\nYou make 100 passes by the doors.\\nThe first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).\\nThe second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.\\nThe third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.\\n\\nAnswer the question:   what state are the doors in after the last pass?   Which are open, which are closed?\\n\\nAlternate:\\nAs noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.\\nOpening only those doors is an   optimization   that may also be expressed;\\nhowever, as should be obvious, this defeats the intent of comparing implementations across programming languages.\\n\\n","\\n'lrcvs 04.11.12\\ncls\\nx = 1 : y = 3 : z = 0\\nprint x + \"" Open\""\\ndo\\nz = x + y\\nprint z + \"" Open\""\\nx = z : y = y + 2\\nuntil z >= 100\\nend\\n"
"BASIC","100_doors","There are 100 doors in a row that are all initially closed.\\nYou make 100 passes by the doors.\\nThe first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).\\nThe second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.\\nThe third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.\\n\\nAnswer the question:   what state are the doors in after the last pass?   Which are open, which are closed?\\n\\nAlternate:\\nAs noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.\\nOpening only those doors is an   optimization   that may also be expressed;\\nhowever, as should be obvious, this defeats the intent of comparing implementations across programming languages.\\n\\n","10 DIM D(100)\\n20 FOR I=1 TO 100\\n30 FOR J=I TO 100 STEP I\\n40 LET D(J)=NOT D(J)\\n50 NEXT J\\n60 NEXT I\\n70 FOR I=1 TO 100\\n80 IF D(I) THEN PRINT I,\\n90 NEXT I"
"BASIC","15_Puzzle_Game","\\nImplement the Fifteen Puzzle Game.\\n\\nThe   15-puzzle   is also known as:\\n\\n\\nWe fist define a generic package Generic_Puzzle. Upon instantiation, it can take any number of rows, any number of columns for a rows*columns-1 game. Instead of plain numbers, the tiles on the board can have arbitrary names (but they should all be of the same length). The package user can request the name for the tile at a certain (row,column)-point, and the set of possible moves. The user can move the empty space up, down, left and right (if possible). If the user makes the attempt to perform an impossible move, a Constraint_Error is raised.\\nThe package implementation is as follows.\\nThe main program reads the level from the command line. A larger level implies a more difficult instance. The default level is 10, which is fairly simple. After randomizing the board, the user can move the tiles.\\n","10 REM 15-PUZZLE GAME\\n20 REM COMMODORE BASIC 2.0\\n30 REM ********************************\\n40 GOSUB 400 : REM INTRO AND LEVEL\\n50 GOSUB 510 : REM SETUP BOARD\\n60 GOSUB 210 : REM PRINT PUZZLE\\n70 PRINT \""TO MOVE A PIECE, ENTER ITS NUMBER:\""\\n80 INPUT X\\n90 GOSUB 730 : REM CHECK IF MOVE IS VALID\\n100 IF MV=0 THEN PRINT \""WRONG MOVE\"" : GOSUB 1050 : GOTO 60\\n110 D(Z)=X : D(Y)=0\\n120 GOSUB 210 : REM PRINT PUZZLE\\n130 GOSUB 950 : REM CHECK IF PUZZLE COMPLETE\\n140 IF PC THEN 160\\n150 GOTO 70\\n160 PRINT\""YOU WON!\""\\n170 END\\n180 REM\\n190 REM *******************************\\n200 REM PRINT/DRAW THE PUZZLE\\n210 FOR P=1 TO 16\\n220   IF D(P)=0 THEN D$(P)=\""     \"" : GOTO 260\\n230   S$=STR$(D(P))\\n240   N=LEN(S$)\\n250   D$(P) = LEFT$(\""   \"",3-N)+S$+\""  \""\\n260 NEXT\\n270 PRINT \""+-----+-----+-----+-----+\""\\n280 PRINT \""!\""D$(1)\""!\""D$(2)\""!\""D$(3)\""!\""D$(4)\""!\""\\n290 PRINT \""+-----+-----+-----+-----+\""\\n300 PRINT \""!\""D$(5)\""!\""D$(6)\""!\""D$(7)\""!\""D$(8)\""!\""\\n310 PRINT \""+-----+-----+-----+-----+\""\\n320 PRINT \""!\""D$(9)\""!\""D$(10)\""!\""D$(11)\""!\""D$(12)\""!\""\\n330 PRINT \""+-----+-----+-----+-----+\""\\n340 PRINT \""!\""D$(13)\""!\""D$(14)\""!\""D$(15)\""!\""D$(16)\""!\""\\n350 PRINT \""+-----+-----+-----+-----+\""\\n360 RETURN\\n370 REM\\n380 REM *******************************\\n390 REM INTRO AND LEVEL OF DIFFICULTY\\n400 PRINT CHR$(147)\\n410 DIM SH(3) : SH(1)=10 : SH(2)=50 : SH(3)=100\\n420 PRINT \""15 PUZZLE GAME FOR COMMODORE BASIC 2.0\"" : PRINT : PRINT\\n430 PRINT \""PLEASE ENTER LEVEL OF DIFFICULTY,\""\\n440 PRINT \""1(EASY), 2(MEDIUM) OR 3(HARD):\"";\\n450 INPUT V\\n460 IF V<1 OR V>3 THEN 440\\n470 RETURN\\n480 REM\\n490 REM *******************************\\n500 REM BUILD THE BOARD\\n510 DIM D(16) : DIM D$(16) : REM BOARD PIECES\\n520 REM SET PIECES IN CORRECT ORDER FIRST\\n530 FOR P=1 TO 15\\n540   D(P) = P\\n550 NEXT\\n560 D(16) = 0 : REM 0 = EMPTY PIECE/SLOT\\n570 Z=16      : REM Z = EMPTY POSITION\\n580 PRINT: PRINT \""SHUFFLING PIECES\"";\\n590 FOR N=1 TO SH(V)\\n600   PRINT\"".\"";\\n610   X = INT(RND(0)*4)+1\\n620   R = Z+(X=1)*4-(X=2)*4+(X=3)-(X=4)\\n630   IF R<1 OR R>16 THEN 610\\n640   D(Z)=D(R)\\n650   Z=R\\n660   D(Z)=0\\n670 NEXT\\n680 PRINT CHR$(147)\\n690 RETURN\\n700 REM\\n710 REM *******************************\\n720 REM CHECK IF MOVE IS VALID\\n730 MV = 0\\n740 IF X<1 OR X>15 THEN RETURN\\n750 REM FIND POSITION OF PIECE X\\n760 P=1\\n770 IF D(P)=X THEN Y=P : GOTO 810\\n780 P=P+1 : IF P>16 THEN PRINT \""UH OH!\"" : STOP\\n790 GOTO 770\\n800 REM FIND POSITION OF EMPTY PIECE\\n810 P=1\\n820 IF D(P)=0 THEN Z=P : GOTO 860\\n830 P=P+1 : IF P>16 THEN PRINT \""UH OH!\"" : STOP\\n840 GOTO 820\\n850 PRINT Y;Z\\n860 REM CHECK IF EMPTY PIECE IS ABOVE, BELOW, LEFT OR RIGHT TO PIECE X\\n870 IF Y-4=Z THEN MV=1 : RETURN\\n880 IF Y+4=Z THEN MV=1 : RETURN\\n890 IF Y-1=Z THEN MV=1 : RETURN\\n900 IF Y+1=Z THEN MV=1 : RETURN\\n910 RETURN\\n920 REM\\n930 REM *******************************\\n940 REM CHECK IF PUZZLE IS COMPLETE / GAME OVER\\n950 PC = 0\\n960 P=1\\n970 IF D(P)<>P THEN RETURN\\n980 P=P+1\\n990 IF P<16 THEN 970\\n1000 PC = 1\\n1010 RETURN\\n1020 REM\\n1030 REM ******************************\\n1040 REM A SMALL DELAY\\n1050 FOR T=0 TO 400\\n1060 NEXT\\n1070 RETURN"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","PLAY \""<\""\\nFOR x = 99 TO 0 STEP -1\\n  PRINT x; \""bottles of beer on the wall\""\\n  PRINT x; \""bottles of beer\""\\n  PRINT \""Take one down, pass it around\""\\n  PRINT x-1; \""bottles of beer on the wall\""\\n  PRINT\\n  PLAY \""e-8e-8e-8<b-8b-8b-8>e-8e-8e-8e-4\""'X bottles of beer on the wall\\n  PLAY \""f8f8f8c8c8c8f4\""'X bottles of beer\\n  PLAY \""d4d8d8 N0 d8d8d8d4\""'take one down, pass it around\\n  PLAY \""c8c8d8d+8d+8d+8d+4\""'X-1 bottles of beer on the wall\\nNEXT x"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","FOR x = 99 TO 1 STEP -1\\n  PRINT x; \""bottles of beer on the wall\""\\n  PRINT x; \""bottles of beer\""\\n  PRINT \""Take one down, pass it around\""\\n  PRINT x-1; \""bottles of beer on the wall\""\\n  PRINT\\nNEXT x"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","H$ = \""HELLO, WORLD!\"":B$ = \"" BOTTLES OF BEER\"":N$ =  CHR$ (13):W$ = \"" ON THE WALL\"" + N$: FOR B = 99 TO 1 STEP  - 1: PRINT B;B$W$B\"" \""B$N$\""TAKE ONE DOWN, PASS IT AROUND\""N$B - 1;B$W$: NEXT "
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","' 99 bottles of beer on the wall\\nDECLARE counter$\\nDECLARE bottle$\\nDECLARE ofbeer$ = \""of beer\""\\nDECLARE onthewall$ = \""on the wall\""\\n\\nSUB howmany(b)\\n    LOCAL plural$\\n    plural$ = IIF$(b != 1, \""s\"", \""\"")\\n    bottle$ = \""bottle\"" & plural$\\n    counter$ = IIF$(b >= 1, STR$(b), \""no more\"")\\nEND SUB\\n    \\nFOR bottles = 99 DOWNTO 0\\n    howmany(bottles)\\n    IF counter$ = \""no more\"" THEN counter$ = \""No more\""\\n    PRINT counter$, bottle$, ofbeer$, onthewall$ FORMAT \""%s %s %s %s, \""\\n    IF counter$ = \""No more\"" THEN counter$ = \""no more\""\\n    PRINT counter$, bottle$, ofbeer$ FORMAT \""%s %s %s.\\n\""\\n    IF bottles > 0 THEN\\n        PRINT \""Take one down and pass it around\"" FORMAT \""%s, \""\\n        howmany(bottles - 1)\\n    ELSE\\n        PRINT \""Go to the store and buy some more\"" FORMAT \""%s, \""\\n        howmany(99)\\n    ENDIF\\n    PRINT counter$, bottle$, ofbeer$, onthewall$ FORMAT \""%s %s %s %s.\\n\""\\n    IF bottles > 0 THEN PRINT\\nNEXT"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","#length of querter and eight note in ms\\nn4 = 1000 * 60 / 80 / 4\\nn8 = n4 / 2\\n\\n#frequency of musical notes in hz\\ne = 330\\nef = 311\\nb = 247\\nbf = 233\\nf = 349\\nc = 262\\nd = 294\\nds = 311\\na = 220\\n\\ndim notes(1)\\ndim lengs(1)\\n\\n# redim is automatic when using a {} list to assign an array\\nnotes = {ef, ef, ef, bf, bf, bf, ef, ef, ef, ef, f , f , f , c , c , c , f , d , d , d , d , d , d , d , bf, bf, bf, c , c , ef, ef, ef, ef, ef}\\nlengs = {n8, n8, n8, n8, n8, n8, n8, n8, n8, n4, n8, n8, n8, n8, n8, n8, n4, n4, n8, n8, n8, n8, n8, n4, n8, n8, n8, n8, n8, n8, n8, n8, n8, n4 }\\n\\nfor x = 99 to 1 step -1\\n   for t = 0 to notes[?]-1\\n      if t = 0 then print x + \"" bottles of beer on the wall\""\\n      if t = 11 then print x + \"" bottles of beer\""\\n      if t = 18 then print \""Take one down, pass it around\""\\n      if t = 25 then print(x-1) + \"" bottles of beer on the wall\""\\n      sound notes[t], lengs[t]\\n      pause .002\\n   next t\\n   print\\nnext x\\n"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","\\n      N_Bottles = 99\\n      \\n      beer$ = \"" of beer\""\\n      wall$ = \"" on the wall\""\\n      unit$ = \""99 bottles\""\\n      \\n      WHILE N_Bottles >= 0\\n        \\n        IF N_Bottles=0 THEN\\n          PRINT '\""No more bottles\"" beer$ wall$ \"", \"" unit$ beer$ \"".\""\\n          PRINT \""Go to the store and buy some more, \"";\\n        ELSE\\n          PRINT 'unit$ beer$ wall$ \"", \"" unit$ beer$ \"".\""\\n          PRINT \""Take one down and pass it around, \"";\\n        ENDIF\\n        \\n        N_Bottles -= 1\\n        \\n        CASE N_Bottles OF\\n          WHEN 0:\\n            unit$ = \""no more bottles\""\\n          WHEN 1:\\n            unit$ = \""1 bottle\""\\n          OTHERWISE:\\n            unit$ = STR$((N_Bottles + 100) MOD 100) + \"" bottles\""\\n        ENDCASE\\n        \\n        PRINT unit$ beer$ wall$ \"".\""\\n        \\n      ENDWHILE\\n      \\n      END\\n"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","DEF Win:WINDOW\\nDEF Close:CHAR\\nDEF ScreenSizeX,ScreenSizeY:INT\\n\\nDECLARE VSpace(Number:UINT)\\nDECLARE CLR()\\n\\nDEF TheLine$[4],Number$,Erase:STRING\\nDEF TheLine,TextHeight,TextWidth:INT\\nDEF TextX,TextY:UINT\\n\\nTheLine$[0]=\""bottles\""\\nTheLine$[1]=\""of beer on the wall.\""\\nTheLine$[2]=\""of beer.\""\\nTheLine$[3]=\""Take one down, pass it around.\""\\n\\nBottlesOfBeer=99\\nTheLine=1\\n\\nGETSCREENSIZE(ScreenSizeX,ScreenSizeY)\\n\\nWINDOW Win,0,0,ScreenSizeX,ScreenSizeY,@MINBOX|@MAXBOX|@SIZE,0,\""99 Bottles Of Beer\"",MainHandler\\n\\nGETTEXTSIZE(Win,TheLine$[3],TextWidth,TextHeight)\\n\\nErase$=STRING$(TextWidth,\"" \"")\\n\\nPRINT Win,\""Let's sing a song.\""\\n\\nVSpace(2)\\n\\n'1.2 seconds.\\nSTARTTIMER Win,1200 \\n\\nGOSUB Sing\\n\\nWAITUNTIL Close=1\\n\\nCLOSEWINDOW Win\\n\\nEND\\n\\nSUB MainHandler\\n\\n     SELECT @CLASS\\n\\n     CASE @IDCLOSEWINDOW\\n\\n     Close=1\\n\\n     CASE @IDTIMER\\n\\n     GOSUB Sing\\n\\n     ENDSELECT\\n\\nRETURN\\n\\nSUB Sing\\n\\n     DEF Sing:INT\\n\\n     Sing=TheLine\\n\\n     MOVE Win,TextX,TextY\\n\\n     Number$=STR$(BottlesOfBeer)\\n\\n     IF BottlesOfBeer=0\\n\\n          Number$=\""No more\""\\n	  TheLine$[0]=\""bottles\""\\n	  TheLine$[3]=\""Go to the store and buy some more.\""\\n	\\n     ENDIF\\n				\\n     IF BottlesOfBeer=1 \\n\\n	  TheLine$[0]=\""bottle\""\\n	  TheLine$[3]=\""Take it down, pass it around.\""\\n	\\n     ENDIF\\n\\n     IF TheLine=4 THEN Sing=1\\n	\\n     IF (TheLine=1)|(TheLine=2)|(TheLine=4)\\n\\n	  IF BottlesOfBeer>-1 THEN PRINT Win,Number$+\"" \""+TheLine$[0]+\"" \""+TheLine$[Sing] ELSE GOSUB TheEnd\\n				\\n     ELSE\\n		\\n	  PRINT Win,TheLine$[3]\\n\\n	  BottlesOfBeer=BottlesOfBeer-1 \\n\\n     ENDIF	\\n\\n     TheLine=TheLine+1\\n		\\n     VSpace(1)\\n\\n     IF TheLine>4\\n			\\n           TheLine=1\\n						 \\n	   VSpace(1)\\n\\n     ENDIF\\n\\nRETURN\\n\\nSUB TheEnd\\n\\n     PRINT Win,\""What's the problem, offishur?\""\\n\\n     STOPTIMER Win\\n\\n     VSpace(2)\\n\\n     MOVE Win,TextX,TextY:PRINT Win,\""That's all.\""\\n		\\nRETURN\\n\\nSUB VSpace(Number:UINT)\\n\\n     TextY=TextY+(TextHeight*Number)\\n\\n     IF TextY+(TextHeight*8)>ScreenSizeY THEN CLR()\\n\\nRETURN \\n\\nSUB CLR()\\n\\n     FOR X=0 TO ScreenSizeY\\n\\n          MOVE Win,0,X:PRINT Win,Erase$\\n\\n          TextY=8\\n\\n     NEXT X\\n\\nRETURN\\n"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","REM Using the ESC key to exit will not work in console programs under Windows 95/98 or ME.\\n\\nDECLARE SingWallLn()\\nDECLARE Delay1()\\nDECLARE Delay2()\\n'To use ESC Key to exit.\\nDECLARE Quit()\\nDECLARE TheEnd()\\n\\nDEF Bottles:UINT\\nDEF Number$,Again$:STRING\\n\\nOPENCONSOLE\\n\\nPRINT\""I'm going to sing a song.\"":PRINT\\n\\nDelay1()\\n\\nLABEL StartSong\\n\\nBottles=99\\n\\nDO 	\\n     Quit()\\n\\n     SingWallLn():Delay1()\\n\\n     PRINT LTRIM$(STR$(Bottles))+Number$+\"" of beer.\"":Delay1()\\n\\n     IF Bottles>0 THEN PRINT\""Take one down, pass it around.\"" ELSE PRINT\""Take it down, pass it around.\"":Delay1()\\n\\n     Bottles=Bottles-1\\n	\\n     SingWallLn()\\n\\n     Delay2()\\n\\nPRINT:PRINT\\n\\nUNTIL Bottles=0\\n\\nDelay2()\\n\\nClS\\n\\nLABEL Question\\n\\nINPUT\""Sing it again (y or n)?\"",Again$\\n\\nSELECT Again$\\n\\n	CASE(\""y\"")\\n	CASE(\""Y\"")\\n\\n	CLS\\n\\n	GOTO StartSong\\n\\n	CASE \""n\""\\n	CASE \""N\""\\n\\n	CLS\\n\\n	PRINT\""Fine, be that way.\"":Delay2()\\n\\n	TheEnd()\\n\\nENDSELECT\\n	\\nPRINT\""Sorry, I didn't understand.\"":PRINT\\n\\nGOTO Question\\n\\n'Keep from running into subroutines.\\nEND\\n\\nSUB SingWallLn()\\n\\n     IF Bottles=1 THEN Number$=\"" bottle\"" ELSE Number$=\"" bottles\""\\n\\n     PRINT LTRIM$(STR$(Bottles))+Number$+\"" of beer on the wall.\""\\n\\nRETURN\\n\\nSUB Delay1()\\n\\n     FOR X=1 TO 7000:NEXT X\\n\\nRETURN\\n\\nSUB Delay2()\\n\\n     FOR X=1 TO 1750000:NEXT X\\n\\nRETURN\\n\\nSUB Quit()\\n\\n     'Close program by pressing the ESC key.\\n     'Will not work in console under Windows 95/98 or ME.\\n     IF GETKEYSTATE(0x1B) THEN TheEnd()\\n\\nRETURN\\n\\nSUB TheEnd()\\n\\n     CLOSECONSOLE\\n\\n     END\\n\\nRETURN\\n"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","#AppType Console\\n\\nClass Wall\\n	bottles\\n\\n	Sub Initialize(%n = 99)\\n		bottles = n\\n	End Sub\\n\\n	Method Denom()\\n		if bottles+1 > 1 then\\n			return \""one\""\\n		elseif bottles+1 = 1 then\\n			return \""it\""\\n		end if\\n	End Method\\n	\\n	Method StockUp( %n = 99 ) \\n		bottles = n\\n	End Method\\n	\\n	Method TakeOneDown()\\n		bottles = bottles - 1\\n	end Method\\n	\\n	Method Pluraliser()\\n		if bottles > 1 then\\n			return \""s\""\\n		else\\n			return \""\""\\n		end if\\n	end method\\n	\\n	Method Sing()\\n		print bottles, \"" bottle\"", Pluraliser(), \"" of beer on the wall\""\\n		print bottles, \"" bottle\"", Pluraliser(), \"" of beer\""\\n		TakeOneDown()\\n		print \""take \"", Denom(), \"" down and pass it round\""\\n		if bottles > 0 then\\n			print bottles, \"" bottle\"", Pluraliser(), \"" of beer on the wall\""\\n			print\\n		else\\n			print \""no more bottles of beer on the wall\""\\n			print \\n			print \""no more bottles of beer on the wall\""\\n			print \""no more bottles of beer on the wall\""\\n			print \""go to the store and buy some more\""\\n			StockUp(99)\\n			print bottles, \"" bottle\"", Pluraliser(), \"" of beer on the wall\""\\n			print\\n		end if\\n		return bottles\\n	End Method\\n	\\nEnd Class\\n\\nDim BeerSong as new Wall(99)\\n\\nwhile BeerSong.Sing() <> 99\\nend while\\n"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","' FB 1.05.0 Win64\\n\\nDim As Integer bottles = 99\\nDim As String b = \"" bottles \""\\n\\nDo\\n  Print Str(bottles); b; \""of beer hanging on the wall\""  \\n  Print Str(bottles); b; \""of beer hanging on the wall\"" \\n  Print \""And if one bottle of beer should accidently be drunk\""\\n  bottles -= 1\\n  If bottles = 1 Then \\n    b = \"" bottle \""\\n  ElseIf bottles = 0 Then\\n    b = \"" bottles \""\\n  End If\\n  Print \""There'll be\""; bottles; b; \""of beer hanging on the wall\""\\n  Print\\nLoop Until bottles = 0 \\n\\nPrint \""Press any key to sleep it off\""\\nSleep"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","CLS\\nDIM s$(1)\\nREAD b,s$(0),s$(1),a$,b$,c$,d$,e$,f$\\ng$ = chr$(10)\\nWHILE b > 0 CYCLE\\n    PRINT b;a$;s$(b>1);b$;c$;b;a$;s$(b>1);b$;\"".\"";g$;d$;b-1;a$;s$(b-1<>1);b$;c$;g$\\n    b = b - 1\\nREPEAT\\nPRINT e$;a$;\""s\"";b$;c$;e$;a$;\""s\"";b$;\"".\"";g$;f$;a$;\""s\"";b$;c$\\nDATA 99,\""\"",\""s\"",\"" bottle\"",\"" of beer\"",\"" on the wall. \"",\""Take one down, pass it around. \""\\nDATA \""No more\"",\""Go to the store and buy some more. 99\""\\nEND"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","E000G (APPLE II)\\nE000R (APPLE I)\\n10 REM -------------------------\\n11 REM BEERSONG IN APPLE INTEGER\\n12 REM BASIC BY BARRYM 2011-8-21\\n13 REM THANKS : APPLEWIN1.17.2.0\\n14 REM THANKS ALSO : POM1 0.7B\\n15 REM -------------------------\\n16 REM PRINTS THE COMPLETE UPPER\\n17 REM CASE LYRICS ON AN APPLE I\\n18 REM OR AN 'ORIGINAL' APPLE II\\n19 REM WITH WOZ'S INTEGER BASIC.\\n20 REM -------------------------\\n21 REM THIS BASIC HAS AN UNUSUAL\\n22 REM 'THEN', WHICH EXECUTES OR\\n23 REM SKIPS ONE (AND ONLY ONE!)\\n24 REM STATEMENT.  THIS CONFUSED\\n25 REM US KIDS REGULARLY WHEN WE\\n26 REM TRIED TRANSLATING INTEGER\\n27 REM BASIC GAMES TO APPLE$OFT!\\n30 REM -------------------------\\n40 FOR B=99 TO 98 STEP 0: PRINT : FOR W=0 TO 2: IF W<2 THEN 70\\n50 IF B THEN PRINT \""TAKE ONE DOWN AND PASS IT AROUND\"";:B=B-1\\n60 IF B+1 THEN 70:B=99: PRINT \""GO TO THE STORE AND BUY SOME MORE\"";\\n70 IF W THEN PRINT \"",\"": IF B THEN PRINT B;: IF B=0 THEN PRINT \""NO MORE\"";\\n80 PRINT \"" BOTTLE\"";: IF B#1 THEN PRINT \""S\"";: PRINT \"" OF BEER\"";\\n90 IF W#1 THEN PRINT \"" ON THE WALL\"";: IF W THEN PRINT \"".\"": NEXT W,B: END \\nRUN"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","For bottles = 99 To 1 Step -1\\n    song$ = song$ + str$(bottles) + \"" bottle\""\\n    If (bottles > 1) Then song$ = song$ + \""s\""\\n    song$ = song$ + \"" of beer on the wall, \"" + str$(bottles) + \"" bottle\""\\n    If (bottles > 1) Then song$ = song$ + \""s\""\\n    song$ = song$ + \"" of beer,\""  + chr$(13) + chr$(10) + \""Take one down, pass it around, \"" + str$(bottles - 1) + \"" bottle\""\\n    If (bottles > 2) Or (bottles = 1) Then song$ = song$ + \""s\""\\n    song$ = song$ + \"" of beer on the wall.\"" + chr$(13) + chr$(10)\\nNext bottles\\nsong$ = song$ + \""No more bottles of beer on the wall, no more bottles of beer.\"" _\\n        + chr$(13) + chr$(10) + \""Go to the store and buy some more, 99 bottles of beer on the wall.\""\\n\\nPrint song$"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","Microsoft Small Basic \\nFor n = 99 To 1 Step -1\\n  If n = 1 Then\\n    bottleText1 = \"" bottle\""\\n    bottleText2 = \""No more bottles\""\\n  ElseIf n = 2 then\\n    bottleText1 = \"" bottles\""\\n    bottleText2 = \""1 bottle\""\\n  Else\\n    bottleText1 = \"" bottles\""\\n    bottleText2 = n-1+\"" bottles\""   \\n  EndIf\\n  TextWindow.WriteLine(n+bottleText1+\"" of beer on the wall\"")\\n  TextWindow.WriteLine(n+bottleText1+\"" of beer\"")\\n  TextWindow.WriteLine(\""Take one down, pass it around\"")\\n  TextWindow.WriteLine(bottleText2+\"" of beer on the wall\"")\\n  TextWindow.WriteLine(\""\"")\\nEndFor\\n"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","\\nint    x=99\\nstring cr,tab,pr,bottles,bottlem,remain\\ncr=chr(13) chr(10)\\ntab=chr(9)\\npr=\""99 BOTTLES\"" cr cr\\nbottles=\"" bottles \""\\nbottlem=\"" bottles \""\\n'\\nfor x=99 to 1 step -1\\n  if x=1\\n    bottles=\"" bottle \""\\n    bottlem=\"" bottles \""\\n    remain=\""No\""\\n  elseif x=2\\n    bottlem=\"" bottle \""\\n    remain=x-1\\n  else\\n    remain=x-1\\n  end if\\n  pr+=\\n  x bottles      \""of beer on the wall\"" cr + \\n  x bottles      \""of beer\"" cr +\\n                 \""Take one down, pass it around\"" cr +\\n  remain bottlem \""of beer on the wall\"" cr +\\n  cr\\nnext\\n'\\nputfile \""t.txt\"",pr \\n"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","#COMPILE EXE\\n#DIM ALL\\n\\nFUNCTION PBMAIN () AS LONG\\n\\n    DIM bottles%\\n    DIM b$\\n    DIM done$\\n    bottles% = 99\\n    b$ = \"" bottles \""\\n    DO\\n        PRINT bottles%; b$; \""of beer hanging on the wall\""\\n        PRINT bottles%; b$; \""of beer...\""\\n        PRINT \""And if one bottle of beer should accidentally be drunk\""\\n        bottles% = bottles% - 1\\n        IF bottles% = 1 THEN\\n            b$ = \"" bottle \""\\n        ELSEIF bottles% = 0 THEN\\n            b$ = \"" bottles \""\\n        ELSE\\n            ' Press on!\\n        END IF\\n        PRINT \""There'll be\""; bottles; b$; \""of beer hanging on the wall\""\\n        PRINT\\n    LOOP UNTIL bottles% = 0\\n\\n\\n    CON.INPUT(\""Press any key to sleep it off\"",done$)\\n\\nEND FUNCTION"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","If OpenConsole()\\n  Define Bottles=99\\n  While Bottles\\n    PrintN(Str(Bottles)+\"" bottles of beer on the wall\"")\\n    PrintN(Str(Bottles)+\"" bottles of beer\"")\\n    PrintN(\""Take one down, pass it around\"")\\n    Bottles-1\\n    PrintN(Str(Bottles)+\"" bottles of beer on the wall\""+#CRLF$)\\n  Wend\\n  \\n  PrintN(#CRLF$+#CRLF$+\""Press ENTER to exit\""):Input()\\n  CloseConsole()\\nEndIf"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","Prototype Wall_Action(*Self, Number.i)\\n\\nStructure WallClass\\n  Inventory.i\\n  AddBottle.Wall_Action\\n  DrinkAndSing.Wall_Action\\nEndStructure\\n\\nProcedure.s _B(n, Short=#False)\\n  Select n\\n    Case 0 : result$=\""No more bottles \""\\n    Case 1 : result$=Str(n)+\"" bottle of beer\""\\n    Default: result$=Str(n)+\"" bottles of beer\""\\n  EndSelect\\n  If Not Short: result$+\"" on the wall\"": EndIf\\n  ProcedureReturn result$+#CRLF$\\nEndProcedure\\n\\nProcedure PrintBottles(*Self.WallClass, n)\\n  Bottles$=\"" bottles of beer \""\\n  Bottle$ =\"" bottle of beer \""\\n  txt$ = _B(*Self\\Inventory)\\n  txt$ + _B(*Self\\Inventory, #True)\\n  txt$ + \""Take one down, pass it around\""+#CRLF$\\n  *Self\\AddBottle(*Self, -1)\\n  txt$ + _B(*self\\Inventory)\\n  PrintN(txt$)\\n  ProcedureReturn *Self\\Inventory\\nEndProcedure\\n\\nProcedure AddBottle(*Self.WallClass, n)\\n  i=*Self\\Inventory+n\\n  If i>=0\\n    *Self\\Inventory=i\\n  EndIf\\nEndProcedure\\n\\nProcedure InitClass()\\n  *class.WallClass=AllocateMemory(SizeOf(WallClass))\\n  If *class\\n    InitializeStructure(*class, WallClass)\\n    With *class\\n      \\AddBottle    =@AddBottle()\\n      \\DrinkAndSing =@PrintBottles()\\n    EndWith\\n  EndIf\\n  ProcedureReturn *class\\nEndProcedure\\n\\nIf OpenConsole()\\n  *MyWall.WallClass=InitClass()\\n  If *MyWall\\n    *MyWall\\AddBottle(*MyWall, 99)\\n    While *MyWall\\DrinkAndSing(*MyWall, #True): Wend\\n    ;\\n    PrintN(#CRLF$+#CRLF$+\""Press ENTER to exit\""):Input()\\n    CloseConsole()\\n  EndIf\\nEndIf"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","dim bottles as Integer = 99\\nWhile bottles > 0\\n   Print(str(bottles) + \"" bottles of beer on the wall\"")\\n   Print(str(bottles) + \"" bottles of beer\"")\\n   Print(\""Take one down, pass it around\"")\\n   bottles = bottles - 1\\n   Print(str(bottles) + \"" bottles of beer on the wall\"")\\nWend"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","b$ = \"" bottles\""\\nfor bottles = 99 To 1 Step -1\\n   If (bottles = 1) then b$ = \"" bottle\""\\n   print  bottles;b$;\"" of beer on the wall, \""\\n   print bottles ;b$;\"" of beer\""\\n   print \""Take one down, pass it around, \""\\n   if bottles = 1 then \\n      print \""No bottles of beer on the wall\""\\n   else\\n      print bottles - 1;b$;\"" of beer on the wall.\"";chr$(10)\\n   end if\\nnext bottles"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","READ b,s$(0),s$(1),a$,b$,c$,d$,e$,f$\\ng$ = CHR$(10)\\nWHILE b > 0\\n    IF b>1 THEN\\n        x=1\\n    ELSE\\n        x=0\\n    ENDIF\\n    IF b-1 <> 1 THEN\\n        y=1\\n    ELSE\\n        y=0\\n    ENDIF\\nPRINT b;a$;s$(x);b$;c$;b;a$;s$(x);b$;\"".\"";g$;d$;b-1;a$;s$(y);b$;c$;g$\\nb = b - 1\\nEND WHILE\\nPRINT e$;a$;\""s\"";b$;c$;e$;a$;\""s\"";b$;\"".\"";g$;f$;a$;\""s\"";b$;c$\\nDATA 99,\""\"",\""s\"",\"" bottle\"",\"" of beer\"",\"" on the wall. \"",\""Take one down, pass it around. \""\\nDATA \""No more\"",\""Go to the store and buy some more. 99\""\\nEND"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","PROGRAM:BEER\\n:For(I,99,1,-1)\\n:Disp I\\n:Disp \""BOTTLES OF BEER\""\\n:Disp \""ON THE WALL,\""\\n:Disp I\\n:Pause \""BOTTLES OF BEER,\""\\n:Disp \""TAKE ONE DOWN,\""\\n:Disp \""PASS IT AROUND,\""\\n:Disp I-1\\n:Disp \""BOTTLES OF BEER\""\\n:Disp \""ON THE WALL.\""\\n:End\\n"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","Prgm\\n  Local i,plural,clockWas,t,k,wait\\n  \""s\"" → plural\\n  0 → k\\n  isClkOn() → clockWas\\n\\n  Define wait() = Prgm\\n  EndPrgm\\n\\n  ClockOn\\n\\n  For i,99,0,–1\\n    Disp \""\""\\n    Disp string(i) & \"" bottle\"" & plural & \"" of beer on the\""\\n    Disp \""wall, \"" & string(i) & \"" bottle\"" & plural & \"" of beer.\""\\n\\n    getTime()[3]→t\\n    While getTime()[3] = t and k = 0 : getKey() → k : EndWhile\\n    If k ≠ 0 Then : Exit : EndIf\\n\\n    Disp \""Take one down, pass it\""\\n    Disp \""around.\""\\n\\n    getTime()[3]→t\\n    While getTime()[3] = t and k = 0 : getKey() → k : EndWhile\\n    If k ≠ 0 Then : Exit : EndIf\\n\\n    If i - 1 = 1 Then\\n      \""\"" → plural\\n    EndIf\\n    If i > 1 Then\\n        Disp string(i-1) & \"" bottle\"" & plural & \"" of beer on the\""\\n        Disp \""wall.\""\\n    Else\\n        Disp \""No more bottles of beer on\""\\n        Disp \""the wall.\""\\n    EndIf\\n\\n    getTime()[3]→t\\n    While abs(getTime()[3] - t)<2 and k = 0 : getKey() → k : EndWhile\\n    If k ≠ 0 Then : Exit : EndIf\\n\\n  EndFor\\n  If not clockWas Then\\n    ClockOff\\n  ENdIf\\nEndPrgm"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","\\n! TrueBASIC v6.007\\n\\nLET bottles = 99\\nLET b$ = \"" bottles \""\\n\\nDO\\n	PRINT bottles; b$; \""of beer hanging on the wall\""\\n	PRINT bottles; b$; \""f beer hanging on the wall\""\\n	PRINT \""And if one bottle of beer should accidentally be drunk\""\\n	LET bottles = bottles -1\\n	IF bottles = 1 THEN\\n		LET b$ = \"" bottle \""\\n	ELSEIF bottles = 0 THEN\\n		LET b$ = \"" bottles \""\\n	ELSE\\n		! Press on\\n	END IF\\n	PRINT \""There'll be\""; bottles; b$; \""of beer hanging on the wall\""\\n	PRINT\\nLOOP UNTIL bottles = 0\\n\\nPRINT \""Press any key to sleep it off\""\\nGET KEY done\\nEND\\n"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","Sub Main()\\n    Const bottlesofbeer As String = \"" bottles of beer\""\\n    Const onthewall As String = \"" on the wall\""\\n    Const takeonedown As String = \""Take one down, pass it around\""\\n    Const onebeer As String = \""1 bottle of beer\""\\n\\n    Dim bottles As Long\\n\\n    For bottles = 99 To 3 Step -1\\n        Debug.Print CStr(bottles) & bottlesofbeer & onthewall\\n        Debug.Print CStr(bottles) & bottlesofbeer\\n        Debug.Print takeonedown\\n        Debug.Print CStr(bottles - 1) & bottlesofbeer & onthewall\\n        Debug.Print\\n    Next\\n\\n    Debug.Print \""2\"" & bottlesofbeer & onthewall\\n    Debug.Print \""2\"" & bottlesofbeer\\n    Debug.Print takeonedown\\n    Debug.Print onebeer & onthewall\\n    Debug.Print\\n\\n    Debug.Print onebeer & onthewall\\n    Debug.Print onebeer\\n    Debug.Print takeonedown\\n    Debug.Print \""No more\"" & bottlesofbeer & onthewall\\n    Debug.Print\\n\\n    Debug.Print \""No\"" & bottlesofbeer & onthewall\\n    Debug.Print \""No\"" & bottlesofbeer\\n    Debug.Print \""Go to the store, buy some more\""\\n    Debug.Print \""99\"" & bottlesofbeer & onthewall\\nEnd Sub"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","Module Module1\\n   Sub Main()\\n       Dim Bottles As Integer\\n       For Bottles = 99 To 0 Step -1\\n           If Bottles = 0 Then\\n               Console.WriteLine(\""No more bottles of beer on the wall, no more bottles of beer.\"")\\n               Console.WriteLine(\""Go to the store and buy some more, 99 bottles of beer on the wall.\"")\\n               Console.ReadLine()\\n           ElseIf Bottles = 1 Then\\n               Console.WriteLine(Bottles & \"" bottle of beer on the wall, \"" & Bottles & \"" bottle of beer.\"")\\n               Console.WriteLine(\""Take one down and pass it around, no more bottles of beer on the wall.\"")\\n               Console.ReadLine()\\n           Else\\n               Console.WriteLine(Bottles & \"" bottles of beer on the wall, \"" & Bottles & \"" bottles of beer.\"")\\n               Console.WriteLine(\""Take one down and pass it around, \"" & (Bottles - 1) & \"" bottles of beer on the wall.\"")\\n               Console.ReadLine()\\n           End If\\n       Next\\n   End Sub\\nEnd Module"
"BASIC","99_Bottles_of_Beer/Basic","99 Bottles of Beer done in any of the BASIC-languages.\\nThis version plays the tune 100 times while printing out the lyrics (not synchronized).\\nWith lyrics and punctuation taken from the 99-bottles-of-beer.net site.\\nRather quickly written and dirty.\\nThis is a OO version, using FBSL v3.5 Beta\\nIMPORTANT NOTE: Integer BASIC was written (and hand-assembled by Woz himself)\\nfor the Apple 1 and original Apple 2.\\nThe Apple 1 has NO support for lower-case letters, and it was an expensive (and later) option on the Apple 2.\\nThe UPPER-CASE output of this example accurately represents the only reasonable solution for those target devices, and therefore cannot be \""fixed\"" for mixed case, only deleted.\\nPlace the following in the \""open\"" event of a console application.\\n\\nPlatform: .NET\\nThis version uses tail recursion and inline if-statements,\\nplus a Static variable to count the number of bottles emptied.\\nUsage: type \""drink 99\"" in the Immediate window of the VBA editor. If you're not a beer drinker, you can specify your own favourite drink as the second argument; for example:\\n","10 DEF FN n$(b)=\""no more\"" AND NOT b\\n20 DEF FN m$(b)=(STR$ b) AND b\\n30 DEF FN o$(b)=\""s\"" AND (b>1)\\n40 DEF FN b$(b)=FN m$(b)+FN n$(b)\\n50 DEF FN p$(b)=FN o$(b)+(\""s\"" AND NOT b)\\n60 FOR i=99 TO 0 STEP -1\\n70 LET x$=FN b$(i)\\n80 IF x$(1)=\""n\"" THEN LET x$(1)=\""N\""\\n90 PRINT x$;\\n100 PRINT \"" bottle\"";FN o$(i);\"" of beer on the wall, \""'FN b$(i);\"" bottle\"";FN p$(i);\"" of beer.\""\\n110 IF NOT i THEN GO TO 160\\n120 PRINT \""Take one down\""'\""and pass it around, \"";\\n130 PRINT FN b$(i-1);\"" bottle\"";FN p$(i-1);\"" of beer on the wall.\""\\n140 PRINT\\n150 NEXT i\\n160 PRINT \""Go to the store and buy some more, 99 bottles of beer on the wall.\""\\n"
"BASIC","A+B","A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.\\n\\nGiven two integers,   A and B.\\nTheir sum needs to be calculated.\\n\\nTwo integers are written in the input stream, separated by space(s):\\n\\nThe required output is one integer:   the sum of A and B.\\n\\n\\n","DEFINT A-Z\\n\\ntryagain:\\nbackhere = CSRLIN\\nINPUT \""\"", i$\\ni$ = LTRIM$(RTRIM$(i$))\\nwhere = INSTR(i$, \"" \"")\\nIF where THEN\\n    a = VAL(LEFT$(i$, where - 1))\\n    b = VAL(MID$(i$, where + 1))\\n    c = a + b\\n    LOCATE backhere, LEN(i$) + 1\\n    PRINT c\\nELSE\\n    GOTO tryagain\\nEND IF"
"BASIC","A+B","A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.\\n\\nGiven two integers,   A and B.\\nTheir sum needs to be calculated.\\n\\nTwo integers are written in the input stream, separated by space(s):\\n\\nThe required output is one integer:   the sum of A and B.\\n\\n\\n","10 BH = PEEK(37)\\n20 INPUT \""\""; A$ : I$ = A$ : VTAB BH : A = PEEK(40) + PEEK(41) * 256 : FOR S  = 0 TO 39 : IF PEEK(A + S) = 160 THEN NEXT S : S = 0\\n40 IF LEN(I$) THEN IF MID$(I$, LEN(I$), 1) = \"" \"" THEN I$ = MID$(I$, 1, LEN(I$) - 1) : GOTO 40RTRIM\\n50 IF LEN(I$) < 3 THEN 10\""TRY AGAIN\\n60 FOR WHERE = 1 TO LEN(I$) : IF MID$(I$, WHERE, 1) <> \"" \"" THEN NEXT WHERE : GOTO 10\""TRY AGAIN\\n70 A% = VAL(LEFT$(I$, WHERE - 1))\\n80 B% = VAL(MID$(I$, WHERE + 1, LEN(I$)))\\n90 C% = A% + B%\\n100 VTAB BH\\n110 HTAB LEN(A$) + 2 + S\\n120 PRINT C%"
"BASIC","A+B","A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.\\n\\nGiven two integers,   A and B.\\nTheir sum needs to be calculated.\\n\\nTwo integers are written in the input stream, separated by space(s):\\n\\nThe required output is one integer:   the sum of A and B.\\n\\n\\n","' A+B\\nINPUT d$\\nPRINT VAL(TOKEN$(d$, 1)) + VAL(TOKEN$(d$, 2))"
"BASIC","A+B","A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.\\n\\nGiven two integers,   A and B.\\nTheir sum needs to be calculated.\\n\\nTwo integers are written in the input stream, separated by space(s):\\n\\nThe required output is one integer:   the sum of A and B.\\n\\n\\n","dim a(2)\\ninput \""Enter two numbers separated by a space?\"", t$\\na = explode(t$,\"" \"")\\nprint t$ + \"" \"" + (a[0] + a[1])"
"BASIC","A+B","A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.\\n\\nGiven two integers,   A and B.\\nTheir sum needs to be calculated.\\n\\nTwo integers are written in the input stream, separated by space(s):\\n\\nThe required output is one integer:   the sum of A and B.\\n\\n\\n","      REPEAT\\n        hereY% = VPOS\\n        INPUT LINE \""\"" q$\\n        hereX% = LEN(q$) + 1\\n        WHILE LEFT$(q$, 1) = \"" \""\\n          q$ = MID$(q$, 2)\\n        ENDWHILE\\n        space% = INSTR(q$, \"" \"")\\n        IF space% THEN\\n          a = VAL(LEFT$(q$, space% - 1))\\n          b = VAL(MID$(q$, space% + 1))\\n          PRINT TAB(hereX%, hereY%) ; a + b\\n        ENDIF\\n      UNTIL FALSE"
"BASIC","A+B","A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.\\n\\nGiven two integers,   A and B.\\nTheir sum needs to be calculated.\\n\\nTwo integers are written in the input stream, separated by space(s):\\n\\nThe required output is one integer:   the sum of A and B.\\n\\n\\n","      REPEAT\\n        INPUT LINE \""\"" q$\\n        space% = INSTR(q$,\"" \"")\\n        PRINT VAL LEFT$(q$,space%-1) + VAL MID$(q$,space%+1)\\n      UNTIL FALSE"
"BASIC","A+B","A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.\\n\\nGiven two integers,   A and B.\\nTheir sum needs to be calculated.\\n\\nTwo integers are written in the input stream, separated by space(s):\\n\\nThe required output is one integer:   the sum of A and B.\\n\\n\\n","10 PRINT \""ENTER TWO NUMBERS, SEPARATED BY A SPACE: \"";\\n20 INPUT X$\\n30 I = 1 : N = LEN(X$)\\n40 IF MID$(X$,I,1)<>\"" \"" AND I\\n\\n==={{header|FreeBASIC}}===\\n' fb 1.05.0 Win64\\n\\nDim As Integer a, b\\nDo\\n  Print \""Enter two integers separated by a space : \"";\\n  Input \""\"", a, b\\n  If Abs(a) > 1000 OrElse Abs(b) > 1000 then\\n    Print \""Both numbers must be in the interval [-1000, 1000] - try again\""\\n    Print\\n  Else\\n    Print \""Their sum is\""; a + b\\n    Exit Do\\n  End If\\nLoop\\nPrint\\nPrint \""Press any key to quit the program\""\\nSleep\\n\\n==={{header|FUZE BASIC}}===\\nINPUT n$\\nPRINT VAL(LEFT$(n$,(LEN(STR$(VAL(n$))))))+VAL(RIGHT$(n$,(LEN(n$)-LEN(STR$(VAL(n$)))-1)))\\nEND\\n\\n==={{header|IS-BASIC}}===\\n100 DO\\n110   INPUT PROMPT \""Ener two integers separated by a comma: \"":A,B\\n120   IF ABS(A)>1000 OR ABS(B)>1000 OR IP(A)<>A OR IP(B)<>B THEN\\n130     PRINT \""Both integers must be in the interval [-1000..1000] - try again.\"":PRINT \\n140   ELSE\\n150     PRINT \""Their sum is\"";A+B\\n160     EXIT DO\\n170   END IF\\n180 LOOP\\n\\n==={{header|Liberty BASIC}}===\\ninput, n$\\nprint  eval(word$(n$,1);\"" + \"";word$(n$,2))\\n\\n==={{header|Sinclair ZX81 BASIC}}===\\n10 INPUT A$\\n20 LET I=1\\n30 IF A$(I)=\"" \"" THEN GOTO 60\\n40 LET I=I+1\\n50 GOTO 30\\n60 PRINT VAL A$( TO I-1)+VAL A$(I+1 TO )\\n"
"BASIC","A+B","A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.\\n\\nGiven two integers,   A and B.\\nTheir sum needs to be calculated.\\n\\nTwo integers are written in the input stream, separated by space(s):\\n\\nThe required output is one integer:   the sum of A and B.\\n\\n\\n","' fb 1.05.0 Win64\\n\\nDim As Integer a, b\\nDo\\n  Print \""Enter two integers separated by a space : \"";\\n  Input \""\"", a, b\\n  If Abs(a) > 1000 OrElse Abs(b) > 1000 then\\n    Print \""Both numbers must be in the interval [-1000, 1000] - try again\""\\n    Print\\n  Else\\n    Print \""Their sum is\""; a + b\\n    Exit Do\\n  End If\\nLoop\\nPrint\\nPrint \""Press any key to quit the program\""\\nSleep"
"BASIC","A+B","A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.\\n\\nGiven two integers,   A and B.\\nTheir sum needs to be calculated.\\n\\nTwo integers are written in the input stream, separated by space(s):\\n\\nThe required output is one integer:   the sum of A and B.\\n\\n\\n","INPUT n$\\nPRINT VAL(LEFT$(n$,(LEN(STR$(VAL(n$))))))+VAL(RIGHT$(n$,(LEN(n$)-LEN(STR$(VAL(n$)))-1)))\\nEND"
"BASIC","A+B","A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.\\n\\nGiven two integers,   A and B.\\nTheir sum needs to be calculated.\\n\\nTwo integers are written in the input stream, separated by space(s):\\n\\nThe required output is one integer:   the sum of A and B.\\n\\n\\n","100 DO\\n110   INPUT PROMPT \""Ener two integers separated by a comma: \"":A,B\\n120   IF ABS(A)>1000 OR ABS(B)>1000 OR IP(A)<>A OR IP(B)<>B THEN\\n130     PRINT \""Both integers must be in the interval [-1000..1000] - try again.\"":PRINT \\n140   ELSE\\n150     PRINT \""Their sum is\"";A+B\\n160     EXIT DO\\n170   END IF\\n180 LOOP"
"BASIC","A+B","A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.\\n\\nGiven two integers,   A and B.\\nTheir sum needs to be calculated.\\n\\nTwo integers are written in the input stream, separated by space(s):\\n\\nThe required output is one integer:   the sum of A and B.\\n\\n\\n","input, n$\\nprint  eval(word$(n$,1);\"" + \"";word$(n$,2))"
"BASIC","A+B","A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.\\n\\nGiven two integers,   A and B.\\nTheir sum needs to be calculated.\\n\\nTwo integers are written in the input stream, separated by space(s):\\n\\nThe required output is one integer:   the sum of A and B.\\n\\n\\n","10 INPUT A$\\n20 LET I=1\\n30 IF A$(I)=\"" \"" THEN GOTO 60\\n40 LET I=I+1\\n50 GOTO 30\\n60 PRINT VAL A$( TO I-1)+VAL A$(I+1 TO )"
"BASIC","ABC_Problem","\\nYou are given a collection of ABC blocks   (maybe like the ones you had when you were a kid).\\nThere are twenty blocks with two letters on each block.\\nA complete alphabet is guaranteed amongst all sides of the blocks.\\nThe sample collection of blocks:\\n\\nWrite a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks.\\n\\nThe rules are simple:\\n\\n\\nThe program uses one ASSIST macro (XPRNT) to keep the code as short as possible.\\n","\\n' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '\\n' ABC_Problem                                       '\\n'                                                   '\\n' Developed by A. David Garza Marín in VB-DOS for   '\\n' RosettaCode. November 29, 2016.                   '\\n' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '\\n\\n' Comment the following line to run it in QB or QBasic\\nOPTION EXPLICIT  ' Modify to OPTION _EXPLICIT for QB64\\n\\n' SUBs and FUNCTIONs\\nDECLARE SUB doCleanBlocks ()\\nDECLARE FUNCTION ICanMakeTheWord (WhichWord AS STRING) AS INTEGER\\nDECLARE SUB doReadBlocks ()\\n\\n' rBlock Data Type\\nTYPE regBlock\\n  Block AS STRING * 2\\n  Used AS INTEGER\\nEND TYPE\\n\\n' Initialize\\nCONST False = 0, True = NOT False, HMBlocks = 20\\nDATA \""BO\"", \""XK\"", \""DQ\"", \""CP\"", \""NA\"", \""GT\"",\""RE\"", \""TG\""\\nDATA \""QD\"", \""FS\"", \""JW\"", \""HU\"", \""VI\"", \""AN\"", \""OB\"", \""ER\""\\nDATA \""FS\"", \""LY\"", \""PC\"",\""ZM\""\\n\\nDIM rBlock(1 TO HMBlocks) AS regBlock\\nDIM i AS INTEGER, aWord AS STRING, YorN AS STRING\\n\\ndoReadBlocks ' Read the data in the blocks\\n\\n'-------------- Main program cycle ------------------\\nCLS\\nPRINT \""This program has the following blocks: \"";\\nFOR i = 1 TO HMBlocks\\n  PRINT rBlock(i).Block; \""|\"";\\nNEXT i\\nPRINT : PRINT\\nPRINT \""Please, write a word or a short sentence to see if the available\""\\nPRINT \""blocks can make it. If so, I will tell you.\""\\nDO\\n  doCleanBlocks ' Clean all blocks\\n  PRINT\\n  INPUT \""Which is the word\""; aWord\\n  aWord = LTRIM$(RTRIM$(aWord))\\n\\n  IF aWord <> \""\"" THEN\\n    IF ICanMakeTheWord(aWord) THEN\\n      PRINT \""Yes, i can make it.\""\\n    ELSE\\n      PRINT \""No, I can't make it.\""\\n    END IF\\n  ELSE\\n    PRINT \""At least, you need to type a letter.\""\\n  END IF\\n\\n  PRINT\\n  PRINT \""Do you want to try again (Y/N) \"";\\n  DO\\n    YorN = INPUT$(1)\\n    YorN = UCASE$(YorN)\\n  LOOP UNTIL YorN = \""Y\"" OR YorN = \""N\""\\n  PRINT YorN\\n\\nLOOP UNTIL YorN = \""N\""\\n' -------------- End of Main program ----------------\\nEND\\n\\nSUB doCleanBlocks ()\\n  ' Var\\n  SHARED rBlock() AS regBlock\\n  DIM i AS INTEGER\\n\\n  ' Will clean the Used status of all blocks\\n  FOR i = 1 TO HMBlocks\\n    rBlock(i).Used = False\\n  NEXT i\\n\\nEND SUB\\n\\nSUB doReadBlocks ()\\n  ' Var\\n  SHARED rBlock() AS regBlock\\n  DIM i AS INTEGER\\n\\n  ' Will read the block values from DATA\\n  FOR i = 1 TO HMBlocks\\n    READ rBlock(i).Block\\n  NEXT i\\nEND SUB\\n\\nFUNCTION ICanMakeTheWord (WhichWord AS STRING) AS INTEGER ' Comment AS INTEGER to run in QBasic, QB64 and QuickBASIC\\n  ' Var\\n  SHARED rBlock() AS regBlock\\n  DIM i AS INTEGER, l AS INTEGER, j AS INTEGER, iYesICan AS INTEGER\\n  DIM c AS STRING, sUWord AS STRING\\n\\n  ' Will evaluate if can make the word\\n  sUWord = UCASE$(WhichWord)\\n  l = LEN(sUWord)\\n  i = 0\\n\\n  DO\\n    i = i + 1\\n    iYesICan = False\\n    c = MID$(sUWord, i, 1)\\n    j = 0\\n    DO\\n      j = j + 1\\n      IF NOT rBlock(j).Used THEN\\n        iYesICan = (INSTR(rBlock(j).Block, c) > 0)\\n        rBlock(j).Used = iYesICan\\n      END IF\\n    LOOP UNTIL j >= HMBlocks OR iYesICan\\n\\n  LOOP UNTIL i >= l OR NOT iYesICan\\n\\n  ' The result will depend on the last value of\\n  '  iYesICan variable. If the last value is True\\n  '  is because the function found even the last\\n  '  letter analyzed.\\n  ICanMakeTheWord = iYesICan\\n\\nEND FUNCTION\\n"
"BASIC","ABC_Problem","\\nYou are given a collection of ABC blocks   (maybe like the ones you had when you were a kid).\\nThere are twenty blocks with two letters on each block.\\nA complete alphabet is guaranteed amongst all sides of the blocks.\\nThe sample collection of blocks:\\n\\nWrite a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks.\\n\\nThe rules are simple:\\n\\n\\nThe program uses one ASSIST macro (XPRNT) to keep the code as short as possible.\\n","10 W$ = \""A\"" : GOSUB 100\\n20 W$ = \""BARK\"" : GOSUB 100\\n30 W$ = \""BOOK\"" : GOSUB 100\\n40 W$ = \""TREAT\"" : GOSUB 100\\n50 W$ = \""COMMON\"" : GOSUB 100\\n60 W$ = \""SQUAD\"" : GOSUB 100\\n70 W$ = \""CONFUSE\"" : GOSUB 100\\n80 END\\n90 REM ********************************\\n100 B$=\""BOXKDQCPNAGTRETGQDFSJWHUVIANOBERFSLYPCZM\""\\n110 FOR I=1 TO LEN(W$)\\n120    BL = LEN(B$)\\n130    FOR J=1 TO BL STEP 2\\n140      C$=MID$(B$,J,1): D$=MID$(B$,J+1,1)\\n150      X$=MID$(W$,I,1)\\n160      IF C$<>X$ AND D$<>X$ THEN GOTO 190\\n170      B$ = LEFT$(B$,J-1)+RIGHT$(B$,BL-J-1)\\n180      GOTO 210\\n190   NEXT J\\n200   IF J>BL-1 THEN GOTO 240\\n210 NEXT I\\n220 PRINT W$\"" -> YES\""\\n230 RETURN\\n240 PRINT W$\"" -> NO\""\\n250 RETURN"
"BASIC","ABC_Problem","\\nYou are given a collection of ABC blocks   (maybe like the ones you had when you were a kid).\\nThere are twenty blocks with two letters on each block.\\nA complete alphabet is guaranteed amongst all sides of the blocks.\\nThe sample collection of blocks:\\n\\nWrite a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks.\\n\\nThe rules are simple:\\n\\n\\nThe program uses one ASSIST macro (XPRNT) to keep the code as short as possible.\\n"," 10 LET B$=\""BOXKDQCPNAGTRETGQDFSJWHUVIANOBERFSLYPCZM\""\\n 20 INPUT W$\\n 30 FOR I=1 TO LEN W$\\n 40 FOR J=1 TO LEN B$ STEP 2\\n 50 IF B$(J)<>W$(I) AND B$(J+1)<>W$(I) THEN GOTO 100\\n 60 LET B$=B$( TO J-1)+B$(J+2 TO )\\n 70 NEXT I\\n 80 PRINT \""YES\""\\n 90 STOP\\n100 NEXT J\\n110 PRINT \""NO\"""
"BASIC","Ackermann_function","The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.\\n\\nThe Ackermann function is usually defined as follows:\\n\\n","DECLARE FUNCTION ack! (m!, n!)\\n\\nFUNCTION ack (m!, n!)\\n       IF m = 0 THEN ack = n + 1\\n\\n       IF m > 0 AND n = 0 THEN\\n               ack = ack(m - 1, 1)\\n       END IF\\n       IF m > 0 AND n > 0 THEN\\n               ack = ack(m - 1, ack(m, n - 1))\\n       END IF\\nEND FUNCTION"
"BASIC","Address_of_a_variable","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\n\\nDemonstrate how to get the address of a variable and how to set the address of a variable.\\n\\nTo get the address of a variable, use LA (load address) instead of L (load):\\nTo set a variable dynamically at the same address of an other variable, use a DSECT (dummy section):\\nSet the address of a variable to address A100 in hexadecimal\\nSet the address of one variable to the address of another variable, creating an overlay.\\nBasically ALGOL 68 refuses to let the programmer access the memory directly.\\nThe language does allow \""references\"" any variables.\\nThese references are effectively the address a particular variable.\\nBut the value of the actual address is not available\\nfor printing or any arithmetic.\\n","'get a variable's address:\\nDIM x AS INTEGER, y AS LONG\\ny = VARPTR(x)\\n\\n'can't set the address, but can access a given memory location... 1 byte at a time\\nDIM z AS INTEGER\\nz = PEEK(y)\\nz = z + (PEEK(y) * 256)"
"BASIC","Align_columns","Given a text file of many lines, where fields within a line\\nare delineated by a single 'dollar' character, write a program\\nthat aligns each column of fields by ensuring that words in each\\ncolumn are separated by at least one space.\\nFurther, allow for each word in a column to be either left\\njustified, right justified, or center justified within its column.\\nUse the following text to test your programs:\\nNote that:\\n\\n","      DATA 6\\n      DATA \""Given$a$text$file$of$many$lines,$where$fields$within$a$line$\""\\n      DATA \""are$delineated$by$a$single$'dollar'$character,$write$a$program\""\\n      DATA \""that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\""\\n      DATA \""column$are$separated$by$at$least$one$space.\""\\n      DATA \""Further,$allow$for$each$word$in$a$column$to$be$either$left$\""\\n      DATA \""justified,$right$justified,$or$center$justified$within$its$column.\""\\n      \\n      REM First find the maximum length of a 'word':\\n      max% = 0\\n      READ nlines%\\n      FOR Line% = 1 TO nlines%\\n        READ text$\\n        REPEAT\\n          word$ = FNword(text$, \""$\"")\\n          IF LEN(word$) > max% THEN max% = LEN(word$)\\n        UNTIL word$ = \""\""\\n      NEXT Line%\\n      @% = max% : REM set column width\\n      \\n      REM Now display the aligned text:\\n      RESTORE\\n      READ nlines%\\n      FOR Line% = 1 TO nlines%\\n        READ text$\\n        REPEAT\\n          word$ = FNword(text$, \""$\"")\\n          PRINT FNjustify(word$, max%, \""left\""),;\\n        UNTIL word$ = \""\""\\n        PRINT\\n      NEXT Line%\\n      \\n      END\\n      \\n      DEF FNword(text$, delim$)\\n      PRIVATE delim%\\n      LOCAL previous%\\n      IF delim% = 0 THEN\\n        previous% = 1\\n      ELSE\\n        previous% = delim% + LEN(delim$)\\n      ENDIF\\n      delim% = INSTR(text$+delim$, delim$, previous%)\\n      IF delim% = 0 THEN\\n        = \""\""\\n      ELSE\\n        = MID$(text$, previous%, delim%-previous%) + \"" \""\\n      ENDIF\\n      \\n      DEF FNjustify(word$, field%, mode$)\\n      IF word$ = \""\"" THEN = \""\""\\n      CASE mode$ OF\\n        WHEN \""center\"": = STRING$((field%-LEN(word$)) DIV 2, \"" \"") + word$\\n        WHEN \""right\"": = STRING$(field%-LEN(word$), \"" \"") + word$\\n      ENDCASE\\n      = word$"
"BASIC","Align_columns","Given a text file of many lines, where fields within a line\\nare delineated by a single 'dollar' character, write a program\\nthat aligns each column of fields by ensuring that words in each\\ncolumn are separated by at least one space.\\nFurther, allow for each word in a column to be either left\\njustified, right justified, or center justified within its column.\\nUse the following text to test your programs:\\nNote that:\\n\\n","10 rem ********************************\\n20 rem print words in columns\\n30 rem commodore basic 2.0\\n40 rem ********************************\\n50 print chr$(14) : rem change to upper/lower case set\\n60 gosub 140      : rem find length of longest word\\n70 algn$ = \""left\""\\n80 gosub 260      : rem print aligned text\\n90 algn$ = \""center\""\\n100 gosub 260\\n110 algn$ = \""right\""\\n120 gosub 260\\n130 end\\n140 rem *** find length of longest word\\n150 mx=0\\n160 for i=1 to 6\\n170     read a$\\n180     n=1\\n190     for j=1 to len(a$)\\n200         if mid$(a$,j,1)<>\""$\"" then n=n+1: goto 230\\n210         if mx\""$\"" then n=n+1 : goto 380\\n360         gosub 440 : rem print word\\n370         n=1\\n380     next\\n390     if n>1 then gosub 440\\n400 next\\n410 print\\n420 return\\n430 rem ********* print word **********\\n440 b$ = mid$(a$,j-n+1,n-1)\\n450 b = len(b$)\\n460 if algn$ = \""center\"" then 520\\n470 if algn$ = \""right\"" then 570\\n480 if c+b<40 and c+mx>40 then print b$: c=1: return\\n490 if c+mx>40 then print : c=1\\n500 print b$;left$(s$,mx-b);: c=c+mx\\n510 return\\n520 if c+mx>40 then print : c=1\\n530 bb=(mx-b)/2 : ba=bb\\n540 if bb>1 and int(bb)=bb then ba=bb-1\\n550 print left$(s$,ba);b$;left$(s$,bb);: c=c+mx\\n560 return\\n570 if c+mx>40 then print : c=1\\n580 print left$(s$,mx-b);b$;: c=c+mx\\n590 return\\n600 rem *********** the words *********\\n610 data \""Given$a$text$file$of$many$lines,$where$fields$within$a$line$\""\\n620 data \""are$delineated$by$a$single$'dollar'$character,$write$a$program\""\\n630 data \""that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\""\\n640 data \""column$are$separated$by$at$least$one$space.\""\\n650 data \""Further,$allow$for$each$word$in$a$column$to$be$either$left$\""\\n660 data \""justified,$right$justified,$or$center$justified$within$its$column\"""
"BASIC","Animate_a_pendulum","One good way of making an animation is by simulating a physical system and illustrating the variables in that system using a dynamically changing graphical display.\\nThe classic such physical system is a simple gravity pendulum.\\nFor this task, create a simple physical model of a pendulum and animate it.\\nThis does not use a GUI, it simply animates the pendulum and prints out the positions. If you want, you can replace the output method with graphical update methods.\\nX and Y are relative positions of the pendulum to the anchor.\\npendulums.ads:\\npendulums.adb:\\nexample main.adb:\\n","      MODE 8\\n      *FLOAT 64\\n      VDU 23,23,4;0;0;0; : REM Set line thickness\\n      \\n      theta = RAD(40) : REM initial displacement\\n      g = 9.81 : REM acceleration due to gravity\\n      l = 0.50 : REM length of pendulum in metres\\n      \\n      REPEAT\\n        PROCpendulum(theta, l)\\n        WAIT 1\\n        PROCpendulum(theta, l)\\n        accel = - g * SIN(theta) / l / 100\\n        speed += accel / 100\\n        theta += speed\\n      UNTIL FALSE\\n      END\\n      \\n      DEF PROCpendulum(a, l)\\n      LOCAL pivotX, pivotY, bobX, bobY\\n      pivotX = 640\\n      pivotY = 800\\n      bobX = pivotX + l * 1000 * SIN(a)\\n      bobY = pivotY - l * 1000 * COS(a)\\n      GCOL 3,6\\n      LINE pivotX, pivotY, bobX, bobY\\n      GCOL 3,11\\n      CIRCLE FILL bobX + 24 * SIN(a), bobY - 24 * COS(a), 24\\n      ENDPROC"
"BASIC","Animate_a_pendulum","One good way of making an animation is by simulating a physical system and illustrating the variables in that system using a dynamically changing graphical display.\\nThe classic such physical system is a simple gravity pendulum.\\nFor this task, create a simple physical model of a pendulum and animate it.\\nThis does not use a GUI, it simply animates the pendulum and prints out the positions. If you want, you can replace the output method with graphical update methods.\\nX and Y are relative positions of the pendulum to the anchor.\\npendulums.ads:\\npendulums.adb:\\nexample main.adb:\\n","10 GOSUB 1000\\n20 THETA = π/2\\n30 G = 9.81\\n40 L = 0.5\\n50 SPEED = 0\\n60 PX = 20\\n70 PY = 1\\n80 BX = PX+L*20*SIN(THETA)\\n90 BY = PY-L*20*COS(THETA)\\n100 PRINT CHR$(147);\\n110 FOR X=PX TO BX STEP (BX-PX)/10\\n120 Y=PY+(X-PX)*(BY-PY)/(BX-PX)\\n130 PRINT CHR$(19);LEFT$(X$,X);LEFT$(Y$,Y);\"".\""\\n140 NEXT\\n150 PRINT CHR$(19);LEFT$(X$,BX);LEFT$(Y$,BY);CHR$(113)\\n160 ACCEL=G*SIN(THETA)/L/50\\n170 SPEED=SPEED+ACCEL/10\\n180 THETA=THETA+SPEED\\n190 GOTO 80\\n980 REM ** SETUP STRINGS TO BE USED **\\n990 REM ** FOR CURSOR POSITIONING   **\\n1000 FOR I=0 TO 39: X$ = X$+CHR$(29): NEXT\\n1010 FOR I=0 TO 24: Y$ = Y$+CHR$(17): NEXT\\n1020 RETURN"
"BASIC","Animate_a_pendulum","One good way of making an animation is by simulating a physical system and illustrating the variables in that system using a dynamically changing graphical display.\\nThe classic such physical system is a simple gravity pendulum.\\nFor this task, create a simple physical model of a pendulum and animate it.\\nThis does not use a GUI, it simply animates the pendulum and prints out the positions. If you want, you can replace the output method with graphical update methods.\\nX and Y are relative positions of the pendulum to the anchor.\\npendulums.ads:\\npendulums.adb:\\nexample main.adb:\\n","Const PI = 3.141592920\\nDim As Double theta, g, l, accel, speed, px, py, bx, by\\ntheta = PI/2\\ng = 9.81\\nl = 1\\nspeed = 0\\npx = 320\\npy = 10\\nScreen 17 '640x400 graphic\\nDo\\n    bx=px+l*300*Sin(theta)\\n    by=py-l*300*Cos(theta)\\n    Cls\\n    Line (px,py)-(bx,by)\\n    Circle (bx,by),5,,,,,F\\n    accel=g*Sin(theta)/l/100\\n    speed=speed+accel/100\\n    theta=theta+speed\\n    Draw String (0,370), \""Pendulum\""\\n    Draw String (0,385), \""Press any key to quit\""\\n    Sleep 10\\nLoop Until Inkey()<>\""\"""
"BASIC","Animate_a_pendulum","One good way of making an animation is by simulating a physical system and illustrating the variables in that system using a dynamically changing graphical display.\\nThe classic such physical system is a simple gravity pendulum.\\nFor this task, create a simple physical model of a pendulum and animate it.\\nThis does not use a GUI, it simply animates the pendulum and prints out the positions. If you want, you can replace the output method with graphical update methods.\\nX and Y are relative positions of the pendulum to the anchor.\\npendulums.ads:\\npendulums.adb:\\nexample main.adb:\\n","100 PROGRAM \""Pendulum.bas\""\\n110 LET THETA=RAD(50):LET G=9.81:LET L=.5\\n120 CALL INIC\\n130 CALL DRAWING\\n140 CALL ANIMATE\\n150 CALL RESET\\n160 END\\n170 DEF INIC\\n180   CLOSE #102\\n190   OPTION ANGLE RADIANS\\n200   SET STATUS OFF:SET INTERRUPT STOP OFF:SET BORDER 56\\n210   SET VIDEO MODE 1:SET VIDEO COLOR 1:SET VIDEO X 14:SET VIDEO Y 8\\n220   FOR I=1 TO 24\\n230     OPEN #I:\""video:\""\\n240     SET #I:PALETTE 56,0,255,YELLOW\\n250   NEXT\\n260 END DEF\\n270 DEF DRAWING\\n280   LET SPD=0\\n290   FOR I=1 TO 24\\n300     DISPLAY #I:AT 3 FROM 1 TO 8\\n310     SET #I:INK 2\\n320     PLOT #I:224,280,ELLIPSE 10,10\\n330     PLOT #I:0,280;214,280,234,280;446,280\\n340     SET #I:INK 1\\n350     CALL PENDULUM(THETA,L,I)\\n360     LET ACC=-G*SIN(THETA)/L/100\\n370     LET SPD=SPD+ACC/10.5\\n380     LET THETA=THETA+SPD\\n390   NEXT\\n400 END DEF\\n410 DEF PENDULUM(A,L,CH)\\n420   LET PX=224:LET PY=280\\n430   LET BX=PX+L*460*SIN(A)\\n440   LET BY=PY-L*460*COS(A)\\n450   PLOT #CH:PX,PY;BX,BY\\n460   PLOT #CH:BX+24*SIN(A),BY-24*COS(A),ELLIPSE 20,20,\\n470   SET #CH:INK 3:PLOT #CH:PAINT\\n480 END DEF\\n490 DEF ANIMATE\\n500   DO\\n510     FOR I=1 TO 24\\n520       DISPLAY #I:AT 3 FROM 1 TO 8\\n530     NEXT \\n540     FOR I=23 TO 2 STEP-1\\n550       DISPLAY #I:AT 3 FROM 1 TO 8\\n560     NEXT \\n570   LOOP UNTIL INKEY$=CHR$(27)\\n580 END DEF\\n590 DEF RESET\\n600   TEXT 40:SET STATUS ON:SET INTERRUPT STOP ON:SET BORDER 0\\n610   FOR I=24 TO 1 STEP-1\\n620     CLOSE #I\\n630   NEXT\\n640 END DEF"
"BASIC","Archimedean_spiral","The Archimedean spiral is a spiral named after the Greek mathematician Archimedes.\\n\\nAn Archimedean spiral can be described by the equation:\\nwith real numbers a and b.\\n\\nDraw an Archimedean spiral.\\n\\n\\n","110 LET H = 96\\n120 LET W = H + H / 2\\n130 HGR2 \\n140 HCOLOR= 3\\n150 LET A = 1\\n160 LET B = 9\\n170 LET PI = 3.1415926535\\n180 LET M = 10 * PI\\n190 LET S = .02\\n200 FOR T = S TO M STEP S\\n210     LET R = A + B * T\\n220     LET X = R *  COS (T) + W\\n230     LET Y = R *  SIN (T) + H\\n240     IF X < 0 THEN  290\\n250     IF Y < 0 THEN  290 \\n260     IF X > 279 THEN  290  \\n270     IF Y > 191 THEN  290\\n280     HPLOT X,Y\\n290 NEXT\\n"
"BASIC","Archimedean_spiral","The Archimedean spiral is a spiral named after the Greek mathematician Archimedes.\\n\\nAn Archimedean spiral can be described by the equation:\\nwith real numbers a and b.\\n\\nDraw an Archimedean spiral.\\n\\n\\n","\\n# Basic-256 ver 1.1.4\\n# Archimedean Spiral\\n\\nwidth = 430 : height = 430\\ngraphsize width, height\\nrect 0,0, graphwidth,graphheight\\npenwidth 1\\ncolor green\\n\\nx = width/2 : y = height/2            # Center of graphics window\\ni = 1 : t = 0 : xn = 0 : yn = 0       # Initial values\\niter = 150 : q = 30\\n\\n\\nline x,0,x,height\\nline 0,y,width,y \\n\\npenwidth 2\\ncolor red\\n\\nwhile i <= iter\\n    t = i / q * pi\\n    xn = (1 + (1 * t)) * cos(t) +x\\n    yn = (1 + (1 * t)) * sin(t) +y\\n    line x,y,xn,yn\\n    x = xn : y = yn    \\n    print i + chr(9) + int(x) + chr(9) + int(y) + chr(9) + int(t)    # chr(9) = TAB\\n    i += 1\\n\\nend while\\n\\nimgsave \""spiral-Basic-256.png\"", \""PNG\""\\n"
"BASIC","Archimedean_spiral","The Archimedean spiral is a spiral named after the Greek mathematician Archimedes.\\n\\nAn Archimedean spiral can be described by the equation:\\nwith real numbers a and b.\\n\\nDraw an Archimedean spiral.\\n\\n\\n","1 REM       ARCHIMEDEAN SPIRAL\\n2 REM   USING COMMODORE BASIC 7.0\\n3 REM      OF THE COMMODORE 128\\n4 REM **********************************\\n10 GRAPHIC 1,1\\n20 A = 1.5\\n30 B = 0.7\\n40 X0 = 160 : Y0 = 100\\n50 FOR T = 0 TO 40*π STEP 0.2\\n60 R = A+B*T\\n70 X = R*COS(T)+160 : Y = R*SIN(T)+100\\n80 DRAW 1,X0,Y0 TO X,Y\\n90 X0 = X : Y0 = Y\\n100 NEXT T\\n110 GOTO 110"
"BASIC","Archimedean_spiral","The Archimedean spiral is a spiral named after the Greek mathematician Archimedes.\\n\\nAn Archimedean spiral can be described by the equation:\\nwith real numbers a and b.\\n\\nDraw an Archimedean spiral.\\n\\n\\n","' version 16-10-2016\\n' compile with: fbc -s gui\\n\\nConst As double      deg2rad = Atn(1) * 4 / 180    ' pi = atn(1) * 4, pi/180\\n\\nConst As UInteger screensize = 600                 ' size of window in pixels     \\nConst As Double        turns = 5                   ' number of turns\\nConst As UInteger   halfscrn = screensize \\ 2    \\nConst As uinteger         sf = (turns * (screensize - 100)) / halfscrn \\n\\nScreenRes screensize, screensize, 32   ' screen 600 * 600 pixels, 4 byte color\\n\\nDim As Double r, x, y \\n\\nFor r = 0 To turns * 360 Step 0.05\\n  x = Cos(r * deg2rad) * r / sf \\n  y = Sin(r * deg2rad) * r / sf\\n  PSet(halfscrn + x, halfscrn - y), RGB(255, 255, 255)  \\nNext\\n\\n\\n' empty keyboard buffer \\nWhile InKey <> \""\"" : Wend\\nPrint : Print \""hit any key to end program\""\\nSleep\\nEnd"
"BASIC","Archimedean_spiral","The Archimedean spiral is a spiral named after the Greek mathematician Archimedes.\\n\\nAn Archimedean spiral can be described by the equation:\\nwith real numbers a and b.\\n\\nDraw an Archimedean spiral.\\n\\n\\n","100 GRAPHICS LORES 2\\n110 OPTION ANGLE DEGREES\\n120 PLOT 640,360,ANGLE 90;\\n130 FOR I=2 TO 33.2 STEP .05\\n140   PLOT FORWARD I,LEFT 5;\\n150 NEXT"
"BASIC","Archimedean_spiral","The Archimedean spiral is a spiral named after the Greek mathematician Archimedes.\\n\\nAn Archimedean spiral can be described by the equation:\\nwith real numbers a and b.\\n\\nDraw an Archimedean spiral.\\n\\n\\n","    'archimedean spiral.bas\\n    'runs in Run Basic\\n    'Run Basic website http://www.runbasic.com\\n    'From Rosettacode.org/wiki/ *** Liberty_BASIC\\n\\n  graphic #g, 300,300 'width and height - the center is 150\\n  c = 255  '255 for white '0 for black\\n  print \""Welcome to the Arch-Spiral Program\""\\n\\n  pi=acs(-1)\\n  nLoops = 5\\n   #g cls(\""blue\"") 'blue background color\\n   #g color(c,c,c) 'set line color - see color above\\n\\n  for t=0 to 2*pi*nLoops step 0.01\\n     'c = c - 1  'changes color parameter\\n     x=100*t/(2*pi*nLoops)*cos(t)+150  '150x150 is the center\\n     y=100*t/(2*pi*nLoops)*sin(t)+150 \\n     #g color(c,c,c)  'changes color\\n     #g set(x,y)\\n     'if c <1 then c=255\\n  next\\n    render #g\\n\\n  print \""Thank you and Goodbye\""\\n  end\\nEnd"
"BASIC","Archimedean_spiral","The Archimedean spiral is a spiral named after the Greek mathematician Archimedes.\\n\\nAn Archimedean spiral can be described by the equation:\\nwith real numbers a and b.\\n\\nDraw an Archimedean spiral.\\n\\n\\n","SCREEN 12\\nWINDOW (-2.67, -2!)-(2.67, 2!)\\nPI = 4 * ATN(1)\\nH = PI / 40\\nA = .2: B = .05\\nPSET (A, 0)\\nFOR I = 0 TO 400\\n    T = I * H\\n    X = (A + B * T) * COS(T)\\n    Y = (A + B * T) * SIN(T)\\n    LINE -(X, Y)\\nNEXT"
"BASIC","Archimedean_spiral","The Archimedean spiral is a spiral named after the Greek mathematician Archimedes.\\n\\nAn Archimedean spiral can be described by the equation:\\nwith real numbers a and b.\\n\\nDraw an Archimedean spiral.\\n\\n\\n","10 LET A=1.5\\n20 LET B=0.7\\n30 FOR T=0 TO 7*PI STEP 0.05\\n40 LET R=A+B*T\\n50 PLOT R*COS T+32,R*SIN T+22\\n60 NEXT T"
"BASIC","Arithmetic-geometric_mean","\\nWrite a function to compute the arithmetic-geometric mean of two numbers.\\n[1]\\nThe arithmetic-geometric mean of two numbers can be (usefully) denoted as \\n\\n\\n\\n\\na\\ng\\nm\\n\\n(\\na\\n,\\ng\\n)\\n\\n\\n{\\displaystyle \\mathrm {agm} (a,g)}\\n\\n, and is equal to the limit of the sequence:\\nSince the limit of \\n\\n\\n\\n\\na\\n\\nn\\n\\n\\n−\\n\\ng\\n\\nn\\n\\n\\n\\n\\n{\\displaystyle a_{n}-g_{n}}\\n\\n tends (rapidly) to zero with iterations, this is an efficient method.\\nDemonstrate the function by calculating:\\n\\n\\n","10 A = 1\\n20 G = 1/SQR(2)\\n30 GOSUB 100\\n40 PRINT A\\n50 END\\n100 TA = A\\n110 A = (A+G)/2\\n120 G = SQR(TA*G)\\n130 IF A\\n\\n==={{header|BBC BASIC}}===\\n{{works with|BBC BASIC for Windows}}\\n      *FLOAT 64\\n      @% = &1010\\n      PRINT FNagm(1, 1/SQR(2))\\n      END\\n      \\n      DEF FNagm(a,g)\\n      LOCAL ta\\n      REPEAT\\n        ta = a\\n        a = (a+g)/2\\n        g = SQR(ta*g)\\n      UNTIL a = ta\\n      = a\\n\\nProduces this output:\\n<pre>\\n0.8472130847939792\\n"
"BASIC","Arithmetic-geometric_mean","\\nWrite a function to compute the arithmetic-geometric mean of two numbers.\\n[1]\\nThe arithmetic-geometric mean of two numbers can be (usefully) denoted as \\n\\n\\n\\n\\na\\ng\\nm\\n\\n(\\na\\n,\\ng\\n)\\n\\n\\n{\\displaystyle \\mathrm {agm} (a,g)}\\n\\n, and is equal to the limit of the sequence:\\nSince the limit of \\n\\n\\n\\n\\na\\n\\nn\\n\\n\\n−\\n\\ng\\n\\nn\\n\\n\\n\\n\\n{\\displaystyle a_{n}-g_{n}}\\n\\n tends (rapidly) to zero with iterations, this is an efficient method.\\nDemonstrate the function by calculating:\\n\\n\\n","      *FLOAT 64\\n      @% = &1010\\n      PRINT FNagm(1, 1/SQR(2))\\n      END\\n      \\n      DEF FNagm(a,g)\\n      LOCAL ta\\n      REPEAT\\n        ta = a\\n        a = (a+g)/2\\n        g = SQR(ta*g)\\n      UNTIL a = ta\\n      = a\\n"
"BASIC","Arithmetic-geometric_mean","\\nWrite a function to compute the arithmetic-geometric mean of two numbers.\\n[1]\\nThe arithmetic-geometric mean of two numbers can be (usefully) denoted as \\n\\n\\n\\n\\na\\ng\\nm\\n\\n(\\na\\n,\\ng\\n)\\n\\n\\n{\\displaystyle \\mathrm {agm} (a,g)}\\n\\n, and is equal to the limit of the sequence:\\nSince the limit of \\n\\n\\n\\n\\na\\n\\nn\\n\\n\\n−\\n\\ng\\n\\nn\\n\\n\\n\\n\\n{\\displaystyle a_{n}-g_{n}}\\n\\n tends (rapidly) to zero with iterations, this is an efficient method.\\nDemonstrate the function by calculating:\\n\\n\\n","100 PRINT AGM(1,1/SQR(2))\\n110 DEF AGM(A,G)\\n120   DO\\n130     LET TA=A\\n140     LET A=(A+G)/2:LET G=SQR(TA*G)\\n150   LOOP UNTIL A=TA\\n160   LET AGM=A\\n170 END DEF"
"BASIC","Arithmetic/Complex","A   complex number   is a number which can be written as:\\n\\n\\n\\n\\na\\n+\\nb\\n×\\ni\\n\\n\\n{\\displaystyle a+b\\times i}\\n\\n\\n(sometimes shown as:\\n\\n\\n\\n\\nb\\n+\\na\\n×\\ni\\n\\n\\n{\\displaystyle b+a\\times i}\\n\\n\\nwhere   \\n\\n\\n\\na\\n\\n\\n{\\displaystyle a}\\n\\n   and   \\n\\n\\n\\nb\\n\\n\\n{\\displaystyle b}\\n\\n  are real numbers,   and   \\n\\n\\n\\ni\\n\\n\\n{\\displaystyle i}\\n\\n   is   √ -1 \\n\\nTypically, complex numbers are represented as a pair of real numbers called the \""imaginary part\"" and \""real part\"",   where the imaginary part is the number to be multiplied by \\n\\n\\n\\ni\\n\\n\\n{\\displaystyle i}\\n\\n.\\n\\n\\nBy definition, the   complex conjugate   of\\n\\n\\n\\n\\na\\n+\\nb\\ni\\n\\n\\n{\\displaystyle a+bi}\\n\\n\\nis\\n\\n\\n\\n\\na\\n−\\nb\\ni\\n\\n\\n{\\displaystyle a-bi}\\n\\n\\n\\nSome languages have complex number libraries available.   If your language does, show the operations.   If your language does not, also show the definition of this type.\\n\\n","TYPE complex\\n        real AS DOUBLE\\n        imag AS DOUBLE\\nEND TYPE\\nDECLARE SUB add (a AS complex, b AS complex, c AS complex)\\nDECLARE SUB mult (a AS complex, b AS complex, c AS complex)\\nDECLARE SUB inv (a AS complex, b AS complex)\\nDECLARE SUB neg (a AS complex, b AS complex)\\nCLS\\nDIM x AS complex\\nDIM y AS complex\\nDIM z AS complex\\nx.real = 1\\nx.imag = 1\\ny.real = 2\\ny.imag = 2\\nCALL add(x, y, z)\\nPRINT z.real; \""+\""; z.imag; \""i\""\\nCALL mult(x, y, z)\\nPRINT z.real; \""+\""; z.imag; \""i\""\\nCALL inv(x, z)\\nPRINT z.real; \""+\""; z.imag; \""i\""\\nCALL neg(x, z)\\nPRINT z.real; \""+\""; z.imag; \""i\""\\n\\n\\nSUB add (a AS complex, b AS complex, c AS complex)\\n        c.real = a.real + b.real\\n        c.imag = a.imag + b.imag\\nEND SUB\\n\\nSUB inv (a AS complex, b AS complex)\\n        denom = a.real ^ 2 + a.imag ^ 2\\n        b.real = a.real / denom\\n        b.imag = -a.imag / denom\\nEND SUB\\n\\nSUB mult (a AS complex, b AS complex, c AS complex)\\n        c.real = a.real * b.real - a.imag * b.imag\\n        c.imag = a.real * b.imag + a.imag * b.real\\nEND SUB\\n\\nSUB neg (a AS complex, b AS complex)\\n        b.real = -a.real\\n        b.imag = -a.imag\\nEND SUB"
"BASIC","Arithmetic/Integer","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\nGet two integers from the user,   and then (for those two integers), display their:\\n\\nDon't include error handling.\\nFor quotient, indicate how it rounds   (e.g. towards zero, towards negative infinity, etc.).\\nFor remainder, indicate whether its sign matches the sign of the first operand or of the second operand, if they are different.\\n\\n","' Arthimetic/Integer\\nDECLARE a%, b%\\nINPUT \""Enter integer A: \"", a%\\nINPUT \""Enter integer B: \"", b%\\nPRINT\\n\\nPRINT a%, \"" + \"", b%, \""     is \"", a% + b%\\nPRINT a%, \"" - \"", b%, \""     is \"", a% - b%\\nPRINT a%, \"" * \"", b%, \""     is \"", a% * b%\\nPRINT a%, \"" / \"", b%, \""     is \"", a% / b%, \"", trucation toward zero\""\\nPRINT \""MOD(\"", a%, \"", \"", b%, \"") is \"", MOD(a%, b%), \"", same sign as first operand\""\\nPRINT \""POW(\"", a%, \"", \"", b%, \"") is \"", INT(POW(a%, b%))"
"BASIC","Arithmetic/Integer","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\nGet two integers from the user,   and then (for those two integers), display their:\\n\\nDon't include error handling.\\nFor quotient, indicate how it rounds   (e.g. towards zero, towards negative infinity, etc.).\\nFor remainder, indicate whether its sign matches the sign of the first operand or of the second operand, if they are different.\\n\\n","10 INPUT \""ENTER A NUMBER\""; A%\\n20 INPUT \""ENTER ANOTHER NUMBER\""; B%\\n30 PRINT \""ADDITION:\"";A%;\""+\"";B%;\""=\"";A%+B%\\n40 PRINT \""SUBTRACTION:\"";A%;\""-\"";B%;\""=\"";A%-B%\\n50 PRINT \""MULTIPLICATION:\"";A%;\""*\"";B%;\""=\"";A%*B%\\n60 PRINT \""INTEGER DIVISION:\"";A%;\""/\"";B%;\""=\"";INT(A%/B%)\\n70 PRINT \""REMAINDER OR MODULO:\"";A%;\""%\"";B%;\""=\"";A%-INT(A%/B%)*B%\\n80 PRINT \""POWER:\"";A%;\""^\"";B%;\""=\"";A%^B%"
"BASIC","Arithmetic/Integer","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\nGet two integers from the user,   and then (for those two integers), display their:\\n\\nDon't include error handling.\\nFor quotient, indicate how it rounds   (e.g. towards zero, towards negative infinity, etc.).\\nFor remainder, indicate whether its sign matches the sign of the first operand or of the second operand, if they are different.\\n\\n","\\n! RosettaCode: Integer Arithmetic\\n! True BASIC v6.007\\n! Translated from BaCon example.\\nPROGRAM Integer_Arithmetic\\n	INPUT PROMPT \""Enter integer A: \"": a\\n	INPUT PROMPT \""Enter integer B: \"": b\\n	PRINT\\n	PRINT a;\"" + \"";b;\"" is \"";a+b\\n	PRINT a;\"" - \"";b;\"" is \"";a-b\\n	PRINT a;\"" * \"";b;\"" is \"";a*b\\n	PRINT a;\"" / \"";b;\"" is \"";INT(a/b);\\n	PRINT \""MOD(\"";a;\"", \"";b;\"") is \""; MOD(a,b)\\n	PRINT \""POW(\"";a;\"", \"";b;\"") is \"";INT(a^b)\\n	GET KEY done\\nEND\\n"
"BASIC","Arithmetic/Integer","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\nGet two integers from the user,   and then (for those two integers), display their:\\n\\nDon't include error handling.\\nFor quotient, indicate how it rounds   (e.g. towards zero, towards negative infinity, etc.).\\nFor remainder, indicate whether its sign matches the sign of the first operand or of the second operand, if they are different.\\n\\n","function math(a!, b!)\\n	print a + b\\n	print a - b\\n	print a * b\\n	print a / b\\n	print a mod b\\nend function"
"BASIC","Array_concatenation","Show how to concatenate two arrays in your language.\\n\\nIf this is as simple as array1 + array2, so be it.\\n\\n","' Array concatenation\\nOPTION BASE 1\\n\\nCONST asize = 2\\nCONST bsize = 3\\nDECLARE a[asize] TYPE NUMBER\\nDECLARE b[bsize] TYPE NUMBER\\n\\n' BaCon has no array concatenation builtin, it will need to be done by hand\\nLOCAL c TYPE NUMBER ARRAY asize + bsize\\nFOR i = 1 TO asize\\n    c[i] = a[i]\\nNEXT\\n\\nFOR i = 1 TO bsize\\n    c[asize + i] = b[i]\\nNEXT"
"BASIC","Array_concatenation","Show how to concatenate two arrays in your language.\\n\\nIf this is as simple as array1 + array2, so be it.\\n\\n","      DIM a(3), b(4)\\n      a() = 1, 2, 3, 4\\n      b() = 5, 6, 7, 8, 9\\n      PROCconcat(a(), b(), c())\\n      \\n      FOR i% = 0 TO DIM(c(),1)\\n        PRINT c(i%)\\n      NEXT\\n      END\\n      \\n      DEF PROCconcat(a(), b(), RETURN c())\\n      LOCAL s%, na%, nb%\\n      s% = ^a(1) - ^a(0) : REM Size of each array element\\n      na% = DIM(a(),1)+1 : REM Number of elements in a()\\n      nb% = DIM(b(),1)+1 : REM Number of elements in b()\\n      DIM c(na%+nb%-1)\\n      SYS \""RtlMoveMemory\"", ^c(0), ^a(0), s%*na%\\n      SYS \""RtlMoveMemory\"", ^c(na%), ^b(0), s%*nb%\\n      ENDPROC"
"BASIC","Array_concatenation","Show how to concatenate two arrays in your language.\\n\\nIf this is as simple as array1 + array2, so be it.\\n\\n","10 X=4 : Y=5\\n20 DIM A(X) : DIM B(Y) : DIM C(X+Y)\\n30 FOR I=1 TO X\\n40 : A(I) = I\\n50 NEXT\\n60 FOR I=1 TO Y\\n70 : B(I) = I*10\\n80 NEXT\\n90 FOR I=1 TO X\\n100 : C(I) = A(I)\\n110 NEXT\\n120 FOR I=1 TO Y\\n130 : C(X+I) = B(I)\\n140 NEXT\\n150 FOR I=1 TO X+Y\\n160 : PRINT C(I);\\n170 NEXT"
"BASIC","Array_length","Determine the amount of elements in an array.\\n\\nAs an example use an array holding the strings 'apple' and 'orange'.\\n\\n\\n","DIM X$(1 TO 2)\\nX$(1) = \""apple\""\\nX$(2) = \""orange\""\\nPRINT UBOUND(X$) - LBOUND(X$) + 1"
"BASIC","Array_length","Determine the amount of elements in an array.\\n\\nAs an example use an array holding the strings 'apple' and 'orange'.\\n\\n\\n","10 DIM A$(2)\\n20 A$(1) = \""ORANGE\""\\n30 A$(2) = \""APPLE\""\\n40 PRINT LEN(A$(1))+LEN(A$(2))"
"BASIC","Arrays","This task is about arrays.\\nFor hashes or associative arrays, please see Creating an Associative Array.\\nFor a definition and in-depth discussion of what an array is, see Array.\\n\\nShow basic array syntax in your language.\\nBasically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and\\ndynamic arrays, pushing a value into it).\\nPlease discuss at Village Pump:   Arrays.\\nPlease merge code in from these obsolete tasks:\\n\\n\\nDynamic (resizable) arrays are possible to implement, but are error-prone since bounds checking must be done by the programmer.\\nArrays are declared using JSON syntax, and are dynamic (but not sparse)\\nThere are no real arrays in ABAP but a construct called internal tables.\\n","10 DIM A%(11): REM ARRAY OF ELEVEN INTEGER ELEMENTS\\n20 LET A%(1) = -1\\n30 LET A%(11) = 1\\n40 PRINT A%(1), A%(11)\\n50 END"
"BASIC","Arrays","This task is about arrays.\\nFor hashes or associative arrays, please see Creating an Associative Array.\\nFor a definition and in-depth discussion of what an array is, see Array.\\n\\nShow basic array syntax in your language.\\nBasically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and\\ndynamic arrays, pushing a value into it).\\nPlease discuss at Village Pump:   Arrays.\\nPlease merge code in from these obsolete tasks:\\n\\n\\nDynamic (resizable) arrays are possible to implement, but are error-prone since bounds checking must be done by the programmer.\\nArrays are declared using JSON syntax, and are dynamic (but not sparse)\\nThere are no real arrays in ABAP but a construct called internal tables.\\n"," OPTION BASE 1\\n DIM myArray(100) AS INTEGER "
"BASIC","Arrays","This task is about arrays.\\nFor hashes or associative arrays, please see Creating an Associative Array.\\nFor a definition and in-depth discussion of what an array is, see Array.\\n\\nShow basic array syntax in your language.\\nBasically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and\\ndynamic arrays, pushing a value into it).\\nPlease discuss at Village Pump:   Arrays.\\nPlease merge code in from these obsolete tasks:\\n\\n\\nDynamic (resizable) arrays are possible to implement, but are error-prone since bounds checking must be done by the programmer.\\nArrays are declared using JSON syntax, and are dynamic (but not sparse)\\nThere are no real arrays in ABAP but a construct called internal tables.\\n"," DIM myArray(-10 TO 10) AS INTEGER "
"BASIC","Arrays","This task is about arrays.\\nFor hashes or associative arrays, please see Creating an Associative Array.\\nFor a definition and in-depth discussion of what an array is, see Array.\\n\\nShow basic array syntax in your language.\\nBasically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and\\ndynamic arrays, pushing a value into it).\\nPlease discuss at Village Pump:   Arrays.\\nPlease merge code in from these obsolete tasks:\\n\\n\\nDynamic (resizable) arrays are possible to implement, but are error-prone since bounds checking must be done by the programmer.\\nArrays are declared using JSON syntax, and are dynamic (but not sparse)\\nThere are no real arrays in ABAP but a construct called internal tables.\\n"," 'Specify that the array is dynamic and not static:\\n '$DYNAMIC\\n DIM SHARED myArray(-10 TO 10, 10 TO 30) AS STRING\\n REDIM SHARED myArray(20, 20) AS STRING\\n myArray(1,1) = \""Item1\""\\n myArray(1,2) = \""Item2\"" "
"BASIC","Arrays","This task is about arrays.\\nFor hashes or associative arrays, please see Creating an Associative Array.\\nFor a definition and in-depth discussion of what an array is, see Array.\\n\\nShow basic array syntax in your language.\\nBasically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and\\ndynamic arrays, pushing a value into it).\\nPlease discuss at Village Pump:   Arrays.\\nPlease merge code in from these obsolete tasks:\\n\\n\\nDynamic (resizable) arrays are possible to implement, but are error-prone since bounds checking must be done by the programmer.\\nArrays are declared using JSON syntax, and are dynamic (but not sparse)\\nThere are no real arrays in ABAP but a construct called internal tables.\\n"," DIM month$(12)\\n DATA January, February, March, April, May, June, July\\n DATA August, September, October, November, December\\n FOR m=1 TO 12\\n    READ month$(m)\\n NEXT m "
"BASIC","Arrays","This task is about arrays.\\nFor hashes or associative arrays, please see Creating an Associative Array.\\nFor a definition and in-depth discussion of what an array is, see Array.\\n\\nShow basic array syntax in your language.\\nBasically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and\\ndynamic arrays, pushing a value into it).\\nPlease discuss at Village Pump:   Arrays.\\nPlease merge code in from these obsolete tasks:\\n\\n\\nDynamic (resizable) arrays are possible to implement, but are error-prone since bounds checking must be done by the programmer.\\nArrays are declared using JSON syntax, and are dynamic (but not sparse)\\nThere are no real arrays in ABAP but a construct called internal tables.\\n"," Dim myArray(1 To 2, 1 To 5) As Integer => {{1, 2, 3, 4, 5}, {1, 2, 3, 4, 5}} "
"BASIC","Arrays","This task is about arrays.\\nFor hashes or associative arrays, please see Creating an Associative Array.\\nFor a definition and in-depth discussion of what an array is, see Array.\\n\\nShow basic array syntax in your language.\\nBasically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and\\ndynamic arrays, pushing a value into it).\\nPlease discuss at Village Pump:   Arrays.\\nPlease merge code in from these obsolete tasks:\\n\\n\\nDynamic (resizable) arrays are possible to implement, but are error-prone since bounds checking must be done by the programmer.\\nArrays are declared using JSON syntax, and are dynamic (but not sparse)\\nThere are no real arrays in ABAP but a construct called internal tables.\\n","10 REM TRANSLATION OF QBASIC STATIC VERSION\\n20 REM ELEMENT NUMBERS TRADITIONALLY START AT ONE\\n30 DIM A%(11): REM ARRAY OF ELEVEN INTEGER ELEMENTS\\n40 LET A%(1) = -1\\n50 LET A%(11) = 1\\n60 PRINT A%(1), A%(11)\\n70 END"
"BASIC","Arrays","This task is about arrays.\\nFor hashes or associative arrays, please see Creating an Associative Array.\\nFor a definition and in-depth discussion of what an array is, see Array.\\n\\nShow basic array syntax in your language.\\nBasically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and\\ndynamic arrays, pushing a value into it).\\nPlease discuss at Village Pump:   Arrays.\\nPlease merge code in from these obsolete tasks:\\n\\n\\nDynamic (resizable) arrays are possible to implement, but are error-prone since bounds checking must be done by the programmer.\\nArrays are declared using JSON syntax, and are dynamic (but not sparse)\\nThere are no real arrays in ABAP but a construct called internal tables.\\n","DIM staticArray(10) AS INTEGER\\n\\nstaticArray(0) = -1\\nstaticArray(10) = 1\\n\\nPRINT staticArray(0), staticArray(10)"
"BASIC","Arrays","This task is about arrays.\\nFor hashes or associative arrays, please see Creating an Associative Array.\\nFor a definition and in-depth discussion of what an array is, see Array.\\n\\nShow basic array syntax in your language.\\nBasically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and\\ndynamic arrays, pushing a value into it).\\nPlease discuss at Village Pump:   Arrays.\\nPlease merge code in from these obsolete tasks:\\n\\n\\nDynamic (resizable) arrays are possible to implement, but are error-prone since bounds checking must be done by the programmer.\\nArrays are declared using JSON syntax, and are dynamic (but not sparse)\\nThere are no real arrays in ABAP but a construct called internal tables.\\n","10 DIM A%(11): REM ARRAY OF ELEVEN INTEGER ELEMENTS\\n20 LET A%(1) = -1\\n30 LET A%(11) = 1\\n40 PRINT A%(1), A%(11)\\n50 END"
"BASIC","Arrays","This task is about arrays.\\nFor hashes or associative arrays, please see Creating an Associative Array.\\nFor a definition and in-depth discussion of what an array is, see Array.\\n\\nShow basic array syntax in your language.\\nBasically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and\\ndynamic arrays, pushing a value into it).\\nPlease discuss at Village Pump:   Arrays.\\nPlease merge code in from these obsolete tasks:\\n\\n\\nDynamic (resizable) arrays are possible to implement, but are error-prone since bounds checking must be done by the programmer.\\nArrays are declared using JSON syntax, and are dynamic (but not sparse)\\nThere are no real arrays in ABAP but a construct called internal tables.\\n","REDIM dynamicArray(10) AS INTEGER\\n\\ndynamicArray(0) = -1\\nPRINT dynamicArray(0)\\n\\nREDIM dynamicArray(20)\\n\\ndynamicArray(20) = 1\\nPRINT dynamicArray(0), dynamicArray(20)"
"BASIC","Averages/Arithmetic_mean","Write a program to find the mean (arithmetic average) of a numeric vector.\\nIn case of a zero-length input, since the mean of an empty set of numbers is ill-defined, the program may choose to behave in any way it deems appropriate, though if the programming language has an established convention for conveying math errors or undefined values, it's preferable to follow it.\\n","mean = 0\\nsum = 0;\\nFOR i = LBOUND(nums) TO UBOUND(nums)\\n   sum = sum + nums(i);\\nNEXT i\\nsize = UBOUND(nums) - LBOUND(nums) + 1\\nPRINT \""The mean is: \"";\\nIF size <> 0 THEN\\n   PRINT (sum / size)\\nELSE\\n   PRINT 0\\nEND IF"
"BASIC","Averages/Arithmetic_mean","Write a program to find the mean (arithmetic average) of a numeric vector.\\nIn case of a zero-length input, since the mean of an empty set of numbers is ill-defined, the program may choose to behave in any way it deems appropriate, though if the programming language has an established convention for conveying math errors or undefined values, it's preferable to follow it.\\n","\\n      REM specific functions for the array/vector types\\n      \\n      REM Byte Array\\n      DEF FN_Mean_Arithmetic&(n&())\\n      = SUM(n&()) / (DIM(n&(),1)+1)\\n      \\n      REM Integer Array\\n      DEF FN_Mean_Arithmetic%(n%())\\n      = SUM(n%()) / (DIM(n%(),1)+1)\\n      \\n      REM Float 40 array\\n      DEF FN_Mean_Arithmetic(n())\\n      = SUM(n()) / (DIM(n(),1)+1)\\n\\n      REM A String array\\n      DEF FN_Mean_Arithmetic$(n$())\\n      LOCAL I%, S%, sum, Q%\\n      S% = DIM(n$(),1)\\n      FOR I% = 0 TO S%\\n        Q% = TRUE\\n        ON ERROR LOCAL Q% = FALSE\\n        IF Q% sum += EVAL(n$(I%))\\n      NEXT\\n      = sum / (S%+1)\\n     \\n      REM Float 64 array\\n      DEF FN_Mean_Arithmetic#(n#())\\n      = SUM(n#()) / (DIM(n#(),1)+1)\\n"
"BASIC","Averages/Arithmetic_mean","Write a program to find the mean (arithmetic average) of a numeric vector.\\nIn case of a zero-length input, since the mean of an empty set of numbers is ill-defined, the program may choose to behave in any way it deems appropriate, though if the programming language has an established convention for conveying math errors or undefined values, it's preferable to follow it.\\n","100 NUMERIC ARR(3 TO 8)\\n110 LET ARR(3)=3:LET ARR(4)=1:LET ARR(5)=4:LET ARR(6)=1:LET ARR(7)=5:LET ARR(8)=9\\n120 PRINT AM(ARR)\\n130 DEF AM(REF A)\\n140   LET T=0\\n150   FOR I=LBOUND(A) TO UBOUND(A)\\n160     LET T=T+A(I)\\n170   NEXT\\n180   LET AM=T/SIZE(A)\\n190 END DEF"
"BASIC","Averages/Median","Write a program to find the   median   value of a vector of floating-point numbers.\\nThe program need not handle the case where the vector is empty, but must handle the case where there are an even number of elements.   In that case, return the average of the two middle values.\\nThere are several approaches to this.   One is to sort the elements, and then pick the element(s) in the middle.\\nSorting would take at least   O(n logn).   Another approach would be to build a priority queue from the elements, and then extract half of the elements to get to the middle element(s).   This would also take   O(n logn).   The best solution is to use the   selection algorithm   to find the median in   O(n)   time.\\nQuickselect_algorithm\\n","DECLARE FUNCTION median! (vector() AS SINGLE)\\n\\nDIM vec1(10) AS SINGLE, vec2(11) AS SINGLE, n AS INTEGER\\n\\nRANDOMIZE TIMER\\n\\nFOR n = 0 TO 10\\n    vec1(n) = RND * 100\\n    vec2(n) = RND * 100\\nNEXT\\nvec2(11) = RND * 100\\n\\nPRINT median(vec1())\\nPRINT median(vec2())\\n\\nFUNCTION median! (vector() AS SINGLE)\\n    DIM lb AS INTEGER, ub AS INTEGER, L0 AS INTEGER\\n    lb = LBOUND(vector)\\n    ub = UBOUND(vector)\\n    REDIM v(lb TO ub) AS SINGLE\\n    FOR L0 = lb TO ub\\n        v(L0) = vector(L0)\\n    NEXT\\n    quicksort v(), lb, ub\\n    IF ((ub - lb + 1) MOD 2) THEN\\n        median = v((ub + lb) / 2)\\n    ELSE\\n        median = (v(INT((ub + lb) / 2)) + v(INT((ub + lb) / 2) + 1)) / 2\\n    END IF\\nEND FUNCTION"
"BASIC","Averages/Root_mean_square","Compute the   Root mean square   of the numbers 1..10.\\n\\nThe   root mean square   is also known by its initials RMS (or rms), and as the quadratic mean.\\nThe RMS is calculated as the mean of the squares of the numbers, square-rooted:\\n\\n\\n","DIM i(1 TO 10) AS DOUBLE, L0 AS LONG\\nFOR L0 = 1 TO 10\\n    i(L0) = L0\\nNEXT\\nPRINT STR$(rms#(i()))\\n\\nFUNCTION rms# (what() AS DOUBLE)\\n    DIM L0 AS LONG, tmp AS DOUBLE, rt AS DOUBLE\\n    FOR L0 = LBOUND(what) TO UBOUND(what)\\n        rt = rt + (what(L0) ^ 2)\\n    NEXT\\n    tmp = UBOUND(what) - LBOUND(what) + 1\\n    rms# = SQR(rt / tmp)\\nEND FUNCTION"
"BASIC","Averages/Root_mean_square","Compute the   Root mean square   of the numbers 1..10.\\n\\nThe   root mean square   is also known by its initials RMS (or rms), and as the quadratic mean.\\nThe RMS is calculated as the mean of the squares of the numbers, square-rooted:\\n\\n\\n"," 10 N = 10\\n 20  FOR I = 1 TO N\\n 30 S = S + I * I\\n 40  NEXT\\n 50 X =  SQR (S / N)\\n 60  PRINT X"
"BASIC","Averages/Root_mean_square","Compute the   Root mean square   of the numbers 1..10.\\n\\nThe   root mean square   is also known by its initials RMS (or rms), and as the quadratic mean.\\nThe RMS is calculated as the mean of the squares of the numbers, square-rooted:\\n\\n\\n","100 PRINT RMS(10)\\n110 DEF RMS(N)\\n120   LET R=0\\n130   FOR X=1 TO N\\n140     LET R=R+X^2\\n150   NEXT\\n160   LET RMS=SQR(R/N)\\n170 END DEF"
"BASIC","Averages/Root_mean_square","Compute the   Root mean square   of the numbers 1..10.\\n\\nThe   root mean square   is also known by its initials RMS (or rms), and as the quadratic mean.\\nThe RMS is calculated as the mean of the squares of the numbers, square-rooted:\\n\\n\\n","10 FAST\\n20 LET RMS=0\\n30 FOR X=1 TO 10\\n40 LET RMS=RMS+X**2\\n50 NEXT X\\n60 LET RMS=SQR (RMS/10)\\n70 SLOW\\n80 PRINT RMS"
"BASIC","Averages/Root_mean_square","Compute the   Root mean square   of the numbers 1..10.\\n\\nThe   root mean square   is also known by its initials RMS (or rms), and as the quadratic mean.\\nThe RMS is calculated as the mean of the squares of the numbers, square-rooted:\\n\\n\\n","      DIM array(9)\\n      array() = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\\n      \\n      PRINT FNrms(array())\\n      END\\n      \\n      DEF FNrms(a()) = MOD(a()) / SQR(DIM(a(),1)+1)"
"BASIC","Babbage_problem","Charles Babbage, looking ahead to the sorts of problems his Analytical Engine would be able to solve, gave this example:\\nHe thought the answer might be 99,736, whose square is 9,947,269,696; but he couldn't be certain.\\n\\nThe task is to find out if Babbage had the right answer — and to do so, as far as your language allows it, in code that Babbage himself would have been able to read and understand.\\nAs Babbage evidently solved the task with pencil and paper, a similar efficient solution is preferred.\\nFor these purposes, Charles Babbage may be taken to be an intelligent person, familiar with mathematics and with the idea of a computer; he has written the first drafts of simple computer programmes in tabular form. [Babbage Archive Series L].\\n\\nThe aim of the task is to write a program that is sufficiently clear and well-documented for such a person to be able to read it and be confident that it does indeed solve the specified problem.\\n\\nAn assembler program always seems a bit tricky for non system engineer because it deals directly with the operating system and with the hardware instructions. Here we have a 32-bit computer with 16 32-bit registers. The caller (the operating system to keep it simple) is calling you giving your location address stored in register-15 and has stored in register-14 his return address. To save each program context, register-13 points to a 18 word save area. Do not spend time in understanding the context saving and restoring in the prologue and epilogue part of the program. What you have to know, “360” architecture uses 32-bit signed binary arithmetic, so here the maximum integer value is 2^31-1 (2147483647). Therefore the solution must be less than 2147483647. The multiplication and the division use a pair of registers; coding “MR 4,2” means multiply register-5 by register-2 and place result in the (register-4,register-5) pair; the same way “DR 4,2” means divide the (register-4,register-5) pair by register-2 and place the quotient in register-5 and the reminder in register-4. We use in the below program this intermediate 64-bit integers to find a solution with a value up to 2^31-1 even when we have to compute the square of this value.\\n","\\n 100 :\\n 110  REM  BABBAGE PROBLEM\\n 120 :\\n 130  DEF  FN ST(A) = N - INT (A) * INT (A)\\n 140 N = 269696\\n 150 N = N + 1000000\\n 160 R =  SQR (N)\\n 170  IF FN ST(R) <  > 0 AND N < 999999999 THEN GOTO 150           \\n 180  IF N > 999999999 THEN  GOTO 210                                \\n 190  PRINT \""SMALLESt NUMBER WHOSE \\n      SQUARE ENDS IN\""; CHR$ (13);\\n      \""269696 IS \"";R;\"", AND THE \\n      SQUARE IS\""; CHR$ (13);N             \\n 200  END                               \\n 210  PRINT \""THERE IS NO SOLUTION       \\n      FOR VALUES SMALLER\""; CHR$(13);\\n      \""THAN 999999999.\""              \\n"
"BASIC","Babbage_problem","Charles Babbage, looking ahead to the sorts of problems his Analytical Engine would be able to solve, gave this example:\\nHe thought the answer might be 99,736, whose square is 9,947,269,696; but he couldn't be certain.\\n\\nThe task is to find out if Babbage had the right answer — and to do so, as far as your language allows it, in code that Babbage himself would have been able to read and understand.\\nAs Babbage evidently solved the task with pencil and paper, a similar efficient solution is preferred.\\nFor these purposes, Charles Babbage may be taken to be an intelligent person, familiar with mathematics and with the idea of a computer; he has written the first drafts of simple computer programmes in tabular form. [Babbage Archive Series L].\\n\\nThe aim of the task is to write a program that is sufficiently clear and well-documented for such a person to be able to read it and be confident that it does indeed solve the specified problem.\\n\\nAn assembler program always seems a bit tricky for non system engineer because it deals directly with the operating system and with the hardware instructions. Here we have a 32-bit computer with 16 32-bit registers. The caller (the operating system to keep it simple) is calling you giving your location address stored in register-15 and has stored in register-14 his return address. To save each program context, register-13 points to a 18 word save area. Do not spend time in understanding the context saving and restoring in the prologue and epilogue part of the program. What you have to know, “360” architecture uses 32-bit signed binary arithmetic, so here the maximum integer value is 2^31-1 (2147483647). Therefore the solution must be less than 2147483647. The multiplication and the division use a pair of registers; coding “MR 4,2” means multiply register-5 by register-2 and place result in the (register-4,register-5) pair; the same way “DR 4,2” means divide the (register-4,register-5) pair by register-2 and place the quotient in register-5 and the reminder in register-4. We use in the below program this intermediate 64-bit integers to find a solution with a value up to 2^31-1 even when we have to compute the square of this value.\\n","10 rem This code is an implementation of Babbage Problem\\n20 num = 100 : rem We can safely start at 100\\n30 s = num*num\\n40 r = s - int(s/1000000)*1000000 : rem remainder when divided by 1,000,000\\n50 if r = 269696 then goto 100    : rem compare with 269,696\\n60 print \""n=\""num\""sq=\""s\""rem=\""r\\n70 num = num+1\\n80 goto 30\\n90 rem Print out the result\\n100 print:print \""The smallest number whose square ends in 269696 is:\""\\n110 print num;\""....\"";num;\""squared = \"";s\\n120 end"
"BASIC","Babbage_problem","Charles Babbage, looking ahead to the sorts of problems his Analytical Engine would be able to solve, gave this example:\\nHe thought the answer might be 99,736, whose square is 9,947,269,696; but he couldn't be certain.\\n\\nThe task is to find out if Babbage had the right answer — and to do so, as far as your language allows it, in code that Babbage himself would have been able to read and understand.\\nAs Babbage evidently solved the task with pencil and paper, a similar efficient solution is preferred.\\nFor these purposes, Charles Babbage may be taken to be an intelligent person, familiar with mathematics and with the idea of a computer; he has written the first drafts of simple computer programmes in tabular form. [Babbage Archive Series L].\\n\\nThe aim of the task is to write a program that is sufficiently clear and well-documented for such a person to be able to read it and be confident that it does indeed solve the specified problem.\\n\\nAn assembler program always seems a bit tricky for non system engineer because it deals directly with the operating system and with the hardware instructions. Here we have a 32-bit computer with 16 32-bit registers. The caller (the operating system to keep it simple) is calling you giving your location address stored in register-15 and has stored in register-14 his return address. To save each program context, register-13 points to a 18 word save area. Do not spend time in understanding the context saving and restoring in the prologue and epilogue part of the program. What you have to know, “360” architecture uses 32-bit signed binary arithmetic, so here the maximum integer value is 2^31-1 (2147483647). Therefore the solution must be less than 2147483647. The multiplication and the division use a pair of registers; coding “MR 4,2” means multiply register-5 by register-2 and place result in the (register-4,register-5) pair; the same way “DR 4,2” means divide the (register-4,register-5) pair by register-2 and place the quotient in register-5 and the reminder in register-4. We use in the below program this intermediate 64-bit integers to find a solution with a value up to 2^31-1 even when we have to compute the square of this value.\\n","REM Statements beginning 'REM' are explanatory remarks: the machine will ignore them.\\n\\nREM We shall test positive integers from 1 upwards until we find one whose square ends in 269,696.\\n\\nREM A number that ends in 269,696 is one that leaves a remainder of 269,696 when divided by a million.\\n\\nREM So we are looking for a value of n that satisfies the condition 'n squared modulo 1,000,000 = 269,696', or 'n^2 MOD 1000000 = 269696' in the notation that the machine can accept.\\n\\nLET n = 0\\n\\nREPEAT\\n  LET n = n + 1\\nUNTIL n^2 MOD 1000000 = 269696\\n\\nPRINT \""The smallest number whose square ends in 269696 is\"" n\\n\\nPRINT \""Its square is\"" n^2"
"BASIC","Babbage_problem","Charles Babbage, looking ahead to the sorts of problems his Analytical Engine would be able to solve, gave this example:\\nHe thought the answer might be 99,736, whose square is 9,947,269,696; but he couldn't be certain.\\n\\nThe task is to find out if Babbage had the right answer — and to do so, as far as your language allows it, in code that Babbage himself would have been able to read and understand.\\nAs Babbage evidently solved the task with pencil and paper, a similar efficient solution is preferred.\\nFor these purposes, Charles Babbage may be taken to be an intelligent person, familiar with mathematics and with the idea of a computer; he has written the first drafts of simple computer programmes in tabular form. [Babbage Archive Series L].\\n\\nThe aim of the task is to write a program that is sufficiently clear and well-documented for such a person to be able to read it and be confident that it does indeed solve the specified problem.\\n\\nAn assembler program always seems a bit tricky for non system engineer because it deals directly with the operating system and with the hardware instructions. Here we have a 32-bit computer with 16 32-bit registers. The caller (the operating system to keep it simple) is calling you giving your location address stored in register-15 and has stored in register-14 his return address. To save each program context, register-13 points to a 18 word save area. Do not spend time in understanding the context saving and restoring in the prologue and epilogue part of the program. What you have to know, “360” architecture uses 32-bit signed binary arithmetic, so here the maximum integer value is 2^31-1 (2147483647). Therefore the solution must be less than 2147483647. The multiplication and the division use a pair of registers; coding “MR 4,2” means multiply register-5 by register-2 and place result in the (register-4,register-5) pair; the same way “DR 4,2” means divide the (register-4,register-5) pair by register-2 and place the quotient in register-5 and the reminder in register-4. We use in the below program this intermediate 64-bit integers to find a solution with a value up to 2^31-1 even when we have to compute the square of this value.\\n","REM Lines that begin 'REM' are explanatory remarks addressed to the human reader.\\n\\nREM The machine will ignore them.\\n\\nLET n = 269696\\n\\nREPEAT\\n  \\n  LET n = n + 1000000\\n  \\n  REM Find the next number that ends in 269,696.\\n  \\n  REM The function SQR finds the square root.\\n  \\n  LET root = SQR n\\n  \\n  REM The function INT truncates a real number to an integer.\\n  \\nUNTIL root = INT root\\n\\nREM If the square root is equal to its integer truncation, then it is an integer: so we have found our answer.\\n\\nPRINT \""The smallest number whose square ends in 269696 is\"" root\\n\\nPRINT \""Its square is\"" n"
"BASIC","Babbage_problem","Charles Babbage, looking ahead to the sorts of problems his Analytical Engine would be able to solve, gave this example:\\nHe thought the answer might be 99,736, whose square is 9,947,269,696; but he couldn't be certain.\\n\\nThe task is to find out if Babbage had the right answer — and to do so, as far as your language allows it, in code that Babbage himself would have been able to read and understand.\\nAs Babbage evidently solved the task with pencil and paper, a similar efficient solution is preferred.\\nFor these purposes, Charles Babbage may be taken to be an intelligent person, familiar with mathematics and with the idea of a computer; he has written the first drafts of simple computer programmes in tabular form. [Babbage Archive Series L].\\n\\nThe aim of the task is to write a program that is sufficiently clear and well-documented for such a person to be able to read it and be confident that it does indeed solve the specified problem.\\n\\nAn assembler program always seems a bit tricky for non system engineer because it deals directly with the operating system and with the hardware instructions. Here we have a 32-bit computer with 16 32-bit registers. The caller (the operating system to keep it simple) is calling you giving your location address stored in register-15 and has stored in register-14 his return address. To save each program context, register-13 points to a 18 word save area. Do not spend time in understanding the context saving and restoring in the prologue and epilogue part of the program. What you have to know, “360” architecture uses 32-bit signed binary arithmetic, so here the maximum integer value is 2^31-1 (2147483647). Therefore the solution must be less than 2147483647. The multiplication and the division use a pair of registers; coding “MR 4,2” means multiply register-5 by register-2 and place result in the (register-4,register-5) pair; the same way “DR 4,2” means divide the (register-4,register-5) pair by register-2 and place the quotient in register-5 and the reminder in register-4. We use in the below program this intermediate 64-bit integers to find a solution with a value up to 2^31-1 even when we have to compute the square of this value.\\n","100 PROGRAM \""Babbage.bas\""\\n110 LET N=2\\n120 DO \\n130   LET N=N+2\\n140 LOOP UNTIL MOD(N*N,1000000)=269696\\n150 PRINT \""The smallest number whose square ends in 269696 is:\"";N\\n160 PRINT \""It's square is\"";N^2"
"BASIC","Babbage_problem","Charles Babbage, looking ahead to the sorts of problems his Analytical Engine would be able to solve, gave this example:\\nHe thought the answer might be 99,736, whose square is 9,947,269,696; but he couldn't be certain.\\n\\nThe task is to find out if Babbage had the right answer — and to do so, as far as your language allows it, in code that Babbage himself would have been able to read and understand.\\nAs Babbage evidently solved the task with pencil and paper, a similar efficient solution is preferred.\\nFor these purposes, Charles Babbage may be taken to be an intelligent person, familiar with mathematics and with the idea of a computer; he has written the first drafts of simple computer programmes in tabular form. [Babbage Archive Series L].\\n\\nThe aim of the task is to write a program that is sufficiently clear and well-documented for such a person to be able to read it and be confident that it does indeed solve the specified problem.\\n\\nAn assembler program always seems a bit tricky for non system engineer because it deals directly with the operating system and with the hardware instructions. Here we have a 32-bit computer with 16 32-bit registers. The caller (the operating system to keep it simple) is calling you giving your location address stored in register-15 and has stored in register-14 his return address. To save each program context, register-13 points to a 18 word save area. Do not spend time in understanding the context saving and restoring in the prologue and epilogue part of the program. What you have to know, “360” architecture uses 32-bit signed binary arithmetic, so here the maximum integer value is 2^31-1 (2147483647). Therefore the solution must be less than 2147483647. The multiplication and the division use a pair of registers; coding “MR 4,2” means multiply register-5 by register-2 and place result in the (register-4,register-5) pair; the same way “DR 4,2” means divide the (register-4,register-5) pair by register-2 and place the quotient in register-5 and the reminder in register-4. We use in the below program this intermediate 64-bit integers to find a solution with a value up to 2^31-1 even when we have to compute the square of this value.\\n","100 PROGRAM \""Babbage.bas\""\\n110 LET N=269696\\n120 DO \\n130   LET N=N+1000000\\n140   LET R=SQR(N)\\n150 LOOP UNTIL R=INT(R)\\n160 PRINT \""The smallest number whose square ends in 269696 is:\"";R\\n170 PRINT \""It's square is\"";N"
"BASIC","Balanced_brackets","Task:\\n\\n\\n","DECLARE FUNCTION checkBrackets% (brackets AS STRING)\\nDECLARE FUNCTION generator$ (length AS INTEGER)\\n\\nRANDOMIZE TIMER\\n\\nDO\\n    x$ = generator$ (10)\\n    PRINT x$,\\n    IF checkBrackets(x$) THEN\\n        PRINT \""OK\""\\n    ELSE\\n        PRINT \""NOT OK\""\\n    END IF\\nLOOP WHILE LEN(x$)\\n\\nFUNCTION checkBrackets% (brackets AS STRING)\\n    'returns -1 (TRUE) if everything's ok, 0 (FALSE) if not\\n    DIM L0 AS INTEGER, sum AS INTEGER\\n\\n    FOR L0 = 1 TO LEN(brackets)\\n        SELECT CASE MID$(brackets, L0, 1)\\n            CASE \""[\""\\n                sum = sum + 1\\n            CASE \""]\""\\n                sum = sum - 1\\n        END SELECT\\n        IF sum < 0 THEN\\n            checkBrackets% = 0\\n            EXIT FUNCTION\\n        END IF\\n    NEXT\\n\\n    IF 0 = sum THEN\\n        checkBrackets% = -1\\n    ELSE\\n        checkBrackets% = 0\\n    END IF\\nEND FUNCTION\\n\\nFUNCTION generator$ (length AS INTEGER)\\n    z = INT(RND * length)\\n    IF z < 1 THEN generator$ = \""\"": EXIT FUNCTION\\n    REDIM x(z * 2) AS STRING\\n    FOR i = 0 TO z STEP 2\\n        x(i) = \""[\""\\n        x(i + 1) = \""]\""\\n    NEXT\\n    FOR i = 1 TO UBOUND(x)\\n        z = INT(RND * 2)\\n        IF z THEN SWAP x(i), x(i - 1)\\n    NEXT\\n    xx$ = \""\""\\n    FOR i = 0 TO UBOUND(x)\\n        xx$ = xx$ + x(i)\\n    NEXT\\n    generator$ = xx$\\nEND FUNCTION"
"BASIC","Balanced_brackets","Task:\\n\\n\\n","10 PRINT CHR$(147): REM CLEAR SCREEN\\n20 FOR N=1 TO 7\\n30   READ S$\\n40   IF S$=\""\"" THEN PRINT\""(EMPTY)\"";: GOTO 60\\n50   PRINT S$;\\n60   PRINT TAB(20);\\n70   GOSUB 1000\\n80 NEXT N\\n90 END \\n100 REM ********************************\\n1000 S = 0\\n1010 FOR K=1 TO LEN(S$)\\n1020   C$ = MID$(S$,K,1)\\n1030   IF C$=\""[\"" THEN S = S+1\\n1040   IF C$=\""]\"" THEN S = S-1\\n1050   IF S<0 THEN PRINT \""NOT OK\"": RETURN \\n1060 NEXT K\\n1070 IF S=0 THEN PRINT \""OK\"": RETURN \\n1090 PRINT \""NOT OK\""\\n1100 RETURN \\n2000 DATA , [], ][, [][], ][][, [[][]], []][[]"
"BASIC","Binary_digits","Create and display the sequence of binary digits for a given   non-negative integer.\\nThe results can be achieved using built-in radix functions within the language   (if these are available),   or alternatively a user defined function can be used.\\nThe output produced should consist just of the binary digits of each number followed by a   newline.\\nThere should be no other whitespace, radix or sign markers in the produced output, and leading zeros should not appear in the results.\\n\\n"," 0 N = 5: GOSUB 1:N = 50: GOSUB 1:N = 9000: GOSUB 1: END \\n 1  LET N2 =  ABS ( INT (N))\\n 2  LET B$ = \""\""\\n 3  FOR N1 = N2 TO 0 STEP 0\\n 4      LET N2 =  INT (N1 / 2)\\n 5      LET B$ =  STR$ (N1 - N2 * 2) + B$\\n 6      LET N1 = N2\\n 7  NEXT N1\\n 8  PRINT B$\\n 9  RETURN"
"BASIC","Binary_digits","Create and display the sequence of binary digits for a given   non-negative integer.\\nThe results can be achieved using built-in radix functions within the language   (if these are available),   or alternatively a user defined function can be used.\\nThe output produced should consist just of the binary digits of each number followed by a   newline.\\nThere should be no other whitespace, radix or sign markers in the produced output, and leading zeros should not appear in the results.\\n\\n","\\n# DecToBin.bas\\n# BASIC256 1.1.4.0\\n\\n\\ndim a(3)                                            #dimension a 3 element array (a)\\na = {5, 50, 9000}\\n\\nfor i = 0 to 2\\n    print a[i] + chr(9) + toRadix(a[i],2)           # radix (decimal, base2)\\nnext i\\n"
"BASIC","Binary_digits","Create and display the sequence of binary digits for a given   non-negative integer.\\nThe results can be achieved using built-in radix functions within the language   (if these are available),   or alternatively a user defined function can be used.\\nThe output produced should consist just of the binary digits of each number followed by a   newline.\\nThere should be no other whitespace, radix or sign markers in the produced output, and leading zeros should not appear in the results.\\n\\n","      FOR num% = 0 TO 16\\n        PRINT FN_tobase(num%, 2, 0)\\n      NEXT\\n      END\\n      \\n      REM Convert N% to string in base B% with minimum M% digits:\\n      DEF FN_tobase(N%,B%,M%)\\n      LOCAL D%,A$\\n      REPEAT\\n        D% = N%MODB%\\n        N% DIV= B%\\n        IF D%<0 D% += B%:N% -= 1\\n        A$ = CHR$(48 + D% - 7*(D%>9)) + A$\\n        M% -= 1\\n      UNTIL (N%=FALSE OR N%=TRUE) AND M%<=0\\n      =A$"
"BASIC","Binary_digits","Create and display the sequence of binary digits for a given   non-negative integer.\\nThe results can be achieved using built-in radix functions within the language   (if these are available),   or alternatively a user defined function can be used.\\nThe output produced should consist just of the binary digits of each number followed by a   newline.\\nThere should be no other whitespace, radix or sign markers in the produced output, and leading zeros should not appear in the results.\\n\\n","PRINT FNbinary(5)\\nPRINT FNbinary(50)\\nPRINT FNbinary(9000)\\nEND\\n\\nDEF FNbinary(N%)\\nLOCAL A$\\nREPEAT\\n  A$ = STR$(N% AND 1) + A$\\n  N% = N% >>> 1  : REM BBC Basic prior to V5 can use N% = N% DIV 2\\nUNTIL N% = 0\\n=A$"
"BASIC","Binary_digits","Create and display the sequence of binary digits for a given   non-negative integer.\\nThe results can be achieved using built-in radix functions within the language   (if these are available),   or alternatively a user defined function can be used.\\nThe output produced should consist just of the binary digits of each number followed by a   newline.\\nThere should be no other whitespace, radix or sign markers in the produced output, and leading zeros should not appear in the results.\\n\\n","10 N = 5 : GOSUB 100\\n20 N = 50 : GOSUB 100\\n30 N = 9000 : GOSUB 100\\n40 END\\n90 REM *** SUBROUTINE: CONVERT DECIMAL TO BINARY\\n100 N2 =  ABS(INT(N))\\n110 B$ = \""\""\\n120 FOR N1 = N2 TO 0 STEP 0\\n130 :  N2 =  INT(N1 / 2)\\n140 :  B$ =  STR$(N1 - N2 * 2) + B$\\n150 :  N1 = N2\\n160 NEXT N1\\n170 PRINT B$\\n180 RETURN"
"BASIC","Binary_digits","Create and display the sequence of binary digits for a given   non-negative integer.\\nThe results can be achieved using built-in radix functions within the language   (if these are available),   or alternatively a user defined function can be used.\\nThe output produced should consist just of the binary digits of each number followed by a   newline.\\nThere should be no other whitespace, radix or sign markers in the produced output, and leading zeros should not appear in the results.\\n\\n","10 PRINT BIN$(50)\\n100 DEF BIN$(N)\\n110   LET N=ABS(INT(N)):LET B$=\""\""\\n120   DO\\n140     LET B$=STR$(MOD(N,2))&B$:LET N=INT(N/2)\\n150   LOOP WHILE N>0\\n160   LET BIN$=B$\\n170 END DEF"
"BASIC","Binary_search","A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a \""divide and conquer\"" algorithm.\\nAs an analogy, consider the children's game \""guess a number.\"" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.\\nAs the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.\\n\\nGiven the starting point of a range, the ending point of a range, and the \""secret value\"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.\\nThere are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.\\nAll of the following code examples use an \""inclusive\"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using \""exclusive\"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):\\nThe algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the \""insertion point\"" for it (the index that the value would have if it were inserted into the array).\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nMake sure it does not have overflow bugs.\\nThe line in the pseudo-code above to calculate the mean of two integers:\\ncould produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.\\nOne way to fix it is to manually add half the range to the low number:\\nEven though this is mathematically equivalent to the above, it is not susceptible to overflow.\\nAnother way for signed integers, possibly faster, is the following:\\nwhere  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.\\n\\n\\n\\n","FUNCTION binary_search ( array() AS Integer, value AS Integer, lo AS Integer, hi AS Integer) AS Integer\\n  DIM middle AS Integer\\n  \\n  IF hi < lo THEN\\n    binary_search = 0\\n  ELSE\\n    middle = (hi + lo) / 2\\n    SELECT CASE value\\n      CASE IS < array(middle)\\n	binary_search = binary_search(array(), value, lo, middle-1)\\n      CASE IS > array(middle)\\n	binary_search = binary_search(array(), value, middle+1, hi)\\n      CASE ELSE\\n	binary_search = middle\\n    END SELECT\\n  END IF\\nEND FUNCTION"
"BASIC","Binary_search","A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a \""divide and conquer\"" algorithm.\\nAs an analogy, consider the children's game \""guess a number.\"" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.\\nAs the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.\\n\\nGiven the starting point of a range, the ending point of a range, and the \""secret value\"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.\\nThere are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.\\nAll of the following code examples use an \""inclusive\"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using \""exclusive\"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):\\nThe algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the \""insertion point\"" for it (the index that the value would have if it were inserted into the array).\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nMake sure it does not have overflow bugs.\\nThe line in the pseudo-code above to calculate the mean of two integers:\\ncould produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.\\nOne way to fix it is to manually add half the range to the low number:\\nEven though this is mathematically equivalent to the above, it is not susceptible to overflow.\\nAnother way for signed integers, possibly faster, is the following:\\nwhere  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.\\n\\n\\n\\n","FUNCTION binary_search ( array() AS Integer, value AS Integer, lo AS Integer, hi AS Integer) AS Integer\\n  DIM middle AS Integer\\n  \\n  WHILE lo <= hi\\n    middle = (hi + lo) / 2\\n    SELECT CASE value\\n      CASE IS < array(middle)\\n	hi = middle - 1\\n      CASE IS > array(middle)\\n	lo = middle + 1\\n      CASE ELSE\\n	binary_search = middle\\n	EXIT FUNCTION\\n    END SELECT\\n  WEND\\n  binary_search = 0\\nEND FUNCTION"
"BASIC","Binary_search","A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a \""divide and conquer\"" algorithm.\\nAs an analogy, consider the children's game \""guess a number.\"" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.\\nAs the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.\\n\\nGiven the starting point of a range, the ending point of a range, and the \""secret value\"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.\\nThere are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.\\nAll of the following code examples use an \""inclusive\"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using \""exclusive\"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):\\nThe algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the \""insertion point\"" for it (the index that the value would have if it were inserted into the array).\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nMake sure it does not have overflow bugs.\\nThe line in the pseudo-code above to calculate the mean of two integers:\\ncould produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.\\nOne way to fix it is to manually add half the range to the low number:\\nEven though this is mathematically equivalent to the above, it is not susceptible to overflow.\\nAnother way for signed integers, possibly faster, is the following:\\nwhere  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.\\n\\n\\n\\n","SUB search (array() AS Integer, value AS Integer)\\n  DIM idx AS Integer\\n\\n  idx = binary_search(array(), value, LBOUND(array), UBOUND(array))\\n  PRINT \""Value \""; value;\\n  IF idx < 1 THEN\\n    PRINT \"" not found\""\\n  ELSE\\n    PRINT \"" found at index \""; idx\\n  END IF\\nEND SUB\\n\\nDIM test(1 TO 10) AS Integer\\nDIM i AS Integer\\n\\nDATA 2, 3, 5, 6, 8, 10, 11, 15, 19, 20\\nFOR i = 1 TO 10		' Fill the test array\\n  READ test(i)\\nNEXT i\\n\\nsearch test(), 4\\nsearch test(), 8\\nsearch test(), 20"
"BASIC","Binary_search","A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a \""divide and conquer\"" algorithm.\\nAs an analogy, consider the children's game \""guess a number.\"" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.\\nAs the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.\\n\\nGiven the starting point of a range, the ending point of a range, and the \""secret value\"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.\\nThere are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.\\nAll of the following code examples use an \""inclusive\"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using \""exclusive\"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):\\nThe algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the \""insertion point\"" for it (the index that the value would have if it were inserted into the array).\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nMake sure it does not have overflow bugs.\\nThe line in the pseudo-code above to calculate the mean of two integers:\\ncould produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.\\nOne way to fix it is to manually add half the range to the low number:\\nEven though this is mathematically equivalent to the above, it is not susceptible to overflow.\\nAnother way for signed integers, possibly faster, is the following:\\nwhere  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.\\n\\n\\n\\n","      DIM array%(9)\\n      array%() = 7, 14, 21, 28, 35, 42, 49, 56, 63, 70\\n      \\n      secret% = 42\\n      index% = FNwhere(array%(), secret%, 0, DIM(array%(),1))\\n      IF index% >= 0 THEN\\n        PRINT \""The value \""; secret% \"" was found at index \""; index%\\n      ELSE\\n        PRINT \""The value \""; secret% \"" was not found\""\\n      ENDIF\\n      END\\n      \\n      REM Search ordered array A%() for the value S% from index B% to T%\\n      DEF FNwhere(A%(), S%, B%, T%)\\n      LOCAL H%\\n      H% = 2\\n      WHILE H%<(T%-B%) H% *= 2:ENDWHILE\\n      H% /= 2\\n      REPEAT\\n        IF (B%+H%)<=T% IF S%>=A%(B%+H%) B% += H%\\n        H% /= 2\\n      UNTIL H%=0\\n      IF S%=A%(B%) THEN = B% ELSE = -1"
"BASIC","Binary_search","A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a \""divide and conquer\"" algorithm.\\nAs an analogy, consider the children's game \""guess a number.\"" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.\\nAs the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.\\n\\nGiven the starting point of a range, the ending point of a range, and the \""secret value\"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.\\nThere are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.\\nAll of the following code examples use an \""inclusive\"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using \""exclusive\"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):\\nThe algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the \""insertion point\"" for it (the index that the value would have if it were inserted into the array).\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nMake sure it does not have overflow bugs.\\nThe line in the pseudo-code above to calculate the mean of two integers:\\ncould produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.\\nOne way to fix it is to manually add half the range to the low number:\\nEven though this is mathematically equivalent to the above, it is not susceptible to overflow.\\nAnother way for signed integers, possibly faster, is the following:\\nwhere  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.\\n\\n\\n\\n","100 PROGRAM \""Search.bas\""\\n110 RANDOMIZE\\n120 NUMERIC ARR(1 TO 20)\\n130 CALL FILL(ARR)\\n140 PRINT:INPUT PROMPT \""Value: \"":N\\n150 LET IDX=SEARCH(ARR,N)\\n160 IF IDX THEN\\n170   PRINT \""The value\"";N;\""was found the index\"";IDX\\n180 ELSE\\n190   PRINT \""The value\"";N;\""was not found.\""\\n200 END IF\\n210 DEF FILL(REF T)\\n220   LET T(LBOUND(T))=RND(3):PRINT T(1);\\n230   FOR I=LBOUND(T)+1 TO UBOUND(T)\\n240     LET T(I)=T(I-1)+RND(3)+1\\n250     PRINT T(I);\\n260   NEXT\\n270 END DEF\\n280 DEF SEARCH(REF T,N)\\n290   LET SEARCH=0:LET BO=LBOUND(T):LET UP=UBOUND(T)\\n300   DO\\n310     LET K=INT((BO+UP)/2)\\n320     IF T(K)N THEN LET UP=K-1\\n340   LOOP WHILE BO<=UP AND T(K)<>N\\n350   IF BO<=UP THEN LET SEARCH=K\\n360 END DEF"
"BASIC","Binary_strings","Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks.\\nThis task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them. If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language.\\nIn particular the functions you need to create are:\\n\\nPossible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.\\n\\nAda has native support for single dimensioned arrays, which provide all specified operations. String is a case of array. The array of bytes is predefined in Ada in the package System.Storage_Elements (LRM 13.7.1). Storage_Element is substitute for byte.\\nStorage_Array is \""binary string\"" used for memory representation. For stream-oriented I/O communication Ada provides alternative \""binary string\"" called Stream_Element_Array (LRM 13.13.1). When dealing with octets of bits, programmers are encouraged to provide a data type of their own to ensure that the byte is exactly 8 bits length. For example:\\nAlternatively:\\nNote that all of these types will have all operations described above.\\nOutput:\\nOutput:\\nString creation (garbage collection will handle its destruction)\\nusing the string as an atom and casting a character list to a string\\nString assignment\\ncomparing two string\\ncopy a string\\nstring replacement isn't covered by the ansi standard probably best to use (replace-all) or cl-ppcre\\n\\njoining strings works in the same way as appending bytes\\nBlackBox Component Builder\\nExecute: ^Q NpctBinaryString.Do\\nOutput:\\nDéjà Vu has a blob type, which is much like Python 3's bytearray. They are used for dealing with binary data in the standard library, and works basically like a list, except it can only have integer numbers from 0 to 255 as elements, pushing and popping is not supported, and can be resized to any size in a single step.\\n(Since the task is not a specific program, the code here consists of example REPL sessions, not a whole program.)\\nIn E, binary data is represented as ELists (implemented as arrays or ropes) of integers; a String is strictly a character string. ELists come in Flex (mutable) and Const (immutable) varieties.\\nTo work with binary strings we must first have a byte type; this is a place where E shows its Java roots (to be fixed).\\nAs E is a memory-safe garbage-collected language there is no explicit destruction. It is good practice to work with immutable ConstLists when reasonable, however; especially when passing strings around.\\nNote: Elixir data types are immutable.\\n","REM STRING CREATION AND DESTRUCTION (WHEN NEEDED AND IF THERE'S NO GARBAGE COLLECTION OR SIMILAR MECHANISM)\\nA$ = \""STRING\"" : REM CREATION\\nA$ = \""\"" : REM DESTRUCTION\\nPRINT FRE(0) : REM GARBAGE COLLECTION\\n\\nREM STRING ASSIGNMENT\\nA$ = \""STRING\"" : R$ = \""DEUX\""\\n\\nREM STRING COMPARISON\\nPRINT A$ = B$; A$ <> B$; A$ < B$; A$ > B$; A$ <= B$; A$ >= B$\\n\\nREM STRING CLONING AND COPYING\\nB$ = A$\\n\\nREM CHECK IF A STRING IS EMPTY\\nPRINT LEN(A$) = 0\\n\\nREM APPEND A BYTE TO A STRING\\nA$ = A$ + CHR$(0)\\n\\nREM EXTRACT A SUBSTRING FROM A STRING\\nS$ = MID$(A$, 2, 3)\\n\\nREM REPLACE EVERY OCCURRENCE OF A BYTE (OR A STRING) IN A STRING WITH ANOTHER STRING\\nS = LEN(S$) : R = LEN(R$) : A = LEN(A$) : IF A > S THEN B$ = \""\"" : FOR I = 1 TO A : F = MID$(A$, I, S) = S$ : B$ = B$ + MID$(R$, 1, R * F) + MID$(A$, I, F = 0) : NEXT I : A$ = B$ : PRINT A$\\n\\nREM JOIN STRINGS\\nJ$ = A$ + STR$(42) + \"" PUDDLES \"" + B$ + CHR$(255) : REM USE +"
"BASIC","Binary_strings","Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks.\\nThis task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them. If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language.\\nIn particular the functions you need to create are:\\n\\nPossible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.\\n\\nAda has native support for single dimensioned arrays, which provide all specified operations. String is a case of array. The array of bytes is predefined in Ada in the package System.Storage_Elements (LRM 13.7.1). Storage_Element is substitute for byte.\\nStorage_Array is \""binary string\"" used for memory representation. For stream-oriented I/O communication Ada provides alternative \""binary string\"" called Stream_Element_Array (LRM 13.13.1). When dealing with octets of bits, programmers are encouraged to provide a data type of their own to ensure that the byte is exactly 8 bits length. For example:\\nAlternatively:\\nNote that all of these types will have all operations described above.\\nOutput:\\nOutput:\\nString creation (garbage collection will handle its destruction)\\nusing the string as an atom and casting a character list to a string\\nString assignment\\ncomparing two string\\ncopy a string\\nstring replacement isn't covered by the ansi standard probably best to use (replace-all) or cl-ppcre\\n\\njoining strings works in the same way as appending bytes\\nBlackBox Component Builder\\nExecute: ^Q NpctBinaryString.Do\\nOutput:\\nDéjà Vu has a blob type, which is much like Python 3's bytearray. They are used for dealing with binary data in the standard library, and works basically like a list, except it can only have integer numbers from 0 to 255 as elements, pushing and popping is not supported, and can be resized to any size in a single step.\\n(Since the task is not a specific program, the code here consists of example REPL sessions, not a whole program.)\\nIn E, binary data is represented as ELists (implemented as arrays or ropes) of integers; a String is strictly a character string. ELists come in Flex (mutable) and Const (immutable) varieties.\\nTo work with binary strings we must first have a byte type; this is a place where E shows its Java roots (to be fixed).\\nAs E is a memory-safe garbage-collected language there is no explicit destruction. It is good practice to work with immutable ConstLists when reasonable, however; especially when passing strings around.\\nNote: Elixir data types are immutable.\\n","10 REM create two strings\\n20 LET s$ = \""Hello\""\\n30 LET t$ = \""Bob\""\\n40 REM choose any random character\\n50 LET c = INT(RND*256)\\n60 REM add the character to the string\\n70 LET s$ = s$ + CHR$(c)\\n80 REM check if the string is empty\\n90 IF s$ = \""\"" THEN PRINT \""String is empty\""\\n100 REM compare two strings\\n110 IF s$ = t$ THEN PRINT \""Strings are the same\""\\n120 REM print characters 2 to 4 of a string (a substring)\\n130 PRINT s$(2 TO 4)"
"BASIC","Bitmap/Bresenham's_line_algorithm","Using the data storage type defined on the Bitmap page for raster graphics images, draw a line given two points with Bresenham's line algorithm.\\n\\nThe test program's\\nsample output\\n16 bit Intel 8086\\80486 Assembly for dos, see x86 assembly language.\\nTo run this code you will need to use Dos emulator.\\n\\nInstead of swaps in the initialisation use error calculation for both directions x and y simultaneously:\\nPort of the C version.\\nThis code uses the Image defined in Bitmap Task.\\nTo run the demo code compile with -version=bitmap_bresenhams_line_algorithm_main.\\n"," 1500 REM === Draw a line. Ported from C version\\n 1510 REM Inputs are X1, Y1, X2, Y2: Destroys value of X1, Y1\\n 1520 DX = ABS(X2 - X1):SX = -1:IF X1 < X2 THEN SX = 1\\n 1530 DY = ABS(Y2 - Y1):SY = -1:IF Y1 < Y2 THEN SY = 1\\n 1540 ER = -DY:IF DX > DY THEN ER = DX\\n 1550 ER = INT(ER / 2)\\n 1560 PLOT X1,Y1:REM This command may differ depending on BASIC dialect\\n 1570 IF X1 = X2 AND Y1 = Y2 THEN RETURN\\n 1580 E2 = ER\\n 1590 IF E2 > -DX THEN ER = ER - DY:X1 = X1 + SX\\n 1600 IF E2 < DY THEN ER = ER + DX:Y1 = Y1 + SY\\n 1610 GOTO 1560"
"BASIC","Bitwise_operations","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\n\\nWrite a routine to perform a bitwise AND, OR, and XOR on two integers, a bitwise NOT on the first integer, a left shift, right shift, right arithmetic shift, left rotate, and right rotate.\\nAll shifts and rotates should be done on the first integer with a shift/rotate amount of the second integer.\\nIf any operation is not available in your language, note it.\\n\\n","SUB bitwise (a, b)\\n  PRINT a AND b\\n  PRINT a OR b\\n  PRINT a XOR b\\n  PRINT NOT a\\nEND SUB"
"BASIC","Bitwise_operations","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\n\\nWrite a routine to perform a bitwise AND, OR, and XOR on two integers, a bitwise NOT on the first integer, a left shift, right shift, right arithmetic shift, left rotate, and right rotate.\\nAll shifts and rotates should be done on the first integer with a shift/rotate amount of the second integer.\\nIf any operation is not available in your language, note it.\\n\\n","SUB bitwise (a AS Integer, b AS Integer)\\n  DIM u AS UInteger\\n\\n  PRINT \""a AND b = \""; a AND b\\n  PRINT \""a OR b  = \""; a OR b\\n  PRINT \""a XOR b = \""; a XOR b\\n  PRINT \""NOT a   = \""; NOT a\\n  PRINT \""a SHL b = \""; a SHL b\\n  PRINT \""a SHR b (arithmetic) = \""; a SHR b\\n  u = a\\n  PRINT \""a SHR b (logical) = \""; u SHR b\\nEND SUB"
"BASIC","Bitwise_operations","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\n\\nWrite a routine to perform a bitwise AND, OR, and XOR on two integers, a bitwise NOT on the first integer, a left shift, right shift, right arithmetic shift, left rotate, and right rotate.\\nAll shifts and rotates should be done on the first integer with a shift/rotate amount of the second integer.\\nIf any operation is not available in your language, note it.\\n\\n","10 INPUT \""A=\""; A\\n20 INPUT \""B=\""; B\\n30 PRINT \""A AND B =\"" A AND B    :rem AND\\n40 PRINT \""A OR B =\"" A OR B      :rem OR\\n50 PRINT \""A XOR B =\"" (A AND(NOT B))OR((NOT A)AND B)    :rem XOR\\n60 PRINT \""NOT A =\"" NOT A        :rem NOT"
"BASIC","Bitwise_operations","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\n\\nWrite a routine to perform a bitwise AND, OR, and XOR on two integers, a bitwise NOT on the first integer, a left shift, right shift, right arithmetic shift, left rotate, and right rotate.\\nAll shifts and rotates should be done on the first integer with a shift/rotate amount of the second integer.\\nIf any operation is not available in your language, note it.\\n\\n","100 LET A=10:LET B=12\\n110 PRINT A;\""and\"";B;\""=\"";A AND B\\n120 PRINT A;\""band\"";B;\""=\"";A BAND B\\n130 PRINT A;\""or \"";B;\""=\"";A OR B\\n140 PRINT A;\""bor\"";B;\""=\"";A BOR B\\n150 PRINT A;\""xor\"";B;\""=\"";XOR(A,B)\\n160 PRINT \"" not\"";A;\""=\"";NOT A\\n170 DEF XOR(A,B)=(A BOR B)-(A BAND B)"
"BASIC","Bitwise_operations","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\n\\nWrite a routine to perform a bitwise AND, OR, and XOR on two integers, a bitwise NOT on the first integer, a left shift, right shift, right arithmetic shift, left rotate, and right rotate.\\nAll shifts and rotates should be done on the first integer with a shift/rotate amount of the second integer.\\nIf any operation is not available in your language, note it.\\n\\n","           org   4084\\n3a 83 40   ld    a, (4083)\\n47         ld    b, a\\n3a 82 40   ld    a, (4082)\\na0         and   b\\n00         nop            ; negate and shift instructions take 2 bytes\\n06 00      ld    b, 0\\n4f         ld    c, a     ; value in BC reg pair is returned to BASIC\\nc9         ret"
"BASIC","Bitwise_operations","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\n\\nWrite a routine to perform a bitwise AND, OR, and XOR on two integers, a bitwise NOT on the first integer, a left shift, right shift, right arithmetic shift, left rotate, and right rotate.\\nAll shifts and rotates should be done on the first integer with a shift/rotate amount of the second integer.\\nIf any operation is not available in your language, note it.\\n\\n"," 10 REM ABCDEFGHIJKLMNO\\n 20 INPUT A\\n 30 INPUT B\\n 40 POKE 16514,A\\n 50 POKE 16515,B\\n 60 LET ADDR=16516\\n 70 LET R$=\""3A8340473A8240A00006004FC9\""\\n 80 POKE ADDR,CODE R$*16+CODE R$(2)-476\\n 90 LET R$=R$(3 TO )\\n100 LET ADDR=ADDR+1\\n110 IF R$<>\""\"" THEN GOTO 80\\n120 PRINT A;\"" AND \"";B;\"" = \"";USR 16516\\n130 POKE 16523,176\\n140 PRINT A;\"" OR \"";B;\"" = \"";USR 16516\\n150 POKE 16523,168\\n160 PRINT A;\"" XOR \"";B;\"" = \"";USR 16516\\n170 POKE 16523,237\\n180 POKE 16524,68\\n190 PRINT \""NOT \"";A;\"" = \"";USR 16516\\n200 POKE 16523,203\\n210 POKE 16524,39\\n220 FOR I=1 TO B\\n230 POKE 16514,USR 16516\\n240 NEXT I\\n250 PRINT A;\"" << \"";B;\"" = \"";PEEK 16514"
"BASIC","Boolean_values","Show how to represent the boolean states \""true\"" and \""false\"" in a language.\\nIf other objects represent \""true\"" or \""false\"" in conditionals, note it.\\n\\n\\n11l defines a built-in data type Bool, which has two values represented by the constants 0B and 1B.\\nThe are no TRUE or FALSE constants in 360 Assembly; but an often used convention is :\\nA single bit represents true or false. By convention, 0 (cleared) is false, 1 (set) is true.\\nIn the following, \""bit\"" represents the direct address of any of the 256 directly accessible bits.\\nIn 8th, any non-zero number is true, as is the specific boolean value 'true'. Everything else evaluates as 'false' (including the boolean value, 'false')\\nSame as Boolean Values#Common Lisp.\\nAda has a predefined discrete type with the specification:\\nwith Boolean lattice and relational operations defined on it. See RM A.1.\\nALGOL 68 Enforces strong typing and so has few default coercions. The appropriate operators must be used to convert to and from bool[ean] and the following code demonstrates principle conversions:\\n","10 LET A%=0\\n20 LET B%=NOT(A%)\\n30 PRINT \""THIS VERSION OF BASIC USES\""\\n40 PRINT B%; \"" AS ITS TRUE VALUE\""\\n50 IF A% THEN PRINT \""TEST ONE DOES NOT PRINT\""\\n60 IF B% THEN PRINT \""TEST TWO DOES PRINT\""\\n70 IF A%=0 THEN PRINT \""TEST THREE (FALSE BY COMPARISON) DOES PRINT\""\\n80 IF B%=0 THEN PRINT \""TEST FOUR (FALSE BY COMPARISON) DOES NOT PRINT\""\\n90 IF A%<>0 THEN PRINT \""TEST FIVE (TRUE BY COMPARISON) DOES NOT PRINT\""\\n100 IF B%<>0 THEN PRINT \""TEST SIX (TRUE BY COMPARISON) DOES PRINT\""\\n110 END"
"BASIC","Boolean_values","Show how to represent the boolean states \""true\"" and \""false\"" in a language.\\nIf other objects represent \""true\"" or \""false\"" in conditionals, note it.\\n\\n\\n11l defines a built-in data type Bool, which has two values represented by the constants 0B and 1B.\\nThe are no TRUE or FALSE constants in 360 Assembly; but an often used convention is :\\nA single bit represents true or false. By convention, 0 (cleared) is false, 1 (set) is true.\\nIn the following, \""bit\"" represents the direct address of any of the 256 directly accessible bits.\\nIn 8th, any non-zero number is true, as is the specific boolean value 'true'. Everything else evaluates as 'false' (including the boolean value, 'false')\\nSame as Boolean Values#Common Lisp.\\nAda has a predefined discrete type with the specification:\\nwith Boolean lattice and relational operations defined on it. See RM A.1.\\nALGOL 68 Enforces strong typing and so has few default coercions. The appropriate operators must be used to convert to and from bool[ean] and the following code demonstrates principle conversions:\\n","' Boolean TRUE and FALSE are non-zero and zero constants\\na = TRUE\\nb = FALSE\\nPRINT a, \"", \"", b\\n\\nIF 0 THEN PRINT \""TRUE\"" : ELSE PRINT \""FALSE\""\\nIF 1 THEN PRINT \""TRUE\""\\nIF 2 THEN PRINT \""TRUE\"""
"BASIC","Bulls_and_cows","\\nCreate a four digit random number from the digits   1   to   9,   without duplication.\\nThe program should:\\n\\nThe score is computed as:\\n\\n\\nOutput:\\nGUI implementation; the prompt for a guess includes a list of all past guesses and their scores.\\nThe following function contains the code to check how many bulls and cows there are.\\nTo handle I/O, we use functions named say (which simply outputs a string) and prompt (which takes a prompt string to display to the user and returns a line of input, without a trailing newline). These require platform-specific implementations. Here's how they can be implemented for the SpiderMonkey shell:\\nWe can now solve the task using say and prompt:\\n","DEFINT A-Z\\n\\nDIM secret AS STRING\\nDIM guess  AS STRING\\nDIM c      AS STRING\\nDIM bulls, cows, guesses, i\\n\\nRANDOMIZE TIMER\\nDO WHILE LEN(secret) < 4\\n    c = CHR$(INT(RND * 10) + 48)\\n    IF INSTR(secret, c) = 0 THEN secret = secret + c\\nLOOP\\n\\nguesses = 0\\nDO\\n    INPUT \""Guess a 4-digit number with no duplicate digits: \""; guess\\n    guess = LTRIM$(RTRIM$(guess))\\n    IF LEN(guess) = 0 THEN EXIT DO\\n\\n    IF LEN(guess) <> 4 OR VAL(guess) = 0 THEN\\n        PRINT \""** You should enter 4 numeric digits!\""\\n        GOTO looper\\n    END IF\\n\\n    bulls = 0: cows = 0: guesses = guesses + 1\\n    FOR i = 1 TO 4\\n        c = MID$(secret, i, 1)\\n        IF MID$(guess, i, 1) = c THEN\\n            bulls = bulls + 1\\n        ELSEIF INSTR(guess, c) THEN\\n            cows = cows + 1\\n        END IF\\n    NEXT i\\n    PRINT bulls; \"" bulls, \""; cows; \"" cows\""\\n\\n    IF guess = secret THEN\\n        PRINT \""You won after \""; guesses; \"" guesses!\""\\n        EXIT DO\\n    END IF\\nlooper:\\nLOOP"
"BASIC","Bulls_and_cows","\\nCreate a four digit random number from the digits   1   to   9,   without duplication.\\nThe program should:\\n\\nThe score is computed as:\\n\\n\\nOutput:\\nGUI implementation; the prompt for a guess includes a list of all past guesses and their scores.\\nThe following function contains the code to check how many bulls and cows there are.\\nTo handle I/O, we use functions named say (which simply outputs a string) and prompt (which takes a prompt string to display to the user and returns a line of input, without a trailing newline). These require platform-specific implementations. Here's how they can be implemented for the SpiderMonkey shell:\\nWe can now solve the task using say and prompt:\\n","100 D$ = \""123456789\""\\n110 FOR I = 1 TO 4\\n120    P = INT(RND(1) * LEN(D$)) + 1\\n130    N$ = N$ + MID$(D$, P, 1)\\n140    D$ = MID$(D$, 1, P - 1) + MID$(D$, P + 1, 8)\\n150 NEXT\\n160 PRINT \""A RANDOM NUMBER HAS BEEN CREATED.\\n170 PRINT \""THE NUMBER HAS FOUR DIGITS FROM 1 TO 9, WITHOUT DUPLICATION.\""\\n200 FOR Q = 0 TO 1 STEP 0\\n210     INPUT \""GUESS THE NUMBER: \""; G%\\n220     G$ = STR$(G%)\\n230     M = LEN(G$) <> 4 OR G% = 0\\n240     IF NOT M THEN FOR I = 2 TO 4 : M = MID$(G$, I, 1) = \""0\"" : IF NOT M THEN NEXT I\\n250     IF NOT M THEN FOR I = 1 TO 3 : FOR J = I + 1 TO 4 : M = MID$(G$, I, 1) = MID$(G$, J, 1) : IF NOT M THEN NEXT J, I\\n260     IF M THEN PRINT \""THE GUESS IS MALFORMED.\"" : NEXT Q\\n270     B = 0\\n280     C = 0\\n300     FOR I = 1 TO 4\\n310         C$ = MID$(N$, I, 1)\\n320         BULL = MID$(G$, I, 1) = C$\\n330         COW = 0\\n340         IF NOT BULL THEN FOR J = 1 TO 4 : COW = MID$(G$, J, 1) = C$ : IF NOT COW THEN NEXT J\\n350         B = B + BULL\\n360         C = C + COW\\n370     NEXT I\\n380     PRINT B \"" BULLS, \"" C \"" COWS\""\\n390     Q = G$ = N$\\n400 NEXT Q"
"BASIC","Catalan_numbers","\\nCatalan numbers are a sequence of numbers which can be defined directly:\\nOr recursively:\\nOr alternatively (also recursive):\\n\\nImplement at least one of these algorithms and print out the first 15 Catalan numbers with each.\\nMemoization   is not required, but may be worth the effort when using the second method above.\\n\\n\\n","DECLARE FUNCTION catalan (n as INTEGER) AS SINGLE\\n\\nREDIM SHARED results(0) AS SINGLE\\n\\nFOR x% = 1 TO 15\\n    PRINT x%, catalan (x%)\\nNEXT\\n\\nFUNCTION catalan (n as INTEGER) AS SINGLE\\n    IF UBOUND(results) < n THEN REDIM PRESERVE results(n)\\n\\n    IF 0 = n THEN\\n    	results(0) = 1\\n    ELSE\\n    	results(n) = ((2 * ((2 * n) - 1)) / (n + 1)) * catalan(n - 1)\\n    END IF\\n    catalan = results(n)\\nEND FUNCTION"
"BASIC","Catalan_numbers","\\nCatalan numbers are a sequence of numbers which can be defined directly:\\nOr recursively:\\nOr alternatively (also recursive):\\n\\nImplement at least one of these algorithms and print out the first 15 Catalan numbers with each.\\nMemoization   is not required, but may be worth the effort when using the second method above.\\n\\n\\n"," 10 FOR N=0 TO 14\\n 20 LET X=N\\n 30 GOSUB 130\\n 40 LET A=FX\\n 50 LET X=N+1\\n 60 GOSUB 130\\n 70 LET B=FX\\n 80 LET X=2*N\\n 90 GOSUB 130\\n100 PRINT N,FX/(B*A)\\n110 NEXT N\\n120 STOP\\n130 LET FX=1\\n140 FOR I=1 TO X\\n150 LET FX=FX*I\\n160 NEXT I\\n170 RETURN"
"BASIC","Chaos_game","The Chaos Game is a method of generating the attractor of an iterated function system (IFS). One of the best-known and simplest examples creates a fractal, using a polygon and an initial point selected at random.\\n\\nPlay the Chaos Game using the corners of an equilateral triangle as the reference points. Add a starting point at random (preferably inside the triangle). Then add the next point halfway between the starting point and one of the reference points. This reference point is chosen at random.\\nAfter a sufficient number of iterations, the image of a Sierpinski Triangle should emerge.\\n\\n\\nThis should require minimal adaptation to work with any of the older Microsoft-style BASICs. Users of other dialects will need to replace lines 10 and 150 with the appropriate statements to select a graphics output mode (if necessary) and to plot a pixel at x,y in colour v; they should also add LET throughout and 170 END if their dialects require those things.\\nAdapted from the code given above.\\nAdapted from the other BASIC versions. Monochrome and low-resolution, of course. Works with only 1k of RAM. If you like, you can try changing line 30 to go round the loop a different number of times.\\nNote that ZX81 BASIC does not have an explicit computed GOTO; we can, however, actually compute the value of an expression and then GOTO it as a line number.\\n","10 SCREEN 1\\n20 X = INT(RND(0) * 200)\\n30 Y = INT(RND(0) * 173)\\n40 FOR I=1 TO 20000\\n50 V = INT(RND(0) * 3) + 1\\n60 ON V GOTO 70,100,130\\n70 X = X/2\\n80 Y = Y/2\\n90 GOTO 150\\n100 X = 100 + (100-X)/2\\n110 Y = 173 - (173-Y)/2\\n120 GOTO 150\\n130 X = 200 - (200-X)/2\\n140 Y = Y/2\\n150 PSET X,Y,V\\n160 NEXT I"
"BASIC","Chaos_game","The Chaos Game is a method of generating the attractor of an iterated function system (IFS). One of the best-known and simplest examples creates a fractal, using a polygon and an initial point selected at random.\\n\\nPlay the Chaos Game using the corners of an equilateral triangle as the reference points. Add a starting point at random (preferably inside the triangle). Then add the next point halfway between the starting point and one of the reference points. This reference point is chosen at random.\\nAfter a sufficient number of iterations, the image of a Sierpinski Triangle should emerge.\\n\\n\\nThis should require minimal adaptation to work with any of the older Microsoft-style BASICs. Users of other dialects will need to replace lines 10 and 150 with the appropriate statements to select a graphics output mode (if necessary) and to plot a pixel at x,y in colour v; they should also add LET throughout and 170 END if their dialects require those things.\\nAdapted from the code given above.\\nAdapted from the other BASIC versions. Monochrome and low-resolution, of course. Works with only 1k of RAM. If you like, you can try changing line 30 to go round the loop a different number of times.\\nNote that ZX81 BASIC does not have an explicit computed GOTO; we can, however, actually compute the value of an expression and then GOTO it as a line number.\\n","10 HGR2\\n20 X = INT(RND(1) * 200)\\n30 Y = INT(RND(1) * 173)\\n40 FOR I=1 TO 20000\\n50 V = INT(RND(1) * 3) + 1\\n60 ON V GOTO 70,100,130\\n70 X = X/2\\n80 Y = Y/2\\n90 GOTO 150\\n100 X = 100 + (100-X)/2\\n110 Y = 173 - (173-Y)/2\\n120 GOTO 150\\n130 X = 200 - (200-X)/2\\n140 Y = Y/2\\n150 HCOLOR=V+4\\n160 HPLOT X,Y\\n170 NEXT I"
"BASIC","Chaos_game","The Chaos Game is a method of generating the attractor of an iterated function system (IFS). One of the best-known and simplest examples creates a fractal, using a polygon and an initial point selected at random.\\n\\nPlay the Chaos Game using the corners of an equilateral triangle as the reference points. Add a starting point at random (preferably inside the triangle). Then add the next point halfway between the starting point and one of the reference points. This reference point is chosen at random.\\nAfter a sufficient number of iterations, the image of a Sierpinski Triangle should emerge.\\n\\n\\nThis should require minimal adaptation to work with any of the older Microsoft-style BASICs. Users of other dialects will need to replace lines 10 and 150 with the appropriate statements to select a graphics output mode (if necessary) and to plot a pixel at x,y in colour v; they should also add LET throughout and 170 END if their dialects require those things.\\nAdapted from the code given above.\\nAdapted from the other BASIC versions. Monochrome and low-resolution, of course. Works with only 1k of RAM. If you like, you can try changing line 30 to go round the loop a different number of times.\\nNote that ZX81 BASIC does not have an explicit computed GOTO; we can, however, actually compute the value of an expression and then GOTO it as a line number.\\n"," 10 LET X=RND*46\\n 20 LET Y=RND*40\\n 30 FOR I=1 TO 5000\\n 40 LET VERTEX=INT (RND*3)\\n 50 GOTO 60+VERTEX*30\\n 60 LET X=X/2\\n 70 LET Y=Y/2\\n 80 GOTO 140\\n 90 LET X=23+(23-X)/2\\n100 LET Y=40-(40-Y)/2\\n110 GOTO 140\\n120 LET X=46-(46-X)/2\\n130 LET Y=Y/2\\n140 PLOT X,42-Y\\n150 NEXT I"
"BASIC","Chaos_game","The Chaos Game is a method of generating the attractor of an iterated function system (IFS). One of the best-known and simplest examples creates a fractal, using a polygon and an initial point selected at random.\\n\\nPlay the Chaos Game using the corners of an equilateral triangle as the reference points. Add a starting point at random (preferably inside the triangle). Then add the next point halfway between the starting point and one of the reference points. This reference point is chosen at random.\\nAfter a sufficient number of iterations, the image of a Sierpinski Triangle should emerge.\\n\\n\\nThis should require minimal adaptation to work with any of the older Microsoft-style BASICs. Users of other dialects will need to replace lines 10 and 150 with the appropriate statements to select a graphics output mode (if necessary) and to plot a pixel at x,y in colour v; they should also add LET throughout and 170 END if their dialects require those things.\\nAdapted from the code given above.\\nAdapted from the other BASIC versions. Monochrome and low-resolution, of course. Works with only 1k of RAM. If you like, you can try changing line 30 to go round the loop a different number of times.\\nNote that ZX81 BASIC does not have an explicit computed GOTO; we can, however, actually compute the value of an expression and then GOTO it as a line number.\\n"," 10 LET x=RND*200\\n 20 LET y=RND*173\\n 30 FOR i=1 TO 20000\\n 40 LET vertex=INT (RND*3)\\n 50 IF vertex=1 THEN GO TO 100\\n 60 IF vertex=2 THEN GO TO 130\\n 70 LET x=x/2\\n 80 LET y=y/2\\n 90 GO TO 150\\n100 LET x=100+(100-x)/2\\n110 LET y=173-(173-y)/2\\n120 GO TO 150\\n130 LET x=200-(200-x)/2\\n140 LET y=y/2\\n150 INK vertex+1\\n160 PLOT x,y\\n170 NEXT i\\n180 INK 0"
"BASIC","Character_codes","\\nGiven a character value in your language, print its code   (could be ASCII code, Unicode code, or whatever your language uses).\\n\\nThe character   'a'   (lowercase letter A)   has a code of 97 in ASCII   (as well as Unicode, as ASCII forms the beginning of Unicode).\\nConversely, given a code, print out the corresponding character.\\n\\nS/360 architecture and EBCDIC was born together.\\nIn EBCDIC, the character 'a' (lowercase letter A) has a code of 129 in decimal and '81'x in hexadecimal.\\nTo perform conversion, we use IC (insert character) and STC (store character) opcodes.\\n","charCode = 97\\nchar = \""a\""\\nPRINT CHR$(charCode) 'prints a\\nPRINT ASC(char) 'prints 97"
"BASIC","Character_codes","\\nGiven a character value in your language, print its code   (could be ASCII code, Unicode code, or whatever your language uses).\\n\\nThe character   'a'   (lowercase letter A)   has a code of 97 in ASCII   (as well as Unicode, as ASCII forms the beginning of Unicode).\\nConversely, given a code, print out the corresponding character.\\n\\nS/360 architecture and EBCDIC was born together.\\nIn EBCDIC, the character 'a' (lowercase letter A) has a code of 129 in decimal and '81'x in hexadecimal.\\nTo perform conversion, we use IC (insert character) and STC (store character) opcodes.\\n","10 LET c = 97: REM c is a character code\\n20 LET d$ = \""b\"": REM d$ holds the character\\n30 PRINT CHR$(c): REM this prints a\\n40 PRINT CODE(d$): REM this prints 98"
"BASIC","Character_codes","\\nGiven a character value in your language, print its code   (could be ASCII code, Unicode code, or whatever your language uses).\\n\\nThe character   'a'   (lowercase letter A)   has a code of 97 in ASCII   (as well as Unicode, as ASCII forms the beginning of Unicode).\\nConversely, given a code, print out the corresponding character.\\n\\nS/360 architecture and EBCDIC was born together.\\nIn EBCDIC, the character 'a' (lowercase letter A) has a code of 129 in decimal and '81'x in hexadecimal.\\nTo perform conversion, we use IC (insert character) and STC (store character) opcodes.\\n","?CHR$(97)\""=\""ASC(CHR$(97))"
"BASIC","Character_codes","\\nGiven a character value in your language, print its code   (could be ASCII code, Unicode code, or whatever your language uses).\\n\\nThe character   'a'   (lowercase letter A)   has a code of 97 in ASCII   (as well as Unicode, as ASCII forms the beginning of Unicode).\\nConversely, given a code, print out the corresponding character.\\n\\nS/360 architecture and EBCDIC was born together.\\nIn EBCDIC, the character 'a' (lowercase letter A) has a code of 129 in decimal and '81'x in hexadecimal.\\nTo perform conversion, we use IC (insert character) and STC (store character) opcodes.\\n","' ASCII\\nc$ = \""$\""\\nPRINT c$, \"": \"", ASC(c$)\\n\\n' UTF-8\\nuc$ = \""€\""\\nPRINT uc$, \"": \"", UCS(uc$), \"", \"", UCS(c$)"
"BASIC","Character_codes","\\nGiven a character value in your language, print its code   (could be ASCII code, Unicode code, or whatever your language uses).\\n\\nThe character   'a'   (lowercase letter A)   has a code of 97 in ASCII   (as well as Unicode, as ASCII forms the beginning of Unicode).\\nConversely, given a code, print out the corresponding character.\\n\\nS/360 architecture and EBCDIC was born together.\\nIn EBCDIC, the character 'a' (lowercase letter A) has a code of 129 in decimal and '81'x in hexadecimal.\\nTo perform conversion, we use IC (insert character) and STC (store character) opcodes.\\n","10 REM THE ZX81 USES ITS OWN NON-ASCII CHARACTER SET\\n20 REM WHICH DOES NOT INCLUDE LOWER-CASE LETTERS\\n30 PRINT CODE \""A\""\\n40 PRINT CHR$ 38"
"BASIC","Character_codes","\\nGiven a character value in your language, print its code   (could be ASCII code, Unicode code, or whatever your language uses).\\n\\nThe character   'a'   (lowercase letter A)   has a code of 97 in ASCII   (as well as Unicode, as ASCII forms the beginning of Unicode).\\nConversely, given a code, print out the corresponding character.\\n\\nS/360 architecture and EBCDIC was born together.\\nIn EBCDIC, the character 'a' (lowercase letter A) has a code of 129 in decimal and '81'x in hexadecimal.\\nTo perform conversion, we use IC (insert character) and STC (store character) opcodes.\\n","10 CH = 65:        REM IN PETSCII CODE FOR 'A' IS 65\\n20 D$ = \""B\"":       REM D$ HOLDS THE CHARACTER 'B'\\n30 PRINT CHR$(CH): REM THIS PRINTS 'A'\\n40 PRINT ASC(D$):  REM THIS PRINTS 66"
"BASIC","Character_codes","\\nGiven a character value in your language, print its code   (could be ASCII code, Unicode code, or whatever your language uses).\\n\\nThe character   'a'   (lowercase letter A)   has a code of 97 in ASCII   (as well as Unicode, as ASCII forms the beginning of Unicode).\\nConversely, given a code, print out the corresponding character.\\n\\nS/360 architecture and EBCDIC was born together.\\nIn EBCDIC, the character 'a' (lowercase letter A) has a code of 129 in decimal and '81'x in hexadecimal.\\nTo perform conversion, we use IC (insert character) and STC (store character) opcodes.\\n","100 PRINT ORD(\""A\"")\\n110 PRINT CHR$(65)"
"BASIC","Check_that_file_exists","Verify that a file called     input.txt     and   a directory called     docs     exist.\\n\\nThis should be done twice:  \\n\\nOptional criteria (May 2015):   verify it works with:\\n\\nThis example should work with any Ada 95 compiler.\\nThis example should work with any Ada 2005 compiler.\\nThe stat function returns a System.Stat object for an existing file or directory, or null if it can't be found.\\nUses the Algol 68G specific \""file is directory\"" procedure to test for the existence of directories.\\n(macOS JavaScript for Automation)\\n","\\nON ERROR GOTO ohNo\\nf$ = \""input.txt\""\\nGOSUB opener\\nf$ = \""\\input.txt\""\\nGOSUB opener\\n\\n'can't directly check for directories,\\n'but can check for the NUL device in the desired dir\\nf$ = \""docs\\nul\""\\nGOSUB opener\\nf$ = \""\\docs\\nul\""\\nGOSUB opener\\nEND\\n\\nopener:\\n    e$ = \"" found\""\\n    OPEN f$ FOR INPUT AS 1\\n    PRINT f$; e$\\n    CLOSE\\n    RETURN\\n\\nohNo:\\n    IF (53 = ERR) OR (76 = ERR) THEN\\n        e$ = \"" not\"" + e$\\n    ELSE\\n        e$ = \""Unknown error\""\\n    END IF\\n    RESUME NEXT\\n"
"BASIC","Check_that_file_exists","Verify that a file called     input.txt     and   a directory called     docs     exist.\\n\\nThis should be done twice:  \\n\\nOptional criteria (May 2015):   verify it works with:\\n\\nThis example should work with any Ada 95 compiler.\\nThis example should work with any Ada 2005 compiler.\\nThe stat function returns a System.Stat object for an existing file or directory, or null if it can't be found.\\nUses the Algol 68G specific \""file is directory\"" procedure to test for the existence of directories.\\n(macOS JavaScript for Automation)\\n","\\nON ERROR GOTO ohNo\\nd$ = \""docs\""\\nCHDIR d$\\nd$ = \""\\docs\""\\nCHDIR d$\\nEND\\n\\nohNo:\\n    IF 76 = ERR THEN\\n        PRINT d$; \"" not found\""\\n    ELSE\\n        PRINT \""Unknown error\""\\n    END IF\\n    RESUME NEXT\\n"
"BASIC","Check_that_file_exists","Verify that a file called     input.txt     and   a directory called     docs     exist.\\n\\nThis should be done twice:  \\n\\nOptional criteria (May 2015):   verify it works with:\\n\\nThis example should work with any Ada 95 compiler.\\nThis example should work with any Ada 2005 compiler.\\nThe stat function returns a System.Stat object for an existing file or directory, or null if it can't be found.\\nUses the Algol 68G specific \""file is directory\"" procedure to test for the existence of directories.\\n(macOS JavaScript for Automation)\\n","\\nf$ = \""input.txt\""\\nGOSUB opener\\nf$ = \""\\input.txt\""\\nGOSUB opener\\n\\n'can't directly check for directories,\\n'but can check for the NUL device in the desired dir\\nf$ = \""docs\\nul\""\\nGOSUB opener\\nf$ = \""\\docs\\nul\""\\nGOSUB opener\\nEND\\n\\nopener:\\n    d$ = DIR$(f$)\\n    IF LEN(d$) THEN\\n        PRINT f$; \"" found\""\\n    ELSE\\n        PRINT f$; \"" not found\""\\n    END IF\\n    RETURN\\n"
"BASIC","Check_that_file_exists","Verify that a file called     input.txt     and   a directory called     docs     exist.\\n\\nThis should be done twice:  \\n\\nOptional criteria (May 2015):   verify it works with:\\n\\nThis example should work with any Ada 95 compiler.\\nThis example should work with any Ada 2005 compiler.\\nThe stat function returns a System.Stat object for an existing file or directory, or null if it can't be found.\\nUses the Algol 68G specific \""file is directory\"" procedure to test for the existence of directories.\\n(macOS JavaScript for Automation)\\n","' File exists\\nf$ = \""input.txt\""\\nd$ = \""docs\""\\nIF FILEEXISTS(f$) THEN PRINT f$, \"" exists\""\\nIF FILEEXISTS(d$) AND FILETYPE(d$) = 2 THEN PRINT d$, \"" directory exists\""\\n\\nf$ = \""/\"" & f$\\nd$ = \""/\"" & d$\\nPRINT f$, IIF$(FILEEXISTS(f$), \"" exists\"", \"" does not exist\"")\\nPRINT d$, IIF$(FILEEXISTS(d$) AND FILETYPE(d$) = 2, \"" is\"", \"" is not\""), \"" a directory\""\\n\\nf$ = \""empty.bac\""\\nPRINT f$, IIF$(FILEEXISTS(f$), \"" exists\"", \"" does not exist\"")\\n\\nf$ = \""`Abdu'l-Bahá.txt\""\\nPRINT f$, IIF$(FILEEXISTS(f$), \"" exists\"", \"" does not exist\"")"
"BASIC","Check_that_file_exists","Verify that a file called     input.txt     and   a directory called     docs     exist.\\n\\nThis should be done twice:  \\n\\nOptional criteria (May 2015):   verify it works with:\\n\\nThis example should work with any Ada 95 compiler.\\nThis example should work with any Ada 2005 compiler.\\nThe stat function returns a System.Stat object for an existing file or directory, or null if it can't be found.\\nUses the Algol 68G specific \""file is directory\"" procedure to test for the existence of directories.\\n(macOS JavaScript for Automation)\\n","10 REM CHECK FILE EXISTS\\n15 ER=0:EM$=\""\"":MSG$=\""FILE EXISTS.\""\\n20 PRINT CHR$(147);:REM CLEAR SCREEN\\n30 FI$=\""\"":INPUT \""ENTER FILENAME TO CHECK\"";FI$:PRINT\\n35 IF FI$=\""\"" THEN PRINT \""ABORTED.\"":END\\n40 OPEN 8,8,8,FI$\\n50 GOSUB 1000:REM FETCH ERROR STATUS FROM DRIVE: 0=OK, 62=FILE NOT FOUND\\n55 REM COMPARE ERROR NUMBER\\n60 IF ER<>0 THEN MSG$=\""I/O ERROR:\""+STR$(ER)+\"" \""+EM$\\n70 IF ER=62 THEN MSG$=\""'\""+FI$+\""' IS NOT HERE.\""\\n80 REM DO THINGS WITH FILE...\\n100 CLOSE 8\\n110 PRINT MSG$\\n120 PRINT:GOTO 30:REM REPEAT UNTIL EMPTY FILENAME IS ENTERED\\n1000 REM CHECK ERROR CHANNEL FOR STATUS OF LAST DISK OPERATION\\n1010 OPEN 15,8,15\\n1015 REM GET ERROR CODE, ERROR MESSAGE, TRACK, SECTOR\\n1020 INPUT#15,ER,EM$,T,S\\n1030 CLOSE 15\\n1040 RETURN"
"BASIC","Circles_of_given_radius_through_two_points","Given two points on a plane and a radius, usually two circles of given radius can be drawn through the points.\\n\\n\\n\\n\\nCalculations based on the C solution.\\n","Type Point\\n    As Double x,y\\n    Declare Property length As Double\\nEnd Type\\n\\nProperty point.length As Double\\nReturn Sqr(x*x+y*y)\\nEnd Property\\n\\nSub circles(p1 As Point,p2 As Point,radius As Double)\\n    Print \""Points \"";\""(\""&p1.x\"",\""&p1.y\""),(\""&p2.x\"",\""&p2.y\"")\"";\"", Rad \"";radius\\n    Var ctr=Type<Point>((p1.x+p2.x)/2,(p1.y+p2.y)/2)\\n    Var half=Type<Point>(p1.x-ctr.x,p1.y-ctr.y)\\n    Var lenhalf=half.length\\n    If radius Circle 1 (\""&rot.x\"",\""&rot.y\"")\""\\n    rot= Type<Point>(-(rot.x-ctr.x) +ctr.x,-((rot.y-ctr.y)) +ctr.y)\\n    Print\"" -> Circle 2 (\""&rot.x\"",\""&rot.y\"")\""\\n    Print\\nEnd Sub\\n\\n\\nDim As Point p1=(.1234,.9876),p2=(.8765,.2345)\\ncircles(p1,p2,2)\\np1=Type<Point>(0,2):p2=Type<Point>(0,0)\\ncircles(p1,p2,1)\\np1=Type<Point>(.1234,.9876):p2=p1\\ncircles(p1,p2,2)\\np1=Type<Point>(.1234,.9876):p2=Type<Point>(.8765,.2345)\\ncircles(p1,p2,.5)\\np1=Type<Point>(.1234,.9876):p2=p1\\ncircles(p1,p2,0)\\n\\nSleep"
"BASIC","Classes","In object-oriented programming class is a set (a transitive closure) of types bound by the relation of inheritance. It is said that all types derived from some base type T and the type T itself form a class T.\\nThe first type T from the class T sometimes is called the root type of the class.\\nA class of types itself, as a type, has the values and operations of its own.\\nThe operations of are usually called methods of the root type.\\nBoth operations and values are called  polymorphic.\\nA polymorphic operation (method) selects an implementation depending on the actual specific type of the polymorphic argument.\\nThe action of choice the type-specific implementation of a polymorphic operation is called dispatch. Correspondingly, polymorphic operations are often called dispatching or virtual.\\nOperations with multiple arguments and/or the results of the class are called multi-methods.\\nA further generalization of is the operation with arguments and/or results from different classes.\\n\\nA polymorphic value has a type tag indicating its specific type from the class and the corresponding specific value of that type.\\nThis type is sometimes called the most specific type of a [polymorphic] value.\\nThe type tag of the value is used in order to resolve the dispatch.\\nThe set of polymorphic values of a class is a transitive closure of the sets of values of all types from that class.\\nIn many  OO languages\\nthe type of the class of T and T itself are considered equivalent.\\nIn some languages they are distinct (like in Ada).\\nWhen class T and T are equivalent, there is no way to distinguish\\npolymorphic and specific values.\\n\\nCreate a basic class with a method, a constructor, an instance variable and how to instantiate it.\\n\\nNote that member functions in 11l by default are not polymorphic; if you want a polymorphic member function, you have to mark it as virtual. Example:\\nClass is used in many languages to provide both encapsulation, or grouping of data and actions, and type definition. Ada packages provide encapsulation or grouping while type definitions are done using the type reserved word. Types participating in inheritance are named tagged record types.\\nA package specification has the following form:\\nThe type declaration at the top of the package gives public visibility to the private tagged type My_Type. Since My_Type is declared to be private, the public has no visibility of its structure. The type must be treated as a black box. The private section of the package specification includes the actual tagged record definition. Note that the data member Variable is initialized to -12. This corresponds to a default constructor for the type.\\nThe package body must contain the implementation of the procedures and functions declared in the package specification.\\nThe Set function acts as a conversion constructor for My_Type.\\nAn instance is typically created outside the package:\\nAikido provides classes with single inheritance and multiple interface implementation. A class takes a set of constructor arguments and provides a set of public functions, operators, classes, monitors and threads.\\nThe following code is experimental. Basically ALGOL 68 is not object oriented, so the task to create (and use of) objects is tedious due to the lack of certain constructs, especially the lack of OO syntactic sugar.\\nFor further details:\\nOther examples of this experimental approach are located at pages: Life in two dimensions, Playing Cards and Stack.\\n","  DECLARE SUB MyClassDelete (pthis AS MyClass)\\n  DECLARE SUB MyClassSomeMethod (pthis AS MyClass)\\n  DECLARE SUB MyClassInit (pthis AS MyClass)\\n\\n  TYPE MyClass\\n    Variable AS INTEGER\\n  END TYPE\\n\\n  DIM obj AS MyClass\\n  MyClassInit obj\\n  MyClassSomeMethod obj\\n\\n  SUB MyClassInit (pthis AS MyClass)\\n    pthis.Variable = 0\\n  END SUB\\n\\n  SUB MyClassSomeMethod (pthis AS MyClass)\\n    pthis.Variable = 1\\n  END SUB"
"BASIC","Code_segment_unload","Some advanced applications, such as memory resident applications, daemons and memory demanding applications unload unrequired parts of the application during use (such as initialization code that will no longer be used again once the application is operational) to free up memory and resources. Demonstrate or explain how to unload an unused section of code from memory.\\nNote that it is sufficient to flag the memory area as being available for reuse by the memory management system, without the need to demonstrate the zeroing of the bytes and performing a memory shuffle, unless such actions are required to free up the code segment.\\nLanguages that do not have the facility to free up their code segment (such as scripting languages) can be omitted.\\nSome versions of basic have the facility to delete lines of code:\\nThe CANCEL statement in COBOL unloads from memory the dynamically-loadable module containing the specified program or entry-point.\\n","10 GOSUB 5000: REM call initializer\\n20 DELETE 5000-9999: REM delete initializer\\n30 PRINT A: REM show initializer worked\\n40 LIST: REM show initializer has gone\\n50 END\\n\\n5000 REM this is a dummy initializer\\n5010 LET A=1\\n5020 RETURN"
"BASIC","Color_of_a_screen_pixel","Get color information from an arbitrary pixel on the screen, such as the current location of the mouse cursor.\\nThe mouse cursor may or may not have to be active in a GUI created by your program. These functions are OS related.\\n\\nApp Inventor has two Canvas blocks to determine the color under a pixel.\\nGetBackgroundPixelColor returns a color from the Canvas but ignores Ball sprites and ImageSprites.\\nGetPixelColor returns a color from either the Canvas or a Ball sprite or ImageSprite.\\nIn the app's display below, the purple Ball sprite was touched on the left canvas, but the pixel color (green) returned was from the area below it.\\n<VIEW THE BLOCKS AND ANDROID APP DISPLAY>\\nLow-Resolution (Lo-Res) graphics 40x48, 16 colors, page 1\\nHi-Resolution (Hi-Res) graphics 280x192, 6 colors\\nThere is no HSCRN( X,Y) function in Applesoft. What follows is an elaborate subroutine that determines the hi-res color at the location given by variables X and Y on the current hi-res page. A color value in the range from 0 to 7 is returned in the variable C. The color is determined by peeking at adjacent pixels and the Most Significant Bit MSB. The VTAB routine is used as an aid to calculate the address of pixels. Other colors beyond the 6 hi-res colors can be displayed by positioning pixels at byte boundaries using the MSB. This routine is limited to the eight hi-res colors.\\n","color = point(x, y)"
"BASIC","Colour_bars/Display","Display a series of vertical color bars across the width of the display.\\nThe color bars should either use:\\n\\nThis task achieved only on Commodore computers with color capabilities. The example below tested as-is in VICE on the following machines:\\n\\nIt will also work well on the VIC-20 if you either omit line 310 or comment (REM) it out as the VIC-20 has only an eight-color palette.\\nThis cross-compatibility is achieved by using the PETSCII control codes (CHR$(x)) for changing color, which are generally the same across all platforms, although the system palettes themselves may differ. This is combined with printing a \""reverse video\"" space (solid block) character in the color selected.\\nShow the default MODE 0 palette (includes two blinking colors at the end):\\nPress Enter or Escape to exit the program.\\n\\nAssuming a terminal with support for ANSI escape sequences, this fills the screen with the colour sequence: black, red, green, blue, magenta, cyan, yellow and white. It then waits for the user to press Enter before terminating.\\nThis task requires functionality which allows the code to communicate to the video device. This will vary from vendor to vendor. The following examples show two ways of doing this, in the text and graphics mode, using Borland's Turbo C.\\nThe required functions and structures are in conio.h\\nThe required functions and structures are in graphics.h, conio.h is included for getch().\\nusing Qt 4.6\\nfile colorbars.h:\\nfile colorbars.cpp:\\nfile main.cpp:\\nThis program extends ANS Forth to control the TMS9918 Video display processor in the TI-99 computer.\\n The color bars are shown in Society of Motion Picture and Television Engineers (SMPTE) order.\\n","1 DATA1,12,6,3,14,13,15\\n2 HOME : GR : FOR I = 1 TO 7\\n3                 READ C(I) : NEXT\\n4 FOR I = 0 TO 39\\n5     COLOR= C(I / 5)\\n6     VLIN 0,39 AT I : NEXT"
"BASIC","Colour_bars/Display","Display a series of vertical color bars across the width of the display.\\nThe color bars should either use:\\n\\nThis task achieved only on Commodore computers with color capabilities. The example below tested as-is in VICE on the following machines:\\n\\nIt will also work well on the VIC-20 if you either omit line 310 or comment (REM) it out as the VIC-20 has only an eight-color palette.\\nThis cross-compatibility is achieved by using the PETSCII control codes (CHR$(x)) for changing color, which are generally the same across all platforms, although the system palettes themselves may differ. This is combined with printing a \""reverse video\"" space (solid block) character in the color selected.\\nShow the default MODE 0 palette (includes two blinking colors at the end):\\nPress Enter or Escape to exit the program.\\n\\nAssuming a terminal with support for ANSI escape sequences, this fills the screen with the colour sequence: black, red, green, blue, magenta, cyan, yellow and white. It then waits for the user to press Enter before terminating.\\nThis task requires functionality which allows the code to communicate to the video device. This will vary from vendor to vendor. The following examples show two ways of doing this, in the text and graphics mode, using Borland's Turbo C.\\nThe required functions and structures are in conio.h\\nThe required functions and structures are in graphics.h, conio.h is included for getch().\\nusing Qt 4.6\\nfile colorbars.h:\\nfile colorbars.cpp:\\nfile main.cpp:\\nThis program extends ANS Forth to control the TMS9918 Video display processor in the TI-99 computer.\\n The color bars are shown in Society of Motion Picture and Television Engineers (SMPTE) order.\\n","      SW_MAXIMIZE = 3\\n      SYS \""ShowWindow\"", @hwnd%, SW_MAXIMIZE\\n      VDU 26\\n      \\n      W% = @vdu%!208 / 4\\n      H% = @vdu%!212 * 2\\n      \\n      COLOUR 1,9\\n      COLOUR 2,10\\n      COLOUR 3,12\\n      COLOUR 4,13\\n      COLOUR 5,14\\n      COLOUR 6,11\\n      COLOUR 7,15\\n      \\n      FOR C% = 0 TO 7\\n        GCOL C%\\n        RECTANGLE FILL C%*W%, 0, W%, H%\\n      NEXT\\n"
"BASIC","Colour_bars/Display","Display a series of vertical color bars across the width of the display.\\nThe color bars should either use:\\n\\nThis task achieved only on Commodore computers with color capabilities. The example below tested as-is in VICE on the following machines:\\n\\nIt will also work well on the VIC-20 if you either omit line 310 or comment (REM) it out as the VIC-20 has only an eight-color palette.\\nThis cross-compatibility is achieved by using the PETSCII control codes (CHR$(x)) for changing color, which are generally the same across all platforms, although the system palettes themselves may differ. This is combined with printing a \""reverse video\"" space (solid block) character in the color selected.\\nShow the default MODE 0 palette (includes two blinking colors at the end):\\nPress Enter or Escape to exit the program.\\n\\nAssuming a terminal with support for ANSI escape sequences, this fills the screen with the colour sequence: black, red, green, blue, magenta, cyan, yellow and white. It then waits for the user to press Enter before terminating.\\nThis task requires functionality which allows the code to communicate to the video device. This will vary from vendor to vendor. The following examples show two ways of doing this, in the text and graphics mode, using Borland's Turbo C.\\nThe required functions and structures are in conio.h\\nThe required functions and structures are in graphics.h, conio.h is included for getch().\\nusing Qt 4.6\\nfile colorbars.h:\\nfile colorbars.cpp:\\nfile main.cpp:\\nThis program extends ANS Forth to control the TMS9918 Video display processor in the TI-99 computer.\\n The color bars are shown in Society of Motion Picture and Television Engineers (SMPTE) order.\\n","5 REM COLOR BARS PROGRAM\\n10 PRINT CHR$(147);:DIM CO(17):C=1\\n20 READ CO(C):IF CO(C)>0 THEN C=C+1:GOTO 20\\n25 SP$=\""     \"":H=22:C=C-1:REM SP$=5 SPACES\\n30 FOR R=1 TO C STEP INT(C/2)\\n40 FOR H=1 TO 10\\n50 FOR B=R TO (R+INT(C/2))-1\\n60 PRINT CHR$(18);CHR$(CO(B));SP$;\\n70 NEXT B\\n75 REM CHECK IF PALETTE IS ONLY 8 (VIC-20). \\n76 REM IF SO, WE NEED TO FILL THE LAST TWO SPACES.\\n80 IF C<=8 THEN PRINT \""  \"";\\n90 NEXT H:NEXT R\\n100 GET K$:IF K$=\""\"" THEN 100\\n110 END\\n280 REM BECAUSE THE CONTROL CODES FOR COLOR ARE NON-SEQUENTIAL,\\n285 REM WE PUT THEM INTO A SEQUENTIAL ARRAY FOR USE\\n300 DATA 144,5,28,159,156,30,31,158\\n305 REM OMIT OR REM THE NEXT LINE FOR VIC-20\\n310 DATA 129,149,150,151,152,153,154,155\\n320 DATA 0:REM DATA TERMINATOR"
"BASIC","Colour_bars/Display","Display a series of vertical color bars across the width of the display.\\nThe color bars should either use:\\n\\nThis task achieved only on Commodore computers with color capabilities. The example below tested as-is in VICE on the following machines:\\n\\nIt will also work well on the VIC-20 if you either omit line 310 or comment (REM) it out as the VIC-20 has only an eight-color palette.\\nThis cross-compatibility is achieved by using the PETSCII control codes (CHR$(x)) for changing color, which are generally the same across all platforms, although the system palettes themselves may differ. This is combined with printing a \""reverse video\"" space (solid block) character in the color selected.\\nShow the default MODE 0 palette (includes two blinking colors at the end):\\nPress Enter or Escape to exit the program.\\n\\nAssuming a terminal with support for ANSI escape sequences, this fills the screen with the colour sequence: black, red, green, blue, magenta, cyan, yellow and white. It then waits for the user to press Enter before terminating.\\nThis task requires functionality which allows the code to communicate to the video device. This will vary from vendor to vendor. The following examples show two ways of doing this, in the text and graphics mode, using Borland's Turbo C.\\nThe required functions and structures are in conio.h\\nThe required functions and structures are in graphics.h, conio.h is included for getch().\\nusing Qt 4.6\\nfile colorbars.h:\\nfile colorbars.cpp:\\nfile main.cpp:\\nThis program extends ANS Forth to control the TMS9918 Video display processor in the TI-99 computer.\\n The color bars are shown in Society of Motion Picture and Television Engineers (SMPTE) order.\\n","nomainwin\\ncolors$=\""black red green blue pink cyan yellow white\""\\nWindowWidth=DisplayWidth:WindowHeight=DisplayHeight\\nUpperLeftX=1:UpperLeftY=1\\nbarWidth=DisplayWidth/8\\ngraphicbox #main.g, 0,0,DisplayWidth,DisplayHeight\\nopen \""\"" for window_popup as #main\\n#main \""trapclose [quit]\""\\n#main.g \""down; setfocus; when characterInput [quit]\""\\n#main.g \""when leftButtonUp [quit]\""\\n#main.g \""size \"";barWidth\\n\\nfor x = barWidth/2 to DisplayWidth step barWidth\\n    i=i+1\\n    if i>8 then i=1\\n    col$=word$(colors$,i)\\n    #main.g \""color \"";col$;\""; line \"";x;\"" 0 \"";x;\"" \"";DisplayHeight\\nnext\\nwait\\n[quit] close #main:end \\n "
"BASIC","Colour_bars/Display","Display a series of vertical color bars across the width of the display.\\nThe color bars should either use:\\n\\nThis task achieved only on Commodore computers with color capabilities. The example below tested as-is in VICE on the following machines:\\n\\nIt will also work well on the VIC-20 if you either omit line 310 or comment (REM) it out as the VIC-20 has only an eight-color palette.\\nThis cross-compatibility is achieved by using the PETSCII control codes (CHR$(x)) for changing color, which are generally the same across all platforms, although the system palettes themselves may differ. This is combined with printing a \""reverse video\"" space (solid block) character in the color selected.\\nShow the default MODE 0 palette (includes two blinking colors at the end):\\nPress Enter or Escape to exit the program.\\n\\nAssuming a terminal with support for ANSI escape sequences, this fills the screen with the colour sequence: black, red, green, blue, magenta, cyan, yellow and white. It then waits for the user to press Enter before terminating.\\nThis task requires functionality which allows the code to communicate to the video device. This will vary from vendor to vendor. The following examples show two ways of doing this, in the text and graphics mode, using Borland's Turbo C.\\nThe required functions and structures are in conio.h\\nThe required functions and structures are in graphics.h, conio.h is included for getch().\\nusing Qt 4.6\\nfile colorbars.h:\\nfile colorbars.cpp:\\nfile main.cpp:\\nThis program extends ANS Forth to control the TMS9918 Video display processor in the TI-99 computer.\\n The color bars are shown in Society of Motion Picture and Television Engineers (SMPTE) order.\\n","10 MODE 0:BORDER 23\\n20 FOR x=0 TO 15\\n30 ORIGIN x*40,0\\n40 GRAPHICS PEN x\\n50 FOR z=0 TO 39 STEP 4:MOVE z,0:DRAW z,400:NEXT\\n60 NEXT\\n70 CALL &bb06 ' wait for key press"
"BASIC","Colour_bars/Display","Display a series of vertical color bars across the width of the display.\\nThe color bars should either use:\\n\\nThis task achieved only on Commodore computers with color capabilities. The example below tested as-is in VICE on the following machines:\\n\\nIt will also work well on the VIC-20 if you either omit line 310 or comment (REM) it out as the VIC-20 has only an eight-color palette.\\nThis cross-compatibility is achieved by using the PETSCII control codes (CHR$(x)) for changing color, which are generally the same across all platforms, although the system palettes themselves may differ. This is combined with printing a \""reverse video\"" space (solid block) character in the color selected.\\nShow the default MODE 0 palette (includes two blinking colors at the end):\\nPress Enter or Escape to exit the program.\\n\\nAssuming a terminal with support for ANSI escape sequences, this fills the screen with the colour sequence: black, red, green, blue, magenta, cyan, yellow and white. It then waits for the user to press Enter before terminating.\\nThis task requires functionality which allows the code to communicate to the video device. This will vary from vendor to vendor. The following examples show two ways of doing this, in the text and graphics mode, using Borland's Turbo C.\\nThe required functions and structures are in conio.h\\nThe required functions and structures are in graphics.h, conio.h is included for getch().\\nusing Qt 4.6\\nfile colorbars.h:\\nfile colorbars.cpp:\\nfile main.cpp:\\nThis program extends ANS Forth to control the TMS9918 Video display processor in the TI-99 computer.\\n The color bars are shown in Society of Motion Picture and Television Engineers (SMPTE) order.\\n","Dim color(7)\\ncolor(0) = RGB($00, $00, $00) ;black\\ncolor(1) = RGB($FF, $00, $00) ;red\\ncolor(2) = RGB($00, $FF, $00) ;green\\ncolor(3) = RGB($00, $00, $FF) ;blue\\ncolor(4) = RGB($FF, $00, $FF) ;magenta\\ncolor(5) = RGB($00, $FF, $FF) ;cyan\\ncolor(6) = RGB($FF, $FF, $00) ;yellow\\ncolor(7) = RGB($FF, $FF, $FF) ;white \\n\\nIf Not InitKeyboard(): End: EndIf    ;can't init keyboard\\nIf Not InitSprite(): End: EndIf      ;can't init sprite/screen library\\nIf Not ExamineDesktops(): End: EndIf ;can't retrieve information about desktop\\n\\nheight = DesktopHeight(0)\\nwidth = DesktopWidth(0)\\ndepth = DesktopDepth(0)\\nIf OpenScreen(width, height, depth, \""Press ENTER to exit\"")\\n  StartDrawing(ScreenOutput())\\n    For c = 0 To 7\\n      Box((width * c) / 8, 0, width / 8, height, color(c))\\n    Next\\n  StopDrawing()\\n  FlipBuffers()\\n\\n  Repeat\\n    Delay(10)\\n    ExamineKeyboard()\\n  Until KeyboardPushed(#PB_Key_Escape) Or KeyboardPushed(#PB_Key_Return)\\n  CloseScreen()\\nEndIf"
"BASIC","Colour_bars/Display","Display a series of vertical color bars across the width of the display.\\nThe color bars should either use:\\n\\nThis task achieved only on Commodore computers with color capabilities. The example below tested as-is in VICE on the following machines:\\n\\nIt will also work well on the VIC-20 if you either omit line 310 or comment (REM) it out as the VIC-20 has only an eight-color palette.\\nThis cross-compatibility is achieved by using the PETSCII control codes (CHR$(x)) for changing color, which are generally the same across all platforms, although the system palettes themselves may differ. This is combined with printing a \""reverse video\"" space (solid block) character in the color selected.\\nShow the default MODE 0 palette (includes two blinking colors at the end):\\nPress Enter or Escape to exit the program.\\n\\nAssuming a terminal with support for ANSI escape sequences, this fills the screen with the colour sequence: black, red, green, blue, magenta, cyan, yellow and white. It then waits for the user to press Enter before terminating.\\nThis task requires functionality which allows the code to communicate to the video device. This will vary from vendor to vendor. The following examples show two ways of doing this, in the text and graphics mode, using Borland's Turbo C.\\nThe required functions and structures are in conio.h\\nThe required functions and structures are in graphics.h, conio.h is included for getch().\\nusing Qt 4.6\\nfile colorbars.h:\\nfile colorbars.cpp:\\nfile main.cpp:\\nThis program extends ANS Forth to control the TMS9918 Video display processor in the TI-99 computer.\\n The color bars are shown in Society of Motion Picture and Television Engineers (SMPTE) order.\\n","DataSection\\n  ;Black, Red, Green, Blue, Magenta, Cyan, Yellow, White\\n  Data.i  0, 12, 10, 9, 13, 11, 14, 15\\nEndDataSection\\n\\nDim colors(7)\\nFor c = 0 To 7\\n  Read.i colors(c)\\nNext \\n\\nIf OpenConsole()\\n  ;The console display is 80 columns wide by 25 rows\\n  For r = 0 To 24\\n    For c = 0 To 7 \\n      ConsoleColor(colors(c), colors(c))\\n      Print(Space(80 / 8))\\n    Next\\n  Next\\n  EnableGraphicalConsole(1)\\n  ConsoleLocate(0, 0)\\n  \\n  ConsoleTitle(\""Press ENTER to exit\""): Input()\\n  CloseConsole()\\nEndIf"
"BASIC","Colour_bars/Display","Display a series of vertical color bars across the width of the display.\\nThe color bars should either use:\\n\\nThis task achieved only on Commodore computers with color capabilities. The example below tested as-is in VICE on the following machines:\\n\\nIt will also work well on the VIC-20 if you either omit line 310 or comment (REM) it out as the VIC-20 has only an eight-color palette.\\nThis cross-compatibility is achieved by using the PETSCII control codes (CHR$(x)) for changing color, which are generally the same across all platforms, although the system palettes themselves may differ. This is combined with printing a \""reverse video\"" space (solid block) character in the color selected.\\nShow the default MODE 0 palette (includes two blinking colors at the end):\\nPress Enter or Escape to exit the program.\\n\\nAssuming a terminal with support for ANSI escape sequences, this fills the screen with the colour sequence: black, red, green, blue, magenta, cyan, yellow and white. It then waits for the user to press Enter before terminating.\\nThis task requires functionality which allows the code to communicate to the video device. This will vary from vendor to vendor. The following examples show two ways of doing this, in the text and graphics mode, using Borland's Turbo C.\\nThe required functions and structures are in conio.h\\nThe required functions and structures are in graphics.h, conio.h is included for getch().\\nusing Qt 4.6\\nfile colorbars.h:\\nfile colorbars.cpp:\\nfile main.cpp:\\nThis program extends ANS Forth to control the TMS9918 Video display processor in the TI-99 computer.\\n The color bars are shown in Society of Motion Picture and Television Engineers (SMPTE) order.\\n","colors$ = \""black,red,green,blue,magenta,cyan,yellow,white\""\\nhtml \""\""\\nfor i = 1 to 8\\n  html \""\""\\nnext i\\nhtml \""\"""
"BASIC","Colour_bars/Display","Display a series of vertical color bars across the width of the display.\\nThe color bars should either use:\\n\\nThis task achieved only on Commodore computers with color capabilities. The example below tested as-is in VICE on the following machines:\\n\\nIt will also work well on the VIC-20 if you either omit line 310 or comment (REM) it out as the VIC-20 has only an eight-color palette.\\nThis cross-compatibility is achieved by using the PETSCII control codes (CHR$(x)) for changing color, which are generally the same across all platforms, although the system palettes themselves may differ. This is combined with printing a \""reverse video\"" space (solid block) character in the color selected.\\nShow the default MODE 0 palette (includes two blinking colors at the end):\\nPress Enter or Escape to exit the program.\\n\\nAssuming a terminal with support for ANSI escape sequences, this fills the screen with the colour sequence: black, red, green, blue, magenta, cyan, yellow and white. It then waits for the user to press Enter before terminating.\\nThis task requires functionality which allows the code to communicate to the video device. This will vary from vendor to vendor. The following examples show two ways of doing this, in the text and graphics mode, using Borland's Turbo C.\\nThe required functions and structures are in conio.h\\nThe required functions and structures are in graphics.h, conio.h is included for getch().\\nusing Qt 4.6\\nfile colorbars.h:\\nfile colorbars.cpp:\\nfile main.cpp:\\nThis program extends ANS Forth to control the TMS9918 Video display processor in the TI-99 computer.\\n The color bars are shown in Society of Motion Picture and Television Engineers (SMPTE) order.\\n","10 REM The ZX Spectrum display is 32 columns wide, so we have 8 columns of 4 spaces\\n20 FOR r=0 TO 20: REM There are 21 rows\\n30 FOR c=0 TO 7: REM We use the native colour sequence here\\n40 PAPER c: REM set the background colour for the spaces to be printed\\n50 PRINT \""    \"";: REM four spaces, the semicolon prevents newline\\n60 NEXT c\\n70 REM at this point the cursor has wrapped, so we don't need a newline\\n80 NEXT r"
"BASIC","Command-line_arguments","See also Program name.\\nFor parsing command line arguments intelligently, see Parsing command-line arguments.\\nExample command line:\\n:argv is a list containing all command line arguments, including the program name.\\nIn Ada95 and later versions, command line arguments are available through the predefined package Ada.Command_Line. In Ada83, this would be implementation dependent.\\nUses Matreshka\\nThe arguments are passed to the program as a vector of strings called args\\nLinux command:\\nOutput:\\nFrom the AutoHotkey documentation:\\n\""The script sees incoming parameters as the variables %1%, %2%, and so on. In addition, %0% contains the number of parameters passed (0 if none). \""\\n\\nInvoke Babel in interactive mode with arguments using the -i switch:\\nPrint the argv list with newlines:\\n","PRINT \""args: '\""; COMMAND$; \""'\"""
"BASIC","Command-line_arguments","See also Program name.\\nFor parsing command line arguments intelligently, see Parsing command-line arguments.\\nExample command line:\\n:argv is a list containing all command line arguments, including the program name.\\nIn Ada95 and later versions, command line arguments are available through the predefined package Ada.Command_Line. In Ada83, this would be implementation dependent.\\nUses Matreshka\\nThe arguments are passed to the program as a vector of strings called args\\nLinux command:\\nOutput:\\nFrom the AutoHotkey documentation:\\n\""The script sees incoming parameters as the variables %1%, %2%, and so on. In addition, %0% contains the number of parameters passed (0 if none). \""\\n\\nInvoke Babel in interactive mode with arguments using the -i switch:\\nPrint the argv list with newlines:\\n","DIM i AS INTEGER\\n\\nPRINT COMMAND$\\n\\nPRINT \""This program is named \""; COMMAND$(0)\\ni = 1\\nDO WHILE(LEN(COMMAND$(i)))\\n    PRINT \""The argument \""; i; \"" is \""; COMMAND$(i)\\n    i = i + 1\\nLOOP\\n\\nFOR i = 0 TO __FB_ARGC__ - 1\\n        PRINT \""arg \""; i; \"" = '\""; *__FB_ARGV__[i]; \""'\""\\nNEXT i"
"BASIC","Command-line_arguments","See also Program name.\\nFor parsing command line arguments intelligently, see Parsing command-line arguments.\\nExample command line:\\n:argv is a list containing all command line arguments, including the program name.\\nIn Ada95 and later versions, command line arguments are available through the predefined package Ada.Command_Line. In Ada83, this would be implementation dependent.\\nUses Matreshka\\nThe arguments are passed to the program as a vector of strings called args\\nLinux command:\\nOutput:\\nFrom the AutoHotkey documentation:\\n\""The script sees incoming parameters as the variables %1%, %2%, and so on. In addition, %0% contains the number of parameters passed (0 if none). \""\\n\\nInvoke Babel in interactive mode with arguments using the -i switch:\\nPrint the argv list with newlines:\\n","' Command line arguments including program name\\nPRINT \""Entire command line: \"", ARGUMENT$\\n\\nSPLIT ARGUMENT$ BY \"" \"" TO cli$ SIZE args\\nPRINT \""Skip program name:\"";\\nFOR i = 1 TO args - 1\\n    PRINT \"" \"" & cli$[i];\\nNEXT\\nPRINT"
"BASIC","Comments","Show all ways to include text in a language source file\\nthat's completely ignored by the compiler or interpreter.\\n\\n\\n\\nNote: syntax depends on the assembler software but use of a semicolon is fairly standard\\nNote: syntax depends on the assembler software but use of a semicolon is fairly standard\\nJust like Common Lisp:\\nAgena has single line comments and two styles of multi-line comments.\\nA comment in ALGOL 60 takes the place of a single instruction.\\nComments can be inserted in variety of ways:\\nincludes bold typeface.\\nlike to Wiki markup.\\n7-bit/ascii implementations.\\ndetecting reserved words.\\n6-bits/byte implementations.\\ncomment text comment\\n'comment' text 'comment'\\nCOMMENT text COMMENT\\ncomment text comment\\n.COMMENT TEXT .COMMENT\\nNotes:\\nComments in Algol W can appear anywhere whitespace is allowed. A comment starts with the reserved word 'comment' and ends with the next semi-colon. Alternatively a comment can start with a percent sign and end with the next percent sign or semi-colon.\\nA single word in the form of an identifier following the reserved word 'end' is also a comment.\\nArendelle uses C style comments\\nSee programming introduction in the Asymptote manual.\\nWhen reading data files a comment character in them can be specified as comment=\""#\"" etc. See Files in the Asymptote manual.\\nFor multi-line comments, the /* and */ must be on their own separate lines. Nothing else can be on the same line.\\nThe hash symbol # start a comment; it ends at the end of line.\\n\\nThe only truly standard method of marking a comment in BASIC is using the REM keyword. This dates back to (at least) the late 1970's, and should work with most BASICs available today:\\nThis may not be well known, but you may include text after the line number of GOTO and GOSUB statements. This is kind of a comment in absence of labels.\\nSpaces are removed from non-keyword text. BASIC keywords can be used.\\nList outputs spaces around keywords.\\nMost BASICs also support alternate comment characters,\\ncommonly an apostrophe (single quote):\\nCharacters other than apostrophe are used in some BASICs. For example, DarkBASIC uses a back-tick character (`, a.k.a. grave accent):\\nIn addition to single-line comments, a few BASICs support block comments. FreeBASIC was influenced by the C family's block comment characters:\\nBaCon accepts REM (or single quote apostrophe) for line comments.\\nC-style block comments can be used with /* and */ pairs; these comment blocks may cross line boundaries.\\nInside USEC sections, all comment styles accepted by the configured C compiler will also be ignored.\\nThere is another (unsupported) option, using a double-colon ::. However, this has issues with some syntactic constructs and therefore may raise syntax errors.\\nSince comment lines are skipped entirely by the parser multi-line comments aren't possible even with line continuation.\\n\\nLike Brainf***, all characters and whitespace which are not commands are ignored.\\nAlso, since the code/data-space is two-dimensional, comments can be placed anywhere that will be untouched by the instruction pointer and data access commands.\\nFinally, in Funge-98, the ; instruction immediately skips to the next ; instruction, which allows to isolate comments from code.\\nBracmat uses curly braces as comment delimiters. Curly braces inside comments must be balanced. Comments are so much ignored when source code is read, that they do not reappear in listings created by the built-in lst$ function, an otherwise very useful function to autoindent your code.\\nMost ASCII characters may be used for comments; only the eight characters \""+-<>[],.\"" are Brainf*** commands. Extra care must be used when using punctuation, particularly the comma or period. These are I/O operators and are actually commands rather than comments, and are instead compiled into the program if used and may have to be \""debugged\"" and removed if you forget this issue.\\nBurlesque does NOT have comments. However, you can comment code by pushing a string and popping it immediately.\\nSince strings are multi-line strings:\\nThe comment starts at the /*, and ends at the */. A comment may be used between any tokens. It cannot be used inside tokens, that is, given the code\\nthe function takes an argument of type char, named isma, not an unnamed argument of type charisma.\\nComments cannot be nested; that is, if you write\\nthe comment ends at the first */, and inside */ is again interpreted as source code (almost certainly causing a compile error). Some compilers have the option to allow nested comments, but this is not a standard feature.\\nConditional compilation also can be used to make the compiler ignore some text:\\nThe trick is that 0 is always false, therefore the text between #if 0 and #endif is never compiled. While this should never be used for actual comments, it's an easy way to comment out some code, especially because it doesn't interfere with normal (documentation) comments.\\nConditional compile \""comments\"" can be nested:\\nEven though the compiler doesn't see #if 0 text, the preprocessor does. Therefore some minimal rules still have to be followed. For example, the following code is not valid:\\nThat's because the preprocessor will interpret the apostrophe as beginning of a character constant, and will complain because that character constant isn't terminated with another apostrophe.\\nNote that the problem mentioned above cannot occur if there's valid code between the #if 0 and #endif.\\nSingle line C++-style comments\\nC++-style comments start with // and reach up to, but not including, the end of line (more exactly, up to the next unescaped newline). While formally, C++-style comments cannot be nested either, in practice they can:\\nThat's because starting with the first // everything in the line is ignored, including the second //.\\nThe fact that the newline is not part of the comment is important for multi-line macro definitions. It means that in the code\\nthe line (no more macro text) is not part of the macro definition. Also escaping the line break at the end of the comment with '\\' doesn't help, because that would make the third line part of the comment instead. Comments inside macros therefore have to be C-style.\\nClean comments are similar to C++.\\nIn contrast to C++ comments can be nested.\\nAnything from a semicolon to the end of a line is a comment.\\nThe (comment) macro will prevent a form from being evaluated, returning nil no matter what is contained in the comment. However the forms inside the comment form must be properly parseable (parentheses balanced, etc.) or an exception will be thrown.\\nFinally, the #_ reader macro will cause a form to be ignored by the reader. Unlike (comment), this does not return nil; the surrounding code is evaluated as though the ignored form isn't even there.\\nA D in the 7th column indicates a debugging line which is treated like a comment unless a compiler flag is set.\\nThis indicates a debugging line like above, but if it is used in fixed format files, it must be in the 8th column or beyond. Not necessarily. GnuCOBOL also supports D as an indicator in column 7, the >>D format works (more by trickery than spec) if the angle brackets start in column 5, the D ending up in column 7. The >>D debug marker can then be both fixed and free form compatible.\\nThis statement causes everything following it up to the next separator period to be treated as a comment. This statement was deleted in COBOL-74.\\nThere are quite a few IDENTIFICATION DIVISION obsolete and extension reserved words that will work in GnuCOBOL 2.\\nIn tags:\\nIn script:\\nCommon Lisp provides line comments (;) and block comments (#|...|#).\\nBlock comments can nest (#|...#|...|#...|#), unlike block comments in e.g. C.\\nIn a common convention, header comments are prefaced with four semicolons, top-level (function level) comments use three, comments for sections of code use two, and margin comments use one.\\nHowever, comments should not be used for inline documentation, as most defining constructs permit a documentation string (which is then available at runtime).\\nThere is no comment syntax in POSIX dc. The convention is to make a string on the stack and move it to an unused register; a no-op.\\nGNU dc added the comment syntax of many other scripting languages.\\nComments are only allowed in places such as \""on load\"" scripts. You cannot put them in form or view definitions.\\nIn addition to Pascal, Delphi also allows C++ style single line comments:\\nAll comments span to the end of the line; there are no paired-delimiter comment syntaxes. “#” begins a comment anywhere outside of quotes; “?” and “>” begin comments only if they are at the beginning of a line (except for whitespace), because those characters are also used for infix operators.\\nIn Updoc, “?” indicates the beginning of a program fragment, “>” the continuation of one, and “#” begins the expected output from its evaluation; “??” indicates special directives.\\nSingle-line comments must begin with //\\nBlock comments must be delimited with /* and */\\nThe original EDSAC made no provision for comments in source code. Modern simulators, however, accept square brackets as comment delimiters.\\nElixir does not have multiple line comments.\\nA comment is started by ; and reaches to the end of the line.\\nThere are some coding conventions for ;; align to indentation, ;;; sections, etc,\\nAnother way to add comments is to use strings at places where the result of an expression is ignored, since they simply evaluate to themselves without any effect. Note that strings can be multi-line:\\nNote that strings at the beginning of function definitions are interpreted as documentation strings for the function (i.e. Emacs will display them if asked for help about the function), e.g.\\nDue to this, it's debatable if the string at that place can be considered as comment.\\n\\nSingle line comment:\\n\\nMultiline C-style comment:\\nF# accepts C++ type line comments and OCaml type block comments\\nFalcon supports C-language style single line and block comments. A single line comment begins with two slashes (//) and ends at the end of the line. A block comment begins with a slash followed by an asterisk, and terminates when an asterisk followed by a slash is met (/*...*/).\\nSince ><> is a funge-like language, all characters not touched by the command pointer or modified by the p and g commands can be comments.\\nUnlike Brainf***, unknown commands are not ignored by the compiler, they just raise an error.\\nStandard Forth includes a number of ways to add comment text. As with everything in Forth, comment characters are actually words that control the compiler.\\nTraditionally, the paren comments are used for \""stack effect\"" notation:\\nThis comment means \""myword takes two cells on the stack and leaves one\"". Sometimes, stack effect comment names give clues about the word's function:\\nSome Forth systems implement other commenting words, such as these words from Win32Forth:\\nCompiler: ANSI FORTRAN 77 or compatible (like g77 -strict)\\nThe first six columns in Fortran are traditionally reserved for labels and certain special characters. In particular the letter \""C\"" in the first column indicates a comment:\\nSome Fortran compilers have the extension that comments starting with D are treated as non-comments if a special debugging flag is given at the compiler invocation. For example:\\nISO Fortran 90 or later have an inline comment (!) syntax:\\nIn ISO Fortran 90 or later, \""C in first column\"" comments are only allowed in the \""fixed\"" source form familiar to FORTRAN 77 programmers. The \""free\"" source form only has inline comments (!).\\nISO Fortran 95 or later has an optional conditional compilation syntax. If present, it can be used (abused?) to (in effect) comment out blocks of code:\\n\\nIn gambas, comments can be inserted by prefixing them with an apostrophe. The gambas interpreter will ignore the apostrophe and any other characters that follow it until the end of the line:\\nA shebang (#!) may be used as a comment in the first line of a file.\\nsingle-line comment:\\nmulti-line comment:\\nThe way backslash continues a comment means that comments can't usefully be put within a multi-line function definition,\\n# through to newline.\\n// works similarly but is reckoned the \""old way\"" (as of Gri 2.12.23)\\nBoth forms can be used in input data files too.\\nAny text after \""#\"" is a comment.\\nThe The Icon Programming Library established conventions for commenting library additions and functions. This included both header block comments and meta comments on procedures within library files.\\nThe comment character in IDL is the semicolon - everything starting with it and to the end of the line is a comment. Like this:\\nJava has two ways to enter normal comments, plus a third type of comment that doubles as a way to generate HTML documentation.\\nThis C-style comment starts with /* and ends with */.\\nThe two delimiters may be on the same or separate lines.\\nThis style comment may be used anywhere white space is permitted.\\nThis C++-style comment starts with // and extends to the end of line.\\nJavadoc is a standardized documentation code for Java. Its comments begin with a forward slash and two stars. Javadoc comments have different tags that signify different things in the methods and classes that they precede.\\nYour editor will probably colour this as great big comment, but it compiles and prints \""Hello World!\"". Once you've figured out how this works, try this discussion on why it's allowed.\\nfirst form\\nsecond form\\nMulti-line comments cannot be nested.\\n\\nExcept when a hash symbol (#) appears within a string, it begins a comment that continues to the end of the line:\\nThis image is a VI Snippet, an executable image of LabVIEW code. The LabVIEW version is shown on the top-right hand corner. You can download it, then drag-and-drop it onto the LabVIEW block diagram from a file browser, and it will appear as runnable, editable code.\\nIn LaTeX, comments look like this:\\nLaTeX comments start with % and continue up to and including the line break. The fact that the line break itself is commented out as well makes it useful for adding line breaks in the source code of complex macros without LaTeX interpreting them (which may cause extra space or even a paragraph break in the resulting typeset text). For example, the following results in the one word \""understandable\"":\\nWithout the percent sign after \\firstpart{stand}, it would have been the two words \""understand able\"".\\nThere are two kinds of comments:\\nand\\nLike with C, block comments don't nest.\\nIn Lingo any line starting with \""--\"" is a comment and ignored by the interpreter.\\nLotusScript has two ways to enter comments.\\nWherever the single quote (') is used, the rest of the line is treated as a comment and ignored. Multi-line comments would each need a single quote mark. This style of comment is usually used for making small in-line or single line comments.\\nA %REM marker begins a comment block, and a %END REM marker ends the comment block. This style of comment is used for making longer multi-line comments, often at the beginning of a class, sub or function.\\nThe author of LSE comments the stack effect of words with header comments as follows:\\nThere is no multi line comment. We have to use ' or \\\\nThere are three types of remarks. After statement with a dark color, in a line, with no statements, with the current pen color, and the Rem statement. Rem statement skip statements in current line, but m2000 editor render these using syntax highlight.\\n\\n","100 REM Standard BASIC comments begin with \""REM\"" (remark) and extend to the end of the line\\n110 PRINT \""this is code\"": REM comment after statement"
"BASIC","Comments","Show all ways to include text in a language source file\\nthat's completely ignored by the compiler or interpreter.\\n\\n\\n\\nNote: syntax depends on the assembler software but use of a semicolon is fairly standard\\nNote: syntax depends on the assembler software but use of a semicolon is fairly standard\\nJust like Common Lisp:\\nAgena has single line comments and two styles of multi-line comments.\\nA comment in ALGOL 60 takes the place of a single instruction.\\nComments can be inserted in variety of ways:\\nincludes bold typeface.\\nlike to Wiki markup.\\n7-bit/ascii implementations.\\ndetecting reserved words.\\n6-bits/byte implementations.\\ncomment text comment\\n'comment' text 'comment'\\nCOMMENT text COMMENT\\ncomment text comment\\n.COMMENT TEXT .COMMENT\\nNotes:\\nComments in Algol W can appear anywhere whitespace is allowed. A comment starts with the reserved word 'comment' and ends with the next semi-colon. Alternatively a comment can start with a percent sign and end with the next percent sign or semi-colon.\\nA single word in the form of an identifier following the reserved word 'end' is also a comment.\\nArendelle uses C style comments\\nSee programming introduction in the Asymptote manual.\\nWhen reading data files a comment character in them can be specified as comment=\""#\"" etc. See Files in the Asymptote manual.\\nFor multi-line comments, the /* and */ must be on their own separate lines. Nothing else can be on the same line.\\nThe hash symbol # start a comment; it ends at the end of line.\\n\\nThe only truly standard method of marking a comment in BASIC is using the REM keyword. This dates back to (at least) the late 1970's, and should work with most BASICs available today:\\nThis may not be well known, but you may include text after the line number of GOTO and GOSUB statements. This is kind of a comment in absence of labels.\\nSpaces are removed from non-keyword text. BASIC keywords can be used.\\nList outputs spaces around keywords.\\nMost BASICs also support alternate comment characters,\\ncommonly an apostrophe (single quote):\\nCharacters other than apostrophe are used in some BASICs. For example, DarkBASIC uses a back-tick character (`, a.k.a. grave accent):\\nIn addition to single-line comments, a few BASICs support block comments. FreeBASIC was influenced by the C family's block comment characters:\\nBaCon accepts REM (or single quote apostrophe) for line comments.\\nC-style block comments can be used with /* and */ pairs; these comment blocks may cross line boundaries.\\nInside USEC sections, all comment styles accepted by the configured C compiler will also be ignored.\\nThere is another (unsupported) option, using a double-colon ::. However, this has issues with some syntactic constructs and therefore may raise syntax errors.\\nSince comment lines are skipped entirely by the parser multi-line comments aren't possible even with line continuation.\\n\\nLike Brainf***, all characters and whitespace which are not commands are ignored.\\nAlso, since the code/data-space is two-dimensional, comments can be placed anywhere that will be untouched by the instruction pointer and data access commands.\\nFinally, in Funge-98, the ; instruction immediately skips to the next ; instruction, which allows to isolate comments from code.\\nBracmat uses curly braces as comment delimiters. Curly braces inside comments must be balanced. Comments are so much ignored when source code is read, that they do not reappear in listings created by the built-in lst$ function, an otherwise very useful function to autoindent your code.\\nMost ASCII characters may be used for comments; only the eight characters \""+-<>[],.\"" are Brainf*** commands. Extra care must be used when using punctuation, particularly the comma or period. These are I/O operators and are actually commands rather than comments, and are instead compiled into the program if used and may have to be \""debugged\"" and removed if you forget this issue.\\nBurlesque does NOT have comments. However, you can comment code by pushing a string and popping it immediately.\\nSince strings are multi-line strings:\\nThe comment starts at the /*, and ends at the */. A comment may be used between any tokens. It cannot be used inside tokens, that is, given the code\\nthe function takes an argument of type char, named isma, not an unnamed argument of type charisma.\\nComments cannot be nested; that is, if you write\\nthe comment ends at the first */, and inside */ is again interpreted as source code (almost certainly causing a compile error). Some compilers have the option to allow nested comments, but this is not a standard feature.\\nConditional compilation also can be used to make the compiler ignore some text:\\nThe trick is that 0 is always false, therefore the text between #if 0 and #endif is never compiled. While this should never be used for actual comments, it's an easy way to comment out some code, especially because it doesn't interfere with normal (documentation) comments.\\nConditional compile \""comments\"" can be nested:\\nEven though the compiler doesn't see #if 0 text, the preprocessor does. Therefore some minimal rules still have to be followed. For example, the following code is not valid:\\nThat's because the preprocessor will interpret the apostrophe as beginning of a character constant, and will complain because that character constant isn't terminated with another apostrophe.\\nNote that the problem mentioned above cannot occur if there's valid code between the #if 0 and #endif.\\nSingle line C++-style comments\\nC++-style comments start with // and reach up to, but not including, the end of line (more exactly, up to the next unescaped newline). While formally, C++-style comments cannot be nested either, in practice they can:\\nThat's because starting with the first // everything in the line is ignored, including the second //.\\nThe fact that the newline is not part of the comment is important for multi-line macro definitions. It means that in the code\\nthe line (no more macro text) is not part of the macro definition. Also escaping the line break at the end of the comment with '\\' doesn't help, because that would make the third line part of the comment instead. Comments inside macros therefore have to be C-style.\\nClean comments are similar to C++.\\nIn contrast to C++ comments can be nested.\\nAnything from a semicolon to the end of a line is a comment.\\nThe (comment) macro will prevent a form from being evaluated, returning nil no matter what is contained in the comment. However the forms inside the comment form must be properly parseable (parentheses balanced, etc.) or an exception will be thrown.\\nFinally, the #_ reader macro will cause a form to be ignored by the reader. Unlike (comment), this does not return nil; the surrounding code is evaluated as though the ignored form isn't even there.\\nA D in the 7th column indicates a debugging line which is treated like a comment unless a compiler flag is set.\\nThis indicates a debugging line like above, but if it is used in fixed format files, it must be in the 8th column or beyond. Not necessarily. GnuCOBOL also supports D as an indicator in column 7, the >>D format works (more by trickery than spec) if the angle brackets start in column 5, the D ending up in column 7. The >>D debug marker can then be both fixed and free form compatible.\\nThis statement causes everything following it up to the next separator period to be treated as a comment. This statement was deleted in COBOL-74.\\nThere are quite a few IDENTIFICATION DIVISION obsolete and extension reserved words that will work in GnuCOBOL 2.\\nIn tags:\\nIn script:\\nCommon Lisp provides line comments (;) and block comments (#|...|#).\\nBlock comments can nest (#|...#|...|#...|#), unlike block comments in e.g. C.\\nIn a common convention, header comments are prefaced with four semicolons, top-level (function level) comments use three, comments for sections of code use two, and margin comments use one.\\nHowever, comments should not be used for inline documentation, as most defining constructs permit a documentation string (which is then available at runtime).\\nThere is no comment syntax in POSIX dc. The convention is to make a string on the stack and move it to an unused register; a no-op.\\nGNU dc added the comment syntax of many other scripting languages.\\nComments are only allowed in places such as \""on load\"" scripts. You cannot put them in form or view definitions.\\nIn addition to Pascal, Delphi also allows C++ style single line comments:\\nAll comments span to the end of the line; there are no paired-delimiter comment syntaxes. “#” begins a comment anywhere outside of quotes; “?” and “>” begin comments only if they are at the beginning of a line (except for whitespace), because those characters are also used for infix operators.\\nIn Updoc, “?” indicates the beginning of a program fragment, “>” the continuation of one, and “#” begins the expected output from its evaluation; “??” indicates special directives.\\nSingle-line comments must begin with //\\nBlock comments must be delimited with /* and */\\nThe original EDSAC made no provision for comments in source code. Modern simulators, however, accept square brackets as comment delimiters.\\nElixir does not have multiple line comments.\\nA comment is started by ; and reaches to the end of the line.\\nThere are some coding conventions for ;; align to indentation, ;;; sections, etc,\\nAnother way to add comments is to use strings at places where the result of an expression is ignored, since they simply evaluate to themselves without any effect. Note that strings can be multi-line:\\nNote that strings at the beginning of function definitions are interpreted as documentation strings for the function (i.e. Emacs will display them if asked for help about the function), e.g.\\nDue to this, it's debatable if the string at that place can be considered as comment.\\n\\nSingle line comment:\\n\\nMultiline C-style comment:\\nF# accepts C++ type line comments and OCaml type block comments\\nFalcon supports C-language style single line and block comments. A single line comment begins with two slashes (//) and ends at the end of the line. A block comment begins with a slash followed by an asterisk, and terminates when an asterisk followed by a slash is met (/*...*/).\\nSince ><> is a funge-like language, all characters not touched by the command pointer or modified by the p and g commands can be comments.\\nUnlike Brainf***, unknown commands are not ignored by the compiler, they just raise an error.\\nStandard Forth includes a number of ways to add comment text. As with everything in Forth, comment characters are actually words that control the compiler.\\nTraditionally, the paren comments are used for \""stack effect\"" notation:\\nThis comment means \""myword takes two cells on the stack and leaves one\"". Sometimes, stack effect comment names give clues about the word's function:\\nSome Forth systems implement other commenting words, such as these words from Win32Forth:\\nCompiler: ANSI FORTRAN 77 or compatible (like g77 -strict)\\nThe first six columns in Fortran are traditionally reserved for labels and certain special characters. In particular the letter \""C\"" in the first column indicates a comment:\\nSome Fortran compilers have the extension that comments starting with D are treated as non-comments if a special debugging flag is given at the compiler invocation. For example:\\nISO Fortran 90 or later have an inline comment (!) syntax:\\nIn ISO Fortran 90 or later, \""C in first column\"" comments are only allowed in the \""fixed\"" source form familiar to FORTRAN 77 programmers. The \""free\"" source form only has inline comments (!).\\nISO Fortran 95 or later has an optional conditional compilation syntax. If present, it can be used (abused?) to (in effect) comment out blocks of code:\\n\\nIn gambas, comments can be inserted by prefixing them with an apostrophe. The gambas interpreter will ignore the apostrophe and any other characters that follow it until the end of the line:\\nA shebang (#!) may be used as a comment in the first line of a file.\\nsingle-line comment:\\nmulti-line comment:\\nThe way backslash continues a comment means that comments can't usefully be put within a multi-line function definition,\\n# through to newline.\\n// works similarly but is reckoned the \""old way\"" (as of Gri 2.12.23)\\nBoth forms can be used in input data files too.\\nAny text after \""#\"" is a comment.\\nThe The Icon Programming Library established conventions for commenting library additions and functions. This included both header block comments and meta comments on procedures within library files.\\nThe comment character in IDL is the semicolon - everything starting with it and to the end of the line is a comment. Like this:\\nJava has two ways to enter normal comments, plus a third type of comment that doubles as a way to generate HTML documentation.\\nThis C-style comment starts with /* and ends with */.\\nThe two delimiters may be on the same or separate lines.\\nThis style comment may be used anywhere white space is permitted.\\nThis C++-style comment starts with // and extends to the end of line.\\nJavadoc is a standardized documentation code for Java. Its comments begin with a forward slash and two stars. Javadoc comments have different tags that signify different things in the methods and classes that they precede.\\nYour editor will probably colour this as great big comment, but it compiles and prints \""Hello World!\"". Once you've figured out how this works, try this discussion on why it's allowed.\\nfirst form\\nsecond form\\nMulti-line comments cannot be nested.\\n\\nExcept when a hash symbol (#) appears within a string, it begins a comment that continues to the end of the line:\\nThis image is a VI Snippet, an executable image of LabVIEW code. The LabVIEW version is shown on the top-right hand corner. You can download it, then drag-and-drop it onto the LabVIEW block diagram from a file browser, and it will appear as runnable, editable code.\\nIn LaTeX, comments look like this:\\nLaTeX comments start with % and continue up to and including the line break. The fact that the line break itself is commented out as well makes it useful for adding line breaks in the source code of complex macros without LaTeX interpreting them (which may cause extra space or even a paragraph break in the resulting typeset text). For example, the following results in the one word \""understandable\"":\\nWithout the percent sign after \\firstpart{stand}, it would have been the two words \""understand able\"".\\nThere are two kinds of comments:\\nand\\nLike with C, block comments don't nest.\\nIn Lingo any line starting with \""--\"" is a comment and ignored by the interpreter.\\nLotusScript has two ways to enter comments.\\nWherever the single quote (') is used, the rest of the line is treated as a comment and ignored. Multi-line comments would each need a single quote mark. This style of comment is usually used for making small in-line or single line comments.\\nA %REM marker begins a comment block, and a %END REM marker ends the comment block. This style of comment is used for making longer multi-line comments, often at the beginning of a class, sub or function.\\nThe author of LSE comments the stack effect of words with header comments as follows:\\nThere is no multi line comment. We have to use ' or \\\\nThere are three types of remarks. After statement with a dark color, in a line, with no statements, with the current pen color, and the Rem statement. Rem statement skip statements in current line, but m2000 editor render these using syntax highlight.\\n\\n"," 'this is a comment\\n PRINT \""this is code\""  'comment after statement"
"BASIC","Comments","Show all ways to include text in a language source file\\nthat's completely ignored by the compiler or interpreter.\\n\\n\\n\\nNote: syntax depends on the assembler software but use of a semicolon is fairly standard\\nNote: syntax depends on the assembler software but use of a semicolon is fairly standard\\nJust like Common Lisp:\\nAgena has single line comments and two styles of multi-line comments.\\nA comment in ALGOL 60 takes the place of a single instruction.\\nComments can be inserted in variety of ways:\\nincludes bold typeface.\\nlike to Wiki markup.\\n7-bit/ascii implementations.\\ndetecting reserved words.\\n6-bits/byte implementations.\\ncomment text comment\\n'comment' text 'comment'\\nCOMMENT text COMMENT\\ncomment text comment\\n.COMMENT TEXT .COMMENT\\nNotes:\\nComments in Algol W can appear anywhere whitespace is allowed. A comment starts with the reserved word 'comment' and ends with the next semi-colon. Alternatively a comment can start with a percent sign and end with the next percent sign or semi-colon.\\nA single word in the form of an identifier following the reserved word 'end' is also a comment.\\nArendelle uses C style comments\\nSee programming introduction in the Asymptote manual.\\nWhen reading data files a comment character in them can be specified as comment=\""#\"" etc. See Files in the Asymptote manual.\\nFor multi-line comments, the /* and */ must be on their own separate lines. Nothing else can be on the same line.\\nThe hash symbol # start a comment; it ends at the end of line.\\n\\nThe only truly standard method of marking a comment in BASIC is using the REM keyword. This dates back to (at least) the late 1970's, and should work with most BASICs available today:\\nThis may not be well known, but you may include text after the line number of GOTO and GOSUB statements. This is kind of a comment in absence of labels.\\nSpaces are removed from non-keyword text. BASIC keywords can be used.\\nList outputs spaces around keywords.\\nMost BASICs also support alternate comment characters,\\ncommonly an apostrophe (single quote):\\nCharacters other than apostrophe are used in some BASICs. For example, DarkBASIC uses a back-tick character (`, a.k.a. grave accent):\\nIn addition to single-line comments, a few BASICs support block comments. FreeBASIC was influenced by the C family's block comment characters:\\nBaCon accepts REM (or single quote apostrophe) for line comments.\\nC-style block comments can be used with /* and */ pairs; these comment blocks may cross line boundaries.\\nInside USEC sections, all comment styles accepted by the configured C compiler will also be ignored.\\nThere is another (unsupported) option, using a double-colon ::. However, this has issues with some syntactic constructs and therefore may raise syntax errors.\\nSince comment lines are skipped entirely by the parser multi-line comments aren't possible even with line continuation.\\n\\nLike Brainf***, all characters and whitespace which are not commands are ignored.\\nAlso, since the code/data-space is two-dimensional, comments can be placed anywhere that will be untouched by the instruction pointer and data access commands.\\nFinally, in Funge-98, the ; instruction immediately skips to the next ; instruction, which allows to isolate comments from code.\\nBracmat uses curly braces as comment delimiters. Curly braces inside comments must be balanced. Comments are so much ignored when source code is read, that they do not reappear in listings created by the built-in lst$ function, an otherwise very useful function to autoindent your code.\\nMost ASCII characters may be used for comments; only the eight characters \""+-<>[],.\"" are Brainf*** commands. Extra care must be used when using punctuation, particularly the comma or period. These are I/O operators and are actually commands rather than comments, and are instead compiled into the program if used and may have to be \""debugged\"" and removed if you forget this issue.\\nBurlesque does NOT have comments. However, you can comment code by pushing a string and popping it immediately.\\nSince strings are multi-line strings:\\nThe comment starts at the /*, and ends at the */. A comment may be used between any tokens. It cannot be used inside tokens, that is, given the code\\nthe function takes an argument of type char, named isma, not an unnamed argument of type charisma.\\nComments cannot be nested; that is, if you write\\nthe comment ends at the first */, and inside */ is again interpreted as source code (almost certainly causing a compile error). Some compilers have the option to allow nested comments, but this is not a standard feature.\\nConditional compilation also can be used to make the compiler ignore some text:\\nThe trick is that 0 is always false, therefore the text between #if 0 and #endif is never compiled. While this should never be used for actual comments, it's an easy way to comment out some code, especially because it doesn't interfere with normal (documentation) comments.\\nConditional compile \""comments\"" can be nested:\\nEven though the compiler doesn't see #if 0 text, the preprocessor does. Therefore some minimal rules still have to be followed. For example, the following code is not valid:\\nThat's because the preprocessor will interpret the apostrophe as beginning of a character constant, and will complain because that character constant isn't terminated with another apostrophe.\\nNote that the problem mentioned above cannot occur if there's valid code between the #if 0 and #endif.\\nSingle line C++-style comments\\nC++-style comments start with // and reach up to, but not including, the end of line (more exactly, up to the next unescaped newline). While formally, C++-style comments cannot be nested either, in practice they can:\\nThat's because starting with the first // everything in the line is ignored, including the second //.\\nThe fact that the newline is not part of the comment is important for multi-line macro definitions. It means that in the code\\nthe line (no more macro text) is not part of the macro definition. Also escaping the line break at the end of the comment with '\\' doesn't help, because that would make the third line part of the comment instead. Comments inside macros therefore have to be C-style.\\nClean comments are similar to C++.\\nIn contrast to C++ comments can be nested.\\nAnything from a semicolon to the end of a line is a comment.\\nThe (comment) macro will prevent a form from being evaluated, returning nil no matter what is contained in the comment. However the forms inside the comment form must be properly parseable (parentheses balanced, etc.) or an exception will be thrown.\\nFinally, the #_ reader macro will cause a form to be ignored by the reader. Unlike (comment), this does not return nil; the surrounding code is evaluated as though the ignored form isn't even there.\\nA D in the 7th column indicates a debugging line which is treated like a comment unless a compiler flag is set.\\nThis indicates a debugging line like above, but if it is used in fixed format files, it must be in the 8th column or beyond. Not necessarily. GnuCOBOL also supports D as an indicator in column 7, the >>D format works (more by trickery than spec) if the angle brackets start in column 5, the D ending up in column 7. The >>D debug marker can then be both fixed and free form compatible.\\nThis statement causes everything following it up to the next separator period to be treated as a comment. This statement was deleted in COBOL-74.\\nThere are quite a few IDENTIFICATION DIVISION obsolete and extension reserved words that will work in GnuCOBOL 2.\\nIn tags:\\nIn script:\\nCommon Lisp provides line comments (;) and block comments (#|...|#).\\nBlock comments can nest (#|...#|...|#...|#), unlike block comments in e.g. C.\\nIn a common convention, header comments are prefaced with four semicolons, top-level (function level) comments use three, comments for sections of code use two, and margin comments use one.\\nHowever, comments should not be used for inline documentation, as most defining constructs permit a documentation string (which is then available at runtime).\\nThere is no comment syntax in POSIX dc. The convention is to make a string on the stack and move it to an unused register; a no-op.\\nGNU dc added the comment syntax of many other scripting languages.\\nComments are only allowed in places such as \""on load\"" scripts. You cannot put them in form or view definitions.\\nIn addition to Pascal, Delphi also allows C++ style single line comments:\\nAll comments span to the end of the line; there are no paired-delimiter comment syntaxes. “#” begins a comment anywhere outside of quotes; “?” and “>” begin comments only if they are at the beginning of a line (except for whitespace), because those characters are also used for infix operators.\\nIn Updoc, “?” indicates the beginning of a program fragment, “>” the continuation of one, and “#” begins the expected output from its evaluation; “??” indicates special directives.\\nSingle-line comments must begin with //\\nBlock comments must be delimited with /* and */\\nThe original EDSAC made no provision for comments in source code. Modern simulators, however, accept square brackets as comment delimiters.\\nElixir does not have multiple line comments.\\nA comment is started by ; and reaches to the end of the line.\\nThere are some coding conventions for ;; align to indentation, ;;; sections, etc,\\nAnother way to add comments is to use strings at places where the result of an expression is ignored, since they simply evaluate to themselves without any effect. Note that strings can be multi-line:\\nNote that strings at the beginning of function definitions are interpreted as documentation strings for the function (i.e. Emacs will display them if asked for help about the function), e.g.\\nDue to this, it's debatable if the string at that place can be considered as comment.\\n\\nSingle line comment:\\n\\nMultiline C-style comment:\\nF# accepts C++ type line comments and OCaml type block comments\\nFalcon supports C-language style single line and block comments. A single line comment begins with two slashes (//) and ends at the end of the line. A block comment begins with a slash followed by an asterisk, and terminates when an asterisk followed by a slash is met (/*...*/).\\nSince ><> is a funge-like language, all characters not touched by the command pointer or modified by the p and g commands can be comments.\\nUnlike Brainf***, unknown commands are not ignored by the compiler, they just raise an error.\\nStandard Forth includes a number of ways to add comment text. As with everything in Forth, comment characters are actually words that control the compiler.\\nTraditionally, the paren comments are used for \""stack effect\"" notation:\\nThis comment means \""myword takes two cells on the stack and leaves one\"". Sometimes, stack effect comment names give clues about the word's function:\\nSome Forth systems implement other commenting words, such as these words from Win32Forth:\\nCompiler: ANSI FORTRAN 77 or compatible (like g77 -strict)\\nThe first six columns in Fortran are traditionally reserved for labels and certain special characters. In particular the letter \""C\"" in the first column indicates a comment:\\nSome Fortran compilers have the extension that comments starting with D are treated as non-comments if a special debugging flag is given at the compiler invocation. For example:\\nISO Fortran 90 or later have an inline comment (!) syntax:\\nIn ISO Fortran 90 or later, \""C in first column\"" comments are only allowed in the \""fixed\"" source form familiar to FORTRAN 77 programmers. The \""free\"" source form only has inline comments (!).\\nISO Fortran 95 or later has an optional conditional compilation syntax. If present, it can be used (abused?) to (in effect) comment out blocks of code:\\n\\nIn gambas, comments can be inserted by prefixing them with an apostrophe. The gambas interpreter will ignore the apostrophe and any other characters that follow it until the end of the line:\\nA shebang (#!) may be used as a comment in the first line of a file.\\nsingle-line comment:\\nmulti-line comment:\\nThe way backslash continues a comment means that comments can't usefully be put within a multi-line function definition,\\n# through to newline.\\n// works similarly but is reckoned the \""old way\"" (as of Gri 2.12.23)\\nBoth forms can be used in input data files too.\\nAny text after \""#\"" is a comment.\\nThe The Icon Programming Library established conventions for commenting library additions and functions. This included both header block comments and meta comments on procedures within library files.\\nThe comment character in IDL is the semicolon - everything starting with it and to the end of the line is a comment. Like this:\\nJava has two ways to enter normal comments, plus a third type of comment that doubles as a way to generate HTML documentation.\\nThis C-style comment starts with /* and ends with */.\\nThe two delimiters may be on the same or separate lines.\\nThis style comment may be used anywhere white space is permitted.\\nThis C++-style comment starts with // and extends to the end of line.\\nJavadoc is a standardized documentation code for Java. Its comments begin with a forward slash and two stars. Javadoc comments have different tags that signify different things in the methods and classes that they precede.\\nYour editor will probably colour this as great big comment, but it compiles and prints \""Hello World!\"". Once you've figured out how this works, try this discussion on why it's allowed.\\nfirst form\\nsecond form\\nMulti-line comments cannot be nested.\\n\\nExcept when a hash symbol (#) appears within a string, it begins a comment that continues to the end of the line:\\nThis image is a VI Snippet, an executable image of LabVIEW code. The LabVIEW version is shown on the top-right hand corner. You can download it, then drag-and-drop it onto the LabVIEW block diagram from a file browser, and it will appear as runnable, editable code.\\nIn LaTeX, comments look like this:\\nLaTeX comments start with % and continue up to and including the line break. The fact that the line break itself is commented out as well makes it useful for adding line breaks in the source code of complex macros without LaTeX interpreting them (which may cause extra space or even a paragraph break in the resulting typeset text). For example, the following results in the one word \""understandable\"":\\nWithout the percent sign after \\firstpart{stand}, it would have been the two words \""understand able\"".\\nThere are two kinds of comments:\\nand\\nLike with C, block comments don't nest.\\nIn Lingo any line starting with \""--\"" is a comment and ignored by the interpreter.\\nLotusScript has two ways to enter comments.\\nWherever the single quote (') is used, the rest of the line is treated as a comment and ignored. Multi-line comments would each need a single quote mark. This style of comment is usually used for making small in-line or single line comments.\\nA %REM marker begins a comment block, and a %END REM marker ends the comment block. This style of comment is used for making longer multi-line comments, often at the beginning of a class, sub or function.\\nThe author of LSE comments the stack effect of words with header comments as follows:\\nThere is no multi line comment. We have to use ' or \\\\nThere are three types of remarks. After statement with a dark color, in a line, with no statements, with the current pen color, and the Rem statement. Rem statement skip statements in current line, but m2000 editor render these using syntax highlight.\\n\\n","100 REM Standard BASIC comments begin with \""REM\"" (remark) and extend to the end of the line\\n110 PRINT \""this is code\"" ! comment after statement"
"BASIC","Compile-time_calculation","Some programming languages allow calculation of values at compile time.\\n\\nCalculate    10!    (ten factorial)   at compile time.\\nPrint the result when the program is run.\\nDiscuss what limitations apply to compile-time calculations in your language.\\n\\nFirst example with the assembler equivalence pseudo instruction (EQU):\\n","CONST factorial10 = 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10"
"BASIC","Compile-time_calculation","Some programming languages allow calculation of values at compile time.\\n\\nCalculate    10!    (ten factorial)   at compile time.\\nPrint the result when the program is run.\\nDiscuss what limitations apply to compile-time calculations in your language.\\n\\nFirst example with the assembler equivalence pseudo instruction (EQU):\\n","DIM factorial10 AS LONG\\nfactorial10 = 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10"
"BASIC","Compound_data_type","Data Structure\\nThis illustrates a data structure, a means of storing data within a program.\\n\\nCreate a compound data type:\\n\\nA compound data type is one that holds multiple independent values.\\n\\n\\n\\n","TYPE Point\\n   x AS INTEGER\\n   y AS INTEGER\\n END TYPE"
"BASIC","Conditional_structures","These are examples of control structures. You may also be interested in:\\nList the   conditional structures   offered by a programming language.\\nCommon conditional structures are     if-then-else     and     switch.\\n\\nHere are the branch mnemonic opcodes:\\nThe ASM (Assembler Structured Macros) toolkit brings structures to IBM assembler 360.\\n6502 Assembly has 8 conditional branch instructions; each instruction will test the appropriate flag and condition and jump between -128 and 127 bytes.\\nTo understand these conditional instructions, it is helpful to remember that the comparison instructions (CMP, CPX, CPY) set the flags as if a subtraction had occurred:\\nFollowing these instructions, the accumulator will still hold 10 but the flags are set as if you had instructed the processor to perform 10 - 11.\\nThe result is -1, so the sign flag will be set, the zero flag will be cleared, the overflow flag will be cleared, and the carry flag will be set.\\nIn the following example, the branch will be taken if memory location Variable holds 200:\\nBecause you don't have to perform a comparison to set the flags, you can perform very fast checks in interative loops:\\nThis code will loop until X is zero.\\nMost assemblers will figure out the correct offset for you if you use a label in place of the offset after a branch instruction, as in the above example.\\nWhen there is no when others clause, the compiler will complain about any uncovered alternative. This defends against a common reason for bugs in other languages.\\nI.e., the following code is syntactically incorrect:\\nThe syntactically correct version:\\nSelect provides conditional acceptance of entry calls.\\nSelect can also be used to conditionally call an entry\\nA selective entry call provides a way to time-out an entry call.\\nWithout the time-out the calling task will suspend until the entry call is accepted.\\nThe entry Start on the task My_Task will be called.\\nIf My_Task accepts the entry call before the timer expires the timer is canceled. If the timeout expires before the entry call is accepted the entry call is canceled.\\n\\nAlgol 60 has invented the famous if then else block structure.\\nAlgol 60 has conditional expressions of the form:\\nAlgol 60 has conditional statements of the form:\\nAn example:\\nAlgol 60 has also a switch structure:\\nAn example:\\nSee Conditional Structures/ALGOL 68\\n\\n","10 LET A%=1: REM A HAS A VALUE OF TRUE\\n20 IF A% THEN PRINT \""A IS TRUE\""\\n30 WE CAN OF COURSE USE EXPRESSIONS\\n40 IF A%<>0 THEN PRINT \""A IS TRUE\""\\n50 IF NOT(A%) THEN PRINT \""A IS FALSE\""\\n60 REM SOME VERSIONS OF BASIC PROVIDE AN ELSE KEYWORD\\n70 IF A% THEN PRINT \""A IS TRUE\"" ELSE PRINT \""A IS FALSE\"""
"BASIC","Conditional_structures","These are examples of control structures. You may also be interested in:\\nList the   conditional structures   offered by a programming language.\\nCommon conditional structures are     if-then-else     and     switch.\\n\\nHere are the branch mnemonic opcodes:\\nThe ASM (Assembler Structured Macros) toolkit brings structures to IBM assembler 360.\\n6502 Assembly has 8 conditional branch instructions; each instruction will test the appropriate flag and condition and jump between -128 and 127 bytes.\\nTo understand these conditional instructions, it is helpful to remember that the comparison instructions (CMP, CPX, CPY) set the flags as if a subtraction had occurred:\\nFollowing these instructions, the accumulator will still hold 10 but the flags are set as if you had instructed the processor to perform 10 - 11.\\nThe result is -1, so the sign flag will be set, the zero flag will be cleared, the overflow flag will be cleared, and the carry flag will be set.\\nIn the following example, the branch will be taken if memory location Variable holds 200:\\nBecause you don't have to perform a comparison to set the flags, you can perform very fast checks in interative loops:\\nThis code will loop until X is zero.\\nMost assemblers will figure out the correct offset for you if you use a label in place of the offset after a branch instruction, as in the above example.\\nWhen there is no when others clause, the compiler will complain about any uncovered alternative. This defends against a common reason for bugs in other languages.\\nI.e., the following code is syntactically incorrect:\\nThe syntactically correct version:\\nSelect provides conditional acceptance of entry calls.\\nSelect can also be used to conditionally call an entry\\nA selective entry call provides a way to time-out an entry call.\\nWithout the time-out the calling task will suspend until the entry call is accepted.\\nThe entry Start on the task My_Task will be called.\\nIf My_Task accepts the entry call before the timer expires the timer is canceled. If the timeout expires before the entry call is accepted the entry call is canceled.\\n\\nAlgol 60 has invented the famous if then else block structure.\\nAlgol 60 has conditional expressions of the form:\\nAlgol 60 has conditional statements of the form:\\nAn example:\\nAlgol 60 has also a switch structure:\\nAn example:\\nSee Conditional Structures/ALGOL 68\\n\\n","IF x = 0 THEN doSomething\\nIF x < 0 THEN doSomething ELSE doOtherThing"
"BASIC","Conditional_structures","These are examples of control structures. You may also be interested in:\\nList the   conditional structures   offered by a programming language.\\nCommon conditional structures are     if-then-else     and     switch.\\n\\nHere are the branch mnemonic opcodes:\\nThe ASM (Assembler Structured Macros) toolkit brings structures to IBM assembler 360.\\n6502 Assembly has 8 conditional branch instructions; each instruction will test the appropriate flag and condition and jump between -128 and 127 bytes.\\nTo understand these conditional instructions, it is helpful to remember that the comparison instructions (CMP, CPX, CPY) set the flags as if a subtraction had occurred:\\nFollowing these instructions, the accumulator will still hold 10 but the flags are set as if you had instructed the processor to perform 10 - 11.\\nThe result is -1, so the sign flag will be set, the zero flag will be cleared, the overflow flag will be cleared, and the carry flag will be set.\\nIn the following example, the branch will be taken if memory location Variable holds 200:\\nBecause you don't have to perform a comparison to set the flags, you can perform very fast checks in interative loops:\\nThis code will loop until X is zero.\\nMost assemblers will figure out the correct offset for you if you use a label in place of the offset after a branch instruction, as in the above example.\\nWhen there is no when others clause, the compiler will complain about any uncovered alternative. This defends against a common reason for bugs in other languages.\\nI.e., the following code is syntactically incorrect:\\nThe syntactically correct version:\\nSelect provides conditional acceptance of entry calls.\\nSelect can also be used to conditionally call an entry\\nA selective entry call provides a way to time-out an entry call.\\nWithout the time-out the calling task will suspend until the entry call is accepted.\\nThe entry Start on the task My_Task will be called.\\nIf My_Task accepts the entry call before the timer expires the timer is canceled. If the timeout expires before the entry call is accepted the entry call is canceled.\\n\\nAlgol 60 has invented the famous if then else block structure.\\nAlgol 60 has conditional expressions of the form:\\nAlgol 60 has conditional statements of the form:\\nAn example:\\nAlgol 60 has also a switch structure:\\nAn example:\\nSee Conditional Structures/ALGOL 68\\n\\n","IF x > 0 AND x < 10 THEN\\n   'do stuff\\nELSE IF x = 0 THEN\\n   'do other stuff\\nELSE\\n   'do more stuff\\nEND IF"
"BASIC","Conditional_structures","These are examples of control structures. You may also be interested in:\\nList the   conditional structures   offered by a programming language.\\nCommon conditional structures are     if-then-else     and     switch.\\n\\nHere are the branch mnemonic opcodes:\\nThe ASM (Assembler Structured Macros) toolkit brings structures to IBM assembler 360.\\n6502 Assembly has 8 conditional branch instructions; each instruction will test the appropriate flag and condition and jump between -128 and 127 bytes.\\nTo understand these conditional instructions, it is helpful to remember that the comparison instructions (CMP, CPX, CPY) set the flags as if a subtraction had occurred:\\nFollowing these instructions, the accumulator will still hold 10 but the flags are set as if you had instructed the processor to perform 10 - 11.\\nThe result is -1, so the sign flag will be set, the zero flag will be cleared, the overflow flag will be cleared, and the carry flag will be set.\\nIn the following example, the branch will be taken if memory location Variable holds 200:\\nBecause you don't have to perform a comparison to set the flags, you can perform very fast checks in interative loops:\\nThis code will loop until X is zero.\\nMost assemblers will figure out the correct offset for you if you use a label in place of the offset after a branch instruction, as in the above example.\\nWhen there is no when others clause, the compiler will complain about any uncovered alternative. This defends against a common reason for bugs in other languages.\\nI.e., the following code is syntactically incorrect:\\nThe syntactically correct version:\\nSelect provides conditional acceptance of entry calls.\\nSelect can also be used to conditionally call an entry\\nA selective entry call provides a way to time-out an entry call.\\nWithout the time-out the calling task will suspend until the entry call is accepted.\\nThe entry Start on the task My_Task will be called.\\nIf My_Task accepts the entry call before the timer expires the timer is canceled. If the timeout expires before the entry call is accepted the entry call is canceled.\\n\\nAlgol 60 has invented the famous if then else block structure.\\nAlgol 60 has conditional expressions of the form:\\nAlgol 60 has conditional statements of the form:\\nAn example:\\nAlgol 60 has also a switch structure:\\nAn example:\\nSee Conditional Structures/ALGOL 68\\n\\n","IF aNumber THEN\\n   'the number is not 0\\nELSE\\n   'the number is 0\\nEND IF"
"BASIC","Conditional_structures","These are examples of control structures. You may also be interested in:\\nList the   conditional structures   offered by a programming language.\\nCommon conditional structures are     if-then-else     and     switch.\\n\\nHere are the branch mnemonic opcodes:\\nThe ASM (Assembler Structured Macros) toolkit brings structures to IBM assembler 360.\\n6502 Assembly has 8 conditional branch instructions; each instruction will test the appropriate flag and condition and jump between -128 and 127 bytes.\\nTo understand these conditional instructions, it is helpful to remember that the comparison instructions (CMP, CPX, CPY) set the flags as if a subtraction had occurred:\\nFollowing these instructions, the accumulator will still hold 10 but the flags are set as if you had instructed the processor to perform 10 - 11.\\nThe result is -1, so the sign flag will be set, the zero flag will be cleared, the overflow flag will be cleared, and the carry flag will be set.\\nIn the following example, the branch will be taken if memory location Variable holds 200:\\nBecause you don't have to perform a comparison to set the flags, you can perform very fast checks in interative loops:\\nThis code will loop until X is zero.\\nMost assemblers will figure out the correct offset for you if you use a label in place of the offset after a branch instruction, as in the above example.\\nWhen there is no when others clause, the compiler will complain about any uncovered alternative. This defends against a common reason for bugs in other languages.\\nI.e., the following code is syntactically incorrect:\\nThe syntactically correct version:\\nSelect provides conditional acceptance of entry calls.\\nSelect can also be used to conditionally call an entry\\nA selective entry call provides a way to time-out an entry call.\\nWithout the time-out the calling task will suspend until the entry call is accepted.\\nThe entry Start on the task My_Task will be called.\\nIf My_Task accepts the entry call before the timer expires the timer is canceled. If the timeout expires before the entry call is accepted the entry call is canceled.\\n\\nAlgol 60 has invented the famous if then else block structure.\\nAlgol 60 has conditional expressions of the form:\\nAlgol 60 has conditional statements of the form:\\nAn example:\\nAlgol 60 has also a switch structure:\\nAn example:\\nSee Conditional Structures/ALGOL 68\\n\\n","SELECT CASE expression\\nCASE 1\\n   'do stuff\\nCASE 2, 3\\n   'do other stuff\\nCASE 3.1 TO 9.9\\n   'do this\\nCASE IS >= 10\\n   'do that\\nCASE ELSE\\n   'default case\\nEND SELECT"
"BASIC","Conditional_structures","These are examples of control structures. You may also be interested in:\\nList the   conditional structures   offered by a programming language.\\nCommon conditional structures are     if-then-else     and     switch.\\n\\nHere are the branch mnemonic opcodes:\\nThe ASM (Assembler Structured Macros) toolkit brings structures to IBM assembler 360.\\n6502 Assembly has 8 conditional branch instructions; each instruction will test the appropriate flag and condition and jump between -128 and 127 bytes.\\nTo understand these conditional instructions, it is helpful to remember that the comparison instructions (CMP, CPX, CPY) set the flags as if a subtraction had occurred:\\nFollowing these instructions, the accumulator will still hold 10 but the flags are set as if you had instructed the processor to perform 10 - 11.\\nThe result is -1, so the sign flag will be set, the zero flag will be cleared, the overflow flag will be cleared, and the carry flag will be set.\\nIn the following example, the branch will be taken if memory location Variable holds 200:\\nBecause you don't have to perform a comparison to set the flags, you can perform very fast checks in interative loops:\\nThis code will loop until X is zero.\\nMost assemblers will figure out the correct offset for you if you use a label in place of the offset after a branch instruction, as in the above example.\\nWhen there is no when others clause, the compiler will complain about any uncovered alternative. This defends against a common reason for bugs in other languages.\\nI.e., the following code is syntactically incorrect:\\nThe syntactically correct version:\\nSelect provides conditional acceptance of entry calls.\\nSelect can also be used to conditionally call an entry\\nA selective entry call provides a way to time-out an entry call.\\nWithout the time-out the calling task will suspend until the entry call is accepted.\\nThe entry Start on the task My_Task will be called.\\nIf My_Task accepts the entry call before the timer expires the timer is canceled. If the timeout expires before the entry call is accepted the entry call is canceled.\\n\\nAlgol 60 has invented the famous if then else block structure.\\nAlgol 60 has conditional expressions of the form:\\nAlgol 60 has conditional statements of the form:\\nAn example:\\nAlgol 60 has also a switch structure:\\nAn example:\\nSee Conditional Structures/ALGOL 68\\n\\n","10 INPUT \""Enter 1,2 or 3: \"";v\\n20 GOTO v * 100\\n99 STOP\\n100 PRINT \""Apple\""\\n110 STOP\\n200 PRINT \""Banana\""\\n210 STOP\\n300 PRINT \""Cherry\""\\n310 STOP"
"BASIC","Conditional_structures","These are examples of control structures. You may also be interested in:\\nList the   conditional structures   offered by a programming language.\\nCommon conditional structures are     if-then-else     and     switch.\\n\\nHere are the branch mnemonic opcodes:\\nThe ASM (Assembler Structured Macros) toolkit brings structures to IBM assembler 360.\\n6502 Assembly has 8 conditional branch instructions; each instruction will test the appropriate flag and condition and jump between -128 and 127 bytes.\\nTo understand these conditional instructions, it is helpful to remember that the comparison instructions (CMP, CPX, CPY) set the flags as if a subtraction had occurred:\\nFollowing these instructions, the accumulator will still hold 10 but the flags are set as if you had instructed the processor to perform 10 - 11.\\nThe result is -1, so the sign flag will be set, the zero flag will be cleared, the overflow flag will be cleared, and the carry flag will be set.\\nIn the following example, the branch will be taken if memory location Variable holds 200:\\nBecause you don't have to perform a comparison to set the flags, you can perform very fast checks in interative loops:\\nThis code will loop until X is zero.\\nMost assemblers will figure out the correct offset for you if you use a label in place of the offset after a branch instruction, as in the above example.\\nWhen there is no when others clause, the compiler will complain about any uncovered alternative. This defends against a common reason for bugs in other languages.\\nI.e., the following code is syntactically incorrect:\\nThe syntactically correct version:\\nSelect provides conditional acceptance of entry calls.\\nSelect can also be used to conditionally call an entry\\nA selective entry call provides a way to time-out an entry call.\\nWithout the time-out the calling task will suspend until the entry call is accepted.\\nThe entry Start on the task My_Task will be called.\\nIf My_Task accepts the entry call before the timer expires the timer is canceled. If the timeout expires before the entry call is accepted the entry call is canceled.\\n\\nAlgol 60 has invented the famous if then else block structure.\\nAlgol 60 has conditional expressions of the form:\\nAlgol 60 has conditional statements of the form:\\nAn example:\\nAlgol 60 has also a switch structure:\\nAn example:\\nSee Conditional Structures/ALGOL 68\\n\\n","10 REM while loop\\n20 L=0\\n30 WHILE L<5\\n40 PRINT L\\n50 L=L+1\\n60 WEND\\n70 REM repeat loop\\n80 L=1\\n90 REPEAT\\n100 PRINT L\\n110 L=L+1\\n120 UNTIL L>5"
"BASIC","Constrained_random_points_on_a_circle","Generate 100 <x,y> coordinate pairs such that x and y are integers sampled from the uniform distribution with the condition that \\n\\n\\n\\n10\\n≤\\n\\n\\n\\nx\\n\\n2\\n\\n\\n+\\n\\ny\\n\\n2\\n\\n\\n\\n\\n≤\\n15\\n\\n\\n{\\displaystyle 10\\leq {\\sqrt {x^{2}+y^{2}}}\\leq 15}\\n\\n. Then display/plot them. The outcome should be a \""fuzzy\"" circle. The actual number of points plotted may be less than 100, given that some pairs may be generated more than once.\\nThere are several possible approaches to accomplish this. Here are two possible algorithms.\\n1) Generate random pairs of integers and filter out those that don't satisfy this condition:\\n2) Precalculate the set of all possible points (there are 404 of them) and select randomly from this set.\\n\\nOutput:\\nSample output:\\nRequires the GDI+ standard library by tic: http://www.autohotkey.com/forum/viewtopic.php?t=32238 Works with individual pixels.\\nPre calculate and plot 100 points to the console\\nConsole output:\\n\\nThe output may be a bit distorted, since even monospace fonts take more vertical space per character than horizontal space.\\nThis uses std.complex because D built-in complex numbers will be deprecated.\\n","      MODE 8\\n      ORIGIN 640, 512\\n      FOR i% = 1 TO 1000\\n        x% = RND(31)-16\\n        y% = RND(31)-16\\n        r = SQR(x%^2 + y%^2)\\n        IF r >= 10 IF r <= 15 PLOT x%*2, y%*2\\n      NEXT"
"BASIC","Constrained_random_points_on_a_circle","Generate 100 <x,y> coordinate pairs such that x and y are integers sampled from the uniform distribution with the condition that \\n\\n\\n\\n10\\n≤\\n\\n\\n\\nx\\n\\n2\\n\\n\\n+\\n\\ny\\n\\n2\\n\\n\\n\\n\\n≤\\n15\\n\\n\\n{\\displaystyle 10\\leq {\\sqrt {x^{2}+y^{2}}}\\leq 15}\\n\\n. Then display/plot them. The outcome should be a \""fuzzy\"" circle. The actual number of points plotted may be less than 100, given that some pairs may be generated more than once.\\nThere are several possible approaches to accomplish this. Here are two possible algorithms.\\n1) Generate random pairs of integers and filter out those that don't satisfy this condition:\\n2) Precalculate the set of all possible points (there are 404 of them) and select randomly from this set.\\n\\nOutput:\\nSample output:\\nRequires the GDI+ standard library by tic: http://www.autohotkey.com/forum/viewtopic.php?t=32238 Works with individual pixels.\\nPre calculate and plot 100 points to the console\\nConsole output:\\n\\nThe output may be a bit distorted, since even monospace fonts take more vertical space per character than horizontal space.\\nThis uses std.complex because D built-in complex numbers will be deprecated.\\n","'Free Basic version .9\\n\\n#define Intrange(f,l) int(Rnd*(((l)+1)-(f))+(f))\\n\\nType pair\\n    As Integer x,y\\nEnd Type\\n\\nOperator =(a As pair,b As pair) As Integer\\nReturn a.x=b.x And a.y=b.y\\nEnd Operator\\n\\nFunction NotInArray(a() As pair,n As pair) As Integer\\n    For z As Integer=Lbound(a) To Ubound(a)\\n        If a(z)=n Then Return 0\\n    Next z\\n    Return -1\\nEnd Function\\n\\nRedim As pair pts(0)\\nDim As Integer x,y,counter\\nDo\\n    counter=counter+1\\n    x=IntRange(-20,20)\\n    y=IntRange(-20,20)\\n    var root=Sqr(x*x+y*y)\\n    If 10<= root And root<=15 Then\\n        If NotInArray(pts(),Type<pair>(x,y)) Then\\n            Redim Preserve pts(1 To Ubound(pts)+1)\\n            pts(Ubound(pts))=Type<pair>(x,y)\\n        End If\\n    End If\\nLoop Until counter=100000\\n\\n'============== Plot to Console ====================== \\n\\ndim as integer yres=hiword(width)\\ndim as integer xres=loword(width)\\n\\n#define map(a,b,x,c,d)  ((d)-(c))*((x)-(a))/((b)-(a))+(c)\\n#define _X(num) int( map(0,xres,(num),0,loword(width))) \\n#define _Y(num) int( map(0,yres,(num),0,hiword(width)))\\n\\ncounter=0\\nFor n As Integer=Lbound(pts) To Ubound(pts)\\n    counter=counter+1\\n    if counter <=100 then \\n    var xpos=map(-20,20,pts(n).x,0,xres)\\n    var ypos=map(-20,20,pts(n).y,0,yres)\\n    locate _Y(ypos),_X(xpos)\\n    print \""*\""\\n    end if\\nNext n\\n\\nprint\\nlocate 1,1\\nPrint \""Total number of points \""; counter\\nprint \""Total number plotted   \"";100\\nprint \""done\""\\nSleep\\n"
"BASIC","Convert_seconds_to_compound_duration","Write a function or program which:\\n\\nDemonstrate that it passes the following three test-cases:\\nTest CasesDetails\\n","10 REM CONVERT SECONDS TO COMPOUND DURATION\\n20 REM ADAPTED FROM RUN BASIC VERSION\\n30 REM ===============================================================\\n40 PRINT CHR$(14)\\n50 SEC = 7259\\n60 GOSUB 1000\\n70 SEC = 85400\\n80 GOSUB 1000\\n90 SEC = 6000000\\n100 GOSUB 1000\\n110 END\\n120 REM ==============================================================\\n1000 WK  = INT(SEC/60/60/24/7)\\n1010 DY  = INT(SEC/60/60/24) - 7*WK\\n1020 HR  = INT(SEC/60/60) - 24*(DY+7*WK)\\n1030 MN  = INT(SEC/60) - 60*(HR+24*(DY+7*WK))\\n1040 SC  = SEC - 60*(MN+60*(HR+24*(DY+7*WK)))\\n1050 PRINT SEC;\""SEC\"" : PRINT \""  =\"";\\n1055 F = 0\\n1060 IF WK = 0 THEN 1080\\n1070 PRINT WK;\""WK\""; : F = 1\\n1080 IF DY = 0 THEN 1110\\n1090 IF F THEN PRINT \"",\"";\\n1100 PRINT DY;\""DY\""; : F = 1\\n1110 IF HR = 0 THEN 1140\\n1120 IF F THEN PRINT \"",\"";\\n1130 PRINT HR;\""HR\""; : F = 1\\n1140 IF MN = 0 THEN 1170\\n1150 IF F THEN PRINT \"",\"";\\n1160 PRINT MN;\""MIN\""; : F = 1\\n1170 IF (SC > 0) AND F THEN PRINT \"",\"";SC;\""SEC\"" : GOTO 1200\\n1180 IF (SC = 0) AND F THEN 1200\\n1190 PRINT SC;\""SEC\""\\n1200 PRINT \\n1210 RETURN"
"BASIC","Convert_seconds_to_compound_duration","Write a function or program which:\\n\\nDemonstrate that it passes the following three test-cases:\\nTest CasesDetails\\n","REM >compduration\\nPRINT FN_convert(7259)\\nPRINT FN_convert(86400)\\nPRINT FN_convert(6000000)\\nEND\\n:\\nDEF FN_convert(seconds%)\\nLOCAL units%(), units$(), i%, unit%, compound$\\nDIM units%(4)\\nDIM units$(4)\\nunits%() = 604800, 86400, 3600, 60, 1\\nunits$() = \""wk\"", \""d\"", \""hr\"", \""min\"", \""sec\""\\ncompound$ = \""\""\\nFOR i% = 0 TO 4\\n  IF seconds% >= units%(i%) THEN\\n    unit% = seconds% DIV units%(i%)\\n    seconds% = seconds% MOD units%(i%)\\n    compound$ += STR$(unit%) + \"" \"" + units$(i%)\\n    IF i% < 4 AND seconds% > 0 THEN compound$ += \"", \""\\n  ENDIF\\nNEXT\\n= compound$"
"BASIC","Convert_seconds_to_compound_duration","Write a function or program which:\\n\\nDemonstrate that it passes the following three test-cases:\\nTest CasesDetails\\n","100 PROGRAM \""Seconds.bas\""\\n110 NUMERIC UN(1 TO 5),SEC,UNIT\\n120 STRING T$(1 TO 5)*3\\n130 LET UN(1)=604800:LET UN(2)=86400:LET UN(3)=3600:LET UN(4)=60:LET UN(5)=1\\n140 LET T$(1)=\""wk\"":LET T$(2)=\""d\"":LET T$(3)=\""hr\"":LET T$(4)=\""min\"":LET T$(5)=\""sec\""\\n150 INPUT PROMPT \""Duration in seconds: \"":SEC\\n160 PRINT SEC;\""sec =\"";\\n170 FOR I=1 TO 5\\n180   IF SEC>=UN(I) THEN\\n190     LET UNIT=INT(SEC/UN(I)):LET SEC=MOD(SEC,UN(I))\\n200     PRINT UNIT;T$(I);\\n210     IF I<4 AND SEC>0 THEN PRINT \"",\"";\\n220   END IF \\n230 NEXT \\n240 PRINT"
"BASIC","Conway's_Game_of_Life","The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.\\nConway's game of life is described   here:\\nA cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.\\nWe calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:\\nAssume cells beyond the boundary are always dead.\\nThe \""game\"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.\\n\\nAlthough you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.\\n\\n\\n\\n","# Conway's_Game_of_Life\\n\\nX = 59 : Y = 35 : H = 4\\n\\nfastgraphics\\ngraphsize X*H,Y*H\\n\\ndim c(X,Y) : dim cn(X,Y) : dim cl(X,Y)\\n"
"BASIC","Conway's_Game_of_Life","The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.\\nConway's game of life is described   here:\\nA cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.\\nWe calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:\\nAssume cells beyond the boundary are always dead.\\nThe \""game\"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.\\n\\nAlthough you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.\\n\\n\\n\\n","\\n# Thunderbird methuselah\\nc[X/2-1,Y/3+1] = 1 : c[X/2,Y/3+1] = 1 : c[X/2+1,Y/3+1] = 1	\\nc[X/2,Y/3+3] = 1 : c[X/2,Y/3+4] = 1 : c[X/2,Y/3+5] = 1\\n\\ns = 0\\ndo\\n	color black\\n	rect 0,0,graphwidth,graphheight\\n	alive = 0 : stable = 1\\n	s = s + 1\\n	for y = 0 to Y-1 \\n		for x = 0 to X-1\\n			xm1 = (x-1+X)%X : xp1 = (x+1+X)%X\\n			ym1 = (y-1+Y)%Y : yp1 = (y+1+Y)%Y\\n			cn[x,y] = c[xm1,y] + c[xp1,y]\\n			cn[x,y] = c[xm1,ym1] + c[x,ym1] + c[xp1,ym1] + cn[x,y]\\n			cn[x,y] = c[xm1,yp1] + c[x,yp1] + c[xp1,yp1] + cn[x,y]\\n			if c[x,y] = 1 then\\n				if cn[x,y] < 2 or cn[x,y] > 3 then \\n					cn[x,y] = 0\\n				else \\n					cn[x,y] = 1\\n					alive = alive + 1\\n				end if\\n			else \\n				if cn[x,y] = 3 then \\n					cn[x,y] = 1\\n					alive = alive + 1\\n				else\\n					cn[x,y] = 0\\n				end if\\n			end if\\n			if c[x,y] then\\n				if cn[x,y] then\\n					if cl[x,y] then color purple		# adult\\n					if not cl[x,y] then color green	        # newborn\\n				else \\n					if cl[x,y] then color red		# old\\n					if not cl[x,y] then color yellow	# shortlived\\n				end if \\n				rect x*H,y*H,H,H\\n			end if\\n		next x\\n	next y\\n	refresh\\n	pause 0.06\\n	# Copy arrays\\n	for i = 0 to X-1\\n		for j = 0 to Y-1\\n			if cl[i,j]<>cn[i,j] then stable = 0\\n			cl[i,j] = c[i,j]\\n			c[i,j] = cn[i,j]\\n		next j\\n	next i	\\nuntil not alive or stable\\n\\nif not alive then\\n	print \""Died in \""+s+\"" iterations\""\\n	color black\\n	rect 0,0,graphwidth,graphheight\\n	refresh\\nelse \\n	print \""Stabilized in \""+(s-2)+\"" iterations\""	\\nend if"
"BASIC","Conway's_Game_of_Life","The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.\\nConway's game of life is described   here:\\nA cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.\\nWe calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:\\nAssume cells beyond the boundary are always dead.\\nThe \""game\"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.\\n\\nAlthough you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.\\n\\n\\n\\n","      dx% = 64\\n      dy% = 64\\n      DIM old&(dx%+1,dy%+1), new&(dx%+1,dy%+1)\\n      VDU 23,22,dx%*4;dy%*4;16,16,16,0\\n      OFF\\n      \\n      REM Set blinker:\\n      old&(50,50) = 1 : old&(50,51) = 1 : old&(50,52) = 1\\n      REM Set glider:\\n      old&(5,7) = 1 : old&(6,7) = 1 : old&(7,7) = 1 : old&(7,6) = 1 : old&(6,5) = 1\\n      \\n      REM Draw initial grid:\\n      FOR X% = 1 TO dx%\\n        FOR Y% = 1 TO dy%\\n          IF old&(X%,Y%) GCOL 11 ELSE GCOL 4\\n          PLOT 69, X%*8-6, Y%*8-4\\n        NEXT\\n      NEXT X%\\n      \\n      REM Run:\\n      GCOL 4,0\\n      REPEAT\\n        FOR X% = 1 TO dx%\\n          FOR Y% = 1 TO dy%\\n            S% = old&(X%-1,Y%) + old&(X%,Y%-1) + old&(X%-1,Y%-1) + old&(X%+1,Y%-1) + \\\\n            \\    old&(X%+1,Y%) + old&(X%,Y%+1) + old&(X%-1,Y%+1) + old&(X%+1,Y%+1)\\n            O% = old&(X%,Y%)\\n            N% = -(S%=3 OR (O%=1 AND S%=2))\\n            new&(X%,Y%) = N%\\n            IF N%<>O% PLOT X%*8-6, Y%*8-4\\n          NEXT\\n        NEXT X%\\n        SWAP old&(), new&()\\n        WAIT 30\\n      UNTIL FALSE"
"BASIC","Conway's_Game_of_Life","The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.\\nConway's game of life is described   here:\\nA cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.\\nWe calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:\\nAssume cells beyond the boundary are always dead.\\nThe \""game\"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.\\n\\nAlthough you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.\\n\\n\\n\\n","' FreeBASIC Conway's Game of Life\\n' May 2015\\n' 07-10-2016 cleanup/little changes\\n' moved test inkey outside the ScreenLock - ScreenUnLock block\\n' compile: fbc -s gui\\n\\nConst As UInteger grid  = 300  '480 by 480\\nConst As UInteger gridy = grid\\nConst As UInteger gridx = grid\\nConst As UInteger pointsize = 5 'pixels\\nConst As UInteger steps = 10\\nDim As UInteger gen, n, neighbours, x, y, was\\n\\nDim As String press\\n\\nConst As UByte red   = 4  'red is color 6\\nConst As UByte white = 15 'color\\nConst As UByte black = 0  'color\\n\\n'color 0 normaly is black\\n'color 1 normaly is dark blue\\n'color 2 normaly is green\\nConst As UInteger bot = 35 'this is 35 lines from the top of the page\\nDim As UByte old( grid + 10, grid +10), new_( grid +10, grid +10)\\n\\n'Set blinker:\\n' old( 160, 160) =1: old( 160, 170) =1 : old( 160, 180) =1\\n\\n'Set blinker:\\n' old( 160, 20) =1: old( 160, 30) =1 : old( 160, 40) =1\\n\\n'Set blinker:\\n' old( 20, 20) =1: old( 20, 30) =1 : old( 20, 40) =1\\n\\n'Set glider:\\n'  old(  50,  70) =1: old(  60,  70) =1: old(  70,  70) =1\\n' old(  70,  60) =1: old(  60,  50) =1\\n\\n' http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\\n' Thunderbird methuselah\\n'X = 59 : Y = 35 : H = 4\\n'c[X/2-1,Y/3+1] = 1 : c[X/2,Y/3+1] = 1 : c[X/2+1,Y/3+1] = 1\\n'c[X/2,Y/3+3] = 1 : c[X/2,Y/3+4] = 1 : c[X/2,Y/3+5] = 1\\n\\n'xb = 59 : yb = 35\\n' old( Xb/2-1,Yb/3+1) =1: old(Xb/2,Yb/3+1) =1: old(Xb/2+1,Yb/3+1) =1\\n' old( Xb/2,Yb/3+3) =1: old(Xb/2,Yb/3+4) =1 :old(Xb/2,Yb/3+5) = 1\\n'r-pentomino\\n'  old( 150,140) =1: old( 160,140) =1\\n'  old( 140,150) =1 :old( 150,150) =1\\n'  old( 150,160) =1\\n\\n'Die Hard  around 150 generations\\n' old( 150,140) =1: old(160,140) =1 : old(160,150) =1\\n' old( 200,150) =1: old(210,150) =1 : old(210,130) = 1 : old(220,150) = 1\\n\\n'Acorn  around 450 generations\\n' it looks like this:\\n'   0X\\n'   000X\\n'   XX00XXX\\nold( 180,200) =1\\nold( 200,210) =1\\nold( 170,220) =1 : old( 180,220) =1 : old( 210,220) =1 : old( 220,220) =1 : old( 230,220) =1\\n\\nScreen 20 'Resolution 800x600 with at least 256 colors\\n\\nColor white\\nLine (10, 10) - (gridx + 10, gridy + 10),,B  'box from top left to bottom right\\n\\nLocate bot, 1  'Use a standard place on the bottom of the page\\nColor white\\nPrint \"" Welcome to Conway's Game of Life\""\\nPrint \"" Using a constrained playing field (300x300), the Acorn seed runs\""\\nPrint \"" for about 450 generations before it becomes stable (or stale).\""\\nPrint \"" Enter any key to start\""\\nBeep\\nSleep\\n\\nDo      ' flush the key input buffer\\n  press = Inkey\\nLoop Until press = \""\""\\n'Print \""                       \""\\n\\n'Draw initial grid\\nFor x = 10 To gridX Step steps\\n  For y = 10 To gridY Step steps\\n    Color white 'old(x,y)\\n    If old(x,y) = 1 Then Circle (x + pointsize, y + pointsize), pointsize,,,,, F\\n  Next y\\nNext x\\n'\\nLocate bot, 1\\nColor white\\nPrint \"" Welcome to Conway's Game of Life\""\\nPrint \"" Using a constrained playing field, the Acorn seed runs for      \""\\nPrint \"" about 450 generations before it becomes stable (or stale).    \""\\nColor red\\nPrint \"" Enter spacebar to continue or pause, ESC to stop\""\\nSleep\\n'\\nDo      ' flush the key input buffer\\n  press = Inkey\\nLoop Until press = \""\""\\n\\nDo\\n  gen = gen + 1\\n  Locate bot+5,1\\n  Color white\\n  Print \"" Gen = \""; gen\\n  ScreenLock\\n  For x = 10 To gridX Step steps\\n    For y = 10 To gridY Step steps\\n      'find number of live neighbours\\n      neighbours = old( x - steps, y - steps) +old( x , y - steps)\\n      neighbours = neighbours + old( x + steps, y -steps)\\n      neighbours = neighbours + old( x - steps, y) + old( x + steps, y)\\n      neighbours = neighbours + old( x - steps, y + steps)\\n      neighbours = neighbours + old( x, y + steps) +old( x + steps, y + steps)\\n      was =old( x, y)\\n      If was =0 Then\\n        If neighbours =3 Then N =1 Else N =0\\n      Else\\n        If neighbours =3  Or neighbours =2 Then N =1 Else N =0\\n      End If\\n      new_( x, y) = N\\n      If n = 2 Then Color white\\n      If n = 1 Then Color red\\n      If n = 0 Then Color black\\n      Circle (x + pointsize, y + pointsize), pointsize,,,,, F\\n    Next y\\n  Next x\\n  Color white\\n  Line (10, 10) - (gridx + 10, gridy + 10),,B  'box from top left to bottom right\\n  ' Locate bot,1\\n  '\\n  't = timer\\n  'do\\n  'loop until timer > t + .2\\n  ScreenUnlock\\n  ' might not be slow enough\\n  Sleep 70, 1  ' ignore key press\\n\\n  press = Inkey\\n  If press = \"" \"" Then\\n    Do      ' flush the key input buffer\\n      press = Inkey\\n    Loop Until press = \""\""\\n    Do      ' wait until a key is pressed\\n      press = Inkey\\n    Loop Until press <> \""\""\\n  End If\\n  If press = Chr(27) Then Exit Do\\n  ' mouse click on close window \""X\""\\n  If press = Chr(255)+\""k\"" Then End ' stop and close window\\n\\n  For x =10 To gridX Step steps\\n    For y =10 To gridY Step steps\\n      old( x, y) =new_( x, y)\\n    Next y\\n  Next x\\n\\nLoop ' UNTIL press = CHR(27) 'return to do loop up top until \""esc\"" key is pressed.\\n\\nColor white\\nLocate bot+3,1\\nPrint Space(55) 'clear instructions\\nLocate bot+6,1\\nPrint \"" Press any key to exit                            \""\\nSleep\\nEnd"
"BASIC","Conway's_Game_of_Life","The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.\\nConway's game of life is described   here:\\nA cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.\\nWe calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:\\nAssume cells beyond the boundary are always dead.\\nThe \""game\"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.\\n\\nAlthough you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.\\n\\n\\n\\n","\\n      nomainwin\\n\\n      gridX = 20\\n      gridY = gridX\\n\\n      mult      =500 /gridX\\n      pointSize =360 /gridX\\n\\n      dim old( gridX +1, gridY +1), new( gridX +1, gridY +1)\\n\\n'Set blinker:\\n      old( 16, 16) =1: old( 16, 17) =1 : old( 16, 18) =1\\n\\n'Set glider:\\n      old(  5,  7) =1: old(  6,  7) =1: old(  7,  7) =1\\n      old(  7,  6) =1: old(  6,  5) =1\\n\\n      WindowWidth  =570\\n      WindowHeight =600\\n\\n      open \""Conway's 'Game of Life'.\"" for graphics_nsb_nf as #w\\n\\n      #w \""trapclose [quit]\""\\n      #w \""down ; size \""; pointSize\\n      #w \""fill black\""\\n\\n'Draw initial grid\\n      for x = 1 to gridX\\n        for y = 1 to gridY\\n          '#w \""color \""; int( old( x, y) *256); \"" 0 255\""\\n          if old( x, y) <>0 then #w \""color red\"" else #w \""color darkgray\""\\n          #w \""set \""; x *mult +20; \"" \""; y *mult +20\\n        next y\\n      next x\\n'   ______________________________________________________________________________\\n'Run\\n      do\\n        for x =1 to gridX\\n          for y =1 to gridY\\n            'find number of live Moore neighbours\\n            neighbours =old( x -1, y -1) +old( x, y -1) +old( x +1, y -1)+_\\n                        old( x -1, y)                   +old( x +1, y   )+_\\n                        old( x -1, y +1) +old( x, y +1) +old( x +1, y +1)\\n            was =old( x, y)\\n            if was =0 then\\n                if neighbours =3 then N =1 else N =0\\n            else\\n                if neighbours =3  or neighbours =2 then N =1 else N =0Tail Recursive\\n            end if\\n            new( x, y) = N\\n            '#w \""color \""; int( N /8 *256); \"" 0 255\""\\n            if N <>0 then #w \""color red\"" else #w \""color darkgray\""\\n            #w \""set \""; x *mult +20; \"" \""; y *mult +20\\n          next y\\n        next x\\n        scan\\n'swap\\n        for x =1 to gridX\\n          for y =1 to gridY\\n            old( x, y) =new( x, y)\\n          next y\\n        next x\\n'Re-run until interrupted...\\n      loop until FALSE\\n'User shutdown received\\n    [quit]\\n    close #w\\n    end\\n"
"BASIC","Conway's_Game_of_Life","The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.\\nConway's game of life is described   here:\\nA cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.\\nWe calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:\\nAssume cells beyond the boundary are always dead.\\nThe \""game\"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.\\n\\nAlthough you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.\\n\\n\\n\\n","EnableExplicit\\nDefine.i x, y ,Xmax ,Ymax ,N\\nXmax = 13 : Ymax = 20\\nDim     world.i(Xmax+1,Ymax+1)\\nDim Nextworld.i(Xmax+1,Ymax+1)  \\n\\n; Glider test\\n;------------------------------------------\\n world(1,1)=1 : world(1,2)=0 : world(1,3)=0\\n world(2,1)=0 : world(2,2)=1 : world(2,3)=1\\n world(3,1)=1 : world(3,2)=1 : world(3,3)=0\\n;------------------------------------------\\n \\nOpenConsole()\\nEnableGraphicalConsole(1)\\nClearConsole()\\nPrint(\""Press any key to interrupt\"")\\nRepeat\\n  ConsoleLocate(0,2)\\n  PrintN(LSet(\""\"", Xmax+2, \""-\""))\\n ;---------- endless world ---------\\n  For y = 1 To Ymax\\n    world(0,y)=world(Xmax,y)\\n    world(Xmax+1,y)=world(1,y)  \\n  Next\\n  For x = 1 To Xmax\\n    world(x,0)=world(x,Ymax)\\n    world(x,Ymax+1)=world(x,1)\\n  Next\\n  world(0     ,0     )=world(Xmax,Ymax)\\n  world(Xmax+1,Ymax+1)=world(1   ,1   )\\n  world(Xmax+1,0     )=world(1   ,Ymax)\\n  world(     0,Ymax+1)=world(Xmax,1   )\\n ;---------- endless world ---------\\n  For y = 1 To Ymax\\n    Print(\""|\"") \\n    For x = 1 To Xmax\\n      Print(Chr(32+world(x,y)*3))\\n      N = world(x-1,y-1)+world(x-1,y)+world(x-1,y+1)+world(x,y-1)\\n      N + world(x,y+1)+world(x+1,y-1)+world(x+1,y)+world(x+1,y+1)\\n      If (world(x,y) And (N = 2 Or N = 3))Or (world(x,y)=0 And N = 3)\\n        Nextworld(x,y)=1      \\n      Else\\n        Nextworld(x,y)=0\\n      EndIf\\n    Next\\n    PrintN(\""|\"")\\n  Next\\n  PrintN(LSet(\""\"", Xmax+2, \""-\""))\\n  Delay(100) \\n  ;Swap world() , Nextworld()    ;PB  <4.50\\n  CopyArray(Nextworld(), world());PB =>4.50\\n  Dim Nextworld.i(Xmax+1,Ymax+1) \\nUntil Inkey() <> \""\""\\n \\nPrintN(\""Press any key to exit\""): Repeat: Until Inkey() <> \""\"""
"BASIC","Conway's_Game_of_Life","The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.\\nConway's game of life is described   here:\\nA cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.\\nWe calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:\\nAssume cells beyond the boundary are always dead.\\nThe \""game\"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.\\n\\nAlthough you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.\\n\\n\\n\\n","1000 LET M=LEN L$(1)\\n1010 DIM N$(M,M)\\n1020 FOR I=0 TO M+1\\n1030 PRINT AT I,0;\""▩\""\\n1040 PRINT AT I,M+1;\""▩\""\\n1050 PRINT AT 0,I;\""▩\""\\n1060 PRINT AT M+1,I;\""▩\""\\n1070 NEXT I\\n1080 LET G=0\\n1090 PRINT AT 1,M+3;G\\n1100 FOR I=1 TO M\\n1110 FOR J=1 TO M\\n1120 IF L$(I,J)=\""0\"" THEN GOTO 1150\\n1130 PRINT AT I,J;\""■\""\\n1140 GOTO 1160\\n1150 PRINT AT I,J;\"" \""\\n1160 NEXT J\\n1170 NEXT I\\n1180 FOR I=1 TO M\\n1190 FOR J=1 TO M\\n1200 LET N=0\\n1210 FOR K=I-1 TO I+1\\n1220 FOR L=J-1 TO J+1\\n1230 IF K=0 OR K>M OR L=0 OR L>M OR (K=I AND L=J) THEN GOTO 1250\\n1240 LET N=N+VAL L$(K,L)\\n1250 NEXT L\\n1260 NEXT K\\n1270 LET N$(I,J)=L$(I,J)\\n1280 IF N<=1 OR N>=4 THEN LET N$(I,J)=\""0\""\\n1290 IF N=3 THEN LET N$(I,J)=\""1\""\\n1300 NEXT J\\n1310 NEXT I\\n1320 FOR I=1 TO M\\n1330 LET L$(I)=N$(I)\\n1340 NEXT I\\n1350 LET G=G+1\\n1360 GOTO 1090"
"BASIC","Conway's_Game_of_Life","The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.\\nConway's game of life is described   here:\\nA cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.\\nWe calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:\\nAssume cells beyond the boundary are always dead.\\nThe \""game\"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.\\n\\nAlthough you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.\\n\\n\\n\\n","10 DIM L$(3,3)\\n20 LET L$(1)=\""000\""\\n30 LET L$(2)=\""111\""\\n40 LET L$(3)=\""000\"""
"BASIC","Conway's_Game_of_Life","The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.\\nConway's game of life is described   here:\\nA cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.\\nWe calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:\\nAssume cells beyond the boundary are always dead.\\nThe \""game\"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.\\n\\nAlthough you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.\\n\\n\\n\\n","10 DIM L$(16,16)\\n20 FOR I=1 TO 16\\n30 FOR J=1 TO 16\\n40 LET L$(I,J)=\""0\""\\n50 IF RND>=.7 THEN LET L$(I,J)=\""1\""\\n60 NEXT J\\n70 NEXT I"
"BASIC","Conway's_Game_of_Life","The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.\\nConway's game of life is described   here:\\nA cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.\\nWe calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:\\nAssume cells beyond the boundary are always dead.\\nThe \""game\"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.\\n\\nAlthough you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.\\n\\n\\n\\n"," PROGRAM:CONWAY\\n:While 1\\n:For(X,2,9,1)\\n:For(Y,2,17,1)\\n:If [A](Y,X)\\n:Then\\n:Output(X-1,Y-1,\""X\"")\\n:Else\\n:Output(X-1,Y-1,\"" \"")\\n:End\\n:[A](Y-1,X-1)+[A](Y,X-1)+[A](Y+1,X-1)+[A](Y-1,X)+[A](Y+1,X)+[A](Y-1,X+1)+[A](Y,X+1)+[A](Y+1,X+1)→N\\n:If ([A](Y,X) and (N=2 or N=3)) or (not([A](Y,X)) and N=3)\\n:Then\\n:1→[B](Y,X)\\n:Else\\n:0→[B](Y,X)\\n:End\\n:End\\n:End\\n:[B]→[A]\\n:End\\n"
"BASIC","Conway's_Game_of_Life","The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.\\nConway's game of life is described   here:\\nA cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.\\nWe calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:\\nAssume cells beyond the boundary are always dead.\\nThe \""game\"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.\\n\\nAlthough you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.\\n\\n\\n\\n","PROGRAM:PIC2LIFE\\n:For(I,0,17,1)\\n:For(J,0,9,1)\\n:pxl-Test(J,I)→[A](I+1,J+1)\\n:End\\n:End\\n"
"BASIC","Conway's_Game_of_Life","The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.\\nConway's game of life is described   here:\\nA cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.\\nWe calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:\\nAssume cells beyond the boundary are always dead.\\nThe \""game\"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.\\n\\nAlthough you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.\\n\\n\\n\\n","Define life(pattern) = Prgm\\n  Local x,y,nt,count,save,xl,yl,xh,yh\\n  Define nt(y,x) = when(pxlTest(y,x), 1, 0)\\n  \\n  {}→save\\n  setGraph(\""Axes\"", \""Off\"")→save[1]\\n  setGraph(\""Grid\"", \""Off\"")→save[2]\\n  setGraph(\""Labels\"", \""Off\"")→save[3]\\n  FnOff\\n  PlotOff\\n  ClrDraw\\n\\n  If pattern = \""blinker\"" Then\\n    36→yl\\n    40→yh\\n    78→xl\\n    82→xh\\n    PxlOn  36,80\\n    PxlOn  38,80\\n    PxlOn  40,80\\n  ElseIf pattern = \""glider\"" Then\\n    30→yl\\n    40→yh\\n    76→xl\\n    88→xh\\n    PxlOn  38,76\\n    PxlOn  36,78\\n    PxlOn  36,80\\n    PxlOn  38,80\\n    PxlOn  40,80\\n  ElseIf pattern = \""r\"" Then\\n    38-5*2→yl\\n    38+5*2→yh\\n    80-5*2→xl\\n    80+5*2→xh\\n    PxlOn  38,78\\n    PxlOn  36,82\\n    PxlOn  36,80\\n    PxlOn  38,80\\n    PxlOn  40,80\\n  EndIf\\n\\n  While getKey() = 0\\n    © Expand upper-left corner to whole cell\\n    For y,yl,yh,2\\n      For x,xl,xh,2\\n        If pxlTest(y,x) Then\\n          PxlOn y+1,x\\n          PxlOn y+1,x+1\\n          PxlOn y,  x+1\\n        Else\\n          PxlOff y+1,x\\n          PxlOff y+1,x+1\\n          PxlOff y,  x+1\\n        EndIf\\n      EndFor\\n    EndFor\\n\\n    © Compute next generation\\n    For y,yl,yh,2\\n      For x,xl,xh,2\\n        nt(y-1,x-1) + nt(y-1,x) + nt(y-1,x+2) + nt(y,x-1) + nt(y+1,x+2) + nt(y+2,x-1) + nt(y+2,x+1) + nt(y+2,x+2) → count\\n        If count = 3 Then\\n          PxlOn y,x\\n        ElseIf count ≠ 2 Then\\n          PxlOff y,x\\n        EndIf\\n      EndFor\\n    EndFor\\n  EndWhile\\n\\n  © Restore changed options\\n  setGraph(\""Axes\"", save[1])\\n  setGraph(\""Grid\"", save[2])\\n  setGraph(\""Labels\"", save[3])\\nEndPrgm"
"BASIC","Copy_a_string","This task is about copying a string.\\n\\nWhere it is relevant, distinguish between copying the contents of a string\\nversus making an additional reference to an existing string.\\n\\nTo copy a string, we use an MVC (Move Character). To make a reference to a string, we use a LA (Load Address).\\nStrings are immutable in ActionScript, and can safely be assigned with the assignment operator, much as they can in Java.[1]\\nAda provides three different kinds of strings.\\nThe String type is a fixed length string.\\nThe Bounded_String type is a string with variable length up to a specified maximum size.\\nThe Unbounded_String type is a variable length string with no specified maximum size.\\nThe Bounded_String type behaves a lot like C strings, while the Unbounded_String type behaves a lot like the C++ String class.\\nAda provides the ability to manipulate slices of strings.\\nAda Bounded_String type provides a number of functions for dealing with slices.\\nThe intrinsic text type is immediate, immutable\\nand cannot be referred more than once.\\nCopying an intrinsic string:\\nData of the non intrinsic byte array type can be referred more than once.\\nCopying a binary array of bytes:\\nIn ALGOL 68 strings are simply flexible length arrays of CHAR;\\n","100 DEF  FN P(A) =  PEEK (A) +  PEEK(A + 1) * 256 : FOR I =  FN P(105) TO  FN P(107) - 1 STEP 7 : ON PEEK(I + 1) < 128 OR PEEK(I) > 127 GOTO 130 : ON LEFT$(P$, 1) <> CHR$(PEEK(I)) GOTO 130\\n110 IF LEN(P$) > 1 THEN ON PEEK(I + 1) = 128 GOTO 130 : IF MID$(P$, 2, 1) <> CHR$(PEEK(I + 1) - 128) GOTO 130\\n120 POKE I + 4, P / 256 : POKE I + 3, P - PEEK(I + 4) * 256 : RETURN\\n130 NEXT I : STOP"
"BASIC","Copy_a_string","This task is about copying a string.\\n\\nWhere it is relevant, distinguish between copying the contents of a string\\nversus making an additional reference to an existing string.\\n\\nTo copy a string, we use an MVC (Move Character). To make a reference to a string, we use a LA (Load Address).\\nStrings are immutable in ActionScript, and can safely be assigned with the assignment operator, much as they can in Java.[1]\\nAda provides three different kinds of strings.\\nThe String type is a fixed length string.\\nThe Bounded_String type is a string with variable length up to a specified maximum size.\\nThe Unbounded_String type is a variable length string with no specified maximum size.\\nThe Bounded_String type behaves a lot like C strings, while the Unbounded_String type behaves a lot like the C++ String class.\\nAda provides the ability to manipulate slices of strings.\\nAda Bounded_String type provides a number of functions for dealing with slices.\\nThe intrinsic text type is immediate, immutable\\nand cannot be referred more than once.\\nCopying an intrinsic string:\\nData of the non intrinsic byte array type can be referred more than once.\\nCopying a binary array of bytes:\\nIn ALGOL 68 strings are simply flexible length arrays of CHAR;\\n","S$ = \""HELLO\"" : REM S$ IS THE ORIGINAL STRING\\nC$ = S$ : REM C$ IS THE COPY"
"BASIC","Copy_a_string","This task is about copying a string.\\n\\nWhere it is relevant, distinguish between copying the contents of a string\\nversus making an additional reference to an existing string.\\n\\nTo copy a string, we use an MVC (Move Character). To make a reference to a string, we use a LA (Load Address).\\nStrings are immutable in ActionScript, and can safely be assigned with the assignment operator, much as they can in Java.[1]\\nAda provides three different kinds of strings.\\nThe String type is a fixed length string.\\nThe Bounded_String type is a string with variable length up to a specified maximum size.\\nThe Unbounded_String type is a variable length string with no specified maximum size.\\nThe Bounded_String type behaves a lot like C strings, while the Unbounded_String type behaves a lot like the C++ String class.\\nAda provides the ability to manipulate slices of strings.\\nAda Bounded_String type provides a number of functions for dealing with slices.\\nThe intrinsic text type is immediate, immutable\\nand cannot be referred more than once.\\nCopying an intrinsic string:\\nData of the non intrinsic byte array type can be referred more than once.\\nCopying a binary array of bytes:\\nIn ALGOL 68 strings are simply flexible length arrays of CHAR;\\n","P$ = \""S\"" : P = 53637 : GOSUB 100\""POINT STRING S AT SOMETHING ELSE\\n?S$\\n?C$"
"BASIC","Copy_a_string","This task is about copying a string.\\n\\nWhere it is relevant, distinguish between copying the contents of a string\\nversus making an additional reference to an existing string.\\n\\nTo copy a string, we use an MVC (Move Character). To make a reference to a string, we use a LA (Load Address).\\nStrings are immutable in ActionScript, and can safely be assigned with the assignment operator, much as they can in Java.[1]\\nAda provides three different kinds of strings.\\nThe String type is a fixed length string.\\nThe Bounded_String type is a string with variable length up to a specified maximum size.\\nThe Unbounded_String type is a variable length string with no specified maximum size.\\nThe Bounded_String type behaves a lot like C strings, while the Unbounded_String type behaves a lot like the C++ String class.\\nAda provides the ability to manipulate slices of strings.\\nAda Bounded_String type provides a number of functions for dealing with slices.\\nThe intrinsic text type is immediate, immutable\\nand cannot be referred more than once.\\nCopying an intrinsic string:\\nData of the non intrinsic byte array type can be referred more than once.\\nCopying a binary array of bytes:\\nIn ALGOL 68 strings are simply flexible length arrays of CHAR;\\n","a$ = \""I am here\""\\nb$ = a$\\na$ = \""Hello world...\""\\nPRINT a$, b$"
"BASIC","Copy_a_string","This task is about copying a string.\\n\\nWhere it is relevant, distinguish between copying the contents of a string\\nversus making an additional reference to an existing string.\\n\\nTo copy a string, we use an MVC (Move Character). To make a reference to a string, we use a LA (Load Address).\\nStrings are immutable in ActionScript, and can safely be assigned with the assignment operator, much as they can in Java.[1]\\nAda provides three different kinds of strings.\\nThe String type is a fixed length string.\\nThe Bounded_String type is a string with variable length up to a specified maximum size.\\nThe Unbounded_String type is a variable length string with no specified maximum size.\\nThe Bounded_String type behaves a lot like C strings, while the Unbounded_String type behaves a lot like the C++ String class.\\nAda provides the ability to manipulate slices of strings.\\nAda Bounded_String type provides a number of functions for dealing with slices.\\nThe intrinsic text type is immediate, immutable\\nand cannot be referred more than once.\\nCopying an intrinsic string:\\nData of the non intrinsic byte array type can be referred more than once.\\nCopying a binary array of bytes:\\nIn ALGOL 68 strings are simply flexible length arrays of CHAR;\\n","a$ = \""Hello world...\""\\nLOCAL b TYPE STRING\\nb = a$\\na$ = \""Goodbye...\""\\nPRINT a$, b"
"BASIC","Copy_a_string","This task is about copying a string.\\n\\nWhere it is relevant, distinguish between copying the contents of a string\\nversus making an additional reference to an existing string.\\n\\nTo copy a string, we use an MVC (Move Character). To make a reference to a string, we use a LA (Load Address).\\nStrings are immutable in ActionScript, and can safely be assigned with the assignment operator, much as they can in Java.[1]\\nAda provides three different kinds of strings.\\nThe String type is a fixed length string.\\nThe Bounded_String type is a string with variable length up to a specified maximum size.\\nThe Unbounded_String type is a variable length string with no specified maximum size.\\nThe Bounded_String type behaves a lot like C strings, while the Unbounded_String type behaves a lot like the C++ String class.\\nAda provides the ability to manipulate slices of strings.\\nAda Bounded_String type provides a number of functions for dealing with slices.\\nThe intrinsic text type is immediate, immutable\\nand cannot be referred more than once.\\nCopying an intrinsic string:\\nData of the non intrinsic byte array type can be referred more than once.\\nCopying a binary array of bytes:\\nIn ALGOL 68 strings are simply flexible length arrays of CHAR;\\n","10 A$ = \""HELLO\""\\n20 REM COPY CONTENTS OF A$ TO B$\\n30 B$ = A$\\n40 REM CHANGE CONTENTS OF A$\\n50 A$ = \""HI\""\\n60 REM DISPLAY CONTENTS\\n70 PRINT A$, B$"
"BASIC","Copy_a_string","This task is about copying a string.\\n\\nWhere it is relevant, distinguish between copying the contents of a string\\nversus making an additional reference to an existing string.\\n\\nTo copy a string, we use an MVC (Move Character). To make a reference to a string, we use a LA (Load Address).\\nStrings are immutable in ActionScript, and can safely be assigned with the assignment operator, much as they can in Java.[1]\\nAda provides three different kinds of strings.\\nThe String type is a fixed length string.\\nThe Bounded_String type is a string with variable length up to a specified maximum size.\\nThe Unbounded_String type is a variable length string with no specified maximum size.\\nThe Bounded_String type behaves a lot like C strings, while the Unbounded_String type behaves a lot like the C++ String class.\\nAda provides the ability to manipulate slices of strings.\\nAda Bounded_String type provides a number of functions for dealing with slices.\\nThe intrinsic text type is immediate, immutable\\nand cannot be referred more than once.\\nCopying an intrinsic string:\\nData of the non intrinsic byte array type can be referred more than once.\\nCopying a binary array of bytes:\\nIn ALGOL 68 strings are simply flexible length arrays of CHAR;\\n","10 LET A$=\""BECAUSE I DO NOT HOPE TO TURN AGAIN\""\\n20 LET B$=A$\\n30 LET A$=A$( TO 21)\\n40 PRINT B$\\n50 PRINT A$\\n60 LET B$=A$+B$(22 TO 29)\\n70 PRINT B$"
"BASIC","Count_in_octal","Produce a sequential count in octal,   starting at zero,   and using an increment of a one for each consecutive number.\\nEach number should appear on a single line,   and the program should count until terminated,   or until the maximum value of the numeric type in use is reached.\\n\\n\\nThe program uses one ASSIST macro (XPRNT) to keep the code as short as possible.\\n","DIM n AS LONG\\nFOR n = 0 TO &h7FFFFFFF\\n    PRINT OCT$(n)\\nNEXT"
"BASIC","Count_in_octal","Produce a sequential count in octal,   starting at zero,   and using an increment of a one for each consecutive number.\\nEach number should appear on a single line,   and the program should count until terminated,   or until the maximum value of the numeric type in use is reached.\\n\\n\\nThe program uses one ASSIST macro (XPRNT) to keep the code as short as possible.\\n","WHILE (\""\"" = INKEY$)\\n    PRINT Octal$(n)\\n    n = n + 1\\nWEND\\nEND\\nFUNCTION Octal$(what)\\n    outp$ = \""\""\\n    w = what\\n    WHILE ABS(w) > 0\\n        o = w AND 7\\n        w = INT(w / 8)\\n        outp$ = STR$(o) + outp$\\n    WEND\\n    Octal$ = outp$\\nEND FUNCTION"
"BASIC","Count_in_octal","Produce a sequential count in octal,   starting at zero,   and using an increment of a one for each consecutive number.\\nEach number should appear on a single line,   and the program should count until terminated,   or until the maximum value of the numeric type in use is reached.\\n\\n\\nThe program uses one ASSIST macro (XPRNT) to keep the code as short as possible.\\n","10 N$ = \""0\""\\n\\n100 O$ = N$\\n110 PRINT O$\\n120 N$ = \""\""\\n130 C = 1\\n140 FOR I = LEN(O$) TO 1 STEP -1\\n150     N = VAL(MID$(O$, I, 1)) + C\\n160     C = N >= 8\\n170     N$ = STR$(N - C * 8) + N$\\n180 NEXT I\\n190 IF C THEN N$ = \""1\"" + N$\\n200 GOTO 100"
"BASIC","Count_in_octal","Produce a sequential count in octal,   starting at zero,   and using an increment of a one for each consecutive number.\\nEach number should appear on a single line,   and the program should count until terminated,   or until the maximum value of the numeric type in use is reached.\\n\\n\\nThe program uses one ASSIST macro (XPRNT) to keep the code as short as possible.\\n"," 10 LET N$=\""0\""\\n 20 SCROLL\\n 30 PRINT N$\\n 40 LET L=LEN N$\\n 50 LET N=VAL N$(L)+1\\n 60 IF N=8 THEN GOTO 90\\n 70 LET N$(L)=STR$ N\\n 80 GOTO 20\\n 90 LET N$(L)=\""0\""\\n100 IF L=1 THEN GOTO 130\\n110 LET L=L-1\\n120 GOTO 50\\n130 LET N$=\""1\""+N$\\n140 GOTO 20"
"BASIC","Count_occurrences_of_a_substring","Create a function,   or show a built-in function,   to count the number of non-overlapping occurrences of a substring inside a string.\\nThe function should take two arguments:\\n\\nIt should return an integer count.\\nThe matching should yield the highest number of non-overlapping matches.\\nIn general, this essentially means matching from left-to-right or right-to-left   (see proof on talk page).\\n\\nMetrics: length\\nSub-string search: Count occurrences of a substring\\nMulti-string operations: LCP, LCS, concatenation\\nManipulation: reverse, lower- and uppercase\\n\\nThe program uses two ASSIST macros (XDECO,XPRNT) to keep the code as short as possible.\\n","DECLARE FUNCTION countSubstring& (where AS STRING, what AS STRING)\\n\\nPRINT \""the three truths, th:\"", countSubstring&(\""the three truths\"", \""th\"")\\nPRINT \""ababababab, abab:\"", countSubstring&(\""ababababab\"", \""abab\"")\\n\\nFUNCTION countSubstring& (where AS STRING, what AS STRING)\\n    DIM c AS LONG, s AS LONG\\n    s = 1 - LEN(what)\\n    DO\\n        s = INSTR(s + LEN(what), where, what)\\n        IF 0 = s THEN EXIT DO\\n        c = c + 1\\n    LOOP\\n    countSubstring = c\\nEND FUNCTION"
"BASIC","Count_occurrences_of_a_substring","Create a function,   or show a built-in function,   to count the number of non-overlapping occurrences of a substring inside a string.\\nThe function should take two arguments:\\n\\nIt should return an integer count.\\nThe matching should yield the highest number of non-overlapping matches.\\nIn general, this essentially means matching from left-to-right or right-to-left   (see proof on talk page).\\n\\nMetrics: length\\nSub-string search: Count occurrences of a substring\\nMulti-string operations: LCP, LCS, concatenation\\nManipulation: reverse, lower- and uppercase\\n\\nThe program uses two ASSIST macros (XDECO,XPRNT) to keep the code as short as possible.\\n","10 F$ = \""TH\""\\n20 S$ = \""THE THREE TRUTHS\""\\n30 GOSUB 100\""COUNT SUBSTRING\\n40 PRINT R\\n50 F$ = \""ABAB\""\\n60 S$ = \""ABABABABAB\""\\n70 GOSUB 100\""COUNT SUBSTRING\\n80 PRINT R\\n90 END\\n\\n100 R = 0\\n110 F = LEN(F$)\\n120 S = LEN(S$)\\n130 IF F > S THEN RETURN\\n140 IF F = 0 THEN RETURN\\n150 IF F = S AND F$ = S$ THEN R = 1 : RETURN\\n160 FOR I = 1 TO S - F\\n170     IF F$ = MID$(S$, I, F) THEN R = R + 1 : I = I + F - 1\\n180 NEXT I\\n190 RETURN"
"BASIC","Count_occurrences_of_a_substring","Create a function,   or show a built-in function,   to count the number of non-overlapping occurrences of a substring inside a string.\\nThe function should take two arguments:\\n\\nIt should return an integer count.\\nThe matching should yield the highest number of non-overlapping matches.\\nIn general, this essentially means matching from left-to-right or right-to-left   (see proof on talk page).\\n\\nMetrics: length\\nSub-string search: Count occurrences of a substring\\nMulti-string operations: LCP, LCS, concatenation\\nManipulation: reverse, lower- and uppercase\\n\\nThe program uses two ASSIST macros (XDECO,XPRNT) to keep the code as short as possible.\\n","100 INPUT PROMPT \""String:    \"":TXT$\\n110 INPUT PROMPT \""Substring: \"":SUB$\\n120 PRINT COUNT(LCASE$(TXT$),LCASE$(SUB$))\\n130 DEF COUNT(TXT$,SUB$)\\n140   LET N=0:LET PO=1\\n150   DO\\n160     LET PO=POS(TXT$,SUB$,PO)\\n170     IF PO THEN LET N=N+1:LET PO=PO+LEN(SUB$)\\n180   LOOP UNTIL PO=0\\n190   LET COUNT=N\\n200 END DEF"
"BASIC","Count_occurrences_of_a_substring","Create a function,   or show a built-in function,   to count the number of non-overlapping occurrences of a substring inside a string.\\nThe function should take two arguments:\\n\\nIt should return an integer count.\\nThe matching should yield the highest number of non-overlapping matches.\\nIn general, this essentially means matching from left-to-right or right-to-left   (see proof on talk page).\\n\\nMetrics: length\\nSub-string search: Count occurrences of a substring\\nMulti-string operations: LCP, LCS, concatenation\\nManipulation: reverse, lower- and uppercase\\n\\nThe program uses two ASSIST macros (XDECO,XPRNT) to keep the code as short as possible.\\n"," 10 LET S$=\""THE THREE TRUTHS\""\\n 20 LET U$=\""TH\""\\n 30 GOSUB 100\\n 40 PRINT N\\n 50 LET S$=\""ABABABABAB\""\\n 60 LET U$=\""ABAB\""\\n 70 GOSUB 100\\n 80 PRINT N\\n 90 STOP\\n100 LET N=0\\n110 LET I=0\\n120 LET I=I+1\\n130 IF I+LEN U$>LEN S$ THEN RETURN\\n140 IF S$(I TO I+LEN U$-1)<>U$ THEN GOTO 120\\n150 LET N=N+1\\n160 LET I=I+LEN U$\\n170 GOTO 130"
"BASIC","Create_a_file","In this task, the job is to create a new empty file called \""output.txt\"" of size 0 bytes\\nand an empty directory called \""docs\"". This should be done twice: once \""here\"", i.e. in the current working directory and once in the filesystem root.\\nNotes:\\nNote: file names are Operating System dependent.\\nIt may be best to to use an operating system provided library.\\nAppleScript itself has limited built-in File System access, but folders (directories) can be created by controlling the Mac OS Finder, and files can be created and accessed using the Standard Additions (osax) scripting addition included with AppleScript. Also, the Finder has no concept of the working directory (as it is a GUI). You can however target the frontmost Finder window that is open.\\nCreate a zero-byte text file on the startup disk (root directory). Note: the close command is a memory allocation housekeeping command that should be performed once file access is complete.\\nCreate a new folder (directory) on the startup disk (root directory).\\nCreate a zero-byte text file in the frontmost (open) Finder window.\\nCreate a new folder (directory) in the frontmost (open) Finder window.\\n--Apl.way 21:20, 9 June 2010 (UTC)\\nSince the TI-OS does not have a true filesystem, this task is emulated using an application variable instead of a file.\\n","OPEN \""output.txt\"" FOR OUTPUT AS 1\\nCLOSE\\nOPEN \""\\output.txt\"" FOR OUTPUT AS 1\\nCLOSE"
"BASIC","Create_a_file","In this task, the job is to create a new empty file called \""output.txt\"" of size 0 bytes\\nand an empty directory called \""docs\"". This should be done twice: once \""here\"", i.e. in the current working directory and once in the filesystem root.\\nNotes:\\nNote: file names are Operating System dependent.\\nIt may be best to to use an operating system provided library.\\nAppleScript itself has limited built-in File System access, but folders (directories) can be created by controlling the Mac OS Finder, and files can be created and accessed using the Standard Additions (osax) scripting addition included with AppleScript. Also, the Finder has no concept of the working directory (as it is a GUI). You can however target the frontmost Finder window that is open.\\nCreate a zero-byte text file on the startup disk (root directory). Note: the close command is a memory allocation housekeeping command that should be performed once file access is complete.\\nCreate a new folder (directory) on the startup disk (root directory).\\nCreate a zero-byte text file in the frontmost (open) Finder window.\\nCreate a new folder (directory) in the frontmost (open) Finder window.\\n--Apl.way 21:20, 9 June 2010 (UTC)\\nSince the TI-OS does not have a true filesystem, this task is emulated using an application variable instead of a file.\\n","' Create file and dir\\nTRAP LOCAL\\n\\nOPEN \""output.txt\"" FOR WRITING AS afile\\nCLOSE FILE afile\\n\\nCATCH GOTO report\\nOPEN \""/output.txt\"" FOR WRITING AS afile\\nCLOSE FILE afile\\n\\nLABEL trydir\\nMAKEDIR \""docs\""\\n\\nCATCH GOTO report2\\nMAKEDIR \""/docs\""\\nEND\\n\\nLABEL report\\n    PRINT ERR$(ERROR)\\n    GOTO trydir\\n\\nLABEL report2\\n    PRINT ERR$(ERROR)"
"BASIC","Create_a_two-dimensional_array_at_runtime","Data Structure\\nThis illustrates a data structure, a means of storing data within a program.\\nGet two integers from the user, then create a two-dimensional array where the two dimensions have the sizes given by those numbers, and which can be accessed in the most natural way possible. Write some element of that array, and then output that element. Finally destroy the array if not done by the language itself.\\nArrays are an integral part of APL. Array size, shape, and data type can be easily manipulated at runtime.\\nAppleScript has no array, but an AppleScript list can be used in a multidimensional fashion. There's no issue with their dimensions, they grow while adding elements. Memory allocation is dynamic.\\nAWK has no multidimensional array; but AWK arrays (which are Associative array indeed) can be used also in a multidimensional fashion. Since AWK arrays are associative arrays, there's no issue in their dimensions: they grow while adding new key-value pair.\\nAllocate multi-dimensional arrays with a single call to malloc. The demonstration code builds a rank 3 array.\\n\\nThis style is supported by all 'C' compilers.\\nThis style also supports more efficient memory utilization if you're only using a portion of the\\narray. If you only need the upper right half of a square array, you can do something like the following.\\nThis approach most closely matches the C99 example, as alloca allocates on the stack, rather than the heap, as malloc does.\\n\\nThe assert will allow the user to reenter the dimensions if they are not positive integers.\\nArrays in Component Pascal are started from zero index. No DISPOSE-like procedures because of garbage collection.\\n"," CLS\\n INPUT a, b 'inputs need to be separated by commas\\n DIM array (1 TO a, 1 TO b)\\n array(1,1) = 42\\n PRINT array(1,1)\\n ERASE array"
"BASIC","Date_format","\\nDisplay the   current date   in the formats of:\\n\\n","#include \""vbcompat.bi\""\\n\\nDIM today As Double = Now()\\n\\nPRINT Format(today, \""yyyy-mm-dd\"") \\nPRINT Format(today, \""dddd, mmmm d, yyyy\"")"
"BASIC","Day_of_the_week","A company decides that whenever Xmas falls on a Sunday they will give their workers all extra paid holidays so that, together with any public holidays, workers will not have to work the following week (between the 25th of December and the first of January).\\n\\nIn what years between 2008 and 2121 will the 25th of December be a Sunday?\\nUsing any standard date handling libraries of your programming language;\\ncompare the dates calculated with the output of other languages to discover any anomalies in the handling of dates which may be due to, for example, overflow in types used to represent dates/times similar to   y2k   type problems.\\n\\nThe program uses two ASSIST macro (XDECO,XPRNT) to keep the code as short as possible.\\n","Declare Function modulo(x As Double, y As Double) As Double\\nDeclare Function wd(m As Double, d As Double, y As Double) As Integer\\n\\nCls\\nDim yr As Double\\nFor yr = 2008 To 2121\\n	If wd(12,25,yr) = 1 Then\\n		Print \""Dec \"" & 25 & \"", \"" & yr\\n	EndIf\\nNext\\nSleep\\n\\nFunction modulo(x As Double, y As Double) As Double\\n	If y = 0 Then\\n		Return x\\n	Else\\n		Return x - y * Int(x / y)\\n	End If\\nEnd Function\\n\\nFunction wd(m As Double, d As Double, y As Double) As Integer\\n	If m = 1 Or m = 2 Then\\n		m += 12\\n		y-= 1\\n	End If\\n	Return modulo(365 * y + Fix(y / 4) - Fix(y / 100) + Fix(y / 400) + d  + Fix((153 * m + 8) / 5), 7) + 1\\nEnd Function\\n\\nDec 25, 2011\\nDec 25, 2016\\nDec 25, 2022\\nDec 25, 2033\\nDec 25, 2039\\nDec 25, 2044\\nDec 25, 2050\\nDec 25, 2061\\nDec 25, 2067\\nDec 25, 2072\\nDec 25, 2078\\nDec 25, 2089\\nDec 25, 2095\\nDec 25, 2101\\nDec 25, 2107\\nDec 25, 2112\\nDec 25, 2118"
"BASIC","Day_of_the_week","A company decides that whenever Xmas falls on a Sunday they will give their workers all extra paid holidays so that, together with any public holidays, workers will not have to work the following week (between the 25th of December and the first of January).\\n\\nIn what years between 2008 and 2121 will the 25th of December be a Sunday?\\nUsing any standard date handling libraries of your programming language;\\ncompare the dates calculated with the output of other languages to discover any anomalies in the handling of dates which may be due to, for example, overflow in types used to represent dates/times similar to   y2k   type problems.\\n\\nThe program uses two ASSIST macro (XDECO,XPRNT) to keep the code as short as possible.\\n","' Sunday Christmas\\nPRINT \""Years with Christmas on a Sunday\""\\nFOR y = 2008 TO 2121\\n    tv = TIMEVALUE(y, 12, 25, 0, 0, 0)\\n    IF WEEKDAY$(tv) = \""Sunday\"" THEN PRINT y\\nNEXT"
"BASIC","Day_of_the_week","A company decides that whenever Xmas falls on a Sunday they will give their workers all extra paid holidays so that, together with any public holidays, workers will not have to work the following week (between the 25th of December and the first of January).\\n\\nIn what years between 2008 and 2121 will the 25th of December be a Sunday?\\nUsing any standard date handling libraries of your programming language;\\ncompare the dates calculated with the output of other languages to discover any anomalies in the handling of dates which may be due to, for example, overflow in types used to represent dates/times similar to   y2k   type problems.\\n\\nThe program uses two ASSIST macro (XDECO,XPRNT) to keep the code as short as possible.\\n","' version 17-06-2015\\n' compile with: fbc -s console\\n\\nFunction wd(m As Integer, d As Integer, y As Integer) As Integer\\n  If m < 3 Then        ' If m = 1 Or m = 2 Then\\n    m += 12\\n    y -= 1\\n  End If\\n  Return (y + (y \\ 4) - (y \\ 100) + (y \\ 400) + d + ((153 * m + 8) \\ 5)) Mod 7\\nEnd Function\\n\\n' ------=< MAIN >=------\\n\\nFor yr As Integer = 2008 To 2121\\n  If wd(12, 25, yr) = 0 Then\\n    Print \""Dec 25 \""; yr\\n  EndIf\\nNext\\n\\n' empty keyboard buffer \\nWhile InKey <> \""\"" : Wend\\nPrint : Print \""hit any key to end program\""\\nSleep\\nEnd"
"BASIC","Day_of_the_week","A company decides that whenever Xmas falls on a Sunday they will give their workers all extra paid holidays so that, together with any public holidays, workers will not have to work the following week (between the 25th of December and the first of January).\\n\\nIn what years between 2008 and 2121 will the 25th of December be a Sunday?\\nUsing any standard date handling libraries of your programming language;\\ncompare the dates calculated with the output of other languages to discover any anomalies in the handling of dates which may be due to, for example, overflow in types used to represent dates/times similar to   y2k   type problems.\\n\\nThe program uses two ASSIST macro (XDECO,XPRNT) to keep the code as short as possible.\\n","' version 17-06-2015\\n' Weekday And DateSerial only works with #Include \""vbcompat.bi\""\\n' compile with: fbc -s console\\n\\n#Include Once \""vbcompat.bi\""\\nDim As Double a\\n\\nFor yr As Integer = 2008 To 2121\\n  a = DateSerial (yr, 12, 25)\\n  If Weekday(a) = 1 Then Print Format(a, \""dd-mm-yyyy\"")   ' 1 = sunday, 2 = monday ...\\nNext                                                      \\n\\n' empty keyboard buffer \\nWhile InKey <> \""\"" : Wend\\nPrint : Print \""hit any key to end program\""\\nSleep\\nEnd"
"BASIC","Day_of_the_week","A company decides that whenever Xmas falls on a Sunday they will give their workers all extra paid holidays so that, together with any public holidays, workers will not have to work the following week (between the 25th of December and the first of January).\\n\\nIn what years between 2008 and 2121 will the 25th of December be a Sunday?\\nUsing any standard date handling libraries of your programming language;\\ncompare the dates calculated with the output of other languages to discover any anomalies in the handling of dates which may be due to, for example, overflow in types used to represent dates/times similar to   y2k   type problems.\\n\\nThe program uses two ASSIST macro (XDECO,XPRNT) to keep the code as short as possible.\\n","100 PROGRAM \""Dayweek.bas\""\\n110 PRINT \""The years between 2008 and 2121 will the 25th of December be a Sunday:\""\\n120 FOR Y=2008 TO 2121\\n130   IF DAYWEEK(Y,12,25)=0 THEN PRINT \""Dec 25,\"";Y\\n140 NEXT \\n150 DEF DAYWEEK(Y,M,D)\\n160   LET A=INT((14-M)/12):LET Y=Y-A\\n170   LET W=D+INT((13*(M+12*A-2)-1)/5)+Y+INT(Y/4)-INT(Y/100)+INT(Y/400)\\n180   LET DAYWEEK=W-7*INT(W/7)\\n190 END DEF"
"BASIC","Day_of_the_week","A company decides that whenever Xmas falls on a Sunday they will give their workers all extra paid holidays so that, together with any public holidays, workers will not have to work the following week (between the 25th of December and the first of January).\\n\\nIn what years between 2008 and 2121 will the 25th of December be a Sunday?\\nUsing any standard date handling libraries of your programming language;\\ncompare the dates calculated with the output of other languages to discover any anomalies in the handling of dates which may be due to, for example, overflow in types used to represent dates/times similar to   y2k   type problems.\\n\\nThe program uses two ASSIST macro (XDECO,XPRNT) to keep the code as short as possible.\\n"," 10 LET M=12\\n 20 LET D=25\\n 30 FOR Y=2008 TO 2121\\n 40 GOSUB 80\\n 50 IF W=0 THEN PRINT Y\\n 60 NEXT Y\\n 70 STOP\\n 80 LET A=INT ((14-M)/12)\\n 90 LET MM=M+12*A-2\\n100 LET YY=Y-A\\n110 LET W=D+INT ((13*MM-1)/5)+YY+INT (YY/4)-INT (YY/100)+INT (YY/400)\\n120 LET W=W-7*INT (W/7)\\n130 RETURN"
"BASIC","Delete_a_file","Delete a file called \""input.txt\"" and delete a directory called \""docs\"".\\nThis should be done twice: once \""here\"", i.e. in the current working directory and once in the filesystem root.\\n\\nThe 'drop' removes the result (true or false, indicating success or failure). It is not strictly necessary to do so, but it keeps the stack clean.\\nand then\\nNaming conventions for the file path are OS-specific. The language does not specify the encoding of the file paths, the directory separators or brackets, the file extension delimiter, the file version delimiter and syntax. The example provided works under Linux and Windows.\\nThe remove function removes either a file or a directory (the directory must be empty for this to work). Exception is thrown if this fails.\\nNote: scratch does not appear to do anything on ALGOL 68G. Also note that file names are Operating System dependent.\\nSource: DeleteFile @github by jNizM\\nAssuming we are on a Unix/Linux or at least Cygwin system:\\nSome versions of Qbasic may have had a builtin RMDIR command. However this is not documented in the manual, so we use the external MSDOS command in this example.\\nBaCon has a DELETE instruction, that accepts FILE|DIRECTORY|RECURSIVE options.\\nErrors can be caught with the CATCH GOTO label instruction (which allows RESUME from the labelled code section).\\nThe ZX Spectrum microdrive had only a main directory, and filenames did not have\\nfile extensions. Here we delete the file named INPUTTXT from the first microdrive:\\nAnd for disc drive of ZX Spectrum +3:\\nIf the names are known as constants at compile time:\\nIf the names are known only at run time:\\nISO C:\\nPOSIX:\\nTo delete files or directories in COBOL we need to use unofficial extensions. The following are built-in subroutines originally created as part of some of the COBOL products created by Micro Focus.\\nAlternate method of deleting files using the DELETE FILE statement.\\nTo delete directories we need an implementation specific extension. In clisp this is ext:delete-dir.\\nOr you can use the portability library CL-FAD:\\nPOSIX:\\nELENA 3.4 :\\nThere is no means to delete directories in ANS Forth.\\nI don't know a way of deleting directories in Fortran\\nOn most *nix systems, this must be run as sudo for the files in root to be deleted. If you don't have permissions, it will silently fail to delete those files. I would recommend against running anything you find on the internet as sudo.\\nor\\nIcon supports 'remove' for files.\\nNote Icon and Unicon accept both / and \\ for directory separators.\\nThe J standard library comes with a set of file access utilities.\\nThe function above actually uses a foreign conjunction and defined in the files library like so:\\nThis means that you can directly erase files and directories without loading the files library.\\nor\\nSynchronous\\nAsynchronous\\n","\\nKILL \""INPUT.TXT\""\\nKILL \""C:\\INPUT.TXT\""\\nSHELL \""RMDIR /S /Q DIR\""\\nSHELL \""RMDIR /S /Q C:\\DIR\""\\n"
"BASIC","Delete_a_file","Delete a file called \""input.txt\"" and delete a directory called \""docs\"".\\nThis should be done twice: once \""here\"", i.e. in the current working directory and once in the filesystem root.\\n\\nThe 'drop' removes the result (true or false, indicating success or failure). It is not strictly necessary to do so, but it keeps the stack clean.\\nand then\\nNaming conventions for the file path are OS-specific. The language does not specify the encoding of the file paths, the directory separators or brackets, the file extension delimiter, the file version delimiter and syntax. The example provided works under Linux and Windows.\\nThe remove function removes either a file or a directory (the directory must be empty for this to work). Exception is thrown if this fails.\\nNote: scratch does not appear to do anything on ALGOL 68G. Also note that file names are Operating System dependent.\\nSource: DeleteFile @github by jNizM\\nAssuming we are on a Unix/Linux or at least Cygwin system:\\nSome versions of Qbasic may have had a builtin RMDIR command. However this is not documented in the manual, so we use the external MSDOS command in this example.\\nBaCon has a DELETE instruction, that accepts FILE|DIRECTORY|RECURSIVE options.\\nErrors can be caught with the CATCH GOTO label instruction (which allows RESUME from the labelled code section).\\nThe ZX Spectrum microdrive had only a main directory, and filenames did not have\\nfile extensions. Here we delete the file named INPUTTXT from the first microdrive:\\nAnd for disc drive of ZX Spectrum +3:\\nIf the names are known as constants at compile time:\\nIf the names are known only at run time:\\nISO C:\\nPOSIX:\\nTo delete files or directories in COBOL we need to use unofficial extensions. The following are built-in subroutines originally created as part of some of the COBOL products created by Micro Focus.\\nAlternate method of deleting files using the DELETE FILE statement.\\nTo delete directories we need an implementation specific extension. In clisp this is ext:delete-dir.\\nOr you can use the portability library CL-FAD:\\nPOSIX:\\nELENA 3.4 :\\nThere is no means to delete directories in ANS Forth.\\nI don't know a way of deleting directories in Fortran\\nOn most *nix systems, this must be run as sudo for the files in root to be deleted. If you don't have permissions, it will silently fail to delete those files. I would recommend against running anything you find on the internet as sudo.\\nor\\nIcon supports 'remove' for files.\\nNote Icon and Unicon accept both / and \\ for directory separators.\\nThe J standard library comes with a set of file access utilities.\\nThe function above actually uses a foreign conjunction and defined in the files library like so:\\nThis means that you can directly erase files and directories without loading the files library.\\nor\\nSynchronous\\nAsynchronous\\n","DELETE FILE \""input.txt\""\\nDELETE FILE \""/input.txt\"""
"BASIC","Delete_a_file","Delete a file called \""input.txt\"" and delete a directory called \""docs\"".\\nThis should be done twice: once \""here\"", i.e. in the current working directory and once in the filesystem root.\\n\\nThe 'drop' removes the result (true or false, indicating success or failure). It is not strictly necessary to do so, but it keeps the stack clean.\\nand then\\nNaming conventions for the file path are OS-specific. The language does not specify the encoding of the file paths, the directory separators or brackets, the file extension delimiter, the file version delimiter and syntax. The example provided works under Linux and Windows.\\nThe remove function removes either a file or a directory (the directory must be empty for this to work). Exception is thrown if this fails.\\nNote: scratch does not appear to do anything on ALGOL 68G. Also note that file names are Operating System dependent.\\nSource: DeleteFile @github by jNizM\\nAssuming we are on a Unix/Linux or at least Cygwin system:\\nSome versions of Qbasic may have had a builtin RMDIR command. However this is not documented in the manual, so we use the external MSDOS command in this example.\\nBaCon has a DELETE instruction, that accepts FILE|DIRECTORY|RECURSIVE options.\\nErrors can be caught with the CATCH GOTO label instruction (which allows RESUME from the labelled code section).\\nThe ZX Spectrum microdrive had only a main directory, and filenames did not have\\nfile extensions. Here we delete the file named INPUTTXT from the first microdrive:\\nAnd for disc drive of ZX Spectrum +3:\\nIf the names are known as constants at compile time:\\nIf the names are known only at run time:\\nISO C:\\nPOSIX:\\nTo delete files or directories in COBOL we need to use unofficial extensions. The following are built-in subroutines originally created as part of some of the COBOL products created by Micro Focus.\\nAlternate method of deleting files using the DELETE FILE statement.\\nTo delete directories we need an implementation specific extension. In clisp this is ext:delete-dir.\\nOr you can use the portability library CL-FAD:\\nPOSIX:\\nELENA 3.4 :\\nThere is no means to delete directories in ANS Forth.\\nI don't know a way of deleting directories in Fortran\\nOn most *nix systems, this must be run as sudo for the files in root to be deleted. If you don't have permissions, it will silently fail to delete those files. I would recommend against running anything you find on the internet as sudo.\\nor\\nIcon supports 'remove' for files.\\nNote Icon and Unicon accept both / and \\ for directory separators.\\nThe J standard library comes with a set of file access utilities.\\nThe function above actually uses a foreign conjunction and defined in the files library like so:\\nThis means that you can directly erase files and directories without loading the files library.\\nor\\nSynchronous\\nAsynchronous\\n","\\nERASE \""m\""; 1; \""INPUTTXT\""\\n"
"BASIC","Delete_a_file","Delete a file called \""input.txt\"" and delete a directory called \""docs\"".\\nThis should be done twice: once \""here\"", i.e. in the current working directory and once in the filesystem root.\\n\\nThe 'drop' removes the result (true or false, indicating success or failure). It is not strictly necessary to do so, but it keeps the stack clean.\\nand then\\nNaming conventions for the file path are OS-specific. The language does not specify the encoding of the file paths, the directory separators or brackets, the file extension delimiter, the file version delimiter and syntax. The example provided works under Linux and Windows.\\nThe remove function removes either a file or a directory (the directory must be empty for this to work). Exception is thrown if this fails.\\nNote: scratch does not appear to do anything on ALGOL 68G. Also note that file names are Operating System dependent.\\nSource: DeleteFile @github by jNizM\\nAssuming we are on a Unix/Linux or at least Cygwin system:\\nSome versions of Qbasic may have had a builtin RMDIR command. However this is not documented in the manual, so we use the external MSDOS command in this example.\\nBaCon has a DELETE instruction, that accepts FILE|DIRECTORY|RECURSIVE options.\\nErrors can be caught with the CATCH GOTO label instruction (which allows RESUME from the labelled code section).\\nThe ZX Spectrum microdrive had only a main directory, and filenames did not have\\nfile extensions. Here we delete the file named INPUTTXT from the first microdrive:\\nAnd for disc drive of ZX Spectrum +3:\\nIf the names are known as constants at compile time:\\nIf the names are known only at run time:\\nISO C:\\nPOSIX:\\nTo delete files or directories in COBOL we need to use unofficial extensions. The following are built-in subroutines originally created as part of some of the COBOL products created by Micro Focus.\\nAlternate method of deleting files using the DELETE FILE statement.\\nTo delete directories we need an implementation specific extension. In clisp this is ext:delete-dir.\\nOr you can use the portability library CL-FAD:\\nPOSIX:\\nELENA 3.4 :\\nThere is no means to delete directories in ANS Forth.\\nI don't know a way of deleting directories in Fortran\\nOn most *nix systems, this must be run as sudo for the files in root to be deleted. If you don't have permissions, it will silently fail to delete those files. I would recommend against running anything you find on the internet as sudo.\\nor\\nIcon supports 'remove' for files.\\nNote Icon and Unicon accept both / and \\ for directory separators.\\nThe J standard library comes with a set of file access utilities.\\nThe function above actually uses a foreign conjunction and defined in the files library like so:\\nThis means that you can directly erase files and directories without loading the files library.\\nor\\nSynchronous\\nAsynchronous\\n","\\nERASE \""a:INPUTTXT\""\\n"
"BASIC","Delete_a_file","Delete a file called \""input.txt\"" and delete a directory called \""docs\"".\\nThis should be done twice: once \""here\"", i.e. in the current working directory and once in the filesystem root.\\n\\nThe 'drop' removes the result (true or false, indicating success or failure). It is not strictly necessary to do so, but it keeps the stack clean.\\nand then\\nNaming conventions for the file path are OS-specific. The language does not specify the encoding of the file paths, the directory separators or brackets, the file extension delimiter, the file version delimiter and syntax. The example provided works under Linux and Windows.\\nThe remove function removes either a file or a directory (the directory must be empty for this to work). Exception is thrown if this fails.\\nNote: scratch does not appear to do anything on ALGOL 68G. Also note that file names are Operating System dependent.\\nSource: DeleteFile @github by jNizM\\nAssuming we are on a Unix/Linux or at least Cygwin system:\\nSome versions of Qbasic may have had a builtin RMDIR command. However this is not documented in the manual, so we use the external MSDOS command in this example.\\nBaCon has a DELETE instruction, that accepts FILE|DIRECTORY|RECURSIVE options.\\nErrors can be caught with the CATCH GOTO label instruction (which allows RESUME from the labelled code section).\\nThe ZX Spectrum microdrive had only a main directory, and filenames did not have\\nfile extensions. Here we delete the file named INPUTTXT from the first microdrive:\\nAnd for disc drive of ZX Spectrum +3:\\nIf the names are known as constants at compile time:\\nIf the names are known only at run time:\\nISO C:\\nPOSIX:\\nTo delete files or directories in COBOL we need to use unofficial extensions. The following are built-in subroutines originally created as part of some of the COBOL products created by Micro Focus.\\nAlternate method of deleting files using the DELETE FILE statement.\\nTo delete directories we need an implementation specific extension. In clisp this is ext:delete-dir.\\nOr you can use the portability library CL-FAD:\\nPOSIX:\\nELENA 3.4 :\\nThere is no means to delete directories in ANS Forth.\\nI don't know a way of deleting directories in Fortran\\nOn most *nix systems, this must be run as sudo for the files in root to be deleted. If you don't have permissions, it will silently fail to delete those files. I would recommend against running anything you find on the internet as sudo.\\nor\\nIcon supports 'remove' for files.\\nNote Icon and Unicon accept both / and \\ for directory separators.\\nThe J standard library comes with a set of file access utilities.\\nThe function above actually uses a foreign conjunction and defined in the files library like so:\\nThis means that you can directly erase files and directories without loading the files library.\\nor\\nSynchronous\\nAsynchronous\\n","\\n      *DELETE input.txt\\n      *DELETE \\input.txt\\n      *RMDIR docs\\n      *RMDIR \\docs\\n"
"BASIC","Delete_a_file","Delete a file called \""input.txt\"" and delete a directory called \""docs\"".\\nThis should be done twice: once \""here\"", i.e. in the current working directory and once in the filesystem root.\\n\\nThe 'drop' removes the result (true or false, indicating success or failure). It is not strictly necessary to do so, but it keeps the stack clean.\\nand then\\nNaming conventions for the file path are OS-specific. The language does not specify the encoding of the file paths, the directory separators or brackets, the file extension delimiter, the file version delimiter and syntax. The example provided works under Linux and Windows.\\nThe remove function removes either a file or a directory (the directory must be empty for this to work). Exception is thrown if this fails.\\nNote: scratch does not appear to do anything on ALGOL 68G. Also note that file names are Operating System dependent.\\nSource: DeleteFile @github by jNizM\\nAssuming we are on a Unix/Linux or at least Cygwin system:\\nSome versions of Qbasic may have had a builtin RMDIR command. However this is not documented in the manual, so we use the external MSDOS command in this example.\\nBaCon has a DELETE instruction, that accepts FILE|DIRECTORY|RECURSIVE options.\\nErrors can be caught with the CATCH GOTO label instruction (which allows RESUME from the labelled code section).\\nThe ZX Spectrum microdrive had only a main directory, and filenames did not have\\nfile extensions. Here we delete the file named INPUTTXT from the first microdrive:\\nAnd for disc drive of ZX Spectrum +3:\\nIf the names are known as constants at compile time:\\nIf the names are known only at run time:\\nISO C:\\nPOSIX:\\nTo delete files or directories in COBOL we need to use unofficial extensions. The following are built-in subroutines originally created as part of some of the COBOL products created by Micro Focus.\\nAlternate method of deleting files using the DELETE FILE statement.\\nTo delete directories we need an implementation specific extension. In clisp this is ext:delete-dir.\\nOr you can use the portability library CL-FAD:\\nPOSIX:\\nELENA 3.4 :\\nThere is no means to delete directories in ANS Forth.\\nI don't know a way of deleting directories in Fortran\\nOn most *nix systems, this must be run as sudo for the files in root to be deleted. If you don't have permissions, it will silently fail to delete those files. I would recommend against running anything you find on the internet as sudo.\\nor\\nIcon supports 'remove' for files.\\nNote Icon and Unicon accept both / and \\ for directory separators.\\nThe J standard library comes with a set of file access utilities.\\nThe function above actually uses a foreign conjunction and defined in the files library like so:\\nThis means that you can directly erase files and directories without loading the files library.\\nor\\nSynchronous\\nAsynchronous\\n","      OSCLI \""DELETE \"" + file$\\n      OSCLI \""RMDIR \"" + dir$"
"BASIC","Delete_a_file","Delete a file called \""input.txt\"" and delete a directory called \""docs\"".\\nThis should be done twice: once \""here\"", i.e. in the current working directory and once in the filesystem root.\\n\\nThe 'drop' removes the result (true or false, indicating success or failure). It is not strictly necessary to do so, but it keeps the stack clean.\\nand then\\nNaming conventions for the file path are OS-specific. The language does not specify the encoding of the file paths, the directory separators or brackets, the file extension delimiter, the file version delimiter and syntax. The example provided works under Linux and Windows.\\nThe remove function removes either a file or a directory (the directory must be empty for this to work). Exception is thrown if this fails.\\nNote: scratch does not appear to do anything on ALGOL 68G. Also note that file names are Operating System dependent.\\nSource: DeleteFile @github by jNizM\\nAssuming we are on a Unix/Linux or at least Cygwin system:\\nSome versions of Qbasic may have had a builtin RMDIR command. However this is not documented in the manual, so we use the external MSDOS command in this example.\\nBaCon has a DELETE instruction, that accepts FILE|DIRECTORY|RECURSIVE options.\\nErrors can be caught with the CATCH GOTO label instruction (which allows RESUME from the labelled code section).\\nThe ZX Spectrum microdrive had only a main directory, and filenames did not have\\nfile extensions. Here we delete the file named INPUTTXT from the first microdrive:\\nAnd for disc drive of ZX Spectrum +3:\\nIf the names are known as constants at compile time:\\nIf the names are known only at run time:\\nISO C:\\nPOSIX:\\nTo delete files or directories in COBOL we need to use unofficial extensions. The following are built-in subroutines originally created as part of some of the COBOL products created by Micro Focus.\\nAlternate method of deleting files using the DELETE FILE statement.\\nTo delete directories we need an implementation specific extension. In clisp this is ext:delete-dir.\\nOr you can use the portability library CL-FAD:\\nPOSIX:\\nELENA 3.4 :\\nThere is no means to delete directories in ANS Forth.\\nI don't know a way of deleting directories in Fortran\\nOn most *nix systems, this must be run as sudo for the files in root to be deleted. If you don't have permissions, it will silently fail to delete those files. I would recommend against running anything you find on the internet as sudo.\\nor\\nIcon supports 'remove' for files.\\nNote Icon and Unicon accept both / and \\ for directory separators.\\nThe J standard library comes with a set of file access utilities.\\nThe function above actually uses a foreign conjunction and defined in the files library like so:\\nThis means that you can directly erase files and directories without loading the files library.\\nor\\nSynchronous\\nAsynchronous\\n","100 WHEN EXCEPTION USE IOERROR\\n110   EXT \""del input.txt\""\\n120   EXT \""del \\input.txt\""\\n130   EXT \""rmdir docs\""\\n140   EXT \""rmdir \\docs\""\\n150 END WHEN \\n160 HANDLER IOERROR\\n170   PRINT \""Error in line\"";EXLINE\\n180   PRINT \""*** \"";EXSTRING$(EXTYPE)\\n190   CONTINUE \\n200 END HANDLER"
"BASIC","Department_Numbers","There is a highly organized city that has decided to assign a number to each of their departments:\\n\\nEach department can have a number between 1 and 7   (inclusive).\\nThe three department numbers are to be unique (different from each other) and must add up to the number 12.\\nThe Chief of the Police doesn't like odd numbers and wants to have an even number for his department.\\n\\nWrite a program which outputs all valid combinations.\\n\\nPossible output:\\n1 2 9 \\n5 3 4\\n\\nAs noted in the Fortran sample, once the police and sanitation departments are posited, the fire department value is fixed\\n","100 PRINT \""Police\"",\""San.\"",\""Fire\""\\n110 FOR P=2 TO 7 STEP 2\\n120   FOR S=1 TO 7\\n130     IF S<>P THEN\\n131       LET F=(12-P)-S\\n140       IF F>0 AND F<=7 AND F<>S AND F<>P THEN PRINT P,S,F\\n141     END IF\\n150   NEXT\\n160 NEXT"
"BASIC","Department_Numbers","There is a highly organized city that has decided to assign a number to each of their departments:\\n\\nEach department can have a number between 1 and 7   (inclusive).\\nThe three department numbers are to be unique (different from each other) and must add up to the number 12.\\nThe Chief of the Police doesn't like odd numbers and wants to have an even number for his department.\\n\\nWrite a program which outputs all valid combinations.\\n\\nPossible output:\\n1 2 9 \\n5 3 4\\n\\nAs noted in the Fortran sample, once the police and sanitation departments are posited, the fire department value is fixed\\n","10 PRINT \""POLICE SANITATION FIRE\""\\n20 FOR P=2 TO 7 STEP 2\\n30 FOR S=1 TO 7\\n40 IF S=P THEN NEXT S\\n50 LET F=(12-P)-S\\n60 IF F>0 AND F<=7 AND F<>S AND F<>P THEN PRINT \""   \"";P;\""       \"";S;\""       \"";F\\n70 NEXT S\\n80 NEXT P"
"BASIC","Department_Numbers","There is a highly organized city that has decided to assign a number to each of their departments:\\n\\nEach department can have a number between 1 and 7   (inclusive).\\nThe three department numbers are to be unique (different from each other) and must add up to the number 12.\\nThe Chief of the Police doesn't like odd numbers and wants to have an even number for his department.\\n\\nWrite a program which outputs all valid combinations.\\n\\nPossible output:\\n1 2 9 \\n5 3 4\\n\\nAs noted in the Fortran sample, once the police and sanitation departments are posited, the fire department value is fixed\\n","REM >deptnums\\nmax_dept_num% = 7\\ndept_sum% = 12\\nPRINT \""police sanitation fire\""\\nFOR police% = 2 TO max_dept_num% STEP 2\\n  FOR sanitation% = 1 TO max_dept_num%\\n    IF sanitation% <> police% THEN\\n      fire% = (dept_sum% - police%) - sanitation%\\n      IF fire% > 0 AND fire% <= max_dept_num% AND fire% <> sanitation% AND fire% <> police% THEN PRINT \""   \""; police%; \""       \""; sanitation%; \""       \""; fire%\\n    ENDIF\\n  NEXT\\nNEXT\\nEND"
"BASIC","Detect_division_by_zero","Write a function to detect a   divide by zero error   without checking if the denominator is zero.\\n\\nDivision by zero results in the value \""Inf\"":\\n"," 100  REM TRY\\n 110  ONERR  GOTO 200\\n 120 D =  - 44 / 0\\n 190  END\\n 200  REM CATCH\\n 210 E =  PEEK (222) <  > 133\\n 220  POKE 216,0: REM ONERR OFF\\n 230  IF E THEN  RESUME\\n 240  CALL  - 3288: REM RECOVER\\n 250  PRINT \""DIVISION BY ZERO\""\\n"
"BASIC","Detect_division_by_zero","Write a function to detect a   divide by zero error   without checking if the denominator is zero.\\n\\nDivision by zero results in the value \""Inf\"":\\n","      PROCdivide(-44, 0)\\n      PROCdivide(-44, 5)\\n      PROCdivide(0, 5)\\n      PROCdivide(5, 0)\\n      END\\n      \\n      DEF PROCdivide(numerator, denominator)\\n      ON ERROR LOCAL IF FALSE THEN\\n        REM 'Try' clause:\\n        PRINT numerator / denominator\\n      ELSE\\n        REM 'Catch' clause:\\n        CASE ERR OF\\n          WHEN 18: PRINT \""Division by zero\""\\n          WHEN 20: PRINT \""Number too big\""\\n          OTHERWISE RESTORE LOCAL : ERROR ERR, REPORT$\\n        ENDCASE\\n      ENDIF\\n      ENDPROC"
"BASIC","Detect_division_by_zero","Write a function to detect a   divide by zero error   without checking if the denominator is zero.\\n\\nDivision by zero results in the value \""Inf\"":\\n","100 WHEN EXCEPTION USE ERROR\\n110   FOR I=5 TO-2 STEP-1\\n120     PRINT 10/I\\n130   NEXT\\n140 END WHEN\\n150 HANDLER ERROR\\n160   IF EXTYPE=3001 THEN PRINT EXSTRING$(EXTYPE);\"" in line\"";EXLINE\\n170   CONTINUE\\n180 END HANDLER"
"BASIC","Detect_division_by_zero","Write a function to detect a   divide by zero error   without checking if the denominator is zero.\\n\\nDivision by zero results in the value \""Inf\"":\\n","result = DetectDividebyZero(1, 0)\\n\\n\\nFunction DetectDividebyZero(a, b)\\n    On Error GoTo [Error]\\n        DetectDividebyZero= (a/ b)\\n        Exit Function\\n    [Error]\\n        If Err = 11 Then '11 is the error number raised when divide by zero occurs\\n            Notice \""Divide by Zero Detected!\""\\n        End If\\nEnd Function"
"BASIC","Detect_division_by_zero","Write a function to detect a   divide by zero error   without checking if the denominator is zero.\\n\\nDivision by zero results in the value \""Inf\"":\\n","10 ON ERROR GOTO 60\\n20 PRINT 2/3\\n30 PRINT 3/5\\n40 PRINT 4/0\\n50 END\\n60 IF ERR=11 THEN PRINT \""Division by zero in line\""ERL:RESUME 50"
"BASIC","Detect_division_by_zero","Write a function to detect a   divide by zero error   without checking if the denominator is zero.\\n\\nDivision by zero results in the value \""Inf\"":\\n",";Set up a Procedure to handle any Error\\nProcedure MyErrorHandler()\\n  Define txt$=\""The following error happened.\""+#CRLF$+ ErrorMessage()+\""at line  \""+Str(ErrorLine())\\n  MessageRequester(\""OnError test\"", txt$)\\nEndProcedure\\n \\n; Tell where to go if an Error happens\\nOnErrorCall(@MyErrorHandler())\\n \\n;Now, do something very stupid so that we may see an Error...\\nRepeat \\n  A=Random(100)/Random(100)\\nForEver"
"BASIC","Detect_division_by_zero","Write a function to detect a   divide by zero error   without checking if the denominator is zero.\\n\\nDivision by zero results in the value \""Inf\"":\\n","Define.d a, b\\nDebug a/b"
"BASIC","Detect_division_by_zero","Write a function to detect a   divide by zero error   without checking if the denominator is zero.\\n\\nDivision by zero results in the value \""Inf\"":\\n","on error goto [error]\\na = 1 / 0\\nwait\\n\\n[error] ' error 11 is division by zero err number\\nIf err = 11 Then print \""Division by Zero\""\\nwait"
"BASIC","Determine_if_a_string_is_numeric","Create a boolean function which takes in a string and tells whether it is a numeric string (floating point and negative numbers included) in the syntax the language uses for numeric literals or numbers converted from strings.\\n\\nThe first file is the package interface containing the declaration of the Is_Numeric function.\\nThe second file is the package body containing the implementation of the Is_Numeric function.\\nThe last file shows how the Is_Numeric function can be called.\\n","10 INPUT \""Enter a string\"";S$:GOSUB 1000\\n20 IF R THEN PRINT \""Is num\"" ELSE PRINT\""Not num\""\\n99 END\\n1000 T1=VAL(S$):T1$=STR$(T1)\\n1010 R=T1$=S$ OR T1$=\"" \""+S$\\n1099 RETURN"
"BASIC","Digital_root","The digital root, \\n\\n\\n\\nX\\n\\n\\n{\\displaystyle X}\\n\\n, of a number, \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n, is calculated:\\nThe additive persistence is the number of summations required to obtain the single digit.\\nThe task is to calculate the additive persistence and the digital root of a number, e.g.:\\nThe digital root may be calculated in bases other than 10.\\n\\n\\n","DECLARE SUB digitalRoot (what AS LONG)\\n\\n'test inputs:\\ndigitalRoot 627615\\ndigitalRoot 39390\\ndigitalRoot 588225\\n\\nSUB digitalRoot (what AS LONG)\\n    DIM w AS LONG, t AS LONG, c AS INTEGER\\n\\n    w = ABS(what)\\n    IF w > 10 THEN\\n        DO\\n            c = c + 1\\n            WHILE w\\n                t = t + (w MOD (10))\\n                w = w \\ 10\\n            WEND\\n            w = t\\n            t = 0\\n        LOOP WHILE w > 9\\n    END IF\\n    PRINT what; \"": additive persistance \""; c; \"", digital root \""; w\\nEND SUB"
"BASIC","Discordian_date","\\nConvert a given date from the   Gregorian calendar   to the   Discordian calendar.\\n\\ndiscordian.adb:\\n","#INCLUDE \""datetime.bi\""\\n\\nDECLARE FUNCTION julian(AS DOUBLE) AS INTEGER\\n\\nSeasonNames:\\nDATA \""Chaos\"", \""Discord\"", \""Confusion\"", \""Bureaucracy\"", \""The Aftermath\""\\nWeekdays:\\nDATA \""Setting Orange\"", \""Sweetmorn\"", \""Boomtime\"", \""Pungenday\"", \""Prickle-Prickle\""\\nDaysPreceding1stOfMonth:\\n'   jan feb mar apr may  jun  jul  aug  sep  oct  nov  dec\\nDATA 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334\\n\\nDIM dyear AS INTEGER, dseason AS STRING, dday AS INTEGER, dweekday AS STRING\\nDIM tmpdate AS DOUBLE, jday AS INTEGER, result AS STRING\\nDIM L0 AS INTEGER\\n\\nIF LEN(COMMAND$) THEN\\n    tmpdate = DATEVALUE(COMMAND$)\\nELSE\\n    tmpdate = FIX(NOW())\\nEND IF\\ndyear = YEAR(tmpdate) + 1166\\nIF (2 = MONTH(tmpdate)) AND (29 = DAY(tmpdate)) THEN\\n    result = \""Saint Tib's Day, \"" & STR$(dyear) & \"" YOLD\""\\nELSE\\n    jday = julian(tmpdate)\\n    RESTORE SeasonNames\\n    FOR L0 = 1 TO ((jday - 1) \\ 73) + 1\\n    	READ dseason\\n    NEXT\\n    dday = (jday MOD 73)\\n    IF 0 = dday THEN dday = 73\\n    RESTORE Weekdays\\n    FOR L0 = 1 TO (jday MOD 5) + 1\\n        READ dweekday\\n    NEXT\\n    result = dweekday & \"", \"" & dseason & \"" \"" & TRIM$(STR$(dday)) & \"", \"" & TRIM$(STR$(dyear)) & \"" YOLD\""\\nEND IF\\n\\n? result\\nEND\\n\\nFUNCTION julian(d AS DOUBLE) AS INTEGER\\n    'doesn't account for leap years (not needed for ddate)\\n    DIM tmp AS INTEGER, L1 AS INTEGER\\n    RESTORE DaysPreceding1stOfMonth\\n    FOR L1 = 1 TO MONTH(d)\\n        READ tmp\\n    NEXT\\n    FUNCTION = tmp + DAY(d)\\nEND FUNCTION"
"BASIC","Dot_product","Create a function/use an in-built function, to compute the   dot product,   also known as the   scalar product   of two vectors.\\nIf possible, make the vectors of arbitrary length.\\n\\nAs an example, compute the dot product of the vectors:\\n\\nIf implementing the dot product of two vectors directly:\\n\\n\\n","\\n 100 :\\n 110  REM  DOT PRODUCT\\n 120 :\\n 130  REM  INITIALIZE VECTORS OF LENGTH N\\n 140  N = 3\\n 150  DIM V1(N): DIM V2(N)\\n 160  FOR I = 1 TO N\\n 170  V1(I) =  INT ( RND (1) * 20 - 9.5)\\n 180  V2(I) =  INT ( RND (1) * 20 - 9.5)\\n 190  NEXT I\\n 300 :\\n 310  REM  CALCULATE THE DOT PRODUCT\\n 320 :\\n 330  FOR I = 1 TO N:DP = DP + V1(I) * V2(I): NEXT I\\n 400 :\\n 410  REM  DISPLAY RESULT\\n 420 :\\n 430  PRINT \""[\"";: FOR I = 1 TO N: PRINT \"" \"";V1(I);: NEXT I\\n 440  PRINT \""] . [\"";: FOR I = 1 TO N: PRINT \"" \"";V2(I);: NEXT I\\n 450  PRINT \""] = \"";DP\\n"
"BASIC","Dot_product","Create a function/use an in-built function, to compute the   dot product,   also known as the   scalar product   of two vectors.\\nIf possible, make the vectors of arbitrary length.\\n\\nAs an example, compute the dot product of the vectors:\\n\\nIf implementing the dot product of two vectors directly:\\n\\n\\n","      DIM vec1(2), vec2(2), dot(0)\\n      \\n      vec1() = 1, 3, -5\\n      vec2() = 4, -2, -1\\n      \\n      dot() = vec1() . vec2()\\n      PRINT \""Result is \""; dot(0)"
"BASIC","Dragon_curve","Create and display a dragon curve fractal.\\n(You may either display the curve directly or write it to an image file.)\\n\\nHere are some brief notes the algorithms used and how they might suit various languages.\\nThis always has F at even positions and S at odd. Eg. after 3 levels F_S_F_S_F_S_F_S. The +/- turns in between bend to the left or right the same as the \""successive approximation\"" method above. Read more at for instance Joel Castellanos' L-system page.\\nVariations are possible if you have only a single symbol for line draw, for example the Icon and Unicon and Xfractint code. The angles can also be broken into 45-degree parts to keep the expansion in a single direction rather than the endpoint rotating around.\\nThe string rewrites can be done recursively without building the whole string, just follow its instructions at the target level. See for example C by IFS Drawing code. The effect is the same as \""recursive with parameter\"" above but can draw other curves defined by L-systems. \\nOutput:\\nNote: each Dragon curve is composed of many smaller dragon curves (shown in a different colour).\\nExample code using mutual recursion can be found in Recursion Example of \""A Beginner's Guide to Amiga E\"".\\nApple IIe BASIC code can be found in Thomas Bannon, \""Fractals and Transformations\"", Mathematics Teacher, March 1991, pages 178-185. (At JSTOR.)\\nThe Asymptote source code includes an examples/dragon.asy which draws the dragon curve (four interlocking copies actually),\\nAs of its version 2.15 it uses the successive approximation method. Vertices are represented as an array of \""pairs\"" (complex numbers). Between each two vertices a new vertex is is introduced so as to double the segments, repeated to a desired level.\\nSee: Dragon curve/AutoHotkey\\n\\nSee also Sydney Afriat \""Dragon Curves\"" paper for various approaches in BASIC\\nAnd TRS-80 BASIC code in Dan Rollins, \""A Tiger Meets a Dragon: An examination of the mathematical properties of dragon curves and a program to print them on an IDS Paper Tiger\"", Byte Magazine, December 1983. (Based on generating a string of turns by appending middle turn and reversed copy. Options for the middle turn give the alternate paper folding curve and more too. The turns are then followed for the plot.)\\nThis is loosely based on the M4 predicate algorithm, only it produces a more compact ASCII output (which is also a little easier to implement), and it lets you choose the depth of the expansion rather than having to specify the coordinates of the viewing area.\\nIn Befunge-93 the 8-bit cell size restricts you to a maximum depth of 15, but in Befunge-98 you should be able go quite a bit deeper before other limits of the implementation come into play.\\n","DIM SHARED angle AS Double\\n \\nSUB turn (degrees AS Double)\\n    angle = angle + degrees*3.14159265/180\\nEND SUB\\n \\nSUB forward (length AS Double)\\n    LINE - STEP (cos(angle)*length, sin(angle)*length), 7\\nEND SUB\\n \\nSUB dragon (length AS Double, split AS Integer, d AS Double)\\n    IF split=0 THEN\\n        forward length\\n    ELSE\\n	turn d*45\\n	dragon length/1.4142136, split-1, 1\\n	turn -d*90\\n	dragon length/1.4142136, split-1, -1\\n	turn d*45\\n    END IF\\nEND SUB\\n \\n' Main program\\n \\nSCREEN 12\\nangle = 0\\nPSET (150,180), 0\\ndragon 400, 12, 1\\nSLEEP"
"BASIC","Dragon_curve","Create and display a dragon curve fractal.\\n(You may either display the curve directly or write it to an image file.)\\n\\nHere are some brief notes the algorithms used and how they might suit various languages.\\nThis always has F at even positions and S at odd. Eg. after 3 levels F_S_F_S_F_S_F_S. The +/- turns in between bend to the left or right the same as the \""successive approximation\"" method above. Read more at for instance Joel Castellanos' L-system page.\\nVariations are possible if you have only a single symbol for line draw, for example the Icon and Unicon and Xfractint code. The angles can also be broken into 45-degree parts to keep the expansion in a single direction rather than the endpoint rotating around.\\nThe string rewrites can be done recursively without building the whole string, just follow its instructions at the target level. See for example C by IFS Drawing code. The effect is the same as \""recursive with parameter\"" above but can draw other curves defined by L-systems. \\nOutput:\\nNote: each Dragon curve is composed of many smaller dragon curves (shown in a different colour).\\nExample code using mutual recursion can be found in Recursion Example of \""A Beginner's Guide to Amiga E\"".\\nApple IIe BASIC code can be found in Thomas Bannon, \""Fractals and Transformations\"", Mathematics Teacher, March 1991, pages 178-185. (At JSTOR.)\\nThe Asymptote source code includes an examples/dragon.asy which draws the dragon curve (four interlocking copies actually),\\nAs of its version 2.15 it uses the successive approximation method. Vertices are represented as an array of \""pairs\"" (complex numbers). Between each two vertices a new vertex is is introduced so as to double the segments, repeated to a desired level.\\nSee: Dragon curve/AutoHotkey\\n\\nSee also Sydney Afriat \""Dragon Curves\"" paper for various approaches in BASIC\\nAnd TRS-80 BASIC code in Dan Rollins, \""A Tiger Meets a Dragon: An examination of the mathematical properties of dragon curves and a program to print them on an IDS Paper Tiger\"", Byte Magazine, December 1983. (Based on generating a string of turns by appending middle turn and reversed copy. Options for the middle turn give the alternate paper folding curve and more too. The turns are then followed for the plot.)\\nThis is loosely based on the M4 predicate algorithm, only it produces a more compact ASCII output (which is also a little easier to implement), and it lets you choose the depth of the expansion rather than having to specify the coordinates of the viewing area.\\nIn Befunge-93 the 8-bit cell size restricts you to a maximum depth of 15, but in Befunge-98 you should be able go quite a bit deeper before other limits of the implementation come into play.\\n","100 PROGRAM \""Dragon.bas\""\\n110 OPTION ANGLE DEGREES\\n120 LET SQ2=SQR(2)\\n130 GRAPHICS HIRES 2\\n140 SET PALETTE 0,33\\n150 PLOT 250,360,ANGLE 0;\\n160 CALL DC(580,0,11)\\n170 DEF DC(D,A,LEV)\\n180   IF LEV=0 THEN\\n190     PLOT FORWARD D;\\n200   ELSE\\n210     PLOT RIGHT A;\\n220     CALL DC(D/SQ2,45,LEV-1)\\n230     PLOT LEFT 2*A;\\n240     CALL DC(D/SQ2,-45,LEV-1)\\n250     PLOT RIGHT A;\\n260   END IF\\n270 END DEF"
"BASIC","Draw_a_clock","Draw a clock.\\n\\nMore specific:\\n\\n\\nrequires the GDI+ Library from http://www.autohotkey.com/forum/viewtopic.php?t=32238\\nthis code from http://www.autohotkey.com/forum/viewtopic.php?p=231836#231836\\ndraws a very nice clock with GDI+\\n","10 gosub 1500: rem setup clock digit strings\\n20 ti$ = \""123456\""\\n25 rem do some other stuff after this line\\n30 print x: x=x+1\\n40 for i=0 to 500: next\\n50 gosub 1000: rem display the time\\n60 goto 30\\n70 end\\n1000 t$ = ti$\\n1010 for i=1 to 6\\n1020   t(i) = val(mid$(t$,i,1))\\n1030 next\\n1040 print chr$(19);\\n1050 for j=1 to 5\\n1055   print tab(19);\\n1060   for i=1 to 6\\n1070     k=t(i)*3+1\\n1080     print mid$(z$(j),k,3);\\n1090     rem if j<5 then print\"" \"";: goto 1130\\n1100     if i=2 then print\"" \"";\\n1110     if i=4 then print\"" \"";\\n1130   next\\n1140   print\\n1150 next\\n1160 return\\n1500 dim z$(5)\\n1510 z$(1) = \""UCI I UCICCIB BCCCUCIUCIUCI\""\\n1520 z$(2) = \""B B B   B  BB BB  B  B BB B\""\\n1530 z$(3) = \""B B B UCK CBJCBJCIBCIBCIJCB\""\\n1540 z$(4) = \""B B B B    B  B  BB BB B  B\""\\n1550 z$(5) = \""JCKCCCJCCCCK  BCCKJCKJCK CK\""\\n1560 return"
"BASIC","Draw_a_clock","Draw a clock.\\n\\nMore specific:\\n\\n\\nrequires the GDI+ Library from http://www.autohotkey.com/forum/viewtopic.php?t=32238\\nthis code from http://www.autohotkey.com/forum/viewtopic.php?p=231836#231836\\ndraws a very nice clock with GDI+\\n","100 PROGRAM \""Clock.bas\""\\n110 OPTION ANGLE DEGREES\\n120 LET CH=1:LET CH2=2\\n130 SET VIDEO MODE 1:SET VIDEO COLOR 1:SET VIDEO X 26:SET VIDEO Y 25\\n140 OPEN #1:\""video:\""\\n150 OPEN #2:\""video:\""\\n160 DO\\n170   LET H=VAL(TIME$(1:2)):LET M=VAL(TIME$(4:5)):LET S=VAL(TIME$(7:))\\n180   SET #CH:INK 3:PLOT #CH:420,420,ANGLE 90-30*H-M/2;FORWARD 200\\n190   PLOT #CH:420,420,ANGLE 90-6*M;FORWARD 350\\n200   SET #CH:INK 2:PLOT #CH:420,420,ANGLE 90-6*S;FORWARD 300\\n210   SET #CH:INK 1:PLOT #CH:420,420,ELLIPSE 12,12,ELLIPSE 400,400\\n230   PLOT #CH:394,812,:PRINT #CH:\""12\"":PLOT #CH:784,434,:PRINT #CH:\""3\""\\n240   PLOT #CH:406,58,:PRINT #CH:\""6\"":PLOT #CH:28,434,:PRINT #CH:\""9\""\\n250   DISPLAY #CH:AT 1 FROM 1 TO 25\\n260   CLEAR #CH2\\n270   LET T=CH:LET CH=CH2:LET CH2=T\\n280 LOOP UNTIL INKEY$=CHR$(27)\\n290 CLOSE #2\\n300 CLOSE #1\\n310 TEXT"
"BASIC","Draw_a_sphere","Draw a sphere.\\nThe sphere can be represented graphically, or in ASCII art, depending on the language capabilities.\\nEither static or rotational projection is acceptable for this task.\\n\\nTranslation from the C code at http://cairographics.org/samples/gradient\\nUses the Cairo component of GtkAda to create and save as png\\nThis uses a very loose binding to SDL as found in any GPS installation. For it to work, you must choose New Project From Templte|Empty Game\\n","clg\\ncolor white\\nrect 0,0,graphwidth, graphheight\\nFor n = 1 to 100\\ncolor rgb(2*n,2*n,2*n)\\ncircle 150-2*n/3,150-n/2,150-n\\nnext n"
"BASIC","Draw_a_sphere","Draw a sphere.\\nThe sphere can be represented graphically, or in ASCII art, depending on the language capabilities.\\nEither static or rotational projection is acceptable for this task.\\n\\nTranslation from the C code at http://cairographics.org/samples/gradient\\nUses the Cairo component of GtkAda to create and save as png\\nThis uses a very loose binding to SDL as found in any GPS installation. For it to work, you must choose New Project From Templte|Empty Game\\n","      MODE 8\\n      INSTALL @lib$+\""D3DLIB\""\\n      D3DTS_VIEW = 2\\n      D3DTS_PROJECTION = 3\\n      D3DRS_SPECULARENABLE = 29\\n      \\n      SYS \""LoadLibrary\"", @lib$+\""D3DX8BBC.DLL\"" TO d3dx%\\n      IF d3dx%=0 ERROR 100, \""Couldn't load D3DX8BBC.DLL\""\\n      SYS \""GetProcAddress\"", d3dx%, \""D3DXCreateSphere\"" TO `D3DXCreateSphere`\\n      SYS \""GetProcAddress\"", d3dx%, \""D3DXMatrixLookAtLH\"" TO `D3DXMatrixLookAtLH`\\n      SYS \""GetProcAddress\"", d3dx%, \""D3DXMatrixPerspectiveFovLH\"" TO `D3DXMatrixPerspectiveFovLH`\\n      \\n      DIM eyepos%(2), lookat%(2), up%(2), mat%(3,3)\\n      \\n      DIM D3Dlight8{Type%, Diffuse{r%,g%,b%,a%}, Specular{r%,g%,b%,a%}, \\\\n      \\ Ambient{r%,g%,b%,a%}, Position{x%,y%,z%}, Direction{x%,y%,z%}, \\\\n      \\ Range%, Falloff%, Attenuation0%, Attenuation1%, Attenuation2%, \\\\n      \\ Theta%, Phi%}\\n      \\n      DIM D3Dmaterial8{Diffuse{r%,g%,b%,a%}, Ambient{r%,g%,b%,a%}, \\\\n      \\ Specular{r%,g%,b%,a%}, Emissive{r%,g%,b%,a%}, Power%}\\n      \\n      DIM D3Dbasemesh8{QueryInterface%, Addref%, Release%, \\\\n      \\ DrawSubset%, GetNumFaces%, GetNumVertices%, GetFVF%, \\\\n      \\ GetDeclaration%, GetOptions%, GetDevice%, \\\\n      \\ CloneMeshFVF%, CloneMesh%, GetVertexBuffer%, GetIndexBuffer%, \\\\n      \\ LockVertexBuffer%, UnlockVertexBuffer%, LockIndexBuffer%, \\\\n      \\ UnlockIndexBuffer%, GetAttributeTable%}\\n      \\n      DIM D3Ddevice8{QueryInterface%, AddRef%, Release%, TestCooperativeLevel%, \\\\n      \\ GetAvailableTextureMem%, ResourceManagerDiscardBytes%, GetDirect3D%, \\\\n      \\ GetDeviceCaps%, GetDisplayMode%, GetCreationParameters%, SetCursorProperties%, \\\\n      \\ SetCursorPosition%, ShowCursor%, CreateAdditionalSwapChain%, Reset%, \\\\n      \\ Present%, GetBackBuffer%, GetRasterStatus%, SetGammaRamp%, GetGammaRamp%, \\\\n      \\ CreateTexture%, CreateVolumeTexture%, CreateCubeTexture%, CreateVertexBuffer%, \\\\n      \\ CreateIndexBuffer%, CreateRenderTarget%, CreateDepthStencilSurface%, \\\\n      \\ CreateImageSurface%, CopyRects%, UpdateTexture%, GetFrontBuffer%, \\\\n      \\ SetRenderTarget%, GetRenderTarget%, GetDepthStencilSurface%, BeginScene%, \\\\n      \\ EndScene%, Clear%, SetTransform%, GetTransform%, MultiplyTransform%, \\\\n      \\ SetViewport%, GetViewport%, SetMaterial%, GetMaterial%, SetLight%, GetLight%, \\\\n      \\ LightEnable%, GetLightEnable%, SetClipPlane%, GetClipPlane%, SetRenderState%, \\\\n      \\ GetRenderState%, BeginStateBlock%, EndStateBlock%, ApplyStateBlock%, \\\\n      \\ CaptureStateBlock%, DeleteStateBlock%, CreateStateBlock%, SetClipStatus%, \\\\n      \\ GetClipStatus%, GetTexture%, SetTexture%, GetTextureStageState%, \\\\n      \\ SetTextureStageState%, ValidateDevice%, GetInfo%, SetPaletteEntries%, \\\\n      \\ GetPaletteEntries%, SetCurrentTexturePalette%, GetCurrentTexturePalette%, \\\\n      \\ DrawPrimitive%, DrawIndexedPrimitive%, DrawPrimitiveUP%, \\\\n      \\ DrawIndexedPrimitiveUP%, ProcessVertices%, CreateVertexShader%, \\\\n      \\ SetVertexShader%, GetVertexShader%, DeleteVertexShader%, \\\\n      \\ SetVertexShaderConstant%, GetVertexShaderConstant%, GetVertexShaderDeclaration%, \\\\n      \\ GetVertexShaderFunction%, SetStreamSource%, GetStreamSource%, SetIndices%, \\\\n      \\ GetIndices%, CreatePixelShader%, SetPixelShader%, GetPixelShader%, \\\\n      \\ DeletePixelShader%, SetPixelShaderConstant%, GetPixelShaderConstant%, \\\\n      \\ GetPixelShaderFunction%, DrawRectPatch%, DrawTriPatch%, DeletePatch%}\\n      \\n      pDevice%=FN_initd3d(@hwnd%, 1, 1)\\n      IF pDevice%=0 ERROR 100, \""Couldn't create Direct3D8 device\""\\n      !(^D3Ddevice8{}+4) = !pDevice%\\n      \\n      SYS `D3DXCreateSphere`, pDevice%, FN_f4(1), 50, 50, ^meshSphere%, 0\\n      IF meshSphere% = 0 ERROR 100, \""D3DXCreateSphere failed\""\\n      !(^D3Dbasemesh8{}+4) = !meshSphere%\\n      \\n      REM. Point-source light:\\n      D3Dlight8.Type%=1 : REM. point source\\n      D3Dlight8.Diffuse.r%  = FN_f4(1)\\n      D3Dlight8.Diffuse.g%  = FN_f4(1)\\n      D3Dlight8.Diffuse.b%  = FN_f4(1)\\n      D3Dlight8.Specular.r% = FN_f4(1)\\n      D3Dlight8.Specular.g% = FN_f4(1)\\n      D3Dlight8.Specular.b% = FN_f4(1)\\n      D3Dlight8.Position.x% = FN_f4(2)\\n      D3Dlight8.Position.y% = FN_f4(1)\\n      D3Dlight8.Position.z% = FN_f4(4)\\n      D3Dlight8.Range%      = FN_f4(10)\\n      D3Dlight8.Attenuation0% = FN_f4(1)\\n      \\n      REM. Material:\\n      D3Dmaterial8.Diffuse.r%  = FN_f4(0.2)\\n      D3Dmaterial8.Diffuse.g%  = FN_f4(0.6)\\n      D3Dmaterial8.Diffuse.b%  = FN_f4(1.0)\\n      D3Dmaterial8.Specular.r% = FN_f4(0.4)\\n      D3Dmaterial8.Specular.g% = FN_f4(0.4)\\n      D3Dmaterial8.Specular.b% = FN_f4(0.4)\\n      D3Dmaterial8.Power%      = FN_f4(100)\\n      \\n      fovy = RAD(30)\\n      aspect = 5/4\\n      znear = 1\\n      zfar = 1000\\n      bkgnd% = &7F7F7F\\n      eyepos%() = 0, 0, FN_f4(6)\\n      lookat%() = 0, 0, 0\\n      up%() = 0, FN_f4(1), 0\\n      \\n      SYS D3Ddevice8.Clear%, pDevice%, 0, 0, 3, bkgnd%, FN_f4(1), 0\\n      SYS D3Ddevice8.BeginScene%, pDevice%\\n      SYS D3Ddevice8.SetLight%, pDevice%, 0, D3Dlight8{}\\n      SYS D3Ddevice8.LightEnable%, pDevice%, 0, 1\\n      SYS D3Ddevice8.SetMaterial%, pDevice%, D3Dmaterial8{}\\n      SYS D3Ddevice8.SetRenderState%, pDevice%, D3DRS_SPECULARENABLE, 1\\n      \\n      SYS `D3DXMatrixLookAtLH`, ^mat%(0,0), ^eyepos%(0), ^lookat%(0), ^up%(0)\\n      SYS D3Ddevice8.SetTransform%, pDevice%, D3DTS_VIEW, ^mat%(0,0)\\n      \\n      SYS `D3DXMatrixPerspectiveFovLH`, ^mat%(0,0), FN_f4(fovy), \\\\n      \\                                 FN_f4(aspect), FN_f4(znear), FN_f4(zfar)\\n      SYS D3Ddevice8.SetTransform%, pDevice%, D3DTS_PROJECTION, ^mat%(0,0)\\n      \\n      SYS D3Dbasemesh8.DrawSubset%, meshSphere%, 0\\n      SYS D3Ddevice8.EndScene%, pDevice%\\n      SYS D3Ddevice8.Present%, pDevice%, 0, 0, 0, 0\\n      \\n      SYS D3Ddevice8.Release%, pDevice%\\n      SYS D3Dbasemesh8.Release%, meshSphere%\\n      SYS \""FreeLibrary\"", d3dx%\\n      END\\n"
"BASIC","Draw_a_sphere","Draw a sphere.\\nThe sphere can be represented graphically, or in ASCII art, depending on the language capabilities.\\nEither static or rotational projection is acceptable for this task.\\n\\nTranslation from the C code at http://cairographics.org/samples/gradient\\nUses the Cairo component of GtkAda to create and save as png\\nThis uses a very loose binding to SDL as found in any GPS installation. For it to work, you must choose New Project From Templte|Empty Game\\n","MAKE OBJECT SPHERE 1,1"
"BASIC","Draw_a_sphere","Draw a sphere.\\nThe sphere can be represented graphically, or in ASCII art, depending on the language capabilities.\\nEither static or rotational projection is acceptable for this task.\\n\\nTranslation from the C code at http://cairographics.org/samples/gradient\\nUses the Cairo component of GtkAda to create and save as png\\nThis uses a very loose binding to SDL as found in any GPS installation. For it to work, you must choose New Project From Templte|Empty Game\\n","' \""\\\"" = a integer division (CPU) \\n' \""/\"" = a floating point division (FPU)\\n' the compiler takes care of the conversion between floating point and integer\\n' compile with: FBC -s console \""filename.bas\"" or FBC -s GUI \""filename.bas\""\\n' filename is whatever name you give it, .bas is mandatory\\n\\n' Sphere using XPL0 code from rosetacode sphere page\\n' Altered freebasic version to compile in default mode\\n' version 17-06-2015\\n' compile with: fbc -s console or fbc -s gui\\n#Define W 640\\n#Define H 480\\n\\nScreenRes W, H, 32   ' set 640x480x32 graphics mode, 32 bits color mode\\nWindowTitle \""32 bpp Cyan Sphere FreeBASIC\""\\n\\n' wait until keypress\\n' Color(RGB(255,255,255),RGB(0,0,0))         ' default white foreground, black background \\nLocate 50,2\\nPrint \""Enter any key to start\""\\nSleep\\n\\nDim As UInteger R = 100, R2 = R * R          ' radius, in pixels; radius squared\\nDim As UInteger X0 = W \\ 2, Y0 = H \\ 2       ' coordinates of center of screen\\nDim As Integer X, Y, C, D2                   ' coords, color, distance from center squared\\n   \\nFor Y = -R To R                              ' for all the coordinates near the circle\\n  For X = -R To R                            ' which is under the sphere\\n    D2 = X * X + Y * Y \\n    If D2 <= R2 Then                         ' coordinate is inside circle under sphere\\n                                             ' height of point on surface of sphere above X,Y\\n      C = Sqr(R2 - D2) - ( X + Y) / 2 + 130  ' color is proportional; offset X and Y, and\\n\\n      Color C Shl 8 + C                      ' = color RGB(0, C, C)\\n                                             ' green + blue = cyan\\n      PSet(X + X0, Y + Y0)\\n    End If\\n  Next \\nNext \\n\\n' wait until keypress\\nLocate 50,2\\nColor(RGB(255,255,255),RGB(0,0,0))           ' foreground color is changed\\n' empty keyboard buffer \\nWhile InKey <> \""\"" : Wend\\nPrint : Print \""hit any key to end program\""\\nSleep\\nEnd"
"BASIC","Draw_a_sphere","Draw a sphere.\\nThe sphere can be represented graphically, or in ASCII art, depending on the language capabilities.\\nEither static or rotational projection is acceptable for this task.\\n\\nTranslation from the C code at http://cairographics.org/samples/gradient\\nUses the Cairo component of GtkAda to create and save as png\\nThis uses a very loose binding to SDL as found in any GPS installation. For it to work, you must choose New Project From Templte|Empty Game\\n","'Sphere for FreeBASIC May 2015\\n'spherefb4.bas\\n'Sphere using XPL0 code from rosetacode sphere page\\n'\\nscreenres 640,480,32   '\\set 640x480x32 graphics mode\\nwindowtitle \""32 bpp Blue Sphere FreeBASIC\""\\n'\\n' wait until keypress\\nlocate 50,2\\ncolor(rgb(255,255,255),rgb(0,0,0)) \\nPrint \""Enter any key to start\"" \\nsleep\\n R=100 : R2=R*R	               '\\radius, in pixels; radius squared\\n X0=640/2 : Y0=480/2           '\\coordinates of center of screen\\n dim as integer X, Y, Z, C, D2 '\\coords, color, distance from center squared\\n'                             \\nfor Y= -R to +R                '\\for all the coordinates near the circle\\n    for X = -R to +R          '\\ which is under the sphere\\n        D2 = X*X + Y*Y        '\\n        C = 0                  '\\default color is black\\n        if D2 <= R2 then       '\\coordinate is inside circle under sphere\\n            Z = sqr(R2-D2)     '\\height of point on surface of sphere above X,Y\\n            C = Z-(X+Y)/2+130  ' \\color is proportional; offset X and Y, and\\n        endif\\n         color c                ' \\ shift color to upper limit of its range\\n                                '\\green + blue = cyan orginal line don't understand\\n         Pset(X+X0, Y+Y0)\\n    next x\\n  next y\\n' \\n' wait until keypress\\nlocate 50,2\\ncolor(rgb(255,255,255),rgb(0,0,0)) \\nPrint \""Enter any key to exit \"" \\nsleep\\nEND"
"BASIC","Draw_a_sphere","Draw a sphere.\\nThe sphere can be represented graphically, or in ASCII art, depending on the language capabilities.\\nEither static or rotational projection is acceptable for this task.\\n\\nTranslation from the C code at http://cairographics.org/samples/gradient\\nUses the Cairo component of GtkAda to create and save as png\\nThis uses a very loose binding to SDL as found in any GPS installation. For it to work, you must choose New Project From Templte|Empty Game\\n","\\nWindowWidth  =420\\nWindowHeight =460\\n\\nnomainwin\\n\\nopen \""Sphere\"" for graphics_nsb_nf as #w\\n\\n#w \""down ; fill lightgray\""\\n\\nxS =200\\nyS =200\\nfor radius =150 to 0 step -1\\n    level$ =str$( int( 256 -256 *radius /150))\\n    c$ =level$ +\"" \"" +level$ +\"" \"" +level$ \\n    #w \""color \"";     c$\\n    #w \""backcolor \""; c$\\n    #w \""place \""; xS; \"" \""; yS\\n    xS =xS -0.5\\n    yS =yS -0.2\\n    #w \""circlefilled \""; radius\\nnext radius\\n\\n#w \""flush\""\\nwait\\nclose #w\\nend\\n"
"BASIC","Draw_a_sphere","Draw a sphere.\\nThe sphere can be represented graphically, or in ASCII art, depending on the language capabilities.\\nEither static or rotational projection is acceptable for this task.\\n\\nTranslation from the C code at http://cairographics.org/samples/gradient\\nUses the Cairo component of GtkAda to create and save as png\\nThis uses a very loose binding to SDL as found in any GPS installation. For it to work, you must choose New Project From Templte|Empty Game\\n","; Original by Comtois @ 28/03/06\\n;\\n; Updated/Formated by Fluid Byte @ March.24,2009\\n;\\n; http://www.purebasic.fr/english/viewtopic.php?p=281258#p281258\\n\\nDeclare CreateSphere(M,P)\\nDeclare UpdateMesh()\\n\\n#_SIZEVERT = 36\\n#_SIZETRIS = 6\\n#FULLSCREEN = 0\\n\\nStructure VECTOR\\n  X.f\\n  Y.f\\n  Z.f\\nEndStructure\\n\\nStructure VERTEX\\n  X.f\\n  Y.f\\n  Z.f\\n  NX.f\\n  NY.f\\n  NZ.f\\n  Color.l\\n  U.f\\n  V.f\\nEndStructure\\n\\nStructure TRIANGLE\\n  V1.w\\n  V2.w\\n  V3.w\\nEndStructure\\n\\nMacro CALC_NORMALS\\n  *PtrV\\NX = *PtrV\\X\\n  *PtrV\\NY = *PtrV\\Y\\n  *PtrV\\NZ = *PtrV\\Z\\nEndMacro\\n\\nGlobal *VBuffer, *IBuffer\\nGlobal Meridian = 50, Parallele = 50, PasLength = 4, Length\\n\\nDefine EventID, i, NbSommet, CameraMode, Angle.f, Pas.f = 0.5\\n\\nInitEngine3D() : InitSprite() : InitKeyboard()\\n\\nAdd3DArchive(GetTemporaryDirectory(),#PB_3DArchive_FileSystem)\\nAdd3DArchive(#PB_Compiler_Home + \""Examples\\Sources\\Data\\\"",#PB_3DArchive_FileSystem)\\n\\nIf #FULLSCREEN\\n  OpenScreen(800,600,32,\""Sphere 3D\"")\\nElse\\n  OpenWindow(0,0,0,800,600,\""Sphere 3D\"",#PB_Window_SystemMenu | 1)\\n  OpenWindowedScreen(WindowID(0),0,0,800,600,0,0,0)\\nEndIf\\n\\n;-Texture\\nCreateImage(0,128,128)\\nStartDrawing(ImageOutput(0))\\nFor i = 0 To 127 Step 4\\n  Box(0,i,ImageWidth(0),2,RGB(255,255,255))\\n  Box(0,i + 2,ImageWidth(0),2,RGB(0,0,155))\\nNext i\\nStopDrawing()\\nSaveImage(0,GetTemporaryDirectory() + \""temp.bmp\"") : FreeImage(0)\\n\\n;-Material\\nCreateMaterial(0,LoadTexture(0,\""temp.bmp\""))\\nRotateMaterial(0,0.1,#PB_Material_Animated)\\n\\n;-Mesh\\nCreateSphere(Meridian,Parallele)\\n\\n;-Entity\\nCreateEntity(0,MeshID(0),MaterialID(0))\\nScaleEntity(0,60,60,60)\\n\\n;-Camera\\nCreateCamera(0,0,0,100,100)\\nMoveCamera(0,0,0,-200)\\nCameraLookAt(0,EntityX(0),EntityY(0),EntityZ(0))\\n\\n;-Light\\nAmbientColor(RGB(105, 105, 105))\\nCreateLight(0, RGB(255, 255,  55), EntityX(0) + 150, EntityY(0)      , EntityZ(0))\\nCreateLight(1, RGB( 55, 255, 255), EntityX(0) - 150, EntityY(0)      , EntityZ(0))\\nCreateLight(2, RGB( 55,  55, 255), EntityX(0)      , EntityY(0) + 150, EntityZ(0))\\nCreateLight(3, RGB(255,  55, 255), EntityX(0)      , EntityY(0) - 150, EntityZ(0))\\n\\n; ----------------------------------------------------------------------------------------------------\\n; MAINLOOP\\n; ----------------------------------------------------------------------------------------------------\\n\\nRepeat\\n  If #FULLSCREEN = 0\\n    Repeat\\n      EventID = WindowEvent()\\n      \\n      Select EventID\\n        Case #PB_Event_CloseWindow : End\\n      EndSelect\\n    Until EventID = 0\\n  EndIf\\n  \\n  Angle + Pas\\n  RotateEntity(0, Angle, Angle,Angle)\\n  \\n  If PasLength > 0 : UpdateMesh() : EndIf\\n  \\n  If ExamineKeyboard()\\n    If KeyboardReleased(#PB_Key_F1)\\n      CameraMode = 1 - CameraMode\\n      CameraRenderMode(0, CameraMode)\\n    EndIf\\n  EndIf\\n  \\n  RenderWorld()\\n  FlipBuffers()\\nUntil KeyboardPushed(#PB_Key_Escape)\\n\\n; ----------------------------------------------------------------------------------------------------\\n; FUNCTIONS\\n; ----------------------------------------------------------------------------------------------------\\n\\nProcedure CreateSphere(M,P)\\n  ; M = Meridian\\n  ; P = Parallele\\n  ; The radius is 1. Front to remove it later, it's just for the demo.\\n  \\n  If M < 3 Or P < 2  : ProcedureReturn 0 : EndIf\\n  \\n  Protected Normale.VECTOR, NbSommet, i, j, Theta.f, cTheta.f, sTheta.f\\n  Protected Alpha.f, cAlpha.f, sAlpha.f, *PtrV.VERTEX, *PtrF.TRIANGLE, NbTriangle\\n  \\n  NbSommet = 2 + ((M + 1) * P)\\n  *VBuffer = AllocateMemory(#_SIZEVERT * Nbsommet)\\n  \\n  For i = 0 To M\\n    Theta  = i * #PI * 2.0 / M\\n    cTheta = Cos(theta)\\n    sTheta = Sin(theta)\\n    \\n    For j = 1 To P\\n      Alpha  = j * #PI / (P + 1)\\n      cAlpha = Cos(Alpha)\\n      sAlpha = Sin(Alpha)\\n      *PtrV = *VBuffer + #_SIZEVERT * ((i * P) + (j - 1))\\n      *PtrV\\X = sAlpha * cTheta\\n      *PtrV\\Y = sAlpha * sTheta\\n      *PtrV\\Z = cAlpha\\n      *PtrV\\U  = Theta / (2.0 * #PI)\\n      *PtrV\\V  = Alpha / #PI\\n      CALC_NORMALS\\n    Next j\\n  Next i\\n  \\n  ; Southpole\\n  *PtrV = *VBuffer + #_SIZEVERT * ((M + 1) * P)   \\n  *PtrV\\X =  0\\n  *PtrV\\Y =  0   \\n  *PtrV\\Z = -1\\n  *PtrV\\U =  0\\n  *PtrV\\V =  0\\n  CALC_NORMALS\\n  \\n  ; Northpole\\n  *PtrV + #_SIZEVERT\\n  *PtrV\\X = 0\\n  *PtrV\\Y = 0   \\n  *PtrV\\Z = 1\\n  *PtrV\\U = 0\\n  *PtrV\\V = 0\\n  CALC_NORMALS\\n  \\n  ; Les facettes\\n  NbTriangle = 4 * M * P\\n  *IBuffer = AllocateMemory(#_SIZETRIS * NbTriangle)\\n  *PtrF = *IBuffer\\n  \\n  For i = 0 To M - 1\\n    For j = 1 To P - 1\\n      *PtrF\\V1 = ((i + 1) * P) + j\\n      *PtrF\\V2 = ((i + 1) * P) + (j - 1)\\n      *PtrF\\V3 = (i * P) + (j - 1)\\n      *PtrF + #_SIZETRIS\\n      *PtrF\\V3 = ((i + 1) * P) + j        ;Recto\\n      *PtrF\\V2 = ((i + 1) * P) + (j - 1)  ;Recto\\n      *PtrF\\V1 = (i * P) + (j - 1)        ;Recto\\n      *PtrF + #_SIZETRIS\\n      *PtrF\\V1 = i * P + j\\n      *PtrF\\V2 = ((i + 1) * P) + j\\n      *PtrF\\V3 = (i * P) + (j - 1)\\n      *PtrF + #_SIZETRIS\\n      *PtrF\\V3 = i * P + j               ;Recto\\n      *PtrF\\V2 = ((i + 1) * P) + j       ;Recto\\n      *PtrF\\V1 = (i * P) + (j - 1)       ;Recto\\n      *PtrF + #_SIZETRIS\\n    Next j     \\n  Next i\\n  \\n  ; The Poles\\n  For i = 0 To M - 1\\n    *PtrF\\V3 = (M + 1) * P + 1\\n    *PtrF\\V2 = (i + 1) * P\\n    *PtrF\\V1 = i * P\\n    *PtrF + #_SIZETRIS\\n    *PtrF\\V1 = (M + 1) * P + 1   ;Recto\\n    *PtrF\\V2 = (i + 1) * P       ;Recto\\n    *PtrF\\V3 = i * P             ;Recto\\n    *PtrF + #_SIZETRIS\\n  Next i     \\n  \\n  For i = 0 To M - 1\\n    *PtrF\\V3 = (M + 1) * P\\n    *PtrF\\V2 = i * P + (P - 1)\\n    *PtrF\\V1 = (i + 1) * P + (P - 1)\\n    *PtrF + #_SIZETRIS\\n    *PtrF\\V1 = (M + 1) * P              ;Recto\\n    *PtrF\\V2 = i * P + (P - 1)          ;Recto\\n    *PtrF\\V3 = (i + 1) * P + (P - 1)    ;Recto\\n    *PtrF + #_SIZETRIS \\n  Next i     \\n  \\n  If CreateMesh(0,100)\\n    Protected Flag = #PB_Mesh_Vertex | #PB_Mesh_Normal | #PB_Mesh_UVCoordinate | #PB_Mesh_Color\\n    SetMeshData(0,Flag,*VBuffer,NbSommet)\\n    SetMeshData(0,#PB_Mesh_Face,*IBuffer,NbTriangle)\\n    ProcedureReturn 1\\n  EndIf\\n  \\n  ProcedureReturn 0\\nEndProcedure   \\n\\n; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\\n\\nProcedure UpdateMesh()\\n  Protected NbTriangle = 4 * Meridian * Parallele\\n  \\n  Length + PasLength\\n  \\n  If Length >= NbTriangle\\n    PasLength = 0\\n    Length = Nbtriangle\\n  EndIf\\n  \\n  SetMeshData(0,#PB_Mesh_Face,*IBuffer,Length)\\nEndProcedure"
"BASIC","Draw_a_sphere","Draw a sphere.\\nThe sphere can be represented graphically, or in ASCII art, depending on the language capabilities.\\nEither static or rotational projection is acceptable for this task.\\n\\nTranslation from the C code at http://cairographics.org/samples/gradient\\nUses the Cairo component of GtkAda to create and save as png\\nThis uses a very loose binding to SDL as found in any GPS installation. For it to work, you must choose New Project From Templte|Empty Game\\n","SCREEN 13 ' enter high-color graphic mode\\n\\n' sets palette colors B/N\\nFOR i = 0 TO 255\\n PALETTE 255 - i, INT(i / 4) + INT(i / 4) * 256 + INT(i / 4) * 65536\\nNEXT i\\nPALETTE 0, 0\\n\\n' draw the sphere\\nFOR i = 255 TO 0 STEP -1\\n x = 50 + i / 3\\n y = 99\\n CIRCLE (x, y), i / 3, i\\n PAINT (x, y), i\\nNEXT i\\n\\n' wait until keypress\\nDO: LOOP WHILE INKEY$ = \""\""\\nEND"
"BASIC","Draw_a_sphere","Draw a sphere.\\nThe sphere can be represented graphically, or in ASCII art, depending on the language capabilities.\\nEither static or rotational projection is acceptable for this task.\\n\\nTranslation from the C code at http://cairographics.org/samples/gradient\\nUses the Cairo component of GtkAda to create and save as png\\nThis uses a very loose binding to SDL as found in any GPS installation. For it to work, you must choose New Project From Templte|Empty Game\\n","'Run BASIC White Sphere, Black background\\n'runbasic.com\\ngraphic #win, 300, 300\\n#win size(1)\\n R=100\\n R2=R*R\\n X0=300/2\\n Y0=300/2\\nfor Y = -150 to 150\\nfor X = -150 to 150\\n D2 = X*X + Y*Y\\n C = 0\\n if D2 <= R2 then Z = sqr(R2-D2) : C = int(Z-(X+Y)/2+130)\\n #win color(C,C,C)\\n #win set(X+X0, Y+Y0)\\nnext X\\nnext Y\\nrender #win"
"BASIC","Draw_a_sphere","Draw a sphere.\\nThe sphere can be represented graphically, or in ASCII art, depending on the language capabilities.\\nEither static or rotational projection is acceptable for this task.\\n\\nTranslation from the C code at http://cairographics.org/samples/gradient\\nUses the Cairo component of GtkAda to create and save as png\\nThis uses a very loose binding to SDL as found in any GPS installation. For it to work, you must choose New Project From Templte|Empty Game\\n","'This is a simple Circle\\ngraphic #g, 300, 300 	'create a graphic object\\n#g place(100,100) 	'place the drawing pen at 100,100\\n#g circle(75) 		'make a circle with radius 75\\nrender #g 		'show it"
"BASIC","Draw_a_sphere","Draw a sphere.\\nThe sphere can be represented graphically, or in ASCII art, depending on the language capabilities.\\nEither static or rotational projection is acceptable for this task.\\n\\nTranslation from the C code at http://cairographics.org/samples/gradient\\nUses the Cairo component of GtkAda to create and save as png\\nThis uses a very loose binding to SDL as found in any GPS installation. For it to work, you must choose New Project From Templte|Empty Game\\n","10 LET I=21\\n20 LET J=2\\n30 FOR K=-PI TO PI STEP 0.07\\n40 PLOT 21+I*SIN K,22+21*COS K\\n50 PLOT 21+21*SIN K,22+(I-1)*COS K\\n60 NEXT K\\n70 LET I=I-J\\n80 LET J=J+1\\n90 IF I>0 THEN GOTO 30"
"BASIC","Dynamic_variable_names","Create a variable with a user-defined name.\\nThe variable name should not be written in the program text, but should be taken from the user dynamically.\\n\\n\\nNot exactly a variable, but ExpandoObject allows adding properties at runtime.\\n","10 INPUT \""Enter a variable name\"", v$\\n20 KEYIN \""LET \""+v$+\""=42\"""
"C","15_Puzzle_Game","\\nImplement the Fifteen Puzzle Game.\\n\\nThe   15-puzzle   is also known as:\\n\\n\\nWe fist define a generic package Generic_Puzzle. Upon instantiation, it can take any number of rows, any number of columns for a rows*columns-1 game. Instead of plain numbers, the tiles on the board can have arbitrary names (but they should all be of the same length). The package user can request the name for the tile at a certain (row,column)-point, and the set of possible moves. The user can move the empty space up, down, left and right (if possible). If the user makes the attempt to perform an impossible move, a Constraint_Error is raised.\\nThe package implementation is as follows.\\nThe main program reads the level from the command line. A larger level implies a more difficult instance. The default level is 10, which is fairly simple. After randomizing the board, the user can move the tiles.\\n","/* RosettaCode: Fifteen puzle game, C89, plain vanillia TTY, MVC, § 22 */\\n#define _CRT_SECURE_NO_WARNINGS\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#define N 4\\n#define M 4\\nenum Move{UP,DOWN,LEFT,RIGHT};int hR;int hC;int cc[N][M];const int nS=100;int\\nupdate(enum Move m){const int dx[]={0,0,-1,1};const int dy[]={-1,1,0,0};int i=hR\\n+dy[m];int j=hC+dx[m];if(i>= 0&&i=0&&j\\n\\n===C89, short version, TTY mode===\\n/*\\n * RosettaCode: Fifteen puzle game, C89, plain vanillia TTY, MVC\\n */\\n\\n#define _CRT_SECURE_NO_WARNINGS /* unlocks printf etc. in MSVC */\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nenum Move { MOVE_UP = 0, MOVE_DOWN = 1, MOVE_LEFT = 2, MOVE_RIGHT = 3 };\\n\\n/* *****************************************************************************\\n * Model\\n */\\n\\n#define NROWS     4\\n#define NCOLLUMNS 4\\nint holeRow;       \\nint holeCollumn;   \\nint cells[NROWS][NCOLLUMNS];\\nconst int nShuffles = 100;\\n\\nint Game_update(enum Move move){\\n    const int dx[] = {  0,  0, -1, +1 };\\n    const int dy[] = { -1, +1,  0,  0 };\\n    int i = holeRow     + dy[move];\\n    int j = holeCollumn + dx[move];    \\n    if ( i >= 0 && i < NROWS && j >= 0 && j < NCOLLUMNS ){\\n        cells[holeRow][holeCollumn] = cells[i][j];\\n        cells[i][j] = 0; holeRow = i; holeCollumn = j;\\n        return 1;\\n    }\\n    return 0;\\n}\\n\\nvoid Game_setup(void){\\n    int i,j,k;\\n    for ( i = 0; i < NROWS; i++ )\\n        for ( j = 0; j < NCOLLUMNS; j++ )\\n            cells[i][j] = i * NCOLLUMNS + j + 1;\\n    cells[NROWS-1][NCOLLUMNS-1] = 0;\\n    holeRow = NROWS - 1;\\n    holeCollumn = NCOLLUMNS - 1;\\n    k = 0;\\n    while ( k < nShuffles )\\n        k += Game_update((enum Move)(rand() % 4));\\n}\\n\\nint Game_isFinished(void){\\n    int i,j; int k = 1;\\n    for ( i = 0; i < NROWS; i++ )\\n        for ( j = 0; j < NCOLLUMNS; j++ ) \\n            if ( (k < NROWS*NCOLLUMNS) && (cells[i][j] != k++ ) )\\n                return 0;\\n    return 1;        \\n}\\n\\n\\n/* *****************************************************************************\\n * View \\n */\\n\\nvoid View_showBoard(){\\n    int i,j;\\n    putchar('\\n');\\n    for ( i = 0; i < NROWS; i++ )\\n        for ( j = 0; j < NCOLLUMNS; j++ ){\\n            if ( cells[i][j] )\\n                printf(j != NCOLLUMNS-1 ? \"" %2d \"" : \"" %2d \\n\"", cells[i][j]);\\n            else\\n                printf(j != NCOLLUMNS-1 ? \"" %2s \"" : \"" %2s \\n\"", \""\"");\\n        }\\n    putchar('\\n');\\n}\\n\\nvoid View_displayMessage(char* text){\\n    printf(\""\\n%s\\n\"", text);\\n}\\n\\n\\n/* *****************************************************************************\\n * Controller\\n */\\n\\nenum Move Controller_getMove(void){\\n    int c;\\n    for(;;){\\n        printf(\""%s\"", \""enter u/d/l/r : \"");\\n        c = getchar();\\n        while( getchar() != '\\n' )\\n            ;\\n        switch ( c ){\\n            case 27: exit(EXIT_SUCCESS);\\n            case 'd' : return MOVE_UP;   \\n            case 'u' : return MOVE_DOWN;\\n            case 'r' : return MOVE_LEFT;\\n            case 'l' : return MOVE_RIGHT;\\n        }\\n    }\\n}\\n\\nvoid Controller_pause(void){\\n    getchar();\\n}\\n\\nint main(void){\\n\\n    srand((unsigned)time(NULL));\\n\\n    do Game_setup(); while ( Game_isFinished() );\\n\\n    View_showBoard();\\n    while( !Game_isFinished() ){ \\n        Game_update( Controller_getMove() ); \\n        View_showBoard(); \\n    }\\n\\n    View_displayMessage(\""You win\"");\\n    Controller_pause();\\n\\n    return EXIT_SUCCESS;\\n}\\n\\n\\n{{Out}}\\n<pre>\\n  9   1   4   7\\n  6   5   3   2\\n 13  10       8\\n 14  15  11  12\\n\\nenter u/d/l/r : u\\n\\n  9   1   4   7\\n  6   5   3   2\\n 13  10  11   8\\n 14  15      12\\n\\nenter u/d/l/r : l\\n\\n  9   1   4   7\\n  6   5   3   2\\n 13  10  11   8\\n 14  15  12\\n\\nenter u/d/l/r : d\\n\\n  9   1   4   7\\n  6   5   3   2\\n 13  10  11\\n 14  15  12   8\\n\\nenter u/d/l/r :"
"C","15_Puzzle_Game","\\nImplement the Fifteen Puzzle Game.\\n\\nThe   15-puzzle   is also known as:\\n\\n\\nWe fist define a generic package Generic_Puzzle. Upon instantiation, it can take any number of rows, any number of columns for a rows*columns-1 game. Instead of plain numbers, the tiles on the board can have arbitrary names (but they should all be of the same length). The package user can request the name for the tile at a certain (row,column)-point, and the set of possible moves. The user can move the empty space up, down, left and right (if possible). If the user makes the attempt to perform an impossible move, a Constraint_Error is raised.\\nThe package implementation is as follows.\\nThe main program reads the level from the command line. A larger level implies a more difficult instance. The default level is 10, which is fairly simple. After randomizing the board, the user can move the tiles.\\n","/*\\n * RosettaCode: Fifteen puzle game, C89, plain vanillia TTY, MVC\\n */\\n\\n#define _CRT_SECURE_NO_WARNINGS /* unlocks printf etc. in MSVC */\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nenum Move { MOVE_UP = 0, MOVE_DOWN = 1, MOVE_LEFT = 2, MOVE_RIGHT = 3 };\\n\\n/* *****************************************************************************\\n * Model\\n */\\n\\n#define NROWS     4\\n#define NCOLLUMNS 4\\nint holeRow;       \\nint holeCollumn;   \\nint cells[NROWS][NCOLLUMNS];\\nconst int nShuffles = 100;\\n\\nint Game_update(enum Move move){\\n    const int dx[] = {  0,  0, -1, +1 };\\n    const int dy[] = { -1, +1,  0,  0 };\\n    int i = holeRow     + dy[move];\\n    int j = holeCollumn + dx[move];    \\n    if ( i >= 0 && i < NROWS && j >= 0 && j < NCOLLUMNS ){\\n        cells[holeRow][holeCollumn] = cells[i][j];\\n        cells[i][j] = 0; holeRow = i; holeCollumn = j;\\n        return 1;\\n    }\\n    return 0;\\n}\\n\\nvoid Game_setup(void){\\n    int i,j,k;\\n    for ( i = 0; i < NROWS; i++ )\\n        for ( j = 0; j < NCOLLUMNS; j++ )\\n            cells[i][j] = i * NCOLLUMNS + j + 1;\\n    cells[NROWS-1][NCOLLUMNS-1] = 0;\\n    holeRow = NROWS - 1;\\n    holeCollumn = NCOLLUMNS - 1;\\n    k = 0;\\n    while ( k < nShuffles )\\n        k += Game_update((enum Move)(rand() % 4));\\n}\\n\\nint Game_isFinished(void){\\n    int i,j; int k = 1;\\n    for ( i = 0; i < NROWS; i++ )\\n        for ( j = 0; j < NCOLLUMNS; j++ ) \\n            if ( (k < NROWS*NCOLLUMNS) && (cells[i][j] != k++ ) )\\n                return 0;\\n    return 1;        \\n}\\n\\n\\n/* *****************************************************************************\\n * View \\n */\\n\\nvoid View_showBoard(){\\n    int i,j;\\n    putchar('\\n');\\n    for ( i = 0; i < NROWS; i++ )\\n        for ( j = 0; j < NCOLLUMNS; j++ ){\\n            if ( cells[i][j] )\\n                printf(j != NCOLLUMNS-1 ? \"" %2d \"" : \"" %2d \\n\"", cells[i][j]);\\n            else\\n                printf(j != NCOLLUMNS-1 ? \"" %2s \"" : \"" %2s \\n\"", \""\"");\\n        }\\n    putchar('\\n');\\n}\\n\\nvoid View_displayMessage(char* text){\\n    printf(\""\\n%s\\n\"", text);\\n}\\n\\n\\n/* *****************************************************************************\\n * Controller\\n */\\n\\nenum Move Controller_getMove(void){\\n    int c;\\n    for(;;){\\n        printf(\""%s\"", \""enter u/d/l/r : \"");\\n        c = getchar();\\n        while( getchar() != '\\n' )\\n            ;\\n        switch ( c ){\\n            case 27: exit(EXIT_SUCCESS);\\n            case 'd' : return MOVE_UP;   \\n            case 'u' : return MOVE_DOWN;\\n            case 'r' : return MOVE_LEFT;\\n            case 'l' : return MOVE_RIGHT;\\n        }\\n    }\\n}\\n\\nvoid Controller_pause(void){\\n    getchar();\\n}\\n\\nint main(void){\\n\\n    srand((unsigned)time(NULL));\\n\\n    do Game_setup(); while ( Game_isFinished() );\\n\\n    View_showBoard();\\n    while( !Game_isFinished() ){ \\n        Game_update( Controller_getMove() ); \\n        View_showBoard(); \\n    }\\n\\n    View_displayMessage(\""You win\"");\\n    Controller_pause();\\n\\n    return EXIT_SUCCESS;\\n}\\n\\n"
"C","15_Puzzle_Game","\\nImplement the Fifteen Puzzle Game.\\n\\nThe   15-puzzle   is also known as:\\n\\n\\nWe fist define a generic package Generic_Puzzle. Upon instantiation, it can take any number of rows, any number of columns for a rows*columns-1 game. Instead of plain numbers, the tiles on the board can have arbitrary names (but they should all be of the same length). The package user can request the name for the tile at a certain (row,column)-point, and the set of possible moves. The user can move the empty space up, down, left and right (if possible). If the user makes the attempt to perform an impossible move, a Constraint_Error is raised.\\nThe package implementation is as follows.\\nThe main program reads the level from the command line. A larger level implies a more difficult instance. The default level is 10, which is fairly simple. After randomizing the board, the user can move the tiles.\\n","/**\\n * RosettaCode: Fifteen puzle game, C89, MS Windows Console API, MVC\\n *\\n * @version 0.2 (added TTY and ncurses modes)\\n */\\n\\n#define UNDEFINED_WIN32API_CONSOLE\\n#define UNDEFINED_NCURSES_CONSOLE\\n#if !defined (TTY_CONSOLE) && !defined(WIN32API_CONSOLE) && !defined(NCURSES_CONSOLE)\\n#define TTY_CONSOLE\\n#endif\\n\\n#define _CRT_SECURE_NO_WARNINGS    /* enable printf etc. */\\n#define _CRT_NONSTDC_NO_DEPRECATE  /* POSIX functions enabled */\\n\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include <time.h>\\n#if defined(NCURSES_CONSOLE)\\n#include \""curses.h\""  /* see http://pdcurses.sourceforge.net/ */\\n#elif defined(WIN32API_CONSOLE)\\n#define NOGDI                   /* we don't need GDI */\\n#define WIN32_LEAN_AND_MEAN     /* we don't need OLE etc. */\\n#include <windows.h>            /* MS Windows stuff */\\n#include <conio.h>              /* kbhit() and getch() */\\n#endif\\n\\nenum Move { MOVE_UP = 0, MOVE_DOWN = 1, MOVE_LEFT = 2, MOVE_RIGHT = 3 };\\n\\n/* *****************************************************************************\\n * Model\\n */\\n\\n#define NROWS     4\\n#define NCOLLUMNS 4\\nint holeRow;       \\nint holeCollumn;   \\nint cells[NROWS][NCOLLUMNS];\\nconst int nShuffles = 100;\\n\\nint Game_update(enum Move move){\\n    const int dx[] = {  0,  0, -1, +1 };\\n    const int dy[] = { -1, +1,  0,  0 };\\n    int i = holeRow     + dy[move];\\n    int j = holeCollumn + dx[move];    \\n    if ( i >= 0 && i < NROWS && j >= 0 && j < NCOLLUMNS ){\\n        cells[holeRow][holeCollumn] = cells[i][j];\\n        cells[i][j] = 0; holeRow = i; holeCollumn = j;\\n        return 1;\\n    }\\n    return 0;\\n}\\n\\nvoid Game_setup(void){\\n    int i,j,k;\\n    for ( i = 0; i < NROWS; i++ )\\n        for ( j = 0; j < NCOLLUMNS; j++ )\\n            cells[i][j] = i * NCOLLUMNS + j + 1;\\n    cells[NROWS-1][NCOLLUMNS-1] = 0;\\n    holeRow = NROWS - 1;\\n    holeCollumn = NCOLLUMNS - 1;\\n    k = 0;\\n    while ( k < nShuffles )\\n        k += Game_update((enum Move)(rand() % 4));\\n}\\n\\nint Game_isFinished(void){\\n    int i,j; int k = 1;\\n    for ( i = 0; i < NROWS; i++ )\\n        for ( j = 0; j < NCOLLUMNS; j++ ) \\n            if ( (k < NROWS*NCOLLUMNS) && (cells[i][j] != k++ ) )\\n                return 0;\\n    return 1;        \\n}\\n\\n\\n/* *****************************************************************************\\n * View \\n */\\n\\nint fieldWidth;\\n#ifdef WIN32API_CONSOLE\\nHANDLE hConsole;\\nCONSOLE_SCREEN_BUFFER_INFO csbi; \\n#endif\\n\\nvoid View_setup_base(void)\\n{\\n    int i;\\n    fieldWidth = 0;\\n    for ( i = NROWS * NCOLLUMNS - 1; i > 0; i /= 10 )\\n        fieldWidth++;\\n}\\n\\n#if defined(TTY_CONSOLE)\\n\\nvoid View_setup(void) {\\n    View_setup_base();\\n}\\n\\nvoid View_showBoard()\\n{\\n    int i,j;\\n    putchar('\\n');\\n    for ( i = 0; i < NROWS; i++ )\\n        for ( j = 0; j < NCOLLUMNS; j++ ){\\n            if ( cells[i][j] )\\n                printf(j != NCOLLUMNS-1 ? \"" %*d \"" : \"" %*d \\n\"", fieldWidth, cells[i][j]);\\n            else\\n                printf(j != NCOLLUMNS-1 ? \"" %*s \"" : \"" %*s \\n\"", fieldWidth, \""\"");\\n        }\\n    putchar('\\n');\\n}\\n\\nvoid View_displayMessage(char* text)\\n{\\n    printf(\""\\n%s\\n\"", text);\\n}\\n\\n#elif defined(NCURSES_CONSOLE)\\n\\nvoid View_setup(void) {\\n    View_setup_base();\\n    initscr();        \\n    clear();\\n}\\n\\nvoid View_showBoard()\\n{\\n    int i,j;\\n    for ( i = 0; i < NROWS; i++ )\\n        for ( j = 0; j < NCOLLUMNS; j++ ){\\n            int x = (fieldWidth+1)*j;\\n            int y = 2*i;\\n            if ( cells[i][j] ){\\n                attron(A_REVERSE);\\n                mvprintw(y,x,\""%*d\"", fieldWidth, cells[i][j]);\\n            }else{\\n                attroff(A_REVERSE);\\n                mvprintw(y,x,\""%*s\"", fieldWidth, \"" \"");\\n            }\\n        }\\n    attrset(A_NORMAL);\\n}\\n\\nvoid View_displayMessage(char* text)\\n{\\n    mvprintw(2*NROWS,0, \""%s\"", text);\\n}\\n\\n#elif defined(WIN32API_CONSOLE)\\n\\nvoid View_setup(void) {\\n    const COORD coordHome = { 0, 0 }; \\n    CONSOLE_CURSOR_INFO cci;\\n    DWORD size, nWritten;\\n    View_setup_base();\\n    hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\\n    cci.bVisible = FALSE; \\n    cci.dwSize = 1;\\n    SetConsoleCursorInfo(hConsole,&cci);    \\n    GetConsoleScreenBufferInfo(hConsole,&(csbi));\\n    size = csbi.dwSize.X*csbi.dwSize.Y;\\n    FillConsoleOutputCharacter(hConsole,' ',size,coordHome,&nWritten);\\n    FillConsoleOutputAttribute(hConsole,csbi.wAttributes,size,coordHome,&nWritten);\\n\\n}\\n\\nvoid View_showBoard()\\n{\\n    int i,j;\\n    char labelString[32];\\n    WORD attributes;\\n    DWORD nWritten;\\n    for ( i = 0; i < NROWS; i++ )\\n        for ( j = 0; j < NCOLLUMNS; j++ ){\\n            COORD coord = { ((SHORT)fieldWidth+1)*j, coord.Y = 2*i };\\n            if ( cells[i][j] ){\\n                sprintf(labelString,\""%*d\"", fieldWidth, cells[i][j]);                \\n                attributes = BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED;\\n            }else{\\n                sprintf(labelString,\""%*s\"", fieldWidth, \"" \"");\\n                attributes = csbi.wAttributes;\\n            }\\n            WriteConsoleOutputCharacter(hConsole,labelString,fieldWidth,coord,&nWritten);\\n            FillConsoleOutputAttribute (hConsole,attributes,fieldWidth,coord,&nWritten);\\n        }\\n}\\n\\nvoid View_displayMessage(char* text)\\n{\\n    DWORD nWritten;\\n    COORD coord = { 0, 2 * NROWS };\\n    WriteConsoleOutputCharacter(hConsole,text,strlen(text),coord,&nWritten);\\n}\\n\\n#endif\\n\\n\\n/* *****************************************************************************\\n * Controller\\n */\\n\\n#if defined(TTY_CONSOLE)\\n\\nvoid Controller_setup(void){\\n}\\n\\nenum Move Controller_getMove(void){\\n    int c;\\n    for(;;){\\n        printf(\""%s\"", \""enter u/d/l/r : \"");\\n        c = getchar();\\n        while( getchar() != '\\n' )\\n            ;\\n        switch ( c ){\\n            case 27: exit(EXIT_SUCCESS);\\n            case 'd' : return MOVE_UP;   \\n            case 'u' : return MOVE_DOWN;\\n            case 'r' : return MOVE_LEFT;\\n            case 'l' : return MOVE_RIGHT;\\n        }\\n    }\\n}\\n\\nvoid Controller_pause(void)\\n{\\n    getchar();\\n}\\n\\n#elif defined(NCURSES_CONSOLE)\\n\\nvoid Controller_setup(void){\\n    noecho();\\n    cbreak();\\n    curs_set(0);\\n    keypad(stdscr,TRUE);\\n}\\n\\nenum Move Controller_getMove(void){\\n    for(;;){\\n        switch ( wgetch(stdscr) ){\\n            case  27: exit(EXIT_SUCCESS);\\n            case KEY_DOWN  : return MOVE_UP;   \\n            case KEY_UP    : return MOVE_DOWN;\\n            case KEY_RIGHT : return MOVE_LEFT;\\n            case KEY_LEFT  : return MOVE_RIGHT;\\n            case ERR: /* NOP */;\\n        }\\n    }\\n}\\n\\nvoid Controller_pause(void){\\n    while ( wgetch(stdscr) == ERR )\\n        ;\\n}\\n\\n\\n#elif defined(WIN32API_CONSOLE)\\n\\nvoid Controller_setup(void){\\n}\\n\\nenum Move Controller_getMove(void){\\n    for(;;){\\n        switch ( getch() ){\\n            case  27: exit(EXIT_SUCCESS);\\n            case   0:\\n            case 224: switch ( getch() ){\\n                case 80 : return MOVE_UP;   \\n                case 72 : return MOVE_DOWN;\\n                case 77 : return MOVE_LEFT;\\n                case 75 : return MOVE_RIGHT;\\n            }\\n        }\\n    }\\n}\\n\\nvoid Controller_pause(void){\\n    while(  kbhit() ) getch();\\n    while( !kbhit() )   ;\\n    while(  kbhit() ) getch();\\n}\\n\\n#endif\\n\\n\\n/* *****************************************************************************\\n * Main function: create model, view and controller. Run main loop.\\n */\\nint main(void) {\\n\\n    srand((unsigned)time(NULL));\\n\\n    do Game_setup(); while ( Game_isFinished() );\\n    View_setup(); \\n    Controller_setup();\\n\\n    View_showBoard();\\n    while( !Game_isFinished() ){ \\n        Game_update( Controller_getMove() ); \\n        View_showBoard(); \\n    }\\n\\n    View_displayMessage(\""You win\"");\\n    Controller_pause();\\n\\n    return EXIT_SUCCESS;\\n}\\n"
"C","2048","Implement a 2D sliding block puzzle game where blocks with numbers are combined to add their values.\\nThe rules are that on each turn the player must choose a direction (up, down, left or right) and all tiles move as far as possible in that direction, some more than others. Two adjacent tiles (in that direction only) with matching numbers combine into one bearing the sum of those numbers. A move is valid when at least one tile can be moved, if only by combination. A new tile with the value of 2 is spawned at the end of each turn at a randomly chosen empty square, if there is one. To win the player must create a tile with the number 2048. The player loses if no valid moves are possible.\\nThe name comes from the popular open-source implementation of this game mechanic, 2048.\\nRequirements:\\nto the right should result in\\nand not\\nto the right should result in\\nand not\\n\\n","\\n#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include <termios.h>\\n#include <time.h>\\n#include <unistd.h>\\n\\n#define D_INVALID -1\\n#define D_UP       1\\n#define D_DOWN     2\\n#define D_RIGHT    3\\n#define D_LEFT     4\\n\\nconst long values[] = {\\n    0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048\\n};\\n\\nconst char *colors[] = {\\n    \""39\"", \""31\"", \""32\"", \""33\"", \""34\"", \""35\"", \""36\"", \""37\"", \""91\"", \""92\"", \""93\"", \""94\""\\n};\\n\\nstruct gamestate_struct__ {\\n    int grid[4][4];\\n    int have_moved;\\n    long total_score;\\n    long score_last_move;\\n    int blocks_in_play;\\n} game;\\n\\nstruct termios oldt, newt;\\n\\nvoid do_draw(void)\\n{\\n    printf(\""\\033[2J\\033[HScore: %ld\"", game.total_score);\\n    if (game.score_last_move)\\n        printf(\"" (+%ld)\"", game.score_last_move);\\n    printf(\""\\n\"");\\n\\n    for (int i = 0; i < 25; ++i)\\n        printf(\""-\"");\\n    printf(\""\\n\"");\\n\\n    for (int y = 0; y < 4; ++y) {\\n        printf(\""|\"");\\n        for (int x = 0; x < 4; ++x) {\\n            if (game.grid[x][y])\\n                printf(\""\\033[7m\\033[%sm%*zd \\033[0m|\"", colors[game.grid[x][y]],\\n                        4, values[game.grid[x][y]]);\\n            else\\n                printf(\""%*s |\"", 4, \""\"");\\n        }\\n        printf(\""\\n\"");\\n    }\\n\\n    for (int i = 0; i < 25; ++i) {\\n        printf(\""-\"");\\n    }\\n    printf(\""\\n\"");\\n}\\n\\nvoid do_merge(int d)\\n{\\n/* These macros look pretty scary, but mainly demonstrate some space saving */\\n#define MERGE_DIRECTION(_v1, _v2, _xs, _xc, _xi, _ys, _yc, _yi, _x, _y)     \\\\n    do {                                                                    \\\\n        for (int _v1 = _xs; _v1 _xc; _v1 += _xi) {                          \\\\n            for (int _v2 = _ys; _v2 _yc; _v2 += _yi) {                      \\\\n                if (game.grid[x][y] && (game.grid[x][y] ==                  \\\\n                                    game.grid[x + _x][y + _y])) {           \\\\n                    game.grid[x][y] += (game.have_moved = 1);               \\\\n                    game.grid[x + _x][y + _y] = (0 * game.blocks_in_play--);\\\\n                    game.score_last_move += values[game.grid[x][y]];        \\\\n                    game.total_score += values[game.grid[x][y]];            \\\\n                }                                                           \\\\n            }                                                               \\\\n        }                                                                   \\\\n    } while (0)\\n\\n    game.score_last_move = 0;\\n\\n    switch (d) {\\n        case D_LEFT:\\n            MERGE_DIRECTION(x, y, 0, < 3, 1, 0, < 4, 1, 1, 0);\\n            break;\\n        case D_RIGHT:\\n            MERGE_DIRECTION(x, y, 3, > 0, -1, 0, < 4, 1, -1, 0);\\n            break;\\n        case D_DOWN:\\n            MERGE_DIRECTION(y, x, 3, > 0, -1, 0, < 4, 1, 0, -1);\\n            break;\\n        case D_UP:\\n            MERGE_DIRECTION(y, x, 0, < 3, 1, 0, < 4, 1, 0, 1);\\n            break;\\n    }\\n\\n#undef MERGE_DIRECTION\\n}\\n\\nvoid do_gravity(int d)\\n{\\n#define GRAVITATE_DIRECTION(_v1, _v2, _xs, _xc, _xi, _ys, _yc, _yi, _x, _y) \\\\n    do {                                                                    \\\\n        int break_cond = 0;                                                 \\\\n        while (!break_cond) {                                               \\\\n            break_cond = 1;                                                 \\\\n            for (int _v1 = _xs; _v1 _xc; _v1 += _xi) {                      \\\\n                for (int _v2 = _ys; _v2 _yc; _v2 += _yi) {                  \\\\n                    if (!game.grid[x][y] && game.grid[x + _x][y + _y]) {    \\\\n                        game.grid[x][y] = game.grid[x + _x][y + _y];        \\\\n                        game.grid[x + _x][y + _y] = break_cond = 0;         \\\\n                        game.have_moved = 1;                                \\\\n                    }                                                       \\\\n                }                                                           \\\\n            }                                                               \\\\n            do_draw(); usleep(40000);                                       \\\\n        }                                                                   \\\\n    } while (0)\\n\\n    switch (d) {\\n        case D_LEFT:\\n            GRAVITATE_DIRECTION(x, y, 0, < 3, 1, 0, < 4, 1, 1, 0);\\n            break;\\n        case D_RIGHT:\\n            GRAVITATE_DIRECTION(x, y, 3, > 0, -1, 0, < 4, 1, -1, 0);\\n            break;\\n        case D_DOWN:\\n            GRAVITATE_DIRECTION(y, x, 3, > 0, -1, 0, < 4, 1, 0, -1);\\n            break;\\n        case D_UP:\\n            GRAVITATE_DIRECTION(y, x, 0, < 3, 1, 0, < 4, 1, 0, 1);\\n            break;\\n    }\\n\\n#undef GRAVITATE_DIRECTION\\n}\\n\\nint do_check_end_condition(void)\\n{\\n    int ret = -1;\\n    for (int x = 0; x < 4; ++x) {\\n        for (int y = 0; y < 4; ++y) {\\n            if (values[game.grid[x][y]] == 2048)\\n                return 1;\\n            if (!game.grid[x][y] ||\\n                  ((x + 1 < 4) && (game.grid[x][y] == game.grid[x + 1][y])) ||\\n                  ((y + 1 < 4) && (game.grid[x][y] == game.grid[x][y + 1])))\\n                ret = 0;\\n        }\\n    }\\n    return ret;\\n}\\n\\nint do_tick(int d)\\n{\\n    game.have_moved = 0;\\n    do_gravity(d);\\n    do_merge(d);\\n    do_gravity(d);\\n    return game.have_moved;\\n}\\n\\nvoid do_newblock(void) {\\n    if (game.blocks_in_play >= 16) return;\\n\\n    int bn = rand() % (16 - game.blocks_in_play);\\n    int pn = 0;\\n\\n    for (int x = 0; x < 4; ++x) {\\n        for (int y = 0; y < 4; ++y) {\\n            if (game.grid[x][y])\\n                continue;\\n\\n            if (pn == bn){\\n                game.grid[x][y] = rand() % 10 ? 1 : 2;\\n                game.blocks_in_play += 1;\\n                return;\\n            }\\n            else {\\n                ++pn;\\n            }\\n        }\\n    }\\n}\\n\\nint main(void)\\n{\\n    /* Initialize terminal settings */\\n    tcgetattr(STDIN_FILENO, &oldt);\\n    newt = oldt;\\n    newt.c_lflag &= ~(ICANON | ECHO);\\n    tcsetattr(STDIN_FILENO, TCSANOW, &newt);\\n\\n    srand(time(NULL));\\n    memset(&game, sizeof(game), 0);\\n    do_newblock();\\n    do_newblock();\\n    do_draw();\\n\\n    while (1) {\\n        int found_valid_key, direction, value;\\n        do {\\n            found_valid_key = 1;\\n            direction       = D_INVALID;\\n            value           = getchar();\\n            switch (value) {\\n                case 'h': case 'a':\\n                    direction = D_LEFT;\\n                    break;\\n                case 'l': case 'd':\\n                    direction = D_RIGHT;\\n                    break;\\n                case 'j': case 's':\\n                    direction = D_DOWN;\\n                    break;\\n                case 'k': case 'w':\\n                    direction = D_UP;\\n                    break;\\n                case 'q':\\n                    goto game_quit;\\n                    break;\\n                case 27:\\n                    if (getchar() == 91) {\\n                        value = getchar();\\n                        switch (value) {\\n                            case 65:\\n                                direction = D_UP;\\n                                break;\\n                            case 66:\\n                                direction = D_DOWN;\\n                                break;\\n                            case 67:\\n                                direction = D_RIGHT;\\n                                break;\\n                            case 68:\\n                                direction = D_LEFT;\\n                                break;\\n                            default:\\n                                found_valid_key = 0;\\n                                break;\\n                        }\\n                    }\\n                    break;\\n                default:\\n                    found_valid_key = 0;\\n                    break;\\n            }\\n        }  while (!found_valid_key);\\n\\n        do_tick(direction);\\n        if (game.have_moved != 0){\\n                do_newblock();\\n        }\\n        do_draw();\\n\\n        switch (do_check_end_condition()) {\\n            case -1:\\n                goto game_lose;\\n            case 1:\\n                goto game_win;\\n            case 0:\\n                break;\\n        }\\n    }\\n\\n    if (0)\\ngame_lose:\\n    printf(\""You lose!\\n\"");\\n    goto game_quit;\\n    if (0)\\ngame_win:\\n    printf(\""You win!\\n\"");\\n    goto game_quit;\\n    if (0)\\ngame_quit:\\n\\n    /* Restore terminal settings */\\n    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);\\n    return 0;\\n}\\n"
"C","2048","Implement a 2D sliding block puzzle game where blocks with numbers are combined to add their values.\\nThe rules are that on each turn the player must choose a direction (up, down, left or right) and all tiles move as far as possible in that direction, some more than others. Two adjacent tiles (in that direction only) with matching numbers combine into one bearing the sum of those numbers. A move is valid when at least one tile can be moved, if only by combination. A new tile with the value of 2 is spawned at the end of each turn at a randomly chosen empty square, if there is one. To win the player must create a tile with the number 2048. The player loses if no valid moves are possible.\\nThe name comes from the popular open-source implementation of this game mechanic, 2048.\\nRequirements:\\nto the right should result in\\nand not\\nto the right should result in\\nand not\\n\\n","\\n\\n#include <stdio.h>\\n#include <string.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#define EMPTY_TILE 0\\n#define ROWS 4\\n#define COLUMNS 4\\n\\n\\n/* \\n *                                     GENERAL CONCEPT\\n * \\n * How do you add up tiles when there is whitespace between them?\\n * You sort the array so that there are no empty tiles between them while stacking them all to one side\\n * then the addition function always adds up from left to right or up to bottom. It does not care\\n * about the left movements or the down movement. This can be achieved by reversing the array\\n * whenever the player chooses to move to the right or down, when the addition is finished\\n * the array gets reversed back and its like it had been added from right to left or bottom to top\\n * When the addition is done, the program scans for the number of empty tiles and uses that\\n * in its selection of the next tile to be filled. 10% of times a tile gets occupied with a 4\\n *\\n*/\\n\\n\\n\\n/* \\n * the remove_whitespace functions; it is pretty clear what they do.\\n * they use a bubble short algorith to move the 0's or empty tiles to the end of the array\\n * depending on the direction moved (without carring about going right or up\\n *\\n*/\\n\\nvoid remove_whitespace_horizontaly(int board[ROWS][COLUMNS], int rows, int columns)\\n{\\n  int a = columns;\\n  int tmp;\\n\\n  \\n  for (; a < COLUMNS - 1; ++a) {\\n    tmp = board[rows][a];\\n    board[rows][a] = board[rows][a+1];\\n    board[rows][a+1] = tmp;\\n  }\\n}\\n\\nvoid remove_whitespace_verticaly(int board[ROWS][COLUMNS], int columns, int rows)\\n{\\n  int a = rows;\\n  int tmp;\\n\\n  for (; a < ROWS - 1; ++a) {\\n    tmp = board[a][columns];\\n    board[a][columns] = board[a+1][columns];\\n    board[a+1][columns] = tmp;\\n  }\\n}\\n\\n/*\\n * the add_tiles functions. those functions do the heavy work of adding the tiles and\\n * taking care of special situations such as when adding two equal tiles a 0 gets generated\\n * they are quite difficult to understand i think (which means not that you need to be too clever\\n * but that i have done a poor job of creating them) and it took around 4 hours to get the \\n * proper result\\n*/\\n\\nvoid add_tiles_horizontaly(int board[ROWS][COLUMNS])\\n{\\n  int a, b, flag;\\n\\n  for (a = 0; a < ROWS; ++a) {\\n    for (b = 0, flag = 0; b < COLUMNS - 1 && flag != 4; ++b) {\\n      if (board[a][b] == EMPTY_TILE) {\\n	remove_whitespace_horizontaly(board, a, b);\\n	--b;\\n	++flag;\\n      }\\n      else {\\n	if (board[a][b+1] == EMPTY_TILE) {\\n	  board[a][b+1] = board[a][b];\\n	  board[a][b] = EMPTY_TILE;\\n	  --b;\\n	} else if (board[a][b] == board[a][b+1]) {\\n	  board[a][b] += board[a][b+1];\\n	  board[a][b+1] = EMPTY_TILE;\\n	}\\n      }\\n    }\\n  }\\n}\\n\\nvoid add_tiles_verticaly(int board[ROWS][COLUMNS])\\n{\\n  int a, b, flag;\\n\\n  for (a = 0; a < COLUMNS; ++a) {\\n    for (b = 0, flag = 0; b < ROWS-1 && flag != 4; ++b) {\\n      if (board[b][a] == EMPTY_TILE) {\\n	remove_whitespace_verticaly(board, a, b);\\n	--b;\\n	++flag;\\n      }\\n      else {\\n	if (board[b+1][a] == EMPTY_TILE) {\\n	  board[b+1][a] = board[b][a];\\n	  board[b][a] = EMPTY_TILE;\\n	  --b;\\n	} else if (board[b][a] == board[b+1][a]) {\\n	  board[b][a] += board[b+1][a];\\n	  board[b+1][a] = EMPTY_TILE;\\n	}\\n      }\\n    }\\n  }\\n}\\n	  \\n/*\\n * ... print the board\\n */\\n\\nvoid print_board(int board[ROWS][COLUMNS])\\n{\\n  int a, b;\\n\\n  for (a = 0; a < ROWS; ++a) {\\n    printf(\""\\n\"");\\n    for (b = 0; b < COLUMNS; ++b) {\\n      printf(\""%5i\"", board[a][b]);\\n    }\\n  }\\n  printf(\""\\n\"");\\n}\\n\\n/*\\n * The reverse_board function reverses the array\\n * if the movement is right or down reverse the array\\n*/\\n\\nvoid reverse_board(char input[], int board[ROWS][COLUMNS])\\n{\\n  int a, b, c, tmp;\\n\\n  if (!strcmp(input, \""right\"")) {\\n    for (a = 0; a < ROWS; ++a) {\\n      for (b = 0, c = 3; b < 2; ++b, --c) {\\n	tmp = board[a][b];\\n	board[a][b] = board[a][c];\\n	board[a][c] = tmp;\\n      }\\n    }\\n  }\\n  else if  (!strcmp(input, \""down\"")) {\\n    for (a = 0; a < COLUMNS; ++a) {\\n      for (b = 0, c = 3; b < 2; ++b, --c) {\\n	tmp = board[b][a];\\n	board[b][a] = board[c][a];\\n	board[c][a] = tmp;\\n      }\\n    }\\n  }\\n}\\n\\n/*\\n * the check_board function is the one which evaluates the win or lose condition\\n * for each turn and at the same time providing the number of empty tiles for the random generator\\n * function\\n*/\\n\\nint check_board (int board[ROWS][COLUMNS])\\n{\\n  int a, b;\\n\\n  int result = 0;\\n  int empty_tiles = 0;\\n\\n\\n  for (a = 0; a < ROWS; ++a)\\n    for (b = 0; b < COLUMNS; ++b)\\n      if (board[a][b] == 2048)\\n	result = -1;\\n      else if (board[a][b] == EMPTY_TILE)\\n	++empty_tiles;\\n\\n  result = result == -1 ? result : empty_tiles;\\n\\n  return result;\\n}\\n\\n/*\\n * the generate_random functin generates a random number between 0 and the number of\\n * empty tiles. the generated number will assign to the Nth empty tile = (random_number) \\n * the new value, it also takes care of the 10% chance for producing a 4 tile\\n*/\\n\\nvoid generate_random(int board[ROWS][COLUMNS], int empty_tiles )\\n{\\n\\n  srand(time(NULL));\\n\\n  int a, b;\\n  int random = 0;\\n  int tile = 0;\\n\\n  random = rand() % empty_tiles;\\n  tile = (rand() % 9 == 4) ? 4 : 2;\\n\\n  for (a = 0; a < ROWS; ++a)\\n    for (b = 0; b < COLUMNS; ++b)\\n      if (board[a][b] == EMPTY_TILE && random != 0)\\n	--random;\\n      else if (board[a][b] == EMPTY_TILE && random == 0) {\\n	board[a][b] = tile;\\n	return;\\n      }\\n}\\n\\n/*\\n * infinite loop, get the movements or exit code and act accordingly \\n*/\\n\\nint play_game(int board[ROWS][COLUMNS])\\n{\\n\\n  char movement[81];\\n  int tiles = 0;\\n  \\n  printf(\""this is the 2048 game\\n\""					\\\\n	 \""The goal of this game is make a tile reach the value of 2048\\n\""\\\\n	 \""The board starts of with only one occupied tile.\\n\""\\\\n	 \""On each round a new tile gets added with the value of 2\\n\""\\\\n	 \""or at 10%% of the times with the value of 4\\n\""\\\\n	 \""If you run out of tiles you lose\\n\""\\\\n	 \""There are 4 movements you can supply to the game\\n\""\\\\n	 \""right, left, up, and down.\\n\""\\\\n	 \""For each of this movements the tiles move to the direction specified\\n\""\\\\n	 \""If two tiles have the same value the get added up just once.\\n\""\\\\n	 \""If 2 occupied tiles share the same row or column but are seperated by empty tiles\\n\""\\\\n	 \""then the occupied tiles travel along the empty tiles stacking in the direction\\n\""\\\\n	 \""they were directed\\n\""\\\\n	 \""For a more visual explanation you can check the wikipedia entry\\n\""\\n	 \"" if you search for 2058 board game\\n\""	\\\\n	 \""Here we go\\n\"");\\n\\n  print_board(board);\\n  while (1) {\\n    printf(\""(enter: left,right,up,down,exit)>> \"");\\n    scanf(\""%s\"", movement);\\n    if (!strcmp(movement, \""down\"")) {\\n      reverse_board(movement,board);\\n      add_tiles_verticaly(board);\\n      tiles = check_board(board);\\n      if (tiles == -1)\\n	return -1;\\n      else if (tiles == 0)\\n	return 0;\\n      generate_random(board,tiles);\\n      reverse_board(movement, board);\\n    }\\n    else if (!strcmp(movement, \""up\"")) {\\n      add_tiles_verticaly(board);\\n      tiles = check_board(board);\\n      if (tiles == -1)\\n	return -1;\\n      else if (tiles == 0)\\n	return 0;\\n      generate_random(board,tiles);\\n    }\\n    else if (!strcmp(movement, \""right\"")) {\\n      reverse_board(movement,board);\\n      add_tiles_horizontaly(board);\\n      tiles = check_board(board);\\n      if (tiles == -1)\\n	return -1;\\n      else if (tiles == 0)\\n	return 0;\\n      generate_random(board,tiles);\\n      reverse_board(movement, board);\\n    }\\n    else if (!strcmp(movement, \""left\"")) {\\n      add_tiles_horizontaly(board);\\n      tiles = check_board(board);\\n      if (tiles == -1)\\n	return -1;\\n      else if (tiles == 0)\\n	return 0;\\n      generate_random(board,tiles);\\n    }\\n    else if (!strcmp(movement, \""exit\"")) {\\n      return 1;\\n    }\\n    else {\\n      printf(\""Do not recognize this movement please type again\\n\"");\\n      continue;\\n    }\\n    print_board(board);\\n  }\\n}\\n\\n\\nint main(void)\\n{\\n  int play_game(int board[ROWS][COLUMNS]);\\n  void generate_random(int board[ROWS][COLUMNS], int empty_tiles );\\n  int check_board (int board[ROWS][COLUMNS]);\\n  void reverse_board(char input[], int board[ROWS][COLUMNS]);\\n  void print_board(int board[ROWS][COLUMNS]);\\n  void add_tiles_verticaly(int board[ROWS][COLUMNS]);\\n  void add_tiles_horizontaly(int board[ROWS][COLUMNS]);\\n  void remove_whitespace_verticaly(int board[ROWS][COLUMNS], int columns, int rows);\\n  void remove_whitespace_horizontaly(int board[ROWS][COLUMNS], int rows, int columns);\\n    \\n  int win_condition;\\n  int board[ROWS][COLUMNS] = {\\n    {0,0,0,0},\\n    {0,0,0,0},\\n    {0,0,0,0},\\n    {0,0,0,0}\\n  };\\n\\n\\n  generate_random(board, 16); /* initialize the board */\\n\\n  win_condition = play_game(board);\\n  switch (win_condition) {\\n  case 1:\\n    printf(\""But you are not done yet!!!\\n\""	\\\\n	   \""Fine, see you another day\\n\"");\\n    break;\\n  case 0:\\n    printf(\""Ohh noo, you run out of tiles\\n\""	\\\\n	   \""Run me agan to play some more\\n\""	\\\\n	   \""Byyyeee\\n\"");\\n    break;\\n  case -1:\\n    printf(\""WooooW you did it, Good job!!!\\n\""	\\\\n	   \""See ya later homie\\n\"");\\n    break;\\n  }\\n\\n  return 0;\\n}\\n"
"C","24_game","\\nThe 24 Game tests one's mental arithmetic.\\n\\nWrite a program that randomly chooses and displays four digits, each from 1 ──► 9 (inclusive) with repetitions allowed.\\nThe program should prompt for the player to enter an arithmetic expression using just those, and all of those four digits, used exactly once each. The program should check then evaluate the expression.\\nThe goal is for the player to enter an expression that (numerically) evaluates to 24.\\n\\n\\n\\n\\nThis is a fully-worked sample of the game in 8th, showing error-detection and user-restriction techniques:\\nSee 24 game/ABAP\\ngame24.adb:\\n","#include <stdio.h>\\n#include <ctype.h>\\n#include <stdlib.h>\\n#include <setjmp.h>\\n#include <time.h>\\n \\njmp_buf ctx;\\nconst char *msg;\\n \\nenum { OP_NONE = 0, OP_NUM, OP_ADD, OP_SUB, OP_MUL, OP_DIV };\\n \\ntypedef struct expr_t *expr, expr_t;\\nstruct expr_t {\\n	int op, val, used;\\n	expr left, right;\\n};\\n \\n#define N_DIGITS 4\\nexpr_t digits[N_DIGITS];\\n \\nvoid gen_digits()\\n{\\n	int i;\\n	for (i = 0; i < N_DIGITS; i++)\\n		digits[i].val = 1 + rand() % 9;\\n}\\n \\n#define MAX_INPUT 64\\nchar str[MAX_INPUT];\\nint pos;\\n \\n#define POOL_SIZE 8\\nexpr_t pool[POOL_SIZE];\\nint pool_ptr;\\n \\nvoid reset()\\n{\\n	int i;\\n	msg = 0;\\n	pool_ptr = pos = 0;\\n	for (i = 0; i < POOL_SIZE; i++) {\\n		pool[i].op = OP_NONE;\\n		pool[i].left = pool[i].right = 0;\\n	}\\n	for (i = 0; i < N_DIGITS; i++)\\n		digits[i].used = 0;\\n}\\n \\n/* longish jumpish back to input cycle */\\nvoid bail(const char *s)\\n{\\n	msg = s;\\n	longjmp(ctx, 1);\\n}\\n \\nexpr new_expr()\\n{\\n	if (pool_ptr < POOL_SIZE)\\n		return pool + pool_ptr++;\\n	return 0;\\n}\\n \\n/* check next input char */\\nint next_tok()\\n{\\n	while (isspace(str[pos])) pos++;\\n	return str[pos];\\n}\\n \\n/* move input pointer forward */\\nint take()\\n{\\n	if (str[pos] != '\\0') return ++pos;\\n	return 0;\\n}\\n \\n/* BNF(ish)\\nexpr = term { (\""+\"")|(\""-\"") term }\\nterm = fact { (\""*\"")|(\""/\"") expr }\\nfact =	number\\n	| '(' expr ')'\\n*/\\n \\nexpr get_fact();\\nexpr get_term();\\nexpr get_expr();\\n \\nexpr get_expr()\\n{\\n	int c;\\n	expr l, r, ret;\\n	if (!(ret = get_term())) bail(\""Expected term\"");\\n	while ((c = next_tok()) == '+' || c == '-') {\\n		if (!take()) bail(\""Unexpected end of input\"");\\n		if (!(r = get_term())) bail(\""Expected term\"");\\n \\n		l = ret;\\n		ret = new_expr();\\n		ret->op = (c == '+') ? OP_ADD : OP_SUB;\\n		ret->left = l;\\n		ret->right = r;\\n	}\\n	return ret;\\n}\\n \\nexpr get_term()\\n{\\n	int c;\\n	expr l, r, ret;\\n	ret = get_fact();\\n	while((c = next_tok()) == '*' || c == '/') {\\n		if (!take()) bail(\""Unexpected end of input\"");\\n \\n		r = get_fact();\\n		l = ret;\\n		ret = new_expr();\\n		ret->op = (c == '*') ? OP_MUL : OP_DIV;\\n		ret->left = l;\\n		ret->right = r;\\n	}\\n	return ret;\\n}\\n \\nexpr get_digit()\\n{\\n	int i, c = next_tok();\\n	expr ret;\\n	if (c >= '0' && c <= '9') {\\n		take();\\n		ret = new_expr();\\n		ret->op = OP_NUM;\\n		ret->val = c - '0';\\n		for (i = 0; i < N_DIGITS; i++)\\n			if (digits[i].val == ret->val && !digits[i].used) {\\n				digits[i].used = 1;\\n				return ret;\\n			}\\n		bail(\""Invalid digit\"");\\n	}\\n	return 0;\\n}\\n \\nexpr get_fact()\\n{\\n	int c;\\n	expr l = get_digit();\\n	if (l) return l;\\n	if ((c = next_tok()) == '(') {\\n		take();\\n		l = get_expr();\\n		if (next_tok() != ')') bail(\""Unbalanced parens\"");\\n		take();\\n		return l;\\n	}\\n	return 0;\\n}\\n \\nexpr parse()\\n{\\n	int i;\\n	expr ret = get_expr();\\n	if (next_tok() != '\\0')\\n		bail(\""Trailing garbage\"");\\n	for (i = 0; i < N_DIGITS; i++)\\n		if (!digits[i].used)\\n			bail(\""Not all digits are used\"");\\n	return ret;\\n}\\n \\ntypedef struct frac_t frac_t, *frac;\\nstruct frac_t { int denom, num; };\\n \\nint gcd(int m, int n)\\n{\\n	int t;\\n	while (m) {\\n		t = m; m = n % m; n = t;\\n	}\\n	return n;\\n}\\n \\n/* evaluate expression tree.  result in fraction form */\\nvoid eval_tree(expr e, frac res)\\n{\\n	frac_t l, r;\\n	int t;\\n	if (e->op == OP_NUM) {\\n		res->num = e->val;\\n		res->denom = 1;\\n		return;\\n	}\\n \\n	eval_tree(e->left, &l);\\n	eval_tree(e->right, &r);\\n \\n	switch(e->op) {\\n	case OP_ADD:\\n		res->num = l.num * r.denom + l.denom * r.num;\\n		res->denom = l.denom * r.denom;\\n		break;\\n	case OP_SUB:\\n		res->num = l.num * r.denom - l.denom * r.num;\\n		res->denom = l.denom * r.denom;\\n		break;\\n	case OP_MUL:\\n		res->num = l.num * r.num;\\n		res->denom = l.denom * r.denom;\\n		break;\\n	case OP_DIV:\\n		res->num = l.num * r.denom;\\n		res->denom = l.denom * r.num;\\n		break;\\n	}\\n	if ((t = gcd(res->denom, res->num))) {\\n		res->denom /= t;\\n		res->num /= t;\\n	}\\n}\\n \\nvoid get_input()\\n{\\n	int i;\\nreinput:\\n	reset();\\n	printf(\""\\nAvailable digits are:\"");\\n	for (i = 0; i < N_DIGITS; i++) \\n		printf(\"" %d\"", digits[i].val);\\n	printf(\"". Type an expression and I'll check it for you, or make new numbers.\\n\""\\n		\""Your choice? [Expr/n/q] \"");\\n \\n	while (1) {\\n		for (i = 0; i < MAX_INPUT; i++) str[i] = '\\n';\\n		fgets(str, MAX_INPUT, stdin);\\n		if (*str == '\\0') goto reinput;\\n		if (str[MAX_INPUT - 1] != '\\n')\\n			bail(\""string too long\"");\\n \\n		for (i = 0; i < MAX_INPUT; i++)\\n			if (str[i] == '\\n') str[i] = '\\0';\\n		if (str[0] == 'q') {\\n			printf(\""Bye\\n\"");\\n			exit(0);\\n		}\\n		if (str[0] == 'n') {\\n			gen_digits();\\n			goto reinput;\\n		}\\n		return;\\n	}\\n}\\n \\nint main()\\n{\\n	frac_t f;\\n	srand(time(0));\\n \\n	gen_digits();\\n	while(1) {\\n		get_input();\\n		setjmp(ctx); /* if parse error, jump back here with err msg set */\\n		if (msg) {\\n			/* after error jump; announce, reset, redo */\\n			printf(\""%s at '%.*s'\\n\"", msg, pos, str);\\n			continue;\\n		}\\n \\n		eval_tree(parse(), &f);\\n \\n		if (f.denom == 0) bail(\""Divide by zero\"");\\n		if (f.denom == 1 && f.num == 24)\\n			printf(\""You got 24.  Very good.\\n\"");\\n		else {\\n			if (f.denom == 1)\\n				printf(\""Eval to: %d, \"", f.num);\\n			else\\n				printf(\""Eval to: %d/%d, \"", f.num, f.denom);\\n			printf(\""no good.  Try again.\\n\"");\\n		}\\n	}\\n	return 0;\\n}"
"C","24_game/Solve","Write a program that takes four digits, either from user input or by random generation, and computes arithmetic expressions following the rules of the 24 game.\\nShow examples of solutions generated by the program.\\n\\n\\nWill generate all possible solutions of any given four numbers according to the rules of the 24 game.\\nNote: the permute function was locally from here\\nSample Runs:\\nExamples:\\nOutput is in RPN.\\n","#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\n#define n_cards 4\\n#define solve_goal 24\\n#define max_digit 9\\n\\ntypedef struct { int num, denom; } frac_t, *frac;\\ntypedef enum { C_NUM = 0, C_ADD, C_SUB, C_MUL, C_DIV } op_type;\\n\\ntypedef struct expr_t *expr;\\ntypedef struct expr_t {\\n        op_type op;\\n        expr left, right;\\n        int value;\\n} expr_t;\\n\\nvoid show_expr(expr e, op_type prec, int is_right)\\n{\\n        const char * op;\\n        switch(e->op) {\\n        case C_NUM:     printf(\""%d\"", e->value);\\n                        return;\\n        case C_ADD:     op = \"" + \""; break;\\n        case C_SUB:     op = \"" - \""; break;\\n        case C_MUL:     op = \"" x \""; break;\\n        case C_DIV:     op = \"" / \""; break;\\n        }\\n\\n        if ((e->op == prec && is_right) || e->op < prec) printf(\""(\"");\\n        show_expr(e->left, e->op, 0);\\n        printf(\""%s\"", op);\\n        show_expr(e->right, e->op, 1);\\n        if ((e->op == prec && is_right) || e->op < prec) printf(\"")\"");\\n}\\n\\nvoid eval_expr(expr e, frac f)\\n{\\n        frac_t left, right;\\n        if (e->op == C_NUM) {\\n                f->num = e->value;\\n                f->denom = 1;\\n                return;\\n        }\\n        eval_expr(e->left, &left);\\n        eval_expr(e->right, &right);\\n        switch (e->op) {\\n        case C_ADD:\\n                f->num = left.num * right.denom + left.denom * right.num;\\n                f->denom = left.denom * right.denom;\\n                return;\\n        case C_SUB:\\n                f->num = left.num * right.denom - left.denom * right.num;\\n                f->denom = left.denom * right.denom;\\n                return;\\n        case C_MUL:\\n                f->num = left.num * right.num;\\n                f->denom = left.denom * right.denom;\\n                return;\\n        case C_DIV:\\n                f->num = left.num * right.denom;\\n                f->denom = left.denom * right.num;\\n                return;\\n        default:\\n                fprintf(stderr, \""Unknown op: %d\\n\"", e->op);\\n                return;\\n        }\\n}\\nint solve(expr ex_in[], int len)\\n{\\n        int i, j;\\n        expr_t node;\\n        expr ex[n_cards];\\n        frac_t final;\\n\\n        if (len == 1) {\\n                eval_expr(ex_in[0], &final);\\n                if (final.num == final.denom * solve_goal && final.denom) {\\n                        show_expr(ex_in[0], 0, 0);\\n                        return 1;\\n                }\\n                return 0;\\n        }\\n\\n        for (i = 0; i < len - 1; i++) {\\n                for (j = i + 1; j < len; j++)\\n                        ex[j - 1] = ex_in[j];\\n                ex[i] = &node\\n                for (j = i + 1; j < len; j++) {\\n                        node.left = ex_in[i];\\n                        node.right = ex_in[j];\\n                        for (node.op = C_ADD; node.op <= C_DIV; node.op++)\\n                                if (solve(ex, len - 1))\\n                                        return 1;\\n\\n                        node.left = ex_in[j];\\n                        node.right = ex_in[i];\\n                        node.op = C_SUB;\\n                        if (solve(ex, len - 1)) return 1;\\n                        node.op = C_DIV;\\n                        if (solve(ex, len - 1)) return 1;\\n\\n                        ex[j] = ex_in[j];\\n                }\\n                ex[i] = ex_in[i];\\n        }\\n\\n        return 0;\\n}\\n\\nint solve24(int n[])\\n{\\n        int i;\\n        expr_t ex[n_cards];\\n        expr   e[n_cards];\\n        for (i = 0; i < n_cards; i++) {\\n                e[i] = ex + i;\\n                ex[i].op = C_NUM;\\n                ex[i].left = ex[i].right = 0;\\n                ex[i].value = n[i];\\n        }\\n        return solve(e, n_cards);\\n}\\n\\nint main()\\n{\\n        int i, j, n[] = { 3, 3, 8, 8, 9 };\\n        srand(time(0));\\n\\n        for (j = 0; j < 10; j++) {\\n                for (i = 0; i < n_cards; i++) {\\n                        n[i] = 1 + (double) rand() * max_digit / RAND_MAX;\\n                        printf(\"" %d\"", n[i]);\\n                }\\n                printf(\"":  \"");\\n                printf(solve24(n) ? \""\\n\"" : \""No solution\\n\"");\\n        }\\n\\n        return 0;\\n}"
"C","4-rings_or_4-squares_puzzle","Replace       a, b, c, d, e, f,   and\\n  g        with the decimal\\ndigits   LOW   ───►   HIGH\\nsuch that the sum of the letters inside of each of the four large squares add up to\\nthe same sum.\\nShow all output here.\\n\\n\\n\\nAs with the REXX solution, we use explicit loops to generate the permutations.\\n","\\n#include <stdio.h>\\n\\n#define TRUE 1\\n#define FALSE 0\\n\\nint a,b,c,d,e,f,g;\\nint lo,hi,unique,show;\\nint solutions;\\n\\nvoid\\nbf()\\n{\\n    for (f = lo;f <= hi; f++)\\n        if ((!unique) ||\\n           ((f != a) && (f != c) && (f != d) && (f != g) && (f != e)))\\n            {\\n            b = e + f - c;\\n            if ((b >= lo) && (b <= hi) &&\\n                   ((!unique) || ((b != a) && (b != c) &&\\n                   (b != d) && (b != g) && (b != e) && (b != f))))\\n                {\\n                solutions++;\\n                if (show)\\n                    printf(\""%d %d %d %d %d %d %d\\n\"",a,b,c,d,e,f,g);\\n                }\\n            }\\n}\\n\\n\\nvoid\\nge()\\n{\\n    for (e = lo;e <= hi; e++)\\n        if ((!unique) || ((e != a) && (e != c) && (e != d)))\\n            {\\n            g = d + e;\\n            if ((g >= lo) && (g <= hi) &&\\n                   ((!unique) || ((g != a) && (g != c) &&\\n                   (g != d) && (g != e))))\\n                bf();\\n            }\\n}\\n\\nvoid\\nacd()\\n{\\n    for (c = lo;c <= hi; c++)\\n        for (d = lo;d <= hi; d++)\\n            if ((!unique) || (c != d))\\n                {\\n                a = c + d;\\n                if ((a >= lo) && (a <= hi) &&\\n                   ((!unique) || ((c != 0) && (d != 0))))\\n                    ge();\\n                }\\n}\\n\\n\\nvoid\\nfoursquares(int plo,int phi, int punique,int pshow)\\n{\\n    lo = plo;\\n    hi = phi;\\n    unique = punique;\\n    show = pshow;\\n    solutions = 0;\\n\\n    printf(\""\\n\"");\\n\\n    acd();\\n\\n    if (unique)\\n        printf(\""\\n%d unique solutions in %d to %d\\n\"",solutions,lo,hi);\\n    else\\n        printf(\""\\n%d non-unique solutions in %d to %d\\n\"",solutions,lo,hi);\\n}\\n\\nmain()\\n{\\n    foursquares(1,7,TRUE,TRUE);\\n    foursquares(3,9,TRUE,TRUE);\\n    foursquares(0,9,FALSE,FALSE);\\n}\\n"
"C","9_billion_names_of_God_the_integer","This task is a variation of the short story by Arthur C. Clarke.\\n(Solvers should be aware of the consequences of completing this task.)\\nIn detail, to specify what is meant by a   “name”:\\n\\nDisplay the first 25 rows of a number triangle which begins:\\nWhere row   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n   corresponds to integer   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n,   and each column   \\n\\n\\n\\nC\\n\\n\\n{\\displaystyle C}\\n\\n   in row   \\n\\n\\n\\nm\\n\\n\\n{\\displaystyle m}\\n\\n   from left to right corresponds to the number of names beginning with   \\n\\n\\n\\nC\\n\\n\\n{\\displaystyle C}\\n\\n.\\nA function   \\n\\n\\n\\nG\\n(\\nn\\n)\\n\\n\\n{\\displaystyle G(n)}\\n\\n   should return the sum of the   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n-th   row.\\nDemonstrate this function by displaying:   \\n\\n\\n\\nG\\n(\\n23\\n)\\n\\n\\n{\\displaystyle G(23)}\\n\\n,   \\n\\n\\n\\nG\\n(\\n123\\n)\\n\\n\\n{\\displaystyle G(123)}\\n\\n,   \\n\\n\\n\\nG\\n(\\n1234\\n)\\n\\n\\n{\\displaystyle G(1234)}\\n\\n,   and   \\n\\n\\n\\nG\\n(\\n12345\\n)\\n\\n\\n{\\displaystyle G(12345)}\\n\\n.\\nOptionally note that the sum of the   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n-th   row   \\n\\n\\n\\nP\\n(\\nn\\n)\\n\\n\\n{\\displaystyle P(n)}\\n\\n   is the     integer partition function.\\nDemonstrate this is equivalent to   \\n\\n\\n\\nG\\n(\\nn\\n)\\n\\n\\n{\\displaystyle G(n)}\\n\\n   by displaying:   \\n\\n\\n\\nP\\n(\\n23\\n)\\n\\n\\n{\\displaystyle P(23)}\\n\\n,   \\n\\n\\n\\nP\\n(\\n123\\n)\\n\\n\\n{\\displaystyle P(123)}\\n\\n,   \\n\\n\\n\\nP\\n(\\n1234\\n)\\n\\n\\n{\\displaystyle P(1234)}\\n\\n,   and   \\n\\n\\n\\nP\\n(\\n12345\\n)\\n\\n\\n{\\displaystyle P(12345)}\\n\\n.\\n\\nIf your environment is able, plot   \\n\\n\\n\\nP\\n(\\nn\\n)\\n\\n\\n{\\displaystyle P(n)}\\n\\n   against   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n   for   \\n\\n\\n\\nn\\n=\\n1\\n…\\n999\\n\\n\\n{\\displaystyle n=1\\ldots 999}\\n\\n.\\n\\n","#include <stdio.h>\\n#include <gmp.h>\\n\\n#define N 100000\\nmpz_t p[N + 1];\\n\\nvoid calc(int n)\\n{\\n	mpz_init_set_ui(p[n], 0);\\n\\n	for (int k = 1; k <= n; k++) {\\n		int d = n - k * (3 * k - 1) / 2;\\n		if (d < 0) break;\\n\\n		if (k&1)mpz_add(p[n], p[n], p[d]);\\n		else	mpz_sub(p[n], p[n], p[d]);\\n\\n		d -= k;\\n		if (d < 0) break;\\n\\n		if (k&1)mpz_add(p[n], p[n], p[d]);\\n		else	mpz_sub(p[n], p[n], p[d]);\\n	}\\n}\\n\\nint main(void)\\n{\\n	int idx[] = { 23, 123, 1234, 12345, 20000, 30000, 40000, 50000, N, 0 };\\n	int at = 0;\\n\\n	mpz_init_set_ui(p[0], 1);\\n\\n	for (int i = 1; idx[at]; i++) {\\n		calc(i);\\n		if (i != idx[at]) continue;\\n\\n		gmp_printf(\""%2d:\\t%Zd\\n\"", i, p[i]);\\n		at++;\\n	}\\n}"
"C","99_Bottles_of_Beer","Display the complete lyrics for the song:     99 Bottles of Beer on the Wall.\\n\\nThe lyrics follow this form:\\n 99 bottles of beer on the wall\\n99 bottles of beer\\nTake one down, pass it around\\n98 bottles of beer on the wall\\n 98 bottles of beer on the wall\\n98 bottles of beer\\nTake one down, pass it around\\n97 bottles of beer on the wall\\n... and so on, until reaching 0.\\nGrammatical support for \""1 bottle of beer\"" is optional.\\nAs with any puzzle, try to do it in as creative/concise/comical a way\\nas possible (simple, obvious solutions allowed, too).\\n\\n\\n\\nSee 99 Bottles of Beer/EsoLang\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nor (With ABAP 7.40)\\nSee 99 Bottles of Beer/Lisp\\nwith 1 task to print out the information and 99 tasks to specify the number of bottles\\nImplementation in Apache Ant, due to the limitations of Ant, this requires ant-contrib for arithmetic operations and a dummy target to keep Ant from detecting the loop.\\n\\nNote that the output label text is not displayed until the entire lyrics text has been built and there is some delay between button press and display.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\nOutput can be sent directly to a label with this preferred method as there is no noticeable delay between button press and output.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\n\\n\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Shell\\nSee 99 Bottles of Beer/Shell\\nIf you don't want so many beers, here you can specify the starting amount. \\nFor example, just a sixpack:\\n","/*\\n * 99 Bottles, C, KISS (i.e. keep it simple and straightforward) version\\n */\\n\\n#include <stdio.h>\\n\\nint main(void)\\n{\\n  int n;\\n\\n  for( n = 99; n > 2; n-- )\\n    printf(\\n      \""%d bottles of beer on the wall, %d bottles of beer.\\n\""\\n      \""Take one down and pass it around, %d bottles of beer on the wall.\\n\\n\"", \\n       n, n, n - 1);\\n\\n  printf(  \\n      \""2 bottles of beer on the wall, 2 bottles of beer.\\n\""\\n      \""Take one down and pass it around, 1 bottle of beer on the wall.\\n\\n\""                  \\n\\n      \""1 bottle of beer on the wall, 1 bottle of beer.\\n\""\\n      \""Take one down and pass it around, no more bottles of beer on the wall.\\n\\n\""                  \\n\\n      \""No more bottles of beer on the wall, no more bottles of beer.\\n\"" \\n      \""Go to the store and buy some more, 99 bottles of beer on the wall.\\n\"");\\n\\n      return 0;\\n}"
"C","99_Bottles_of_Beer","Display the complete lyrics for the song:     99 Bottles of Beer on the Wall.\\n\\nThe lyrics follow this form:\\n 99 bottles of beer on the wall\\n99 bottles of beer\\nTake one down, pass it around\\n98 bottles of beer on the wall\\n 98 bottles of beer on the wall\\n98 bottles of beer\\nTake one down, pass it around\\n97 bottles of beer on the wall\\n... and so on, until reaching 0.\\nGrammatical support for \""1 bottle of beer\"" is optional.\\nAs with any puzzle, try to do it in as creative/concise/comical a way\\nas possible (simple, obvious solutions allowed, too).\\n\\n\\n\\nSee 99 Bottles of Beer/EsoLang\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nor (With ABAP 7.40)\\nSee 99 Bottles of Beer/Lisp\\nwith 1 task to print out the information and 99 tasks to specify the number of bottles\\nImplementation in Apache Ant, due to the limitations of Ant, this requires ant-contrib for arithmetic operations and a dummy target to keep Ant from detecting the loop.\\n\\nNote that the output label text is not displayed until the entire lyrics text has been built and there is some delay between button press and display.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\nOutput can be sent directly to a label with this preferred method as there is no noticeable delay between button press and output.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\n\\n\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Shell\\nSee 99 Bottles of Beer/Shell\\nIf you don't want so many beers, here you can specify the starting amount. \\nFor example, just a sixpack:\\n","#include <stdio.h>\\n\\nint main(int argc, char *argv[])\\n{\\n        if(argc == 99)\\n                return 99;\\n        if(argv[0] != NULL){\\n                argv[0] = NULL;\\n                argc = 0;\\n        }\\n        argc = main(argc + 1, argv);\\n        printf(\""%d bottle%c of beer on the wall\\n\"", argc, argc == 1?'\\0': 's');\\n        printf(\""%d bottle%c of beer\\n\"", argc, argc == 1?'\\0': 's');\\n        printf(\""Take one down, pass it around\\n\""); \\n        printf(\""%d bottle%c of beer on the wall\\n\\n\"", argc - 1, (argc - 1) == 1?'\\0': 's');\\n        return argc - 1;\\n}"
"C","99_Bottles_of_Beer","Display the complete lyrics for the song:     99 Bottles of Beer on the Wall.\\n\\nThe lyrics follow this form:\\n 99 bottles of beer on the wall\\n99 bottles of beer\\nTake one down, pass it around\\n98 bottles of beer on the wall\\n 98 bottles of beer on the wall\\n98 bottles of beer\\nTake one down, pass it around\\n97 bottles of beer on the wall\\n... and so on, until reaching 0.\\nGrammatical support for \""1 bottle of beer\"" is optional.\\nAs with any puzzle, try to do it in as creative/concise/comical a way\\nas possible (simple, obvious solutions allowed, too).\\n\\n\\n\\nSee 99 Bottles of Beer/EsoLang\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nor (With ABAP 7.40)\\nSee 99 Bottles of Beer/Lisp\\nwith 1 task to print out the information and 99 tasks to specify the number of bottles\\nImplementation in Apache Ant, due to the limitations of Ant, this requires ant-contrib for arithmetic operations and a dummy target to keep Ant from detecting the loop.\\n\\nNote that the output label text is not displayed until the entire lyrics text has been built and there is some delay between button press and display.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\nOutput can be sent directly to a label with this preferred method as there is no noticeable delay between button press and output.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\n\\n\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Shell\\nSee 99 Bottles of Beer/Shell\\nIf you don't want so many beers, here you can specify the starting amount. \\nFor example, just a sixpack:\\n","#include <stdio.h>\\nmain(){_=100;while(--_)printf(\""%i bottle%s of beer in the wall,\\n%i bottle%\""\\n\""s of beer.\\nTake one down, pass it round,\\n%s%s\\n\\n\"",_,_-1?\""s\"":\""\"",_,_-1?\""s\""\\n:\""\"",_-1?(char[]){(_-1)/10?(_-1)/10+48:(_-1)%10+48,(_-1)/10?(_-1)%10+48:2+30,\\n(_-1)/10?32:0,0}:\""\"",_-1?\""bottles of beer in the wall\"":\""No more beers\"");}"
"C","99_Bottles_of_Beer","Display the complete lyrics for the song:     99 Bottles of Beer on the Wall.\\n\\nThe lyrics follow this form:\\n 99 bottles of beer on the wall\\n99 bottles of beer\\nTake one down, pass it around\\n98 bottles of beer on the wall\\n 98 bottles of beer on the wall\\n98 bottles of beer\\nTake one down, pass it around\\n97 bottles of beer on the wall\\n... and so on, until reaching 0.\\nGrammatical support for \""1 bottle of beer\"" is optional.\\nAs with any puzzle, try to do it in as creative/concise/comical a way\\nas possible (simple, obvious solutions allowed, too).\\n\\n\\n\\nSee 99 Bottles of Beer/EsoLang\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nor (With ABAP 7.40)\\nSee 99 Bottles of Beer/Lisp\\nwith 1 task to print out the information and 99 tasks to specify the number of bottles\\nImplementation in Apache Ant, due to the limitations of Ant, this requires ant-contrib for arithmetic operations and a dummy target to keep Ant from detecting the loop.\\n\\nNote that the output label text is not displayed until the entire lyrics text has been built and there is some delay between button press and display.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\nOutput can be sent directly to a label with this preferred method as there is no noticeable delay between button press and output.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\n\\n\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Shell\\nSee 99 Bottles of Beer/Shell\\nIf you don't want so many beers, here you can specify the starting amount. \\nFor example, just a sixpack:\\n","#include <stdlib.h>\\n#include <stdio.h>\\n\\n#define BOTTLE(nstr) nstr \"" bottles of beer\""\\n\\n#define WALL(nstr) BOTTLE(nstr) \"" on the wall\""\\n\\n#define PART1(nstr) WALL(nstr) \""\\n\"" BOTTLE(nstr) \\\\n                    \""\\nTake one down, pass it around\\n\""\\n\\n#define PART2(nstr) WALL(nstr) \""\\n\\n\""\\n\\n#define MIDDLE(nstr) PART2(nstr) PART1(nstr)\\n\\n#define SONG PART1(\""100\"") CD2 PART2(\""0\"")\\n\\n#define CD2 CD3(\""9\"") CD3(\""8\"") CD3(\""7\"") CD3(\""6\"") CD3(\""5\"") \\\\n        CD3(\""4\"") CD3(\""3\"") CD3(\""2\"") CD3(\""1\"") CD4(\""\"")\\n\\n#define CD3(pre) CD4(pre) MIDDLE(pre \""0\"")\\n\\n#define CD4(pre) MIDDLE(pre \""9\"") MIDDLE(pre \""8\"") MIDDLE(pre \""7\"") \\\\n MIDDLE(pre \""6\"") MIDDLE(pre \""5\"") MIDDLE(pre \""4\"") MIDDLE(pre \""3\"") \\\\n MIDDLE(pre \""2\"") MIDDLE(pre \""1\"")\\n\\nint main(void)\\n{\\n  (void) printf(SONG);\\n  return EXIT_SUCCESS;\\n}"
"C","99_Bottles_of_Beer","Display the complete lyrics for the song:     99 Bottles of Beer on the Wall.\\n\\nThe lyrics follow this form:\\n 99 bottles of beer on the wall\\n99 bottles of beer\\nTake one down, pass it around\\n98 bottles of beer on the wall\\n 98 bottles of beer on the wall\\n98 bottles of beer\\nTake one down, pass it around\\n97 bottles of beer on the wall\\n... and so on, until reaching 0.\\nGrammatical support for \""1 bottle of beer\"" is optional.\\nAs with any puzzle, try to do it in as creative/concise/comical a way\\nas possible (simple, obvious solutions allowed, too).\\n\\n\\n\\nSee 99 Bottles of Beer/EsoLang\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nor (With ABAP 7.40)\\nSee 99 Bottles of Beer/Lisp\\nwith 1 task to print out the information and 99 tasks to specify the number of bottles\\nImplementation in Apache Ant, due to the limitations of Ant, this requires ant-contrib for arithmetic operations and a dummy target to keep Ant from detecting the loop.\\n\\nNote that the output label text is not displayed until the entire lyrics text has been built and there is some delay between button press and display.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\nOutput can be sent directly to a label with this preferred method as there is no noticeable delay between button press and output.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\n\\n\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Shell\\nSee 99 Bottles of Beer/Shell\\nIf you don't want so many beers, here you can specify the starting amount. \\nFor example, just a sixpack:\\n","      int b =99,u =1;\\n     #include<stdio.h>\\n      char *d[16],y[]\\n      = \""#:ottle/ of\""\\n      \"":eer_ a_Goy\\x20some6\""\\n      \""_Take8;down4p\""\\n      \""a=1rou7_17 _<\""\\n      \""h;_ m?_nd_ on\""\\n      \""_085wal\"" \""l_ \""\\n      \""b_e _ t_ss it\""\\n      \""_?4bu_ore_9, \""\\n      \""\\060.\""\""@, 9$\"";\\n     # define x  c  ^=\\n    #include <string.h>\\n   #define or(t,z) else\\\\n  if(c==t && !(c = 0) &&\\\\n (c =! z)); int p(char *t)\\n{ char *s = t; int c; for (\\nd[c = 0] = y; !t && (d[c +1\\n]= strchr(s = d[c], '_'));*\\n(d[++c]++) = 0); for(t = s?\\ns:t;(c= *s++); c && putchar\\n(c)) { if (!((( x 48)& ~0xf\\n) && ( x 48)) ) p(d[c]), c=\\n0 ; or('$', p(b - 99?\"".\\n\"":\\n\"".\"" ) && p(b - 99? t : \""\""))\\nor ('\\x40', c && p( d[!!b--\\n+ 2])) or('/', c && p( b^1?\\n\""s\"": \""\"")) or ('\\043', b++ ?\\np(\""So6\"" + --b):!printf(\""%d\""\\n, b ? --b : (b += 99))) or(\\n'S',!(++u % 3) * 32+ 78) or\\n('.', puts(\"".\""))}return c;}\\n int main() {return p(0);}"
"C","A*_search_algorithm","The A* search algorithm is an extension of Dijkstra's algorithm useful for finding the lowest cost path between two nodes (aka vertices) of a graph. The path may traverse any number of nodes connected by edges (aka arcs) with each edge having an associated cost. The algorithm uses a heuristic which associates an estimate of the lowest cost path from this node to the goal node, such that this estimate is never greater than the actual cost.\\nThe algorithm should not assume that all edge costs are the same. It should be possible to start and finish on any node, including ones identified as a barrier in the task.\\nConsider the problem of finding a route across the diagonal of a chess board-like 8x8 grid. The rows are numbered from 0 to 7. The columns are also numbered 0 to 7. The start position is (0, 0) and the end position is (7, 7). Movement is allow by one square in any direction including diagonals, similar to a king in chess. The standard movement cost is 1. To make things slightly harder, there is a barrier that occupy certain positions of the grid. Moving into any of the barrier positions has a cost of 100.\\nThe barrier occupies the positions (2,4), (2,5), (2,6), (3,6), (4,6), (5,6), (5,5), (5,4), (5,3), (5,2), (4,2) and (3,2).\\nA route with the lowest cost should be found using the A* search algorithm (there are multiple optimal solutions with the same total cost).\\nPrint the optimal route in text format, as well as the total cost of the route.\\nOptionally, draw the optimal route and the barrier positions.\\nNote: using a heuristic score of zero is equivalent to Dijkstra's algorithm and that's kind of cheating/not really A*!\\nUse this algorithm to solve an 8 puzzle. Each node of the input graph will represent an arrangement of the tiles. The nodes will be connected by 4 edges representing swapping the blank tile up, down, left, or right. The cost of each edge is 1. The heuristic will be the sum of the manhatten distance of each numbered tile from its goal position. An 8 puzzle graph will have 9!/2 (181,440) nodes. The 15 puzzle has over 10 trillion nodes. This algorithm may solve simple 15 puzzles (but there are not many of those).\\n\\n\\n\\n","\\n#include <stdlib.h>\\n#include <stdio.h>\\n#include <string.h>\\n#include <float.h>\\n/* and not not_eq */\\n#include <iso646.h>\\n/* add -lm to command line to compile with this header */\\n#include <math.h>\\n\\n#define map_size_rows 10\\n#define map_size_cols 10\\n\\nchar map[map_size_rows][map_size_cols] = {\\n    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},\\n    {1, 0, 0, 0, 0, 0, 0, 0, 0, 1},\\n    {1, 0, 0, 0, 0, 0, 0, 0, 0, 1},\\n    {1, 0, 0, 0, 0, 1, 1, 1, 0, 1},\\n    {1, 0, 0, 1, 0, 0, 0, 1, 0, 1},\\n    {1, 0, 0, 1, 0, 0, 0, 1, 0, 1},\\n    {1, 0, 0, 1, 1, 1, 1, 1, 0, 1},\\n    {1, 0, 0, 0, 0, 0, 0, 0, 0, 1},\\n    {1, 0, 0, 0, 0, 0, 0, 0, 0, 1},\\n    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}\\n};\\n\\n/* description of graph node */\\nstruct stop {\\n    double col, row;\\n    /* array of indexes of routes from this stop to neighbours in array of all routes */\\n    int * n;\\n    int n_len;\\n    double f, g, h;\\n    int from;\\n};\\n\\nint ind[map_size_rows][map_size_cols] = {\\n    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1},\\n    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1},\\n    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1},\\n    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1},\\n    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1},\\n    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1},\\n    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1},\\n    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1},\\n    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1},\\n    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}\\n};\\n\\n/* description of route between two nodes */\\nstruct route {\\n    /* route has only one direction! */\\n    int x; /* index of stop in array of all stops of src of this route */\\n    int y; /* intex of stop in array of all stops od dst of this route */\\n    double d;\\n};\\n\\nint main() {\\n    int i, j, k, l, b, found;\\n    int p_len = 0;\\n    int * path = NULL;\\n    int c_len = 0;\\n    int * closed = NULL;\\n    int o_len = 1;\\n    int * open = (int*)calloc(o_len, sizeof(int));\\n    double min, tempg;\\n    int s;\\n    int e;\\n    int current;\\n    int s_len = 0;\\n    struct stop * stops = NULL;\\n    int r_len = 0;\\n    struct route * routes = NULL;\\n\\n    for (i = 1; i < map_size_rows - 1; i++) {\\n        for (j = 1; j < map_size_cols - 1; j++) {\\n            if (!map[i][j]) {\\n                ++s_len;\\n                stops = (struct stop *)realloc(stops, s_len * sizeof(struct stop));\\n                int t = s_len - 1;\\n                stops[t].col = j;\\n                stops[t].row = i;\\n                stops[t].from = -1;\\n                stops[t].g = DBL_MAX;\\n                stops[t].n_len = 0;\\n                stops[t].n = NULL;\\n                ind[i][j] = t;\\n            }\\n        }\\n    }\\n\\n    /* index of start stop */\\n    s = 0;\\n    /* index of finish stop */\\n    e = s_len - 1;\\n\\n    for (i = 0; i < s_len; i++) {\\n        stops[i].h = sqrt(pow(stops[e].row - stops[i].row, 2) + pow(stops[e].col - stops[i].col, 2));\\n    }\\n\\n    for (i = 1; i < map_size_rows - 1; i++) {\\n        for (j = 1; j < map_size_cols - 1; j++) {\\n            if (ind[i][j] >= 0) {\\n                for (k = i - 1; k <= i + 1; k++) {\\n                    for (l = j - 1; l <= j + 1; l++) {\\n                        if ((k == i) and (l == j)) {\\n                            continue;\\n                        }\\n                        if (ind[k][l] >= 0) {\\n                            ++r_len;\\n                            routes = (struct route *)realloc(routes, r_len * sizeof(struct route));\\n                            int t = r_len - 1;\\n                            routes[t].x = ind[i][j];\\n                            routes[t].y = ind[k][l];\\n                            routes[t].d = sqrt(pow(stops[routes[t].y].row - stops[routes[t].x].row, 2) + pow(stops[routes[t].y].col - stops[routes[t].x].col, 2));\\n                            ++stops[routes[t].x].n_len;\\n                            stops[routes[t].x].n = (int*)realloc(stops[routes[t].x].n, stops[routes[t].x].n_len * sizeof(int));\\n                            stops[routes[t].x].n[stops[routes[t].x].n_len - 1] = t;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    open[0] = s;\\n    stops[s].g = 0;\\n    stops[s].f = stops[s].g + stops[s].h;\\n    found = 0;\\n\\n    while (o_len and not found) {\\n        min = DBL_MAX;\\n\\n        for (i = 0; i < o_len; i++) {\\n            if (stops[open[i]].f < min) {\\n                current = open[i];\\n                min = stops[open[i]].f;\\n            }\\n        }\\n\\n        if (current == e) {\\n            found = 1;\\n\\n            ++p_len;\\n            path = (int*)realloc(path, p_len * sizeof(int));\\n            path[p_len - 1] = current;\\n            while (stops[current].from >= 0) {\\n                current = stops[current].from;\\n                ++p_len;\\n                path = (int*)realloc(path, p_len * sizeof(int));\\n                path[p_len - 1] = current;\\n            }\\n        }\\n\\n        for (i = 0; i < o_len; i++) {\\n            if (open[i] == current) {\\n                if (i not_eq (o_len - 1)) {\\n                    for (j = i; j < (o_len - 1); j++) {\\n                        open[j] = open[j + 1];\\n                    }\\n                }\\n                --o_len;\\n                open = (int*)realloc(open, o_len * sizeof(int));\\n                break;\\n            }\\n        }\\n\\n        ++c_len;\\n        closed = (int*)realloc(closed, c_len * sizeof(int));\\n        closed[c_len - 1] = current;\\n\\n        for (i = 0; i < stops[current].n_len; i++) {\\n            b = 0;\\n\\n            for (j = 0; j < c_len; j++) {\\n                if (routes[stops[current].n[i]].y == closed[j]) {\\n                    b = 1;\\n                }\\n            }\\n\\n            if (b) {\\n                continue;\\n            }\\n\\n            tempg = stops[current].g + routes[stops[current].n[i]].d;\\n\\n            b = 1;\\n\\n            if (o_len > 0) {\\n                for (j = 0; j < o_len; j++) {\\n                    if (routes[stops[current].n[i]].y == open[j]) {\\n                        b = 0;\\n                    }\\n                }\\n            }\\n\\n            if (b or (tempg < stops[routes[stops[current].n[i]].y].g)) {\\n                stops[routes[stops[current].n[i]].y].from = current;\\n                stops[routes[stops[current].n[i]].y].g = tempg;\\n                stops[routes[stops[current].n[i]].y].f = stops[routes[stops[current].n[i]].y].g + stops[routes[stops[current].n[i]].y].h;\\n\\n                if (b) {\\n                    ++o_len;\\n                    open = (int*)realloc(open, o_len * sizeof(int));\\n                    open[o_len - 1] = routes[stops[current].n[i]].y;\\n                }\\n            }\\n        }\\n    }\\n\\n    for (i = 0; i < map_size_rows; i++) {\\n        for (j = 0; j < map_size_cols; j++) {\\n            if (map[i][j]) {\\n                putchar(0xdb);\\n            } else {\\n                b = 0;\\n                for (k = 0; k < p_len; k++) {\\n                    if (ind[i][j] == path[k]) {\\n                        ++b;\\n                    }\\n                }\\n                if (b) {\\n                    putchar('x');\\n                } else {\\n                    putchar('.');\\n                }\\n            }\\n        }\\n        putchar('\\n');\\n    }\\n\\n    if (not found) {\\n        puts(\""IMPOSSIBLE\"");\\n    } else {\\n        printf(\""path cost is %d:\\n\"", p_len);\\n        for (i = p_len - 1; i >= 0; i--) {\\n            printf(\""(%1.0f, %1.0f)\\n\"", stops[path[i]].col, stops[path[i]].row);\\n        }\\n    }\\n\\n    for (i = 0; i < s_len; ++i) {\\n        free(stops[i].n);\\n    }\\n    free(stops);\\n    free(routes);\\n    free(path);\\n    free(open);\\n    free(closed);\\n\\n    return 0;\\n}\\n"
"C","A+B","A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.\\n\\nGiven two integers,   A and B.\\nTheir sum needs to be calculated.\\n\\nTwo integers are written in the input stream, separated by space(s):\\n\\nThe required output is one integer:   the sum of A and B.\\n\\n\\n","// Standard input-output streams\\n#include <stdio.h>\\nint main()\\n{\\n   int a, b;\\n   scanf(\""%d%d\"", &a, &b);\\n   printf(\""%d\\n\"", a + b);\\n   return 0;\\n}"
"C","A+B","A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.\\n\\nGiven two integers,   A and B.\\nTheir sum needs to be calculated.\\n\\nTwo integers are written in the input stream, separated by space(s):\\n\\nThe required output is one integer:   the sum of A and B.\\n\\n\\n","// Input file: input.txt\\n// Output file: output.txt\\n#include <stdio.h>\\nint main()\\n{\\n   freopen(\""input.txt\"", \""rt\"", stdin);\\n   freopen(\""output.txt\"", \""wt\"", stdout);\\n   int a, b;\\n   scanf(\""%d%d\"", &a, &b);\\n   printf(\""%d\\n\"", a + b);\\n   return 0;\\n}"
"C","A+B","A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.\\n\\nGiven two integers,   A and B.\\nTheir sum needs to be calculated.\\n\\nTwo integers are written in the input stream, separated by space(s):\\n\\nThe required output is one integer:   the sum of A and B.\\n\\n\\n","\\n#include <stdio.h>\\n#include <stdlib.h>\\nint main(int argc, char **argv) //not sure if argv counts as input stream... certainly it is brought here via input stream.\\n{\\n   printf(\""%d\\n\"", atoi(*(argv+1)) + atoi(*(argv+2)));\\n   return 0;\\n}\\n"
"C","ABC_Problem","\\nYou are given a collection of ABC blocks   (maybe like the ones you had when you were a kid).\\nThere are twenty blocks with two letters on each block.\\nA complete alphabet is guaranteed amongst all sides of the blocks.\\nThe sample collection of blocks:\\n\\nWrite a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks.\\n\\nThe rules are simple:\\n\\n\\nThe program uses one ASSIST macro (XPRNT) to keep the code as short as possible.\\n","#include <stdio.h>\\n#include <ctype.h>\\n\\nint can_make_words(char **b, char *word)\\n{\\n	int i, ret = 0, c = toupper(*word);\\n\\n#define SWAP(a, b) if (a != b) { char * tmp = a; a = b; b = tmp; }\\n\\n	if (!c) return 1;\\n	if (!b[0]) return 0;\\n\\n	for (i = 0; b[i] && !ret; i++) {\\n		if (b[i][0] != c && b[i][1] != c) continue;\\n		SWAP(b[i], b[0]);\\n		ret = can_make_words(b + 1, word + 1);\\n		SWAP(b[i], b[0]);\\n	}\\n\\n	return ret;\\n}\\n\\nint main(void)\\n{\\n	char* blocks[] = {\\n		\""BO\"", \""XK\"", \""DQ\"", \""CP\"", \""NA\"", \\n		\""GT\"", \""RE\"", \""TG\"", \""QD\"", \""FS\"", \\n		\""JW\"", \""HU\"", \""VI\"", \""AN\"", \""OB\"", \\n		\""ER\"", \""FS\"", \""LY\"", \""PC\"", \""ZM\"",\\n		0 };\\n\\n	char *words[] = {\\n		\""\"", \""A\"", \""BARK\"", \""BOOK\"", \""TREAT\"", \""COMMON\"", \""SQUAD\"", \""Confuse\"", 0\\n	};\\n\\n	char **w;\\n	for (w = words; *w; w++)\\n		printf(\""%s\\t%d\\n\"", *w, can_make_words(blocks, *w));\\n\\n	return 0;\\n}"
"C","Abstract_type","Abstract type is a type without instances or without definition.\\nFor example in object-oriented programming using some languages, abstract types can be partial implementations of other types, which are to be derived there-from. An abstract type may provide implementation of some operations and/or components. Abstract types without any implementation are called interfaces. In the languages that do not support multiple inheritance (Ada, Java), classes can, nonetheless, inherit from multiple interfaces. The languages with multiple inheritance (like C++) usually make no distinction between partially implementable abstract types and interfaces. Because the abstract type's implementation is incomplete,  OO languages normally prevent instantiation from them (instantiation must derived from one of their descendant classes).\\nThe term abstract datatype also may denote a type, with an implementation provided by the programmer rather than directly by the language (a built-in or an inferred type). Here the word abstract means that the implementation is abstracted away, irrelevant for the user of the type. Such implementation can and should be hidden if the language supports separation of implementation and specification. This hides complexity while allowing the implementation to change without repercussions on the usage. The corresponding software design practice is said to follow the information hiding principle.\\nIt is important not to confuse this abstractness (of implementation) with one of the abstract type. The latter is abstract in the sense that the set of its values is empty. In the sense of implementation abstracted away, all user-defined types are abstract.\\nIn some languages, like for example in Objective Caml which is strongly statically typed, it is also possible to have abstract types that are not OO related and are not an abstractness too. These are pure abstract types without any definition even in the implementation and can be used for example for the type algebra, or for some consistence of the type inference. For example in this area, an abstract type can be used as a phantom type to augment another type as its parameter.\\nTask: show how an abstract type can be declared in the language. If the language makes a distinction between interfaces and partially implemented types illustrate both.\\n\\nInterfaces in ABAP are classes with the following restrictions:\\n1. All methods must be abstract instance methods (Static methods aren't allowed).\\n2. Variables must be static final. The values may be computed at run time.\\n3. No static initialiser blockers. No static initialiser helper methods.\\nWhile ActionScript does not support explicit abstract classes, it does have interfaces. Interfaces in ActionScript may not implement any methods and all methods are public and implicitly abstract. Interfaces can extend other interfaces, and interfaces may be multiply inherited.\\nAbstract types can also be simulated using the built-in flash.utils.getQualifiedClassName() function in the constructor to check that the runtime type is an inhertied class, and throwing exceptions from \""abstract\"" methods which can be overridden by inheritors to disable them. If any inheriting class does not implement an abstract method, the error will not be thrown until the non-implemented method is called.\\nInheriting this class:\\nInterfaces in Ada may have no components or implemented operation except for ones implemented as null operations. Interfaces can be multiply inherited.\\nInterfaces can be declared synchronized or task when intended implementations are to be provided by protected objects or tasks. For example:\\nAbstract types may provide components and implementation of their operations. Abstract types are singly inherited.\\nHere Node is an abstract type that is inherited from Limited_Controlled and implements a node of a  doubly linked list. It also implements the interface of a queue described above, because any node can be considered a head of the queue of linked elements. For the operation Finalize an implementation is provided to ensure that the element of a list is removed from there upon its finalization. The operation itself is inherited from the parent type Limited_Controlled and then overridden. The operations Dequeue and Enqueue of the Queue interface are also implemented.\\nUsing records for storing the interface methods and instance arguments (which are similar to Haskell type classes) for overloading:\\nThere is dog and cat is objects of different types for which the interface method is implemented.\\nAn abstract class contains functions that have no body defined. You cannot instantiate a class that contains abstract functions.\\nInterfaces in Aikido define a set of functions, operators, classes, interfaces, monitors or threads (but no variables) that must be implemented by a class implementing the interface.\\nIn AmigaE, abstract methods are supported but interfaces are not.\\nprints to the console:\\nred orange\\n\\nBBC BASIC is a procedural language with no built-in OO features. The CLASSLIB library implements simple Object Classes with multiple inheritance; an abstract class may be created without any instantiation, the sole purpose of which is for other classes to inherit from it. At least one member or method must be declared, but no error will be generated if there is no implementation:\\nDoing abstract types in C is not particularly trivial as C doesn't really support classes. The following series will show an abstract type, followed by a realizable class that provides the abstract interface, and finally followed by an example of usage.\\nThe header file for the abstract class, interfaceAbs.h\\nThat will define the abstract class. The next section declares a public interface for a class providing the interface of the abstract class. This class is Silly and\\nthe code is in file silly.h. Note the actual structure of the class is not provided\\nhere. We don't want it visible.\\nOk. Now it is necessary to provide the implementation of the realizable class.\\nThis code should be in silly.c.\\nThat last macro, ABSTRACT_METHODS may need a little explanation. First note that macros do a string substitution of the parameter values into the arguments of the defined macro, with a little hitch. In the macro definition the ' ## ' expression is special. Here cName ## _Iface gets converted to Silly_Iface, as 'Silly' replaces cName. So the macro call declares an instance of the class record, and defines a constructor named Silly_Instance, which takes a Silly structure as an arguments\\nand uses the class record it previously set up as well.\\nThe methods MyMethod1, MyMethod2, and MyMethod3 are called through the abstract class interface and do not need to be visible outside this file. Hence, they are declared static.\\nNow all's left is some example code that uses all this stuff.\\nYou can declare a virtual function to not have an implementation (called \""pure virtual function\"") by the following \""= 0\"" syntax after the method declaration. A class containing at least one pure virtual function (or inheriting one and not overriding it) cannot be instantiated.\\nBecause C++ allows multiple inheritance of classes, no distinction is made between interfaces and abstract classes.\\nIn Caché, abstract and data type classes cannot be instantiated directly - there must be a 'concrete subclass' that extends them as well as the '%RegisteredObject' class in order to instantiate an object, see example below.\\nData type classes differ because they cannot contain properties, see example below.\\nBoth class types can contain implementation code. Caché allows multiple inheritance of classes, so no distinction is made between abstract classes and interfaces.\\n","#ifndef INTERFACE_ABS\\n#define INTERFACE_ABS\\n\\ntypedef struct sAbstractCls *AbsCls;\\n\\ntypedef struct sAbstractMethods {\\n    int         (*method1)(AbsCls c, int a);\\n    const char *(*method2)(AbsCls c, int b);\\n    void        (*method3)(AbsCls c, double d);\\n} *AbstractMethods, sAbsMethods;\\n\\nstruct sAbstractCls {\\n    AbstractMethods  klass;\\n    void     *instData;\\n};\\n\\n#define ABSTRACT_METHODS( cName, m1, m2, m3 ) \\\\n    static sAbsMethods cName ## _Iface = { &m1, &m2, &m3 }; \\\\n    AbsCls cName ## _Instance( void *clInst) { \\\\n        AbsCls ac = malloc(sizeof(struct sAbstractCls)); \\\\n        if (ac) { \\\\n            ac->klass = &cName ## _Iface; \\\\n            ac->instData = clInst; \\\\n        }\\\\n        return ac; }\\n\\n#define Abs_Method1( c, a) (c)->klass->method1(c, a)\\n#define Abs_Method2( c, b) (c)->klass->method2(c, b)\\n#define Abs_Method3( c, d) (c)->klass->method3(c, d)\\n#define Abs_Free(c) \\\\n  do { if (c) { free((c)->instData); free(c); } } while(0);\\n \\n#endif"
"C","Abstract_type","Abstract type is a type without instances or without definition.\\nFor example in object-oriented programming using some languages, abstract types can be partial implementations of other types, which are to be derived there-from. An abstract type may provide implementation of some operations and/or components. Abstract types without any implementation are called interfaces. In the languages that do not support multiple inheritance (Ada, Java), classes can, nonetheless, inherit from multiple interfaces. The languages with multiple inheritance (like C++) usually make no distinction between partially implementable abstract types and interfaces. Because the abstract type's implementation is incomplete,  OO languages normally prevent instantiation from them (instantiation must derived from one of their descendant classes).\\nThe term abstract datatype also may denote a type, with an implementation provided by the programmer rather than directly by the language (a built-in or an inferred type). Here the word abstract means that the implementation is abstracted away, irrelevant for the user of the type. Such implementation can and should be hidden if the language supports separation of implementation and specification. This hides complexity while allowing the implementation to change without repercussions on the usage. The corresponding software design practice is said to follow the information hiding principle.\\nIt is important not to confuse this abstractness (of implementation) with one of the abstract type. The latter is abstract in the sense that the set of its values is empty. In the sense of implementation abstracted away, all user-defined types are abstract.\\nIn some languages, like for example in Objective Caml which is strongly statically typed, it is also possible to have abstract types that are not OO related and are not an abstractness too. These are pure abstract types without any definition even in the implementation and can be used for example for the type algebra, or for some consistence of the type inference. For example in this area, an abstract type can be used as a phantom type to augment another type as its parameter.\\nTask: show how an abstract type can be declared in the language. If the language makes a distinction between interfaces and partially implemented types illustrate both.\\n\\nInterfaces in ABAP are classes with the following restrictions:\\n1. All methods must be abstract instance methods (Static methods aren't allowed).\\n2. Variables must be static final. The values may be computed at run time.\\n3. No static initialiser blockers. No static initialiser helper methods.\\nWhile ActionScript does not support explicit abstract classes, it does have interfaces. Interfaces in ActionScript may not implement any methods and all methods are public and implicitly abstract. Interfaces can extend other interfaces, and interfaces may be multiply inherited.\\nAbstract types can also be simulated using the built-in flash.utils.getQualifiedClassName() function in the constructor to check that the runtime type is an inhertied class, and throwing exceptions from \""abstract\"" methods which can be overridden by inheritors to disable them. If any inheriting class does not implement an abstract method, the error will not be thrown until the non-implemented method is called.\\nInheriting this class:\\nInterfaces in Ada may have no components or implemented operation except for ones implemented as null operations. Interfaces can be multiply inherited.\\nInterfaces can be declared synchronized or task when intended implementations are to be provided by protected objects or tasks. For example:\\nAbstract types may provide components and implementation of their operations. Abstract types are singly inherited.\\nHere Node is an abstract type that is inherited from Limited_Controlled and implements a node of a  doubly linked list. It also implements the interface of a queue described above, because any node can be considered a head of the queue of linked elements. For the operation Finalize an implementation is provided to ensure that the element of a list is removed from there upon its finalization. The operation itself is inherited from the parent type Limited_Controlled and then overridden. The operations Dequeue and Enqueue of the Queue interface are also implemented.\\nUsing records for storing the interface methods and instance arguments (which are similar to Haskell type classes) for overloading:\\nThere is dog and cat is objects of different types for which the interface method is implemented.\\nAn abstract class contains functions that have no body defined. You cannot instantiate a class that contains abstract functions.\\nInterfaces in Aikido define a set of functions, operators, classes, interfaces, monitors or threads (but no variables) that must be implemented by a class implementing the interface.\\nIn AmigaE, abstract methods are supported but interfaces are not.\\nprints to the console:\\nred orange\\n\\nBBC BASIC is a procedural language with no built-in OO features. The CLASSLIB library implements simple Object Classes with multiple inheritance; an abstract class may be created without any instantiation, the sole purpose of which is for other classes to inherit from it. At least one member or method must be declared, but no error will be generated if there is no implementation:\\nDoing abstract types in C is not particularly trivial as C doesn't really support classes. The following series will show an abstract type, followed by a realizable class that provides the abstract interface, and finally followed by an example of usage.\\nThe header file for the abstract class, interfaceAbs.h\\nThat will define the abstract class. The next section declares a public interface for a class providing the interface of the abstract class. This class is Silly and\\nthe code is in file silly.h. Note the actual structure of the class is not provided\\nhere. We don't want it visible.\\nOk. Now it is necessary to provide the implementation of the realizable class.\\nThis code should be in silly.c.\\nThat last macro, ABSTRACT_METHODS may need a little explanation. First note that macros do a string substitution of the parameter values into the arguments of the defined macro, with a little hitch. In the macro definition the ' ## ' expression is special. Here cName ## _Iface gets converted to Silly_Iface, as 'Silly' replaces cName. So the macro call declares an instance of the class record, and defines a constructor named Silly_Instance, which takes a Silly structure as an arguments\\nand uses the class record it previously set up as well.\\nThe methods MyMethod1, MyMethod2, and MyMethod3 are called through the abstract class interface and do not need to be visible outside this file. Hence, they are declared static.\\nNow all's left is some example code that uses all this stuff.\\nYou can declare a virtual function to not have an implementation (called \""pure virtual function\"") by the following \""= 0\"" syntax after the method declaration. A class containing at least one pure virtual function (or inheriting one and not overriding it) cannot be instantiated.\\nBecause C++ allows multiple inheritance of classes, no distinction is made between interfaces and abstract classes.\\nIn Caché, abstract and data type classes cannot be instantiated directly - there must be a 'concrete subclass' that extends them as well as the '%RegisteredObject' class in order to instantiate an object, see example below.\\nData type classes differ because they cannot contain properties, see example below.\\nBoth class types can contain implementation code. Caché allows multiple inheritance of classes, so no distinction is made between abstract classes and interfaces.\\n","#ifndef SILLY_H\\n#define SILLY_H\\n#include \""intefaceAbs.h\""\\n#include <stdlib.h>\\n\\ntypedef struct sillyStruct *Silly;\\nextern Silly NewSilly( double, const char *);\\nextern AbsCls Silly_Instance(void *); \\n\\n#endif"
"C","Abstract_type","Abstract type is a type without instances or without definition.\\nFor example in object-oriented programming using some languages, abstract types can be partial implementations of other types, which are to be derived there-from. An abstract type may provide implementation of some operations and/or components. Abstract types without any implementation are called interfaces. In the languages that do not support multiple inheritance (Ada, Java), classes can, nonetheless, inherit from multiple interfaces. The languages with multiple inheritance (like C++) usually make no distinction between partially implementable abstract types and interfaces. Because the abstract type's implementation is incomplete,  OO languages normally prevent instantiation from them (instantiation must derived from one of their descendant classes).\\nThe term abstract datatype also may denote a type, with an implementation provided by the programmer rather than directly by the language (a built-in or an inferred type). Here the word abstract means that the implementation is abstracted away, irrelevant for the user of the type. Such implementation can and should be hidden if the language supports separation of implementation and specification. This hides complexity while allowing the implementation to change without repercussions on the usage. The corresponding software design practice is said to follow the information hiding principle.\\nIt is important not to confuse this abstractness (of implementation) with one of the abstract type. The latter is abstract in the sense that the set of its values is empty. In the sense of implementation abstracted away, all user-defined types are abstract.\\nIn some languages, like for example in Objective Caml which is strongly statically typed, it is also possible to have abstract types that are not OO related and are not an abstractness too. These are pure abstract types without any definition even in the implementation and can be used for example for the type algebra, or for some consistence of the type inference. For example in this area, an abstract type can be used as a phantom type to augment another type as its parameter.\\nTask: show how an abstract type can be declared in the language. If the language makes a distinction between interfaces and partially implemented types illustrate both.\\n\\nInterfaces in ABAP are classes with the following restrictions:\\n1. All methods must be abstract instance methods (Static methods aren't allowed).\\n2. Variables must be static final. The values may be computed at run time.\\n3. No static initialiser blockers. No static initialiser helper methods.\\nWhile ActionScript does not support explicit abstract classes, it does have interfaces. Interfaces in ActionScript may not implement any methods and all methods are public and implicitly abstract. Interfaces can extend other interfaces, and interfaces may be multiply inherited.\\nAbstract types can also be simulated using the built-in flash.utils.getQualifiedClassName() function in the constructor to check that the runtime type is an inhertied class, and throwing exceptions from \""abstract\"" methods which can be overridden by inheritors to disable them. If any inheriting class does not implement an abstract method, the error will not be thrown until the non-implemented method is called.\\nInheriting this class:\\nInterfaces in Ada may have no components or implemented operation except for ones implemented as null operations. Interfaces can be multiply inherited.\\nInterfaces can be declared synchronized or task when intended implementations are to be provided by protected objects or tasks. For example:\\nAbstract types may provide components and implementation of their operations. Abstract types are singly inherited.\\nHere Node is an abstract type that is inherited from Limited_Controlled and implements a node of a  doubly linked list. It also implements the interface of a queue described above, because any node can be considered a head of the queue of linked elements. For the operation Finalize an implementation is provided to ensure that the element of a list is removed from there upon its finalization. The operation itself is inherited from the parent type Limited_Controlled and then overridden. The operations Dequeue and Enqueue of the Queue interface are also implemented.\\nUsing records for storing the interface methods and instance arguments (which are similar to Haskell type classes) for overloading:\\nThere is dog and cat is objects of different types for which the interface method is implemented.\\nAn abstract class contains functions that have no body defined. You cannot instantiate a class that contains abstract functions.\\nInterfaces in Aikido define a set of functions, operators, classes, interfaces, monitors or threads (but no variables) that must be implemented by a class implementing the interface.\\nIn AmigaE, abstract methods are supported but interfaces are not.\\nprints to the console:\\nred orange\\n\\nBBC BASIC is a procedural language with no built-in OO features. The CLASSLIB library implements simple Object Classes with multiple inheritance; an abstract class may be created without any instantiation, the sole purpose of which is for other classes to inherit from it. At least one member or method must be declared, but no error will be generated if there is no implementation:\\nDoing abstract types in C is not particularly trivial as C doesn't really support classes. The following series will show an abstract type, followed by a realizable class that provides the abstract interface, and finally followed by an example of usage.\\nThe header file for the abstract class, interfaceAbs.h\\nThat will define the abstract class. The next section declares a public interface for a class providing the interface of the abstract class. This class is Silly and\\nthe code is in file silly.h. Note the actual structure of the class is not provided\\nhere. We don't want it visible.\\nOk. Now it is necessary to provide the implementation of the realizable class.\\nThis code should be in silly.c.\\nThat last macro, ABSTRACT_METHODS may need a little explanation. First note that macros do a string substitution of the parameter values into the arguments of the defined macro, with a little hitch. In the macro definition the ' ## ' expression is special. Here cName ## _Iface gets converted to Silly_Iface, as 'Silly' replaces cName. So the macro call declares an instance of the class record, and defines a constructor named Silly_Instance, which takes a Silly structure as an arguments\\nand uses the class record it previously set up as well.\\nThe methods MyMethod1, MyMethod2, and MyMethod3 are called through the abstract class interface and do not need to be visible outside this file. Hence, they are declared static.\\nNow all's left is some example code that uses all this stuff.\\nYou can declare a virtual function to not have an implementation (called \""pure virtual function\"") by the following \""= 0\"" syntax after the method declaration. A class containing at least one pure virtual function (or inheriting one and not overriding it) cannot be instantiated.\\nBecause C++ allows multiple inheritance of classes, no distinction is made between interfaces and abstract classes.\\nIn Caché, abstract and data type classes cannot be instantiated directly - there must be a 'concrete subclass' that extends them as well as the '%RegisteredObject' class in order to instantiate an object, see example below.\\nData type classes differ because they cannot contain properties, see example below.\\nBoth class types can contain implementation code. Caché allows multiple inheritance of classes, so no distinction is made between abstract classes and interfaces.\\n","#include \""silly.h\""\\n#include <string.h>\\n#include <stdio.h>\\n\\nstruct sillyStruct {\\n    double  v1;\\n    char   str[32];\\n};\\n\\nSilly NewSilly(double vInit, const char *strInit)\\n{\\n    Silly sily = malloc(sizeof( struct sillyStruct ));\\n    sily->v1 = vInit;\\n    sily->str[0] = '\\0';\\n    strncat(sily->str, strInit, 31);\\n    return sily;\\n}\\n\\nstatic\\nint MyMethod1(  AbsCls c, int a)\\n{\\n    Silly s = (Silly)(c->instData);\\n    return a+strlen(s->str);\\n}\\n\\nstatic\\nconst char *MyMethod2(AbsCls c, int b)\\n{\\n    Silly s = (Silly)(c->instData);\\n    sprintf(s->str, \""%d\"", b);\\n    return s->str;\\n}\\n\\nstatic\\nvoid  MyMethod3(AbsCls c, double d)\\n{\\n    Silly s = (Silly)(c->instData);\\n    printf(\""InMyMethod3, %f\\n\"",s->v1 * d);\\n}\\n\\nABSTRACT_METHODS( Silly, MyMethod1, MyMethod2, MyMethod3)"
"C","Abstract_type","Abstract type is a type without instances or without definition.\\nFor example in object-oriented programming using some languages, abstract types can be partial implementations of other types, which are to be derived there-from. An abstract type may provide implementation of some operations and/or components. Abstract types without any implementation are called interfaces. In the languages that do not support multiple inheritance (Ada, Java), classes can, nonetheless, inherit from multiple interfaces. The languages with multiple inheritance (like C++) usually make no distinction between partially implementable abstract types and interfaces. Because the abstract type's implementation is incomplete,  OO languages normally prevent instantiation from them (instantiation must derived from one of their descendant classes).\\nThe term abstract datatype also may denote a type, with an implementation provided by the programmer rather than directly by the language (a built-in or an inferred type). Here the word abstract means that the implementation is abstracted away, irrelevant for the user of the type. Such implementation can and should be hidden if the language supports separation of implementation and specification. This hides complexity while allowing the implementation to change without repercussions on the usage. The corresponding software design practice is said to follow the information hiding principle.\\nIt is important not to confuse this abstractness (of implementation) with one of the abstract type. The latter is abstract in the sense that the set of its values is empty. In the sense of implementation abstracted away, all user-defined types are abstract.\\nIn some languages, like for example in Objective Caml which is strongly statically typed, it is also possible to have abstract types that are not OO related and are not an abstractness too. These are pure abstract types without any definition even in the implementation and can be used for example for the type algebra, or for some consistence of the type inference. For example in this area, an abstract type can be used as a phantom type to augment another type as its parameter.\\nTask: show how an abstract type can be declared in the language. If the language makes a distinction between interfaces and partially implemented types illustrate both.\\n\\nInterfaces in ABAP are classes with the following restrictions:\\n1. All methods must be abstract instance methods (Static methods aren't allowed).\\n2. Variables must be static final. The values may be computed at run time.\\n3. No static initialiser blockers. No static initialiser helper methods.\\nWhile ActionScript does not support explicit abstract classes, it does have interfaces. Interfaces in ActionScript may not implement any methods and all methods are public and implicitly abstract. Interfaces can extend other interfaces, and interfaces may be multiply inherited.\\nAbstract types can also be simulated using the built-in flash.utils.getQualifiedClassName() function in the constructor to check that the runtime type is an inhertied class, and throwing exceptions from \""abstract\"" methods which can be overridden by inheritors to disable them. If any inheriting class does not implement an abstract method, the error will not be thrown until the non-implemented method is called.\\nInheriting this class:\\nInterfaces in Ada may have no components or implemented operation except for ones implemented as null operations. Interfaces can be multiply inherited.\\nInterfaces can be declared synchronized or task when intended implementations are to be provided by protected objects or tasks. For example:\\nAbstract types may provide components and implementation of their operations. Abstract types are singly inherited.\\nHere Node is an abstract type that is inherited from Limited_Controlled and implements a node of a  doubly linked list. It also implements the interface of a queue described above, because any node can be considered a head of the queue of linked elements. For the operation Finalize an implementation is provided to ensure that the element of a list is removed from there upon its finalization. The operation itself is inherited from the parent type Limited_Controlled and then overridden. The operations Dequeue and Enqueue of the Queue interface are also implemented.\\nUsing records for storing the interface methods and instance arguments (which are similar to Haskell type classes) for overloading:\\nThere is dog and cat is objects of different types for which the interface method is implemented.\\nAn abstract class contains functions that have no body defined. You cannot instantiate a class that contains abstract functions.\\nInterfaces in Aikido define a set of functions, operators, classes, interfaces, monitors or threads (but no variables) that must be implemented by a class implementing the interface.\\nIn AmigaE, abstract methods are supported but interfaces are not.\\nprints to the console:\\nred orange\\n\\nBBC BASIC is a procedural language with no built-in OO features. The CLASSLIB library implements simple Object Classes with multiple inheritance; an abstract class may be created without any instantiation, the sole purpose of which is for other classes to inherit from it. At least one member or method must be declared, but no error will be generated if there is no implementation:\\nDoing abstract types in C is not particularly trivial as C doesn't really support classes. The following series will show an abstract type, followed by a realizable class that provides the abstract interface, and finally followed by an example of usage.\\nThe header file for the abstract class, interfaceAbs.h\\nThat will define the abstract class. The next section declares a public interface for a class providing the interface of the abstract class. This class is Silly and\\nthe code is in file silly.h. Note the actual structure of the class is not provided\\nhere. We don't want it visible.\\nOk. Now it is necessary to provide the implementation of the realizable class.\\nThis code should be in silly.c.\\nThat last macro, ABSTRACT_METHODS may need a little explanation. First note that macros do a string substitution of the parameter values into the arguments of the defined macro, with a little hitch. In the macro definition the ' ## ' expression is special. Here cName ## _Iface gets converted to Silly_Iface, as 'Silly' replaces cName. So the macro call declares an instance of the class record, and defines a constructor named Silly_Instance, which takes a Silly structure as an arguments\\nand uses the class record it previously set up as well.\\nThe methods MyMethod1, MyMethod2, and MyMethod3 are called through the abstract class interface and do not need to be visible outside this file. Hence, they are declared static.\\nNow all's left is some example code that uses all this stuff.\\nYou can declare a virtual function to not have an implementation (called \""pure virtual function\"") by the following \""= 0\"" syntax after the method declaration. A class containing at least one pure virtual function (or inheriting one and not overriding it) cannot be instantiated.\\nBecause C++ allows multiple inheritance of classes, no distinction is made between interfaces and abstract classes.\\nIn Caché, abstract and data type classes cannot be instantiated directly - there must be a 'concrete subclass' that extends them as well as the '%RegisteredObject' class in order to instantiate an object, see example below.\\nData type classes differ because they cannot contain properties, see example below.\\nBoth class types can contain implementation code. Caché allows multiple inheritance of classes, so no distinction is made between abstract classes and interfaces.\\n","#include <stdio.h>\\n#include \""silly.h\""\\n\\nint main()\\n{\\n    AbsCls abster = Silly_Instance(NewSilly( 10.1, \""Green Tomato\""));\\n\\n    printf(\""AbsMethod1: %d\\n\"", Abs_Method1(abster, 5));\\n    printf(\""AbsMethod2: %s\\n\"", Abs_Method2(abster, 4));\\n    Abs_Method3(abster, 21.55);\\n    Abs_Free(abster);\\n    return 0;\\n}\\n"
"C","Abundant,_deficient_and_perfect_number_classifications","These define three classifications of positive integers based on their   proper divisors.\\nLet   P(n)   be the sum of the proper divisors of   n   where the proper divisors are all positive divisors of   n   other than   n   itself.\\n\\n6   has proper divisors of   1,   2,   and   3.\\n1 + 2 + 3 = 6,   so   6   is classed as a perfect number.\\n\\nCalculate how many of the integers   1   to   20,000   (inclusive) are in each of the three classes.\\nShow the results here.\\n\\n\\n","\\n#include<stdio.h>\\n#define de 0\\n#define pe 1\\n#define ab 2\\n\\nint main(){\\n	int sum = 0, i, j;\\n	int try_max = 0;\\n	//1 is deficient by default and can add it deficient list\\n	int   count_list[3] = {1,0,0};\\n	for(i=2; i <= 20000; i++){\\n		//Set maximum to check for proper division\\n		try_max = i/2;\\n		//1 is in all proper division number\\n		sum = 1;\\n		for(j=2; j i){\\n			count_list[ab]++;\\n			continue;\\n		}\\n		count_list[pe]++;\\n	}\\n	printf(\""\\nThere are %d deficient,\"" ,count_list[de]);\\n	printf(\"" %d perfect,\"" ,count_list[pe]);\\n	printf(\"" %d abundant numbers between 1 and 20000.\\n\"" ,count_list[ab]);\\nreturn 0;\\n}\\n"
"C","Accumulator_factory","A problem posed by Paul Graham is that of creating a function that takes a single (numeric) argument and which returns another function that is an accumulator. The returned accumulator function in turn also takes a single numeric argument, and returns the sum of all the numeric values passed in so far to that accumulator (including the initial value passed when the accumulator was created).\\n\\nThe detailed rules are at http://paulgraham.com/accgensub.html and are reproduced here for simplicity (with additions in small italic text).\\n\\nCreate a function that implements the described rules.\\n\\nIt need not handle any special error cases not described above. The simplest way to implement the task as described is typically to use a closure, providing the language supports them.\\nWhere it is not possible to hold exactly to the constraints above, describe the deviations.\\n\\n","#include <stdio.h>\\n//~ Take a number n and return a function that takes a number i\\n#define ACCUMULATOR(name,n) __typeof__(n) name (__typeof__(n) i) { \\\\n    static __typeof__(n) _n=n; LOGIC; }\\n//~ have it return n incremented by the accumulation of i\\n#define LOGIC return _n+=i\\nACCUMULATOR(x,1.0)\\nACCUMULATOR(y,3)\\nACCUMULATOR(z,'a')\\n#undef LOGIC\\nint main (void) {\\n    printf (\""%f\\n\"", x(5));   /* 6.000000 */\\n    printf (\""%f\\n\"", x(2.3)); /* 8.300000 */\\n    printf (\""%i\\n\"", y(5.0)); /* 8 */\\n    printf (\""%i\\n\"", y(3.3)); /* 11 */\\n    printf (\""%c\\n\"", z(5));   /* f */\\n    return 0;\\n}"
"C","Ackermann_function","The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.\\n\\nThe Ackermann function is usually defined as follows:\\n\\n","#include <stdio.h>\\n\\nint ackermann(int m, int n)\\n{\\n        if (!m) return n + 1;\\n        if (!n) return ackermann(m - 1, 1);\\n        return ackermann(m - 1, ackermann(m, n - 1));\\n}\\n\\nint main()\\n{\\n        int m, n;\\n        for (m = 0; m <= 4; m++)\\n                for (n = 0; n < 6 - m; n++)\\n                        printf(\""A(%d, %d) = %d\\n\"", m, n, ackermann(m, n));\\n\\n        return 0;\\n}"
"C","Ackermann_function","The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.\\n\\nThe Ackermann function is usually defined as follows:\\n\\n","#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\nint m_bits, n_bits;\\nint *cache;\\n\\nint ackermann(int m, int n)\\n{\\n        int idx, res;\\n        if (!m) return n + 1;\\n\\n        if (n >= 1<\\n{{out}}\\n<pre>A(0, 0) = 1\\nA(0, 1) = 2\\nA(0, 2) = 3\\nA(0, 3) = 4\\nA(0, 4) = 5\\nA(0, 5) = 6\\nA(1, 0) = 2\\nA(1, 1) = 3\\nA(1, 2) = 4\\nA(1, 3) = 5\\nA(1, 4) = 6\\nA(2, 0) = 3\\nA(2, 1) = 5\\nA(2, 2) = 7\\nA(2, 3) = 9\\nA(3, 0) = 5\\nA(3, 1) = 13\\nA(3, 2) = 29\\nA(4, 0) = 13\\nA(4, 1) = 65533"
"C","Active_Directory/Connect","The task is to establish a connection to an Active Directory or Lightweight Directory Access Protocol server.\\nWith OpenLDAP:\\n\\n\\nBased on dopenldap.\\nThis needs a test case. Is there a LDAP server available?\\nFor Active Directory we use the library System.DirectoryServicesFor your average LDAP server we use System.DirectoryServices.ProtocolFor a minimal example we make an anonymous connect to the local machine on the well-known LDAP port 389\\nlet ldapServer = new System.DirectoryServices.Protocols.LdapDirectoryIdentifier(\""127.0.0.1\"")let connect = new System.DirectoryServices.Protocols.LdapConnection(ldapServer)connect.Bind()\\nGo[edit]\\nLibrary: go-ldap-client\\n\\nThere are a large number of third-party LDAP libraries for Go. This uses one of the simpler ones and the code below is largely taken from the example on its main page.\\n\\npackage main import (    \""log\""    \""github.com/jtblin/go-ldap-client\"") func main() {    client := &ldap.LDAPClient{        Base:         \""dc=example,dc=com\"",        Host:         \""ldap.example.com\"",        Port:         389,        UseSSL:       false,        BindDN:       \""uid=readonlyuser,ou=People,dc=example,dc=com\"",        BindPassword: \""readonlypassword\"",        UserFilter:   \""(uid=%s)\"",        GroupFilter:  \""(memberUid=%s)\"",        Attributes:   []string{\""givenName\"", \""sn\"", \""mail\"", \""uid\""},    }    defer client.Close()    err := client.Connect()    if err != nil {         log.Fatalf(\""Failed to connect : %+v\"", err)    }    // Do something}\\nHaskell[edit]\\nExample uses the ldap-client package:\\n\\n{-# LANGUAGE OverloadedStrings #-} module Main (main) where import           Data.Foldable (for_)import qualified Data.Text.Encoding as Text (encodeUtf8)import           Ldap.Client (Attr(..), Filter(..))import qualified Ldap.Client as Ldap (Dn(..), Host(..), search, with, typesOnly) main :: IO ()main = do    entries <- Ldap.with (Ldap.Plain \""localhost\"") 389 $ \\ldap ->        Ldap.search ldap (Ldap.Dn \""o=example.com\"") (Ldap.typesOnly True) (Attr \""uid\"" := Text.encodeUtf8 \""user\"") []    for_ entries $ \\entry ->        print entry\\nJava[edit]\\nThis code uses the Apache Directory third-party library.\\n\\nimport java.io.IOException;import org.apache.directory.api.ldap.model.exception.LdapException;import org.apache.directory.ldap.client.api.LdapConnection;import org.apache.directory.ldap.client.api.LdapNetworkConnection; public class LdapConnectionDemo {     public static void main(String[] args) throws LdapException, IOException {        try (LdapConnection connection = new LdapNetworkConnection(\""localhost\"", 10389)) {            connection.bind();            connection.unBind();        }    }}\\nKotlin[edit]\\n import org.apache.directory.api.ldap.model.exception.LdapExceptionimport org.apache.directory.ldap.client.api.LdapNetworkConnectionimport java.io.IOExceptionimport java.util.logging.Levelimport java.util.logging.Logger class LDAP(map: Map<String, String>) {    fun run() {        var connection: LdapNetworkConnection? = null        try {            if (info) log.info(\""LDAP Connection to $hostname on port $port\"")            connection = LdapNetworkConnection(hostname, port.toInt())             try {                if (info) log.info(\""LDAP bind\"")                connection.bind()            } catch (e: LdapException) {                log.severe(e.toString())            }             try {                if (info) log.info(\""LDAP unbind\"")                connection.unBind()            } catch (e: LdapException) {                log.severe(e.toString())            }        } finally {            try {                if (info) log.info(\""LDAP close connection\"")                connection!!.close()            } catch (e: IOException) {                log.severe(e.toString())            }        }    }     private val log = Logger.getLogger(LDAP::class.java.name)    private val info = log.isLoggable(Level.INFO)    private val hostname: String by map    private val port: String by map} fun main(args: Array<String>) = LDAP(mapOf(\""hostname\"" to \""localhost\"", \""port\""  to \""10389\"")).run() \\nNetRexx[edit]\\nUses the Apache LDAP API, connecting to a local ApacheDS LDAP directory server.\\n\\n/* NetRexx */options replace format comments java crossref symbols binary import org.apache.directory.ldap.client.api.LdapConnectionimport org.apache.directory.ldap.client.api.LdapNetworkConnectionimport org.apache.directory.shared.ldap.model.exception.LdapExceptionimport org.slf4j.Loggerimport org.slf4j.LoggerFactory class RDirectoryLDAP public   properties constant    log_ = LoggerFactory.getLogger(RDirectoryLDAP.class)   properties private static    connection = LdapConnection null   method main(args = String[]) public static    ldapHostName = String \""localhost\""    ldapPort = int 10389     if log_.isInfoEnabled() then log_.info(\""LDAP Connection to\"" ldapHostName \""on port\"" ldapPort)    connection = LdapNetworkConnection(ldapHostName, ldapPort)     do      if log_.isTraceEnabled() then log_.trace(\""LDAP bind\"")      connection.bind()       if log_.isTraceEnabled() then log_.trace(\""LDAP unbind\"")      connection.unBind()    catch lex = LdapException      log_.error(\""LDAP Error\"", Throwable lex)    catch iox = IOException      log_.error(\""I/O Error\"", Throwable iox)    finally      do      if connection \\= null then connection.close()      catch iox = IOException        log_.error(\""I/O Error on connection.close()\"", Throwable iox)      end    end     return \\nSample log4j.xml configuration file:\\n\\n<?xml version=\""1.0\"" encoding=\""UTF-8\"" ?><!DOCTYPE log4j:configuration SYSTEM \""log4j.dtd\""><log4j:configuration xmlns:log4j='http://jakarta.apache.org/log4j/'>  <appender name=\""stdout\"" class=\""org.apache.log4j.ConsoleAppender\"">    <param name=\""Target\"" value=\""System.out\"" />    <layout class=\""org.apache.log4j.PatternLayout\"">      <param name=\""ConversionPattern\"" value=\""[%d{HH:mm:ss}] %-5p [%c] - %m%n\"" />    </layout>  </appender>   <!-- with these we'll not get innundated when switching to DEBUG -->  <logger name=\""org.apache.directory.shared.ldap.name\"">    <level value=\""warn\"" />  </logger>  <logger name=\""org.apache.directory.shared.codec\"">    <level value=\""warn\"" />  </logger>  <logger name=\""org.apache.directory.shared.asn1\"">    <level value=\""warn\"" />  </logger>   <root>    <level value=\""info\"" />    <appender-ref ref=\""stdout\"" />  </root></log4j:configuration> \\nOutput:\\n\\n[08:40:05] INFO  [RDirectoryLDAP] - LDAP Connection to localhost on port 10389\\n\\nPerl[edit]\\nLDAP Modules\\n\\n use Net::LDAP; my $ldap = Net::LDAP->new('ldap://ldap.example.com') or die [email protected];my $mesg = $ldap->bind( $bind_dn, password => $bind_pass ); \\nPHP[edit]\\nPHP LDAP Reference\\n\\n<?php$ldap = ldap_connect($hostname, $port);$success = ldap_bind($ldap, $username, $password);\\nPicoLisp[edit]\\n(unless (=0 (setq Ldap (native \""libldap.so\"" \""ldap_open\"" 'N \""example.com\"" 389)))   (quit \""Can't open LDAP\"") ) (native \""libldap.so\"" \""ldap_simple_bind_s\"" 'I Ldap \""user\"" \""password\"")\\nPython[edit]\\nWorks with: Python version 2.6\\nLibrary: python-ldap\\npython-ldap Documentation\\n\\nimport ldap l = ldap.initialize(\""ldap://ldap.example.com\"")try:    l.protocol_version = ldap.VERSION3    l.set_option(ldap.OPT_REFERRALS, 0)     bind = l.simple_bind_s(\""[email protected]\"", \""password\"")finally:    l.unbind() \\nRacket[edit]\\nThis version uses the ldap package, and was tested against OpenLDAP (with real values):\\n\\n#lang racket(require net/ldap)(ldap-authenticate \""ldap.somewhere.com\"" 389 \""uid=username,ou=people,dc=somewhere,dc=com\"" password)\\nTranslation of: C\\nThis is a direct translation of the C code -- I have no idea how to try it out since I don't have a working ldap server... So take it as a stub that waits for someone who can try it to do so. (And it's a low level thing anyway, there's an ldap package for Racket which I can't try for a similar reason.)\\n\\n#lang racket (require ffi/unsafe ffi/unsafe/define) (define-ffi-definer defldap (ffi-lib \""libldap\""))(defldap ldap_init (_fun _string _int -> _pointer))(defldap ldap_unbind (_fun _pointer -> _void))(defldap ldap_simple_bind_s (_fun _pointer _string _string -> _int))(defldap ldap_err2string (_fun _int -> _string)) (define name ...)(define password ...)(define ld (ldap_init \""ldap.somewhere.com\"" 389))(ldap_simple_bind_s ld name password) (ldap_unbind ld)\\nRing[edit]\\n see system(\""dir\"") + nl \\nRuby[edit]\\nSimilar to Tcl, assume the AD server talks LDAP.\\nThere are many Ruby LDAP packages ([1]) -- this solution uses Net::LDAP (\""Pure Ruby LDAP Tools\"" on RubyForge, gem name \""ruby-net-ldap\"")\\n\\nLibrary: RubyGems\\nrequire 'rubygems'require 'net/ldap'ldap = Net::LDAP.new(:host => 'ldap.example.com', :base => 'o=companyname')ldap.authenticate('bind_dn', 'bind_pass')\\nRun BASIC[edit]\\nprint shell$(\""dir\"") ' shell out to the os and print it\\nScala[edit]\\nimport java.io.IOException import org.apache.directory.api.ldap.model.exception.LdapExceptionimport org.apache.directory.ldap.client.api.{LdapConnection, LdapNetworkConnection} object LdapConnectionDemo {  @throws[LdapException]  @throws[IOException]  def main(args: Array[String]): Unit = {    try {      val connection: LdapConnection = new LdapNetworkConnection(\""localhost\"", 10389)      try {        connection.bind()        connection.unBind()      } finally if (connection != null) connection.close()    }  }}\\nsmart BASIC[edit]\\nsmart BASIC uses three separate commands to list the current directory, folder and files respectively.\\n\\nPRINT \""Current directory: \"";CURRENT_DIR$()PRINTPRINT \""Folders:\""PRINTDIR \""/\"" LIST DIRS a$,cFOR n = 0 TO c-1PRINT ,a$(n)NEXT nPRINTPRINT \""Files:\""PRINTDIR \""/\"" LIST FILES a$,cFOR n = 0 TO c-1PRINT ,a$(n)NEXT n\\nTcl[edit]\\nThis does not use SSPI/Kerberos yet, so your AD would need to allow simple ldap access.\\n\\npackage require ldapset conn [ldap::connect $host $port]ldap::bind $conn $user $password\\nVBScript[edit]\\nCreating the normal connection to AD\\n\\nSet objConn = CreateObject(\""ADODB.Connection\"")Set objCmd = CreateObject(\""ADODB.Command\"")objConn.Provider = \""ADsDSOObject\""objConn.Open\\nThere are a large number of third-party LDAP libraries for Go. This uses one of the simpler ones and the code below is largely taken from the example on its main page.\\nExample uses the ldap-client package:\\nThis code uses the Apache Directory third-party library.\\nUses the Apache LDAP API, connecting to a local ApacheDS LDAP directory server.\\nSample log4j.xml configuration file:\\nOutput:\\nLDAP Modules\\nPHP LDAP Reference\\npython-ldap Documentation\\nThis version uses the ldap package, and was tested against OpenLDAP (with real values):\\nThis is a direct translation of the C code -- I have no idea how to try it out since I don't have a working ldap server... So take it as a stub that waits for someone who can try it to do so. (And it's a low level thing anyway, there's an ldap package for Racket which I can't try for a similar reason.)\\nSimilar to Tcl, assume the AD server talks LDAP.\\nThere are many Ruby LDAP packages ([1]) -- this solution uses Net::LDAP (\""Pure Ruby LDAP Tools\"" on RubyForge, gem name \""ruby-net-ldap\"")\\nsmart BASIC uses three separate commands to list the current directory, folder and files respectively.\\nThis does not use SSPI/Kerberos yet, so your AD would need to allow simple ldap access.\\nCreating the normal connection to AD\\n","#include <ldap.h>\\n...\\nchar *name, *password;\\n...\\nLDAP *ld = ldap_init(\""ldap.somewhere.com\"", 389);\\nldap_simple_bind_s(ld, name, password);\\n... after done with it...\\nldap_unbind(ld);"
"C","Active_Directory/Search_for_a_user","Make sure you Connect to Active Directory\\n\\nBased on dopenldap.\\nEiffel does not have the notion of \""return\"", but \""Result\"". A consequence of this is that Eiffel routines are Single-entry-Single-exit, which means less bugs. In the example (below), the Result is of type BOOLEAN.\\nMoreover, strings in Eiffel are objects and cannot be directly passed to the Windows OS. As such, they need to undergo a format change through the facilities of a WEL_STRING, which makes the appropriate structure conversion.\\nBecause Active Directory is a Windows OS facility, in Eiffel we must use the WEL (Windows Eiffel Library) components. Thus, the code above is not cross-platform. Moreover, the call to `cwel_is_credential_valid' is shown below:\\n\\nThere are a large number of third-party LDAP libraries for Go. This uses one of the simpler ones and the code below is largely taken from the example on its main page.\\nExample uses the ldap-client package:\\nThe following code uses the Apache Directory project, version 1.0.0.\\nUsing LDAP connecting to a local ApacheDS LDAP directory server.\\nThis program drives the ldapsearch command and captures the output into an external data queue via ooRexx rxqueue facility. The contents of the queue are then read into program variables for further processing.\\nOutput:\\nTest:\\nUses the Apache LDAP API, connecting to a local ApacheDS LDAP directory server.\\nOutput:\\npython-ldap Documentation\\nUsing LDAP connecting to a local ApacheDS LDAP directory server.\\nA little contrived; this REXX program drives the ldapsearch command.\\nOutput:\\nAssume AD server talks LDAP.\\nOne can do it with the low level Connect to Active Directory based handle with this code:\\nThis is just the basic setup.\\nNow do the actual search.\\nIf we have only a single result its easy:\\nLooping over the result set to output some values.\\nIf you're bored you can also use this instead:\\nUsing LDAP connecting to a local ApacheDS LDAP directory server.\\nA shell script to drive the ldapsearch command.\\nOutput:\\nThe search string and execution of the string\\nDoing something with a single result (this will output the returned users full DN)\\nDoing something with multiple results (this will output each returned users full DN)\\n","#include <ldap.h>\\n\\nchar *name, *password;\\n...\\n\\nLDAP *ld = ldap_init(\""ldap.somewhere.com\"", 389);\\nldap_simple_bind_s(ld, name, password);\\n\\nLDAPMessage **result;\\nldap_search_s(ld, \""dc=somewhere,dc=com\"", LDAP_SCOPE_SUBTREE,\\n	/* search for all persons whose names start with joe or shmoe */\\n	\""(&(objectclass=person)(|(cn=joe*)(cn=shmoe*)))\"",\\n	NULL, /* return all attributes */\\n	0,  /* want both types and values of attrs */\\n	result); /* ldap will allocate room for return messages */\\n\\n/* arduously do stuff here to result, with ldap_first_message(),\\n	ldap_parse_result(), etc. */\\n\\nldap_msgfree(*result);	/* free messages */\\nldap_unbind(ld);	/* disconnect */"
"C","Active_object","In object-oriented programming an object is active when its state depends on clock. Usually an active object encapsulates a task that updates the object's state. To the outer world the object looks like a normal object with methods that can be called from outside. Implementation of such methods must have a certain synchronization mechanism with the encapsulated task in order to prevent object's state corruption.\\nA typical instance of an active object is an animation widget. The widget state changes with the time, while as an object it has all properties of a normal widget.\\nThe task\\nImplement an active integrator object. The object has an input and output. The input can be set using the method Input. The input is a function of time. The output can be queried using the method Output. The object integrates its input over the time and the result becomes the object's output. So if the input is K(t) and the output is S, the object state S is changed to S + (K(t1) + K(t0)) * (t1 - t0) / 2, i.e. it integrates K using the trapeze method. Initially K is constant 0 and S is 0.\\nIn order to test the object:\\nVerify that now the object's output is approximately 0 (the sine has the period of 2s). The accuracy of the result will depend on the OS scheduler time slicing and the accuracy of the clock.\\nSample output:\\nOutput:\\nUses POSIX threads.\\noutput\\nOutput:\\noutput\\n","#include <stdio.h>\\n#include <stdlib.h>\\n#include <unistd.h>\\n#include <math.h>\\n#include \\n#include <pthread.h>\\n\\n/* no need to lock the object: at worst the readout would be 1 tick off,\\n   which is no worse than integrator's inate inaccuracy */\\ntypedef struct {\\n	double (*func)(double);\\n	struct timeval start;\\n	double v, last_v, last_t;\\n	pthread_t id;\\n} integ_t, *integ;\\n\\nvoid update(integ x)\\n{\\n	struct timeval tv;\\n	double t, v, (*f)(double);\\n\\n	f = x->func;\\n	gettimeofday(&tv, 0);\\n	t = ((tv.tv_sec - x->start.tv_sec) * 1000000\\n		+ tv.tv_usec - x->start.tv_usec) * 1e-6;\\n	v = f ? f(t) : 0;\\n	x->v += (x->last_v + v) * (t - x->last_t) / 2;\\n	x->last_t = t;\\n}\\n\\nvoid* tick(void *a)\\n{\\n	integ x = a;\\n	while (1) {\\n		usleep(100000); /* update every .1 sec */\\n		update(x);\\n	}\\n}\\n\\nvoid set_input(integ x, double (*func)(double))\\n{\\n	update(x);\\n	x->func = func;\\n	x->last_t = 0;\\n	x->last_v = func ? func(0) : 0;\\n}\\n\\ninteg new_integ(double (*func)(double))\\n{\\n	integ x = malloc(sizeof(integ_t));\\n	x->v = x->last_v = 0;\\n	x->func = 0;\\n	gettimeofday(&x->start, 0);\\n	set_input(x, func);\\n	pthread_create(&x->id, 0, tick, x);\\n	return x;\\n}\\n\\ndouble sine(double t) { return sin(4 * atan2(1, 1) * t); }\\n\\nint main()\\n{\\n	integ x = new_integ(sine);\\n	sleep(2);\\n	set_input(x, 0);\\n	usleep(500000);\\n	printf(\""%g\\n\"", x->v);\\n\\n	return 0;\\n}"
"C","Addition_chains","An addition chain of length r for n is a sequence 1 = a(0) < a(1) < a(2) ... < a(r) = n , such as a(k) = a(i) + a(j) ( i < k and j < k , i may be = j) . Each member is the sum of two earlier members, not necessarily distincts.\\nA Brauer chain for n is an addition chain where a(k) = a(k-1) + a(j) with j < k. Each member uses the previous member as a summand.\\nWe are interested in chains of minimal length L(n).\\nTask\\nFor each n in {7,14,21,29,32,42,64} display the following : L(n), the count of Brauer chains of length L(n), an example of such a Brauer chain, the count of non-brauer chains of length L(n), an example of such a chain. (NB: counts may be 0 ).\\nExtra-credit: Same task for n in {47, 79, 191, 382 , 379, 12509}\\nReferences\\nExample\\n","#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n#define TRUE 1\\n#define FALSE 0\\n\\ntypedef int bool;\\n\\ntypedef struct {\\n    int x, y;\\n} pair;\\n\\nint* example = NULL;\\nint exampleLen = 0;\\n\\nvoid reverse(int s[], int len) {\\n    int i, j, t;\\n    for (i = 0, j = len - 1; i < j; ++i, --j) {\\n        t = s[i];\\n        s[i] = s[j];\\n        s[j] = t;\\n    }\\n}\\n\\npair tryPerm(int i, int pos, int seq[], int n, int len, int minLen);\\n\\npair checkSeq(int pos, int seq[], int n, int len, int minLen) {\\n    pair p;\\n    if (pos > minLen || seq[0] > n) {\\n        p.x = minLen; p.y = 0;\\n        return p;\\n    }\\n    else if (seq[0] == n) {\\n        example = malloc(len * sizeof(int));\\n        memcpy(example, seq, len * sizeof(int));\\n        exampleLen = len;\\n        p.x = pos; p.y = 1;\\n        return p;\\n    }\\n    else if (pos < minLen) {\\n        return tryPerm(0, pos, seq, n, len, minLen);\\n    }\\n    else {\\n        p.x = minLen; p.y = 0;\\n        return p;\\n    }\\n}\\n\\npair tryPerm(int i, int pos, int seq[], int n, int len, int minLen) {\\n    int *seq2;\\n    pair p, res1, res2;\\n    size_t size = sizeof(int);    \\n    if (i > pos) {\\n        p.x = minLen; p.y = 0;\\n        return p;\\n    }\\n    seq2 = malloc((len + 1) * size);\\n    memcpy(seq2 + 1, seq, len * size);\\n    seq2[0] = seq[0] + seq[i];\\n    res1 = checkSeq(pos + 1, seq2, n, len + 1, minLen);\\n    res2 = tryPerm(i + 1, pos, seq, n, len, res1.x);\\n    free(seq2);\\n    if (res2.x < res1.x)\\n        return res2;\\n    else if (res2.x == res1.x) {\\n        p.x = res2.x; p.y = res1.y + res2.y;\\n        return p;\\n    }\\n    else {\\n        printf(\""Error in tryPerm\\n\"");\\n        p.x = 0; p.y = 0;\\n        return p;\\n    }\\n}\\n\\npair initTryPerm(int x, int minLen) {\\n    int seq[1] = {1};\\n    return tryPerm(0, 0, seq, x, 1, minLen);\\n}\\n\\nvoid printArray(int a[], int len) {\\n    int i;\\n    printf(\""[\"");\\n    for (i = 0; i < len; ++i) printf(\""%d \"", a[i]);\\n    printf(\""\\b]\\n\"");\\n}\\n\\nbool isBrauer(int a[], int len) {\\n    int i, j;\\n    bool ok;\\n    for (i = 2; i < len; ++i) {\\n        ok = FALSE;\\n        for (j = i - 1; j >= 0; j--) {\\n            if (a[i-1] + a[j] == a[i]) {\\n                ok = TRUE;\\n                break;\\n            }\\n        }\\n        if (!ok) return FALSE;\\n    }\\n    return TRUE;\\n}\\n\\nbool isAdditionChain(int a[], int len) {\\n    int i, j, k;\\n    bool ok, exit;\\n    for (i = 2; i < len; ++i) {\\n        if (a[i] > a[i - 1] * 2) return FALSE;\\n        ok = FALSE; exit = FALSE;\\n        for (j = i - 1; j >= 0; --j) {\\n            for (k = j; k >= 0; --k) {\\n               if (a[j] + a[k] == a[i]) { ok = TRUE; exit = TRUE; break; }\\n            }\\n            if (exit) break;\\n        }\\n        if (!ok) return FALSE;\\n    }\\n    if (example == NULL && !isBrauer(a, len)) {\\n        example = malloc(len * sizeof(int));\\n        memcpy(example, a, len * sizeof(int));\\n        exampleLen = len;\\n    }\\n    return TRUE;\\n}\\n\\nvoid nextChains(int index, int len, int seq[], int *pcount) {\\n    for (;;) {\\n        int i;\\n        if (index < len - 1) {\\n           nextChains(index + 1, len, seq, pcount);\\n        }\\n        if (seq[index] + len - 1 - index >= seq[len - 1]) return;\\n        seq[index]++;\\n        for (i = index + 1; i < len - 1; ++i) {\\n            seq[i] = seq[i-1] + 1;\\n        }\\n        if (isAdditionChain(seq, len)) (*pcount)++;\\n    }\\n}\\n\\nint findNonBrauer(int num, int len, int brauer) {\\n    int i, count = 0;\\n    int *seq = malloc(len * sizeof(int));\\n    seq[0] = 1;\\n    seq[len - 1] = num;\\n    for (i = 1; i < len - 1; ++i) {\\n        seq[i] = seq[i - 1] + 1;\\n    }\\n    if (isAdditionChain(seq, len)) count = 1;\\n    nextChains(2, len, seq, &count);\\n    free(seq);\\n    return count - brauer;\\n}\\n\\nvoid findBrauer(int num, int minLen, int nbLimit) {\\n    pair p = initTryPerm(num, minLen);\\n    int actualMin = p.x, brauer = p.y, nonBrauer;\\n    printf(\""\\nN = %d\\n\"", num);\\n    printf(\""Minimum length of chains : L(%d) = %d\\n\"", num, actualMin);\\n    printf(\""Number of minimum length Brauer chains : %d\\n\"", brauer);\\n    if (brauer > 0) {\\n        printf(\""Brauer example : \"");\\n        reverse(example, exampleLen);\\n        printArray(example, exampleLen);\\n    }\\n    if (example != NULL) {\\n        free(example);\\n        example = NULL; \\n        exampleLen = 0;\\n    }\\n    if (num <= nbLimit) {\\n        nonBrauer = findNonBrauer(num, actualMin + 1, brauer);\\n        printf(\""Number of minimum length non-Brauer chains : %d\\n\"", nonBrauer);\\n        if (nonBrauer > 0) {\\n            printf(\""Non-Brauer example : \"");\\n            printArray(example, exampleLen);\\n        }\\n        if (example != NULL) {\\n            free(example);\\n            example = NULL; \\n            exampleLen = 0;\\n        }\\n    }\\n    else {\\n        printf(\""Non-Brauer analysis suppressed\\n\"");\\n    }\\n}\\n\\nint main() {\\n    int i;\\n    int nums[12] = {7, 14, 21, 29, 32, 42, 64, 47, 79, 191, 382, 379};\\n    printf(\""Searching for Brauer chains up to a minimum length of 12:\\n\"");\\n    for (i = 0; i < 12; ++i) findBrauer(nums[i], 12, 79);\\n    return 0;\\n}"
"C","Addition-chain_exponentiation","In cases of special objects (such as with matrices) the operation of multiplication can be excessively expensive. In these cases the operation of multiplication should be avoided or reduced to a minimum.\\nIn mathematics and computer science, optimal addition-chain exponentiation is a method of exponentiation by positive integer powers that requires a minimal number of multiplications. It works by creating a shortest addition chain that generates the desired exponent. Each exponentiation in the chain can be evaluated by multiplying two of the earlier exponentiation results. More generally, addition-chain exponentiation may also refer to exponentiation by non-minimal addition chains constructed by a variety of algorithms (since a shortest addition chain is very difficult to find).\\nThe shortest addition-chain algorithm requires no more multiplications than binary exponentiation and usually less. The first example of where it does better is for \\n\\n\\n\\n\\na\\n\\n15\\n\\n\\n\\n\\n{\\displaystyle a^{15}}\\n\\n, where the binary method needs six multiplies but a shortest addition chain requires only five:\\nOn the other hand, the addition-chain method is much more complicated, since the determination of a shortest addition chain seems quite difficult: no efficient optimal methods are currently known for arbitrary exponents, and the related problem of finding a shortest addition chain for a given set of exponents has been proven NP-complete.\\nThe number of multiplications required follows this sequence:\\n0, 1, 2, 2, 3, 3, 4, 3, 4, 4, 5, 4, 5, 5, 5, 4, 5, 5, 6, 5,\\n6, 6, 6, 5, 6, 6, 6, 6, 7, 6, 7, 5, 6, 6, 7, 6, 7, 7, 7, 6,\\n7, 7, 7, 7, 7, 7, 8, 6, 7, 7, 7, 7, 8, 7, 8, 7, 8, 8, 8, 7,\\n8, 8, 8, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 8, 8, 8, 8, 9, 7,\\n8, 8, 8, 8, 8, 8, 9, 8, 9, 8, 9, 8, 9, 9, 9, 7, 8, 8, 8, 8...\\nThis sequence can be found at: http://oeis.org/A003313\\nTask requirements:\\nUsing the following values:\\n\\n\\n\\n\\nA\\n=\\n\\n\\n[\\n\\n\\n\\n\\n\\n\\n1\\n2\\n\\n\\n\\n\\n\\n0\\n\\n\\n\\n\\n\\n1\\n2\\n\\n\\n\\n\\n\\n0\\n\\n\\n0\\n\\n\\n0\\n\\n\\n\\n\\n\\n0\\n\\n\\n\\n\\n\\n1\\n2\\n\\n\\n\\n\\n\\n0\\n\\n\\n\\n\\n\\n1\\n2\\n\\n\\n\\n\\n\\n0\\n\\n\\n0\\n\\n\\n\\n\\n\\n0\\n\\n\\n\\n\\n\\n1\\n2\\n\\n\\n\\n\\n\\n0\\n\\n\\n−\\n\\n\\n\\n1\\n2\\n\\n\\n\\n\\n\\n0\\n\\n\\n0\\n\\n\\n\\n\\n\\n−\\n\\n\\n\\n1\\n2\\n\\n\\n\\n\\n\\n0\\n\\n\\n\\n\\n\\n1\\n2\\n\\n\\n\\n\\n\\n0\\n\\n\\n0\\n\\n\\n0\\n\\n\\n\\n\\n\\n0\\n\\n\\n0\\n\\n\\n0\\n\\n\\n0\\n\\n\\n0\\n\\n\\n1\\n\\n\\n\\n\\n\\n0\\n\\n\\n0\\n\\n\\n0\\n\\n\\n0\\n\\n\\n1\\n\\n\\n0\\n\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle A={\\begin{bmatrix}{\\sqrt {\\frac {1}{2}}}&0&{\\sqrt {\\frac {1}{2}}}&0&0&0&\\\\0&{\\sqrt {\\frac {1}{2}}}&0&{\\sqrt {\\frac {1}{2}}}&0&0&\\\\0&{\\sqrt {\\frac {1}{2}}}&0&-{\\sqrt {\\frac {1}{2}}}&0&0&\\\\-{\\sqrt {\\frac {1}{2}}}&0&{\\sqrt {\\frac {1}{2}}}&0&0&0&\\\\0&0&0&0&0&1&\\\\0&0&0&0&1&0&\\\\\\end{bmatrix}}}\\n\\n \\n\\n\\n\\nm\\n=\\n31415\\n\\n\\n{\\displaystyle m=31415}\\n\\n and \\n\\n\\n\\nn\\n=\\n27182\\n\\n\\n{\\displaystyle n=27182}\\n\\n\\nRepeat task Matrix-exponentiation operator, except use addition-chain exponentiation to better calculate:\\nAs an easier alternative to doing the matrix manipulation above, generate the addition-chains for 12509, 31415 and 27182 and use addition-chain exponentiation to calculate these two equations:\\nAlso: Display a count of how many multiplications were done in each case.\\nNote: There are two ways to approach this task:\\nNote: Binary exponentiation does not usually produce the best solution. Provide only optimal solutions.\\nKudos (κῦδος) for providing a routine that generate sequence A003313 in the output.\\nAlso, see the Rosetta Code task:   [http://rosettacode.org/wiki/Knuth%27s_power_tree\\nKnuth's power tree].\\nUsing complex instead of matrix. Requires Achain.c. It takes a long while to compute the shortest addition chains, such that if you don't have the chain lengths precomputed and stored somewhere, you are probably better off with a binary chain (normally not shortest but very simple to calculate) whatever you intend to use the chains for.\\noutput\\nA non-optimal solution.\\nOutput (manually wrapped at 80 columns.)\\nNaieve brute force search, no attempt to optimise, manages about 4 million checks/s.\\nReplacing the recursion with an internal stack and chosen with a fixed length array might help, but\\notherwise I got no good ideas at all for trimming the search space.\\nGiving it the same length, I think, yields the same result as Knuth's_power_tree#Phix, and at least\\nin the cases that I tried, somewhat faster than the method on that page.\\nIf you know the A003313 number, you can throw that at it and wait (for several billion years) or get the\\npower tree length and loop trying to find a path one shorter (and wait several trillion years). For the\\npath() and treepow() routines see link above.\\nNote that \""tries\"" overflows (crashes) at 1073741824, which I kept in as a deliberate limiter.\\n","#include <stdio.h>\\n\\n#include \""achain.c\"" /* not common practice */\\n\\n/* don't have a C99 compiler atm */\\ntypedef struct {double u, v;} cplx;\\n\\ninline cplx c_mul(cplx a, cplx b)\\n{\\n	cplx c;\\n	c.u = a.u * b.u - a.v * b.v;\\n	c.v = a.u * b.v + a.v * b.u;\\n	return c;\\n}\\n\\ncplx chain_expo(cplx x, int n)\\n{\\n	int i, j, k, l, e[32];\\n	cplx v[32];\\n\\n	l = seq(n, 0, e);\\n\\n	puts(\""Exponents:\"");\\n	for (i = 0; i <= l; i++)\\n		printf(\""%d%c\"", e[i], i == l ? '\\n' : ' ');\\n\\n	v[0] = x; v[1] = c_mul(x, x);\\n	for (i = 2; i <= l; i++) {\\n		for (j = i - 1; j; j--) {\\n			for (k = j; k >= 0; k--) {\\n				if (e[k] + e[j] < e[i]) break;\\n				if (e[k] + e[j] > e[i]) continue;\\n				v[i] = c_mul(v[j], v[k]);\\n				j = 1;\\n				break;\\n			}\\n		}\\n	}\\n	printf(\""(%f + i%f)^%d = %f + i%f\\n\"",\\n		x.u, x.v, n, v[l].u, v[l].v);\\n\\n	return x;\\n}\\n\\nint bin_len(int n)\\n{\\n	int r, o;\\n	for (r = o = -1; n; n >>= 1, r++)\\n		if (n & 1) o++;\\n	return r + o;\\n}\\n\\nint main()\\n{\\n	cplx	r1 = {1.0000254989, 0.0000577896},\\n		r2 = {1.0000220632, 0.0000500026};\\n	int n1 = 27182, n2 = 31415, i;\\n\\n	init();\\n	puts(\""Precompute chain lengths\"");\\n	seq_len(n2);\\n\\n	chain_expo(r1, n1);\\n	chain_expo(r2, n2);\\n	puts(\""\\nchain lengths: shortest binary\"");\\n	printf(\""%14d %7d %7d\\n\"", n1, seq_len(n1), bin_len(n1));\\n	printf(\""%14d %7d %7d\\n\"", n2, seq_len(n2), bin_len(n2));\\n	for (i = 1; i < 100; i++)\\n		printf(\""%14d %7d %7d\\n\"", i, seq_len(i), bin_len(i));\\n	return 0;\\n}"
"C","Aliquot_sequence_classifications","An aliquot sequence of a positive integer K is defined recursively as the first member\\nbeing K and subsequent members being the sum of the Proper divisors of the previous term.\\n\\nShow all output on this page.\\n\\n\\nAssumes LONG INT is at least 64 bits, as in Algol 68G.\\n","\\n#include<stdlib.h>\\n#include<string.h>\\n#include<stdio.h>\\n\\nunsigned long long bruteForceProperDivisorSum(unsigned long long n){\\n	unsigned long long i,sum = 0;\\n	\\n	for(i=1;i<(n+1)/2;i++)\\n		if(n%i==0 && n!=i)\\n			sum += i;\\n		\\n	return sum;\\n}\\n\\nvoid printSeries(unsigned long long* arr,int size,char* type){\\n	int i;\\n	\\n	printf(\""\\nInteger : %llu, Type : %s, Series : \"",arr[0],type);\\n	\\n	for(i=0;i\"",argV[0]);\\n	else{\\n		if(strchr(argV[1],'.')!=NULL)\\n			processFile(argV[1]);\\n		else\\n			aliquotClassifier(strtoull(argV[1],(char**)NULL,10));\\n	}\\n	return 0;\\n}\\n"
"C","Aliquot_sequence_classifications","An aliquot sequence of a positive integer K is defined recursively as the first member\\nbeing K and subsequent members being the sum of the Proper divisors of the previous term.\\n\\nShow all output on this page.\\n\\n\\nAssumes LONG INT is at least 64 bits, as in Algol 68G.\\n","\\n#include<string.h>\\n#include<stdlib.h>\\n#include<stdio.h>\\n\\nunsigned long long raiseTo(unsigned long long base, unsigned long long power){\\n    unsigned long long result = 1,i;\\n    for (i=0; i 1)\\n			prod *= ((raiseTo(i,count + 1) - 1)/(i-1));\\n	}\\n	\\n	if(n>2)\\n		prod *= (n+1);\\n\\n	return prod - temp;\\n}\\n\\nvoid printSeries(unsigned long long* arr,int size,char* type){\\n	int i;\\n	\\n	printf(\""\\nInteger : %llu, Type : %s, Series : \"",arr[0],type);\\n	\\n	for(i=0;i\"",argV[0]);\\n	else{\\n		if(strchr(argV[1],'.')!=NULL)\\n			processFile(argV[1]);\\n		else\\n			aliquotClassifier(strtoull(argV[1],(char**)NULL,10));\\n	}\\n	return 0;\\n}\\n"
"C","Almost_prime","A   k-Almost-prime   is a natural number   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n   that is the product of   \\n\\n\\n\\nk\\n\\n\\n{\\displaystyle k}\\n\\n   (possibly identical) primes.\\n\\n1-almost-primes,   where   \\n\\n\\n\\nk\\n=\\n1\\n\\n\\n{\\displaystyle k=1}\\n\\n,   are the prime numbers themselves.\\n2-almost-primes,   where   \\n\\n\\n\\nk\\n=\\n2\\n\\n\\n{\\displaystyle k=2}\\n\\n,   are the   semiprimes.\\n\\nWrite a function/method/subroutine/... that generates k-almost primes and use it to create a table here of the first ten members of k-Almost primes for   \\n\\n\\n\\n1\\n<=\\nK\\n<=\\n5\\n\\n\\n{\\displaystyle 1<=K<=5}\\n\\n.\\n\\n\\n","#include <stdio.h>\\n\\nint kprime(int n, int k)\\n{\\n	int p, f = 0;\\n	for (p = 2; f < k && p*p <= n; p++)\\n		while (0 == n % p)\\n			n /= p, f++;\\n\\n	return f + (n > 1) == k;\\n}\\n\\nint main(void)\\n{\\n	int i, c, k;\\n\\n	for (k = 1; k <= 5; k++) {\\n		printf(\""k = %d:\"", k);\\n\\n		for (i = 2, c = 0; c < 10; i++)\\n			if (kprime(i, k)) {\\n				printf(\"" %d\"", i);\\n				c++;\\n			}\\n\\n		putchar('\\n');\\n	}\\n\\n	return 0;\\n}"
"C","Amicable_pairs","Two integers \\n\\n\\n\\nN\\n\\n\\n{\\displaystyle N}\\n\\n and \\n\\n\\n\\nM\\n\\n\\n{\\displaystyle M}\\n\\n are said to be amicable pairs if \\n\\n\\n\\nN\\n≠\\nM\\n\\n\\n{\\displaystyle N\\neq M}\\n\\n and the sum of the proper divisors of \\n\\n\\n\\nN\\n\\n\\n{\\displaystyle N}\\n\\n (\\n\\n\\n\\n\\ns\\nu\\nm\\n\\n(\\n\\np\\nr\\no\\np\\nD\\ni\\nv\\ns\\n\\n(\\nN\\n)\\n)\\n\\n\\n{\\displaystyle \\mathrm {sum} (\\mathrm {propDivs} (N))}\\n\\n) \\n\\n\\n\\n=\\nM\\n\\n\\n{\\displaystyle =M}\\n\\n as well as \\n\\n\\n\\n\\ns\\nu\\nm\\n\\n(\\n\\np\\nr\\no\\np\\nD\\ni\\nv\\ns\\n\\n(\\nM\\n)\\n)\\n=\\nN\\n\\n\\n{\\displaystyle \\mathrm {sum} (\\mathrm {propDivs} (M))=N}\\n\\n.\\n\\n1184 and 1210 are an amicable pair, with proper divisors:\\n\\nCalculate and show here the Amicable pairs below 20,000; (there are eight).\\n\\n\\n","#include <stdio.h>\\n#include <stdlib.h>\\n\\ntypedef unsigned int uint;\\n\\nint main(int argc, char **argv)\\n{\\n  uint top = atoi(argv[1]);\\n  uint *divsum = malloc((top + 1) * sizeof(*divsum));\\n  uint pows[32] = {1, 0};\\n\\n  for (uint i = 0; i <= top; i++) divsum[i] = 1;\\n\\n  // sieve\\n  // only sieve within lower half , the modification starts at 2*p\\n  for (uint p = 2; p+p <= top; p++) {\\n    if (divsum[p] > 1) {\\n      divsum[p] -= p;// subtract number itself from divisor sum ('proper')\\n      continue;}     // p not prime\\n\\n    uint x; // highest power of p we need\\n    //checking x <= top/y instead of x*y <= top to avoid overflow\\n    for (x = 1; pows[x - 1] <= top/p; x++)\\n      pows[x] = p*pows[x - 1];\\n\\n    //counter where n is not a*p with a = ?*p, useful for most p.\\n    //think of p>31 seldom divisions or p>sqrt(top) than no division is needed\\n    //n = 2*p, so the prime itself is left unchanged => k=p-1\\n    uint k= p-1;\\n    for (uint n = p+p; n <= top; n += p) {\\n      uint s=1+pows[1];\\n      k--;\\n      // search the right power only if needed\\n      if ( k==0) {\\n        for (uint i = 2; i < x && !(n%pows[i]); s += pows[i++]);\\n        k = p; }\\n      divsum[n] *= s;\\n    }\\n  }\\n\\n  //now correct the upper half\\n  for (uint p = (top >> 1)+1; p <= top; p++) {\\n    if (divsum[p] > 1){\\n      divsum[p] -= p;}\\n  }\\n\\n  uint cnt = 0;\\n  for (uint a = 1; a <= top; a++) {\\n    uint b = divsum[a];\\n    if (b > a && b <= top && divsum[b] == a){\\n      printf(\""%u %u\\n\"", a, b);\\n      cnt++;}\\n  }\\n  printf(\""\\nTop %u count : %u\\n\"",top,cnt);\\n  return 0;\\n}"
"C","Anagrams","When two or more words are composed of the same characters, but in a different order, they are called anagrams.\\nUsing the word list at   http://www.puzzlers.org/pub/wordlists/unixdict.txt,\\nfind the sets of words that share the same characters that contain the most words in them.\\nOrdered words\\nPalindrome detection\\nSemordnilap\\nAnagrams\\nAnagrams/Deranged anagrams\\n","#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include <ctype.h>\\n#include <time.h>\\n\\nchar *sortedWord(const char *word, char *wbuf)\\n{\\n    char *p1, *p2, *endwrd;\\n    char t;\\n    int swaps;\\n\\n    strcpy(wbuf, word);\\n    endwrd = wbuf+strlen(wbuf);\\n    do {\\n       swaps = 0;\\n       p1 = wbuf; p2 = endwrd-1;\\n       while (p1 *p1) {\\n             t = *p2; *p2 = *p1; *p1 = t;\\n             swaps = 1;\\n          }\\n          p1++; p2--;\\n       }\\n       p1 = wbuf; p2 = p1+1;\\n       while(p2 < endwrd) {\\n           if (*p2 > *p1) {\\n             t = *p2; *p2 = *p1; *p1 = t;\\n             swaps = 1;\\n           }\\n           p1++; p2++;\\n       }\\n    } while (swaps);\\n    return wbuf;\\n}\\n\\nstatic\\nshort cxmap[] = {\\n    0x06, 0x1f, 0x4d, 0x0c, 0x5c, 0x28, 0x5d, 0x0e, 0x09, 0x33, 0x31, 0x56,\\n    0x52, 0x19, 0x29, 0x53, 0x32, 0x48, 0x35, 0x55, 0x5e, 0x14, 0x27, 0x24,\\n    0x02, 0x3e, 0x18, 0x4a, 0x3f, 0x4c, 0x45, 0x30, 0x08, 0x2c, 0x1a, 0x03,\\n    0x0b, 0x0d, 0x4f, 0x07, 0x20, 0x1d, 0x51, 0x3b, 0x11, 0x58, 0x00, 0x49,\\n    0x15, 0x2d, 0x41, 0x17, 0x5f, 0x39, 0x16, 0x42, 0x37, 0x22, 0x1c, 0x0f,\\n    0x43, 0x5b, 0x46, 0x4b, 0x0a, 0x26, 0x2e, 0x40, 0x12, 0x21, 0x3c, 0x36,\\n    0x38, 0x1e, 0x01, 0x1b, 0x05, 0x4e, 0x44, 0x3d, 0x04, 0x10, 0x5a, 0x2a,\\n    0x23, 0x34, 0x25, 0x2f, 0x2b, 0x50, 0x3a, 0x54, 0x47, 0x59, 0x13, 0x57,\\n   };\\n#define CXMAP_SIZE (sizeof(cxmap)/sizeof(short))\\n\\n\\nint Str_Hash( const char *key, int ix_max )\\n{\\n   const char *cp;\\n   short mash;\\n   int  hash = 33501551;\\n   for (cp = key; *cp; cp++) {\\n      mash = cxmap[*cp % CXMAP_SIZE];\\n      hash = (hash >>4) ^ 0x5C5CF5C ^ ((hash<<1) + (mash<<5));\\n      hash &= 0x3FFFFFFF;\\n      }\\n   return  hash % ix_max;\\n}\\n\\ntypedef struct sDictWord  *DictWord;\\nstruct sDictWord {\\n    const char *word;\\n    DictWord next;\\n};\\n\\ntypedef struct sHashEntry *HashEntry;\\nstruct sHashEntry {\\n    const char *key;\\n    HashEntry next;\\n    DictWord  words;\\n    HashEntry link;\\n    short wordCount;\\n};\\n\\n#define HT_SIZE 8192\\n\\nHashEntry hashTable[HT_SIZE];\\n\\nHashEntry mostPerms = NULL;\\n\\nint buildAnagrams( FILE *fin )\\n{\\n    char buffer[40];\\n    char bufr2[40];\\n    char *hkey;\\n    int hix;\\n    HashEntry he, *hep;\\n    DictWord  we;\\n    int  maxPC = 2;\\n    int numWords = 0;\\n    \\n    while ( fgets(buffer, 40, fin)) {\\n        for(hkey = buffer; *hkey && (*hkey!='\\n'); hkey++);\\n        *hkey = 0;\\n        hkey = sortedWord(buffer, bufr2);\\n        hix = Str_Hash(hkey, HT_SIZE);\\n        he = hashTable[hix]; hep = &hashTable[hix];\\n        while( he && strcmp(he->key , hkey) ) {\\n            hep = &he->next;\\n            he = he->next;\\n        }\\n        if ( ! he ) {\\n            he = malloc(sizeof(struct sHashEntry));\\n            he->next = NULL;\\n            he->key = strdup(hkey);\\n            he->wordCount = 0;\\n            he->words = NULL;\\n            he->link = NULL;\\n            *hep = he;\\n        }\\n        we = malloc(sizeof(struct sDictWord));\\n        we->word = strdup(buffer);\\n        we->next = he->words;\\n        he->words = we;\\n        he->wordCount++;\\n        if ( maxPC < he->wordCount) {\\n            maxPC = he->wordCount;\\n            mostPerms = he;\\n            he->link = NULL;\\n        }\\n        else if (maxPC == he->wordCount) {\\n            he->link = mostPerms;\\n            mostPerms = he;\\n        }\\n         \\n        numWords++;\\n    }\\n    printf(\""%d words in dictionary max ana=%d\\n\"", numWords, maxPC);\\n    return maxPC;\\n}\\n\\n\\nint main( ) \\n{\\n    HashEntry he;\\n    DictWord  we;\\n    FILE *f1;\\n    \\n    f1 = fopen(\""unixdict.txt\"",\""r\"");\\n    buildAnagrams(f1);\\n    fclose(f1);\\n    \\n    f1 = fopen(\""anaout.txt\"",\""w\"");\\n//    f1 = stdout;\\n\\n    for (he = mostPerms; he; he = he->link) {\\n        fprintf(f1,\""%d:\"", he->wordCount);\\n        for(we = he->words; we; we = we->next) {\\n            fprintf(f1,\""%s, \"", we->word);\\n        }\\n        fprintf(f1, \""\\n\"");\\n    }\\n\\n    fclose(f1);\\n    return 0;\\n}"
"C","Anagrams","When two or more words are composed of the same characters, but in a different order, they are called anagrams.\\nUsing the word list at   http://www.puzzlers.org/pub/wordlists/unixdict.txt,\\nfind the sets of words that share the same characters that contain the most words in them.\\nOrdered words\\nPalindrome detection\\nSemordnilap\\nAnagrams\\nAnagrams/Deranged anagrams\\n","#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include <fcntl.h>\\n#include <unistd.h>\\n#include \\n#include <string.h>\\n\\ntypedef struct { const char *key, *word; int cnt; } kw_t;\\n\\nint lst_cmp(const void *a, const void *b)\\n{\\n	return strcmp(((const kw_t*)a)->key, ((const kw_t*)b)->key);\\n}\\n\\n/* Bubble sort.  Faster than stock qsort(), believe it or not */\\nvoid sort_letters(char *s)\\n{\\n	int i, j;\\n	char t;\\n	for (i = 0; s[i] != '\\0'; i++) {\\n		for (j = i + 1; s[j] != '\\0'; j++)\\n			if (s[j] < s[i]) {\\n				t = s[j]; s[j] = s[i]; s[i] = t;\\n			}\\n	}\\n}\\n\\nint main()\\n{\\n	struct stat s;\\n	char *words, *keys;\\n	size_t i, j, k, longest, offset;\\n	int n_word = 0;\\n	kw_t *list;\\n\\n	int fd = open(\""unixdict.txt\"", O_RDONLY);\\n	if (fd == -1) return 1;\\n	fstat(fd, &s);\\n	words = malloc(s.st_size * 2);\\n	keys  = words + s.st_size;\\n\\n	read(fd, words, s.st_size);\\n	memcpy(keys, words, s.st_size);\\n\\n	/* change newline to null for easy use; sort letters in keys */\\n	for (i = j = 0; i < s.st_size; i++) {\\n		if (words[i] == '\\n') {\\n			words[i] = keys[i] = '\\0';\\n			sort_letters(keys + j);\\n			j = i + 1;\\n			n_word ++;\\n		}\\n	}\\n\\n	list = calloc(n_word, sizeof(kw_t));\\n\\n	/* make key/word pointer pairs for sorting */\\n	for (i = j = k = 0; i < s.st_size; i++) {\\n		if (words[i] == '\\0') {\\n			list[j].key = keys + k;\\n			list[j].word = words + k;\\n			k = i + 1;\\n			j++;\\n		}\\n	}\\n\\n	qsort(list, n_word, sizeof(kw_t), lst_cmp);\\n\\n	/* count each key's repetition */\\n	for (i = j = k = offset = longest = 0; i < n_word; i++) {\\n		if (!strcmp(list[i].key, list[j].key)) {\\n			++k;\\n			continue;\\n		}\\n\\n		/* move current longest to begining of array */\\n		if (k < longest) {\\n			k = 0;\\n			j = i;\\n			continue;\\n		}\\n\\n		if (k > longest) offset = 0;\\n\\n		while (j < i) list[offset++] = list[j++];\\n		longest = k;\\n		k = 0;\\n	}\\n\\n	/* show the longest */\\n	for (i = 0; i < offset; i++) {\\n		printf(\""%s \"", list[i].word);\\n		if (i < n_word - 1 && strcmp(list[i].key, list[i+1].key))\\n			printf(\""\\n\"");\\n	}\\n\\n	/* free(list); free(words); */\\n	close(fd);\\n	return 0;\\n}"
"C","Anagrams/Deranged_anagrams","Two or more words are said to be anagrams if they have the same characters, but in a different order.\\nBy analogy with derangements we define a deranged anagram as two words with the same characters, but in which the same character does not appear in the same position in both words.\\nUse the word list at unixdict to find and display the longest deranged anagram.\\nOrdered words\\nPalindrome detection\\nSemordnilap\\nAnagrams\\nAnagrams/Deranged anagrams\\n","#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include <unistd.h>\\n#include \\n#include <fcntl.h>\\n#include \\n\\n// Letter lookup by frequency.  This is to reduce word insertion time.\\nconst char *freq = \""zqxjkvbpygfwmucldrhsnioate\"";\\nint char_to_idx[128];\\n\\n// Trie structure of sorts\\nstruct word {\\n	const char *w;\\n	struct word *next;\\n};\\n\\nunion node {\\n	union node *down[10];\\n	struct word *list[10];\\n};\\n\\nint deranged(const char *s1, const char *s2)\\n{\\n	int i;\\n	for (i = 0; s1[i]; i++)\\n		if (s1[i] == s2[i]) return 0;\\n	return 1;\\n}\\n\\nint count_letters(const char *s, unsigned char *c)\\n{\\n	int i, len;\\n	memset(c, 0, 26);\\n	for (len = i = 0; s[i]; i++) {\\n		if (s[i] < 'a' || s[i] > 'z')\\n			return 0;\\n		len++, c[char_to_idx[(unsigned char)s[i]]]++;\\n	}\\n	return len;\\n}\\n\\nconst char * insert(union node *root, const char *s, unsigned char *cnt)\\n{\\n	int i;\\n	union node *n;\\n	struct word *v, *w = 0;\\n\\n	for (i = 0; i < 25; i++, root = n) {\\n		if (!(n = root->down[cnt[i]]))\\n			root->down[cnt[i]] = n = calloc(1, sizeof(union node));\\n	}\\n\\n	w = malloc(sizeof(struct word));\\n	w->w = s;\\n	w->next = root->list[cnt[25]];\\n	root->list[cnt[25]] = w;\\n\\n	for (v = w->next; v; v = v->next) {\\n		if (deranged(w->w, v->w))\\n			return v->w;\\n	}\\n	return 0;\\n}\\n\\nint main(int c, char **v)\\n{\\n	int i, j = 0;\\n	char *words;\\n	struct stat st;\\n\\n	int fd = open(c < 2 ? \""unixdict.txt\"" : v[1], O_RDONLY);\\n	if (fstat(fd, &st) < 0) return 1;\\n\\n	words = malloc(st.st_size);\\n	read(fd, words, st.st_size);\\n	close(fd);\\n\\n	union node root = {{0}};\\n	unsigned char cnt[26];\\n	int best_len = 0;\\n	const char *b1, *b2;\\n\\n	for (i = 0; freq[i]; i++)\\n		char_to_idx[(unsigned char)freq[i]] = i;\\n\\n	/* count words, change newline to null */\\n	for (i = j = 0; i < st.st_size; i++) {\\n		if (words[i] != '\\n') continue;\\n		words[i] = '\\0';\\n\\n		if (i - j > best_len) {\\n			count_letters(words + j, cnt);\\n			const char *match = insert(&root, words + j, cnt);\\n\\n			if (match) {\\n				best_len = i - j;\\n				b1 = words + j;\\n				b2 = match;\\n			}\\n		}\\n\\n		j = ++i;\\n	}\\n\\n	if (best_len) printf(\""longest derangement: %s %s\\n\"", b1, b2);\\n\\n	return 0;\\n}"
"C","Angle_difference_between_two_bearings","Finding the angle between two bearings is often confusing.[1]\\n\\nFind the angle which is the result of the subtraction b2 - b1, where b1 and b2 are the bearings.\\nInput bearings are expressed in the range   -180   to   +180   degrees.\\nThe result is also expressed in the range   -180   to   +180   degrees.\\n\\nCompute the angle for the following pairs:\\n\\nAllow the input bearings to be any (finite) value.\\n\\n\\n","\\n#include<stdlib.h>\\n#include<stdio.h>\\n#include<math.h>\\n\\nvoid processFile(char* name){\\n	\\n	int i,records;\\n	double diff,b1,b2;\\n	FILE* fp = fopen(name,\""r\"");\\n	\\n	fscanf(fp,\""%d\\n\"",&records);\\n	\\n	for(i=0;i=180)?diff-360:diff));	\\n	}\\n	\\n	fclose(fp);\\n}\\n\\nint main(int argC,char* argV[])\\n{\\n	double diff;\\n	\\n	if(argC < 2)\\n		printf(\""Usage : %s \"",argV[0]);\\n	else if(argC == 2)\\n		processFile(argV[1]);\\n	else{\\n		diff = fmod(atof(argV[2])-atof(argV[1]),360.0);\\n		printf(\""Difference between b2(%s) and b1(%s) is %lf\"",argV[2],argV[1],(diff<-180)?diff+360:((diff>=180)?diff-360:diff));\\n	}\\n\\n	return 0;\\n}\\n"
"C","Animate_a_pendulum","One good way of making an animation is by simulating a physical system and illustrating the variables in that system using a dynamically changing graphical display.\\nThe classic such physical system is a simple gravity pendulum.\\nFor this task, create a simple physical model of a pendulum and animate it.\\nThis does not use a GUI, it simply animates the pendulum and prints out the positions. If you want, you can replace the output method with graphical update methods.\\nX and Y are relative positions of the pendulum to the anchor.\\npendulums.ads:\\npendulums.adb:\\nexample main.adb:\\n","#include <stdlib.h>\\n#include <math.h>\\n#include \\n#include \\n#include \\n\\n#define length 5\\n#define g 9.8\\ndouble alpha, accl, omega = 0, E;\\nstruct timeval tv;\\n\\ndouble elappsed() {\\n	struct timeval now;\\n	gettimeofday(&now, 0);\\n	int ret = (now.tv_sec - tv.tv_sec) * 1000000\\n		+ now.tv_usec - tv.tv_usec;\\n	tv = now;\\n	return ret / 1.e6;\\n}\\n\\nvoid resize(int w, int h)\\n{\\n	glViewport(0, 0, w, h);\\n	glMatrixMode(GL_PROJECTION);\\n	glLoadIdentity();\\n\\n	glMatrixMode(GL_MODELVIEW);\\n	glLoadIdentity();\\n	glOrtho(0, w, h, 0, -1, 1);\\n}\\n\\nvoid render()\\n{\\n	double x = 320 + 300 * sin(alpha), y = 300 * cos(alpha);\\n	resize(640, 320);\\n 	glClear(GL_COLOR_BUFFER_BIT);\\n\\n	glBegin(GL_LINES);\\n	glVertex2d(320, 0);\\n	glVertex2d(x, y);\\n	glEnd();\\n	glFlush();\\n\\n	double us = elappsed();\\n	alpha += (omega + us * accl / 2) * us;\\n	omega += accl * us;\\n\\n	/* don't let precision error go out of hand */\\n	if (length * g * (1 - cos(alpha)) >= E) {\\n		alpha = (alpha < 0 ? -1 : 1) * acos(1 - E / length / g);\\n		omega = 0;\\n	}\\n	accl = -g / length * sin(alpha);\\n}\\n\\nvoid init_gfx(int *c, char **v)\\n{\\n	glutInit(c, v);\\n	glutInitDisplayMode(GLUT_RGB);\\n	glutInitWindowSize(640, 320);\\n	glutIdleFunc(render);\\n	glutCreateWindow(\""Pendulum\"");\\n}\\n\\nint main(int c, char **v)\\n{\\n	alpha = 4 * atan2(1, 1) / 2.1;\\n	E = length * g * (1 - cos(alpha));\\n\\n	accl = -g / length * sin(alpha);\\n	omega = 0;\\n\\n	gettimeofday(&tv, 0);\\n	init_gfx(&c, v);\\n	glutMainLoop();\\n	return 0;\\n}"
"C++","100_doors","There are 100 doors in a row that are all initially closed.\\nYou make 100 passes by the doors.\\nThe first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).\\nThe second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.\\nThe third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.\\n\\nAnswer the question:   what state are the doors in after the last pass?   Which are open, which are closed?\\n\\nAlternate:\\nAs noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.\\nOpening only those doors is an   optimization   that may also be expressed;\\nhowever, as should be obvious, this defeats the intent of comparing implementations across programming languages.\\n\\n","#include <iostream>\\n\\nint main()\\n{\\n  bool is_open[100] = { false };\\n\\n  // do the 100 passes\\n  for (int pass = 0; pass < 100; ++pass)\\n    for (int door = pass; door < 100; door += pass+1)\\n      is_open[door] = !is_open[door];\\n\\n  // output the result\\n  for (int door = 0; door < 100; ++door)\\n    std::cout << \""door #\"" << door+1 << (is_open[door]? \"" is open.\"" : \"" is closed.\"") << std::endl;\\n  return 0;\\n}"
"C++","100_doors","There are 100 doors in a row that are all initially closed.\\nYou make 100 passes by the doors.\\nThe first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).\\nThe second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.\\nThe third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.\\n\\nAnswer the question:   what state are the doors in after the last pass?   Which are open, which are closed?\\n\\nAlternate:\\nAs noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.\\nOpening only those doors is an   optimization   that may also be expressed;\\nhowever, as should be obvious, this defeats the intent of comparing implementations across programming languages.\\n\\n","#include <iostream>\\n\\nint main()\\n{\\n  int square = 1, increment = 3;\\n  for (int door = 1; door <= 100; ++door)\\n  {\\n    std::cout << \""door #\"" << door;\\n    if (door == square)\\n    {\\n      std::cout << \"" is open.\"" << std::endl;\\n      square += increment;\\n      increment += 2;\\n    }\\n    else\\n      std::cout << \"" is closed.\"" << std::endl;\\n  }\\n  return 0;\\n}"
"C++","100_doors","There are 100 doors in a row that are all initially closed.\\nYou make 100 passes by the doors.\\nThe first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).\\nThe second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.\\nThe third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.\\n\\nAnswer the question:   what state are the doors in after the last pass?   Which are open, which are closed?\\n\\nAlternate:\\nAs noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.\\nOpening only those doors is an   optimization   that may also be expressed;\\nhowever, as should be obvious, this defeats the intent of comparing implementations across programming languages.\\n\\n","#include <iostream> //compiled with \""Dev-C++\"" , from RaptorOne\\n\\nint main()\\n{\\n    for(int i=1; i*i<=100; i++)\\n            std::cout<<\""Door \""<\\n\\nCompile time computation using C++17 to produce fastest runtime.\\n#include <iostream>    // compiled with clang (tags/RELEASE_600/final)\\n#include  // or g++ (GCC) 7.3.1 20180406 -- from hare1039\\nnamespace functional_list // basic building block for template meta programming\\n{\\nstruct NIL\\n{\\n	using head = NIL;\\n	using tail = NIL;\\n	friend std::ostream& operator << (std::ostream& os, NIL const) { return os; }\\n};\\n\\ntemplate \\nstruct list\\n{\\n	using head = H;\\n	using tail = T;\\n};\\n\\ntemplate \\nstruct integer\\n{\\n	static constexpr int value = i;\\n	friend std::ostream& operator << (std::ostream& os, integer<i> const) { os << integer<i>::value; return os;}\\n};\\n\\ntemplate  constexpr\\nauto at()\\n{\\n	if constexpr (nTH == 0)\\n		return (typename L::head){};\\n	else if constexpr (not std::is_same_v) \\n		return at();\\n	else\\n		return NIL{};\\n}\\ntemplate \\nusing at_t = decltype(at());\\n\\ntemplate  constexpr\\nauto prepend() { return list{}; }\\n\\ntemplate \\nusing prepend_t = decltype(prepend());\\n	\\ntemplate  constexpr\\nauto gen_list()\\n{\\n	if constexpr (Size == 0)\\n		return NIL{};\\n	else\\n	{\\n		using next = decltype(gen_list());\\n		return prepend();\\n	}\\n}\\ntemplate \\nusing gen_list_t = decltype(gen_list());\\n	\\n} namespace fl = functional_list;\\n\\nconstexpr int door_amount = 101; // index from 1 to 100\\n\\ntemplate  constexpr\\nauto construct_loop()\\n{\\n	using val_t = fl::at_t;\\n	if constexpr (std::is_same_v)\\n		return fl::NIL{};\\n	else\\n	{\\n		constexpr int val = val_t::value;\\n		using val_add_t = fl::integer;\\n		using val_old_t = fl::integer<val>;\\n	\\n		if constexpr (current == door_amount)\\n		{\\n			if constexpr(current % moder == 0)\\n				return fl::list{};\\n			else\\n				return fl::list{};\\n		}\\n		else\\n		{\\n			using sub_list = decltype(construct_loop());\\n			if constexpr(current % moder == 0)\\n				return fl::prepend();\\n			else\\n				return fl::prepend();\\n		}\\n	}\\n}\\n\\ntemplate  constexpr\\nauto construct()\\n{\\n	if constexpr (iteration == 1) // door index = 1\\n	{\\n		using l = fl::gen_list_t;\\n		return construct_loop();\\n	}\\n	else\\n	{\\n		using prev_iter_list = decltype(construct());\\n		return construct_loop();\\n	}\\n}\\n\\ntemplate  constexpr\\nvoid show_ans()\\n{\\n	if constexpr (std::is_same_v)\\n		return;\\n	else\\n	{\\n		if constexpr (L::head::value % 2 == 1)\\n			std::cout << \""Door \"" << pos << \"" is opened.\\n\"";\\n		show_ans();\\n	}\\n}\\n\\nint main()\\n{\\n	using result = decltype(construct<100>());\\n	show_ans();\\n}\\n"
"C++","100_doors","There are 100 doors in a row that are all initially closed.\\nYou make 100 passes by the doors.\\nThe first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).\\nThe second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.\\nThe third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.\\n\\nAnswer the question:   what state are the doors in after the last pass?   Which are open, which are closed?\\n\\nAlternate:\\nAs noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.\\nOpening only those doors is an   optimization   that may also be expressed;\\nhowever, as should be obvious, this defeats the intent of comparing implementations across programming languages.\\n\\n","#include <iostream>    // compiled with clang (tags/RELEASE_600/final)\\n#include  // or g++ (GCC) 7.3.1 20180406 -- from hare1039\\nnamespace functional_list // basic building block for template meta programming\\n{\\nstruct NIL\\n{\\n	using head = NIL;\\n	using tail = NIL;\\n	friend std::ostream& operator << (std::ostream& os, NIL const) { return os; }\\n};\\n\\ntemplate \\nstruct list\\n{\\n	using head = H;\\n	using tail = T;\\n};\\n\\ntemplate \\nstruct integer\\n{\\n	static constexpr int value = i;\\n	friend std::ostream& operator << (std::ostream& os, integer<i> const) { os << integer<i>::value; return os;}\\n};\\n\\ntemplate  constexpr\\nauto at()\\n{\\n	if constexpr (nTH == 0)\\n		return (typename L::head){};\\n	else if constexpr (not std::is_same_v) \\n		return at();\\n	else\\n		return NIL{};\\n}\\ntemplate \\nusing at_t = decltype(at());\\n\\ntemplate  constexpr\\nauto prepend() { return list{}; }\\n\\ntemplate \\nusing prepend_t = decltype(prepend());\\n	\\ntemplate  constexpr\\nauto gen_list()\\n{\\n	if constexpr (Size == 0)\\n		return NIL{};\\n	else\\n	{\\n		using next = decltype(gen_list());\\n		return prepend();\\n	}\\n}\\ntemplate \\nusing gen_list_t = decltype(gen_list());\\n	\\n} namespace fl = functional_list;\\n\\nconstexpr int door_amount = 101; // index from 1 to 100\\n\\ntemplate  constexpr\\nauto construct_loop()\\n{\\n	using val_t = fl::at_t;\\n	if constexpr (std::is_same_v)\\n		return fl::NIL{};\\n	else\\n	{\\n		constexpr int val = val_t::value;\\n		using val_add_t = fl::integer;\\n		using val_old_t = fl::integer<val>;\\n	\\n		if constexpr (current == door_amount)\\n		{\\n			if constexpr(current % moder == 0)\\n				return fl::list{};\\n			else\\n				return fl::list{};\\n		}\\n		else\\n		{\\n			using sub_list = decltype(construct_loop());\\n			if constexpr(current % moder == 0)\\n				return fl::prepend();\\n			else\\n				return fl::prepend();\\n		}\\n	}\\n}\\n\\ntemplate  constexpr\\nauto construct()\\n{\\n	if constexpr (iteration == 1) // door index = 1\\n	{\\n		using l = fl::gen_list_t;\\n		return construct_loop();\\n	}\\n	else\\n	{\\n		using prev_iter_list = decltype(construct());\\n		return construct_loop();\\n	}\\n}\\n\\ntemplate  constexpr\\nvoid show_ans()\\n{\\n	if constexpr (std::is_same_v)\\n		return;\\n	else\\n	{\\n		if constexpr (L::head::value % 2 == 1)\\n			std::cout << \""Door \"" << pos << \"" is opened.\\n\"";\\n		show_ans();\\n	}\\n}\\n\\nint main()\\n{\\n	using result = decltype(construct<100>());\\n	show_ans();\\n}"
"C++","15_Puzzle_Game","\\nImplement the Fifteen Puzzle Game.\\n\\nThe   15-puzzle   is also known as:\\n\\n\\nWe fist define a generic package Generic_Puzzle. Upon instantiation, it can take any number of rows, any number of columns for a rows*columns-1 game. Instead of plain numbers, the tiles on the board can have arbitrary names (but they should all be of the same length). The package user can request the name for the tile at a certain (row,column)-point, and the set of possible moves. The user can move the empty space up, down, left and right (if possible). If the user makes the attempt to perform an impossible move, a Constraint_Error is raised.\\nThe package implementation is as follows.\\nThe main program reads the level from the command line. A larger level implies a more difficult instance. The default level is 10, which is fairly simple. After randomizing the board, the user can move the tiles.\\n","\\n#include <time.h>\\n#include <stdlib.h>\\n#include <vector>\\n#include <string>\\n#include <iostream>\\nclass p15 {\\npublic :\\n    void play() {\\n        bool p = true;\\n        std::string a;\\n        while( p ) {\\n            createBrd();\\n            while( !isDone() ) { drawBrd();getMove(); }\\n            drawBrd();\\n            std::cout << \""\\n\\nCongratulations!\\nPlay again (Y/N)?\"";\\n            std::cin >> a; if( a != \""Y\"" && a != \""y\"" ) break;\\n        }\\n    }\\nprivate:\\n    void createBrd() {\\n        int i = 1; std::vector<int> v;\\n        for( ; i < 16; i++ ) { brd[i - 1] = i; }\\n        brd[15] = 0; x = y = 3;\\n        for( i = 0; i < 1000; i++ ) {\\n            getCandidates( v );\\n            move( v[rand() % v.size()] );\\n            v.clear();\\n        }\\n    }\\n    void move( int d ) {\\n        int t = x + y * 4;\\n        switch( d ) {\\n            case 1: y--; break;\\n            case 2: x++; break;\\n            case 4: y++; break;\\n            case 8: x--;\\n        }\\n        brd[t] = brd[x + y * 4];\\n        brd[x + y * 4] = 0;\\n    }\\n    void getCandidates( std::vector<int>& v ) {\\n        if( x < 3 ) v.push_back( 2 ); if( x > 0 ) v.push_back( 8 );\\n        if( y < 3 ) v.push_back( 4 ); if( y > 0 ) v.push_back( 1 );\\n    }\\n    void drawBrd() {\\n        int r; std::cout << \""\\n\\n\"";\\n        for( int y = 0; y < 4; y++ ) {\\n            std::cout << \""+----+----+----+----+\\n\"";\\n            for( int x = 0; x < 4; x++ ) {\\n                r = brd[x + y * 4];\\n                std::cout << \""| \"";\\n                if( r < 10 ) std::cout << \"" \"";\\n                if( !r ) std::cout << \""  \"";\\n                else std::cout << r << \"" \"";\\n            }\\n            std::cout << \""|\\n\"";\\n        }\\n        std::cout << \""+----+----+----+----+\\n\"";\\n    }\\n    void getMove() {\\n        std::vector<int> v; getCandidates( v );\\n        std::vector<int> p; getTiles( p, v ); unsigned int i;\\n        while( true ) {\\n            std::cout << \""\\nPossible moves: \"";\\n            for( i = 0; i < p.size(); i++ ) std::cout << p[i] << \"" \"";\\n            int z; std::cin >> z;\\n            for( i = 0; i < p.size(); i++ )\\n                if( z == p[i] ) { move( v[i] ); return; }\\n        }\\n    }\\n    void getTiles( std::vector<int>& p, std::vector<int>& v ) {\\n        for( unsigned int t = 0; t < v.size(); t++ ) {\\n            int xx = x, yy = y;\\n            switch( v[t] ) {\\n                case 1: yy--; break;\\n                case 2: xx++; break;\\n                case 4: yy++; break;\\n                case 8: xx--;\\n            }\\n            p.push_back( brd[xx + yy * 4] );\\n        }\\n    }\\n    bool isDone() {\\n        for( int i = 0; i < 15; i++ ) {\\n            if( brd[i] != i + 1 ) return false;\\n        }\\n        return true;\\n    }\\n    int brd[16], x, y;\\n};\\nint main( int argc, char* argv[] ) {\\n    srand( ( unsigned )time( 0 ) );\\n    p15 p; p.play(); return 0;\\n}\\n"
"C++","15_puzzle_solver","Your task is to write a program that finds a solution in the fewest moves possible single moves to a random Fifteen Puzzle Game.\\nFor this task you will be using the following puzzle:\\n\\nThe output must show the moves' directions, like so: left, left, left, down, right... and so on.\\nThere are two solutions, of fifty-two moves:\\nrrrulddluuuldrurdddrullulurrrddldluurddlulurruldrdrd\\nrrruldluuldrurdddluulurrrdlddruldluurddlulurruldrrdd\\nsee: Pretty Print of Optimal Solution\\nFinding either one, or both is an acceptable result.\\nSolve the following problem:\\n\\n\\nsee for an analysis of 20 randomly generated 15 puzzles solved with this solver.\\n","\\n// Solve Random 15 Puzzles : Nigel Galloway - October 18th., 2017\\nclass fifteenSolver{\\n  const int Nr[16]{3,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3}, Nc[16]{3,0,1,2,3,0,1,2,3,0,1,2,3,0,1,2};\\n  int n{},_n{}, N0[100]{},N3[100]{},N4[100]{};\\n  unsigned long N2[100]{};\\n  const bool fY(){\\n    if (N2[n]==0x123456789abcdef0) {std::cout<<\""Solution found in \""<0){fG(); ++n; if (fY()) return true; --n;}\\n    if (N3[n]!='l' && N0[n]%4<3){fE(); ++n; if (fY()) return true; --n;}\\n    if (N3[n]!='r' && N0[n]%4>0){fL(); ++n; if (fY()) return true; --n;}\\n    return false;\\n  }\\n  void fI(){\\n    const int           g = (11-N0[n])*4;\\n    const unsigned long a = N2[n]&((unsigned long)15<>g]<=N0[n]/4?0:1);\\n  } \\n  void fG(){\\n    const int           g = (19-N0[n])*4;\\n    const unsigned long a = N2[n]&((unsigned long)15<>16); N3[n+1]='u'; N4[n+1]=N4[n]+(Nr[a>>g]>=N0[n]/4?0:1);\\n  } \\n  void fE(){\\n    const int           g = (14-N0[n])*4;\\n    const unsigned long a = N2[n]&((unsigned long)15<>g]<=N0[n]%4?0:1);\\n  } \\n  void fL(){\\n    const int           g = (16-N0[n])*4;\\n    const unsigned long a = N2[n]&((unsigned long)15<>4); N3[n+1]='l'; N4[n+1]=N4[n]+(Nc[a>>g]>=N0[n]%4?0:1);\\n  }\\npublic:\\n  fifteenSolver(int n, unsigned long g){N0[0]=n; N2[0]=g;}\\n  void Solve(){for(;not fY();++_n);}\\n};\\n"
"C++","15_puzzle_solver","Your task is to write a program that finds a solution in the fewest moves possible single moves to a random Fifteen Puzzle Game.\\nFor this task you will be using the following puzzle:\\n\\nThe output must show the moves' directions, like so: left, left, left, down, right... and so on.\\nThere are two solutions, of fifty-two moves:\\nrrrulddluuuldrurdddrullulurrrddldluurddlulurruldrdrd\\nrrruldluuldrurdddluulurrrdlddruldluurddlulurruldrrdd\\nsee: Pretty Print of Optimal Solution\\nFinding either one, or both is an acceptable result.\\nSolve the following problem:\\n\\n\\nsee for an analysis of 20 randomly generated 15 puzzles solved with this solver.\\n","\\nint main (){\\n  fifteenSolver start(8,0xfe169b4c0a73d852);\\n  start.Solve();\\n}\\n"
"C++","2048","Implement a 2D sliding block puzzle game where blocks with numbers are combined to add their values.\\nThe rules are that on each turn the player must choose a direction (up, down, left or right) and all tiles move as far as possible in that direction, some more than others. Two adjacent tiles (in that direction only) with matching numbers combine into one bearing the sum of those numbers. A move is valid when at least one tile can be moved, if only by combination. A new tile with the value of 2 is spawned at the end of each turn at a randomly chosen empty square, if there is one. To win the player must create a tile with the number 2048. The player loses if no valid moves are possible.\\nThe name comes from the popular open-source implementation of this game mechanic, 2048.\\nRequirements:\\nto the right should result in\\nand not\\nto the right should result in\\nand not\\n\\n","\\n#include <time.h>\\n#include <iostream>\\n#include <string>\\n#include <iomanip>\\n#include <cstdlib>\\n\\ntypedef unsigned int uint;\\nusing namespace std;\\nenum movDir { UP, DOWN, LEFT, RIGHT };\\n\\nclass tile\\n{\\npublic:\\n    tile() : val( 0 ), blocked( false ) {}\\n    uint val;\\n    bool blocked;\\n};\\n\\nclass g2048\\n{\\npublic:\\n    g2048() : done( false ), win( false ), moved( true ), score( 0 ) {}\\n    void loop()\\n    {\\n	addTile(); \\n	while( true )\\n	{\\n	    if( moved ) addTile();\\n	    drawBoard(); \\n	    if( done ) break;\\n	    waitKey();\\n	}\\n	string s = \""Game Over!\"";\\n	if( win ) s = \""You've made it!\"";\\n	cout << s << endl << endl;\\n    }\\nprivate:\\n    void drawBoard()\\n    {\\n	system( \""cls\"" );\\n	cout << \""SCORE: \"" << score << endl << endl;\\n	for( int y = 0; y < 4; y++ )\\n	{\\n	    cout << \""+------+------+------+------+\"" << endl << \""| \"";\\n	    for( int x = 0; x < 4; x++ )\\n	    {\\n		if( !board[x][y].val ) cout << setw( 4 ) << \"" \"";\\n		else cout << setw( 4 ) << board[x][y].val;\\n		cout << \"" | \"";\\n	    }\\n	    cout << endl;\\n	}\\n	cout << \""+------+------+------+------+\"" << endl << endl;\\n    }\\n    void waitKey()\\n    {\\n	moved = false; char c; \\n	cout << \""(W)Up (S)Down (A)Left (D)Right \""; cin >> c; c &= 0x5F;\\n	switch( c )\\n	{\\n	    case 'W': move( UP );break;\\n	    case 'A': move( LEFT ); break;\\n	    case 'S': move( DOWN ); break;\\n	    case 'D': move( RIGHT );\\n	}\\n	for( int y = 0; y < 4; y++ )\\n	    for( int x = 0; x < 4; x++ )\\n		board[x][y].blocked = false;\\n    }\\n    void addTile()\\n    {\\n	for( int y = 0; y < 4; y++ )\\n	    for( int x = 0; x < 4; x++ )\\n		if( !board[x][y].val )\\n		{\\n		    uint a, b;\\n		    do\\n		    { a = rand() % 4; b = rand() % 4; }\\n		    while( board[a][b].val );\\n\\n		    int s = rand() % 100;\\n		    if( s > 89 ) board[a][b].val = 4;\\n		    else board[a][b].val = 2;\\n		    if( canMove() ) return;\\n		}\\n	done = true;\\n    }\\n    bool canMove()\\n    {\\n	for( int y = 0; y < 4; y++ )\\n	    for( int x = 0; x < 4; x++ )\\n		if( !board[x][y].val ) return true;\\n\\n	for( int y = 0; y < 4; y++ )\\n	    for( int x = 0; x < 4; x++ )\\n	    {\\n		if( testAdd( x + 1, y, board[x][y].val ) ) return true;\\n		if( testAdd( x - 1, y, board[x][y].val ) ) return true;\\n		if( testAdd( x, y + 1, board[x][y].val ) ) return true;\\n		if( testAdd( x, y - 1, board[x][y].val ) ) return true;\\n	    }\\n	return false;\\n    }\\n    bool testAdd( int x, int y, uint v )\\n    {\\n	if( x < 0 || x > 3 || y < 0 || y > 3 ) return false;\\n	return board[x][y].val == v;\\n    }\\n    void moveVert( int x, int y, int d )\\n    {\\n	if( board[x][y + d].val && board[x][y + d].val == board[x][y].val && !board[x][y].blocked && !board[x][y + d].blocked  )\\n	{\\n	    board[x][y].val = 0;\\n	    board[x][y + d].val *= 2;\\n	    score += board[x][y + d].val;\\n	    board[x][y + d].blocked = true;\\n	    moved = true;\\n	}\\n	else if( !board[x][y + d].val && board[x][y].val )\\n	{\\n	    board[x][y + d].val = board[x][y].val;\\n	    board[x][y].val = 0;\\n	    moved = true;\\n	}\\n	if( d > 0 ) { if( y + d < 3 ) moveVert( x, y + d,  1 ); }\\n	else        { if( y + d > 0 ) moveVert( x, y + d, -1 ); }\\n    }\\n    void moveHori( int x, int y, int d )\\n    {\\n	if( board[x + d][y].val && board[x + d][y].val == board[x][y].val && !board[x][y].blocked && !board[x + d][y].blocked  )\\n	{\\n	    board[x][y].val = 0;\\n	    board[x + d][y].val *= 2;\\n	    score += board[x + d][y].val;\\n	    board[x + d][y].blocked = true;\\n	    moved = true;\\n	}\\n	else if( !board[x + d][y].val && board[x][y].val )\\n	{\\n	    board[x + d][y].val = board[x][y].val;\\n	    board[x][y].val = 0;\\n	    moved = true;\\n	}\\n	if( d > 0 ) { if( x + d < 3 ) moveHori( x + d, y,  1 ); }\\n	else        { if( x + d > 0 ) moveHori( x + d, y, -1 ); }\\n    }\\n    void move( movDir d )\\n    {\\n	switch( d )\\n	{\\n	    case UP:\\n	    	for( int x = 0; x < 4; x++ )\\n		{\\n		    int y = 1;\\n		    while( y < 4 )\\n		    { if( board[x][y].val ) moveVert( x, y, -1 ); y++;}\\n		}\\n		break;\\n	    case DOWN:\\n		for( int x = 0; x < 4; x++ )\\n		{\\n		    int y = 2;\\n		    while( y >= 0 )\\n		    { if( board[x][y].val ) moveVert( x, y, 1 ); y--;}\\n		}\\n		break;\\n	    case LEFT:\\n		for( int y = 0; y < 4; y++ )\\n		{\\n		    int x = 1;\\n		    while( x < 4 )\\n		    { if( board[x][y].val ) moveHori( x, y, -1 ); x++;}\\n		}\\n		break;\\n	    case RIGHT:\\n		for( int y = 0; y < 4; y++ )\\n		{\\n		    int x = 2;\\n		    while( x >= 0 )\\n		    { if( board[x][y].val ) moveHori( x, y, 1 ); x--;}\\n		}\\n	}\\n    }\\n    tile board[4][4];\\n    bool win, done, moved;\\n    uint score;\\n};\\nint main( int argc, char* argv[] )\\n{\\n    srand( static_cast<uint>( time( NULL ) ) );\\n    g2048 g; g.loop();\\n    return system( \""pause\"" );\\n}\\n"
"C++","24_game/Solve","Write a program that takes four digits, either from user input or by random generation, and computes arithmetic expressions following the rules of the 24 game.\\nShow examples of solutions generated by the program.\\n\\n\\nWill generate all possible solutions of any given four numbers according to the rules of the 24 game.\\nNote: the permute function was locally from here\\nSample Runs:\\nExamples:\\nOutput is in RPN.\\n","\\n#include <iostream>\\n#include <ratio>\\n#include <array>\\n#include <algorithm>\\n#include <random>\\n\\ntypedef short int Digit;  // Typedef for the digits data type.\\n\\nconstexpr Digit nDigits{4};      // Amount of digits that are taken into the game.\\nconstexpr Digit maximumDigit{9}; // Maximum digit that may be taken into the game.\\nconstexpr short int gameGoal{24};    // Desired result.\\n\\ntypedef std::array digitSet; // Typedef for the set of digits in the game.\\ndigitSet d;\\n\\nvoid printTrivialOperation(std::string operation) { // Prints a commutative operation taking all the digits.\\n	bool printOperation(false);\\n	for(const Digit& number : d) {\\n		if(printOperation)\\n			std::cout << operation;\\n		else\\n			printOperation = true;\\n		std::cout << number;\\n	}\\n	std::cout << std::endl;\\n}\\n\\nvoid printOperation(std::string prefix, std::string operation1, std::string operation2, std::string operation3, std::string suffix = \""\"") {\\n	std::cout << prefix << d[0] << operation1 << d[1] << operation2 << d[2] << operation3 << d[3] << suffix << std::endl;\\n}\\n\\nint main() {\\n	std::mt19937_64 randomGenerator;\\n	std::uniform_int_distribution<Digit> digitDistro{1, maximumDigit};\\n	// Let us set up a number of trials:\\n	for(int trial{10}; trial; --trial) {\\n		for(Digit& digit : d) {\\n			digit = digitDistro(randomGenerator);\\n			std::cout << digit << \"" \"";\\n		}\\n		std::cout << std::endl;\\n		std::sort(d.begin(), d.end());\\n		// We start with the most trivial, commutative operations:\\n		if(std::accumulate(d.cbegin(), d.cend(), 0) == gameGoal)\\n			printTrivialOperation(\"" + \"");\\n		if(std::accumulate(d.cbegin(), d.cend(), 1, std::multiplies<Digit>{}) == gameGoal)\\n			printTrivialOperation(\"" * \"");\\n		// Now let's start working on every permutation of the digits.\\n		do {\\n			// Operations with 2 symbols + and one symbol -:\\n			if(d[0] + d[1] + d[2] - d[3] == gameGoal) printOperation(\""\"", \"" + \"", \"" + \"", \"" - \""); // If gameGoal is ever changed to a smaller value, consider adding more operations in this category.\\n			// Operations with 2 symbols + and one symbol *:\\n			if(d[0] * d[1] + d[2] + d[3] == gameGoal) printOperation(\""\"", \"" * \"", \"" + \"", \"" + \"");\\n			if(d[0] * (d[1] + d[2]) + d[3] == gameGoal) printOperation(\""\"", \"" * ( \"", \"" + \"", \"" ) + \"");\\n			if(d[0] * (d[1] + d[2] + d[3]) == gameGoal) printOperation(\""\"", \"" * ( \"", \"" + \"", \"" + \"", \"" )\"");\\n			// Operations with one symbol + and 2 symbols *:\\n			if((d[0] * d[1] * d[2]) + d[3] == gameGoal) printOperation(\""( \"", \"" * \"", \"" * \"", \"" ) + \"");\\n			if(d[0] * d[1] * (d[2] + d[3]) == gameGoal) printOperation(\""( \"", \"" * \"", \"" * ( \"", \"" + \"", \"" )\"");\\n			if((d[0] * d[1]) + (d[2] * d[3]) == gameGoal) printOperation(\""( \"", \"" * \"", \"" ) + ( \"", \"" * \"", \"" )\"");\\n			// Operations with one symbol - and 2 symbols *:\\n			if((d[0] * d[1] * d[2]) - d[3] == gameGoal) printOperation(\""( \"", \"" * \"", \"" * \"", \"" ) - \"");\\n			if(d[0] * d[1] * (d[2] - d[3]) == gameGoal) printOperation(\""( \"", \"" * \"", \"" * ( \"", \"" - \"", \"" )\"");\\n			if((d[0] * d[1]) - (d[2] * d[3]) == gameGoal) printOperation(\""( \"", \"" * \"", \"" ) - ( \"", \"" * \"", \"" )\"");\\n			// Operations with one symbol +, one symbol *, and one symbol -:\\n			if(d[0] * d[1] + d[2] - d[3] == gameGoal) printOperation(\""\"", \"" * \"", \"" + \"", \"" - \"");\\n			if(d[0] * (d[1] + d[2]) - d[3] == gameGoal) printOperation(\""\"", \"" * ( \"", \"" + \"", \"" ) - \"");\\n			if(d[0] * (d[1] - d[2]) + d[3] == gameGoal) printOperation(\""\"", \"" * ( \"", \"" - \"", \"" ) + \"");\\n			if(d[0] * (d[1] + d[2] - d[3]) == gameGoal) printOperation(\""\"", \"" * ( \"", \"" + \"", \"" - \"", \"" )\"");\\n			if(d[0] * d[1] - (d[2] + d[3]) == gameGoal) printOperation(\""\"", \"" * \"", \"" - ( \"", \"" + \"", \"" )\"");\\n			// Operations with one symbol *, one symbol /, one symbol +:\\n			if(d[0] * d[1] == (gameGoal - d[3]) * d[2]) printOperation(\""( \"", \"" * \"", \"" / \"", \"" ) + \"");\\n			if(((d[0] * d[1]) + d[2]) == gameGoal * d[3]) printOperation(\""(( \"", \"" * \"", \"" ) + \"", \"" ) / \"");\\n			if((d[0] + d[1]) * d[2] == gameGoal * d[3]) printOperation(\""(( \"", \"" + \"", \"" ) * \"", \"" ) / \"");\\n			if(d[0] * d[1] == gameGoal * (d[2] + d[3])) printOperation(\""( \"", \"" * \"", \"" ) / ( \"", \"" + \"", \"" )\"");\\n			// Operations with one symbol *, one symbol /, one symbol -:\\n			if(d[0] * d[1] == (gameGoal + d[3]) * d[2]) printOperation(\""( \"", \"" * \"", \"" / \"", \"" ) - \"");\\n			if(((d[0] * d[1]) - d[2]) == gameGoal * d[3]) printOperation(\""(( \"", \"" * \"", \"" ) - \"", \"" ) / \"");\\n			if((d[0] - d[1]) * d[2] == gameGoal * d[3]) printOperation(\""(( \"", \"" - \"", \"" ) * \"", \"" ) / \"");\\n			if(d[0] * d[1] == gameGoal * (d[2] - d[3])) printOperation(\""( \"", \"" * \"", \"" ) / ( \"", \"" - \"", \"" )\"");\\n			// Operations with 2 symbols *, one symbol /:\\n			if(d[0] * d[1] * d[2] == gameGoal * d[3]) printOperation(\""\"", \"" * \"", \"" * \"", \"" / \"");\\n			if(d[0] * d[1] == gameGoal * d[2] * d[3]) printOperation(\""\"", \"" * \"", \"" / ( \"", \"" * \"", \"" )\"");\\n			// Operations with 2 symbols /, one symbol -:\\n			if(d[0] * d[3] == gameGoal * (d[1] * d[3] - d[2])) printOperation(\""\"", \"" / ( \"", \"" - \"", \"" / \"", \"" )\"");\\n			// Operations with 2 symbols /, one symbol *:\\n			if(d[0] * d[1] == gameGoal * d[2] * d[3]) printOperation(\""( \"", \"" * \"", \"" / \"", \"" ) / \"", \""\"");\\n		} while(std::next_permutation(d.begin(), d.end())); // All operations are repeated for all possible permutations of the numbers.\\n	}\\n	return 0;\\n}\\n"
"C++","4-rings_or_4-squares_puzzle","Replace       a, b, c, d, e, f,   and\\n  g        with the decimal\\ndigits   LOW   ───►   HIGH\\nsuch that the sum of the letters inside of each of the four large squares add up to\\nthe same sum.\\nShow all output here.\\n\\n\\n\\nAs with the REXX solution, we use explicit loops to generate the permutations.\\n","\\n//C++14/17\\n#include <algorithm>//std::for_each\\n#include <iostream> //std::cout\\n#include <numeric>  //std::iota\\n#include <vector>   //std::vector, save solutions\\n#include <list>     //std::list, for fast erase\\n\\nusing std::begin, std::end, std::for_each;\\n\\n//Generates all the valid solutions for the problem in the specified range [from, to)\\nstd::list combinations(int from, int to)\\n{\\n    if (from > to)\\n        return {};                          //Return nothing if limits are invalid\\n\\n    auto pool = std::vector<int>(to - from);//Here we'll save our values\\n    std::iota(begin(pool), end(pool), from);//Populates pool\\n\\n    auto solutions = std::list{};   //List for the solutions\\n\\n    //Brute-force calculation of valid values...\\n    for (auto a : pool)\\n        for (auto b : pool)\\n            for (auto c : pool)\\n                for (auto d : pool)\\n                    for (auto e : pool)\\n                        for (auto f : pool)\\n                            for (auto g : pool)\\n                                if ( a      == c + d\\n                                  && b + c  == e + f\\n                                  && d + e  ==     g )\\n                                    solutions.push_back({a, b, c, d, e, f, g});\\n    return solutions;\\n}\\n\\n//Filter the list generated from \""combinations\"" and return only lists with no repetitions\\nstd::list filter_unique(int from, int to)\\n{\\n    //Helper lambda to check repetitions:\\n    //If the count is > 1 for an element, there must be a repetition inside the range\\n    auto has_non_unique_values = [](const auto & range, auto target)\\n    {\\n        return std::count( begin(range), end(range), target) > 1;\\n    };\\n\\n    //Generates all the solutions...\\n    auto results = combinations(from, to);\\n\\n    //For each solution, find duplicates inside\\n    for (auto subrange = cbegin(results); subrange != cend(results); ++subrange)\\n    {\\n        bool repetition = false;\\n\\n        //If some element is repeated, repetition becomes true \\n        for (auto x : *subrange)\\n            repetition |= has_non_unique_values(*subrange, x);\\n\\n        if (repetition)    //If repetition is true, remove the current subrange from the list\\n        {\\n            results.erase(subrange);        //Deletes subrange from solutions\\n            --subrange;                     //Rewind to the last subrange analysed\\n        }\\n    }\\n\\n    return results; //Finally return remaining results\\n}\\n\\ntemplate  //Template for the sake of simplicity\\ninline void print_range(const Container & c)\\n{\\n    for (const auto & subrange : c)\\n    {\\n        std::cout << \""[\"";\\n        for (auto elem : subrange)\\n            std::cout << elem << ' ';\\n        std::cout << \""\\b]\\n\"";\\n    }\\n}\\n\\n\\nint main()\\n{\\n    std::cout << \""Unique-numbers combinations in range 1-7:\\n\"";\\n    auto solution1 = filter_unique(1, 8);\\n    print_range(solution1);\\n    std::cout << \""\\nUnique-numbers combinations in range 3-9:\\n\"";\\n    auto solution2 = filter_unique(3,10);\\n    print_range(solution2);\\n    std::cout << \""\\nNumber of combinations in range 0-9: \"" \\n              << combinations(0, 10).size() << \"".\"" << std::endl;\\n\\n    return 0;\\n}\\n"
"C++","9_billion_names_of_God_the_integer","This task is a variation of the short story by Arthur C. Clarke.\\n(Solvers should be aware of the consequences of completing this task.)\\nIn detail, to specify what is meant by a   “name”:\\n\\nDisplay the first 25 rows of a number triangle which begins:\\nWhere row   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n   corresponds to integer   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n,   and each column   \\n\\n\\n\\nC\\n\\n\\n{\\displaystyle C}\\n\\n   in row   \\n\\n\\n\\nm\\n\\n\\n{\\displaystyle m}\\n\\n   from left to right corresponds to the number of names beginning with   \\n\\n\\n\\nC\\n\\n\\n{\\displaystyle C}\\n\\n.\\nA function   \\n\\n\\n\\nG\\n(\\nn\\n)\\n\\n\\n{\\displaystyle G(n)}\\n\\n   should return the sum of the   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n-th   row.\\nDemonstrate this function by displaying:   \\n\\n\\n\\nG\\n(\\n23\\n)\\n\\n\\n{\\displaystyle G(23)}\\n\\n,   \\n\\n\\n\\nG\\n(\\n123\\n)\\n\\n\\n{\\displaystyle G(123)}\\n\\n,   \\n\\n\\n\\nG\\n(\\n1234\\n)\\n\\n\\n{\\displaystyle G(1234)}\\n\\n,   and   \\n\\n\\n\\nG\\n(\\n12345\\n)\\n\\n\\n{\\displaystyle G(12345)}\\n\\n.\\nOptionally note that the sum of the   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n-th   row   \\n\\n\\n\\nP\\n(\\nn\\n)\\n\\n\\n{\\displaystyle P(n)}\\n\\n   is the     integer partition function.\\nDemonstrate this is equivalent to   \\n\\n\\n\\nG\\n(\\nn\\n)\\n\\n\\n{\\displaystyle G(n)}\\n\\n   by displaying:   \\n\\n\\n\\nP\\n(\\n23\\n)\\n\\n\\n{\\displaystyle P(23)}\\n\\n,   \\n\\n\\n\\nP\\n(\\n123\\n)\\n\\n\\n{\\displaystyle P(123)}\\n\\n,   \\n\\n\\n\\nP\\n(\\n1234\\n)\\n\\n\\n{\\displaystyle P(1234)}\\n\\n,   and   \\n\\n\\n\\nP\\n(\\n12345\\n)\\n\\n\\n{\\displaystyle P(12345)}\\n\\n.\\n\\nIf your environment is able, plot   \\n\\n\\n\\nP\\n(\\nn\\n)\\n\\n\\n{\\displaystyle P(n)}\\n\\n   against   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n   for   \\n\\n\\n\\nn\\n=\\n1\\n…\\n999\\n\\n\\n{\\displaystyle n=1\\ldots 999}\\n\\n.\\n\\n","\\n// Calculate hypotenuse n of OTT assuming only nothingness, unity, and hyp[n-1] if n>1\\n// Nigel Galloway, May 6th., 2013\\n#include <gmpxx.h>\\nint N{123456};\\nmpz_class hyp[N-3];\\nconst mpz_class G(const int n,const int g){return g>n?0:(g==1 or n-g<2)?1:hyp[n-g-2];};\\nvoid G_hyp(const int n){for(int i=0;i\\n\\n===The Alpha and Omega, Beauty===\\nBefore displaying the triangle the following code displays hyp as it is transformed by consequtive calls of G_hyp.\\n\\n#include <iostream>\\n#include <iomanip>\\nint main(){\\n  N=25;\\n  for (int n=1; n\\n{{out}}\\n<pre>\\n   2   2   3   3   4   4   5   5   6   6   7   7   8   8   9   9  10  10  11  11  12  12\\n   2   3   4   5   7   8  10  12  14  16  19  21  24  27  30  33  37  40  44  48  52  12\\n   2   3   5   6   9  11  15  18  23  27  34  39  47  54  64  72  84  94 108 120  52  12\\n   2   3   5   7  10  13  18  23  30  37  47  57  70  84 101 119 141 164 192 120  52  12\\n   2   3   5   7  11  14  20  26  35  44  58  71  90 110 136 163 199 235 192 120  52  12\\n   2   3   5   7  11  15  21  28  38  49  65  82 105 131 164 201 248 235 192 120  52  12\\n   2   3   5   7  11  15  22  29  40  52  70  89 116 146 186 230 248 235 192 120  52  12\\n   2   3   5   7  11  15  22  30  41  54  73  94 123 157 201 230 248 235 192 120  52  12\\n   2   3   5   7  11  15  22  30  42  55  75  97 128 164 201 230 248 235 192 120  52  12\\n   2   3   5   7  11  15  22  30  42  56  76  99 131 164 201 230 248 235 192 120  52  12\\n   2   3   5   7  11  15  22  30  42  56  77 100 131 164 201 230 248 235 192 120  52  12\\n"
"C++","9_billion_names_of_God_the_integer","This task is a variation of the short story by Arthur C. Clarke.\\n(Solvers should be aware of the consequences of completing this task.)\\nIn detail, to specify what is meant by a   “name”:\\n\\nDisplay the first 25 rows of a number triangle which begins:\\nWhere row   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n   corresponds to integer   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n,   and each column   \\n\\n\\n\\nC\\n\\n\\n{\\displaystyle C}\\n\\n   in row   \\n\\n\\n\\nm\\n\\n\\n{\\displaystyle m}\\n\\n   from left to right corresponds to the number of names beginning with   \\n\\n\\n\\nC\\n\\n\\n{\\displaystyle C}\\n\\n.\\nA function   \\n\\n\\n\\nG\\n(\\nn\\n)\\n\\n\\n{\\displaystyle G(n)}\\n\\n   should return the sum of the   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n-th   row.\\nDemonstrate this function by displaying:   \\n\\n\\n\\nG\\n(\\n23\\n)\\n\\n\\n{\\displaystyle G(23)}\\n\\n,   \\n\\n\\n\\nG\\n(\\n123\\n)\\n\\n\\n{\\displaystyle G(123)}\\n\\n,   \\n\\n\\n\\nG\\n(\\n1234\\n)\\n\\n\\n{\\displaystyle G(1234)}\\n\\n,   and   \\n\\n\\n\\nG\\n(\\n12345\\n)\\n\\n\\n{\\displaystyle G(12345)}\\n\\n.\\nOptionally note that the sum of the   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n-th   row   \\n\\n\\n\\nP\\n(\\nn\\n)\\n\\n\\n{\\displaystyle P(n)}\\n\\n   is the     integer partition function.\\nDemonstrate this is equivalent to   \\n\\n\\n\\nG\\n(\\nn\\n)\\n\\n\\n{\\displaystyle G(n)}\\n\\n   by displaying:   \\n\\n\\n\\nP\\n(\\n23\\n)\\n\\n\\n{\\displaystyle P(23)}\\n\\n,   \\n\\n\\n\\nP\\n(\\n123\\n)\\n\\n\\n{\\displaystyle P(123)}\\n\\n,   \\n\\n\\n\\nP\\n(\\n1234\\n)\\n\\n\\n{\\displaystyle P(1234)}\\n\\n,   and   \\n\\n\\n\\nP\\n(\\n12345\\n)\\n\\n\\n{\\displaystyle P(12345)}\\n\\n.\\n\\nIf your environment is able, plot   \\n\\n\\n\\nP\\n(\\nn\\n)\\n\\n\\n{\\displaystyle P(n)}\\n\\n   against   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n   for   \\n\\n\\n\\nn\\n=\\n1\\n…\\n999\\n\\n\\n{\\displaystyle n=1\\ldots 999}\\n\\n.\\n\\n","\\n#include <iostream>\\n#include <iomanip>\\nint main(){\\n  N=25;\\n  for (int n=1; n\\n{{out}}\\n<pre>\\n   2   2   3   3   4   4   5   5   6   6   7   7   8   8   9   9  10  10  11  11  12  12\\n   2   3   4   5   7   8  10  12  14  16  19  21  24  27  30  33  37  40  44  48  52  12\\n   2   3   5   6   9  11  15  18  23  27  34  39  47  54  64  72  84  94 108 120  52  12\\n   2   3   5   7  10  13  18  23  30  37  47  57  70  84 101 119 141 164 192 120  52  12\\n   2   3   5   7  11  14  20  26  35  44  58  71  90 110 136 163 199 235 192 120  52  12\\n   2   3   5   7  11  15  21  28  38  49  65  82 105 131 164 201 248 235 192 120  52  12\\n   2   3   5   7  11  15  22  29  40  52  70  89 116 146 186 230 248 235 192 120  52  12\\n   2   3   5   7  11  15  22  30  41  54  73  94 123 157 201 230 248 235 192 120  52  12\\n   2   3   5   7  11  15  22  30  42  55  75  97 128 164 201 230 248 235 192 120  52  12\\n   2   3   5   7  11  15  22  30  42  56  76  99 131 164 201 230 248 235 192 120  52  12\\n   2   3   5   7  11  15  22  30  42  56  77 100 131 164 201 230 248 235 192 120  52  12\\n"
"C++","9_billion_names_of_God_the_integer","This task is a variation of the short story by Arthur C. Clarke.\\n(Solvers should be aware of the consequences of completing this task.)\\nIn detail, to specify what is meant by a   “name”:\\n\\nDisplay the first 25 rows of a number triangle which begins:\\nWhere row   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n   corresponds to integer   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n,   and each column   \\n\\n\\n\\nC\\n\\n\\n{\\displaystyle C}\\n\\n   in row   \\n\\n\\n\\nm\\n\\n\\n{\\displaystyle m}\\n\\n   from left to right corresponds to the number of names beginning with   \\n\\n\\n\\nC\\n\\n\\n{\\displaystyle C}\\n\\n.\\nA function   \\n\\n\\n\\nG\\n(\\nn\\n)\\n\\n\\n{\\displaystyle G(n)}\\n\\n   should return the sum of the   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n-th   row.\\nDemonstrate this function by displaying:   \\n\\n\\n\\nG\\n(\\n23\\n)\\n\\n\\n{\\displaystyle G(23)}\\n\\n,   \\n\\n\\n\\nG\\n(\\n123\\n)\\n\\n\\n{\\displaystyle G(123)}\\n\\n,   \\n\\n\\n\\nG\\n(\\n1234\\n)\\n\\n\\n{\\displaystyle G(1234)}\\n\\n,   and   \\n\\n\\n\\nG\\n(\\n12345\\n)\\n\\n\\n{\\displaystyle G(12345)}\\n\\n.\\nOptionally note that the sum of the   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n-th   row   \\n\\n\\n\\nP\\n(\\nn\\n)\\n\\n\\n{\\displaystyle P(n)}\\n\\n   is the     integer partition function.\\nDemonstrate this is equivalent to   \\n\\n\\n\\nG\\n(\\nn\\n)\\n\\n\\n{\\displaystyle G(n)}\\n\\n   by displaying:   \\n\\n\\n\\nP\\n(\\n23\\n)\\n\\n\\n{\\displaystyle P(23)}\\n\\n,   \\n\\n\\n\\nP\\n(\\n123\\n)\\n\\n\\n{\\displaystyle P(123)}\\n\\n,   \\n\\n\\n\\nP\\n(\\n1234\\n)\\n\\n\\n{\\displaystyle P(1234)}\\n\\n,   and   \\n\\n\\n\\nP\\n(\\n12345\\n)\\n\\n\\n{\\displaystyle P(12345)}\\n\\n.\\n\\nIf your environment is able, plot   \\n\\n\\n\\nP\\n(\\nn\\n)\\n\\n\\n{\\displaystyle P(n)}\\n\\n   against   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n   for   \\n\\n\\n\\nn\\n=\\n1\\n…\\n999\\n\\n\\n{\\displaystyle n=1\\ldots 999}\\n\\n.\\n\\n","\\nint main(){\\n  N = 25;\\n  std::cout << std::setw(N+52) << \""1\"" << std::endl;\\n  std::cout << std::setw(N+55) << \""1     1\"" << std::endl;\\n  std::cout << std::setw(N+58) << \""1     1     1\"" << std::endl;\\n  std::string ott[N-3];\\n  for (int n=1; n0; g--) {\\n      std::string t{hyp[g-1].get_str()};\\n      t.append(6-t.size(),' ');\\n      std::cout << t;\\n    }\\n    std::cout << \""1     1\"" << std::endl; \\n  }\\n"
"C++","9_billion_names_of_God_the_integer","This task is a variation of the short story by Arthur C. Clarke.\\n(Solvers should be aware of the consequences of completing this task.)\\nIn detail, to specify what is meant by a   “name”:\\n\\nDisplay the first 25 rows of a number triangle which begins:\\nWhere row   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n   corresponds to integer   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n,   and each column   \\n\\n\\n\\nC\\n\\n\\n{\\displaystyle C}\\n\\n   in row   \\n\\n\\n\\nm\\n\\n\\n{\\displaystyle m}\\n\\n   from left to right corresponds to the number of names beginning with   \\n\\n\\n\\nC\\n\\n\\n{\\displaystyle C}\\n\\n.\\nA function   \\n\\n\\n\\nG\\n(\\nn\\n)\\n\\n\\n{\\displaystyle G(n)}\\n\\n   should return the sum of the   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n-th   row.\\nDemonstrate this function by displaying:   \\n\\n\\n\\nG\\n(\\n23\\n)\\n\\n\\n{\\displaystyle G(23)}\\n\\n,   \\n\\n\\n\\nG\\n(\\n123\\n)\\n\\n\\n{\\displaystyle G(123)}\\n\\n,   \\n\\n\\n\\nG\\n(\\n1234\\n)\\n\\n\\n{\\displaystyle G(1234)}\\n\\n,   and   \\n\\n\\n\\nG\\n(\\n12345\\n)\\n\\n\\n{\\displaystyle G(12345)}\\n\\n.\\nOptionally note that the sum of the   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n-th   row   \\n\\n\\n\\nP\\n(\\nn\\n)\\n\\n\\n{\\displaystyle P(n)}\\n\\n   is the     integer partition function.\\nDemonstrate this is equivalent to   \\n\\n\\n\\nG\\n(\\nn\\n)\\n\\n\\n{\\displaystyle G(n)}\\n\\n   by displaying:   \\n\\n\\n\\nP\\n(\\n23\\n)\\n\\n\\n{\\displaystyle P(23)}\\n\\n,   \\n\\n\\n\\nP\\n(\\n123\\n)\\n\\n\\n{\\displaystyle P(123)}\\n\\n,   \\n\\n\\n\\nP\\n(\\n1234\\n)\\n\\n\\n{\\displaystyle P(1234)}\\n\\n,   and   \\n\\n\\n\\nP\\n(\\n12345\\n)\\n\\n\\n{\\displaystyle P(12345)}\\n\\n.\\n\\nIf your environment is able, plot   \\n\\n\\n\\nP\\n(\\nn\\n)\\n\\n\\n{\\displaystyle P(n)}\\n\\n   against   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n   for   \\n\\n\\n\\nn\\n=\\n1\\n…\\n999\\n\\n\\n{\\displaystyle n=1\\ldots 999}\\n\\n.\\n\\n","\\n#include <iostream>\\nint main(){\\n  for (int n=1; n\\n{{out}}\\n<pre>\\nG(23)     = 1255\\nG(123)    = 2552338241\\nG(1234)   = 156978797223733228787865722354959930\\nG(12345)  = 69420357953926116819562977205209384460667673094671463620270321700806074195845953959951425306140971942519870679768681736\\nG(123456) = 30817659578536496678545317146533980855296613274507139217608776782063054452191537379312358383342446230621170608408020911309259407611257151683372221925128388387168451943800027128045369650890220060901494540459081545445020808726917371699102825508039173543836338081612528477859613355349851184591540231790254269948278726548570660145691076819912972162262902150886818986555127204165221706149989\\n"
"C++","99_Bottles_of_Beer","Display the complete lyrics for the song:     99 Bottles of Beer on the Wall.\\n\\nThe lyrics follow this form:\\n 99 bottles of beer on the wall\\n99 bottles of beer\\nTake one down, pass it around\\n98 bottles of beer on the wall\\n 98 bottles of beer on the wall\\n98 bottles of beer\\nTake one down, pass it around\\n97 bottles of beer on the wall\\n... and so on, until reaching 0.\\nGrammatical support for \""1 bottle of beer\"" is optional.\\nAs with any puzzle, try to do it in as creative/concise/comical a way\\nas possible (simple, obvious solutions allowed, too).\\n\\n\\n\\nSee 99 Bottles of Beer/EsoLang\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nor (With ABAP 7.40)\\nSee 99 Bottles of Beer/Lisp\\nwith 1 task to print out the information and 99 tasks to specify the number of bottles\\nImplementation in Apache Ant, due to the limitations of Ant, this requires ant-contrib for arithmetic operations and a dummy target to keep Ant from detecting the loop.\\n\\nNote that the output label text is not displayed until the entire lyrics text has been built and there is some delay between button press and display.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\nOutput can be sent directly to a label with this preferred method as there is no noticeable delay between button press and output.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\n\\n\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Shell\\nSee 99 Bottles of Beer/Shell\\nIf you don't want so many beers, here you can specify the starting amount. \\nFor example, just a sixpack:\\n","#include <iostream>\\nusing std::cout;\\n\\nint main() \\n{\\n  for(int bottles(99); bottles > 0; bottles -= 1){\\n    cout << bottles << \"" bottles of beer on the wall\\n\""\\n         << bottles << \"" bottles of beer\\n\""\\n         << \""Take one down, pass it around\\n\""\\n         << bottles - 1 << \"" bottles of beer on the wall\\n\\n\"";\\n  }\\n}"
"C++","99_Bottles_of_Beer","Display the complete lyrics for the song:     99 Bottles of Beer on the Wall.\\n\\nThe lyrics follow this form:\\n 99 bottles of beer on the wall\\n99 bottles of beer\\nTake one down, pass it around\\n98 bottles of beer on the wall\\n 98 bottles of beer on the wall\\n98 bottles of beer\\nTake one down, pass it around\\n97 bottles of beer on the wall\\n... and so on, until reaching 0.\\nGrammatical support for \""1 bottle of beer\"" is optional.\\nAs with any puzzle, try to do it in as creative/concise/comical a way\\nas possible (simple, obvious solutions allowed, too).\\n\\n\\n\\nSee 99 Bottles of Beer/EsoLang\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nor (With ABAP 7.40)\\nSee 99 Bottles of Beer/Lisp\\nwith 1 task to print out the information and 99 tasks to specify the number of bottles\\nImplementation in Apache Ant, due to the limitations of Ant, this requires ant-contrib for arithmetic operations and a dummy target to keep Ant from detecting the loop.\\n\\nNote that the output label text is not displayed until the entire lyrics text has been built and there is some delay between button press and display.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\nOutput can be sent directly to a label with this preferred method as there is no noticeable delay between button press and output.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\n\\n\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Shell\\nSee 99 Bottles of Beer/Shell\\nIf you don't want so many beers, here you can specify the starting amount. \\nFor example, just a sixpack:\\n","#include <iostream>\\n\\ntemplate struct bottle_countdown\\n{\\n  static const int middle = (min + max)/2;\\n  static void print()\\n  {\\n    bottle_countdown::print();\\n    bottle_countdown::print();\\n  }\\n};\\n\\ntemplate struct bottle_countdown\\n{\\n  static void print()\\n  {\\n    std::cout << value << \"" bottles of beer on the wall\\n\""\\n              << value << \"" bottles of beer\\n\""\\n              << \""Take one down, pass it around\\n\""\\n              << value-1 << \"" bottles of beer\\n\\n\"";\\n  }\\n};\\n\\nint main()\\n{\\n  bottle_countdown<100, 1>::print();\\n  return 0;\\n}"
"C++","99_Bottles_of_Beer","Display the complete lyrics for the song:     99 Bottles of Beer on the Wall.\\n\\nThe lyrics follow this form:\\n 99 bottles of beer on the wall\\n99 bottles of beer\\nTake one down, pass it around\\n98 bottles of beer on the wall\\n 98 bottles of beer on the wall\\n98 bottles of beer\\nTake one down, pass it around\\n97 bottles of beer on the wall\\n... and so on, until reaching 0.\\nGrammatical support for \""1 bottle of beer\"" is optional.\\nAs with any puzzle, try to do it in as creative/concise/comical a way\\nas possible (simple, obvious solutions allowed, too).\\n\\n\\n\\nSee 99 Bottles of Beer/EsoLang\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nor (With ABAP 7.40)\\nSee 99 Bottles of Beer/Lisp\\nwith 1 task to print out the information and 99 tasks to specify the number of bottles\\nImplementation in Apache Ant, due to the limitations of Ant, this requires ant-contrib for arithmetic operations and a dummy target to keep Ant from detecting the loop.\\n\\nNote that the output label text is not displayed until the entire lyrics text has been built and there is some delay between button press and display.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\nOutput can be sent directly to a label with this preferred method as there is no noticeable delay between button press and output.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\n\\n\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Shell\\nSee 99 Bottles of Beer/Shell\\nIf you don't want so many beers, here you can specify the starting amount. \\nFor example, just a sixpack:\\n","#include <iostream>\\nusing namespace std;\\nvoid rec(int bottles)\\n{\\nif ( bottles!=0)    \\n {    \\n     cout << bottles << \"" bottles of beer on the wall\"" << endl; \\n        cout << bottles << \"" bottles of beer\"" << endl;\\n        cout << \""Take one down, pass it around\"" << endl; \\n        cout << --bottles << \"" bottles of beer on the wall\\n\"" << endl;    \\n    rec(bottles);\\n }  \\n}\\n\\nint main() \\n {   \\nrec(99);\\nsystem(\""pause\"");\\nreturn 0;\\n}\\n"
"C++","99_Bottles_of_Beer","Display the complete lyrics for the song:     99 Bottles of Beer on the Wall.\\n\\nThe lyrics follow this form:\\n 99 bottles of beer on the wall\\n99 bottles of beer\\nTake one down, pass it around\\n98 bottles of beer on the wall\\n 98 bottles of beer on the wall\\n98 bottles of beer\\nTake one down, pass it around\\n97 bottles of beer on the wall\\n... and so on, until reaching 0.\\nGrammatical support for \""1 bottle of beer\"" is optional.\\nAs with any puzzle, try to do it in as creative/concise/comical a way\\nas possible (simple, obvious solutions allowed, too).\\n\\n\\n\\nSee 99 Bottles of Beer/EsoLang\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nor (With ABAP 7.40)\\nSee 99 Bottles of Beer/Lisp\\nwith 1 task to print out the information and 99 tasks to specify the number of bottles\\nImplementation in Apache Ant, due to the limitations of Ant, this requires ant-contrib for arithmetic operations and a dummy target to keep Ant from detecting the loop.\\n\\nNote that the output label text is not displayed until the entire lyrics text has been built and there is some delay between button press and display.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\nOutput can be sent directly to a label with this preferred method as there is no noticeable delay between button press and output.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\n\\n\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Shell\\nSee 99 Bottles of Beer/Shell\\nIf you don't want so many beers, here you can specify the starting amount. \\nFor example, just a sixpack:\\n","#include <iostream>\\n#include <ostream>\\n\\n#define BOTTLE(nstr) nstr \"" bottles of beer\""\\n\\n#define WALL(nstr) BOTTLE(nstr) \"" on the wall\""\\n\\n#define PART1(nstr) WALL(nstr) \""\\n\"" BOTTLE(nstr) \\\\n                    \""\\nTake one down, pass it around\\n\""\\n\\n#define PART2(nstr) WALL(nstr) \""\\n\\n\""\\n\\n#define MIDDLE(nstr) PART2(nstr) PART1(nstr)\\n\\n#define SONG PART1(\""100\"") CD2 PART2(\""0\"")\\n\\n#define CD2 CD3(\""9\"") CD3(\""8\"") CD3(\""7\"") CD3(\""6\"") CD3(\""5\"") \\\\n        CD3(\""4\"") CD3(\""3\"") CD3(\""2\"") CD3(\""1\"") CD4(\""\"")\\n\\n#define CD3(pre) CD4(pre) MIDDLE(pre \""0\"")\\n\\n#define CD4(pre) MIDDLE(pre \""9\"") MIDDLE(pre \""8\"") MIDDLE(pre \""7\"") \\\\n MIDDLE(pre \""6\"") MIDDLE(pre \""5\"") MIDDLE(pre \""4\"") MIDDLE(pre \""3\"") \\\\n MIDDLE(pre \""2\"") MIDDLE(pre \""1\"")\\n\\nint main()\\n{\\n  std::cout << SONG;\\n  return 0;\\n}"
"C++","99_Bottles_of_Beer","Display the complete lyrics for the song:     99 Bottles of Beer on the Wall.\\n\\nThe lyrics follow this form:\\n 99 bottles of beer on the wall\\n99 bottles of beer\\nTake one down, pass it around\\n98 bottles of beer on the wall\\n 98 bottles of beer on the wall\\n98 bottles of beer\\nTake one down, pass it around\\n97 bottles of beer on the wall\\n... and so on, until reaching 0.\\nGrammatical support for \""1 bottle of beer\"" is optional.\\nAs with any puzzle, try to do it in as creative/concise/comical a way\\nas possible (simple, obvious solutions allowed, too).\\n\\n\\n\\nSee 99 Bottles of Beer/EsoLang\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nor (With ABAP 7.40)\\nSee 99 Bottles of Beer/Lisp\\nwith 1 task to print out the information and 99 tasks to specify the number of bottles\\nImplementation in Apache Ant, due to the limitations of Ant, this requires ant-contrib for arithmetic operations and a dummy target to keep Ant from detecting the loop.\\n\\nNote that the output label text is not displayed until the entire lyrics text has been built and there is some delay between button press and display.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\nOutput can be sent directly to a label with this preferred method as there is no noticeable delay between button press and output.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\n\\n\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Shell\\nSee 99 Bottles of Beer/Shell\\nIf you don't want so many beers, here you can specify the starting amount. \\nFor example, just a sixpack:\\n","                          //>,_\\n                        //Beer Song>,_\\n                       #include <iostream>\\n                      using namespace std;\\n                     int main(){ for( int\\n                    b=-1; b<99;  cout <<\\n                   '\\n') for ( int w=0;\\n                  w<3; cout << \"".\\n\""){ \\n                 if (w==2) cout << ((\\n                b--) ?\""Take one dow\""\\n               \""n and pass it arou\""\\n              \""nd\"":\""Go to the sto\""\\n             \""re and buy some mo\""\\n            \""re\""); if (b<0) b=99\\n           ; do{ if (w) cout <<\\n          \"", \""; if (b) cout <<\\n          b;  else  cout << (\\n         (w) ? 'n' : 'N') <<\\n         \""o more\""; cout <<\\n         \"" bottle\"" ;  if\\n        (b!=1) cout <<\\n       's' ; cout <<\\n       \"" of beer\"";\\n      if (w!=1)\\n     cout  <<\\n    \"" on th\""\\n   \""e wall\""\\n  ;} while\\n (!w++);}\\n  return\\n       0\\n       ;\\n       }\\n      //\\n  // by barrym 2011-05-01\\n     // no bottles were harmed in the\\n            // making of this program!!!"
"C++","A*_search_algorithm","The A* search algorithm is an extension of Dijkstra's algorithm useful for finding the lowest cost path between two nodes (aka vertices) of a graph. The path may traverse any number of nodes connected by edges (aka arcs) with each edge having an associated cost. The algorithm uses a heuristic which associates an estimate of the lowest cost path from this node to the goal node, such that this estimate is never greater than the actual cost.\\nThe algorithm should not assume that all edge costs are the same. It should be possible to start and finish on any node, including ones identified as a barrier in the task.\\nConsider the problem of finding a route across the diagonal of a chess board-like 8x8 grid. The rows are numbered from 0 to 7. The columns are also numbered 0 to 7. The start position is (0, 0) and the end position is (7, 7). Movement is allow by one square in any direction including diagonals, similar to a king in chess. The standard movement cost is 1. To make things slightly harder, there is a barrier that occupy certain positions of the grid. Moving into any of the barrier positions has a cost of 100.\\nThe barrier occupies the positions (2,4), (2,5), (2,6), (3,6), (4,6), (5,6), (5,5), (5,4), (5,3), (5,2), (4,2) and (3,2).\\nA route with the lowest cost should be found using the A* search algorithm (there are multiple optimal solutions with the same total cost).\\nPrint the optimal route in text format, as well as the total cost of the route.\\nOptionally, draw the optimal route and the barrier positions.\\nNote: using a heuristic score of zero is equivalent to Dijkstra's algorithm and that's kind of cheating/not really A*!\\nUse this algorithm to solve an 8 puzzle. Each node of the input graph will represent an arrangement of the tiles. The nodes will be connected by 4 edges representing swapping the blank tile up, down, left, or right. The cost of each edge is 1. The heuristic will be the sum of the manhatten distance of each numbered tile from its goal position. An 8 puzzle graph will have 9!/2 (181,440) nodes. The 15 puzzle has over 10 trillion nodes. This algorithm may solve simple 15 puzzles (but there are not many of those).\\n\\n\\n\\n","\\n#include <list>\\n#include <algorithm>\\n#include <iostream>\\n \\nclass point {\\npublic:\\n    point( int a = 0, int b = 0 ) { x = a; y = b; }\\n    bool operator ==( const point& o ) { return o.x == x && o.y == y; }\\n    point operator +( const point& o ) { return point( o.x + x, o.y + y ); }\\n    int x, y;\\n};\\n \\nclass map {\\npublic:\\n    map() {\\n        char t[8][8] = {\\n            {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0},\\n            {0, 0, 0, 0, 1, 1, 1, 0}, {0, 0, 1, 0, 0, 0, 1, 0},\\n            {0, 0, 1, 0, 0, 0, 1, 0}, {0, 0, 1, 1, 1, 1, 1, 0},\\n            {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}\\n        };\\n        w = h = 8;\\n        for( int r = 0; r < h; r++ )\\n            for( int s = 0; s < w; s++ )\\n                m[s][r] = t[r][s];\\n    }\\n    int operator() ( int x, int y ) { return m[x][y]; }\\n    char m[8][8];\\n    int w, h;\\n};\\n \\nclass node {\\npublic:\\n    bool operator == (const node& o ) { return pos == o.pos; }\\n    bool operator == (const point& o ) { return pos == o; }\\n    bool operator < (const node& o ) { return dist + cost < o.dist + o.cost; }\\n    point pos, parent;\\n    int dist, cost;\\n};\\n \\nclass aStar {\\npublic:\\n    aStar() {\\n        neighbours[0] = point( -1, -1 ); neighbours[1] = point(  1, -1 );\\n        neighbours[2] = point( -1,  1 ); neighbours[3] = point(  1,  1 );\\n        neighbours[4] = point(  0, -1 ); neighbours[5] = point( -1,  0 );\\n        neighbours[6] = point(  0,  1 ); neighbours[7] = point(  1,  0 );\\n    }\\n \\n    int calcDist( point& p ){\\n        // need a better heuristic\\n        int x = end.x - p.x, y = end.y - p.y;\\n        return( x * x + y * y );\\n    }\\n \\n    bool isValid( point& p ) {\\n        return ( p.x >-1 && p.y > -1 && p.x < m.w && p.y < m.h );\\n    }\\n \\n    bool existPoint( point& p, int cost ) {\\n        std::list<node>::iterator i;\\n        i = std::find( closed.begin(), closed.end(), p );\\n        if( i != closed.end() ) {\\n            if( ( *i ).cost + ( *i ).dist < cost ) return true;\\n            else { closed.erase( i ); return false; }\\n        }\\n        i = std::find( open.begin(), open.end(), p );\\n        if( i != open.end() ) {\\n            if( ( *i ).cost + ( *i ).dist < cost ) return true;\\n            else { open.erase( i ); return false; }\\n        }\\n        return false;\\n    }\\n \\n    bool fillOpen( node& n ) {\\n        int stepCost, nc, dist;\\n        point neighbour;\\n\\n        for( int x = 0; x < 8; x++ ) {\\n            // one can make diagonals have different cost\\n            stepCost = x < 4 ? 1 : 1;\\n            neighbour = n.pos + neighbours[x];\\n            if( neighbour == end ) return true;\\n \\n            if( isValid( neighbour ) && m( neighbour.x, neighbour.y ) != 1 ) {\\n                nc = stepCost + n.cost;\\n                dist = calcDist( neighbour );\\n                if( !existPoint( neighbour, nc + dist ) ) {\\n                    node m;\\n                    m.cost = nc; m.dist = dist;\\n                    m.pos = neighbour; \\n                    m.parent = n.pos;\\n                    open.push_back( m );\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n \\n    bool search( point& s, point& e, map& mp ) {\\n        node n; end = e; start = s; m = mp;\\n        n.cost = 0; n.pos = s; n.parent = 0; n.dist = calcDist( s ); \\n        open.push_back( n );\\n        while( !open.empty() ) {\\n            //open.sort();\\n            node n = open.front();\\n            open.pop_front();\\n            closed.push_back( n );\\n            if( fillOpen( n ) ) return true;\\n        }\\n        return false;\\n    }\\n \\n    int path( std::list<point>& path ) {\\n        path.push_front( end );\\n        int cost = 1 + closed.back().cost; \\n        path.push_front( closed.back().pos );\\n        point parent = closed.back().parent;\\n \\n        for( std::list<node>::reverse_iterator i = closed.rbegin(); i != closed.rend(); i++ ) {\\n            if( ( *i ).pos == parent && !( ( *i ).pos == start ) ) {\\n                path.push_front( ( *i ).pos );\\n                parent = ( *i ).parent;\\n            }\\n        }\\n        path.push_front( start );\\n        return cost;\\n    }\\n \\n    map m; point end, start;\\n    point neighbours[8];\\n    std::list<node> open;\\n    std::list<node> closed;\\n};\\n \\nint main( int argc, char* argv[] ) {\\n    map m;\\n    point s, e( 7, 7 );\\n    aStar as;\\n \\n    if( as.search( s, e, m ) ) {\\n        std::list<point> path;\\n        int c = as.path( path );\\n        for( int y = -1; y < 9; y++ ) {\\n            for( int x = -1; x < 9; x++ ) {\\n                if( x < 0 || y < 0 || x > 7 || y > 7 || m( x, y ) == 1 )\\n                    std::cout << char(0xdb);\\n                else {\\n                    if( std::find( path.begin(), path.end(), point( x, y ) )!= path.end() )\\n                        std::cout << \""x\"";\\n                    else std::cout << \"".\"";\\n                }\\n            }\\n            std::cout << \""\\n\"";\\n        }\\n \\n        std::cout << \""\\nPath cost \"" << c << \"": \"";\\n        for( std::list<point>::iterator i = path.begin(); i != path.end(); i++ ) {\\n            std::cout<< \""(\"" << ( *i ).x << \"", \"" << ( *i ).y << \"") \"";\\n        }\\n    }\\n    std::cout << \""\\n\\n\"";\\n    return 0;\\n}\\n"
"C++","A+B","A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.\\n\\nGiven two integers,   A and B.\\nTheir sum needs to be calculated.\\n\\nTwo integers are written in the input stream, separated by space(s):\\n\\nThe required output is one integer:   the sum of A and B.\\n\\n\\n","// Standard input-output streams\\n#include <iostream>\\nusing namespace std;\\nint main()\\n{\\n   int a, b;\\n   cin >> a >> b;\\n   cout << a + b << endl;\\n}"
"C++","A+B","A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.\\n\\nGiven two integers,   A and B.\\nTheir sum needs to be calculated.\\n\\nTwo integers are written in the input stream, separated by space(s):\\n\\nThe required output is one integer:   the sum of A and B.\\n\\n\\n","// Input file: input.txt\\n// Output file: output.txt\\n#include <fstream>\\nusing namespace std;\\nint main()\\n{\\n   ifstream in(\""input.txt\"");\\n   ofstream out(\""output.txt\"");\\n   int a, b;\\n   in >> a >> b;\\n   out << a + b << endl;\\n   return 0;\\n}"
"C++","Abbreviations,_automatic","The use of   abbreviations   (also sometimes called synonyms, nicknames, AKAs, or aliases)   can be an\\neasy way to add flexibility when specifying or using commands, sub─commands, options, etc.\\n\\nIt would make a list of words easier to maintain   (as words are added, changed, and/or deleted)   if\\nthe minimum abbreviation length of that list could be automatically (programmatically) determined.\\n\\nFor this task, use the list (below) of the days-of-the-week names that are expressed in about a hundred languages   (note that there is a blank line in the list).\\nCaveat:   The list (above) most surely contains errors (or, at the least, differences) of what the actual (or true) names for the days-of-the-week.\\n\\nTo make this Rosetta Code task page as small as possible, if processing the complete list, read the days-of-the-week from a file (that is created from the above list).\\n\\nNotes concerning the above list of words\\n\\n\\n\\n","#include <iomanip>\\n#include <iostream>\\n#include <fstream>\\n#include <map>\\n#include <sstream>\\n#include <string>\\n#include <vector>\\n\\nstd::vector split(const std::string& str, char delimiter) {\\n    std::vector tokens;\\n    std::string token;\\n    std::istringstream tokenStream(str);\\n    while (std::getline(tokenStream, token, delimiter)) {\\n        tokens.push_back(token);\\n    }\\n    return tokens;\\n}\\n\\nint main() {\\n    using namespace std;\\n    string line;\\n    int i = 0;\\n\\n    ifstream in(\""days_of_week.txt\"");\\n    if (in.is_open()) {\\n        while (getline(in, line)) {\\n            i++;\\n            if (line.empty()) {\\n                continue;\\n            }\\n\\n            auto days = split(line, ' ');\\n            if (days.size() != 7) {\\n                throw std::runtime_error(\""There aren't 7 days in line \"" + i);\\n            }\\n\\n            map temp;\\n            for (auto& day : days) {\\n                if (temp.find(day) != temp.end()) {\\n                    cerr << \"" ∞  \"" << line << '\\n';\\n                    continue;\\n                }\\n                temp[day] = 1;\\n            }\\n\\n            int len = 1;\\n            while (true) {\\n                temp.clear();\\n                for (auto& day : days) {\\n                    string key = day.substr(0, len);\\n                    if (temp.find(key) != temp.end()) {\\n                        break;\\n                    }\\n                    temp[key] = 1;\\n                }\\n                if (temp.size() == 7) {\\n                    cout << setw(2) << len << \""  \"" << line << '\\n';\\n                    break;\\n                }\\n                len++;\\n            }\\n        }\\n    }\\n\\n    return 0;\\n}"
"C++","ABC_Problem","\\nYou are given a collection of ABC blocks   (maybe like the ones you had when you were a kid).\\nThere are twenty blocks with two letters on each block.\\nA complete alphabet is guaranteed amongst all sides of the blocks.\\nThe sample collection of blocks:\\n\\nWrite a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks.\\n\\nThe rules are simple:\\n\\n\\nThe program uses one ASSIST macro (XPRNT) to keep the code as short as possible.\\n","#include <iostream>\\n#include <vector>\\n#include <string>\\n#include <set>\\n#include <cctype>\\n\\n\\ntypedef std::pair item_t;\\ntypedef std::vector list_t;\\n\\nbool can_make_word(const std::string& w, const list_t& vals) {\\n    std::set used;\\n    while (used.size() < w.size()) {\\n        const char c = toupper(w[used.size()]);\\n        uint32_t x = used.size();\\n        for (uint32_t i = 0, ii = vals.size(); i < ii; ++i) {\\n            if (used.find(i) == used.end()) {\\n                if (toupper(vals[i].first) == c || toupper(vals[i].second) == c) {\\n                    used.insert(i);\\n                    break;\\n                }\\n            }\\n        }\\n        if (x == used.size()) break;\\n    }\\n    return used.size() == w.size();\\n}\\n\\n\\nint main() {\\n    list_t vals{ {'B','O'}, {'X','K'}, {'D','Q'}, {'C','P'}, {'N','A'}, {'G','T'}, {'R','E'}, {'T','G'}, {'Q','D'}, {'F','S'}, {'J','W'}, {'H','U'}, {'V','I'}, {'A','N'}, {'O','B'}, {'E','R'}, {'F','S'}, {'L','Y'}, {'P','C'}, {'Z','M'} };\\n    std::vector words{\""A\"",\""BARK\"",\""BOOK\"",\""TREAT\"",\""COMMON\"",\""SQUAD\"",\""CONFUSE\""};\\n    for (const std::string& w : words) {\\n        std::cout << w << \"": \"" << std::boolalpha << can_make_word(w,vals) << \"".\\n\"";\\n    }\\n\\n}"
"C++","Abstract_type","Abstract type is a type without instances or without definition.\\nFor example in object-oriented programming using some languages, abstract types can be partial implementations of other types, which are to be derived there-from. An abstract type may provide implementation of some operations and/or components. Abstract types without any implementation are called interfaces. In the languages that do not support multiple inheritance (Ada, Java), classes can, nonetheless, inherit from multiple interfaces. The languages with multiple inheritance (like C++) usually make no distinction between partially implementable abstract types and interfaces. Because the abstract type's implementation is incomplete,  OO languages normally prevent instantiation from them (instantiation must derived from one of their descendant classes).\\nThe term abstract datatype also may denote a type, with an implementation provided by the programmer rather than directly by the language (a built-in or an inferred type). Here the word abstract means that the implementation is abstracted away, irrelevant for the user of the type. Such implementation can and should be hidden if the language supports separation of implementation and specification. This hides complexity while allowing the implementation to change without repercussions on the usage. The corresponding software design practice is said to follow the information hiding principle.\\nIt is important not to confuse this abstractness (of implementation) with one of the abstract type. The latter is abstract in the sense that the set of its values is empty. In the sense of implementation abstracted away, all user-defined types are abstract.\\nIn some languages, like for example in Objective Caml which is strongly statically typed, it is also possible to have abstract types that are not OO related and are not an abstractness too. These are pure abstract types without any definition even in the implementation and can be used for example for the type algebra, or for some consistence of the type inference. For example in this area, an abstract type can be used as a phantom type to augment another type as its parameter.\\nTask: show how an abstract type can be declared in the language. If the language makes a distinction between interfaces and partially implemented types illustrate both.\\n\\nInterfaces in ABAP are classes with the following restrictions:\\n1. All methods must be abstract instance methods (Static methods aren't allowed).\\n2. Variables must be static final. The values may be computed at run time.\\n3. No static initialiser blockers. No static initialiser helper methods.\\nWhile ActionScript does not support explicit abstract classes, it does have interfaces. Interfaces in ActionScript may not implement any methods and all methods are public and implicitly abstract. Interfaces can extend other interfaces, and interfaces may be multiply inherited.\\nAbstract types can also be simulated using the built-in flash.utils.getQualifiedClassName() function in the constructor to check that the runtime type is an inhertied class, and throwing exceptions from \""abstract\"" methods which can be overridden by inheritors to disable them. If any inheriting class does not implement an abstract method, the error will not be thrown until the non-implemented method is called.\\nInheriting this class:\\nInterfaces in Ada may have no components or implemented operation except for ones implemented as null operations. Interfaces can be multiply inherited.\\nInterfaces can be declared synchronized or task when intended implementations are to be provided by protected objects or tasks. For example:\\nAbstract types may provide components and implementation of their operations. Abstract types are singly inherited.\\nHere Node is an abstract type that is inherited from Limited_Controlled and implements a node of a  doubly linked list. It also implements the interface of a queue described above, because any node can be considered a head of the queue of linked elements. For the operation Finalize an implementation is provided to ensure that the element of a list is removed from there upon its finalization. The operation itself is inherited from the parent type Limited_Controlled and then overridden. The operations Dequeue and Enqueue of the Queue interface are also implemented.\\nUsing records for storing the interface methods and instance arguments (which are similar to Haskell type classes) for overloading:\\nThere is dog and cat is objects of different types for which the interface method is implemented.\\nAn abstract class contains functions that have no body defined. You cannot instantiate a class that contains abstract functions.\\nInterfaces in Aikido define a set of functions, operators, classes, interfaces, monitors or threads (but no variables) that must be implemented by a class implementing the interface.\\nIn AmigaE, abstract methods are supported but interfaces are not.\\nprints to the console:\\nred orange\\n\\nBBC BASIC is a procedural language with no built-in OO features. The CLASSLIB library implements simple Object Classes with multiple inheritance; an abstract class may be created without any instantiation, the sole purpose of which is for other classes to inherit from it. At least one member or method must be declared, but no error will be generated if there is no implementation:\\nDoing abstract types in C is not particularly trivial as C doesn't really support classes. The following series will show an abstract type, followed by a realizable class that provides the abstract interface, and finally followed by an example of usage.\\nThe header file for the abstract class, interfaceAbs.h\\nThat will define the abstract class. The next section declares a public interface for a class providing the interface of the abstract class. This class is Silly and\\nthe code is in file silly.h. Note the actual structure of the class is not provided\\nhere. We don't want it visible.\\nOk. Now it is necessary to provide the implementation of the realizable class.\\nThis code should be in silly.c.\\nThat last macro, ABSTRACT_METHODS may need a little explanation. First note that macros do a string substitution of the parameter values into the arguments of the defined macro, with a little hitch. In the macro definition the ' ## ' expression is special. Here cName ## _Iface gets converted to Silly_Iface, as 'Silly' replaces cName. So the macro call declares an instance of the class record, and defines a constructor named Silly_Instance, which takes a Silly structure as an arguments\\nand uses the class record it previously set up as well.\\nThe methods MyMethod1, MyMethod2, and MyMethod3 are called through the abstract class interface and do not need to be visible outside this file. Hence, they are declared static.\\nNow all's left is some example code that uses all this stuff.\\nYou can declare a virtual function to not have an implementation (called \""pure virtual function\"") by the following \""= 0\"" syntax after the method declaration. A class containing at least one pure virtual function (or inheriting one and not overriding it) cannot be instantiated.\\nBecause C++ allows multiple inheritance of classes, no distinction is made between interfaces and abstract classes.\\nIn Caché, abstract and data type classes cannot be instantiated directly - there must be a 'concrete subclass' that extends them as well as the '%RegisteredObject' class in order to instantiate an object, see example below.\\nData type classes differ because they cannot contain properties, see example below.\\nBoth class types can contain implementation code. Caché allows multiple inheritance of classes, so no distinction is made between abstract classes and interfaces.\\n","class Abs {\\npublic:\\n	virtual int method1(double value) = 0;\\n	virtual int add(int a, int b){\\n		return a+b;\\n	}\\n};"
"C++","Abundant,_deficient_and_perfect_number_classifications","These define three classifications of positive integers based on their   proper divisors.\\nLet   P(n)   be the sum of the proper divisors of   n   where the proper divisors are all positive divisors of   n   other than   n   itself.\\n\\n6   has proper divisors of   1,   2,   and   3.\\n1 + 2 + 3 = 6,   so   6   is classed as a perfect number.\\n\\nCalculate how many of the integers   1   to   20,000   (inclusive) are in each of the three classes.\\nShow the results here.\\n\\n\\n","#include <iostream>\\n#include <algorithm>\\n#include <vector>\\n\\nstd::vector<int> findProperDivisors ( int n ) {\\n   std::vector<int> divisors ;\\n   for ( int i = 1 ; i < n / 2 + 1 ; i++ ) {\\n      if ( n % i == 0 ) \\n	 divisors.push_back( i ) ;\\n   }\\n   return divisors  ;\\n}\\n\\nint main( ) {\\n   std::vector<int> deficients , perfects , abundants , divisors ;\\n   for ( int n = 1 ; n < 20001 ; n++ ) {\\n      divisors = findProperDivisors( n ) ;\\n      int sum = std::accumulate( divisors.begin( ) , divisors.end( ) , 0 ) ;\\n      if ( sum < n ) {\\n	 deficients.push_back( n ) ;\\n      }\\n      if ( sum == n ) {\\n	 perfects.push_back( n ) ;\\n      }\\n      if ( sum > n ) {\\n	 abundants.push_back( n ) ;\\n      }\\n   }\\n   std::cout << \""Deficient : \"" << deficients.size( ) << std::endl ;\\n   std::cout << \""Perfect   : \"" << perfects.size( ) << std::endl ;\\n   std::cout << \""Abundant  : \"" << abundants.size( ) << std::endl ;\\n   return 0 ;\\n}"
"C++","Accumulator_factory","A problem posed by Paul Graham is that of creating a function that takes a single (numeric) argument and which returns another function that is an accumulator. The returned accumulator function in turn also takes a single numeric argument, and returns the sum of all the numeric values passed in so far to that accumulator (including the initial value passed when the accumulator was created).\\n\\nThe detailed rules are at http://paulgraham.com/accgensub.html and are reproduced here for simplicity (with additions in small italic text).\\n\\nCreate a function that implements the described rules.\\n\\nIt need not handle any special error cases not described above. The simplest way to implement the task as described is typically to use a closure, providing the language supports them.\\nWhere it is not possible to hold exactly to the constraints above, describe the deviations.\\n\\n","#include <iostream>\\n\\nclass Acc\\n{\\npublic:\\n    Acc(int init)\\n        : _type(intType)\\n        , _intVal(init)\\n    {}\\n\\n    Acc(float init)\\n        : _type(floatType)\\n        , _floatVal(init)\\n    {}\\n\\n    int operator()(int x)\\n    {\\n        if( _type == intType )\\n        {\\n            _intVal += x;\\n            return _intVal;\\n        }\\n        else\\n        {\\n            _floatVal += x;\\n            return static_cast<int>(_floatVal);\\n        }\\n    }\\n\\n    float operator()(float x)\\n    {\\n        if( _type == intType )\\n        {\\n            _floatVal = _intVal + x;\\n            _type = floatType;\\n            return _floatVal;\\n        }\\n        else\\n        {\\n            _floatVal += x;\\n            return _floatVal;\\n        }\\n    }\\nprivate:\\n    enum {floatType, intType} _type;\\n    float _floatVal;\\n    int _intVal;\\n};\\n\\nint main()\\n{\\n    Acc a(1);\\n    a(5);\\n    Acc(3);\\n    std::cout << a(2.3f);\\n    return 0;\\n}"
"C++","Accumulator_factory","A problem posed by Paul Graham is that of creating a function that takes a single (numeric) argument and which returns another function that is an accumulator. The returned accumulator function in turn also takes a single numeric argument, and returns the sum of all the numeric values passed in so far to that accumulator (including the initial value passed when the accumulator was created).\\n\\nThe detailed rules are at http://paulgraham.com/accgensub.html and are reproduced here for simplicity (with additions in small italic text).\\n\\nCreate a function that implements the described rules.\\n\\nIt need not handle any special error cases not described above. The simplest way to implement the task as described is typically to use a closure, providing the language supports them.\\nWhere it is not possible to hold exactly to the constraints above, describe the deviations.\\n\\n","#include <iostream>\\n#include <functional>\\n\\ntemplate \\nstd::function makeAccumulator(T sum) {\\n	return [=](T increment) mutable {\\n		return sum += increment;\\n	};\\n}\\n\\nint main() {\\n	auto acc = makeAccumulator<float>(1);\\n	acc(5);\\n	makeAccumulator(3);\\n	std::cout << acc(2.3) << std::endl;\\n	return 0;\\n}"
"C++","Accumulator_factory","A problem posed by Paul Graham is that of creating a function that takes a single (numeric) argument and which returns another function that is an accumulator. The returned accumulator function in turn also takes a single numeric argument, and returns the sum of all the numeric values passed in so far to that accumulator (including the initial value passed when the accumulator was created).\\n\\nThe detailed rules are at http://paulgraham.com/accgensub.html and are reproduced here for simplicity (with additions in small italic text).\\n\\nCreate a function that implements the described rules.\\n\\nIt need not handle any special error cases not described above. The simplest way to implement the task as described is typically to use a closure, providing the language supports them.\\nWhere it is not possible to hold exactly to the constraints above, describe the deviations.\\n\\n","struct CumulantBase_\\n{\\n   virtual ~CumulantBase_();\\n   virtual std::ostream& Write(std::ostream& dst) const = 0;\\n};\\n\\ntemplate struct Cumulant_ : CumulantBase_\\n{\\n   T_ val_;\\n   Cumulant_(const T_& val) : val_(val) {}\\n   std::ostream& Write(std::ostream& dst) const override \\n   {\\n      return dst << val_;\\n   }\\n};\\n\\nstruct Accumulator_\\n{\\n   std::unique_ptr val_;\\n   template Accumulator_(const T_& val) { Set(val); }\\n   template void Set(const T_& val) { val_.reset(new Cumulant_(val)); }\\n"
"C++","Accumulator_factory","A problem posed by Paul Graham is that of creating a function that takes a single (numeric) argument and which returns another function that is an accumulator. The returned accumulator function in turn also takes a single numeric argument, and returns the sum of all the numeric values passed in so far to that accumulator (including the initial value passed when the accumulator was created).\\n\\nThe detailed rules are at http://paulgraham.com/accgensub.html and are reproduced here for simplicity (with additions in small italic text).\\n\\nCreate a function that implements the described rules.\\n\\nIt need not handle any special error cases not described above. The simplest way to implement the task as described is typically to use a closure, providing the language supports them.\\nWhere it is not possible to hold exactly to the constraints above, describe the deviations.\\n\\n","// still inside struct Accumulator_\\n	// various operator() implementations provide a de facto multimethod\\n	Accumulator_& operator()(int more)\\n	{\\n		if (auto i = CoerceInt(*val_))\\n			Set(+i + more);\\n		else if (auto d = CoerceDouble(*val_))\\n			Set(+d + more);\\n		else\\n			THROW(\""Accumulate(int) failed\"");\\n		return *this;\\n	}\\n	Accumulator_& operator()(double more)\\n	{\\n		if (auto d = CoerceDouble(*val_))\\n			Set(+d + more);\\n		else\\n			THROW(\""Accumulate(double) failed\"");\\n		return *this;\\n	}\\n	Accumulator_& operator()(const String_& more)\\n	{\\n		if (auto s = CoerceString(*val_))\\n			Set(+s + more);\\n		else\\n			THROW(\""Accumulate(string) failed\"");\\n		return *this;\\n	}\\n};\\n"
"C++","Accumulator_factory","A problem posed by Paul Graham is that of creating a function that takes a single (numeric) argument and which returns another function that is an accumulator. The returned accumulator function in turn also takes a single numeric argument, and returns the sum of all the numeric values passed in so far to that accumulator (including the initial value passed when the accumulator was created).\\n\\nThe detailed rules are at http://paulgraham.com/accgensub.html and are reproduced here for simplicity (with additions in small italic text).\\n\\nCreate a function that implements the described rules.\\n\\nIt need not handle any special error cases not described above. The simplest way to implement the task as described is typically to use a closure, providing the language supports them.\\nWhere it is not possible to hold exactly to the constraints above, describe the deviations.\\n\\n","// recognize cumulants by type\\nboost::optional<int> CoerceInt(const CumulantBase_& c)\\n{\\n	if (auto p = dynamic_cast(&c))\\n		return p->val_;\\n	return boost::optional<int>();\\n}\\nboost::optional<double> CoerceDouble(const CumulantBase_& c)\\n{\\n	if (auto p = dynamic_cast(&c))\\n		return p->val_;\\n	if (auto i = CoerceInt(c))\\n		return boost::optional<double>(i);\\n	return boost::optional<double>();\\n}\\nboost::optional CoerceString(const CumulantBase_& c)\\n{\\n	if (auto p = dynamic_cast*>(&c))\\n		return p->val_;\\n	return boost::optional();\\n}\\n"
"C++","Accumulator_factory","A problem posed by Paul Graham is that of creating a function that takes a single (numeric) argument and which returns another function that is an accumulator. The returned accumulator function in turn also takes a single numeric argument, and returns the sum of all the numeric values passed in so far to that accumulator (including the initial value passed when the accumulator was created).\\n\\nThe detailed rules are at http://paulgraham.com/accgensub.html and are reproduced here for simplicity (with additions in small italic text).\\n\\nCreate a function that implements the described rules.\\n\\nIt need not handle any special error cases not described above. The simplest way to implement the task as described is typically to use a closure, providing the language supports them.\\nWhere it is not possible to hold exactly to the constraints above, describe the deviations.\\n\\n","std::ostream& operator<<(std::ostream& dst, const Accumulator_& acc)\\n{\\n	return acc.val_->Write(dst);\\n}\\n"
"C++","Ackermann_function","The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.\\n\\nThe Ackermann function is usually defined as follows:\\n\\n","#include <iostream>\\n\\nunsigned int ackermann(unsigned int m, unsigned int n) {\\n  if (m == 0) {\\n    return n + 1;\\n  }\\n  if (n == 0) {\\n    return ackermann(m - 1, 1);\\n  }\\n  return ackermann(m - 1, ackermann(m, n - 1));\\n}\\n\\nint main() {\\n  for (unsigned int m = 0; m < 4; ++m) {\\n    for (unsigned int n = 0; n < 10; ++n) {\\n      std::cout << \""A(\"" << m << \"", \"" << n << \"") = \"" << ackermann(m, n) << \""\\n\"";\\n    }\\n  }\\n}\\n"
"C++","Ackermann_function","The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.\\n\\nThe Ackermann function is usually defined as follows:\\n\\n","#include <iostream>\\n#include <sstream>\\n#include <string>\\n#include \\n\\nusing big_int = boost::multiprecision::cpp_int;\\n\\nbig_int ipow(big_int base, big_int exp) {\\n  big_int result(1);\\n  while (exp) {\\n    if (exp & 1) {\\n      result *= base;\\n    }\\n    exp >>= 1;\\n    base *= base;\\n  }\\n  return result;\\n}\\n\\nbig_int ackermann(unsigned m, unsigned n) {\\n  static big_int (*ack)(unsigned, big_int) =\\n      [](unsigned m, big_int n)->big_int {\\n    switch (m) {\\n    case 0:\\n      return n + 1;\\n    case 1:\\n      return n + 2;\\n    case 2:\\n      return 3 + 2 * n;\\n    case 3:\\n      return 5 + 8 * (ipow(big_int(2), n) - 1);\\n    default:\\n      return n == 0 ? ack(m - 1, big_int(1)) : ack(m - 1, ack(m, n - 1));\\n    }\\n  };\\n  return ack(m, big_int(n));\\n}\\n\\nint main() {\\n  for (unsigned m = 0; m < 4; ++m) {\\n    for (unsigned n = 0; n < 10; ++n) {\\n      std::cout << \""A(\"" << m << \"", \"" << n << \"") = \"" << ackermann(m, n) << \""\\n\"";\\n    }\\n  }\\n\\n  std::cout << \""A(4, 1) = \"" << ackermann(4, 1) << \""\\n\"";\\n\\n  std::stringstream ss;\\n  ss << ackermann(4, 2);\\n  auto text = ss.str();\\n  std::cout << \""A(4, 2) = (\"" << text.length() << \"" digits)\\n\""\\n            << text.substr(0, 80) << \""\\n...\\n\""\\n            << text.substr(text.length() - 80) << \""\\n\"";\\n}"
"C++","Active_object","In object-oriented programming an object is active when its state depends on clock. Usually an active object encapsulates a task that updates the object's state. To the outer world the object looks like a normal object with methods that can be called from outside. Implementation of such methods must have a certain synchronization mechanism with the encapsulated task in order to prevent object's state corruption.\\nA typical instance of an active object is an animation widget. The widget state changes with the time, while as an object it has all properties of a normal widget.\\nThe task\\nImplement an active integrator object. The object has an input and output. The input can be set using the method Input. The input is a function of time. The output can be queried using the method Output. The object integrates its input over the time and the result becomes the object's output. So if the input is K(t) and the output is S, the object state S is changed to S + (K(t1) + K(t0)) * (t1 - t0) / 2, i.e. it integrates K using the trapeze method. Initially K is constant 0 and S is 0.\\nIn order to test the object:\\nVerify that now the object's output is approximately 0 (the sine has the period of 2s). The accuracy of the result will depend on the OS scheduler time slicing and the accuracy of the clock.\\nSample output:\\nOutput:\\nUses POSIX threads.\\noutput\\nOutput:\\noutput\\n","#include <atomic>\\n#include <chrono>\\n#include <cmath>\\n#include <iostream>\\n#include <mutex>\\n#include <thread>\\n\\nusing namespace std::chrono_literals;\\n\\nclass Integrator\\n{\\n  public:\\n    using clock_type = std::chrono::high_resolution_clock;\\n    using dur_t      = std::chrono::duration<double>;\\n    using func_t     = double(*)(double);\\n\\n    explicit Integrator(func_t f = nullptr);\\n    ~Integrator();\\n    void input(func_t new_input);\\n    double output() { return integrate(); }\\n\\n  private:\\n    std::atomic_flag continue_;\\n    std::mutex       mutex;\\n    std::thread      worker;\\n\\n    func_t                       func;\\n    double                       state = 0;\\n    //Improves precision by reducing sin result error on large values\\n    clock_type::time_point const beginning = clock_type::now();\\n    clock_type::time_point       t_prev = beginning;\\n\\n    void do_work();\\n    double integrate();\\n};\\n\\nIntegrator::Integrator(func_t f) : func(f)\\n{\\n    continue_.test_and_set();\\n    worker = std::thread(&Integrator::do_work, this);\\n}\\n\\nIntegrator::~Integrator()\\n{\\n    continue_.clear();\\n    worker.join();\\n}\\n\\nvoid Integrator::input(func_t new_input)\\n{\\n    integrate();\\n    std::lock_guard lock(mutex);\\n    func = new_input;\\n}\\n\\nvoid Integrator::do_work()\\n{\\n    while(continue_.test_and_set()) {\\n        integrate();\\n        std::this_thread::sleep_for(1ms);\\n    }\\n}\\n\\ndouble Integrator::integrate()\\n{\\n    std::lock_guard lock(mutex);\\n    auto now = clock_type::now();\\n    dur_t start = t_prev - beginning;\\n    dur_t fin   =    now - beginning;\\n    if(func)\\n        state += (func(start.count()) + func(fin.count())) * (fin - start).count() / 2;\\n    t_prev = now;\\n    return state;\\n}\\n\\ndouble sine(double time)\\n{\\n    constexpr double PI = 3.1415926535897932;\\n    return std::sin(2 * PI * 0.5 * time);\\n}\\n\\nint main()\\n{\\n    Integrator foo(sine);\\n    std::this_thread::sleep_for(2s);\\n    foo.input(nullptr);\\n    std::this_thread::sleep_for(500ms);\\n    std::cout << foo.output();\\n}"
"C++","Addition_chains","An addition chain of length r for n is a sequence 1 = a(0) < a(1) < a(2) ... < a(r) = n , such as a(k) = a(i) + a(j) ( i < k and j < k , i may be = j) . Each member is the sum of two earlier members, not necessarily distincts.\\nA Brauer chain for n is an addition chain where a(k) = a(k-1) + a(j) with j < k. Each member uses the previous member as a summand.\\nWe are interested in chains of minimal length L(n).\\nTask\\nFor each n in {7,14,21,29,32,42,64} display the following : L(n), the count of Brauer chains of length L(n), an example of such a Brauer chain, the count of non-brauer chains of length L(n), an example of such a chain. (NB: counts may be 0 ).\\nExtra-credit: Same task for n in {47, 79, 191, 382 , 379, 12509}\\nReferences\\nExample\\n","#include <iostream>\\n#include <tuple>\\n#include <vector>\\n\\nstd::pair tryPerm(int, int, const std::vector<int>&, int, int);\\n\\nstd::pair checkSeq(int pos, const std::vector<int>& seq, int n, int minLen) {\\n    if (pos > minLen || seq[0] > n) return { minLen, 0 };\\n    else if (seq[0] == n)           return { pos, 1 };\\n    else if (pos < minLen)          return tryPerm(0, pos, seq, n, minLen);\\n    else                            return { minLen, 0 };\\n}\\n\\nstd::pair tryPerm(int i, int pos, const std::vector<int>& seq, int n, int minLen) {\\n    if (i > pos) return { minLen, 0 };\\n\\n    std::vector<int> seq2{ seq[0] + seq[i] };\\n    seq2.insert(seq2.end(), seq.cbegin(), seq.cend());\\n    auto res1 = checkSeq(pos + 1, seq2, n, minLen);\\n    auto res2 = tryPerm(i + 1, pos, seq, n, res1.first);\\n\\n    if (res2.first < res1.first)       return res2;\\n    else if (res2.first == res1.first) return { res2.first, res1.second + res2.second };\\n    else                               throw std::runtime_error(\""tryPerm exception\"");\\n}\\n\\nstd::pair initTryPerm(int x) {\\n    return tryPerm(0, 0, { 1 }, x, 12);\\n}\\n\\nvoid findBrauer(int num) {\\n    auto res = initTryPerm(num);\\n    std::cout << '\\n';\\n    std::cout << \""N = \"" << num << '\\n';\\n    std::cout << \""Minimum length of chains: L(n)= \"" << res.first << '\\n';\\n    std::cout << \""Number of minimum length Brauer chains: \"" << res.second << '\\n';\\n}\\n\\nint main() {\\n    std::vector<int> nums{ 7, 14, 21, 29, 32, 42, 64, 47, 79, 191, 382, 379 };\\n    for (int i : nums) {\\n        findBrauer(i);\\n    }\\n\\n    return 0;\\n}"
"C++","Almost_prime","A   k-Almost-prime   is a natural number   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n   that is the product of   \\n\\n\\n\\nk\\n\\n\\n{\\displaystyle k}\\n\\n   (possibly identical) primes.\\n\\n1-almost-primes,   where   \\n\\n\\n\\nk\\n=\\n1\\n\\n\\n{\\displaystyle k=1}\\n\\n,   are the prime numbers themselves.\\n2-almost-primes,   where   \\n\\n\\n\\nk\\n=\\n2\\n\\n\\n{\\displaystyle k=2}\\n\\n,   are the   semiprimes.\\n\\nWrite a function/method/subroutine/... that generates k-almost primes and use it to create a table here of the first ten members of k-Almost primes for   \\n\\n\\n\\n1\\n<=\\nK\\n<=\\n5\\n\\n\\n{\\displaystyle 1<=K<=5}\\n\\n.\\n\\n\\n","#include <cstdlib>\\n#include <iostream>\\n#include <sstream>\\n#include <iomanip>\\n#include <list>\\n\\nbool k_prime(unsigned n, unsigned k) {\\n    unsigned f = 0;\\n    for (unsigned p = 2; f < k && p * p <= n; p++)\\n        while (0 == n % p) { n /= p; f++; }\\n    return f + (n > 1 ? 1 : 0) == k;\\n}\\n\\nstd::list<unsigned> primes(unsigned k, unsigned n)  {\\n    std::list<unsigned> list;\\n    for (unsigned i = 2;list.size() < n;i++)\\n        if (k_prime(i, k)) list.push_back(i);\\n    return list;\\n}\\n\\nint main(const int argc, const char* argv[]) {\\n    using namespace std;\\n    for (unsigned k = 1; k <= 5; k++) {\\n        ostringstream os(\""\"");\\n        const list<unsigned> l = primes(k, 10);\\n        for (list<unsigned>::const_iterator i = l.begin(); i != l.end(); i++)\\n            os << setw(4) << *i;\\n        cout << \""k = \"" << k << ':' << os.str() << endl;\\n    }\\n\\n	return EXIT_SUCCESS;\\n}"
"C++","Amicable_pairs","Two integers \\n\\n\\n\\nN\\n\\n\\n{\\displaystyle N}\\n\\n and \\n\\n\\n\\nM\\n\\n\\n{\\displaystyle M}\\n\\n are said to be amicable pairs if \\n\\n\\n\\nN\\n≠\\nM\\n\\n\\n{\\displaystyle N\\neq M}\\n\\n and the sum of the proper divisors of \\n\\n\\n\\nN\\n\\n\\n{\\displaystyle N}\\n\\n (\\n\\n\\n\\n\\ns\\nu\\nm\\n\\n(\\n\\np\\nr\\no\\np\\nD\\ni\\nv\\ns\\n\\n(\\nN\\n)\\n)\\n\\n\\n{\\displaystyle \\mathrm {sum} (\\mathrm {propDivs} (N))}\\n\\n) \\n\\n\\n\\n=\\nM\\n\\n\\n{\\displaystyle =M}\\n\\n as well as \\n\\n\\n\\n\\ns\\nu\\nm\\n\\n(\\n\\np\\nr\\no\\np\\nD\\ni\\nv\\ns\\n\\n(\\nM\\n)\\n)\\n=\\nN\\n\\n\\n{\\displaystyle \\mathrm {sum} (\\mathrm {propDivs} (M))=N}\\n\\n.\\n\\n1184 and 1210 are an amicable pair, with proper divisors:\\n\\nCalculate and show here the Amicable pairs below 20,000; (there are eight).\\n\\n\\n","\\n#include <vector>\\n#include \\n#include <iostream>\\n\\nint main() {\\n    std::vector<int> alreadyDiscovered;\\n    std::unordered_map divsumMap; \\n    int count = 0;\\n\\n    for (int N = 1; N <= 20000; ++N)\\n    {      \\n        int divSumN = 0;\\n\\n        for (int i = 1; i <= N / 2; ++i)\\n        {\\n            if (fmod(N, i) == 0)\\n            {\\n                divSumN += i;\\n            }\\n        }\\n        \\n        // populate map of integers to the sum of their proper divisors\\n        if (divSumN != 1) // do not include primes\\n            divsumMap[N] = divSumN;\\n\\n        for (std::unordered_map::iterator it = divsumMap.begin(); it != divsumMap.end(); ++it)\\n        {\\n            int M = it->first;\\n            int divSumM = it->second;\\n            int divSumN = divsumMap[N];\\n\\n            if (N != M && divSumM == N && divSumN == M)\\n            {\\n                // do not print duplicate pairs\\n                if (std::find(alreadyDiscovered.begin(), alreadyDiscovered.end(), N) != alreadyDiscovered.end())\\n                    break;\\n\\n                std::cout << \""[\"" << M << \"", \"" << N << \""]\"" << std::endl;\\n\\n                alreadyDiscovered.push_back(M);\\n                alreadyDiscovered.push_back(N);\\n                count++;\\n            }\\n        }\\n    }\\n\\n    std::cout << count << \"" amicable pairs discovered\"" << std::endl;\\n}\\n"
"C++","Anagrams","When two or more words are composed of the same characters, but in a different order, they are called anagrams.\\nUsing the word list at   http://www.puzzlers.org/pub/wordlists/unixdict.txt,\\nfind the sets of words that share the same characters that contain the most words in them.\\nOrdered words\\nPalindrome detection\\nSemordnilap\\nAnagrams\\nAnagrams/Deranged anagrams\\n","#include <iostream>\\n#include <fstream>\\n#include <string>\\n#include <map>\\n#include <vector>\\n#include <algorithm>\\n#include <iterator>\\n \\nint main() {\\n  std::ifstream in(\""unixdict.txt\"");\\n  typedef  std::map > AnagramMap;\\n  AnagramMap anagrams;\\n \\n  std::string word;\\n  size_t count = 0;\\n  while (std::getline(in, word)) {\\n    std::string key = word;\\n    std::sort(key.begin(), key.end());\\n    // note: the [] op. automatically inserts a new value if key does not exist\\n    AnagramMap::mapped_type & v = anagrams[key];\\n    v.push_back(word);\\n    count = std::max(count, v.size());\\n  }\\n \\n  in.close();\\n \\n  for (AnagramMap::const_iterator it = anagrams.begin(), e = anagrams.end();\\n       it != e; it++)\\n    if (it->second.size() >= count) {\\n      std::copy(it->second.begin(), it->second.end(),\\n                std::ostream_iterator(std::cout, \"", \""));\\n      std::cout << std::endl;\\n    }\\n  return 0;\\n}"
"C++","Anagrams/Deranged_anagrams","Two or more words are said to be anagrams if they have the same characters, but in a different order.\\nBy analogy with derangements we define a deranged anagram as two words with the same characters, but in which the same character does not appear in the same position in both words.\\nUse the word list at unixdict to find and display the longest deranged anagram.\\nOrdered words\\nPalindrome detection\\nSemordnilap\\nAnagrams\\nAnagrams/Deranged anagrams\\n","#include <algorithm>\\n#include <fstream>\\n#include <functional>\\n#include <iostream>\\n#include <map>\\n#include <numeric>\\n#include <set>\\n#include <string>\\n\\nbool is_deranged(const std::string& left, const std::string& right)\\n{\\n    return (left.size() == right.size()) &&\\n        (std::inner_product(left.begin(), left.end(), right.begin(), 0, std::plus<int>(), std::equal_to<char>()) == 0);\\n}\\n\\nint main()\\n{\\n    std::ifstream input(\""unixdict.txt\"");\\n    if (!input) {\\n        std::cerr << \""can't open input file\\n\"";\\n        return EXIT_FAILURE;\\n    }\\n\\n    typedef std::set WordList;\\n    typedef std::map AnagraMap;\\n    AnagraMap anagrams;\\n\\n    std::pair result;\\n    size_t longest = 0;\\n\\n    for (std::string value; input >> value; /**/) {\\n        std::string key(value);\\n        std::sort(key.begin(), key.end());\\n\\n        if (longest < value.length()) { // is it a long candidate?\\n            if (0 < anagrams.count(key)) { // is it an anagram?\\n                for (const auto& prior : anagrams[key]) {\\n                    if (is_deranged(prior, value)) { // are they deranged?\\n                        result = std::make_pair(prior, value);\\n                        longest = value.length();\\n                    }\\n                }\\n            }\\n        }\\n        anagrams[key].insert(value);\\n    }\\n\\n    std::cout << result.first << ' ' << result.second << '\\n';\\n    return EXIT_SUCCESS;\\n}"
"C++","Angle_difference_between_two_bearings","Finding the angle between two bearings is often confusing.[1]\\n\\nFind the angle which is the result of the subtraction b2 - b1, where b1 and b2 are the bearings.\\nInput bearings are expressed in the range   -180   to   +180   degrees.\\nThe result is also expressed in the range   -180   to   +180   degrees.\\n\\nCompute the angle for the following pairs:\\n\\nAllow the input bearings to be any (finite) value.\\n\\n\\n","#include <cmath>\\n#include <iostream>\\nusing namespace std;\\n\\ndouble getDifference(double b1, double b2) {\\n	double r = fmod(b2 - b1, 360.0);\\n	if (r < -180.0)\\n		r += 360.0;\\n	if (r >= 180.0)\\n		r -= 360.0;\\n	return r;\\n}\\n\\nint main()\\n{\\n	cout << \""Input in -180 to +180 range\"" << endl;\\n	cout << getDifference(20.0, 45.0) << endl;\\n	cout << getDifference(-45.0, 45.0) << endl;\\n	cout << getDifference(-85.0, 90.0) << endl;\\n	cout << getDifference(-95.0, 90.0) << endl;\\n	cout << getDifference(-45.0, 125.0) << endl;\\n	cout << getDifference(-45.0, 145.0) << endl;\\n	cout << getDifference(-45.0, 125.0) << endl;\\n	cout << getDifference(-45.0, 145.0) << endl;\\n	cout << getDifference(29.4803, -88.6381) << endl;\\n	cout << getDifference(-78.3251, -159.036) << endl;\\n	\\n	cout << \""Input in wider range\"" << endl;\\n	cout << getDifference(-70099.74233810938, 29840.67437876723) << endl;\\n	cout << getDifference(-165313.6666297357, 33693.9894517456) << endl;\\n	cout << getDifference(1174.8380510598456, -154146.66490124757) << endl;\\n	cout << getDifference(60175.77306795546, 42213.07192354373) << endl;\\n\\n	return 0;\\n}"
"C++","Animate_a_pendulum","One good way of making an animation is by simulating a physical system and illustrating the variables in that system using a dynamically changing graphical display.\\nThe classic such physical system is a simple gravity pendulum.\\nFor this task, create a simple physical model of a pendulum and animate it.\\nThis does not use a GUI, it simply animates the pendulum and prints out the positions. If you want, you can replace the output method with graphical update methods.\\nX and Y are relative positions of the pendulum to the anchor.\\npendulums.ads:\\npendulums.adb:\\nexample main.adb:\\n","\\n#ifndef __wxPendulumDlg_h__\\n#define __wxPendulumDlg_h__\\n\\n// ---------------------\\n/// @author Martin Ettl\\n/// @date   2013-02-03\\n// ---------------------\\n\\n#ifdef __BORLANDC__\\n#pragma hdrstop\\n#endif\\n\\n#ifndef WX_PRECOMP\\n#include \\n#include \\n#else\\n#include \\n#endif\\n#include \\n#include \\n#include <cmath>\\n\\nclass wxPendulumDlgApp : public wxApp\\n{\\n    public:\\n        bool OnInit();\\n        int OnExit();\\n};\\n\\nclass wxPendulumDlg : public wxDialog\\n{\\n    public:\\n\\n        wxPendulumDlg(wxWindow *parent, wxWindowID id = 1, const wxString &title = wxT(\""wxPendulum\""), \\n				 const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, \\n				 long style = wxSUNKEN_BORDER | wxCAPTION | wxRESIZE_BORDER | wxSYSTEM_MENU | wxDIALOG_NO_PARENT | wxMINIMIZE_BOX | wxMAXIMIZE_BOX | wxCLOSE_BOX);\\n\\n        virtual ~wxPendulumDlg();\\n	\\n		// Event handler\\n        void wxPendulumDlgPaint(wxPaintEvent& event);\\n        void wxPendulumDlgSize(wxSizeEvent& event);\\n        void OnTimer(wxTimerEvent& event);\\n\\n    private:\\n\\n		// a pointer to a timer object\\n        wxTimer *m_timer;\\n\\n		unsigned int m_uiLength;\\n		double  	 m_Angle;\\n		double       m_AngleVelocity;\\n\\n        enum wxIDs\\n        {\\n            ID_WXTIMER1 = 1001,\\n            ID_DUMMY_VALUE_ \\n        };\\n\\n        void OnClose(wxCloseEvent& event);\\n        void CreateGUIControls();\\n\\n        DECLARE_EVENT_TABLE()\\n};\\n\\n#endif // __wxPendulumDlg_h__\\n"
"C++","Animate_a_pendulum","One good way of making an animation is by simulating a physical system and illustrating the variables in that system using a dynamically changing graphical display.\\nThe classic such physical system is a simple gravity pendulum.\\nFor this task, create a simple physical model of a pendulum and animate it.\\nThis does not use a GUI, it simply animates the pendulum and prints out the positions. If you want, you can replace the output method with graphical update methods.\\nX and Y are relative positions of the pendulum to the anchor.\\npendulums.ads:\\npendulums.adb:\\nexample main.adb:\\n","\\n// ---------------------\\n/// @author Martin Ettl\\n/// @date   2013-02-03\\n// ---------------------\\n\\n#include \""wxPendulumDlg.hpp\""\\n#include \\n\\nIMPLEMENT_APP(wxPendulumDlgApp)\\n\\nbool wxPendulumDlgApp::OnInit()\\n{\\n    wxPendulumDlg* dialog = new wxPendulumDlg(NULL);\\n    SetTopWindow(dialog);\\n    dialog->Show(true);\\n    return true;\\n}\\n\\nint wxPendulumDlgApp::OnExit()\\n{\\n    return 0;\\n}\\n\\nBEGIN_EVENT_TABLE(wxPendulumDlg, wxDialog)\\n    EVT_CLOSE(wxPendulumDlg::OnClose)\\n    EVT_SIZE(wxPendulumDlg::wxPendulumDlgSize)\\n    EVT_PAINT(wxPendulumDlg::wxPendulumDlgPaint)\\n    EVT_TIMER(ID_WXTIMER1, wxPendulumDlg::OnTimer)\\nEND_EVENT_TABLE()\\n\\nwxPendulumDlg::wxPendulumDlg(wxWindow *parent, wxWindowID id, const wxString &title, const wxPoint &position, const wxSize& size, long style)\\n    : wxDialog(parent, id, title, position, size, style)\\n{\\n    CreateGUIControls();\\n}\\n\\nwxPendulumDlg::~wxPendulumDlg()\\n{\\n}\\n\\nvoid wxPendulumDlg::CreateGUIControls()\\n{\\n    SetIcon(wxNullIcon);\\n    SetSize(8, 8, 509, 412);\\n    Center();\\n\\n	m_uiLength = 200;\\n	m_Angle    = M_PI/2.;\\n	m_AngleVelocity = 0;\\n\\n    m_timer = new wxTimer();\\n    m_timer->SetOwner(this, ID_WXTIMER1);\\n    m_timer->Start(20);\\n}\\n\\nvoid wxPendulumDlg::OnClose(wxCloseEvent& WXUNUSED(event))\\n{\\n    Destroy();\\n}\\n\\nvoid wxPendulumDlg::wxPendulumDlgPaint(wxPaintEvent& WXUNUSED(event))\\n{\\n    SetBackgroundStyle(wxBG_STYLE_CUSTOM);\\n    wxBufferedPaintDC dc(this);\\n\\n    // Get window dimensions\\n    wxSize sz = GetClientSize();\\n	// determine the center of the canvas\\n    const wxPoint center(wxPoint(sz.x / 2, sz.y / 2));\\n\\n    // create background color\\n    wxColour powderblue = wxColour(176,224,230);\\n\\n    // draw powderblue background\\n    dc.SetPen(powderblue);\\n    dc.SetBrush(powderblue);\\n    dc.DrawRectangle(0, 0, sz.x, sz.y);\\n\\n    // draw lines\\n	wxPen Pen(*wxBLACK_PEN);\\n	Pen.SetWidth(1);\\n    dc.SetPen(Pen);\\n    dc.SetBrush(*wxBLACK_BRUSH);\\n\\n    double angleAccel, dt = 0.15;\\n\\n    angleAccel = (-9.81 / m_uiLength) * sin(m_Angle);\\n    m_AngleVelocity += angleAccel * dt;\\n    m_Angle += m_AngleVelocity * dt;\\n\\n    int anchorX = sz.x / 2, anchorY = sz.y / 4;\\n    int ballX = anchorX + (int)(sin(m_Angle) * m_uiLength);\\n    int ballY = anchorY + (int)(cos(m_Angle) * m_uiLength);\\n    dc.DrawLine(anchorX, anchorY, ballX, ballY);\\n\\n    dc.SetBrush(*wxGREY_BRUSH);\\n    dc.DrawEllipse(anchorX - 3, anchorY - 4, 7, 7);\\n\\n    dc.SetBrush(wxColour(255,255,0)); // yellow\\n    dc.DrawEllipse(ballX - 7, ballY - 7, 20, 20);\\n}\\n\\nvoid wxPendulumDlg::wxPendulumDlgSize(wxSizeEvent& WXUNUSED(event))\\n{\\n    Refresh();\\n}\\n\\nvoid wxPendulumDlg::OnTimer(wxTimerEvent& WXUNUSED(event))\\n{\\n	// force refresh\\n	Refresh();\\n}\\n"
"C++","Anonymous_recursion","While implementing a recursive function, it often happens that we must resort to a separate   helper function   to handle the actual recursion.\\nThis is usually the case when directly calling the current function would waste too many resources (stack space, execution time), causing unwanted side-effects,   and/or the function doesn't have the right arguments and/or return values.\\nSo we end up inventing some silly name like   foo2   or   foo_helper.   I have always found it painful to come up with a proper name, and see some disadvantages:\\nSome languages allow you to embed recursion directly in-place.   This might work via a label, a local gosub instruction, or some special keyword.\\nAnonymous recursion can also be accomplished using the   Y combinator.\\n\\nIf possible, demonstrate this by writing the recursive version of the fibonacci function   (see Fibonacci sequence)   which checks for a negative argument before doing the actual recursion.\\n\\n","double fib(double n)\\n{\\n  if(n < 0)\\n  {\\n    throw \""Invalid argument passed to fib\"";\\n  }\\n  else\\n  {\\n    struct actual_fib\\n    {\\n        static double calc(double n)\\n        {\\n          if(n < 2)\\n          {\\n            return n;\\n          }\\n          else\\n          {\\n            return calc(n-1) + calc(n-2);\\n          }\\n        }\\n    };\\n\\n    return actual_fib::calc(n);\\n  }\\n}"
"C++","Anonymous_recursion","While implementing a recursive function, it often happens that we must resort to a separate   helper function   to handle the actual recursion.\\nThis is usually the case when directly calling the current function would waste too many resources (stack space, execution time), causing unwanted side-effects,   and/or the function doesn't have the right arguments and/or return values.\\nSo we end up inventing some silly name like   foo2   or   foo_helper.   I have always found it painful to come up with a proper name, and see some disadvantages:\\nSome languages allow you to embed recursion directly in-place.   This might work via a label, a local gosub instruction, or some special keyword.\\nAnonymous recursion can also be accomplished using the   Y combinator.\\n\\nIf possible, demonstrate this by writing the recursive version of the fibonacci function   (see Fibonacci sequence)   which checks for a negative argument before doing the actual recursion.\\n\\n","#include <functional>\\nusing namespace std;\\n\\ndouble fib(double n)\\n{\\n  if(n < 0)\\n    throw \""Invalid argument\"";\\n  \\n  function actual_fib = [&](double n)\\n  {\\n    if(n < 2) return n;\\n    return actual_fib(n-1) + actual_fib(n-2);\\n  };\\n\\n  return actual_fib(n);\\n}"
"C++","Anonymous_recursion","While implementing a recursive function, it often happens that we must resort to a separate   helper function   to handle the actual recursion.\\nThis is usually the case when directly calling the current function would waste too many resources (stack space, execution time), causing unwanted side-effects,   and/or the function doesn't have the right arguments and/or return values.\\nSo we end up inventing some silly name like   foo2   or   foo_helper.   I have always found it painful to come up with a proper name, and see some disadvantages:\\nSome languages allow you to embed recursion directly in-place.   This might work via a label, a local gosub instruction, or some special keyword.\\nAnonymous recursion can also be accomplished using the   Y combinator.\\n\\nIf possible, demonstrate this by writing the recursive version of the fibonacci function   (see Fibonacci sequence)   which checks for a negative argument before doing the actual recursion.\\n\\n","double fib(double n)\\n{\\n  if(n < 0)\\n  {\\n    throw \""Invalid argument passed to fib\"";\\n  }\\n  else\\n  {\\n    struct actual_fib\\n    {\\n      double operator()(double n)\\n      {\\n        if(n < 2)\\n        {\\n          return n;\\n        }\\n        else\\n        {\\n          return (*this)(n-1) + (*this)(n-2);\\n        }\\n      }\\n    };\\n\\n    return actual_fib()(n);\\n  }\\n}"
"C++","Anti-primes","The anti-primes\\n(or highly composite numbers)\\nare the natural numbers with more factors than any smaller than itself.\\nGenerate and show here, the first twenty anti-primes.\\n \\n","#include <iostream>\\n\\nint countDivisors(int n) {\\n    if (n < 2) return 1;\\n    int count = 2; // 1 and n\\n    for (int i = 2; i <= n/2; ++i) {\\n        if (n%i == 0) ++count;\\n    }\\n    return count;\\n}\\n\\nint main() {\\n    int maxDiv = 0, count = 0;\\n    std::cout << \""The first 20 anti-primes are:\"" << std::endl;\\n    for (int n = 1; count < 20; ++n) {\\n        int d = countDivisors(n);\\n        if (d > maxDiv) {\\n            std::cout << n << \"" \"";\\n            maxDiv = d;\\n            count++;\\n        }\\n    }\\n    std::cout << std::endl;\\n    return 0;\\n}"
"C++","Append_a_record_to_the_end_of_a_text_file","Many systems offer the ability to open a file for writing, such that any data written will be appended to the end of the file. Further, the file operations will always adjust the position pointer to guarantee the end of the file, even in a multitasking environment.\\nThis feature is most useful in the case of log files, where many jobs may be appending to the log file at the same time, or where care must be taken to avoid concurrently overwriting the same record from another job.\\n\\nGiven a two record sample for a mythical \""passwd\"" file:\\nResulting file format: should mimic Linux's /etc/passwd file format with particular attention to the \"",\"" separator used in the GECOS field. But if the specific language has a particular or unique format of storing records in text file, then this format should be named and demonstrated with an additional example.\\nExpected output:\\nFinally: Provide a summary of the language's \""append record\"" capabilities in a table. eg.\\nAlternatively: If the language's appends can not guarantee its writes will always append, then note this restriction in the table. If possible, provide an actual code example (possibly using file/record locking) to guarantee correct concurrent appends.\\n\\nOutput:","#include <iostream>\\n#include <fstream>\\n#include <string>\\n#include <vector>\\n\\nstd::ostream& operator<<(std::ostream& out, const std::string s) {\\n    return out << s.c_str();\\n}\\n\\nstruct gecos_t {\\n    std::string fullname, office, extension, homephone, email;\\n\\n    friend std::ostream& operator<<(std::ostream&, const gecos_t&);\\n};\\n\\nstd::ostream& operator<<(std::ostream& out, const gecos_t& g) {\\n    return out << g.fullname << ',' << g.office << ',' << g.extension << ',' << g.homephone << ',' << g.email;\\n}\\n\\nstruct passwd_t {\\n    std::string account, password;\\n    int uid, gid;\\n    gecos_t gecos;\\n    std::string directory, shell;\\n\\n    passwd_t(const std::string& a, const std::string& p, int u, int g, const gecos_t& ge, const std::string& d, const std::string& s)\\n        : account(a), password(p), uid(u), gid(g), gecos(ge), directory(d), shell(s)\\n    {\\n        //empty\\n    }\\n\\n    friend std::ostream& operator<<(std::ostream&, const passwd_t&);\\n};\\n\\nstd::ostream& operator<<(std::ostream& out, const passwd_t& p) {\\n    return out << p.account << ':' << p.password << ':' << p.uid << ':' << p.gid << ':' << p.gecos << ':' << p.directory << ':' << p.shell;\\n}\\n\\nstd::vector passwd_list{\\n    {\\n        \""jsmith\"", \""x\"", 1001, 1000,\\n        {\""Joe Smith\"", \""Room 1007\"", \""(234)555-8917\"", \""(234)555-0077\"", \""jsmith@rosettacode.org\""},\\n        \""/home/jsmith\"", \""/bin/bash\""\\n    },\\n    {\\n        \""jdoe\"", \""x\"", 1002, 1000,\\n        {\""Jane Doe\"", \""Room 1004\"", \""(234)555-8914\"", \""(234)555-0044\"", \""jdoe@rosettacode.org\""},\\n        \""/home/jdoe\"", \""/bin/bash\""\\n    }\\n};\\n\\nint main() {\\n    // Write the first two records\\n    std::ofstream out_fd(\""passwd.txt\"");\\n    for (size_t i = 0; i < passwd_list.size(); ++i) {\\n        out_fd << passwd_list[i] << '\\n';\\n    }\\n    out_fd.close();\\n\\n    // Append the third record\\n    out_fd.open(\""passwd.txt\"", std::ios::app);\\n    out_fd << passwd_t(\""xyz\"", \""x\"", 1003, 1000, { \""X Yz\"", \""Room 1003\"", \""(234)555-8913\"", \""(234)555-0033\"", \""xyz@rosettacode.org\"" }, \""/home/xyz\"", \""/bin/bash\"") << '\\n';\\n    out_fd.close();\\n\\n    // Verify the record was appended\\n    std::ifstream in_fd(\""passwd.txt\"");\\n    std::string line, temp;\\n    while (std::getline(in_fd, temp)) {\\n        // the last line of the file is empty, make sure line contains the last record\\n        if (!temp.empty()) {\\n            line = temp;\\n        }\\n    }\\n    if (line.substr(0, 4) == \""xyz:\"") {\\n        std::cout << \""Appended record: \"" << line << '\\n';\\n    } else {\\n        std::cout << \""Failed to find the expected record appended.\\n\"";\\n    }\\n\\n    return 0;\\n}"
"C++","Apply_a_callback_to_an_array","Take a combined set of elements and apply a function to each element.\\n\\n","#include <iostream> //cout for printing\\n#include <algorithm> //for_each defined here\\n\\n//create the function (print the square)\\nvoid print_square(int i) {\\n  std::cout << i*i << \"" \"";\\n}\\n\\nint main() {\\n  //create the array\\n  int ary[]={1,2,3,4,5};\\n  //stl for_each\\n  std::for_each(ary,ary+5,print_square);\\n  return 0;\\n}\\n//prints 1 4 9 16 25"
"C++","Apply_a_callback_to_an_array","Take a combined set of elements and apply a function to each element.\\n\\n","#include <iostream>  // cout for printing\\n#include <algorithm> // for_each defined here\\n#include <vector>    // stl vector class\\n\\n// create the function (print the square)\\nvoid print_square(int i) {\\n  std::cout << i*i << \"" \"";\\n}\\n\\nint main() {\\n  // create the array\\n  std::vector<int> ary;\\n  ary.push_back(1);\\n  ary.push_back(2);\\n  ary.push_back(3);\\n  ary.push_back(4);\\n  ary.push_back(5);\\n  // stl for_each\\n  std::for_each(ary.begin(),ary.end(),print_square);\\n  return 0;\\n}\\n//prints 1 4 9 16 25"
"C++","Apply_a_callback_to_an_array","Take a combined set of elements and apply a function to each element.\\n\\n","#include <iostream>   // cout for printing\\n#include <algorithm>  // for_each defined here\\n#include <vector>     // stl vector class\\n#include <functional> // bind and ptr_fun\\n\\n// create a binary function (print any two arguments together)\\ntemplate\\nvoid print_juxtaposed(type1 x, type2 y) {\\n  std::cout << x << y;\\n}\\n\\nint main() {\\n  // create the array\\n  std::vector<int> ary;\\n  ary.push_back(1);\\n  ary.push_back(2);\\n  ary.push_back(3);\\n  ary.push_back(4);\\n  ary.push_back(5);\\n  // stl for_each, using binder and adaptable unary function\\n  std::for_each(ary.begin(),ary.end(),std::bind2nd(std::ptr_fun(print_juxtaposed),\""x \""));\\n  return 0;\\n}\\n//prints 1x 2x 3x 4x 5x"
"C++","Apply_a_callback_to_an_array","Take a combined set of elements and apply a function to each element.\\n\\n","using namespace std;\\nusing namespace boost::lambda;\\nvector<int> ary(10);\\nint i = 0;\\nfor_each(ary.begin(), ary.end(), _1 = ++var(i)); // init array\\ntransform(ary.begin(), ary.end(), ostream_iterator<int>(cout, \"" \""), _1 * _1); // square and output"
"C++","Apply_a_callback_to_an_array","Take a combined set of elements and apply a function to each element.\\n\\n","#include <vector>\\n#include <iostream>\\n#include <algorithm>\\n#include <iterator>\\n\\nint main() {\\n   std::vector<int> intVec(10);\\n   std::iota(std::begin(intVec), std::end(intVec), 1 ); // Fill the vector\\n   std::transform(std::begin(intVec) , std::end(intVec), std::begin(intVec),\\n	 [](int i) { return i * i ; } ); // Transform it with closures\\n   std::copy(std::begin(intVec), end(intVec) ,\\n	 std::ostream_iterator<int>(std::cout, \"" \""));\\n   std::cout << std::endl;\\n   return 0;\\n}"
"C++","Apply_a_digital_filter_(direct_form_II_transposed)","Digital filters are used to apply a mathematical operation to a sampled signal. One of the common formulations is the \""direct form II transposed\"" which can represent both infinite impulse response (IIR) and finite impulse response (FIR) filters, as well as being more numerically stable than other forms. [1]\\nFilter a signal using an order 3 low-pass Butterworth filter. The coefficients for the filter are a=[1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17] and b = [0.16666667, 0.5, 0.5, 0.16666667]\\nThe signal that needs filtering is the following vector: [-0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412, -0.662370894973, -1.00700480494, -0.404707073677 ,0.800482325044, 0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195, 0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293, 0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589]\\nGiven the number of values a coefficient or signal vector can have and the number of digits, this implementation reads data from a file and prints it to the console if no output file is specified or writes to the specified output file. Usage printed on incorrect invocation.\\nInput file, 3 lines containing first ( a ) and second ( b ) coefficient followed by the signal, all values should be separated by a single space:\\nInvocation and output for writing to file :\\nOutput file :\\nThis uses the C++11 method of initializing vectors. In g++, use the -std=c++0x compiler switch.\\n","#include <vector>\\n#include <iostream>\\nusing namespace std;\\n\\nvoid Filter(const vector<float> &b, const vector<float> &a, const vector<float> &in, vector<float> &out)\\n{\\n\\n	out.resize(0);\\n	out.resize(in.size());\\n\\n	for(int i=0; i < in.size(); i++)\\n	{\\n		float tmp = 0.;\\n		int j=0;\\n		out[i] = 0.f;\\n		for(j=0; j < b.size(); j++)\\n		{\\n			if(i - j < 0) continue;\\n			tmp += b[j] * in[i-j];\\n		}\\n\\n		for(j=1; j < a.size(); j++)\\n		{\\n			if(i - j < 0) continue;\\n			tmp -= a[j]*out[i-j];\\n		}\\n		\\n		tmp /= a[0];\\n		out[i] = tmp;\\n	}\\n}\\n\\nint main()\\n{\\n	vector<float> sig = {-0.917843918645,0.141984778794,1.20536903482,0.190286794412,-0.662370894973,-1.00700480494,\\\\n		-0.404707073677,0.800482325044,0.743500089861,1.01090520172,0.741527555207,\\\\n		0.277841675195,0.400833448236,-0.2085993586,-0.172842103641,-0.134316096293,\\\\n		0.0259303398477,0.490105989562,0.549391221511,0.9047198589};\\n\\n	//Constants for a Butterworth filter (order 3, low pass)\\n	vector<float> a = {1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17};\\n	vector<float> b = {0.16666667, 0.5, 0.5, 0.16666667};\\n	\\n	vector<float> result;\\n	Filter(b, a, sig, result);\\n\\n	for(size_t i=0;i\\n\\n{{out}}\\n<pre>-0.152974,-0.435258,-0.136043,0.697503,0.656445,-0.435483,-1.08924,-0.537677,0.51705,1.05225,0.961854,0.69569,0.424356,0.196262,-0.0278351,-0.211722,-0.174746,0.0692584,0.385446,0.651771,"
"C++","Arbitrary-precision_integers_(included)","Using the in-built capabilities of your language, calculate the integer value of:\\n\\n\\n\\n","#include <iostream>\\n#include \\n#include <string>\\n\\nnamespace mp = boost::multiprecision;\\n\\nint main(int argc, char const *argv[])\\n{\\n    // We could just use (1 << 18) instead of tmpres, but let's point out one\\n    // pecularity with gmp and hence boost::multiprecision: they won't accept\\n    // a second mpz_int with pow(). Therefore, if we stick to multiprecision\\n    // pow we need to convert_to().\\n    uint64_t tmpres = mp::pow(mp::mpz_int(4)\\n                            , mp::pow(mp::mpz_int(3)\\n                                    , 2).convert_to()\\n                                      ).convert_to();\\n    mp::mpz_int res = mp::pow(mp::mpz_int(5), tmpres);\\n    std::string s = res.str();\\n    std::cout << s.substr(0, 20) \\n              << \""...\""\\n              << s.substr(s.length() - 20, 20) << std::endl;\\n    return 0;\\n}\\n"
"C++","Archimedean_spiral","The Archimedean spiral is a spiral named after the Greek mathematician Archimedes.\\n\\nAn Archimedean spiral can be described by the equation:\\nwith real numbers a and b.\\n\\nDraw an Archimedean spiral.\\n\\n\\n","\\n#include <windows.h>\\n#include <string>\\n#include <iostream>\\n \\nconst int BMP_SIZE = 600;\\n \\nclass myBitmap {\\npublic:\\n    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}\\n    ~myBitmap() {\\n        DeleteObject( pen ); DeleteObject( brush );\\n        DeleteDC( hdc ); DeleteObject( bmp );\\n    }\\n    bool create( int w, int h ) {\\n        BITMAPINFO bi;\\n        ZeroMemory( &bi, sizeof( bi ) );\\n        bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );\\n        bi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;\\n        bi.bmiHeader.biCompression = BI_RGB;\\n        bi.bmiHeader.biPlanes      = 1;\\n        bi.bmiHeader.biWidth       =  w;\\n        bi.bmiHeader.biHeight      = -h;\\n        HDC dc = GetDC( GetConsoleWindow() );\\n        bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );\\n        if( !bmp ) return false;\\n        hdc = CreateCompatibleDC( dc );\\n        SelectObject( hdc, bmp );\\n        ReleaseDC( GetConsoleWindow(), dc );\\n        width = w; height = h;\\n        return true;\\n    }\\n    void clear( BYTE clr = 0 ) {\\n        memset( pBits, clr, width * height * sizeof( DWORD ) );\\n    }\\n    void setBrushColor( DWORD bClr ) {\\n        if( brush ) DeleteObject( brush );\\n        brush = CreateSolidBrush( bClr );\\n        SelectObject( hdc, brush );\\n    }\\n    void setPenColor( DWORD c ) {\\n        clr = c; createPen();\\n    }\\n    void setPenWidth( int w ) {\\n        wid = w; createPen();\\n    }\\n    void saveBitmap( std::string path ) {\\n        BITMAPFILEHEADER fileheader;\\n        BITMAPINFO       infoheader;\\n        BITMAP           bitmap;\\n        DWORD            wb;\\n        GetObject( bmp, sizeof( bitmap ), &bitmap );\\n        DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];\\n        ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );\\n        ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );\\n        ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );\\n        infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;\\n        infoheader.bmiHeader.biCompression = BI_RGB;\\n        infoheader.bmiHeader.biPlanes = 1;\\n        infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );\\n        infoheader.bmiHeader.biHeight = bitmap.bmHeight;\\n        infoheader.bmiHeader.biWidth = bitmap.bmWidth;\\n        infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );\\n        fileheader.bfType    = 0x4D42;\\n        fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );\\n        fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;\\n        GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );\\n        HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, \\n                                  FILE_ATTRIBUTE_NORMAL, NULL );\\n        WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );\\n        WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );\\n        WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );\\n        CloseHandle( file );\\n        delete [] dwpBits;\\n    }\\n    HDC getDC() const     { return hdc; }\\n    int getWidth() const  { return width; }\\n    int getHeight() const { return height; }\\nprivate:\\n    void createPen() {\\n        if( pen ) DeleteObject( pen );\\n        pen = CreatePen( PS_SOLID, wid, clr );\\n        SelectObject( hdc, pen );\\n    }\\n    HBITMAP bmp; HDC    hdc;\\n    HPEN    pen; HBRUSH brush;\\n    void    *pBits; int    width, height, wid;\\n    DWORD    clr;\\n};\\nclass spiral {\\npublic:\\n    spiral() {\\n        bmp.create( BMP_SIZE, BMP_SIZE );\\n    }\\n    void draw( int c, int s ) {\\n        double a = .2, b = .3, r, x, y;\\n        int w = BMP_SIZE >> 1;\\n        HDC dc = bmp.getDC();\\n        for( double d = 0; d < c * 6.28318530718; d += .002 ) {\\n            r = a + b * d; x = r * cos( d ); y = r * sin( d );\\n            SetPixel( dc, ( int )( s * x + w ), ( int )( s * y + w ), 255 );\\n        }\\n        // saves the bitmap\\n        bmp.saveBitmap( \""./spiral.bmp\"" );\\n    }\\nprivate:\\n    myBitmap bmp;\\n};\\nint main(int argc, char* argv[]) {\\n    spiral s; s.draw( 16, 8 ); return 0;\\n}\\n"
"C++","Arena_storage_pool","Dynamically allocated objects take their memory from a heap. The memory for an object is provided by an allocator which maintains the storage pool used for the heap. Often a call to allocator is denoted as\\nwhere T is the type of an allocated object and P is a reference to the object.\\nThe storage pool chosen by the allocator can be determined by either:\\nIn the former case objects can be allocated only in one storage pool. In the latter case objects of the type can be allocated in any storage pool or on the stack.\\nTask description\\nThe task is to show how allocators and user-defined storage pools are supported by the language. In particular:\\nExplain what controls the storage pool choice in the language.\\nIn Ada the choice of storage pool is controlled by the type of the pointer. Objects pointed by anonymous access types are allocated in the default storage pool. Pool-specific pointer types may get a pool assigned to them:\\nThe following example illustrates implementation of an arena pool. Specification:\\nHere is an implementation of the package:\\nThe following is a test program that uses the pool:\\nFor C, dynamic memory is often used for structures and for arrays when the size of the\\narray is unknown in advance. 'Objects' in C are pretty much structures, with the structure sometimes including a pointer to a virtual dispatch table.\\nTo use dynamic memory, the header for the standard library must be included in the module.\\nUninitialized memory is allocated using the malloc function. To obtain the amount of memory that needs to be allocated, sizeof is used. Sizeof is not a normal C function, it is evaluated by the compiler to obtain the amount of memory needed.\\nSince pointers to structures are needed so frequently, often a\\ntypedef will define a type as being a pointer to the associated structure.\\nOnce one gets used to the notation, programs are actually easier to read, as the\\nvariable declarations don't include all the '*'s.\\nThe calloc() function initializes all allocated memory to zero. It is also often\\nused for allocating memory for arrays of some type.\\nFreeing memory dynamically allocated from the heap is done by calling free().\\nOne can allocate space on the stack using the alloca() function. You do not\\nfree memory that's been allocated with alloca\\nAn object oriented approach will define a function for creating a new object of a class.\\nIn these systems, the size of the memory that needs to be allocated for an instance of the\\nclass will often be included in the 'class' record.\\nSee http://rosettacode.org/wiki/Polymorphic%20copy#C\\nWithout using the standard malloc, things get a bit more complicated. For example, here is some code that implements something like it using the mmap system call (for Linux):\\nThis is not how the real malloc is implemented on Linux. For one, memory leaks cannot be caught by Valgrind, and using a linked list to keep track of allocated blocks is very inefficient.\\nIn C++, the situation with allocators is quite complex:\\nThe following code uses class-specific allocation and deallocation functions:\\nGiven automatic memory handling the only way to ask for memory in Erlang is when creating a process. Likewise the only way to manually return memory is by killing a process. So the pool could be built like this. The unit for memory is word, b.t.w.\\nRun-time memory allocation is a latter-day feature in Fortran. In the beginning, a programme would either fit in the available memory or it would not. Any local variables declared in subroutines, especially arrays, would have some storage requirement that had been fixed at compile time, and space would be reserved for all of them whether any subroutine would be invoked or not in a particular run. Fixed array sizes were particularly troublesome in subroutines, as pre-specifying some largeish size for all such arrays would soon exhaust the available memory and this was especially annoying when it was never going to be the case that all the arrays had to be available simultaneously because not all the subroutines would be invoked or be active together in a particular run. Thus, developers of complicated calculations, say involving a lot of matrix manipulation, would be forced towards devising some storage allocation scheme involving scratchpad arrays that would be passed as additional parameters for subroutines to use as working storage, and soon enough one escalated to having a \""pool\"" array, with portions being reserved and passed about the various routines as needed for a given run. Possibly escalating to further schemes involving disc storage and a lot of effort, repaid in suddenly having larger problems solvable.\\nFortran 90 standardised two ameliorations. A subroutine can now declare arrays whose size is specified at run time, with storage typically organised via a stack, since on exit from the subroutine such storage is abandoned, which is to say, returned to the system pool. Secondly, within a routine, and not requiring entry into a subroutine (nor a begin ... end; block as in Algol), storage can be explicitly allocated with a specified size for arrays as needed, this time from a \""heap\"" storage pool, and later de-allocated. Again, on exiting the subroutine, storage for such arrays (if declared within the subroutine) is abandoned.\\nThus, in a sense, a group of items for which storage has been allocated can have their storage released en-mass by exiting the routine. However, it is not the case that items A, B, C can be allocated in one storage \""area\"" (say called \""Able\"") and another group D, E in a second named area (say \""Baker\""), and that by discarding \""Able\"" all its components would be de-allocated without the need to name them in tedious detail.\\nWhereas previously a problem might not be solvable via the existing code because of excessive fixed-size storage requirements, now reduced demands can be made and those only for subroutines that are in action. Thus larger problems can be handled without agonising attempts to cut-to-fit, the usage for scratchpads such as B being particularly natural as in Algol from the 1960s. But on the other hand, a run might exhaust the available storage (either via the stack or via the heap) somewhere in the middle of job because its particular execution path made too many requests and the happy anticipation of results is instead met by a mess - and a bigger mess, because larger problems are being attempted.\\n","T* foo = new(arena) T;"
"C++","Arena_storage_pool","Dynamically allocated objects take their memory from a heap. The memory for an object is provided by an allocator which maintains the storage pool used for the heap. Often a call to allocator is denoted as\\nwhere T is the type of an allocated object and P is a reference to the object.\\nThe storage pool chosen by the allocator can be determined by either:\\nIn the former case objects can be allocated only in one storage pool. In the latter case objects of the type can be allocated in any storage pool or on the stack.\\nTask description\\nThe task is to show how allocators and user-defined storage pools are supported by the language. In particular:\\nExplain what controls the storage pool choice in the language.\\nIn Ada the choice of storage pool is controlled by the type of the pointer. Objects pointed by anonymous access types are allocated in the default storage pool. Pool-specific pointer types may get a pool assigned to them:\\nThe following example illustrates implementation of an arena pool. Specification:\\nHere is an implementation of the package:\\nThe following is a test program that uses the pool:\\nFor C, dynamic memory is often used for structures and for arrays when the size of the\\narray is unknown in advance. 'Objects' in C are pretty much structures, with the structure sometimes including a pointer to a virtual dispatch table.\\nTo use dynamic memory, the header for the standard library must be included in the module.\\nUninitialized memory is allocated using the malloc function. To obtain the amount of memory that needs to be allocated, sizeof is used. Sizeof is not a normal C function, it is evaluated by the compiler to obtain the amount of memory needed.\\nSince pointers to structures are needed so frequently, often a\\ntypedef will define a type as being a pointer to the associated structure.\\nOnce one gets used to the notation, programs are actually easier to read, as the\\nvariable declarations don't include all the '*'s.\\nThe calloc() function initializes all allocated memory to zero. It is also often\\nused for allocating memory for arrays of some type.\\nFreeing memory dynamically allocated from the heap is done by calling free().\\nOne can allocate space on the stack using the alloca() function. You do not\\nfree memory that's been allocated with alloca\\nAn object oriented approach will define a function for creating a new object of a class.\\nIn these systems, the size of the memory that needs to be allocated for an instance of the\\nclass will often be included in the 'class' record.\\nSee http://rosettacode.org/wiki/Polymorphic%20copy#C\\nWithout using the standard malloc, things get a bit more complicated. For example, here is some code that implements something like it using the mmap system call (for Linux):\\nThis is not how the real malloc is implemented on Linux. For one, memory leaks cannot be caught by Valgrind, and using a linked list to keep track of allocated blocks is very inefficient.\\nIn C++, the situation with allocators is quite complex:\\nThe following code uses class-specific allocation and deallocation functions:\\nGiven automatic memory handling the only way to ask for memory in Erlang is when creating a process. Likewise the only way to manually return memory is by killing a process. So the pool could be built like this. The unit for memory is word, b.t.w.\\nRun-time memory allocation is a latter-day feature in Fortran. In the beginning, a programme would either fit in the available memory or it would not. Any local variables declared in subroutines, especially arrays, would have some storage requirement that had been fixed at compile time, and space would be reserved for all of them whether any subroutine would be invoked or not in a particular run. Fixed array sizes were particularly troublesome in subroutines, as pre-specifying some largeish size for all such arrays would soon exhaust the available memory and this was especially annoying when it was never going to be the case that all the arrays had to be available simultaneously because not all the subroutines would be invoked or be active together in a particular run. Thus, developers of complicated calculations, say involving a lot of matrix manipulation, would be forced towards devising some storage allocation scheme involving scratchpad arrays that would be passed as additional parameters for subroutines to use as working storage, and soon enough one escalated to having a \""pool\"" array, with portions being reserved and passed about the various routines as needed for a given run. Possibly escalating to further schemes involving disc storage and a lot of effort, repaid in suddenly having larger problems solvable.\\nFortran 90 standardised two ameliorations. A subroutine can now declare arrays whose size is specified at run time, with storage typically organised via a stack, since on exit from the subroutine such storage is abandoned, which is to say, returned to the system pool. Secondly, within a routine, and not requiring entry into a subroutine (nor a begin ... end; block as in Algol), storage can be explicitly allocated with a specified size for arrays as needed, this time from a \""heap\"" storage pool, and later de-allocated. Again, on exiting the subroutine, storage for such arrays (if declared within the subroutine) is abandoned.\\nThus, in a sense, a group of items for which storage has been allocated can have their storage released en-mass by exiting the routine. However, it is not the case that items A, B, C can be allocated in one storage \""area\"" (say called \""Able\"") and another group D, E in a second named area (say \""Baker\""), and that by discarding \""Able\"" all its components would be de-allocated without the need to name them in tedious detail.\\nWhereas previously a problem might not be solvable via the existing code because of excessive fixed-size storage requirements, now reduced demands can be made and those only for subroutines that are in action. Thus larger problems can be handled without agonising attempts to cut-to-fit, the usage for scratchpads such as B being particularly natural as in Algol from the 1960s. But on the other hand, a run might exhaust the available storage (either via the stack or via the heap) somewhere in the middle of job because its particular execution path made too many requests and the happy anticipation of results is instead met by a mess - and a bigger mess, because larger problems are being attempted.\\n","#include <cstdlib>\\n#include <cassert>\\n#include <new>\\n\\n// This class basically provides a global stack of pools; it is not thread-safe, and pools must be destructed in reverse order of construction\\n// (you definitely want something better in production use :-))\\nclass Pool\\n{\\npublic:\\n  Pool(std::size_type sz);\\n  ~Pool();\\n  static Pool& current() { return *cur; }\\n  void* allocate(std::size_type sz, std::size_t alignment);\\nprivate:\\n  char* memory; // char* instead of void* enables pointer arithmetic\\n  char* free;\\n  char* end;\\n  Pool* prev;\\n  static Pool* cur;\\n\\n  // prohibit copying\\n  Pool(Pool const&); // not implemented\\n  Pool& operator=(Pool const&); // not implemented\\n};\\n\\nPool* pool::cur = 0;\\n\\nPool::Pool(std::size_type size):\\n  memory(static_cast(::operator new(size))),\\n  free(memory),\\n  end(memory + size))\\n{\\n  prev = cur;\\n  cur = this;\\n}\\n\\nPool::~Pool()\\n{\\n  ::operator delete(memory);\\n  cur = prev;\\n}\\n\\nvoid* Pool::allocate(std::size_t size, std::size_t alignment)\\n{\\n  char* start = free;\\n\\n  // align the pointer\\n  std::size_t extra = (start - memory) % aligment;\\n  if (extra != 0)\\n  {\\n    extra = alignment - extra;\\n  }\\n\\n  // test if we can still allocate that much memory\\n  if (end - free < size + extra)\\n    throw std::bad_alloc();\\n\\n  // the free memory now starts after the newly allocated object\\n  free = start + size + extra;\\n  return start;\\n}\\n\\n// this is just a simple C-like struct, except that it uses a specific allocation/deallocation function.\\nstruct X\\n{\\n  int member;\\n  void* operator new(std::size_t);\\n  void operator delete(void*) {} // don't deallocate memory for single objects\\n};\\n\\nvoid* X::operator new(std::size_t size)\\n{\\n  // unfortunately C++ doesn't offer a portable way to find out alignment\\n  // however, using the size as alignment is always safe (although usually wasteful)\\n  return Pool::current().allocate(size, size);\\n}\\n\\n// Example program\\nint main()\\n{\\n  Pool my_pool(3*sizeof(X));\\n  X* p1 = new X; // uses the allocator function defined above\\n  X* p2 = new X;\\n  X* p3 = new X;\\n  delete p3; // doesn't really deallocate the memory because operator delete has an empty body\\n\\n  try\\n  {\\n    X* p4 = new X; // should fail\\n    assert(false);\\n  }\\n  catch(...)\\n  {\\n  }\\n\\n  X* p5 = new X[10]; // uses global array allocation routine because we didn't provide operator new[] and operator delete[]\\n  delete[] p5; // global array deallocation\\n\\n  Pool* my_second_pool(1000); // a large pool\\n  X* p6 = new X; // allocate a new object from that pool\\n  X* p7 = new X;\\n  delete my_second_pool // also deallocates the memory for p6 and p7\\n\\n} // Here my_pool goes out of scope, deallocating the memory for p1, p2 and p3"
"C++","Arithmetic_evaluation","Create a program which parses and evaluates arithmetic expressions.\\n\\nFor those who don't remember, mathematical precedence is as follows:\\n\\n\\nPratt parser\\n"," #include \\n #include \\n #include <string>\\n #include <cassert>\\n #include <iostream>\\n #include <istream>\\n #include <ostream>\\n \\n using boost::spirit::rule;\\n using boost::spirit::parser_tag;\\n using boost::spirit::ch_p;\\n using boost::spirit::real_p;\\n \\n using boost::spirit::tree_node;\\n using boost::spirit::node_val_data;\\n \\n // The grammar\\n struct parser: public boost::spirit::grammar<parser>\\n {\\n   enum rule_ids { addsub_id, multdiv_id, value_id, real_id };\\n \\n   struct set_value\\n   {\\n     set_value(parser const& p): self(p) {}\\n     void operator()(tree_node >& node,\\n                     std::string::iterator begin,\\n                     std::string::iterator end) const\\n     {\\n       node.value.value(self.tmp);\\n     }\\n     parser const& self;\\n   };\\n \\n   mutable double tmp;\\n \\n   template struct definition\\n   {\\n     rule > addsub;\\n     rule > multdiv;\\n     rule > value;\\n     rule > real;\\n \\n     definition(parser const& self)\\n     {\\n       using namespace boost::spirit;\\n       addsub = multdiv\\n         >> *((root_node_d[ch_p('+')] | root_node_d[ch_p('-')]) >> multdiv);\\n       multdiv = value\\n         >> *((root_node_d[ch_p('*')] | root_node_d[ch_p('/')]) >> value);\\n       value = real | inner_node_d[('(' >> addsub >> ')')];\\n       real = leaf_node_d[access_node_d[real_p[assign_a(self.tmp)]][set_value(self)]];\\n     }\\n \\n     rule > const& start() const\\n     {\\n       return addsub;\\n     }\\n   };\\n };\\n \\n template\\n double evaluate(TreeIter const& i)\\n {\\n   double op1, op2;\\n   switch (i->value.id().to_long())\\n   {\\n   case parser::real_id:\\n     return i->value.value();\\n   case parser::value_id:\\n   case parser::addsub_id:\\n   case parser::multdiv_id:\\n     op1 = evaluate(i->children.begin());\\n     op2 = evaluate(i->children.begin()+1);\\n     switch(*i->value.begin())\\n     {\\n     case '+':\\n       return op1 + op2;\\n     case '-':\\n       return op1 - op2;\\n     case '*':\\n       return op1 * op2;\\n     case '/':\\n       return op1 / op2;\\n     default:\\n       assert(!\""Should not happen\"");\\n     }\\n   default:\\n     assert(!\""Should not happen\"");\\n   }\\n   return 0;\\n }\\n \\n // the read/eval/write loop\\n int main()\\n {\\n   parser eval;\\n   std::string line;\\n   while (std::cout << \""Expression: \""\\n          && std::getline(std::cin, line)\\n          && !line.empty())\\n   {\\n     typedef boost::spirit::node_val_data_factory<double> factory_t;\\n     boost::spirit::tree_parse_info info =\\n       boost::spirit::ast_parse(line.begin(), line.end(),\\n                                           eval, boost::spirit::space_p);\\n     if (info.full)\\n     {\\n       std::cout << \""Result: \"" << evaluate(info.trees.begin()) << std::endl;\\n     }\\n     else\\n     {\\n       std::cout << \""Error in expression.\"" << std::endl;\\n     }\\n   }\\n };"
"C++","Arithmetic-geometric_mean/Calculate_Pi","Almkvist Berndt 1988 begins with an investigation of why the agm is such an efficient algorithm, and proves that it converges quadratically. This is an efficient method to calculate \\n\\n\\n\\nπ\\n\\n\\n{\\displaystyle \\pi }\\n\\n.\\nWith the same notations used in Arithmetic-geometric mean, we can summarize the paper by writing:\\n\\n\\n\\n\\nπ\\n=\\n\\n\\n\\n4\\n\\n\\na\\ng\\nm\\n\\n(\\n1\\n,\\n1\\n\\n/\\n\\n\\n\\n2\\n\\n\\n\\n)\\n\\n2\\n\\n\\n\\n\\n1\\n−\\n\\n∑\\n\\nn\\n=\\n1\\n\\n\\n∞\\n\\n\\n\\n2\\n\\nn\\n+\\n1\\n\\n\\n(\\n\\na\\n\\nn\\n\\n\\n2\\n\\n\\n−\\n\\ng\\n\\nn\\n\\n\\n2\\n\\n\\n)\\n\\n\\n\\n\\n\\n{\\displaystyle \\pi ={\\frac {4\\;\\mathrm {agm} (1,1/{\\sqrt {2}})^{2}}{1-\\sum \\limits _{n=1}^{\\infty }2^{n+1}(a_{n}^{2}-g_{n}^{2})}}}\\n\\n\\nThis allows you to make the approximation, for any large   N:\\n\\n\\n\\n\\nπ\\n≈\\n\\n\\n\\n4\\n\\n\\na\\n\\nN\\n\\n\\n2\\n\\n\\n\\n\\n1\\n−\\n\\n∑\\n\\nk\\n=\\n1\\n\\n\\nN\\n\\n\\n\\n2\\n\\nk\\n+\\n1\\n\\n\\n(\\n\\na\\n\\nk\\n\\n\\n2\\n\\n\\n−\\n\\ng\\n\\nk\\n\\n\\n2\\n\\n\\n)\\n\\n\\n\\n\\n\\n{\\displaystyle \\pi \\approx {\\frac {4\\;a_{N}^{2}}{1-\\sum \\limits _{k=1}^{N}2^{k+1}(a_{k}^{2}-g_{k}^{2})}}}\\n\\n\\nThe purpose of this task is to demonstrate how to use this approximation in order to compute a large number of decimals of \\n\\n\\n\\nπ\\n\\n\\n{\\displaystyle \\pi }\\n\\n.\\nSee Talk:Arithmetic-geometric mean\\ni<7 produces:\\ni<8 produces:\\n","\\n#include <gmpxx.h>\\n \\nvoid agm(mpf_class& rop1, mpf_class& rop2, const mpf_class& op1,\\n        const mpf_class& op2)\\n{\\n    rop1 = (op1 + op2) / 2;\\n    rop2 = op1 * op2;\\n    mpf_sqrt(rop2.get_mpf_t(), rop2.get_mpf_t());\\n}\\n \\nint main(void)\\n{\\n    mpf_set_default_prec(300000);\\n    mpf_class x0, y0, resA, resB, Z;\\n \\n    x0 = 1;\\n    y0 = 0.5;\\n    Z  = 0.25;\\n    mpf_sqrt(y0.get_mpf_t(), y0.get_mpf_t());\\n \\n    int n = 1;\\n    for (int i = 0; i < 8; i++) {\\n        agm(resA, resB, x0, y0);\\n        Z -= n * (resA - x0) * (resA - x0);\\n        n *= 2;\\n\\n        agm(x0, y0, resA, resB);\\n        Z -= n * (x0 - resA) * (x0 - resA);\\n        n *= 2;\\n    }\\n\\n    x0 = x0 * x0 / Z;\\n    gmp_printf (\""%.100000Ff\\n\"", x0.get_mpf_t());\\n    return 0;\\n}\\n"
"C++","Arithmetic/Complex","A   complex number   is a number which can be written as:\\n\\n\\n\\n\\na\\n+\\nb\\n×\\ni\\n\\n\\n{\\displaystyle a+b\\times i}\\n\\n\\n(sometimes shown as:\\n\\n\\n\\n\\nb\\n+\\na\\n×\\ni\\n\\n\\n{\\displaystyle b+a\\times i}\\n\\n\\nwhere   \\n\\n\\n\\na\\n\\n\\n{\\displaystyle a}\\n\\n   and   \\n\\n\\n\\nb\\n\\n\\n{\\displaystyle b}\\n\\n  are real numbers,   and   \\n\\n\\n\\ni\\n\\n\\n{\\displaystyle i}\\n\\n   is   √ -1 \\n\\nTypically, complex numbers are represented as a pair of real numbers called the \""imaginary part\"" and \""real part\"",   where the imaginary part is the number to be multiplied by \\n\\n\\n\\ni\\n\\n\\n{\\displaystyle i}\\n\\n.\\n\\n\\nBy definition, the   complex conjugate   of\\n\\n\\n\\n\\na\\n+\\nb\\ni\\n\\n\\n{\\displaystyle a+bi}\\n\\n\\nis\\n\\n\\n\\n\\na\\n−\\nb\\ni\\n\\n\\n{\\displaystyle a-bi}\\n\\n\\n\\nSome languages have complex number libraries available.   If your language does, show the operations.   If your language does not, also show the definition of this type.\\n\\n","#include <iostream>\\n#include <complex>\\nusing std::complex;\\n\\nvoid complex_operations() {\\n  complex<double> a(1.0, 1.0);\\n  complex<double> b(3.14159, 1.25);\\n\\n  // addition\\n  std::cout << a + b << std::endl;\\n  // multiplication\\n  std::cout << a * b << std::endl;\\n  // inversion\\n  std::cout << 1.0 / a << std::endl;\\n  // negation\\n  std::cout << -a << std::endl;\\n  // conjugate\\n  std::cout << std::conj(a) << std::endl;\\n}"
"C++","Arithmetic/Integer","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\nGet two integers from the user,   and then (for those two integers), display their:\\n\\nDon't include error handling.\\nFor quotient, indicate how it rounds   (e.g. towards zero, towards negative infinity, etc.).\\nFor remainder, indicate whether its sign matches the sign of the first operand or of the second operand, if they are different.\\n\\n","#include <iostream>\\n\\nint main()\\n{\\n  int a, b;\\n  std::cin >> a >> b;\\n  std::cout << \""a+b = \"" << a+b << \""\\n\"";\\n  std::cout << \""a-b = \"" << a-b << \""\\n\"";\\n  std::cout << \""a*b = \"" << a*b << \""\\n\"";\\n  std::cout << \""a/b = \"" << a/b << \"", remainder \"" << a%b << \""\\n\"";\\n  return 0;\\n}"
"C++","Arithmetic/Rational","Create a reasonably complete implementation of rational arithmetic in the particular language using the idioms of the language.\\n\\nDefine a new type called frac with binary operator \""//\"" of two integers that returns a structure made up of the numerator and the denominator (as per a rational number).\\nFurther define the appropriate rational unary operators abs and '-', with the binary operators for addition '+', subtraction '-', multiplication '×', division '/', integer division '÷', modulo division, the comparison operators (e.g. '<', '≤', '>', & '≥') and equality operators (e.g. '=' & '≠').\\nDefine standard coercion operators for casting int to frac etc.\\nIf space allows, define standard increment and decrement operators (e.g. '+:=' & '-:=' etc.).\\nFinally test the operators:\\nUse the new type frac to find all perfect numbers less than 219 by summing the reciprocal of the factors.\\n\\n\\nThe generic package specification:\\nThe package can be instantiated with any integer type. It provides rational numbers represented by a numerator and denominator cleaned from the common divisors. Mixed arithmetic of the base integer type and the rational type is supported. Division to zero raises Constraint_Error. The implementation of the specification above is as follows:\\nThe implementation uses solution of the greatest common divisor task. Here is the implementation of the test:\\nThe perfect numbers are searched by summing of the reciprocal of each of the divisors of a candidate except 1. This sum must be 1 for a perfect number.\\n","#include <iostream>\\n#include \""math.h\""\\n#include \""boost/rational.hpp\""\\n\\ntypedef  boost::rational<int> frac;\\n\\nbool is_perfect(int c)\\n{\\n    frac sum(1, c);\\n    for (int f = 2;f < sqrt(static_cast<float>(c)); ++f){\\n\\n        if (c % f == 0) sum += frac(1,f) + frac(1, c/f);\\n    }\\n    if (sum.denominator() == 1){\\n 	return (sum == 1);\\n    }\\n    return false;\\n}\\n\\nint main()\\n{\\n    for (int candidate = 2; candidate < 0x80000; ++candidate){\\n        if (is_perfect(candidate)) \\n	        std::cout << candidate << \"" is perfect\"" << std::endl;\\n    }\\n    return 0;\\n}"
"C++","Array_concatenation","Show how to concatenate two arrays in your language.\\n\\nIf this is as simple as array1 + array2, so be it.\\n\\n","#include <vector>\\n#include <iostream>\\n\\nint main()\\n{\\n  std::vector<int> a(3), b(4);\\n  a[0] = 11; a[1] = 12; a[2] = 13;\\n  b[0] = 21; b[1] = 22; b[2] = 23; b[3] = 24;\\n\\n  a.insert(a.end(), b.begin(), b.end());\\n\\n  for (int i = 0; i < a.size(); ++i)\\n    std::cout << \""a[\"" << i << \""] = \"" << a[i] << \""\\n\"";\\n}"
"C++","Array_concatenation","Show how to concatenate two arrays in your language.\\n\\nIf this is as simple as array1 + array2, so be it.\\n\\n","#include <vector>                                                                                                       \\n#include <iostream>\\n\\nint main() {\\n  std::vector<int> a {1, 2, 3, 4};\\n  std::vector<int> b {5, 6, 7, 8, 9};\\n\\n  a.insert(a.end(), b.begin(), b.end());\\n\\n  for(int& i: a) std::cout << i << \"" \"";\\n  std::cout << std::endl;\\n  return 0;\\n}"
"C++","Array_concatenation","Show how to concatenate two arrays in your language.\\n\\nIf this is as simple as array1 + array2, so be it.\\n\\n","#include <iostream>\\n\\nusing namespace std;\\n\\ntemplate \\nint* concatArrays( T1& array_1, T2& array_2) {\\n  int arrayCount_1 = sizeof(array_1) / sizeof(array_1[0]);\\n  int arrayCount_2 = sizeof(array_2) / sizeof(array_2[0]);\\n  int newArraySize = arrayCount_1 + arrayCount_2;\\n\\n  int *p = new int[newArraySize];\\n\\n  for (int i = 0; i < arrayCount_1; i++) {\\n    p[i] = array_1[i];\\n  }\\n\\n  for (int i = arrayCount_1; i < newArraySize; i++) {\\n    int newIndex = i-arrayCount_2;\\n\\n    if (newArraySize % 2 == 1)\\n	newIndex--;\\n\\n    p[i] = array_2[newIndex];\\n    cout << \""i: \"" << i << endl;\\n    cout << \""array_2[i]: \"" << array_2[newIndex] << endl;\\n    cout << endl;\\n  }\\n\\n  return p;\\n}\\n\\nint main() {\\n  \\n  int ary[4] = {1, 2, 3, 123};\\n  int anotherAry[3] = {4, 5, 6};\\n  \\n  int *r = concatArrays(ary, anotherAry);\\n\\n  cout << *(r + 0) << endl;\\n  cout << *(r + 1) << endl;\\n  cout << *(r + 2) << endl;\\n  cout << *(r + 3) << endl;\\n  cout << *(r + 4) << endl;\\n  cout << *(r + 5) << endl;\\n  cout << *(r + 6) << endl;\\n\\n  delete r;\\n\\n  return 0;\\n}"
"C++","Array_length","Determine the amount of elements in an array.\\n\\nAs an example use an array holding the strings 'apple' and 'orange'.\\n\\n\\n","\\n#include <array>\\n#include <iostream>\\n#include <string>\\n\\nint main() \\n{\\n    std::array fruit { \""apples\"", \""oranges\"" };\\n    std::cout << fruit.size();\\n    return 0;\\n}\\n"
"C++","Array_length","Determine the amount of elements in an array.\\n\\nAs an example use an array holding the strings 'apple' and 'orange'.\\n\\n\\n","\\n    std::vector fruitV({ \""apples\"", \""oranges\"" });\\n    std::list fruitL({ \""apples\"", \""oranges\"" });\\n    std::deque fruitD({ \""apples\"", \""oranges\"" });\\n    std::cout << fruitV.size() << fruitL.size() << fruitD.size() << std::endl;\\n"
"C++","Arrays","This task is about arrays.\\nFor hashes or associative arrays, please see Creating an Associative Array.\\nFor a definition and in-depth discussion of what an array is, see Array.\\n\\nShow basic array syntax in your language.\\nBasically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and\\ndynamic arrays, pushing a value into it).\\nPlease discuss at Village Pump:   Arrays.\\nPlease merge code in from these obsolete tasks:\\n\\n\\nDynamic (resizable) arrays are possible to implement, but are error-prone since bounds checking must be done by the programmer.\\nArrays are declared using JSON syntax, and are dynamic (but not sparse)\\nThere are no real arrays in ABAP but a construct called internal tables.\\n","#include <array>\\n#include <vector>\\n\\n// These headers are only needed for the demonstration\\n#include <algorithm>\\n#include <iostream>\\n#include <iterator>\\n#include <string>\\n\\n// This is a template function that works for any array-like object\\ntemplate \\nvoid demonstrate(Array& array)\\n{\\n  // Array element access\\n  array[2] = \""Three\"";  // Fast, but unsafe - if the index is out of bounds you\\n                       // get undefined behaviour\\n  array.at(1) = \""Two\""; // *Slightly* less fast, but safe - if the index is out\\n                       // of bounds, an exception is thrown\\n  \\n  // Arrays can be used with standard algorithms\\n  std::reverse(begin(array), end(array));\\n  std::for_each(begin(array), end(array),\\n    [](typename Array::value_type const& element) // in C++14, you can just use auto\\n    {\\n      std::cout << element << ' ';\\n    });\\n  \\n  std::cout << '\\n';\\n}\\n\\nint main()\\n{\\n  // Compile-time sized fixed-size array\\n  auto fixed_size_array = std::array{ \""One\"", \""Four\"", \""Eight\"" };\\n  // If you do not supply enough elements, the remainder are default-initialized\\n  \\n  // Dynamic array\\n  auto dynamic_array = std::vector{ \""One\"", \""Four\"" };\\n  dynamic_array.push_back(\""Eight\""); // Dynamically grows to accept new element\\n  \\n  // All types of arrays can be used more or less interchangeably\\n  demonstrate(fixed_size_array);\\n  demonstrate(dynamic_array);\\n}"
"C++","Assertions","Assertions are a way of breaking out of code when there is an error or an unexpected input.\\nSome languages throw exceptions and some treat it as a break point.\\n\\nShow an assertion in your language by asserting that an integer variable is equal to 42.\\n\\nUsing pragma Assert:\\nThe behavior of pragma is controlled by pragma Assertion_Policy. Another way is to use the predefined package Ada.Assertions:\\nThe procedure Assert propagates Assertion_Error when condition is false.\\nExecuting the program will produce on standard error:\\nThe \""Revised Report on the Algorithmic Language - ALGOL 68\"" suggest that\\nASSERT may be made available by a particular implementation, quote: \""Pragmats may\\n... convey to the implementation some piece of information affecting some aspect\\nof the meaning of the program which is not defined by this Report,...\""\\nExample given[1]:\\nThis works with neither ELLA ALGOL 68 nor ALGOL 68G.\\nThe standard alternative would be to implement the assertions\\nas an exception as per the Exceptions sample code.\\nIn ELLA ALGOL 68 the ASSERT is implemented as an operator in the environment prelude:\\nAnd can be \""USEd\"" as follows:\\nAssertions were added to the 1972 version of Algol W. If the tested condition is false, the program terminates. In the following, the write does not get executed.\\nAsserts that the specified condition is true. If it is not, a fatal error is returned that causes code execution to halt.\\nAsserts that the first two arguments are the same. If they are not, a fatal error is returned that causes code execution to halt.\\nAsserts that the first two arguments are different. If they are the same, a fatal error is returned that causes code execution to halt.\\nYou can’t catch an assertion failure using a try/catch block even though it is logged as an exception.\\nAWK doesn't have a built-in assert statement. It could be simulated using a user-defined assert() function defined as below. The BEGIN section shows some examples of successful and failed \""assertions\"".\\nThe above example produces the output below, and sets the program's exit code to 1 (the default is 0)\\n","#include <cassert> // assert.h also works\\n\\nint main()\\n{\\n  int a;\\n  // ... input or change a here\\n\\n  assert(a == 42); // Aborts program if a is not 42, unless the NDEBUG macro was defined\\n                    // when including <cassert>, in which case it has no effect\\n}"
"C++","Associative_array/Iteration","Show how to iterate over the key-value pairs of an associative array, and print each pair out.\\nAlso show how to iterate just over the keys, or the values, if there is a separate way to do that in your language.\\n\\n\\n","#include <iostream>\\n#include <map>\\n#include <string>\\n\\nint main() {\\n  std::map dict {\\n    {\""One\"", 1},\\n    {\""Two\"", 2},\\n    {\""Three\"", 7}\\n  };\\n\\n  dict[\""Three\""] = 3;\\n\\n  std::cout << \""One: \"" << dict[\""One\""] << std::endl;\\n  std::cout << \""Key/Value pairs: \"" << std::endl;\\n  for(auto& kv: dict) {\\n    std::cout << \""  \"" << kv.first << \"": \"" << kv.second << std::endl;\\n  }\\n\\n  return 0;\\n}"
"C++","Associative_array/Iteration","Show how to iterate over the key-value pairs of an associative array, and print each pair out.\\nAlso show how to iterate just over the keys, or the values, if there is a separate way to do that in your language.\\n\\n\\n","std::map myDict;\\nmyDict[\""hello\""] = 1;\\nmyDict[\""world\""] = 2;\\nmyDict[\""!\""] = 3;\\n\\n// iterating over key-value pairs:\\nfor (std::map::iterator it = myDict.begin(); it != myDict.end(); ++it) {\\n    // the thing pointed to by the iterator is an std::pair&\\n    const std::string& key = it->first;\\n    int& value = it->second;\\n    std::cout << \""key = \"" << key << \"", value = \"" << value << std::endl;\\n}"
"C++","Atomic_updates","\\nDefine a data type consisting of a fixed number of 'buckets', each containing a nonnegative integer value, which supports operations to:\\nIn order to exercise this data type, create one set of buckets, and start three concurrent tasks:\\n\\nThe display task need not be explicit; use of e.g. a debugger or trace tool is acceptable provided it is simple to set up to provide the display.\\nThis task is intended as an exercise in atomic operations.   The sum of the bucket values must be preserved even if the two tasks attempt to perform transfers simultaneously, and a straightforward solution is to ensure that at any time, only one transfer is actually occurring — that the transfer operation is atomic.\\n\\n","#include <algorithm>\\n#include <array>\\n#include <chrono>\\n#include <iomanip>\\n#include <iostream>\\n#include <mutex>\\n#include <random>\\n#include <thread>\\n\\nusing namespace std;\\n\\nconstexpr int bucket_count = 15;\\n\\nvoid equalizer(array& buckets,\\n               array& bucket_mutex) {\\n    random_device rd;\\n    mt19937 gen(rd());\\n    uniform_int_distribution<> dist_bucket(0, bucket_count - 1);\\n\\n    while (true) {\\n        int from = dist_bucket(gen);\\n        int to = dist_bucket(gen);\\n        if (from != to) {\\n            lock_guard<mutex> lock_first(bucket_mutex[min(from, to)]);\\n            lock_guard<mutex> lock_second(bucket_mutex[max(from, to)]);\\n            int diff = buckets[from] - buckets[to];\\n            int amount = abs(diff / 2);\\n            if (diff < 0) {\\n                swap(from, to);\\n            }\\n            buckets[from] -= amount;\\n            buckets[to] += amount;\\n        }\\n    }\\n}\\n\\nvoid randomizer(array& buckets,\\n                array& bucket_mutex) {\\n    random_device rd;\\n    mt19937 gen(rd());\\n    uniform_int_distribution<> dist_bucket(0, bucket_count - 1);\\n\\n    while (true) {\\n        int from = dist_bucket(gen);\\n        int to = dist_bucket(gen);\\n        if (from != to) {\\n            lock_guard<mutex> lock_first(bucket_mutex[min(from, to)]);\\n            lock_guard<mutex> lock_second(bucket_mutex[max(from, to)]);\\n            uniform_int_distribution<> dist_amount(0, buckets[from]);\\n            int amount = dist_amount(gen);\\n            buckets[from] -= amount;\\n            buckets[to] += amount;\\n        }\\n    }\\n}\\n\\nvoid print_buckets(const array& buckets) {\\n    int total = 0;\\n    for (const int& bucket : buckets) {\\n        total += bucket;\\n        cout << setw(3) << bucket << ' ';\\n    }\\n    cout << \""= \"" << setw(3) << total << endl;\\n}\\n\\nint main() {\\n    random_device rd;\\n    mt19937 gen(rd());\\n    uniform_int_distribution<> dist(0, 99);\\n\\n    array buckets;\\n    array bucket_mutex;\\n    for (int& bucket : buckets) {\\n        bucket = dist(gen);\\n    }\\n    print_buckets(buckets);\\n\\n    thread t_eq(equalizer, ref(buckets), ref(bucket_mutex));\\n    thread t_rd(randomizer, ref(buckets), ref(bucket_mutex));\\n\\n    while (true) {\\n        this_thread::sleep_for(chrono::seconds(1));\\n        for (mutex& mutex : bucket_mutex) {\\n            mutex.lock();\\n        }\\n        print_buckets(buckets);\\n        for (mutex& mutex : bucket_mutex) {\\n            mutex.unlock();\\n        }\\n    }\\n    return 0;\\n}"
"C++","Average_loop_length","Let f be a uniformly-randomly chosen mapping from the numbers 1..N to the numbers 1..N (note: not necessarily a permutation of 1..N; the mapping could produce a number in more than one way or not at all). At some point, the sequence 1, f(1), f(f(1))... will contain a repetition, a number that occurring for the second time in the sequence.\\n\\nWrite a program or a script that estimates, for each N, the average length until the first such repetition.\\nAlso calculate this expected length using an analytical formula, and optionally compare the simulated result with the theoretical one.\\n\\nThis problem comes from the end of Donald Knuth's Christmas tree lecture 2011.\\nExample of expected output:\\n\\n","#include <random>\\n#include <vector>\\n#include <iostream>\\n\\n#define MAX_N 20\\n#define TIMES 1000000\\n\\n/**\\n * Used to generate a uniform random distribution\\n */\\nstatic std::random_device rd;  //Will be used to obtain a seed for the random number engine\\nstatic std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()\\nstatic std::uniform_int_distribution<> dis;\\n\\nint randint(int n) {\\n    int r, rmax = RAND_MAX / n * n;\\n    dis=std::uniform_int_distribution(0,rmax) ;\\n    r = dis(gen);\\n    return r / (RAND_MAX / n);\\n}\\n\\nunsigned long factorial(size_t n) {\\n    //Factorial using dynamic programming to memoize the values.\\n    static std::vectorfactorials{1,1,2};\\n	for (;factorials.size() <= n;)\\n	    factorials.push_back(factorials.back()*factorials.size());\\n	return factorials[n];\\n}\\n\\nlong double expected(size_t n) {\\n    long double sum = 0;\\n    for (size_t i = 1; i <= n; i++)\\n        sum += factorial(n) / pow(n, i) / factorial(n - i);\\n    return sum;\\n}\\n\\nint test(int n, int times) {\\n    int i, count = 0;\\n    for (i = 0; i < times; i++) {\\n        unsigned int x = 1, bits = 0;\\n        while (!(bits & x)) {\\n            count++;\\n            bits |= x;\\n            x = static_cast(1 << randint(n));\\n        }\\n    }\\n    return count;\\n}\\n\\nint main() {\\n    puts(\"" n\\tavg\\texp.\\tdiff\\n-------------------------------\"");\\n\\n    int n;\\n    for (n = 1; n <= MAX_N; n++) {\\n        int cnt = test(n, TIMES);\\n        long double avg = (double)cnt / TIMES;\\n        long double theory = expected(static_cast(n));\\n        long double diff = (avg / theory - 1) * 100;\\n        printf(\""%2d %8.4f %8.4f %6.3f%%\\n\"", n, static_cast<double>(avg), static_cast<double>(theory), static_cast<double>(diff));\\n    }\\n    return 0;\\n}\\n"
"C++","Averages/Arithmetic_mean","Write a program to find the mean (arithmetic average) of a numeric vector.\\nIn case of a zero-length input, since the mean of an empty set of numbers is ill-defined, the program may choose to behave in any way it deems appropriate, though if the programming language has an established convention for conveying math errors or undefined values, it's preferable to follow it.\\n","#include <vector>\\n\\ndouble mean(const std::vector<double>& numbers)\\n{\\n     if (numbers.size() == 0)\\n          return 0;\\n\\n     double sum = 0;\\n     for (std::vector<double>::iterator i = numbers.begin(); i != numbers.end(); i++)\\n          sum += *i;\\n     return sum / numbers.size();\\n}"
"C++","Averages/Arithmetic_mean","Write a program to find the mean (arithmetic average) of a numeric vector.\\nIn case of a zero-length input, since the mean of an empty set of numbers is ill-defined, the program may choose to behave in any way it deems appropriate, though if the programming language has an established convention for conveying math errors or undefined values, it's preferable to follow it.\\n","#include <vector>\\n#include <algorithm>\\n\\ndouble mean(const std::vector<double>& numbers)\\n{\\n    if (numbers.empty())\\n        return 0;\\n    return std::accumulate(numbers.begin(), numbers.end(), 0.0) / numbers.size();\\n}"
"C++","Averages/Arithmetic_mean","Write a program to find the mean (arithmetic average) of a numeric vector.\\nIn case of a zero-length input, since the mean of an empty set of numbers is ill-defined, the program may choose to behave in any way it deems appropriate, though if the programming language has an established convention for conveying math errors or undefined values, it's preferable to follow it.\\n","#include <iterator>\\n#include <algorithm>\\n\\ntemplate \\ndouble mean(Iterator begin, Iterator end)\\n{\\n    if (begin == end)\\n        return 0;\\n    return std::accumulate(begin, end, 0.0) / std::distance(begin, end);\\n}"
"C++","Averages/Median","Write a program to find the   median   value of a vector of floating-point numbers.\\nThe program need not handle the case where the vector is empty, but must handle the case where there are an even number of elements.   In that case, return the average of the two middle values.\\nThere are several approaches to this.   One is to sort the elements, and then pick the element(s) in the middle.\\nSorting would take at least   O(n logn).   Another approach would be to build a priority queue from the elements, and then extract half of the elements to get to the middle element(s).   This would also take   O(n logn).   The best solution is to use the   selection algorithm   to find the median in   O(n)   time.\\nQuickselect_algorithm\\n","#include <algorithm>\\n\\n// inputs must be random-access iterators of doubles\\n// Note: this function modifies the input range\\ntemplate \\ndouble median(Iterator begin, Iterator end) {\\n  // this is middle for odd-length, and \""upper-middle\"" for even length\\n  Iterator middle = begin + (end - begin) / 2;\\n\\n  // This function runs in O(n) on average, according to the standard\\n  std::nth_element(begin, middle, end);\\n\\n  if ((end - begin) % 2 != 0) { // odd length\\n    return *middle;\\n  } else { // even length\\n    // the \""lower middle\"" is the max of the lower half\\n    Iterator lower_middle = std::max_element(begin, middle);\\n    return (*middle + *lower_middle) / 2.0;\\n  }\\n}\\n\\n#include <iostream>\\n\\nint main() {\\n  double a[] = {4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2};\\n  double b[] = {4.1, 7.2, 1.7, 9.3, 4.4, 3.2};\\n\\n  std::cout << median(a+0, a + sizeof(a)/sizeof(a[0])) << std::endl; // 4.4\\n  std::cout << median(b+0, b + sizeof(b)/sizeof(b[0])) << std::endl; // 4.25\\n\\n  return 0;\\n}"
"C++","Averages/Mode","Write a program to find the mode value of a collection.\\nThe case where the collection is empty may be ignored. Care must be taken to handle the case where the mode is non-unique.\\nIf it is not appropriate or possible to support a general collection, use a vector (array), if possible. If it is not appropriate or possible to support an unspecified value type, use integers.\\n","#include <iterator>\\n#include <utility>\\n#include <algorithm>\\n#include <list>\\n#include <iostream>\\n\\n// helper struct\\ntemplate struct referring\\n{\\n  referring(T const& t): value(t) {}\\n  template\\n   bool operator()(std::pair const& p) const\\n  {\\n    return *p.first == value;\\n  }\\n  T const& value;\\n};\\n\\n// requires:\\n// FwdIterator is a ForwardIterator\\n// The value_type of FwdIterator is EqualityComparable\\n// OutIterator is an output iterator\\n// the value_type of FwdIterator is convertible to the value_type of OutIterator\\n// [first, last) is a valid range\\n// provides:\\n// the mode is written to result\\ntemplate\\n void mode(FwdIterator first, FwdIterator last, OutIterator result)\\n{\\n  typedef typename std::iterator_traits<FwdIterator>::value_type value_type;\\n  typedef std::list > count_type;\\n  typedef typename count_type::iterator count_iterator;\\n\\n  // count elements\\n  count_type counts;\\n\\n  while (first != last)\\n  {\\n    count_iterator element = std::find_if(counts.begin(), counts.end(),\\n                                          referring(*first));\\n    if (element == counts.end())\\n      counts.push_back(std::make_pair(first, 1));\\n    else\\n      ++element->second;\\n    ++first;\\n  }\\n\\n  // find maximum\\n  int max = 0;\\n  for (count_iterator i = counts.begin(); i != counts.end(); ++i)\\n    if (i->second > max)\\n      max = i->second;\\n\\n  // copy corresponding elements to output sequence\\n  for (count_iterator i = counts.begin(); i != counts.end(); ++i)\\n    if (i->second == max)\\n      *result++ = *i->first;\\n}\\n\\n// example usage\\nint main()\\n{\\n  int values[] = { 1, 2, 3, 1, 2, 4, 2, 5, 2, 3, 3, 1, 3, 6 };\\n  median(values, values + sizeof(values)/sizeof(int),\\n         std::ostream_iterator<int>(std::cout, \"" \""));\\n  std::cout << std::endl;\\n  return 0;\\n}"
"C++","Averages/Pythagorean_means","Compute all three of the Pythagorean means of the set of integers 1 through 10 (inclusive).\\nShow that \\n\\n\\n\\nA\\n(\\n\\nx\\n\\n1\\n\\n\\n,\\n…\\n,\\n\\nx\\n\\nn\\n\\n\\n)\\n≥\\nG\\n(\\n\\nx\\n\\n1\\n\\n\\n,\\n…\\n,\\n\\nx\\n\\nn\\n\\n\\n)\\n≥\\nH\\n(\\n\\nx\\n\\n1\\n\\n\\n,\\n…\\n,\\n\\nx\\n\\nn\\n\\n\\n)\\n\\n\\n{\\displaystyle A(x_{1},\\ldots ,x_{n})\\geq G(x_{1},\\ldots ,x_{n})\\geq H(x_{1},\\ldots ,x_{n})}\\n\\n for this set of positive integers.\\n\\n","#include <vector>\\n#include <iostream>\\n#include <numeric>\\n#include <cmath>\\n#include <algorithm>\\n\\ndouble toInverse ( int i ) {\\n   return  1.0 / i  ;\\n}\\n\\nint main( ) {\\n   std::vector<int> numbers ;\\n   for ( int i = 1 ; i < 11 ; i++ ) \\n      numbers.push_back( i ) ;\\n   double arithmetic_mean = std::accumulate( numbers.begin( ) , numbers.end( ) , 0 ) / 10.0 ;\\n   double geometric_mean =\\n      pow( std::accumulate( numbers.begin( ) , numbers.end( ) , 1 , std::multiplies<int>( ) ), 0.1 ) ;\\n   std::vector<double> inverses ;\\n   inverses.resize( numbers.size( ) ) ;\\n   std::transform( numbers.begin( ) , numbers.end( ) , inverses.begin( ) , toInverse ) ;  \\n   double harmonic_mean = 10 / std::accumulate( inverses.begin( ) , inverses.end( ) , 0.0 ); //initial value of accumulate must be a double!\\n   std::cout << \""The arithmetic mean is \"" << arithmetic_mean << \"" , the geometric mean \"" \\n      << geometric_mean << \"" and the harmonic mean \"" << harmonic_mean << \"" !\\n\"" ;\\n   return 0 ;\\n}"
"C++","Averages/Root_mean_square","Compute the   Root mean square   of the numbers 1..10.\\n\\nThe   root mean square   is also known by its initials RMS (or rms), and as the quadratic mean.\\nThe RMS is calculated as the mean of the squares of the numbers, square-rooted:\\n\\n\\n","#include <iostream>\\n#include <vector>\\n#include <cmath>\\n#include <numeric>\\n\\nint main( ) {\\n  std::vector<int> numbers ;\\n  for ( int i = 1 ; i < 11 ; i++ )\\n    numbers.push_back( i ) ;\\n  double meansquare = sqrt( ( std::inner_product( numbers.begin(), numbers.end(), numbers.begin(), 0 ) ) / static_cast<double>( numbers.size() ) );\\n  std::cout << \""The quadratic mean of the numbers 1 .. \"" << numbers.size() << \"" is \"" << meansquare << \"" !\\n\"" ;\\n  return 0 ;\\n}"
"C++","Averages/Simple_moving_average","Computing the simple moving average of a series of numbers.\\nCreate a stateful function/class/instance that takes a period and returns a routine that takes a number as argument and returns a simple moving average of its arguments so far.\\nA simple moving average is a method for computing an average of a stream of numbers by only averaging the last   P   numbers from the stream,   where   P   is known as the period.\\nIt can be implemented by calling an initialing routine with   P   as its argument,   I(P),   which should then return a routine that when called with individual, successive members of a stream of numbers, computes the mean of (up to), the last   P   of them, lets call this   SMA().\\nThe word   stateful   in the task description refers to the need for   SMA()   to remember certain information between calls to it:\\n\\nStateful   also means that successive calls to   I(),   the initializer,   should return separate routines that do   not   share saved state so they could be used on two independent streams of data.\\nPseudo-code for an implementation of   SMA   is:\\n","\\n#include <iostream>\\n#include <stddef.h>\\n#include <assert.h>\\n\\nusing std::cout;\\nusing std::endl;\\n\\nclass SMA {\\npublic:\\n	SMA(unsigned int period) :\\n		period(period), window(new double[period]), head(NULL), tail(NULL),\\n				total(0) {\\n		assert(period >= 1);\\n	}\\n	~SMA() {\\n		delete[] window;\\n	}\\n\\n	// Adds a value to the average, pushing one out if nescessary\\n	void add(double val) {\\n		// Special case: Initialization\\n		if (head == NULL) {\\n			head = window;\\n			*head = val;\\n			tail = head;\\n			inc(tail);\\n			total = val;\\n			return;\\n		}\\n\\n		// Were we already full?\\n		if (head == tail) {\\n			// Fix total-cache\\n			total -= *head;\\n			// Make room\\n			inc(head);\\n		}\\n\\n		// Write the value in the next spot.\\n		*tail = val;\\n		inc(tail);\\n\\n		// Update our total-cache\\n		total += val;\\n	}\\n\\n	// Returns the average of the last P elements added to this SMA.\\n	// If no elements have been added yet, returns 0.0\\n	double avg() const {\\n		ptrdiff_t size = this->size();\\n		if (size == 0) {\\n			return 0; // No entries => 0 average\\n		}\\n		return total / (double) size; // Cast to double for floating point arithmetic\\n	}\\n\\nprivate:\\n	unsigned int period;\\n	double * window; // Holds the values to calculate the average of.\\n\\n	// Logically, head is before tail\\n	double * head; // Points at the oldest element we've stored.\\n	double * tail; // Points at the newest element we've stored.\\n\\n	double total; // Cache the total so we don't sum everything each time.\\n\\n	// Bumps the given pointer up by one.\\n	// Wraps to the start of the array if needed.\\n	void inc(double * & p) {\\n		if (++p >= window + period) {\\n			p = window;\\n		}\\n	}\\n\\n	// Returns how many numbers we have stored.\\n	ptrdiff_t size() const {\\n		if (head == NULL)\\n			return 0;\\n		if (head == tail)\\n			return period;\\n		return (period + tail - head) % period;\\n	}\\n};\\n\\nint main(int argc, char * * argv) {\\n	SMA foo(3);\\n	SMA bar(5);\\n\\n	int data[] = { 1, 2, 3, 4, 5, 5, 4, 3, 2, 1 };\\n	for (int * itr = data; itr < data + 10; itr++) {\\n		foo.add(*itr);\\n		cout << \""Added \"" << *itr << \"" avg: \"" << foo.avg() << endl;\\n	}\\n	cout << endl;\\n	for (int * itr = data; itr < data + 10; itr++) {\\n		bar.add(*itr);\\n		cout << \""Added \"" << *itr << \"" avg: \"" << bar.avg() << endl;\\n	}\\n\\n	return 0;\\n}\\n"
"C++","AVL_tree","\\nIn computer science, an AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; at no time do they differ by more than one because rebalancing is done ensure this is the case. Lookup, insertion, and deletion all take O(log n) time in both the average and worst cases, where n is the number of nodes in the tree prior to the operation. Insertions and deletions may require the tree to be rebalanced by one or more tree rotations.\\nAVL trees are often compared with red-black trees because they support the same set of operations and because red-black trees also take O(log n) time for the basic operations. Because AVL trees are more rigidly balanced, they are faster than red-black trees for lookup-intensive applications. Similar to red-black trees, AVL trees are height-balanced, but in general not weight-balanced nor μ-balanced; that is, sibling nodes can have hugely differing numbers of descendants.\\n\\nImplement an AVL tree in the language of choice, and provide at least basic operations.\\n\\nThis implementation uses the type system to enforce the height invariants, though not the BST invariants\\nSee AVL tree/C\\nSee AVL_tree/C_sharp.\\n","\\n#include <algorithm>\\n#include <iostream>\\n\\n/* AVL node */\\ntemplate \\nclass AVLnode {\\npublic:\\n    T key;\\n    int balance;\\n    AVLnode *left, *right, *parent;\\n\\n    AVLnode(T k, AVLnode *p) : key(k), balance(0), parent(p),\\n                        left(NULL), right(NULL) {}\\n\\n    ~AVLnode() {\\n        delete left;\\n        delete right;\\n    }\\n};\\n\\n/* AVL tree */\\ntemplate \\nclass AVLtree {\\npublic:\\n    AVLtree(void);\\n    ~AVLtree(void);\\n    bool insert(T key);\\n    void deleteKey(const T key);\\n    void printBalance();\\n\\nprivate:\\n    AVLnode<T> *root;\\n\\n    AVLnode<T>* rotateLeft          ( AVLnode<T> *a );\\n    AVLnode<T>* rotateRight         ( AVLnode<T> *a );\\n    AVLnode<T>* rotateLeftThenRight ( AVLnode<T> *n );\\n    AVLnode<T>* rotateRightThenLeft ( AVLnode<T> *n );\\n    void rebalance                  ( AVLnode<T> *n );\\n    int height                      ( AVLnode<T> *n );\\n    void setBalance                 ( AVLnode<T> *n );\\n    void printBalance               ( AVLnode<T> *n );\\n    void clearNode                  ( AVLnode<T> *n );\\n};\\n\\n/* AVL class definition */\\ntemplate \\nvoid AVLtree<T>::rebalance(AVLnode<T> *n) {\\n    setBalance(n);\\n\\n    if (n->balance == -2) {\\n        if (height(n->left->left) >= height(n->left->right))\\n            n = rotateRight(n);\\n        else\\n            n = rotateLeftThenRight(n);\\n    }\\n    else if (n->balance == 2) {\\n        if (height(n->right->right) >= height(n->right->left))\\n            n = rotateLeft(n);\\n        else\\n            n = rotateRightThenLeft(n);\\n    }\\n\\n    if (n->parent != NULL) {\\n        rebalance(n->parent);\\n    }\\n    else {\\n        root = n;\\n    }\\n}\\n\\ntemplate \\nAVLnode<T>* AVLtree<T>::rotateLeft(AVLnode<T> *a) {\\n    AVLnode<T> *b = a->right;\\n    b->parent = a->parent;\\n    a->right = b->left;\\n\\n    if (a->right != NULL)\\n        a->right->parent = a;\\n\\n    b->left = a;\\n    a->parent = b;\\n\\n    if (b->parent != NULL) {\\n        if (b->parent->right == a) {\\n            b->parent->right = b;\\n        }\\n        else {\\n            b->parent->left = b;\\n        }\\n    }\\n\\n    setBalance(a);\\n    setBalance(b);\\n    return b;\\n}\\n\\ntemplate \\nAVLnode<T>* AVLtree<T>::rotateRight(AVLnode<T> *a) {\\n    AVLnode<T> *b = a->left;\\n    b->parent = a->parent;\\n    a->left = b->right;\\n\\n    if (a->left != NULL)\\n        a->left->parent = a;\\n\\n    b->right = a;\\n    a->parent = b;\\n\\n    if (b->parent != NULL) {\\n        if (b->parent->right == a) {\\n            b->parent->right = b;\\n        }\\n        else {\\n            b->parent->left = b;\\n        }\\n    }\\n\\n    setBalance(a);\\n    setBalance(b);\\n    return b;\\n}\\n\\ntemplate \\nAVLnode<T>* AVLtree<T>::rotateLeftThenRight(AVLnode<T> *n) {\\n    n->left = rotateLeft(n->left);\\n    return rotateRight(n);\\n}\\n\\ntemplate \\nAVLnode<T>* AVLtree<T>::rotateRightThenLeft(AVLnode<T> *n) {\\n    n->right = rotateRight(n->right);\\n    return rotateLeft(n);\\n}\\n\\ntemplate \\nint AVLtree<T>::height(AVLnode<T> *n) {\\n    if (n == NULL)\\n        return -1;\\n    return 1 + std::max(height(n->left), height(n->right));\\n}\\n\\ntemplate \\nvoid AVLtree<T>::setBalance(AVLnode<T> *n) {\\n    n->balance = height(n->right) - height(n->left);\\n}\\n\\ntemplate \\nvoid AVLtree<T>::printBalance(AVLnode<T> *n) {\\n    if (n != NULL) {\\n        printBalance(n->left);\\n        std::cout << n->balance << \"" \"";\\n        printBalance(n->right);\\n    }\\n}\\n\\ntemplate \\nAVLtree<T>::AVLtree(void) : root(NULL) {}\\n\\ntemplate \\nAVLtree<T>::~AVLtree(void) {\\n    delete root;\\n}\\n\\ntemplate \\nbool AVLtree<T>::insert(T key) {\\n    if (root == NULL) {\\n        root = new AVLnode<T>(key, NULL);\\n    }\\n    else {\\n        AVLnode<T>\\n            *n = root,\\n            *parent;\\n\\n        while (true) {\\n            if (n->key == key)\\n                return false;\\n\\n            parent = n;\\n\\n            bool goLeft = n->key > key;\\n            n = goLeft ? n->left : n->right;\\n\\n            if (n == NULL) {\\n                if (goLeft) {\\n                    parent->left = new AVLnode<T>(key, parent);\\n                }\\n                else {\\n                    parent->right = new AVLnode<T>(key, parent);\\n                }\\n\\n                rebalance(parent);\\n                break;\\n            }\\n        }\\n    }\\n\\n    return true;\\n}\\n\\ntemplate \\nvoid AVLtree<T>::deleteKey(const T delKey) {\\n    if (root == NULL)\\n        return;\\n\\n    AVLnode<T>\\n        *n       = root,\\n        *parent  = root,\\n        *delNode = NULL,\\n        *child   = root;\\n\\n    while (child != NULL) {\\n        parent = n;\\n        n = child;\\n        child = delKey >= n->key ? n->right : n->left;\\n        if (delKey == n->key)\\n            delNode = n;\\n    }\\n\\n    if (delNode != NULL) {\\n        delNode->key = n->key;\\n\\n        child = n->left != NULL ? n->left : n->right;\\n\\n        if (root->key == delKey) {\\n            root = child;\\n        }\\n        else {\\n            if (parent->left == n) {\\n                parent->left = child;\\n            }\\n            else {\\n                parent->right = child;\\n            }\\n\\n            rebalance(parent);\\n        }\\n    }\\n}\\n\\ntemplate \\nvoid AVLtree<T>::printBalance() {\\n    printBalance(root);\\n    std::cout << std::endl;\\n}\\n\\nint main(void)\\n{\\n    AVLtree<int> t;\\n\\n    std::cout << \""Inserting integer values 1 to 10\"" << std::endl;\\n    for (int i = 1; i <= 10; ++i)\\n        t.insert(i);\\n\\n    std::cout << \""Printing balance: \"";\\n    t.printBalance();\\n}\\n"
"C++","Babbage_problem","Charles Babbage, looking ahead to the sorts of problems his Analytical Engine would be able to solve, gave this example:\\nHe thought the answer might be 99,736, whose square is 9,947,269,696; but he couldn't be certain.\\n\\nThe task is to find out if Babbage had the right answer — and to do so, as far as your language allows it, in code that Babbage himself would have been able to read and understand.\\nAs Babbage evidently solved the task with pencil and paper, a similar efficient solution is preferred.\\nFor these purposes, Charles Babbage may be taken to be an intelligent person, familiar with mathematics and with the idea of a computer; he has written the first drafts of simple computer programmes in tabular form. [Babbage Archive Series L].\\n\\nThe aim of the task is to write a program that is sufficiently clear and well-documented for such a person to be able to read it and be confident that it does indeed solve the specified problem.\\n\\nAn assembler program always seems a bit tricky for non system engineer because it deals directly with the operating system and with the hardware instructions. Here we have a 32-bit computer with 16 32-bit registers. The caller (the operating system to keep it simple) is calling you giving your location address stored in register-15 and has stored in register-14 his return address. To save each program context, register-13 points to a 18 word save area. Do not spend time in understanding the context saving and restoring in the prologue and epilogue part of the program. What you have to know, “360” architecture uses 32-bit signed binary arithmetic, so here the maximum integer value is 2^31-1 (2147483647). Therefore the solution must be less than 2147483647. The multiplication and the division use a pair of registers; coding “MR 4,2” means multiply register-5 by register-2 and place result in the (register-4,register-5) pair; the same way “DR 4,2” means divide the (register-4,register-5) pair by register-2 and place the quotient in register-5 and the reminder in register-4. We use in the below program this intermediate 64-bit integers to find a solution with a value up to 2^31-1 even when we have to compute the square of this value.\\n","#include <iostream>\\n\\nint main( ) {\\n   int current = 0 ;\\n   while ( ( current * current ) % 1000000 != 269696 ) \\n      current++ ;\\n   std::cout << \""The square of \"" << current << \"" is \"" << (current * current) << \"" !\\n\"" ;\\n   return 0 ;\\n}"
"C++","Bacon_cipher","This task is to implement a program for encryption and decryption of plaintext using the simple alphabet of the Baconian cipher or some other kind of representation of this alphabet (make anything signify anything).\\nThe Baconian alphabet:\\n\\nTested with Agena 2.9.5 Win32\\n","\\n#include <iostream>\\n#include <algorithm>\\n#include <vector>\\n#include <bitset>\\n#include <string>\\n\\nclass bacon {\\npublic:\\n    bacon() {\\n        int x = 0;\\n        for( ; x < 9; x++ )\\n            bAlphabet.push_back( std::bitset<5>( x ).to_string() );\\n        bAlphabet.push_back( bAlphabet.back() );\\n        \\n        for( ; x < 20; x++ )\\n            bAlphabet.push_back( std::bitset<5>( x ).to_string() );\\n        bAlphabet.push_back( bAlphabet.back() );\\n        \\n        for( ; x < 24; x++ )\\n            bAlphabet.push_back( std::bitset<5>( x ).to_string() );\\n    }\\n\\n    std::string encode( std::string txt ) {\\n        std::string r;\\n        size_t z;\\n        for( std::string::iterator i = txt.begin(); i != txt.end(); i++ ) {\\n            z = toupper( *i );\\n            if( z < 'A' || z > 'Z' ) continue;\\n            r.append( bAlphabet.at( ( *i & 31 ) - 1 ) );\\n        }\\n        return r;\\n    }\\n\\n    std::string decode( std::string txt ) {\\n        size_t len = txt.length();\\n        while( len % 5 != 0 ) len--;\\n        if( len != txt.length() ) txt = txt.substr( 0, len );\\n        std::string r;\\n        for( size_t i = 0; i < len; i += 5 ) {\\n            r.append( 1, 'A' + std::distance( bAlphabet.begin(), std::find( bAlphabet.begin(), bAlphabet.end(), txt.substr( i, 5 ) ) ) );\\n        }\\n        return r;\\n    }\\n\\nprivate:\\n    std::vector bAlphabet;\\n};\\n"
"C++","Bacon_cipher","This task is to implement a program for encryption and decryption of plaintext using the simple alphabet of the Baconian cipher or some other kind of representation of this alphabet (make anything signify anything).\\nThe Baconian alphabet:\\n\\nTested with Agena 2.9.5 Win32\\n","\\nclass cipherI {\\npublic:\\n    std::string encode( std::string txt ) {\\n        txt = b.encode( txt );\\n        std::string e, d = \""one morning, when gregor samsa woke from troubled dreams, he found himself transformed \""\\n        \""in his bed into a horrible vermin. he lay on his armour-like back, and if he lifted his head a little he \""\\n        \""could see his brown belly, slightly domed and divided by arches into stiff sections.\"";\\n        size_t r = 0; \\n        char t;\\n        for( std::string::iterator i = txt.begin(); i != txt.end(); i++ ) {\\n            t = d.at( r );\\n            while( t < 'a' || t > 'z' ) {\\n                e.append( 1, t );\\n                r++;\\n                t = d.at( r );\\n            }\\n            r++;\\n            e.append( 1, *i == '1' ? t - 32 : t );\\n        }\\n\\n        return e;\\n    }\\n\\n    std::string decode( std::string txt ) {\\n        std::string h;\\n        for( std::string::iterator i = txt.begin(); i != txt.end(); i++ ) {\\n            if( *i < 'a' && ( *i < 'A' || *i > 'Z' ) || *i > 'z' ) continue;\\n            h.append( 1, *i & 32 ? '0' : '1' );\\n        }\\n        return b.decode( h );\\n    }\\n\\nprivate:\\n    bacon b;\\n};\\n\\nclass cipherII {\\npublic:\\n    std::string encode( std::string txt ) {\\n        txt = b.encode( txt );\\n        std::string e;\\n        for( std::string::iterator i = txt.begin(); i != txt.end(); i++ )\\n            e.append( 1, *i == '0' ? 0xf9 : 0xfa );\\n        return e;\\n    }\\n\\n    std::string decode( std::string txt ) {\\n        std::string h;\\n        for( std::string::iterator i = txt.begin(); i != txt.end(); i++ ) {\\n            h.append( 1, *i == ( char )0xf9 ? '0' : '1' );\\n        }\\n        return b.decode( h );\\n    }\\n\\nprivate:\\n    bacon b;\\n};\\n\\nint main( int argc, char* argv[] ) {\\n    cipherI c1;\\n    cipherII c2;\\n    std::string s = \""lets have some fun with bacon cipher\"";\\n\\n    std::string h1 = c1.encode( s ),\\n                h2 = c2.encode( s );\\n\\n    std::cout << h1 << std::endl << std::endl << c1.decode( h1 ) << std::endl << std::endl;\\n    std::cout << h2 << std::endl << std::endl << c2.decode( h2 ) << std::endl << std::endl;\\n\\n    return 0;\\n}\\n"
"C++","Balanced_brackets","Task:\\n\\n\\n","#include <algorithm>\\n#include <iostream>\\n#include <string>\\n\\nstd::string generate(int n, char left = '[', char right = ']')\\n{\\n    std::string str(std::string(n, left) + std::string(n, right));\\n    std::random_shuffle(str.begin(), str.end());\\n    return str;\\n}\\n\\nbool balanced(const std::string &str, char left = '[', char right = ']')\\n{\\n    int count = 0;\\n    for (std::string::const_iterator it = str.begin(); it != str.end(); ++it)\\n    {\\n        if (*it == left)\\n            count++;\\n        else if (*it == right)\\n            if (--count < 0) return false;\\n    }\\n    return count == 0;\\n}\\n\\nint main()\\n{\\n    srand(time(NULL)); // seed rng\\n    for (int i = 0; i < 9; ++i)\\n    {\\n        std::string s(generate(i));\\n        std::cout << (balanced(s) ? \"" ok: \"" : \""bad: \"") << s << \""\\n\"";\\n    }\\n}"
"C++","Balanced_ternary","Balanced ternary is a way of representing numbers. Unlike the prevailing binary representation, a balanced ternary integer is in base 3, and each digit can have the values 1, 0, or −1.\\n\\nDecimal 11 = 32 + 31 − 30, thus it can be written as \""++−\""\\nDecimal 6 = 32 − 31 + 0 × 30, thus it can be written as \""+−0\""\\n\\nImplement balanced ternary representation of integers with the following:\\n\\nTest case With balanced ternaries a from string \""+-0++0+\"", b from native integer -436, c \""+-++-\"":\\n\\nNote: The pages generalised floating point addition and generalised floating point multiplication have code implementing arbitrary precision floating point balanced ternary.\\n\\nSee also:\\nSpecifications (bt.ads):\\nImplementation (bt.adb):\\nTest task requirements (testbt.adb):\\nOutput:\\nOutput:\\nOutput\\noutput:\\n","\\n#include <iostream>\\n#include <string>\\n#include <climits>\\nusing namespace std;\\n\\nclass BalancedTernary {\\nprotected:\\n	// Store the value as a reversed string of +, 0 and - characters\\n	string value;\\n\\n	// Helper function to change a balanced ternary character to an integer\\n	int charToInt(char c) const {\\n		if (c == '0')\\n			return 0;\\n		return 44 - c;\\n	}\\n\\n	// Helper function to negate a string of ternary characters\\n	string negate(string s) const {\\n		for (int i = 0; i < s.length(); ++i) {\\n			if (s[i] == '+')\\n				s[i] = '-';\\n			else if (s[i] == '-')\\n				s[i] = '+';\\n		}\\n		return s;\\n	}\\n\\npublic:\\n	// Default constructor\\n	BalancedTernary() {\\n		value = \""0\"";\\n	}\\n\\n	// Construct from a string\\n	BalancedTernary(string s) {\\n		value = string(s.rbegin(), s.rend());\\n	}\\n\\n	// Construct from an integer\\n	BalancedTernary(long long n) {\\n		if (n == 0) {\\n			value = \""0\"";\\n			return;\\n		}\\n\\n		bool neg = n < 0;\\n		if (neg) \\n			n = -n;\\n\\n		value = \""\"";\\n		while (n != 0) {\\n			int r = n % 3;\\n			if (r == 0)\\n				value += \""0\"";\\n			else if (r == 1)\\n				value += \""+\"";\\n			else {\\n				value += \""-\"";\\n				++n;\\n			}\\n\\n			n /= 3;\\n		}\\n\\n		if (neg)\\n			value = negate(value);\\n	}\\n\\n	// Copy constructor\\n	BalancedTernary(const BalancedTernary &n) {\\n		value = n.value;\\n	}\\n\\n	// Addition operators\\n	BalancedTernary operator+(BalancedTernary n) const {\\n		n += *this;\\n		return n;\\n	}\\n\\n	BalancedTernary& operator+=(const BalancedTernary &n) {\\n		static char *add = \""0+-0+-0\"";\\n		static char *carry = \""--000++\"";\\n\\n		int lastNonZero = 0;\\n		char c = '0';\\n		for (int i = 0; i < value.length() || i < n.value.length(); ++i) {\\n			char a = i < value.length() ? value[i] : '0';\\n			char b = i < n.value.length() ? n.value[i] : '0';\\n\\n			int sum = charToInt(a) + charToInt(b) + charToInt(c) + 3;\\n			c = carry[sum];\\n\\n			if (i < value.length())\\n				value[i] = add[sum];\\n			else\\n				value += add[sum];\\n\\n			if (add[sum] != '0')\\n				lastNonZero = i;\\n		}\\n\\n		if (c != '0')\\n			value += c;\\n		else\\n			value = value.substr(0, lastNonZero + 1); // Chop off leading zeroes\\n\\n		return *this;\\n	}\\n\\n	// Negation operator\\n	BalancedTernary operator-() const {\\n		BalancedTernary result;\\n		result.value = negate(value);\\n		return result;\\n	}\\n\\n	// Subtraction operators\\n	BalancedTernary operator-(const BalancedTernary &n) const {\\n		return operator+(-n);\\n	}\\n\\n	BalancedTernary& operator-=(const BalancedTernary &n) {\\n		return operator+=(-n);\\n	}\\n\\n	// Multiplication operators\\n	BalancedTernary operator*(BalancedTernary n) const {\\n		n *= *this;\\n		return n;\\n	}\\n\\n	BalancedTernary& operator*=(const BalancedTernary &n) {\\n		BalancedTernary pos = *this;\\n		BalancedTernary neg = -pos; // Storing an extra copy to avoid negating repeatedly\\n		value = \""0\"";\\n\\n		for (int i = 0; i < n.value.length(); ++i) {\\n			if (n.value[i] == '+')\\n				operator+=(pos);\\n			else if (n.value[i] == '-')\\n				operator+=(neg);\\n			pos.value = '0' + pos.value;\\n			neg.value = '0' + neg.value;\\n		}\\n\\n		return *this;\\n	}\\n\\n	// Stream output operator\\n	friend ostream& operator<<(ostream &out, const BalancedTernary &n) {\\n		out << n.toString();\\n		return out;\\n	}\\n\\n	// Convert to string\\n	string toString() const {\\n		return string(value.rbegin(), value.rend());\\n	}\\n\\n	// Convert to integer\\n	long long toInt() const {\\n		long long result = 0;\\n		for (long long i = 0, pow = 1; i < value.length(); ++i, pow *= 3)\\n			result += pow * charToInt(value[i]);\\n		return result;\\n	}\\n\\n	// Convert to integer if possible\\n	bool tryInt(long long &out) const {\\n		long long result = 0;\\n		bool ok = true;\\n\\n		for (long long i = 0, pow = 1; i < value.length() && ok; ++i, pow *= 3) {\\n			if (value[i] == '+') {\\n				ok &= LLONG_MAX - pow >= result; // Clear ok if the result overflows\\n				result += pow;\\n			} else if (value[i] == '-') {\\n				ok &= LLONG_MIN + pow <= result; // Clear ok if the result overflows\\n				result -= pow;\\n			}\\n		}\\n\\n		if (ok)\\n			out = result;\\n		return ok;\\n	}\\n};\\n\\nint main() {\\n	BalancedTernary a(\""+-0++0+\"");\\n	BalancedTernary b(-436);\\n	BalancedTernary c(\""+-++-\"");\\n\\n	cout << \""a = \"" << a << \"" = \"" << a.toInt() << endl;\\n	cout << \""b = \"" << b << \"" = \"" << b.toInt() << endl;\\n	cout << \""c = \"" << c << \"" = \"" << c.toInt() << endl;\\n\\n	BalancedTernary d = a * (b - c);\\n\\n	cout << \""a * (b - c) = \"" << d << \"" = \"" << d.toInt() << endl;\\n\\n	BalancedTernary e(\""+++++++++++++++++++++++++++++++++++++++++\"");\\n\\n	long long n;\\n	if (e.tryInt(n))\\n		cout << \""e = \"" << e << \"" = \"" << n << endl;\\n	else\\n		cout << \""e = \"" << e << \"" is too big to fit in a long long\"" << endl;\\n\\n	return 0;\\n}\\n"
"C++","Base64_encode_data","Convert an array of bytes or binary string to the base64-encoding of that string and output that value. Use the icon for Rosetta Code as the data to convert.\\n","\\n#include <iostream>\\n#include <fstream>\\n#include <vector>\\n\\ntypedef unsigned char byte;\\nusing namespace std;\\n\\nconst unsigned m1 = 63 << 18, m2 = 63 << 12, m3 = 63 << 6;\\n\\nclass base64\\n{\\npublic:\\n    base64() { char_set = \""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\""; }\\n    string encode( vector<byte> v )\\n    {\\n	string res;\\n	unsigned d, a = 0, l = static_cast<unsigned>( v.size() );\\n	while( l > 2 )\\n	{\\n	    d = v[a++] << 16 | v[a++] << 8 | v[a++];	\\n	    res.append( 1, char_set.at( ( d & m1 ) >> 18 ) );	\\n	    res.append( 1, char_set.at( ( d & m2 ) >> 12 ) );	\\n	    res.append( 1, char_set.at( ( d & m3 ) >>  6 ) );\\n	    res.append( 1, char_set.at( d & 63 ) );\\n	    l -= 3;\\n	}\\n	if( l == 2 )\\n	{\\n	    d = v[a++] << 16 | v[a++] << 8;\\n	    res.append( 1, char_set.at( ( d & m1 ) >> 18 ) );	\\n	    res.append( 1, char_set.at( ( d & m2 ) >> 12 ) );	\\n	    res.append( 1, char_set.at( ( d & m3 ) >>  6 ) );\\n	    res.append( 1, '=' );\\n	}\\n	else if( l == 1 )\\n	{\\n	    d = v[a++] << 16;\\n	    res.append( 1, char_set.at( ( d & m1 ) >> 18 ) );	\\n	    res.append( 1, char_set.at( ( d & m2 ) >> 12 ) );	\\n	    res.append( \""==\"", 2 );\\n	}\\n	return res;\\n    }\\n\\nprivate:\\n    string char_set;\\n};\\n\\nint main( int argc, char* argv[] )\\n{\\n    base64 b;\\n    basic_ifstream<byte> f( \""favicon.ico\"", ios::binary );\\n    string r = b.encode( vector<byte>( ( istreambuf_iterator<byte>( f ) ), istreambuf_iterator<byte>() ) );\\n    copy( r.begin(), r.end(), ostream_iterator<char>( cout ) );\\n    return 0;\\n}\\n"
"C++","Benford's_law","\\nBenford's law, also called the first-digit law, refers to the frequency distribution of digits in many (but not all) real-life sources of data.\\nIn this distribution, the number 1 occurs as the first digit about 30% of the time, while larger numbers occur in that position less frequently: 9 as the first digit less than 5% of the time. This distribution of first digits is the same as the widths of gridlines on a logarithmic scale.\\nBenford's law also concerns the expected distribution for digits beyond the first, which approach a uniform distribution.\\nThis result has been found to apply to a wide variety of data sets, including electricity bills, street addresses, stock prices, population numbers, death rates, lengths of rivers, physical and mathematical constants, and processes described by power laws (which are very common in nature). It tends to be most accurate when values are distributed across multiple orders of magnitude.\\nA set of numbers is said to satisfy Benford's law if the leading digit \\n\\n\\n\\nd\\n\\n\\n{\\displaystyle d}\\n\\n  (\\n\\n\\n\\nd\\n∈\\n{\\n1\\n,\\n…\\n,\\n9\\n}\\n\\n\\n{\\displaystyle d\\in \\{1,\\ldots ,9\\}}\\n\\n) occurs with probability\\nFor this task, write (a) routine(s) to calculate the distribution of first significant (non-zero) digits in a collection of numbers, then display the actual vs. expected distribution in the way most convenient for your language (table / graph / histogram / whatever).\\nUse the first 1000 numbers from the Fibonacci sequence as your data set. No need to show how the Fibonacci numbers are obtained.\\nYou can generate them or load them from a file; whichever is easiest.\\nDisplay your actual vs expected distribution.\\n\\nFor extra credit: Show the distribution for one other set of numbers from a page on Wikipedia. State which Wikipedia page it can be obtained from and what the set enumerates. Again, no need to display the actual list of numbers or the code to load them.\\n\\n\\n","//to cope with the big numbers , I used the Class Library for Numbers( CLN ) \\n//if used prepackaged you can compile writing \""g++ -std=c++11 -lcln yourprogram.cpp -o yourprogram\""\\n#include \\n#include \\n#include <iostream>\\n#include <algorithm>\\n#include <vector>\\n#include <iomanip>\\n#include <sstream>\\n#include <string>\\n#include <cstdlib>\\n#include <cmath>\\n#include <map>\\nusing namespace cln ;\\n\\nclass NextNum {\\npublic :\\n   NextNum ( cl_I & a , cl_I & b ) : first( a ) , second ( b ) { }\\n   cl_I operator( )( ) {\\n      cl_I result = first + second ;\\n      first = second ;\\n      second = result ;\\n      return result ;\\n   }\\nprivate :\\n   cl_I first ;\\n   cl_I second ;\\n} ;\\n\\nvoid findFrequencies( const std::vector & fibos , std::map &numberfrequencies  ) {\\n   for ( cl_I bignumber : fibos ) {\\n      std::ostringstream os ;\\n      fprintdecimal ( os , bignumber ) ;//from header file cln/integer_io.h\\n      int firstdigit = std::atoi( os.str( ).substr( 0 , 1 ).c_str( )) ;\\n      auto result = numberfrequencies.insert( std::make_pair( firstdigit , 1 ) ) ;\\n      if ( ! result.second ) \\n	 numberfrequencies[ firstdigit ]++ ;\\n   }\\n}\\n\\nint main( ) {\\n   std::vector fibonaccis( 1000 ) ;\\n   fibonaccis[ 0 ] = 0 ;\\n   fibonaccis[ 1 ] = 1 ;\\n   cl_I a = 0 ;\\n   cl_I b = 1 ;\\n   //since a and b are passed as references to the generator's constructor\\n   //they are constantly changed !\\n   std::generate_n( fibonaccis.begin( ) + 2 , 998 , NextNum( a , b ) ) ;\\n   std::cout << std::endl ;\\n   std::map frequencies ;\\n   findFrequencies( fibonaccis , frequencies ) ;\\n   std::cout << \""                found                    expected\\n\"" ;\\n   for ( int i = 1 ; i < 10 ; i++ ) {\\n      double found = static_cast<double>( frequencies[ i ] ) / 1000 ;\\n      double expected = std::log10( 1 + 1 / static_cast<double>( i )) ;\\n      std::cout << i << \"" :\"" << std::setw( 16 ) << std::right << found * 100 << \"" %\"" ;\\n      std::cout.precision( 3 ) ;\\n      std::cout << std::setw( 26 ) << std::right << expected * 100 << \"" %\\n\"" ;\\n   }\\n   return 0 ;\\n}\\n"
"C++","Bernoulli_numbers","Bernoulli numbers are used in some series expansions of several functions   (trigonometric, hyperbolic, gamma, etc.),   and are extremely important in number theory and analysis.\\nNote that there are two definitions of Bernoulli numbers;   this task will be using the modern usage   (as per   The National Institute of Standards and Technology convention).\\nThe   nth   Bernoulli number is expressed as   Bn.\\n\\n\\nThe Akiyama–Tanigawa algorithm for the \""second Bernoulli numbers\"" as taken from wikipedia is as follows:\\n\\nUses Algol 68G's LONG LONG INT which has allows for large numbers of digits.\\n","\\n\\n/**\\n * Configured with: --prefix=/Library/Developer/CommandLineTools/usr --with-gxx-include-dir=/usr/include/c++/4.2.1\\n * Apple LLVM version 9.1.0 (clang-902.0.39.1)\\n * Target: x86_64-apple-darwin17.5.0\\n * Thread model: posix\\n*/\\n\\n#include <iostream> //std::cout\\n#include <iostream> //formatting\\n#include <vector> //Container\\n#include  // Rationals\\n#include  //1024bit precision\\n\\n\\ntypedef boost::rational rational; // reduce boilerplate\\n\\nrational bernulli(size_t n){\\n\\n     auto out = std::vector<rational>();\\n\\n     for(size_t m=0;m<=n;m++){\\n         out.emplace_back(1,(m+1)); // automatically constructs object\\n         for (size_t j = m;j>=1;j--){\\n             out[j-1] = rational(j) * (out[j-1]-out[j]);\\n         }\\n     }\\n     return out[0];\\n }\\n\\nint main() {\\n    for(size_t n = 0; n <= 60;n+=n>=2?2:1){\\n        auto b = bernulli(n);\\n        std::cout << \""B(\""<\\n{{out}}\\n<pre>\\nB( 0) =                                            1 / 1\\nB( 1) =                                            1 / 2\\nB( 2) =                                            1 / 6\\nB( 4) =                                           -1 / 30\\nB( 6) =                                            1 / 42\\nB( 8) =                                           -1 / 30\\nB(10) =                                            5 / 66\\nB(12) =                                         -691 / 2730\\nB(14) =                                            7 / 6\\nB(16) =                                        -3617 / 510\\nB(18) =                                        43867 / 798\\nB(20) =                                      -174611 / 330\\nB(22) =                                       854513 / 138\\nB(24) =                                   -236364091 / 2730\\nB(26) =                                      8553103 / 6\\nB(28) =                                 -23749461029 / 870\\nB(30) =                                8615841276005 / 14322\\nB(32) =                               -7709321041217 / 510\\nB(34) =                                2577687858367 / 6\\nB(36) =                        -26315271553053477373 / 1919190\\nB(38) =                             2929993913841559 / 6\\nB(40) =                       -261082718496449122051 / 13530\\nB(42) =                       1520097643918070802691 / 1806\\nB(44) =                     -27833269579301024235023 / 690\\nB(46) =                     596451111593912163277961 / 282\\nB(48) =                -5609403368997817686249127547 / 46410\\nB(50) =                  495057205241079648212477525 / 66\\nB(52) =              -801165718135489957347924991853 / 1590\\nB(54) =             29149963634884862421418123812691 / 798\\nB(56) =          -2479392929313226753685415739663229 / 870\\nB(58) =          84483613348880041862046775994036021 / 354\\nB(60) = -1215233140483755572040304994079820246041491 / 56786730\\n"
"C++","Binary_digits","Create and display the sequence of binary digits for a given   non-negative integer.\\nThe results can be achieved using built-in radix functions within the language   (if these are available),   or alternatively a user defined function can be used.\\nThe output produced should consist just of the binary digits of each number followed by a   newline.\\nThere should be no other whitespace, radix or sign markers in the produced output, and leading zeros should not appear in the results.\\n\\n","#include <bitset>\\n#include <iostream>\\n#include <limits>\\n#include <string>\\n \\nvoid print_bin(unsigned int n) {\\n  std::string str = \""0\"";\\n\\n  if (n > 0) {\\n    str = std::bitset::digits>(n).to_string();\\n    str = str.substr(str.find('1')); // remove leading zeros\\n  } \\n  \\n  std::cout << str << '\\n';\\n}\\n\\nint main() {\\n  print_bin(0);\\n  print_bin(5);\\n  print_bin(50);\\n  print_bin(9000);\\n} \\n"
"C++","Binary_digits","Create and display the sequence of binary digits for a given   non-negative integer.\\nThe results can be achieved using built-in radix functions within the language   (if these are available),   or alternatively a user defined function can be used.\\nThe output produced should consist just of the binary digits of each number followed by a   newline.\\nThere should be no other whitespace, radix or sign markers in the produced output, and leading zeros should not appear in the results.\\n\\n","#include <iostream>\\n#include <bitset>\\nvoid printBits(int n) {                     // Use int like most programming languages. \\n  int iExp = 0;                             // Bit-length\\n  while (n >> iExp) ++iExp;                 // Could use template   \\n  for (int at = iExp - 1; at >= 0; at--)    // Reverse iter from the bit-length to 0 - msb is at end\\n    std::cout << std::bitset<32>(n)[at];    // Show 1's, show lsb, hide leading zeros\\n  std::cout << '\\n';\\n}\\nint main(int argc, char* argv[]) {\\n  printBits(5);\\n  printBits(50);\\n  printBits(9000);\\n} // for testing with n=0 printBits<32>(0);"
"C++","Binary_digits","Create and display the sequence of binary digits for a given   non-negative integer.\\nThe results can be achieved using built-in radix functions within the language   (if these are available),   or alternatively a user defined function can be used.\\nThe output produced should consist just of the binary digits of each number followed by a   newline.\\nThere should be no other whitespace, radix or sign markers in the produced output, and leading zeros should not appear in the results.\\n\\n","#include <iostream>\\nint main(int argc, char* argv[]) {\\n  unsigned int in[] = {5, 50, 9000};        // Use int like most programming languages\\n  for (int i = 0; i < 3; i++)               // Use all inputs\\n    for (int at = 31; at >= 0; at--)        // reverse iteration from the max bit-length to 0, because msb is at the end\\n      if (int b = (in[i] >> at))            // skip leading zeros. Start output when significant bits are set\\n         std::cout << ('0' + b & 1) << (!at ? \""\\n\"": \""\"");	// '0' or '1'. Add EOL if last bit of num\\n}\\n"
"C++","Binary_digits","Create and display the sequence of binary digits for a given   non-negative integer.\\nThe results can be achieved using built-in radix functions within the language   (if these are available),   or alternatively a user defined function can be used.\\nThe output produced should consist just of the binary digits of each number followed by a   newline.\\nThere should be no other whitespace, radix or sign markers in the produced output, and leading zeros should not appear in the results.\\n\\n","#include <iostream>\\nint main(int argc, char* argv[]) {                        // Usage: program.exe 5 50 9000\\n  for (int i = 1; i < argc; i++)                          // argv[0] is program name\\n    for (int at = 31; at >= 0; at--)                      // reverse iteration from the max bit-length to 0, because msb is at the end\\n      if (int b = (atoi(argv[i]) >> at))                  // skip leading zeros\\n         std::cout << ('0' + b & 1) << (!at ? \""\\n\"": \""\"");  // '0' or '1'. Add EOL if last bit of num\\n}\\n"
"C++","Binary_digits","Create and display the sequence of binary digits for a given   non-negative integer.\\nThe results can be achieved using built-in radix functions within the language   (if these are available),   or alternatively a user defined function can be used.\\nThe output produced should consist just of the binary digits of each number followed by a   newline.\\nThere should be no other whitespace, radix or sign markers in the produced output, and leading zeros should not appear in the results.\\n\\n","\\n#include <iostream>\\n\\nstd::string binary(int n) {\\n  return n == 0 ? \""\"" : binary(n >> 1) + std::to_string(n & 1);\\n}\\n\\nint main(int argc, char* argv[]) {\\n  for (int i = 1; i < argc; ++i) {\\n    std::cout << binary(std::stoi(argv[i])) << std::endl;\\n  }\\n}\\n"
"C++","Binary_search","A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a \""divide and conquer\"" algorithm.\\nAs an analogy, consider the children's game \""guess a number.\"" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.\\nAs the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.\\n\\nGiven the starting point of a range, the ending point of a range, and the \""secret value\"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.\\nThere are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.\\nAll of the following code examples use an \""inclusive\"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using \""exclusive\"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):\\nThe algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the \""insertion point\"" for it (the index that the value would have if it were inserted into the array).\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nMake sure it does not have overflow bugs.\\nThe line in the pseudo-code above to calculate the mean of two integers:\\ncould produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.\\nOne way to fix it is to manually add half the range to the low number:\\nEven though this is mathematically equivalent to the above, it is not susceptible to overflow.\\nAnother way for signed integers, possibly faster, is the following:\\nwhere  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.\\n\\n\\n\\n","\\ntemplate  int binsearch(const T array[], int low, int high, T value) {\\n    if (high < low) {\\n        return -1;\\n    }\\n    auto mid = (low + high) / 2;\\n    if (value < array[mid]) {\\n        return binsearch(array, low, mid - 1, value);\\n    } else if (value > array[mid]) {\\n        return binsearch(array, mid + 1, high, value);\\n    }\\n    return mid;\\n}\\n\\n#include <iostream>\\nint main()\\n{\\n  int array[] = {2, 3, 5, 6, 8};\\n  int result1 = binsearch(array, 0, sizeof(array)/sizeof(int), 4),\\n      result2 = binsearch(array, 0, sizeof(array)/sizeof(int), 8);\\n  if (result1 == -1) std::cout << \""4 not found!\"" << std::endl;\\n  else std::cout << \""4 found at \"" << result1 << std::endl;\\n  if (result2 == -1) std::cout << \""8 not found!\"" << std::endl;\\n  else std::cout << \""8 found at \"" << result2 << std::endl;\\n\\n  return 0;\\n}"
"C++","Binary_search","A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a \""divide and conquer\"" algorithm.\\nAs an analogy, consider the children's game \""guess a number.\"" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.\\nAs the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.\\n\\nGiven the starting point of a range, the ending point of a range, and the \""secret value\"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.\\nThere are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.\\nAll of the following code examples use an \""inclusive\"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using \""exclusive\"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):\\nThe algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the \""insertion point\"" for it (the index that the value would have if it were inserted into the array).\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nMake sure it does not have overflow bugs.\\nThe line in the pseudo-code above to calculate the mean of two integers:\\ncould produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.\\nOne way to fix it is to manually add half the range to the low number:\\nEven though this is mathematically equivalent to the above, it is not susceptible to overflow.\\nAnother way for signed integers, possibly faster, is the following:\\nwhere  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.\\n\\n\\n\\n","template \\nint binSearch(const T arr[], int len, T what) {\\n  int low = 0;\\n  int high = len - 1;\\n  while (low <= high) {\\n    int mid = (low + high) / 2;\\n    if (arr[mid] > what)\\n      high = mid - 1;\\n    else if (arr[mid] < what)\\n      low = mid + 1;\\n    else\\n      return mid;\\n  }\\n  return -1; // indicate not found \\n}"
"C++","Binary_search","A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a \""divide and conquer\"" algorithm.\\nAs an analogy, consider the children's game \""guess a number.\"" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.\\nAs the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.\\n\\nGiven the starting point of a range, the ending point of a range, and the \""secret value\"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.\\nThere are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.\\nAll of the following code examples use an \""inclusive\"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using \""exclusive\"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):\\nThe algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the \""insertion point\"" for it (the index that the value would have if it were inserted into the array).\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nMake sure it does not have overflow bugs.\\nThe line in the pseudo-code above to calculate the mean of two integers:\\ncould produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.\\nOne way to fix it is to manually add half the range to the low number:\\nEven though this is mathematically equivalent to the above, it is not susceptible to overflow.\\nAnother way for signed integers, possibly faster, is the following:\\nwhere  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.\\n\\n\\n\\n","#include <algorithm>"
"C++","Binary_search","A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a \""divide and conquer\"" algorithm.\\nAs an analogy, consider the children's game \""guess a number.\"" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.\\nAs the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.\\n\\nGiven the starting point of a range, the ending point of a range, and the \""secret value\"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.\\nThere are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.\\nAll of the following code examples use an \""inclusive\"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using \""exclusive\"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):\\nThe algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the \""insertion point\"" for it (the index that the value would have if it were inserted into the array).\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nMake sure it does not have overflow bugs.\\nThe line in the pseudo-code above to calculate the mean of two integers:\\ncould produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.\\nOne way to fix it is to manually add half the range to the low number:\\nEven though this is mathematically equivalent to the above, it is not susceptible to overflow.\\nAnother way for signed integers, possibly faster, is the following:\\nwhere  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.\\n\\n\\n\\n","int *ptr = std::lower_bound(array, array+len, what); // a custom comparator can be given as fourth arg"
"C++","Binary_search","A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a \""divide and conquer\"" algorithm.\\nAs an analogy, consider the children's game \""guess a number.\"" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.\\nAs the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.\\n\\nGiven the starting point of a range, the ending point of a range, and the \""secret value\"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.\\nThere are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.\\nAll of the following code examples use an \""inclusive\"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using \""exclusive\"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):\\nThe algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the \""insertion point\"" for it (the index that the value would have if it were inserted into the array).\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nMake sure it does not have overflow bugs.\\nThe line in the pseudo-code above to calculate the mean of two integers:\\ncould produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.\\nOne way to fix it is to manually add half the range to the low number:\\nEven though this is mathematically equivalent to the above, it is not susceptible to overflow.\\nAnother way for signed integers, possibly faster, is the following:\\nwhere  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.\\n\\n\\n\\n","int *ptr = std::upper_bound(array, array+len, what); // a custom comparator can be given as fourth arg"
"C++","Binary_search","A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a \""divide and conquer\"" algorithm.\\nAs an analogy, consider the children's game \""guess a number.\"" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.\\nAs the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.\\n\\nGiven the starting point of a range, the ending point of a range, and the \""secret value\"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.\\nThere are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.\\nAll of the following code examples use an \""inclusive\"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using \""exclusive\"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):\\nThe algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the \""insertion point\"" for it (the index that the value would have if it were inserted into the array).\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nMake sure it does not have overflow bugs.\\nThe line in the pseudo-code above to calculate the mean of two integers:\\ncould produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.\\nOne way to fix it is to manually add half the range to the low number:\\nEven though this is mathematically equivalent to the above, it is not susceptible to overflow.\\nAnother way for signed integers, possibly faster, is the following:\\nwhere  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.\\n\\n\\n\\n","std::pair bounds = std::equal_range(array, array+len, what); // a custom comparator can be given as fourth arg"
"C++","Binary_search","A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a \""divide and conquer\"" algorithm.\\nAs an analogy, consider the children's game \""guess a number.\"" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.\\nAs the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.\\n\\nGiven the starting point of a range, the ending point of a range, and the \""secret value\"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.\\nThere are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.\\nAll of the following code examples use an \""inclusive\"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using \""exclusive\"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):\\nThe algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the \""insertion point\"" for it (the index that the value would have if it were inserted into the array).\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nMake sure it does not have overflow bugs.\\nThe line in the pseudo-code above to calculate the mean of two integers:\\ncould produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.\\nOne way to fix it is to manually add half the range to the low number:\\nEven though this is mathematically equivalent to the above, it is not susceptible to overflow.\\nAnother way for signed integers, possibly faster, is the following:\\nwhere  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.\\n\\n\\n\\n","bool found = std::binary_search(array, array+len, what); // a custom comparator can be given as fourth arg"
"C++","Bitmap","Show a basic storage type to handle a simple RGB raster graphics image,\\nand some primitive associated functions.\\nIf possible provide a function to allocate an uninitialised image,\\ngiven its width and height, and provide 3 additional functions:\\n(If there are specificities about the storage or the allocation, explain those.)\\nThese functions are used as a base for the articles in the category raster graphics operations, \\nand a basic output function to check the results\\nis available in the article write ppm file.\\nActionScript 3 has a BitmapData class (in the flash.display package) which can be used for storage and handling of bitmap images.\\nTo display these images, the Bitmap class can be used.\\nThe package interface:\\nThe implementation of:\\nThis can be used like:\\nNote: short and shorten need to be tuned (added or removed)\\nto match the underlying graphic hardware colour depth.\\n","#include <iostream>\\n#include \\nint main()\\n{\\n    using namespace boost::gil;\\n    // create 30x40 image\\n    rgb8_image_t img(30, 40);\\n\\n    // fill with red\\n    rgb8_pixel_t red(255, 0, 0);\\n    fill_pixels(view(img), red);\\n\\n    // set pixel at 10x20 to blue\\n    rgb8_pixel_t blue(0, 0, 255);\\n    view(img)(10, 20) = blue;\\n\\n    // read the value of pixel at 11x20\\n    rgb8_pixel_t px = const_view(img)(11, 20);\\n    std::cout << \""the pixel at 11, 20 is \"" << (unsigned)px[0] << ':' << (unsigned)px[1] << ':' << (unsigned)px[2]  << '\\n';\\n}"
"C++","Bitmap/Bresenham's_line_algorithm","Using the data storage type defined on the Bitmap page for raster graphics images, draw a line given two points with Bresenham's line algorithm.\\n\\nThe test program's\\nsample output\\n16 bit Intel 8086\\80486 Assembly for dos, see x86 assembly language.\\nTo run this code you will need to use Dos emulator.\\n\\nInstead of swaps in the initialisation use error calculation for both directions x and y simultaneously:\\nPort of the C version.\\nThis code uses the Image defined in Bitmap Task.\\nTo run the demo code compile with -version=bitmap_bresenhams_line_algorithm_main.\\n","\\nvoid Line( const float x1, const float y1, const float x2, const float y2, const Color& color )\\n{\\n        // Bresenham's line algorithm\\n  const bool steep = (fabs(y2 - y1) > fabs(x2 - x1));\\n  if(steep)\\n  {\\n    std::swap(x1, y1);\\n    std::swap(x2, y2);\\n  }\\n\\n  if(x1 > x2)\\n  {\\n    std::swap(x1, x2);\\n    std::swap(y1, y2);\\n  }\\n\\n  const float dx = x2 - x1;\\n  const float dy = fabs(y2 - y1);\\n  \\n  float error = dx / 2.0f;\\n  const int ystep = (y1 < y2) ? 1 : -1;\\n  int y = (int)y1;\\n\\n  const int maxX = (int)x2;\\n\\n  for(int x=(int)x1; x\\n"
"C++","Bitmap/Flood_fill","Implement a flood fill.\\nA flood fill is a way of filling an area using color banks to define the contained area or a target color which \""determines\"" the area (the valley that can be flooded; Wikipedia uses the term target color). It works almost like a water flooding from a point towards the banks (or: inside the valley): if there's a hole in the banks, the flood is not contained and all the image (or all the \""connected valleys\"") get filled.\\nTo accomplish the task, you need to implement just one of the possible algorithms (examples are on Wikipedia). Variations on the theme are allowed (e.g. adding a tolerance parameter or argument for color-matching of the banks or target color).\\nTesting: the basic algorithm is not suitable for truecolor images; a possible test image is the one shown on the right box; you can try to fill the white area, or the black inner circle.\\n\\nThe procedure has the following parameters. Picture is the image to change. From is the point to start at. Fill is the color to fill with. Replace is the color to replace. Distance defines the range of color around Replace to replace as well. The distance is defined as a maximum of the differences of stimuli. The following code snippet reads the test file, fills the area between two circles red, and writes the result:\\nThis is limited to %StackSize% pixels.\\nBBC BASIC has a built-in flood fill statement, but to satisfy the terms of the task it is not used in this example.\\nThe sys/queue.h is not POSIX. (See FIFO)\\nThe pixelcount could be used to know the area of the filled region. The internal parameter tolerance can be tuned to cope with antialiasing, bringing \""sharper\"" resuts.\\n(Comments show changes to fill the white area instead of the black circle)\\nInput is the image, the starting node (x, y), the target color we want to fill, and the replacement color that will replace the target color. It implements a 4-way flood fill algorithm.\\nInterface\\nImplementation\\nThis implementation matches exact colours only. Since the example image has grey pixels around the edges of the circles, these will remain grey after the interiors are filled.\\nThis version uses the bitmap module from the Bitmap Task, matches exact colours only, and is derived from the Go version (to avoid stack overflow because unlike Go the D stack is not segmented).\\nUsing the image type from Basic bitmap storage#E.\\nIn \""PC.LIB\"" library there is a FILL procedure that do the job, but the example program implements the algorithm in ERRE language using an iterative method. This program is taken from the distribution disk and works in 320x200 graphics.\\nNote: I haven't an \""Upload files\"" item, so I can't show the resulting image!\\nUsing an emulated stack. EMT's recursive stack space is limited. For the notebook with images see this page.\\nUsing pure FBSL's built-in graphics functions:\\nOutput: \\nThis simple recursive algorithm uses routines from Basic bitmap storage.\\nHere the target color paradigm is used. Again the matchdistance parameter can be tuned to ignore small differences that could come because of antialiasing.\\nUsage example excerpt (which on the test image will fill with green the inner black circle):\\nAn addition to code from the bitmap task:\\nAnd a test program. Works with code from read ppm and write ppm to pipe tasks. For input, it uses a version of the test file converted by the Go solution to \""Read an image through a pipe\"". For output it uses the trick from \""PPM conversion through a pipe\"" to write the .png suitable for uploading to RC.\\nThis code uses the Bitmap and Bitmap.RGB modules defined here.\\nHicEst color fill is via the decoration option of WRITE()\\nSolution:\\nUses getPixels and setPixels from Basic bitmap storage.\\nExample Usage:\\nThe following draws the same image as for the Tcl example image below.\\nUses definitions from Basic bitmap storage, Bresenham's line algorithm and Midpoint circle algorithm.\\nAlternative findcontig:\\nThe following alternative version of findcontig is less concise but is leaner, faster, works for n-dimensions and is not restricted to numerical arrays.\\nInput is the image, the starting node (x, y), the target color we want to fill, and the replacement color that will replace the target color. It implements a 4-way flood fill algorithm. For large images, the performance can be improved by drawing the scanlines instead of setting each pixel to the replacement color, or by working directly on the databuffer.\\nAnd here is an example of how to replace the white color with red from the sample image (with starting node (50, 50)):\\nInspired to  Python version.\\nLingo has built-in flood fill for image objects, so a custom implementation would be pointless:\\n","#ifndef PROCESSING_FLOODFILLALGORITHM_H_\\n#define PROCESSING_FLOODFILLALGORITHM_H_\\n\\n#include \\n#include <string.h>\\n#include <queue>\\n\\nusing namespace cv;\\nusing namespace std;\\n\\nclass FloodFillAlgorithm {\\npublic:\\n    FloodFillAlgorithm(Mat* image) :\\n        image(image) {\\n    }\\n    virtual ~FloodFillAlgorithm();\\n\\n    void flood(Point startPoint, Scalar tgtColor, Scalar loDiff);\\n    void flood(Point startPoint, Mat* tgtMat);\\n\\nprotected:\\n    Mat* image;\\nprivate:\\n    bool insideImage(Point p);\\n};\\n\\n#endif /* PROCESSING_FLOODFILLALGORITHM_H_ */\\n"
"C++","Bitmap/Flood_fill","Implement a flood fill.\\nA flood fill is a way of filling an area using color banks to define the contained area or a target color which \""determines\"" the area (the valley that can be flooded; Wikipedia uses the term target color). It works almost like a water flooding from a point towards the banks (or: inside the valley): if there's a hole in the banks, the flood is not contained and all the image (or all the \""connected valleys\"") get filled.\\nTo accomplish the task, you need to implement just one of the possible algorithms (examples are on Wikipedia). Variations on the theme are allowed (e.g. adding a tolerance parameter or argument for color-matching of the banks or target color).\\nTesting: the basic algorithm is not suitable for truecolor images; a possible test image is the one shown on the right box; you can try to fill the white area, or the black inner circle.\\n\\nThe procedure has the following parameters. Picture is the image to change. From is the point to start at. Fill is the color to fill with. Replace is the color to replace. Distance defines the range of color around Replace to replace as well. The distance is defined as a maximum of the differences of stimuli. The following code snippet reads the test file, fills the area between two circles red, and writes the result:\\nThis is limited to %StackSize% pixels.\\nBBC BASIC has a built-in flood fill statement, but to satisfy the terms of the task it is not used in this example.\\nThe sys/queue.h is not POSIX. (See FIFO)\\nThe pixelcount could be used to know the area of the filled region. The internal parameter tolerance can be tuned to cope with antialiasing, bringing \""sharper\"" resuts.\\n(Comments show changes to fill the white area instead of the black circle)\\nInput is the image, the starting node (x, y), the target color we want to fill, and the replacement color that will replace the target color. It implements a 4-way flood fill algorithm.\\nInterface\\nImplementation\\nThis implementation matches exact colours only. Since the example image has grey pixels around the edges of the circles, these will remain grey after the interiors are filled.\\nThis version uses the bitmap module from the Bitmap Task, matches exact colours only, and is derived from the Go version (to avoid stack overflow because unlike Go the D stack is not segmented).\\nUsing the image type from Basic bitmap storage#E.\\nIn \""PC.LIB\"" library there is a FILL procedure that do the job, but the example program implements the algorithm in ERRE language using an iterative method. This program is taken from the distribution disk and works in 320x200 graphics.\\nNote: I haven't an \""Upload files\"" item, so I can't show the resulting image!\\nUsing an emulated stack. EMT's recursive stack space is limited. For the notebook with images see this page.\\nUsing pure FBSL's built-in graphics functions:\\nOutput: \\nThis simple recursive algorithm uses routines from Basic bitmap storage.\\nHere the target color paradigm is used. Again the matchdistance parameter can be tuned to ignore small differences that could come because of antialiasing.\\nUsage example excerpt (which on the test image will fill with green the inner black circle):\\nAn addition to code from the bitmap task:\\nAnd a test program. Works with code from read ppm and write ppm to pipe tasks. For input, it uses a version of the test file converted by the Go solution to \""Read an image through a pipe\"". For output it uses the trick from \""PPM conversion through a pipe\"" to write the .png suitable for uploading to RC.\\nThis code uses the Bitmap and Bitmap.RGB modules defined here.\\nHicEst color fill is via the decoration option of WRITE()\\nSolution:\\nUses getPixels and setPixels from Basic bitmap storage.\\nExample Usage:\\nThe following draws the same image as for the Tcl example image below.\\nUses definitions from Basic bitmap storage, Bresenham's line algorithm and Midpoint circle algorithm.\\nAlternative findcontig:\\nThe following alternative version of findcontig is less concise but is leaner, faster, works for n-dimensions and is not restricted to numerical arrays.\\nInput is the image, the starting node (x, y), the target color we want to fill, and the replacement color that will replace the target color. It implements a 4-way flood fill algorithm. For large images, the performance can be improved by drawing the scanlines instead of setting each pixel to the replacement color, or by working directly on the databuffer.\\nAnd here is an example of how to replace the white color with red from the sample image (with starting node (50, 50)):\\nInspired to  Python version.\\nLingo has built-in flood fill for image objects, so a custom implementation would be pointless:\\n","#include \""FloodFillAlgorithm.h\""\\n\\nFloodFillAlgorithm::~FloodFillAlgorithm() {\\n}\\n\\nvoid FloodFillAlgorithm::flood(Point startPoint, Scalar tgtColor, Scalar loDiff) {\\n    floodFill(*image, startPoint, tgtColor, 0, loDiff);\\n}\\n\\nvoid FloodFillAlgorithm::flood(Point startPoint, Mat* tgtMat) {\\n    if (!insideImage(startPoint))\\n        return;\\n\\n    Vec3b srcColor = image->at<Vec3b>(startPoint);\\n\\n    if (image->at<Vec3b>(startPoint) == srcColor) {\\n\\n        queue<Point> pointQueue;\\n	pointQueue.push(startPoint);\\n\\n	while (!pointQueue.empty()) {\\n	    Point p = pointQueue.front();\\n	    pointQueue.pop();\\n\\n	    if (insideImage(p)) {\\n\\n		if ((image->at<Vec3b>(p) == srcColor)) {\\n		    image->at<Vec3b>(p) = tgtMat->at<Vec3b>(p);\\n\\n		    pointQueue.push(Point(p.x + 1, p.y));\\n		    pointQueue.push(Point(p.x - 1, p.y));\\n		    pointQueue.push(Point(p.x, p.y + 1));\\n		    pointQueue.push(Point(p.x, p.y - 1));\\n		}\\n	    }\\n\\n	}\\n    }\\n}\\n\\nbool FloodFillAlgorithm::insideImage(Point p) {\\n    return (p.x >= 0) && (p.x < image->size().width) && (p.y >= 0) && (p.y < image->size().height);\\n}\\n\\n"
"C++","Bitwise_operations","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\n\\nWrite a routine to perform a bitwise AND, OR, and XOR on two integers, a bitwise NOT on the first integer, a left shift, right shift, right arithmetic shift, left rotate, and right rotate.\\nAll shifts and rotates should be done on the first integer with a shift/rotate amount of the second integer.\\nIf any operation is not available in your language, note it.\\n\\n","#include <iostream>\\n\\nvoid bitwise(int a, int b)\\n{\\n  std::cout << \""a and b: \"" << (a & b)  << '\\n'; // Note: parentheses are needed because & has lower precedence than <<\\n  std::cout << \""a or b:  \"" << (a | b)  << '\\n';\\n  std::cout << \""a xor b: \"" << (a ^ b)  << '\\n';\\n  std::cout << \""not a:   \"" << ~a       << '\\n';\\n  std::cout << \""a shl b: \"" << (a << b) << '\\n'; // Note: \""<<\"" is used both for output and for left shift\\n  std::cout << \""a shr b: \"" << (a >> b) << '\\n'; // typically arithmetic right shift, but not guaranteed\\n  unsigned int c = a;\\n  std::cout << \""c sra b: \"" << (c >> b) << '\\n'; // logical right shift (guaranteed)\\n  // there are no rotation operators in C++\\n}"
"C++","Box_the_compass","There be many a land lubber that knows naught of the pirate ways and gives direction by degree!\\nThey know not how to box the compass!\\n\\n\\n\\n","#include <string>\\n#include \\n#include \\n#include \\n#include \\n#include <iostream>\\n#include <math.h>\\nusing std::string;\\nusing namespace boost::assign;\\n\\nint get_Index(float angle)\\n{\\n   return static_cast<int>(floor(angle / 11.25 +0.5 )) % 32 + 1;\\n}\\n\\nstring get_Abbr_From_Index(int i)\\n{\\n    static boost::array points(list_of\\n            (\""N\"")(\""NbE\"")(\""NNE\"")(\""NEbN\"")(\""NE\"")(\""NEbE\"")(\""ENE\"")(\""EbN\"")\\n            (\""E\"")(\""EbS\"")(\""ESE\"")(\""SEbE\"")(\""SE\"")(\""SEbS\"")(\""SSE\"")(\""SbE\"")\\n            (\""S\"")(\""SbW\"")(\""SSW\"")(\""SWbS\"")(\""SW\"")(\""SWbW\"")(\""WSW\"")(\""WbS\"")\\n            (\""W\"")(\""WbN\"")(\""WNW\"")(\""NWbW\"")(\""NW\"")(\""NWbN\"")(\""NNW\"")(\""NbW\""));\\n    return points[i-1];\\n}\\n\\nstring Build_Name_From_Abbreviation(string a)\\n{\\n    string retval;\\n    for (int i = 0; i < a.size(); ++i){\\n        if ((1 == i) && (a[i] != 'b') && (a.size() == 3)) retval += \""-\"";\\n        switch (a[i]){\\n            case 'N' : retval += \""north\""; break; \\n            case 'S' : retval += \""south\""; break; \\n            case 'E' : retval += \""east\"";  break; \\n            case 'W' : retval += \""west\"";  break; \\n            case 'b' : retval += \"" by \"";  break;\\n        }\\n    }\\n    retval[0] = toupper(retval[0]);\\n    return retval;\\n}\\n\\nint main()\\n{\\n    boost::array headings(list_of\\n            (0.0)(16.87)(16.88)(33.75)(50.62)(50.63)(67.5)(84.37)(84.38)(101.25)\\n            (118.12)(118.13)(135.0)(151.87)(151.88)(168.75)(185.62)(185.63)(202.5)\\n            (219.37)(219.38)(236.25)(253.12)(253.13)(270.0)(286.87)(286.88)(303.75)\\n            (320.62)(320.63)(337.5)(354.37)(354.38));\\n    int i;\\n    boost::format f(\""%1$4d %2$-20s %3$_7.2f\"");\\n\\n    BOOST_FOREACH(float a, headings)\\n    {\\n        i = get_Index(a);\\n        std::cout << f % i %  Build_Name_From_Abbreviation(get_Abbr_From_Index(i)) % a << std::endl;\\n    }\\n    return 0;\\n}"
"C++","Brace_expansion","Brace expansion is a type of parameter expansion made popular by Unix shells, where it allows users to specify multiple similar string parameters without having to type them all out. E.g. the parameter enable_{audio,video} would be interpreted as if both enable_audio and enable_video had been specified.\\nWrite a function that can perform brace expansion on any input string, according to the following specification.\\nDemonstrate how it would be used, and that it passes the four test cases given below.\\nIn the input string, balanced pairs of braces containing comma-separated substrings (details below) represent alternations that specify multiple alternatives which are to appear at that position in the output. In general, one can imagine the information conveyed by the input string as a tree of nested alternations interspersed with literal substrings, as shown in the middle part of the following diagram:\\nThis tree can in turn be transformed into the intended list of output strings by, colloquially speaking, determining all the possible ways to walk through it from left to right while only descending into one branch of each alternation one comes across (see the right part of the diagram). When implementing it, one can of course combine the parsing and expansion into a single algorithm, but this specification discusses them separately for the sake of clarity.\\nExpansion of alternations can be more rigorously described by these rules:\\nParsing the input string involves some additional complexity to deal with escaped characters and \""incomplete\"" brace pairs:\\nFor every possible input string, your implementation should produce exactly the output which this specification mandates. Please comply with this even when it's inconvenient, to ensure that all implementations are comparable. However, none of the above should be interpreted as instructions (or even recommendations) for how to implement it. Try to come up with a solution that is idiomatic in your programming language. (See #Perl for a reference implementation.)\\n~/{Downloads,Pictures}/*.{jpg,gif,png}\\n~/Downloads/*.jpg\\n~/Downloads/*.gif\\n~/Downloads/*.png\\n~/Pictures/*.jpg\\n~/Pictures/*.gif\\n~/Pictures/*.png\\nIt{{em,alic}iz,erat}e{d,}, please.\\nItemized, please.\\nItemize, please.\\nItalicized, please.\\nItalicize, please.\\nIterated, please.\\nIterate, please.\\n{,{,gotta have{ ,\\, again\\, }}more }cowbell!\\ncowbell!\\nmore cowbell!\\ngotta have more cowbell!\\ngotta have\\, again\\, more cowbell!\\n{}} some }{,{\\\\{ edge, edge} \\,}{ cases, {here} \\\\\\\\\\}\\n{}} some }{,{\\\\ edge \\,}{ cases, {here} \\\\\\\\\\}\\n{}} some }{,{\\\\ edge \\,}{ cases, {here} \\\\\\\\\\}\\n","#include <iostream>\\n#include <iterator>\\n#include <string>\\n#include <utility>\\n#include <vector>\\n\\nnamespace detail {\\n\\ntemplate \\nclass tokenizer\\n{\\n	\\n	ForwardIterator _tbegin, _tend, _end;\\n	\\npublic:\\n	\\n	tokenizer(ForwardIterator begin, ForwardIterator end)\\n		: _tbegin(begin), _tend(begin), _end(end)\\n	{ }\\n	\\n	template \\n	bool next(Lambda istoken)\\n	{\\n		if (_tbegin == _end) {\\n			return false;\\n		}\\n		_tbegin = _tend;\\n		for (; _tend != _end && !istoken(*_tend); ++_tend) {\\n			if (*_tend == '\\\\' && std::next(_tend) != _end) {\\n				++_tend;\\n			}\\n		}\\n		if (_tend == _tbegin) {\\n			_tend++;\\n		}\\n		return _tbegin != _end;\\n	}\\n	\\n	ForwardIterator begin() const { return _tbegin; }\\n	ForwardIterator end()   const { return _tend; }\\n	bool operator==(char c) { return *_tbegin == c; }\\n	\\n};\\n\\ntemplate \\nvoid append_all(List & lista, const List & listb)\\n{\\n	if (listb.size() == 1) {\\n		for (auto & a : lista) {\\n			a += listb.back();\\n		}\\n	} else {\\n		List tmp;\\n		for (auto & a : lista) {\\n			for (auto & b : listb) {\\n				tmp.push_back(a + b);\\n			}\\n		}\\n		lista = std::move(tmp);\\n	}\\n}\\n\\ntemplate \\nList expand(Tokenizer & token)\\n{\\n	\\n	std::vector<List> alts{ { String() } };\\n	\\n	while (token.next([](char c) { return c == '{' || c == ',' || c == '}'; })) {\\n		\\n		if (token == '{') {\\n			append_all(alts.back(), expand(token));\\n		} else if (token == ',') {\\n			alts.push_back({ String() });\\n		} else if (token == '}') {\\n			if (alts.size() == 1) {\\n				for (auto & a : alts.back()) {\\n					a = '{' + a + '}';\\n				}\\n				return alts.back();\\n			} else {\\n				for (std::size_t i = 1; i < alts.size(); i++) {\\n					alts.front().insert(alts.front().end(),\\n						std::make_move_iterator(std::begin(alts[i])),\\n						std::make_move_iterator(std::end(alts[i])));\\n				}\\n				return std::move(alts.front());\\n			}\\n		} else {\\n			for (auto & a : alts.back()) {\\n				a.append(token.begin(), token.end());\\n			}\\n		}\\n		\\n	}\\n	\\n	List result{ String{ '{' } };\\n	append_all(result, alts.front());\\n	for (std::size_t i = 1; i < alts.size(); i++) {\\n		for (auto & a : result) {\\n			a += ',';\\n		}\\n		append_all(result, alts[i]);\\n	}\\n	return result;\\n}\\n\\n} // namespace detail\\n\\ntemplate <\\n	typename ForwardIterator,\\n	typename String = std::basic_string<\\n		typename std::iterator_traits<ForwardIterator>::value_type\\n	>,\\n	typename List = std::vector<String>\\n>\\nList expand(ForwardIterator begin, ForwardIterator end)\\n{\\n	detail::tokenizer<ForwardIterator> token(begin, end);\\n	List list{ String() };\\n	while (token.next([](char c) { return c == '{'; })) {\\n		if (token == '{') {\\n			detail::append_all(list, detail::expand(token));\\n		} else {\\n			for (auto & a : list) {\\n				a.append(token.begin(), token.end());\\n			}\\n		}\\n	}\\n	return list;\\n}\\n\\ntemplate <\\n	typename Range,\\n	typename String = std::basic_string,\\n	typename List = std::vector<String>\\n>\\nList expand(const Range & range)\\n{\\n	using Iterator = typename Range::const_iterator;\\n	return expand(std::begin(range), std::end(range));\\n}\\n\\nint main()\\n{\\n	\\n	for (std::string string : {\\n		R\""(~/{Downloads,Pictures}/*.{jpg,gif,png})\"",\\n		R\""(It{{em,alic}iz,erat}e{d,}, please.)\"",\\n		R\""({,{,gotta have{ ,\\, again\\, }}more }cowbell!)\"",\\n		R\""({}} some {\\\\{edge,edgy} }{ cases, here\\\\\\})\"",\\n		R\""(a{b{1,2}c)\"",\\n		R\""(a{1,2}b}c)\"",\\n		R\""(a{1,{2},3}b)\"",\\n		R\""(a{b{1,2}c{}})\"",\\n		R\""(more{ darn{ cowbell,},})\"",\\n		R\""(ab{c,d\\,e{f,g\\h},i\\,j{k,l\\,m}n,o\\,p}qr)\"",\\n		R\""({a,{\\,b}c)\"",\\n		R\""(a{b,{{c}})\"",\\n		R\""({a{\\}b,c}d)\"",\\n		R\""({a,b{{1,2}e}f)\"",\\n		R\""({}} some }{,{\\\\{ edge, edge} \\,}{ cases, {here} \\\\\\\\\\})\"",\\n		R\""({{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{)\"",\\n	}) {\\n		std::cout << string << '\\n';\\n		for (auto expansion : expand(string)) {\\n			std::cout << \""    \"" << expansion << '\\n';\\n		}\\n		std::cout << '\\n';\\n	}\\n	\\n	return 0;\\n}"
"C++","Break_OO_privacy","Show how to access private or protected members of a class in an object-oriented language from outside an instance of the class, without calling non-private or non-protected members of the class as a proxy.\\nThe intent is to show how a debugger, serializer, or other meta-programming tool might access information that is barred by normal access methods to the object but can nevertheless be accessed from within the language by some provided escape hatch or reflection mechanism.\\nThe intent is specifically not to demonstrate heroic measures such as peeking and poking raw memory.\\nNote that cheating on your type system is almost universally regarded\\nas unidiomatic at best, and poor programming practice at worst.\\nNonetheless, if your language intentionally maintains a double-standard for OO privacy, here's where you can show it off.\\nSimilar to C++, ABAP allows the declaration of friends which can be both classes and interfaces. All subclasses of friend classes are automatically friends of the source class. For example if classA (source) has classB as a friend and classC is a subclass of classB then classC is a friend of classA. Similarly all implementing classes of friend interfaces are friends of the source class. Also all interfaces which contain the befriended interface as a component are friends of the source class.\\nOne of the great criticisms of Pascal was \""there is no escape\"". The reason was that sometimes you have to convert the incompatible. For this purpose, Ada has the generic function Unchecked_Conversion, that can be used for such purposes\\nas breaking OO privacy. We start with the package that holds the \""secret\"":\\nSecond, the package that provides the \""hack\"" into Confidential_Stuff:\\nThe output shows that C holds, surprise, surprise, the default password:\\n","#include <iostream>\\n\\nclass CWidget; // Forward-declare that we have a class named CWidget.\\n\\nclass CFactory\\n{\\n  friend class CWidget;\\nprivate:\\n  unsigned int m_uiCount;\\npublic:\\n  CFactory();\\n  ~CFactory();\\n  CWidget* GetWidget();\\n};\\n\\nclass CWidget\\n{\\nprivate:\\n  CFactory& m_parent;\\n\\nprivate:\\n  CWidget(); // Disallow the default constructor.\\n  CWidget(const CWidget&); // Disallow the copy constructor\\n  CWidget& operator=(const CWidget&); // Disallow the assignment operator.\\npublic:\\n  CWidget(CFactory& parent);\\n  ~CWidget();\\n};\\n\\n// CFactory constructors and destructors. Very simple things.\\nCFactory::CFactory() : m_uiCount(0) {}\\nCFactory::~CFactory() {}\\n\\n// CFactory method which creates CWidgets.\\nCWidget* CFactory::GetWidget()\\n{\\n  // Create a new CWidget, tell it we're its parent.\\n  return new CWidget(*this);\\n}\\n\\n// CWidget constructor\\nCWidget::CWidget(CFactory& parent) : m_parent(parent)\\n{\\n  ++m_parent.m_uiCount;\\n\\n  std::cout << \""Widget spawning. There are now \"" << m_parent.m_uiCount << \"" Widgets instanciated.\"" << std::endl;\\n}\\n\\nCWidget::~CWidget()\\n{\\n  --m_parent.m_uiCount;\\n\\n  std::cout << \""Widget dieing. There are now \"" << m_parent.m_uiCount << \"" Widgets instanciated.\"" << std::endl;\\n}\\n\\nint main()\\n{\\n  CFactory factory;\\n\\n  CWidget* pWidget1 = factory.GetWidget();\\n  CWidget* pWidget2 = factory.GetWidget();\\n  delete pWidget1;\\n\\n  CWidget* pWidget3 = factory.GetWidget();\\n  delete pWidget3;\\n  delete pWidget2;\\n}"
"C++","Break_OO_privacy","Show how to access private or protected members of a class in an object-oriented language from outside an instance of the class, without calling non-private or non-protected members of the class as a proxy.\\nThe intent is to show how a debugger, serializer, or other meta-programming tool might access information that is barred by normal access methods to the object but can nevertheless be accessed from within the language by some provided escape hatch or reflection mechanism.\\nThe intent is specifically not to demonstrate heroic measures such as peeking and poking raw memory.\\nNote that cheating on your type system is almost universally regarded\\nas unidiomatic at best, and poor programming practice at worst.\\nNonetheless, if your language intentionally maintains a double-standard for OO privacy, here's where you can show it off.\\nSimilar to C++, ABAP allows the declaration of friends which can be both classes and interfaces. All subclasses of friend classes are automatically friends of the source class. For example if classA (source) has classB as a friend and classC is a subclass of classB then classC is a friend of classA. Similarly all implementing classes of friend interfaces are friends of the source class. Also all interfaces which contain the befriended interface as a component are friends of the source class.\\nOne of the great criticisms of Pascal was \""there is no escape\"". The reason was that sometimes you have to convert the incompatible. For this purpose, Ada has the generic function Unchecked_Conversion, that can be used for such purposes\\nas breaking OO privacy. We start with the package that holds the \""secret\"":\\nSecond, the package that provides the \""hack\"" into Confidential_Stuff:\\nThe output shows that C holds, surprise, surprise, the default password:\\n","Widget spawning. There are now 1 Widgets instanciated.\\nWidget spawning. There are now 2 Widgets instanciated.\\nWidget dieing. There are now 1 Widgets instanciated.\\nWidget spawning. There are now 2 Widgets instanciated.\\nWidget dieing. There are now 1 Widgets instanciated.\\nWidget dieing. There are now 0 Widgets instanciated."
"C++","Break_OO_privacy","Show how to access private or protected members of a class in an object-oriented language from outside an instance of the class, without calling non-private or non-protected members of the class as a proxy.\\nThe intent is to show how a debugger, serializer, or other meta-programming tool might access information that is barred by normal access methods to the object but can nevertheless be accessed from within the language by some provided escape hatch or reflection mechanism.\\nThe intent is specifically not to demonstrate heroic measures such as peeking and poking raw memory.\\nNote that cheating on your type system is almost universally regarded\\nas unidiomatic at best, and poor programming practice at worst.\\nNonetheless, if your language intentionally maintains a double-standard for OO privacy, here's where you can show it off.\\nSimilar to C++, ABAP allows the declaration of friends which can be both classes and interfaces. All subclasses of friend classes are automatically friends of the source class. For example if classA (source) has classB as a friend and classC is a subclass of classB then classC is a friend of classA. Similarly all implementing classes of friend interfaces are friends of the source class. Also all interfaces which contain the befriended interface as a component are friends of the source class.\\nOne of the great criticisms of Pascal was \""there is no escape\"". The reason was that sometimes you have to convert the incompatible. For this purpose, Ada has the generic function Unchecked_Conversion, that can be used for such purposes\\nas breaking OO privacy. We start with the package that holds the \""secret\"":\\nSecond, the package that provides the \""hack\"" into Confidential_Stuff:\\nThe output shows that C holds, surprise, surprise, the default password:\\n","#include <iostream>\\n\\nclass CWidget; // Forward-declare that we have a class named CWidget.\\n\\nclass CFactory\\n{\\nprivate:\\n  unsigned int m_uiCount;\\npublic:\\n  CFactory();\\n  ~CFactory();\\n  CWidget* GetWidget();\\n};\\n\\nclass CWidget\\n{\\nprivate:\\n  unsigned int* m_pCounter;\\n\\nprivate:\\n  CWidget(); // Disallow the default constructor.\\n  CWidget(const CWidget&); // Disallow the copy constructor\\n  CWidget& operator=(const CWidget&); // Disallow the assignment operator.\\npublic:\\n  CWidget(unsigned int* pCounter);\\n  ~CWidget();\\n};\\n\\n// CFactory constructors and destructors. Very simple things.\\nCFactory::CFactory() : m_uiCount(0) {}\\nCFactory::~CFactory() {}\\n\\n// CFactory method which creates CWidgets.\\nCWidget* CFactory::GetWidget()\\n{\\n  // Create a new CWidget, tell it we're its parent.\\n  return new CWidget(&m_uiCount);\\n}\\n\\n// CWidget constructor\\nCWidget::CWidget(unsigned int* pCounter) : m_pCounter(pCounter)\\n{\\n  ++*m_pCounter;\\n\\n  std::cout << \""Widget spawning. There are now \"" << *m_pCounter<< \"" Widgets instanciated.\"" << std::endl;\\n}\\n\\nCWidget::~CWidget()\\n{\\n  --*m_pCounter;\\n\\n  std::cout << \""Widget dieing. There are now \"" << *m_pCounter<< \"" Widgets instanciated.\"" << std::endl;\\n}\\n\\nint main()\\n{\\n  CFactory factory;\\n\\n  CWidget* pWidget1 = factory.GetWidget();\\n  CWidget* pWidget2 = factory.GetWidget();\\n  delete pWidget1;\\n\\n  CWidget* pWidget3 = factory.GetWidget();\\n  delete pWidget3;\\n  delete pWidget2;\\n}"
"C++","Brownian_tree","\\nGenerate and draw a   Brownian Tree.\\n\\nA Brownian Tree is generated as a result of an initial seed, followed by the interaction of two processes.\\nBecause of the lax rules governing the random nature of the particle's placement and motion, no two resulting trees are really expected to be the same, or even necessarily have the same general shape. \\nTakes a little while to run, be patient.\\nRequires the GDI+ Standard Library by Tic\\n\\nBold text\\nThis version writes the image as Portable Bit Map to stdout and doesn't move already set particles.\\nRun-time about 12.4 seconds with SIDE=600, NUM_PARTICLES=10000.\\n\\nFor an animated version based on this same code see: Brownian tree/C++ animated\\nWhen the random walk lands on a set pixel it sets the pixel at the previous position.\\nAn alternate method sets a pixel if the current position is vacant and at least one neighbour is set.\\nThe former produces denser trees than the latter. If compiled with SBCL, providing a command line argument will invoke the latter method.\\nRequires Quicklisp library manager and the CL-GD package for producing PNG images.\\nWorld side = 600, num_particles = 10_000, cropped (about 20 seconds run-time with dmd, about 4.3 seconds with ldc2):\\nThis example sets four spawn points, one in each corner of the image, giving the result a vague x-shaped appearance. For visual reasons, movement is restricted to diagonals. So be careful if you change the seed or spawns — they should all fall on the same diagonal.\\n","#include <windows.h>\\n#include <iostream>\\n#include <string>\\n\\n//--------------------------------------------------------------------\\nusing namespace std;\\n\\n//--------------------------------------------------------------------\\nenum states { SEED, GROWING, MOVING, REST };\\nenum treeStates { NONE, MOVER, TREE };\\nconst int MAX_SIDE = 480, MAX_MOVERS = 511, MAX_CELLS = 15137;\\n\\n//--------------------------------------------------------------------\\nclass point\\n{\\npublic:\\n    point()                  { x = y = 0; }\\n    point( int a, int b )    { x = a; y = b; }\\n    void set( int a, int b ) { x = a; y = b; }\\n\\n    int x, y;\\n};\\n//--------------------------------------------------------------------\\nclass movers\\n{\\npublic:\\n    point pos;\\n    bool moving;\\n    movers() : moving( false ){}\\n};\\n//--------------------------------------------------------------------\\nclass myBitmap\\n{\\npublic:\\n    myBitmap() : pen( NULL ) {}\\n    ~myBitmap()\\n    {\\n	DeleteObject( pen );\\n	DeleteDC( hdc );\\n	DeleteObject( bmp );\\n    }\\n\\n    bool create( int w, int h )\\n    {\\n	BITMAPINFO	bi;\\n	ZeroMemory( &bi, sizeof( bi ) );\\n\\n	bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );\\n	bi.bmiHeader.biBitCount	   = sizeof( DWORD ) * 8;\\n	bi.bmiHeader.biCompression = BI_RGB;\\n	bi.bmiHeader.biPlanes	   = 1;\\n	bi.bmiHeader.biWidth	   =  w;\\n	bi.bmiHeader.biHeight	   = -h;\\n\\n	HDC dc = GetDC( GetConsoleWindow() );\\n	bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );\\n	if( !bmp ) return false;\\n\\n	hdc = CreateCompatibleDC( dc );\\n	SelectObject( hdc, bmp );\\n	ReleaseDC( GetConsoleWindow(), dc ); \\n\\n	width = w; height = h;\\n\\n	return true;\\n    }\\n\\n    void clear()\\n    {\\n	ZeroMemory( pBits, width * height * sizeof( DWORD ) );\\n    }\\n\\n    void setPenColor( DWORD clr )\\n    {\\n	if( pen ) DeleteObject( pen );\\n	pen = CreatePen( PS_SOLID, 1, clr );\\n	SelectObject( hdc, pen );\\n    }\\n\\n    void saveBitmap( string path )\\n    {\\n	BITMAPFILEHEADER fileheader;\\n	BITMAPINFO	 infoheader;\\n	BITMAP		 bitmap;\\n	DWORD*		 dwpBits;\\n	DWORD		 wb;\\n	HANDLE		 file;\\n\\n	GetObject( bmp, sizeof( bitmap ), &bitmap );\\n\\n	dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];\\n	ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );\\n	ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );\\n	ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );\\n\\n	infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;\\n	infoheader.bmiHeader.biCompression = BI_RGB;\\n	infoheader.bmiHeader.biPlanes = 1;\\n	infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );\\n	infoheader.bmiHeader.biHeight = bitmap.bmHeight;\\n	infoheader.bmiHeader.biWidth = bitmap.bmWidth;\\n	infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );\\n\\n	fileheader.bfType    = 0x4D42;\\n	fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );\\n	fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;\\n\\n	GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );\\n\\n	file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL,\\n                           CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );\\n	WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );\\n	WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );\\n	WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );\\n	CloseHandle( file );\\n\\n	delete [] dwpBits;\\n    }\\n\\n    HDC getDC()     { return hdc; }\\n    int getWidth()  { return width; }\\n    int getHeight() { return height; }\\n\\nprivate:\\n    HBITMAP bmp;\\n    HDC	    hdc;\\n    HPEN    pen;\\n    void    *pBits;\\n    int	    width, height;\\n};\\n//--------------------------------------------------------------------\\nclass brownianTree\\n{\\npublic:\\n    brownianTree()         \\n    { \\n	_bmp.create( MAX_SIDE, MAX_SIDE );\\n	init(); \\n    }\\n\\n    void init()\\n    {\\n	_cellCount = 0;\\n	ZeroMemory( _grid, sizeof( _grid ) );\\n	_bmp.clear();\\n	_state = SEED;\\n    }\\n\\nbool mainLoop()\\n    {\\n	switch( _state )\\n	{\\n	    case REST:    saveTree(); return false;\\n	    case SEED:    doSeed(); break;\\n	    case GROWING: startMovers(); break;\\n	    case MOVING:  moveMovers();\\n	}\\n	    return true;\\n	}\\n\\n    myBitmap* getBmp() { return &_bmp; }\\n\\nprivate:\\n    void saveTree()\\n    {\\n	for( int y = 0; y < MAX_SIDE; y++ )\\n	    for( int x = 0; x < MAX_SIDE; x++ )\\n		if( _grid[x][y] == TREE )\\n		    SetPixel( _bmp.getDC(), x, y, RGB( 255, 120, 0 ) );\\n\\n        _bmp.saveBitmap( \""f:\\\\rc\\\\tree.bmp\"" );\\n    }\\n\\n    void doSeed()\\n    {\\n	int x = MAX_SIDE - MAX_SIDE / 2, y = MAX_SIDE / 4;\\n	_grid[rand() % x + y][rand() % x + y] = TREE;\\n	_cellCount++;\\n	_state = GROWING;\\n    }\\n\\n    void addMover( movers* m )\\n    {\\n	m->moving = true;\\n	int x = MAX_SIDE - MAX_SIDE / 2, y = MAX_SIDE / 4, a, b;\\n	while( true )\\n	{\\n	    a = rand() % x + y; b = rand() % x + y;\\n	    if( _grid[a][b] == NONE ) break;\\n	}\\n\\n	m->pos.set( a, b );\\n	_grid[a][b] = MOVER;\\n    }\\n\\n    void startMovers()\\n    {\\n	movers* m;\\n	for( int c = 0; c < MAX_MOVERS; c++ )\\n	{\\n	    m = &_movers[c];\\n	    addMover( m );\\n	}\\n	_state = MOVING;\\n    }\\n\\n    void addToTree( movers* m )\\n    {\\n	m->moving = false;\\n	_grid[m->pos.x][m->pos.y] = TREE;\\n	if( ++_cellCount >= MAX_CELLS ) _state = REST;\\n\\n	COORD c = { 0, 1 };\\n	SetConsoleCursorPosition( GetStdHandle( STD_OUTPUT_HANDLE ), c );\\n	cout << \""Cells added: \"" << _cellCount\\n             << \"" from \"" << MAX_CELLS << \"" => \""\\n             <<  static_cast<float>( 100 * _cellCount ) /\\n                 static_cast<float>( MAX_CELLS )\\n             << \""%              \"";\\n    }\\n\\n    bool moveIt( movers* m )\\n    {\\n	point f[8]; int ff = 0;\\n	for( int y = -1; y < 2; y++ )\\n	{\\n	    for( int x = -1; x < 2; x++ )\\n	    {\\n		if( !x && !y ) continue;\\n		int a = m->pos.x + x, b = m->pos.y + y;\\n		if( a < 0 || b < 0 || a >= MAX_SIDE || b >= MAX_SIDE )\\n		{\\n		    addToTree( m );\\n		    return true;\\n		}\\n		switch( _grid[a][b] )\\n		{\\n		    case TREE:\\n			addToTree( m );\\n			return true;\\n		    case NONE:\\n			f[ff++].set( a, b );\\n		}\\n	    }\\n        }\\n\\n	if( ff < 1 ) return false;\\n\\n	_grid[m->pos.x][m->pos.y] = NONE;\\n	m->pos = f[rand() % ff];\\n	_grid[m->pos.x][m->pos.y] = MOVER;\\n\\n	return false;\\n    }\\n\\n    void moveMovers()\\n    {\\n	movers* mm;\\n	for( int m = 0; m < MAX_MOVERS; m++ )\\n	{\\n	    mm = &_movers[m];\\n	    if( !mm->moving ) continue;\\n	    if( moveIt( mm ) && _cellCount < MAX_CELLS ) addMover( mm );\\n	}\\n    }\\n\\n    states   _state;\\n    BYTE     _grid[MAX_SIDE][MAX_SIDE];\\n    myBitmap _bmp;\\n    int      _cellCount;\\n    movers   _movers[MAX_MOVERS];\\n};\\n//--------------------------------------------------------------------\\nint main( int argc, char* argv[] )\\n{\\n    ShowWindow( GetConsoleWindow(), SW_MAXIMIZE );\\n    srand( GetTickCount() );\\n\\n    brownianTree tree;\\n\\n    DWORD now = GetTickCount();\\n    while( tree.mainLoop() );\\n\\n    now = GetTickCount() - now;\\n    cout << endl << endl << \""It took \""\\n         << now / 1000\\n         << \"" seconds to complete the task!\"" << endl << endl;\\n\\n    BitBlt( GetDC( GetConsoleWindow() ), 20, 90, MAX_SIDE, MAX_SIDE,\\n            tree.getBmp()->getDC(), 0, 0, SRCCOPY );\\n\\n    system( \""pause\"" );\\n    return 0;\\n}\\n//--------------------------------------------------------------------"
"C++","Bulls_and_cows","\\nCreate a four digit random number from the digits   1   to   9,   without duplication.\\nThe program should:\\n\\nThe score is computed as:\\n\\n\\nOutput:\\nGUI implementation; the prompt for a guess includes a list of all past guesses and their scores.\\nThe following function contains the code to check how many bulls and cows there are.\\nTo handle I/O, we use functions named say (which simply outputs a string) and prompt (which takes a prompt string to display to the user and returns a line of input, without a trailing newline). These require platform-specific implementations. Here's how they can be implemented for the SpiderMonkey shell:\\nWe can now solve the task using say and prompt:\\n","#include <iostream>\\n#include <string>\\n#include <algorithm>\\n#include <cstdlib>\\n\\nbool contains_duplicates(std::string s)\\n{\\n  std::sort(s.begin(), s.end());\\n  return std::adjacent_find(s.begin(), s.end()) != s.end();\\n}\\n\\nvoid game()\\n{\\n  typedef std::string::size_type index;\\n\\n  std::string symbols = \""0123456789\"";\\n  unsigned int const selection_length = 4;\\n\\n  std::random_shuffle(symbols.begin(), symbols.end());\\n  std::string selection = symbols.substr(0, selection_length);\\n  std::string guess;\\n  while (std::cout << \""Your guess? \"", std::getline(std::cin, guess))\\n  {\\n    if (guess.length() != selection_length\\n        || guess.find_first_not_of(symbols) != std::string::npos\\n        || contains_duplicates(guess))\\n    {\\n      std::cout << guess << \"" is not a valid guess!\"";\\n      continue;\\n    }\\n\\n    unsigned int bulls = 0;\\n    unsigned int cows = 0;\\n    for (index i = 0; i != selection_length; ++i)\\n    {\\n      index pos = selection.find(guess[i]);\\n      if (pos == i)\\n        ++bulls;\\n      else if (pos != std::string::npos)\\n        ++cows;\\n    }\\n    std::cout << bulls << \"" bulls, \"" << cows << \"" cows.\\n\"";\\n    if (bulls == selection_length)\\n    {\\n      std::cout << \""Congratulations! You have won!\\n\"";\\n      return;\\n    }\\n  }\\n  std::cerr << \""Oops! Something went wrong with input, or you've entered end-of-file!\\nExiting ...\\n\"";\\n  std::exit(EXIT_FAILURE);\\n}\\n\\nint main()\\n{\\n  std::cout << \""Welcome to bulls and cows!\\nDo you want to play? \"";\\n  std::string answer;\\n  while (true)\\n  {\\n    while (true)\\n    {\\n      if (!std::getline(std::cin, answer))\\n      {\\n        std::cout << \""I can't get an answer. Exiting.\\n\"";\\n        return EXIT_FAILURE;\\n      }\\n      if (answer == \""yes\"" || answer == \""Yes\"" || answer == \""y\"" || answer == \""Y\"")\\n        break;\\n      if (answer == \""no\"" || answer == \""No\"" || answer == \""n\"" || answer == \""N\"")\\n      {\\n        std::cout << \""Ok. Goodbye.\\n\"";\\n        return EXIT_SUCCESS;\\n      }\\n      std::cout << \""Please answer yes or no: \"";\\n    }\\n    game(); \\n    std::cout << \""Another game? \"";\\n  }\\n}"
"C++","Bulls_and_cows/Player","Write a player of the Bulls and Cows game, rather than a scorer. The player should give intermediate answers that respect the scores to previous attempts.\\nOne method is to generate a list of all possible numbers that could be the answer, then to prune the list by keeping only those numbers that would give an equivalent score to how your last guess was scored. Your next guess can be any number from the pruned list.\\nEither you guess correctly or run out of numbers to guess, which indicates a problem with the scoring.\\n\\n\\nbulls_player.adb:\\noutput:\\nOutput:\\nExample output:-\\nOutput:\\n","\\n#include <iostream>\\n#include <sstream>\\n#include <iomanip>\\n#include <algorithm>\\n#include <vector>\\n#include <time.h>\\n\\n//--------------------------------------------------------------------------------------------------\\nusing namespace std;\\n\\n//--------------------------------------------------------------------------------------------------\\nconst unsigned int LEN = 4;\\n\\n//--------------------------------------------------------------------------------------------------\\nclass CowsAndBulls_Player\\n{\\npublic:\\n    CowsAndBulls_Player() { fillPool(); }\\n    void play() { secret = createSecret(); guess(); }\\n\\nprivate:\\n    void guess()\\n    {\\n	pair res; int cc = 1;\\n	cout << endl << \"" SECRET: \"" << secret << endl << \""==============\"" << endl;\\n	cout << \""+-----------+---------+--------+\\n|   GUESS   |  BULLS  |  COWS  |\\n+-----------+---------+--------+\\n\"";\\n	while( true )\\n	{\\n	    string gs = gimmeANumber();\\n	    if( gs.empty() ) { cout << endl << \""Something went wrong with the scoring...\"" << endl << \""Cannot find an answer!\"" << endl; return; }\\n	    if( scoreIt( gs, res ) ) { cout << endl << \""I found the secret number!\"" << endl << \""It is: \"" << gs << endl; return; }\\n	    cout << \""|    \"" << gs << \""   |  \"" << setw( 3 ) << res.first << \""    |  \"" << setw( 3 ) << res.second << \""   |\\n+-----------+---------+--------+\\n\"";\\n	    clearPool( gs, res );\\n        }\\n    }\\n\\n    void clearPool( string gs, pair& r )\\n    {\\n	vector<string>::iterator pi = pool.begin();\\n	while( pi != pool.end() )\\n	{\\n	    if( removeIt( gs, ( *pi ), r ) ) pi = pool.erase( pi );\\n	    else  pi++;\\n	}\\n    }\\n\\n    string gimmeANumber()\\n    {\\n	if( pool.empty() ) return \""\"";\\n	return pool[rand() % pool.size()];\\n    }\\n\\n    void fillPool()\\n    {\\n	for( int x = 1234; x < 9877; x++ )\\n	{\\n	    ostringstream oss; oss << x;\\n	    if( check( oss.str() ) ) pool.push_back( oss.str() );\\n	}\\n    }\\n\\n    bool check( string s )\\n    {\\n	for( string::iterator si = s.begin(); si != s.end(); si++ )\\n	{\\n	    if( ( *si ) == '0' ) return false;\\n	    if( count( s.begin(), s.end(), ( *si ) ) > 1 ) return false;\\n	}\\n	return true;\\n    }\\n\\n    bool removeIt( string gs, string ts, pair& res )\\n    {\\n	pair tp; getScore( gs, ts, tp );\\n	return tp != res;\\n    }\\n\\n    bool scoreIt( string gs, pair& res )\\n    {\\n	getScore( gs, secret, res );\\n	return res.first == LEN;\\n    }\\n\\n    void getScore( string gs, string st, pair& pr )\\n    {\\n	pr.first = pr.second = 0;\\n	for( unsigned int ui = 0; ui < LEN; ui++ )\\n	{\\n	    if( gs[ui] == st[ui] ) pr.first++;\\n	    else\\n	    {\\n		for( unsigned int vi = 0; vi < LEN; vi++ )\\n		    if( gs[ui] == st[vi] ) pr.second++;\\n	    }\\n	}\\n    }\\n\\n    string createSecret()\\n    {\\n	string n = \""123456789\"", rs = \""\"";\\n	while( rs.length() < LEN )\\n	{\\n	    int r = rand() % n.length();\\n	    rs += n[r]; n.erase( r, 1 );\\n	}\\n	return rs;\\n    }\\n\\n    string secret;\\n    vector<string> pool;\\n};\\n//--------------------------------------------------------------------------------------------------\\nint main( int argc, char* argv[] )\\n{\\n    srand( static_cast( time( NULL ) ) ); CowsAndBulls_Player cb;\\n    cb.play(); cout << endl << endl;\\n    return system( \""pause\"" );\\n}\\n//--------------------------------------------------------------------------------------------------\\n"
"C++","Caesar_cipher","\\nImplement a Caesar cipher, both encoding and decoding. \\nThe key is an integer from 1 to 25.\\nThis cipher rotates (either towards left or right) the letters of the alphabet (A to Z).\\nThe encoding replaces each letter with the 1st to 25th next letter in the alphabet (wrapping Z to A).\\nSo key 2 encrypts \""HI\"" to \""JK\"", but key 20 encrypts \""HI\"" to \""BC\"".\\nThis simple \""mono-alphabetic substitution cipher\"" provides almost no security, because an attacker who has the encoded message can either use frequency analysis to guess the key, or just try all 25 keys.\\nCaesar cipher is identical to Vigenère cipher with a key of length 1. \\nAlso, Rot-13 is identical to Caesar cipher with key 13.\\n\\n\\n","#include <string>\\n#include <iostream>\\n#include <algorithm>\\n#include <cctype>\\n\\nclass MyTransform {\\nprivate : \\n   int shift ;\\npublic :\\n   MyTransform( int s ) : shift( s ) { } \\n\\n  char operator( )( char c ) {\\n      if ( isspace( c ) ) \\n	 return ' ' ;\\n      else {\\n	 static std::string letters( \""abcdefghijklmnopqrstuvwxyz\"" ) ;\\n	 std::string::size_type found = letters.find(tolower( c )) ;\\n	 int shiftedpos = ( static_cast<int>( found ) + shift ) % 26 ;\\n	 if ( shiftedpos < 0 ) //in case of decryption possibly\\n	    shiftedpos = 26 + shiftedpos ;\\n	 char shifted = letters[shiftedpos] ;\\n	 return shifted ;\\n      }\\n  }\\n} ;\\n\\nint main( ) {\\n   std::string input ;\\n   std::cout << \""Which text is to be encrypted ?\\n\"" ;\\n   getline( std::cin , input ) ;\\n   std::cout << \""shift ?\\n\"" ;\\n   int myshift = 0 ;\\n   std::cin >> myshift ;\\n   std::cout << \""Before encryption:\\n\"" << input << std::endl ;\\n   std::transform ( input.begin( ) , input.end( ) , input.begin( ) ,\\n	 MyTransform( myshift ) ) ;\\n   std::cout << \""encrypted:\\n\"" ;\\n   std::cout << input << std::endl ;\\n   myshift *= -1 ; //decrypting again\\n   std::transform ( input.begin( ) , input.end( ) , input.begin( ) ,\\n	 MyTransform( myshift ) ) ;\\n   std::cout << \""Decrypted again:\\n\"" ;\\n   std::cout << input << std::endl ;\\n   return 0 ;\\n}"
"C++","Caesar_cipher","\\nImplement a Caesar cipher, both encoding and decoding. \\nThe key is an integer from 1 to 25.\\nThis cipher rotates (either towards left or right) the letters of the alphabet (A to Z).\\nThe encoding replaces each letter with the 1st to 25th next letter in the alphabet (wrapping Z to A).\\nSo key 2 encrypts \""HI\"" to \""JK\"", but key 20 encrypts \""HI\"" to \""BC\"".\\nThis simple \""mono-alphabetic substitution cipher\"" provides almost no security, because an attacker who has the encoded message can either use frequency analysis to guess the key, or just try all 25 keys.\\nCaesar cipher is identical to Vigenère cipher with a key of length 1. \\nAlso, Rot-13 is identical to Caesar cipher with key 13.\\n\\n\\n","/* caesar cipher */\\n\\n#include <string>\\n#include <iostream>\\n#include <cctype>\\n \\nint main( ) {\\n\\n  using namespace std;\\n\\n  string input ;\\n  int key = 0;\\n\\n  // lambda functions \\n\\n  auto encrypt = [&](char c, int key ) {\\n    char A  = ( islower(c) )? 'a': 'A';\\n    c = (isalpha(c))? (c - A + key) % 26 + A : c;\\n    return (char) c;\\n  };\\n\\n  auto decrypt = [&](char c, int key ) {\\n    char A  = ( islower(c) )? 'a': 'A';\\n    c = (isalpha(c))? (c - A + (26 - key) ) % 26 + A : c;\\n    return (char) c;\\n  };\\n\\n\\n  cout << \""Enter a line of text.\\n\"";\\n  getline( cin , input );\\n\\n  cout << \""Enter an integer to shift text.\\n\"";\\n  cin  >> key;\\n  \\n  while ( (key < 1) || (key > 25) )\\n    {\\n      cout << \""must be an integer between 1 and 25 -->\"" << endl;\\n      cin  >> key;\\n    }\\n\\n  cout << \""Plain:    \\t\"" << input << endl ;\\n\\n  for ( auto & cp : input)    // use & for mutability\\n      cp = encrypt(cp, key);\\n\\n  cout << \""Encrypted:\\t\"" << input << endl;\\n\\n  for ( auto & cp : input)\\n      cp = decrypt(cp, key);\\n\\n  cout << \""Decrypted:\\t\"" << input << endl;\\n\\n  return 0 ;\\n}\\n"
"C++","Calculating_the_value_of_e","Calculate the value of   e.\\n\\n(e   is also known as   Euler's number   and   Napier's constant.)\\n\\nSee details: Calculating the value of e\\n\\n","#include <iostream>\\n#include <iomanip>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nint main() {\\n    const double EPSILON = 1.0e-15;\\n    unsigned long long fact = 1;\\n    double e = 2.0, e0;\\n    int n = 2;\\n    do {\\n        e0 = e;\\n        fact *= n++;\\n        e += 1.0 / fact;\\n    }\\n    while (fabs(e - e0) >= EPSILON);\\n    cout << \""e = \"" << setprecision(16) << e << endl;\\n    return 0;\\n}"
"C++","Call_a_foreign-language_function","Show how a foreign language function can be called from the language.\\n\\nAs an example, consider calling functions defined in the C language. Create a string containing \""Hello World!\"" of the string type typical to the language. Pass the string content to C's strdup. The content can be copied if necessary. Get the result from strdup and print it using language means. Do not forget to free the result of strdup (allocated in the heap).\\n\\n\\n\\nThe designers of Algol 68 made it extremely hard to incorporate code written in other languages. To be fair, this was a long time ago when such considerations weren't thought important and one should be careful to apply Hanlon's razor.\\nThe entry below is wildly non-portable, inefficient, violates the spirit of the specification and is just plain sick. However, it gives the correct results with Algol 68 Genie on Linux and, I claim, meets the letter of the spec. It also omits most of the error checking which should be present in production code.\\nNote that I chose a non-trivial library function because the suggested strdup() doesn't really demonstrate the technique all that well.\\n","FUNCTION MULTIPLY(X, Y)\\nDOUBLE PRECISION MULTIPLY, X, Y"
"C++","Call_a_foreign-language_function","Show how a foreign language function can be called from the language.\\n\\nAs an example, consider calling functions defined in the C language. Create a string containing \""Hello World!\"" of the string type typical to the language. Pass the string content to C's strdup. The content can be copied if necessary. Get the result from strdup and print it using language means. Do not forget to free the result of strdup (allocated in the heap).\\n\\n\\n\\nThe designers of Algol 68 made it extremely hard to incorporate code written in other languages. To be fair, this was a long time ago when such considerations weren't thought important and one should be careful to apply Hanlon's razor.\\nThe entry below is wildly non-portable, inefficient, violates the spirit of the specification and is just plain sick. However, it gives the correct results with Algol 68 Genie on Linux and, I claim, meets the letter of the spec. It also omits most of the error checking which should be present in production code.\\nNote that I chose a non-trivial library function because the suggested strdup() doesn't really demonstrate the technique all that well.\\n","#include <cstdlib>  // for C memory management\\n#include <string>   // for C++ strings\\n#include <iostream> // for output\\n\\n// C functions must be defined extern \""C\""\\nextern \""C\"" char* strdup1(char const*);\\n\\n// Fortran functions must also be defined extern \""C\"" to prevent name\\n// mangling; in addition, all fortran names are converted to lowercase\\n// and get an undescore appended. Fortran takes all arguments by\\n// reference, which translates to pointers in C and C++ (C++\\n// references generally work, too, but that may depend on the C++\\n// compiler)\\nextern \""C\"" double multiply_(double* x, double* y);\\n\\n// to simplify the use and reduce the probability of errors, a simple\\n// inline forwarder like this can be used:\\ninline double multiply(double x, double y)\\n{\\n  return multiply_(&x, &y);\\n}\\n\\nint main()\\n{\\n  std::string msg = \""The product of 3 and 5 is \"";\\n\\n  // call to C function (note that this should not be assigned\\n  // directly to a C++ string, because strdup1 allocates memory, and\\n  // we would leak the memory if we wouldn't save the pointer itself\\n  char* msg2 = strdup1(msg.c_str());\\n\\n  // C strings can be directly output to std::cout, so we don't need\\n  // to put it back into a string to output it.\\n  std::cout << msg2;\\n\\n  // call the FORTRAN function (through the wrapper):\\n  std::cout << multiply(3, 5) << std::endl;\\n\\n  // since strdup1 allocates with malloc, it must be deallocated with\\n  // free, not delete, nor delete[], nor operator delete\\n  std::free(msg2);\\n}"
"C++","Call_an_object_method","In object-oriented programming a method is a function associated with a particular class or object. In most forms of object oriented implementations methods can be static, associated with the class itself; or instance, associated with an instance of a class.\\nShow how to call a static or class method, and an instance method of a class.\\nAda is a language based on strict typing. Nevertheless, since Ada 95 (the first major revision of the language), Ada also includes the concepts of a class. Types may be tagged, and for each tagged type T there is an associated type T'Class. If you define a method as \""procedure Primitive(Self: T)\"", the actual parameter Self must be of type T, exactly, and the method Primitive will be called, well, statically. This may be surprising, if you are used to other object-oriented languages.\\nIf you define a method as \""prodedure Dynamic(Self: T'Class)\"", the actual parameter can be either T or any of its descendents. Now, if you call Self.Primitive within the procedure Dynamic, it will be dispatching, i.e., it will call the primitive function matching the type of Self (i.e., either T or any of its subtype). This is what you would expect in many other object-oriented languages.\\nFinally, a static method can be defined as a subprogram within the same package that holds the object type and the other methods.\\nSpecify the class My_Class, with one primitive subprogram, one dynamic subprogram and a static subprogram:\\nImplement the package:\\nSpecify and implement a subclass of My_Class:\\nThe main program, making the dynamic and static calls:\\n","// Static\\nMyClass::method(someParameter);\\n\\n// Instance\\nmyInstance.method(someParameter);\\n\\n// Pointer\\nMyPointer->method(someParameter);\\n"
"C++","Cantor_set","Draw Cantor set.\\nSee details: Cantor set\\n\\n","#include <iostream>\\n\\nconst int WIDTH = 81;\\nconst int HEIGHT = 5;\\n\\nchar lines[WIDTH*HEIGHT];\\n\\nvoid cantor(int start, int len, int index) {\\n	int seg = len / 3;\\n	if (seg == 0) return;\\n	for (int i = index; i < HEIGHT; i++) {\\n		for (int j = start + seg; j < start + seg * 2; j++) {\\n			int pos = i * WIDTH + j;\\n			lines[pos] = ' ';\\n		}\\n	}\\n	cantor(start,           seg, index + 1);\\n	cantor(start + 2 * seg, seg, index + 1);\\n}\\n\\nint main() {\\n	// init\\n	for (int i = 0; i < WIDTH*HEIGHT; i++) {\\n		lines[i] = '*';\\n	}\\n\\n	// calculate\\n	cantor(0, WIDTH, 1);\\n\\n	// print\\n	for (int i = 0; i < HEIGHT*WIDTH; i += WIDTH) {\\n		printf(\""%.*s\\n\"", WIDTH, lines + i);\\n	}\\n\\n	return 0;\\n}"
"C++","Card_shuffles","\\n\\nThere are many techniques that people use to shuffle cards for card games. Some are more effective than others.\\n\\nImplement the (seemingly) more common techniques of the riffle shuffle and overhand shuffle for   n   iterations.\\n\\nImplementing playing cards is not necessary if it would be easier to implement these shuffling methods for generic collections.\\nWhere possible, compare this to a standard/built-in shuffling procedure.\\nOne iteration of the riffle shuffle is defined as:\\n\\nOne iteration of the overhand shuffle is defined as:\\n\\nImplement other methods described in the Wikipedia\\narticle:   card shuffling.\\nAllow for \""human errors\"" of imperfect cutting and interleaving.\\n\\n","\\n#include <time.h>\\n#include <algorithm>\\n#include <iostream>\\n#include <string>\\n#include <deque>\\n\\n\\nclass riffle\\n{\\npublic:\\n    void shuffle( std::deque<int>* v, int tm )\\n    {\\n        std::deque<int> tmp;\\n	bool fl;\\n	size_t len;\\n	std::deque<int>::iterator it;\\n\\n	copyTo( v, &tmp );\\n\\n	for( int t = 0; t < tm; t++ )\\n	{\\n	    std::deque<int> lHand( rand() % ( tmp.size() / 3 ) + ( tmp.size() >> 1 ) ), rHand( tmp.size() - lHand.size() );\\n\\n	    std::copy( tmp.begin(), tmp.begin() + lHand.size(), lHand.begin() );\\n	    std::copy( tmp.begin() + lHand.size(), tmp.end(), rHand.begin() );\\n	    tmp.clear();\\n\\n	    while( lHand.size() && rHand.size() )\\n	    {\\n		fl = rand() % 10 < 5;\\n		if( fl )\\n    		    len = 1 + lHand.size() > 3 ? rand() % 3 + 1 : rand() % ( lHand.size() ) + 1;\\n		else\\n		    len = 1 + rHand.size() > 3 ? rand() % 3 + 1 : rand() % ( rHand.size() ) + 1;\\n\\n		while( len )\\n		{\\n		    if( fl ) \\n		    {\\n			tmp.push_front( *lHand.begin() );\\n			lHand.erase( lHand.begin() );\\n		    }\\n		    else \\n		    {\\n			tmp.push_front( *rHand.begin() );\\n			rHand.erase( rHand.begin() );\\n		    }\\n		    len--;\\n		}\\n	    }\\n\\n	    if( lHand.size() < 1 ) \\n	    {\\n		for( std::deque<int>::iterator x = rHand.begin(); x != rHand.end(); x++ )\\n		    tmp.push_front( *x );\\n	    }\\n	    if( rHand.size() < 1 ) \\n	    {\\n		for( std::deque<int>::iterator x = lHand.begin(); x != lHand.end(); x++ )\\n		    tmp.push_front( *x );\\n	    }\\n	}\\n	copyTo( &tmp, v );\\n    }\\nprivate:\\n    void copyTo( std::deque<int>* a, std::deque<int>* b )\\n    {\\n	for( std::deque<int>::iterator x = a->begin(); x != a->end(); x++ )\\n	    b->push_back( *x );\\n	a->clear();\\n    }\\n};\\n\\nclass overhand\\n{\\npublic:\\n    void shuffle( std::deque<int>* v, int tm )\\n    {\\n	std::deque<int> tmp;\\n	bool top;\\n	for( int t = 0; t < tm; t++ )\\n	{\\n	    while( v->size() )\\n	    {\\n		size_t len = rand() % ( v->size() ) + 1;\\n		top = rand() % 10 < 5;\\n		while( len )\\n		{\\n		    if( top ) tmp.push_back( *v->begin() );\\n		    else tmp.push_front( *v->begin() );\\n		    v->erase( v->begin() );\\n		    len--;\\n		}\\n	    }\\n	    for( std::deque<int>::iterator x = tmp.begin(); x != tmp.end(); x++ )\\n		v->push_back( *x );\\n\\n	    tmp.clear();\\n	}\\n    }\\n};\\n\\n// global - just to make things simpler ---------------------------------------------------\\nstd::deque<int> cards;\\n\\nvoid fill()\\n{\\n    cards.clear();\\n    for( int x = 0; x < 20; x++ )\\n	cards.push_back( x + 1 );\\n}\\n\\nvoid display( std::string t )\\n{\\n    std::cout << t << \""\\n\"";\\n    for( std::deque<int>::iterator x = cards.begin(); x != cards.end(); x++ )\\n	std::cout << *x << \"" \"";\\n    std::cout << \""\\n\\n\"";\\n}\\n\\nint main( int argc, char* argv[] )\\n{\\n    srand( static_cast<unsigned>( time( NULL ) ) );\\n    riffle r; overhand o;	\\n\\n    fill(); r.shuffle( &cards, 10 ); display( \""RIFFLE\"" );\\n    fill(); o.shuffle( &cards, 10 ); display( \""OVERHAND\"" );\\n    fill(); std::random_shuffle( cards.begin(), cards.end() ); display( \""STD SHUFFLE\"" );\\n\\n    return 0;\\n}\\n"
"C++","Cartesian_product_of_two_or_more_lists","Show one or more idiomatic ways of generating the Cartesian product of two arbitrary lists in your language.\\nDemonstrate that your function/method correctly returns:\\nand, in contrast:\\nAlso demonstrate, using your function/method, that the product of an empty list with any other list is empty.\\nFor extra credit, show or write a function returning the n-ary product of an arbitrary number of lists, each of arbitrary length. Your function might, for example, accept a single argument which is itself a list of lists, and return the n-ary product of those lists.\\nUse your n-ary Cartesian product function to show the following products:\\n\\n","\\n#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n\\nvoid print(const std::vector& v) {\\n  std::cout << \""{ \"";\\n  for (const auto& p : v) {\\n    std::cout << \""(\"";\\n    for (const auto& e : p) {\\n      std::cout << e << \"" \"";\\n    }\\n    std::cout << \"") \"";\\n  }\\n  std::cout << \""}\"" << std::endl;\\n}\\n\\nauto product(const std::vector& lists) {\\n  std::vector result;\\n  if (std::find_if(std::begin(lists), std::end(lists), \\n    [](auto e) -> bool { return e.size() == 0; }) != std::end(lists)) {\\n    return result;\\n  }\\n  for (auto& e : lists[0]) {\\n    result.push_back({ e });\\n  }\\n  for (size_t i = 1; i < lists.size(); ++i) {\\n    std::vector temp;\\n    for (auto& e : result) {\\n      for (auto f : lists[i]) {\\n        auto e_tmp = e;\\n        e_tmp.push_back(f);\\n        temp.push_back(e_tmp);\\n      }\\n    }\\n    result = temp;\\n  }\\n  return result;\\n}\\n\\nint main() {\\n  std::vector prods[] = {\\n    { { 1, 2 }, { 3, 4 } },\\n    { { 3, 4 }, { 1, 2} },\\n    { { 1, 2 }, { } },\\n    { { }, { 1, 2 } },\\n    { { 1776, 1789 }, { 7, 12 }, { 4, 14, 23 }, { 0, 1 } },\\n    { { 1, 2, 3 }, { 30 }, { 500, 100 } },\\n    { { 1, 2, 3 }, { }, { 500, 100 } }\\n  };\\n  for (const auto& p : prods) {\\n    print(product(p));\\n  }\\n  std::cin.ignore();\\n  std::cin.get();\\n  return 0;\\n}"
"C++","Case-sensitivity_of_identifiers","Three dogs (Are there three dogs or one dog?) is a code snippet used to illustrate the lettercase sensitivity of the programming language. For a case-sensitive language, the identifiers dog, Dog and DOG are all different and we should get the output:\\nFor a language that is lettercase insensitive, we get the following output:\\n\\n\\n11l identifiers are case sensitive.\\ncase insensitive\\nOutput:\\nTranslation of Algol W. Agena is case sensitive, as this example demonstrates. Tested with Agena 2.9.5 Win32\\n","#include <iostream>\\n#include <string>\\nusing namespace std;\\n\\nint main() {\\n    string dog = \""Benjamin\"", Dog = \""Samba\"", DOG = \""Bernie\"";\\n    \\n    cout << \""The three dogs are named \"" << dog << \"", \"" << Dog << \"", and \"" << DOG << endl;\\n}"
"C++","Casting_out_nines","\\nWrite a procedure (say \\n\\n\\n\\n\\n\\nc\\no\\n9\\n\\n\\n(\\nx\\n)\\n\\n\\n{\\displaystyle {\\mathit {co9}}(x)}\\n\\n) which implements Casting Out Nines as described by returning the checksum for \\n\\n\\n\\nx\\n\\n\\n{\\displaystyle x}\\n\\n. Demonstrate the procedure using the examples given there, or others you may consider lucky.\\nNotwithstanding past Intel microcode errors, checking computer calculations like this would not be sensible. To find a computer use for your procedure:\\nDemonstrate that your procedure can be used to generate or filter a range of numbers with the property \\n\\n\\n\\n\\n\\nc\\no\\n9\\n\\n\\n(\\nk\\n)\\n=\\n\\n\\nc\\no\\n9\\n\\n\\n(\\n\\nk\\n\\n2\\n\\n\\n)\\n\\n\\n{\\displaystyle {\\mathit {co9}}(k)={\\mathit {co9}}(k^{2})}\\n\\n and show that this subset is a small proportion of the range and contains all the Kaprekar in the range.\\nConsidering this MathWorld page, produce a efficient algorithm based on the more mathematical treatment of Casting Out Nines, and realizing:\\nDemonstrate your algorithm by generating or filtering a range of numbers with the property \\n\\n\\n\\nk\\n%\\n(\\n\\n\\nB\\na\\ns\\ne\\n\\n\\n−\\n1\\n)\\n==\\n(\\n\\nk\\n\\n2\\n\\n\\n)\\n%\\n(\\n\\n\\nB\\na\\ns\\ne\\n\\n\\n−\\n1\\n)\\n\\n\\n{\\displaystyle k\\%({\\mathit {Base}}-1)==(k^{2})\\%({\\mathit {Base}}-1)}\\n\\n and show that this subset is a small proportion of the range and contains all the Kaprekar in the range.\\n\\nThe program uses two ASSIST macros (XDECO,XPRNT) to keep the code as short as possible.\\n","// Casting Out Nines\\n//\\n// Nigel Galloway. June 24th., 2012\\n//\\n#include <iostream>\\nint main() {\\n	int Base = 10;\\n	const int N = 2;\\n	int c1 = 0;\\n	int c2 = 0;\\n	for (int k=1; k\\n{{out|Produces}}\\n<pre>\\n1 9 10 18 19 27 28 36 37 45 46 54 55 63 64 72 73 81 82 90 91 99\\nTrying 22 numbers instead of 99 numbers saves 77.7778%\\n"
"C++","Casting_out_nines","\\nWrite a procedure (say \\n\\n\\n\\n\\n\\nc\\no\\n9\\n\\n\\n(\\nx\\n)\\n\\n\\n{\\displaystyle {\\mathit {co9}}(x)}\\n\\n) which implements Casting Out Nines as described by returning the checksum for \\n\\n\\n\\nx\\n\\n\\n{\\displaystyle x}\\n\\n. Demonstrate the procedure using the examples given there, or others you may consider lucky.\\nNotwithstanding past Intel microcode errors, checking computer calculations like this would not be sensible. To find a computer use for your procedure:\\nDemonstrate that your procedure can be used to generate or filter a range of numbers with the property \\n\\n\\n\\n\\n\\nc\\no\\n9\\n\\n\\n(\\nk\\n)\\n=\\n\\n\\nc\\no\\n9\\n\\n\\n(\\n\\nk\\n\\n2\\n\\n\\n)\\n\\n\\n{\\displaystyle {\\mathit {co9}}(k)={\\mathit {co9}}(k^{2})}\\n\\n and show that this subset is a small proportion of the range and contains all the Kaprekar in the range.\\nConsidering this MathWorld page, produce a efficient algorithm based on the more mathematical treatment of Casting Out Nines, and realizing:\\nDemonstrate your algorithm by generating or filtering a range of numbers with the property \\n\\n\\n\\nk\\n%\\n(\\n\\n\\nB\\na\\ns\\ne\\n\\n\\n−\\n1\\n)\\n==\\n(\\n\\nk\\n\\n2\\n\\n\\n)\\n%\\n(\\n\\n\\nB\\na\\ns\\ne\\n\\n\\n−\\n1\\n)\\n\\n\\n{\\displaystyle k\\%({\\mathit {Base}}-1)==(k^{2})\\%({\\mathit {Base}}-1)}\\n\\n and show that this subset is a small proportion of the range and contains all the Kaprekar in the range.\\n\\nThe program uses two ASSIST macros (XDECO,XPRNT) to keep the code as short as possible.\\n","// Casting Out Nines Generator - Compiles with gcc4.6, MSVC 11, and CLang3\\n//\\n// Nigel Galloway. June 24th., 2012\\n//\\n#include <iostream>\\n#include <vector>\\nstruct ran {\\n	const int base;\\n	std::vector<int> rs;\\n	ran(const int base) : base(base) { for (int nz=0; nzbase)\\n	,_next((_ran->base-1)*_x + _ran->rs[_r])\\n	{\\n		while (operator*() < start) operator++();\\n	}\\n	const co9& operator++() {\\n		const int oldr = _r;\\n		_r = ++_r%_ran->rs.size();\\n		if (_rbase-1)*_x + _ran->rs[_r];\\n		return *this;\\n	}\\n};\\n\\nint main() {\\n	ran r(10);\\n	for (int i : co9(1,99,&r)) { std::cout << i << ' '; }\\n	return 0;\\n}"
"C++","Casting_out_nines","\\nWrite a procedure (say \\n\\n\\n\\n\\n\\nc\\no\\n9\\n\\n\\n(\\nx\\n)\\n\\n\\n{\\displaystyle {\\mathit {co9}}(x)}\\n\\n) which implements Casting Out Nines as described by returning the checksum for \\n\\n\\n\\nx\\n\\n\\n{\\displaystyle x}\\n\\n. Demonstrate the procedure using the examples given there, or others you may consider lucky.\\nNotwithstanding past Intel microcode errors, checking computer calculations like this would not be sensible. To find a computer use for your procedure:\\nDemonstrate that your procedure can be used to generate or filter a range of numbers with the property \\n\\n\\n\\n\\n\\nc\\no\\n9\\n\\n\\n(\\nk\\n)\\n=\\n\\n\\nc\\no\\n9\\n\\n\\n(\\n\\nk\\n\\n2\\n\\n\\n)\\n\\n\\n{\\displaystyle {\\mathit {co9}}(k)={\\mathit {co9}}(k^{2})}\\n\\n and show that this subset is a small proportion of the range and contains all the Kaprekar in the range.\\nConsidering this MathWorld page, produce a efficient algorithm based on the more mathematical treatment of Casting Out Nines, and realizing:\\nDemonstrate your algorithm by generating or filtering a range of numbers with the property \\n\\n\\n\\nk\\n%\\n(\\n\\n\\nB\\na\\ns\\ne\\n\\n\\n−\\n1\\n)\\n==\\n(\\n\\nk\\n\\n2\\n\\n\\n)\\n%\\n(\\n\\n\\nB\\na\\ns\\ne\\n\\n\\n−\\n1\\n)\\n\\n\\n{\\displaystyle k\\%({\\mathit {Base}}-1)==(k^{2})\\%({\\mathit {Base}}-1)}\\n\\n and show that this subset is a small proportion of the range and contains all the Kaprekar in the range.\\n\\nThe program uses two ASSIST macros (XDECO,XPRNT) to keep the code as short as possible.\\n","struct ran {\\n	const int base;\\n	std::vector<int> rs;\\n	ran(const int base) : base(base) { for (int nz=0; nz\\nChanging main:\\nint main() {\\n	ran r(16);\\n	for (int i : co9(1,255,&r)) { std::cout << i << ' '; }\\n	return 0;\\n}\\n{{out|Produces}}\\n<pre>\\n1 6 10 15 16 21 25 30 31 36 40 45 46 51 55 60 61 66 70 75 76 81 85 90 91 96 100 105 106 111 115 120 121 126 130 135 136 141 145 150 151 156 160 165 166 171 175 180 181 186 190 195 196 201 205 210 211 216 220 225 226 231 235 240 241 246 250 255 \\n"
"C++","Casting_out_nines","\\nWrite a procedure (say \\n\\n\\n\\n\\n\\nc\\no\\n9\\n\\n\\n(\\nx\\n)\\n\\n\\n{\\displaystyle {\\mathit {co9}}(x)}\\n\\n) which implements Casting Out Nines as described by returning the checksum for \\n\\n\\n\\nx\\n\\n\\n{\\displaystyle x}\\n\\n. Demonstrate the procedure using the examples given there, or others you may consider lucky.\\nNotwithstanding past Intel microcode errors, checking computer calculations like this would not be sensible. To find a computer use for your procedure:\\nDemonstrate that your procedure can be used to generate or filter a range of numbers with the property \\n\\n\\n\\n\\n\\nc\\no\\n9\\n\\n\\n(\\nk\\n)\\n=\\n\\n\\nc\\no\\n9\\n\\n\\n(\\n\\nk\\n\\n2\\n\\n\\n)\\n\\n\\n{\\displaystyle {\\mathit {co9}}(k)={\\mathit {co9}}(k^{2})}\\n\\n and show that this subset is a small proportion of the range and contains all the Kaprekar in the range.\\nConsidering this MathWorld page, produce a efficient algorithm based on the more mathematical treatment of Casting Out Nines, and realizing:\\nDemonstrate your algorithm by generating or filtering a range of numbers with the property \\n\\n\\n\\nk\\n%\\n(\\n\\n\\nB\\na\\ns\\ne\\n\\n\\n−\\n1\\n)\\n==\\n(\\n\\nk\\n\\n2\\n\\n\\n)\\n%\\n(\\n\\n\\nB\\na\\ns\\ne\\n\\n\\n−\\n1\\n)\\n\\n\\n{\\displaystyle k\\%({\\mathit {Base}}-1)==(k^{2})\\%({\\mathit {Base}}-1)}\\n\\n and show that this subset is a small proportion of the range and contains all the Kaprekar in the range.\\n\\nThe program uses two ASSIST macros (XDECO,XPRNT) to keep the code as short as possible.\\n","int main() {\\n	ran r(16);\\n	for (int i : co9(1,255,&r)) { std::cout << i << ' '; }\\n	return 0;\\n}"
"C++","Casting_out_nines","\\nWrite a procedure (say \\n\\n\\n\\n\\n\\nc\\no\\n9\\n\\n\\n(\\nx\\n)\\n\\n\\n{\\displaystyle {\\mathit {co9}}(x)}\\n\\n) which implements Casting Out Nines as described by returning the checksum for \\n\\n\\n\\nx\\n\\n\\n{\\displaystyle x}\\n\\n. Demonstrate the procedure using the examples given there, or others you may consider lucky.\\nNotwithstanding past Intel microcode errors, checking computer calculations like this would not be sensible. To find a computer use for your procedure:\\nDemonstrate that your procedure can be used to generate or filter a range of numbers with the property \\n\\n\\n\\n\\n\\nc\\no\\n9\\n\\n\\n(\\nk\\n)\\n=\\n\\n\\nc\\no\\n9\\n\\n\\n(\\n\\nk\\n\\n2\\n\\n\\n)\\n\\n\\n{\\displaystyle {\\mathit {co9}}(k)={\\mathit {co9}}(k^{2})}\\n\\n and show that this subset is a small proportion of the range and contains all the Kaprekar in the range.\\nConsidering this MathWorld page, produce a efficient algorithm based on the more mathematical treatment of Casting Out Nines, and realizing:\\nDemonstrate your algorithm by generating or filtering a range of numbers with the property \\n\\n\\n\\nk\\n%\\n(\\n\\n\\nB\\na\\ns\\ne\\n\\n\\n−\\n1\\n)\\n==\\n(\\n\\nk\\n\\n2\\n\\n\\n)\\n%\\n(\\n\\n\\nB\\na\\ns\\ne\\n\\n\\n−\\n1\\n)\\n\\n\\n{\\displaystyle k\\%({\\mathit {Base}}-1)==(k^{2})\\%({\\mathit {Base}}-1)}\\n\\n and show that this subset is a small proportion of the range and contains all the Kaprekar in the range.\\n\\nThe program uses two ASSIST macros (XDECO,XPRNT) to keep the code as short as possible.\\n","int main() {\\n	ran r(17);\\n	for (int i : co9(1,288,&r)) { std::cout << i << ' '; }\\n	return 0;\\n}"
"C++","Catalan_numbers/Pascal's_triangle","Print out the first   15   Catalan numbers by extracting them from Pascal's triangle.\\n\\nPascal's triangle\\n\\n","// Generate Catalan Numbers\\n//\\n// Nigel Galloway: June 9th., 2012\\n//\\n#include <iostream>\\nint main() {\\n  const int N = 15;\\n  int t[N+2] = {0,1};\\n  for(int i = 1; i<=N; i++){\\n    for(int j = i; j>1; j--) t[j] = t[j] + t[j-1];\\n    t[i+1] = t[i];\\n    for(int j = i+1; j>1; j--) t[j] = t[j] + t[j-1];\\n    std::cout << t[i+1] - t[i] << \"" \"";\\n  }\\n  return 0;\\n}"
"C++","Catamorphism","Reduce is a function or method that is used to take the values in an array or a list and apply a function to successive members of the list to produce (or reduce them to), a single value.\\n\\nShow how reduce (or foldl or foldr etc), work (or would be implemented) in your language.\\n\\n\\n","#include <iostream>\\n#include <numeric>\\n#include <functional>\\n#include <vector>\\n\\nint main() {\\n	std::vector<int> nums = { 1, 2, 3, 4, 5 };\\n	auto nums_added = std::accumulate(std::begin(nums), std::end(nums), 0, std::plus<int>());\\n	auto nums_other = std::accumulate(std::begin(nums), std::end(nums), 0, [](const int& a, const int& b) {\\n		return a + 2 * b;\\n	});\\n	std::cout << \""nums_added: \"" << nums_added << std::endl;\\n	std::cout << \""nums_other: \"" << nums_other << std::endl;\\n}"
"C++","Chaos_game","The Chaos Game is a method of generating the attractor of an iterated function system (IFS). One of the best-known and simplest examples creates a fractal, using a polygon and an initial point selected at random.\\n\\nPlay the Chaos Game using the corners of an equilateral triangle as the reference points. Add a starting point at random (preferably inside the triangle). Then add the next point halfway between the starting point and one of the reference points. This reference point is chosen at random.\\nAfter a sufficient number of iterations, the image of a Sierpinski Triangle should emerge.\\n\\n\\nThis should require minimal adaptation to work with any of the older Microsoft-style BASICs. Users of other dialects will need to replace lines 10 and 150 with the appropriate statements to select a graphics output mode (if necessary) and to plot a pixel at x,y in colour v; they should also add LET throughout and 170 END if their dialects require those things.\\nAdapted from the code given above.\\nAdapted from the other BASIC versions. Monochrome and low-resolution, of course. Works with only 1k of RAM. If you like, you can try changing line 30 to go round the loop a different number of times.\\nNote that ZX81 BASIC does not have an explicit computed GOTO; we can, however, actually compute the value of an expression and then GOTO it as a line number.\\n","\\n#include <windows.h>\\n#include <ctime>\\n#include <string>\\n#include <iostream>\\n \\nconst int BMP_SIZE = 600;\\n\\nclass myBitmap {\\npublic:\\n    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}\\n    ~myBitmap() {\\n        DeleteObject( pen ); DeleteObject( brush );\\n        DeleteDC( hdc ); DeleteObject( bmp );\\n    }\\n    bool create( int w, int h ) {\\n        BITMAPINFO bi;\\n        ZeroMemory( &bi, sizeof( bi ) );\\n        bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );\\n        bi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;\\n        bi.bmiHeader.biCompression = BI_RGB;\\n        bi.bmiHeader.biPlanes      = 1;\\n        bi.bmiHeader.biWidth       =  w;\\n        bi.bmiHeader.biHeight      = -h;\\n \\n        HDC dc = GetDC( GetConsoleWindow() );\\n        bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );\\n        if( !bmp ) return false;\\n \\n        hdc = CreateCompatibleDC( dc );\\n        SelectObject( hdc, bmp );\\n        ReleaseDC( GetConsoleWindow(), dc );\\n \\n        width = w; height = h;\\n        return true;\\n    }\\n    void clear( BYTE clr = 0 ) {\\n        memset( pBits, clr, width * height * sizeof( DWORD ) );\\n    }\\n    void setBrushColor( DWORD bClr ) {\\n        if( brush ) DeleteObject( brush );\\n        brush = CreateSolidBrush( bClr );\\n        SelectObject( hdc, brush );\\n    }\\n    void setPenColor( DWORD c ) {\\n        clr = c; createPen();\\n    }\\n    void setPenWidth( int w ) {\\n        wid = w; createPen();\\n    }\\n    void saveBitmap( std::string path ) {\\n        BITMAPFILEHEADER fileheader;\\n        BITMAPINFO       infoheader;\\n        BITMAP           bitmap;\\n        DWORD            wb;\\n \\n        GetObject( bmp, sizeof( bitmap ), &bitmap );\\n        DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];\\n \\n        ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );\\n        ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );\\n        ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );\\n \\n        infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;\\n        infoheader.bmiHeader.biCompression = BI_RGB;\\n        infoheader.bmiHeader.biPlanes = 1;\\n        infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );\\n        infoheader.bmiHeader.biHeight = bitmap.bmHeight;\\n        infoheader.bmiHeader.biWidth = bitmap.bmWidth;\\n        infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );\\n \\n        fileheader.bfType    = 0x4D42;\\n        fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );\\n        fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;\\n \\n        GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );\\n \\n        HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );\\n        WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );\\n        WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );\\n        WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );\\n        CloseHandle( file );\\n \\n        delete [] dwpBits;\\n    }\\n    HDC getDC() const     { return hdc; }\\n    int getWidth() const  { return width; }\\n    int getHeight() const { return height; }\\nprivate:\\n    void createPen() {\\n        if( pen ) DeleteObject( pen );\\n        pen = CreatePen( PS_SOLID, wid, clr );\\n        SelectObject( hdc, pen );\\n    }\\n    HBITMAP bmp; HDC    hdc;\\n    HPEN    pen; HBRUSH brush;\\n    void    *pBits; int    width, height, wid;\\n    DWORD    clr;\\n};\\nclass chaos {\\npublic:\\n    void start() {\\n        POINT org;\\n        fillPts(); initialPoint( org ); initColors();\\n        int cnt = 0, i;\\n        bmp.create( BMP_SIZE, BMP_SIZE );\\n        bmp.clear( 255 );\\n\\n        while( cnt++ < 1000000 ) {\\n            switch( rand() % 6 ) {\\n                case 0: case 3: i = 0; break;\\n                case 1: case 5: i = 1; break;\\n                case 2: case 4: i = 2;\\n            }\\n            setPoint( org, myPoints[i], i );\\n        }\\n        // --- edit this path --- //\\n        bmp.saveBitmap( \""F:/st.bmp\"" );\\n    }\\nprivate:\\n    void setPoint( POINT &o, POINT v, int i ) {\\n        POINT z;\\n        o.x = ( o.x + v.x ) >> 1; o.y = ( o.y + v.y ) >> 1;\\n        SetPixel( bmp.getDC(), o.x, o.y, colors[i] );\\n    }\\n    void fillPts() {\\n        int a = BMP_SIZE - 1;\\n        myPoints[0].x = BMP_SIZE >> 1; myPoints[0].y = 0;\\n        myPoints[1].x = 0; myPoints[1].y = myPoints[2].x = myPoints[2].y = a;\\n    }\\n    void initialPoint( POINT& p ) {\\n        p.x = ( BMP_SIZE >> 1 ) + rand() % 2 ? rand() % 30 + 10 : -( rand() % 30 + 10 );\\n        p.y = ( BMP_SIZE >> 1 ) + rand() % 2 ? rand() % 30 + 10 : -( rand() % 30 + 10 );\\n    }\\n    void initColors() {\\n        colors[0] = RGB( 255, 0, 0 );\\n        colors[1] = RGB( 0, 255, 0 );\\n        colors[2] = RGB( 0, 0, 255 );\\n    }\\n    \\n    myBitmap bmp;\\n    POINT myPoints[3];\\n    COLORREF colors[3];\\n};\\nint main( int argc, char* argv[] ) {\\n    srand( ( unsigned )time( 0 ) );\\n    chaos c; c.start();\\n    return 0;\\n}\\n"
"C++","Character_codes","\\nGiven a character value in your language, print its code   (could be ASCII code, Unicode code, or whatever your language uses).\\n\\nThe character   'a'   (lowercase letter A)   has a code of 97 in ASCII   (as well as Unicode, as ASCII forms the beginning of Unicode).\\nConversely, given a code, print out the corresponding character.\\n\\nS/360 architecture and EBCDIC was born together.\\nIn EBCDIC, the character 'a' (lowercase letter A) has a code of 129 in decimal and '81'x in hexadecimal.\\nTo perform conversion, we use IC (insert character) and STC (store character) opcodes.\\n","#include <iostream>\\n\\nint main() {\\n  std::cout << (int)'a' << std::endl; // prints \""97\""\\n  std::cout << (char)97 << std::endl; // prints \""a\""\\n  return 0;\\n}"
"C++","Chebyshev_coefficients","Chebyshev coefficients are the basis of polynomial approximations of functions. Write a program to generate Chebyshev coefficients.Calculate coefficients: cosine function, 10 coefficients, interval 0 1C99.\\nBased on the C99 implementation above. The main improvement is that, because C++ containers handle memory for us, we can use a more functional style.\\nThe two overloads of cheb_coef show a useful idiom for working with C++ templates; the non-template code, which does all the mathematical work, can be placed in a source file so that it is compiled only once (reducing code bloat from repeating substantial blocks of code). The template function is a minimal wrapper to call the non-template implementation.\\nThe wrapper class ChebyshevApprox_ supports very terse user code.\\nThis imperative code retains some of the style of the original C version.\\n","\\n#include <iostream>\\n#include <iomanip>\\n#include <string>\\n#include <cmath>\\n#include <utility>\\n#include <vector>\\n\\nusing namespace std;\\n\\nstatic const double PI = acos(-1.0);\\n\\ndouble affine_remap(const pair& from, double x, const pair& to)\\n{\\n	return to.first + (x - from.first) * (to.second - to.first) / (from.second - from.first);\\n}\\n\\nvector<double> cheb_coef(const vector<double>& f_vals)\\n{\\n	const int n = f_vals.size();\\n	const double theta = PI / n;\\n	vector<double> retval(n, 0.0);\\n	for (int ii = 0; ii < n; ++ii)\\n	{\\n		double f = f_vals[ii] * 2.0 / n;\\n		const double phi = (ii + 0.5) * theta;\\n		double c1 = cos(phi), s1 = sin(phi);\\n		double c = 1.0, s = 0.0;\\n		for (int j = 0; j < n; j++)\\n		{\\n			retval[j] += f * c;\\n			// update c -> cos(j*phi) for next value of j\\n			const double cNext = c * c1 - s * s1;\\n			s = c * s1 + s * c1;\\n			c = cNext;\\n		}\\n	}\\n	return retval;\\n}\\n\\ntemplate vector<double> cheb_coef(const F_& func, int n, const pair& domain)\\n{\\n	auto remap = [&](double x){return affine_remap({ -1.0, 1.0 }, x, domain); };\\n	const double theta = PI / n;\\n	vector<double> fVals(n);\\n	for (int ii = 0; ii < n; ++ii)\\n		fVals[ii] = func(remap(cos((ii + 0.5) * theta)));\\n	return cheb_coef(fVals);\\n}\\n\\ndouble cheb_eval(const vector<double>& coef, double x)\\n{\\n	double a = 1.0, b = x, c;\\n	double retval = 0.5 * coef[0] + b * coef[1];\\n	for (auto pc = coef.begin() + 2; pc != coef.end(); a = b, b = c, ++pc)\\n	{\\n		c = 2.0 * b * x - a;\\n		retval += (*pc) * c;\\n	}\\n	return retval;\\n}\\ndouble cheb_eval(const vector<double>& coef, const pair& domain, double x)\\n{\\n	return cheb_eval(coef, affine_remap(domain, x, { -1.0, 1.0 }));\\n}\\n\\nstruct ChebyshevApprox_\\n{\\n	vector<double> coeffs_;\\n	pair domain_;\\n\\n	double operator()(double x) const { return cheb_eval(coeffs_, domain_, x); }\\n\\n	template ChebyshevApprox_\\n		(const F_& func,\\n		int n,\\n		const pair& domain)\\n		:\\n		coeffs_(cheb_coef(func, n, domain)),\\n		domain_(domain)\\n	{ }\\n};\\n\\n\\nint main(void)\\n{\\n	static const int N = 10;\\n	ChebyshevApprox_ fApprox(cos, N, { 0.0, 1.0 });\\n	cout << \""Coefficients: \"" << setprecision(14);\\n	for (const auto& c : fApprox.coeffs_)\\n		cout << \""\\t\"" << c << \""\\n\"";\\n\\n	for (;;)\\n	{\\n		cout << \""Enter x, or non-numeric value to quit:\\n\"";\\n		double x;\\n		if (!(cin >> x))\\n			return 0;\\n		cout << \""True value: \\t\"" << cos(x) << \""\\n\"";\\n		cout << \""Approximate: \\t\"" << fApprox(x) << \""\\n\"";\\n	}\\n}\\n"
"C++","Check_that_file_exists","Verify that a file called     input.txt     and   a directory called     docs     exist.\\n\\nThis should be done twice:  \\n\\nOptional criteria (May 2015):   verify it works with:\\n\\nThis example should work with any Ada 95 compiler.\\nThis example should work with any Ada 2005 compiler.\\nThe stat function returns a System.Stat object for an existing file or directory, or null if it can't be found.\\nUses the Algol 68G specific \""file is directory\"" procedure to test for the existence of directories.\\n(macOS JavaScript for Automation)\\n","#include \""boost/filesystem.hpp\""\\n#include <string>\\n#include <iostream>\\n\\nvoid testfile(std::string name)\\n{\\n  boost::filesystem::path file(name);\\n  if (exists(file))\\n  {\\n    if (is_directory(file))\\n      std::cout << name << \"" is a directory.\\n\"";\\n    else\\n      std::cout << name << \"" is a non-directory file.\\n\"";\\n  }\\n  else\\n    std::cout << name << \"" does not exist.\\n\"";\\n}\\n\\nint main()\\n{\\n  testfile(\""input.txt\"");\\n  testfile(\""docs\"");\\n  testfile(\""/input.txt\"");\\n  testfile(\""/docs\"");\\n}"
"C++","Checkpoint_synchronization","The checkpoint synchronization is a problem of synchronizing multiple tasks. Consider a workshop where several workers (tasks) assembly details of some mechanism. When each of them completes his work they put the details together. There is no store, so a worker who finished its part first must wait for others before starting another one. Putting details together is the checkpoint at which tasks synchronize themselves before going their paths apart.\\nThe task\\nImplement checkpoint synchronization in your language.\\nMake sure that the solution is race condition-free. Note that a straightforward solution based on events is exposed to race condition. Let two tasks A and B need to be synchronized at a checkpoint. Each signals its event (EA and EB correspondingly), then waits for the AND-combination of the events (EA&EB) and resets its event. Consider the following scenario: A signals EA first and gets blocked waiting for EA&EB. Then B signals EB and loses the processor. Then A is released (both events are signaled) and resets EA. Now if B returns and enters waiting for EA&EB, it gets lost.\\nWhen a worker is ready it shall not continue before others finish. A typical implementation bug is when a worker is counted twice within one working cycle causing its premature completion. This happens when the quickest worker serves its cycle two times while the laziest one is lagging behind.\\nIf you can, implement workers joining and leaving.\\nSample output:\\nOutput:\\nUsing OpenMP. Compiled with gcc -Wall -fopenmp.\\n\\n{{out}\\nWith a fixed number of workers, this would be very straightforward in Clojure by using a CyclicBarrier from java.util.concurrent.\\nSo to make it interesting, this version supports workers dynamically joining and parting, and uses the new (2013) core.async library to use Go-like channels.\\nAlso, each worker passes a value to the checkpoint, so that some combine function could consume them once they're all received.\\n","#include <iostream>\\n#include <chrono>\\n#include <atomic>\\n#include <mutex>\\n#include <random>\\n#include <thread>\\n\\nstd::mutex cout_lock;\\n\\nclass Latch\\n{\\n    std::atomic<int> semafor;\\n  public:\\n    Latch(int limit) : semafor(limit) {}\\n\\n    void wait()\\n    {\\n        semafor.fetch_sub(1);\\n        while(semafor.load() > 0)\\n            std::this_thread::yield();\\n    }\\n};\\n\\nstruct Worker\\n{\\n    static void do_work(int how_long, Latch& barrier, std::string name)\\n    {\\n        std::this_thread::sleep_for(std::chrono::milliseconds(how_long));\\n        {   std::lock_guard lock(cout_lock);\\n            std::cout << \""Worker \"" << name << \"" finished work\\n\"";   }\\n        barrier.wait();\\n        {   std::lock_guard lock(cout_lock);\\n            std::cout << \""Worker \"" << name << \"" finished assembly\\n\"";   }\\n    }\\n};\\n\\nint main()\\n{\\n    Latch latch(5);\\n    std::mt19937 rng(std::random_device{}());\\n    std::uniform_int_distribution<> dist(300, 3000);\\n    std::thread threads[] {\\n        std::thread(&Worker::do_work, dist(rng), std::ref(latch), \""John\""),\\n        std::thread{&Worker::do_work, dist(rng), std::ref(latch), \""Henry\""},\\n        std::thread{&Worker::do_work, dist(rng), std::ref(latch), \""Smith\""},\\n        std::thread{&Worker::do_work, dist(rng), std::ref(latch), \""Jane\""},\\n        std::thread{&Worker::do_work, dist(rng), std::ref(latch), \""Mary\""},\\n    };\\n    for(auto& t: threads) t.join();\\n    std::cout << \""Assembly is finished\"";\\n}"
"C++","Chinese_remainder_theorem","Suppose   \\n\\n\\n\\n\\nn\\n\\n1\\n\\n\\n\\n\\n{\\displaystyle n_{1}}\\n\\n,   \\n\\n\\n\\n\\nn\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle n_{2}}\\n\\n,   \\n\\n\\n\\n…\\n\\n\\n{\\displaystyle \\ldots }\\n\\n,   \\n\\n\\n\\n\\nn\\n\\nk\\n\\n\\n\\n\\n{\\displaystyle n_{k}}\\n\\n   are positive integers that are pairwise co-prime.  \\nThen, for any given sequence of integers   \\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n{\\displaystyle a_{1}}\\n\\n,   \\n\\n\\n\\n\\na\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle a_{2}}\\n\\n,   \\n\\n\\n\\n…\\n\\n\\n{\\displaystyle \\dots }\\n\\n,   \\n\\n\\n\\n\\na\\n\\nk\\n\\n\\n\\n\\n{\\displaystyle a_{k}}\\n\\n,   there exists an integer   \\n\\n\\n\\nx\\n\\n\\n{\\displaystyle x}\\n\\n   solving the following system of simultaneous congruences:\\nFurthermore, all solutions   \\n\\n\\n\\nx\\n\\n\\n{\\displaystyle x}\\n\\n   of this system are congruent modulo the product,   \\n\\n\\n\\nN\\n=\\n\\nn\\n\\n1\\n\\n\\n\\nn\\n\\n2\\n\\n\\n…\\n\\nn\\n\\nk\\n\\n\\n\\n\\n{\\displaystyle N=n_{1}n_{2}\\ldots n_{k}}\\n\\n.\\n\\nWrite a program to solve a system of linear congruences by applying the   Chinese Remainder Theorem.\\nIf the system of equations cannot be solved, your program must somehow indicate this.\\n(It may throw an exception or return a special false value.)\\nSince there are infinitely many solutions, the program should return the unique solution   \\n\\n\\n\\ns\\n\\n\\n{\\displaystyle s}\\n\\n   where   \\n\\n\\n\\n0\\n≤\\ns\\n≤\\n\\nn\\n\\n1\\n\\n\\n\\nn\\n\\n2\\n\\n\\n…\\n\\nn\\n\\nk\\n\\n\\n\\n\\n{\\displaystyle 0\\leq s\\leq n_{1}n_{2}\\ldots n_{k}}\\n\\n.\\n\\nShow the functionality of this program by printing the result such that the   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n's   are   \\n\\n\\n\\n[\\n3\\n,\\n5\\n,\\n7\\n]\\n\\n\\n{\\displaystyle [3,5,7]}\\n\\n   and the   \\n\\n\\n\\na\\n\\n\\n{\\displaystyle a}\\n\\n's   are   \\n\\n\\n\\n[\\n2\\n,\\n3\\n,\\n2\\n]\\n\\n\\n{\\displaystyle [2,3,2]}\\n\\n.\\n\\nAlgorithm:   The following algorithm only applies if the   \\n\\n\\n\\n\\nn\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle n_{i}}\\n\\n's   are pairwise co-prime.\\nSuppose, as above, that a solution is required for the system of congruences:\\nAgain, to begin, the product   \\n\\n\\n\\nN\\n=\\n\\nn\\n\\n1\\n\\n\\n\\nn\\n\\n2\\n\\n\\n…\\n\\nn\\n\\nk\\n\\n\\n\\n\\n{\\displaystyle N=n_{1}n_{2}\\ldots n_{k}}\\n\\n   is defined.\\nThen a solution   \\n\\n\\n\\nx\\n\\n\\n{\\displaystyle x}\\n\\n   can be found as follows:\\nFor each   \\n\\n\\n\\ni\\n\\n\\n{\\displaystyle i}\\n\\n,   the integers   \\n\\n\\n\\n\\nn\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle n_{i}}\\n\\n   and   \\n\\n\\n\\nN\\n\\n/\\n\\n\\nn\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle N/n_{i}}\\n\\n   are co-prime.\\nUsing the   Extended Euclidean algorithm,   we can find integers   \\n\\n\\n\\n\\nr\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle r_{i}}\\n\\n   and   \\n\\n\\n\\n\\ns\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle s_{i}}\\n\\n   such that   \\n\\n\\n\\n\\nr\\n\\ni\\n\\n\\n\\nn\\n\\ni\\n\\n\\n+\\n\\ns\\n\\ni\\n\\n\\nN\\n\\n/\\n\\n\\nn\\n\\ni\\n\\n\\n=\\n1\\n\\n\\n{\\displaystyle r_{i}n_{i}+s_{i}N/n_{i}=1}\\n\\n.\\nThen, one solution to the system of simultaneous congruences is:\\nand the minimal solution,\\n\\n","#include <iostream>\\n#include <numeric>\\n#include <vector>\\n#include <execution>\\n\\nusing namespace std;\\n\\nint mulInv(int a, int b) {\\n	int b0 = b;\\n	int x0 = 0;\\n	int x1 = 1;\\n\\n	if (b == 1) {\\n		return 1;\\n	}\\n\\n	while (a > 1) {\\n		int q = a / b;\\n		int amb = a % b;\\n		a = b;\\n		b = amb;\\n\\n		int xqx = x1 - q * x0;\\n		x1 = x0;\\n		x0 = xqx;\\n	}\\n\\n	if (x1 < 0) {\\n		x1 += b0;\\n	}\\n\\n	return x1;\\n}\\n\\nint chineseRemainder(vector<int> n, vector<int> a) {\\n	int prod = std::reduce(std::execution::seq, n.begin(), n.end(), 1, [](int a, int b) { return a * b; });\\n\\n	int sm = 0;\\n	for (int i = 0; i < n.size(); i++) {\\n		int p = prod / n[i];\\n		sm += a[i] * mulInv(p, n[i])*p;\\n	}\\n\\n	return sm % prod;\\n}\\n\\nint main() {\\n	vector<int> n = { 3, 5, 7 };\\n	vector<int> a = { 2, 3, 2 };\\n\\n	cout << chineseRemainder(n,a) << endl;\\n\\n	return 0;\\n}"
"C++","Chinese_zodiac","Traditionally, the Chinese have counted years using two simultaneous cycles, one of length 10 (the \""celestial stems\"") and one of length 12 (the \""terrestrial branches\""); the combination results in a repeating 60-year pattern. Mapping the branches to twelve traditional animal deities results in the well-known \""Chinese zodiac\"", assigning each year to a given animal. For example, Saturday, January 28, 2017 CE (in the common Gregorian calendar) begins the lunisolar year of the Rooster.\\nThe celestial stems have no one-to-one mapping like that of the branches to animals; however, the five pairs of consecutive stems each belong to one of the five traditional Chinese elements (Wood, Fire, Earth, Metal, and Water). Further, one of the two years within each element's governance is associated with yin, the other with yang.\\nThus, 2017 is also the yin year of Fire. Note that since 12 is an even number, the association between animals and yin/yang doesn't change. Consecutive Years of the Rooster will cycle through the five elements, but will always be yin, despite the apparent conceptual mismatch between the male animals and the female aspect.\\nYou may optionally provide more information in the form of the year's numerical position within the 60-year cycle and/or its actual Chinese stem-branch name (in Han characters or Pinyin transliteration).\\nThus, 1984 was the year of the Wood Rat (yang), 1985 was the year of the Wood Ox (yin), and 1986 the year of the Fire Tiger (yang); 2017 - which, as already noted, is the year of the Fire Rooster (yin) - is the 34th year of the current cycle.\\nTherefore 1984 was 甲子 (jiă-zĭ, or jia3-zi3). 2017 is the 34th year of the current cycle, 丁酉 (dīng-yŏu or ding1-you3).\\n\\n","#include <iostream>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nconst string animals[]={\""Rat\"",\""Ox\"",\""Tiger\"",\""Rabbit\"",\""Dragon\"",\""Snake\"",\""Horse\"",\""Goat\"",\""Monkey\"",\""Rooster\"",\""Dog\"",\""Pig\""};\\nconst string elements[]={\""Wood\"",\""Fire\"",\""Earth\"",\""Metal\"",\""Water\""};\\n\\nstring getElement(int year)\\n{\\n    int element = floor((year-4)%10/2);\\n    return elements[element];\\n}\\n\\nstring getAnimal(int year)\\n{\\n    return animals[(year-4)%12];\\n}\\n\\nstring getYY(int year)\\n{\\n    if(year%2==0)\\n    {\\n        return \""yang\"";\\n    }\\n    else\\n    {\\n        return \""yin\"";\\n    }\\n}\\n\\nint main()\\n{\\n    int years[]={1935,1938,1968,1972,1976,2017};\\n    //the zodiac cycle didnt start until 4 CE, so years <4 shouldnt be valid\\n    for(int i=0;i<6;i++)\\n    {\\n        cout << years[i] << \"" is the year of the \"" << getElement(years[i]) << \"" \"" << getAnimal(years[i]) << \"" (\"" << getYY(years[i]) << \"").\"" << endl;\\n    }\\n    return 0;\\n}"
"C++","Circles_of_given_radius_through_two_points","Given two points on a plane and a radius, usually two circles of given radius can be drawn through the points.\\n\\n\\n\\n\\nCalculations based on the C solution.\\n","\\n#include <iostream>\\n#include <cmath>\\n#include <tuple>\\n\\nstruct point { double x, y; };\\n\\nbool operator==(const point& lhs, const point& rhs)\\n{ return std::tie(lhs.x, lhs.y) == std::tie(rhs.x, rhs.y); }\\n\\nenum result_category { NONE, ONE_COINCEDENT, ONE_DIAMETER, TWO, INFINITE };\\n\\nusing result_t = std::tuple;\\n\\ndouble distance(point l, point r)\\n{ return std::hypot(l.x - r.x, l.y - r.y); }\\n\\nresult_t find_circles(point p1, point p2, double r)\\n{\\n    point ans1 { 1/0., 1/0.}, ans2 { 1/0., 1/0.};\\n    if (p1 == p2) {\\n        if(r == 0.) return std::make_tuple(ONE_COINCEDENT, p1,   p2  );\\n        else        return std::make_tuple(INFINITE,       ans1, ans2);\\n    }\\n    point center { p1.x/2 + p2.x/2, p1.y/2 + p2.y/2};\\n    double half_distance = distance(center, p1);\\n    if(half_distance > r)      return std::make_tuple(NONE,         ans1,   ans2);\\n    if(half_distance - r == 0) return std::make_tuple(ONE_DIAMETER, center, ans2);\\n    double root = std::hypot(r, half_distance) / distance(p1, p2);\\n    ans1.x = center.x + root * (p1.y - p2.y);\\n    ans1.y = center.y + root * (p2.x - p1.x);\\n    ans2.x = center.x - root * (p1.y - p2.y);\\n    ans2.y = center.y - root * (p2.x - p1.x);\\n    return std::make_tuple(TWO, ans1, ans2);\\n}\\n\\nvoid print(result_t result, std::ostream& out = std::cout)\\n{\\n    point r1, r2; result_category res;\\n    std::tie(res, r1, r2) = result;\\n    switch(res) {\\n      case NONE:\\n        out << \""There are no solutions, points are too far away\\n\""; break;\\n      case ONE_COINCEDENT: case ONE_DIAMETER:\\n        out << \""Only one solution: \"" << r1.x << ' ' << r1.y << '\\n'; break;\\n      case INFINITE:\\n        out << \""Infinitely many circles can be drawn\\n\""; break;\\n      case TWO:\\n        out << \""Two solutions: \"" << r1.x << ' ' << r1.y << \"" and \"" << r2.x << ' ' << r2.y << '\\n'; break;\\n    }\\n}\\n\\nint main()\\n{\\n    constexpr int size = 5;\\n    const point points[size*2] = {\\n        {0.1234, 0.9876}, {0.8765, 0.2345}, {0.0000, 2.0000}, {0.0000, 0.0000},\\n        {0.1234, 0.9876}, {0.1234, 0.9876}, {0.1234, 0.9876}, {0.8765, 0.2345},\\n        {0.1234, 0.9876}, {0.1234, 0.9876}\\n    };\\n    const double radius[size] = {2., 1., 2., .5, 0.};\\n\\n    for(int i = 0; i < size; ++i)\\n        print(find_circles(points[i*2], points[i*2 + 1], radius[i]));\\n}"
"C++","Classes","In object-oriented programming class is a set (a transitive closure) of types bound by the relation of inheritance. It is said that all types derived from some base type T and the type T itself form a class T.\\nThe first type T from the class T sometimes is called the root type of the class.\\nA class of types itself, as a type, has the values and operations of its own.\\nThe operations of are usually called methods of the root type.\\nBoth operations and values are called  polymorphic.\\nA polymorphic operation (method) selects an implementation depending on the actual specific type of the polymorphic argument.\\nThe action of choice the type-specific implementation of a polymorphic operation is called dispatch. Correspondingly, polymorphic operations are often called dispatching or virtual.\\nOperations with multiple arguments and/or the results of the class are called multi-methods.\\nA further generalization of is the operation with arguments and/or results from different classes.\\n\\nA polymorphic value has a type tag indicating its specific type from the class and the corresponding specific value of that type.\\nThis type is sometimes called the most specific type of a [polymorphic] value.\\nThe type tag of the value is used in order to resolve the dispatch.\\nThe set of polymorphic values of a class is a transitive closure of the sets of values of all types from that class.\\nIn many  OO languages\\nthe type of the class of T and T itself are considered equivalent.\\nIn some languages they are distinct (like in Ada).\\nWhen class T and T are equivalent, there is no way to distinguish\\npolymorphic and specific values.\\n\\nCreate a basic class with a method, a constructor, an instance variable and how to instantiate it.\\n\\nNote that member functions in 11l by default are not polymorphic; if you want a polymorphic member function, you have to mark it as virtual. Example:\\nClass is used in many languages to provide both encapsulation, or grouping of data and actions, and type definition. Ada packages provide encapsulation or grouping while type definitions are done using the type reserved word. Types participating in inheritance are named tagged record types.\\nA package specification has the following form:\\nThe type declaration at the top of the package gives public visibility to the private tagged type My_Type. Since My_Type is declared to be private, the public has no visibility of its structure. The type must be treated as a black box. The private section of the package specification includes the actual tagged record definition. Note that the data member Variable is initialized to -12. This corresponds to a default constructor for the type.\\nThe package body must contain the implementation of the procedures and functions declared in the package specification.\\nThe Set function acts as a conversion constructor for My_Type.\\nAn instance is typically created outside the package:\\nAikido provides classes with single inheritance and multiple interface implementation. A class takes a set of constructor arguments and provides a set of public functions, operators, classes, monitors and threads.\\nThe following code is experimental. Basically ALGOL 68 is not object oriented, so the task to create (and use of) objects is tedious due to the lack of certain constructs, especially the lack of OO syntactic sugar.\\nFor further details:\\nOther examples of this experimental approach are located at pages: Life in two dimensions, Playing Cards and Stack.\\n","class MyClass\\n{\\npublic:\\n  void someMethod(); // member function = method\\n  MyClass(); // constructor\\nprivate:\\n  int variable; // member variable = instance variable\\n};\\n\\n// implementation of constructor\\nMyClass::MyClass():\\n  variable(0)\\n{\\n  // here could be more code\\n}\\n\\n// implementation of member function\\nvoid MyClass::someMethod()\\n{\\n  variable = 1; // alternatively: this->variable = 1\\n}\\n\\n// Create an instance as variable\\nMyClass instance;\\n\\n// Create an instance on free store\\nMyClass* pInstance = new MyClass;\\n// Instances allocated with new must be explicitly destroyed when not needed any more:\\ndelete pInstance;"
"C++","Classes","In object-oriented programming class is a set (a transitive closure) of types bound by the relation of inheritance. It is said that all types derived from some base type T and the type T itself form a class T.\\nThe first type T from the class T sometimes is called the root type of the class.\\nA class of types itself, as a type, has the values and operations of its own.\\nThe operations of are usually called methods of the root type.\\nBoth operations and values are called  polymorphic.\\nA polymorphic operation (method) selects an implementation depending on the actual specific type of the polymorphic argument.\\nThe action of choice the type-specific implementation of a polymorphic operation is called dispatch. Correspondingly, polymorphic operations are often called dispatching or virtual.\\nOperations with multiple arguments and/or the results of the class are called multi-methods.\\nA further generalization of is the operation with arguments and/or results from different classes.\\n\\nA polymorphic value has a type tag indicating its specific type from the class and the corresponding specific value of that type.\\nThis type is sometimes called the most specific type of a [polymorphic] value.\\nThe type tag of the value is used in order to resolve the dispatch.\\nThe set of polymorphic values of a class is a transitive closure of the sets of values of all types from that class.\\nIn many  OO languages\\nthe type of the class of T and T itself are considered equivalent.\\nIn some languages they are distinct (like in Ada).\\nWhen class T and T are equivalent, there is no way to distinguish\\npolymorphic and specific values.\\n\\nCreate a basic class with a method, a constructor, an instance variable and how to instantiate it.\\n\\nNote that member functions in 11l by default are not polymorphic; if you want a polymorphic member function, you have to mark it as virtual. Example:\\nClass is used in many languages to provide both encapsulation, or grouping of data and actions, and type definition. Ada packages provide encapsulation or grouping while type definitions are done using the type reserved word. Types participating in inheritance are named tagged record types.\\nA package specification has the following form:\\nThe type declaration at the top of the package gives public visibility to the private tagged type My_Type. Since My_Type is declared to be private, the public has no visibility of its structure. The type must be treated as a black box. The private section of the package specification includes the actual tagged record definition. Note that the data member Variable is initialized to -12. This corresponds to a default constructor for the type.\\nThe package body must contain the implementation of the procedures and functions declared in the package specification.\\nThe Set function acts as a conversion constructor for My_Type.\\nAn instance is typically created outside the package:\\nAikido provides classes with single inheritance and multiple interface implementation. A class takes a set of constructor arguments and provides a set of public functions, operators, classes, monitors and threads.\\nThe following code is experimental. Basically ALGOL 68 is not object oriented, so the task to create (and use of) objects is tedious due to the lack of certain constructs, especially the lack of OO syntactic sugar.\\nFor further details:\\nOther examples of this experimental approach are located at pages: Life in two dimensions, Playing Cards and Stack.\\n","class MyClass\\n{\\npublic:\\n  MyClass(): variable(0) {}\\n  void someMethod() { variable = 1; }\\nprivate:\\n  int variable;\\n};"
"C++","Classes","In object-oriented programming class is a set (a transitive closure) of types bound by the relation of inheritance. It is said that all types derived from some base type T and the type T itself form a class T.\\nThe first type T from the class T sometimes is called the root type of the class.\\nA class of types itself, as a type, has the values and operations of its own.\\nThe operations of are usually called methods of the root type.\\nBoth operations and values are called  polymorphic.\\nA polymorphic operation (method) selects an implementation depending on the actual specific type of the polymorphic argument.\\nThe action of choice the type-specific implementation of a polymorphic operation is called dispatch. Correspondingly, polymorphic operations are often called dispatching or virtual.\\nOperations with multiple arguments and/or the results of the class are called multi-methods.\\nA further generalization of is the operation with arguments and/or results from different classes.\\n\\nA polymorphic value has a type tag indicating its specific type from the class and the corresponding specific value of that type.\\nThis type is sometimes called the most specific type of a [polymorphic] value.\\nThe type tag of the value is used in order to resolve the dispatch.\\nThe set of polymorphic values of a class is a transitive closure of the sets of values of all types from that class.\\nIn many  OO languages\\nthe type of the class of T and T itself are considered equivalent.\\nIn some languages they are distinct (like in Ada).\\nWhen class T and T are equivalent, there is no way to distinguish\\npolymorphic and specific values.\\n\\nCreate a basic class with a method, a constructor, an instance variable and how to instantiate it.\\n\\nNote that member functions in 11l by default are not polymorphic; if you want a polymorphic member function, you have to mark it as virtual. Example:\\nClass is used in many languages to provide both encapsulation, or grouping of data and actions, and type definition. Ada packages provide encapsulation or grouping while type definitions are done using the type reserved word. Types participating in inheritance are named tagged record types.\\nA package specification has the following form:\\nThe type declaration at the top of the package gives public visibility to the private tagged type My_Type. Since My_Type is declared to be private, the public has no visibility of its structure. The type must be treated as a black box. The private section of the package specification includes the actual tagged record definition. Note that the data member Variable is initialized to -12. This corresponds to a default constructor for the type.\\nThe package body must contain the implementation of the procedures and functions declared in the package specification.\\nThe Set function acts as a conversion constructor for My_Type.\\nAn instance is typically created outside the package:\\nAikido provides classes with single inheritance and multiple interface implementation. A class takes a set of constructor arguments and provides a set of public functions, operators, classes, monitors and threads.\\nThe following code is experimental. Basically ALGOL 68 is not object oriented, so the task to create (and use of) objects is tedious due to the lack of certain constructs, especially the lack of OO syntactic sugar.\\nFor further details:\\nOther examples of this experimental approach are located at pages: Life in two dimensions, Playing Cards and Stack.\\n","class MyClass\\n{\\npublic:\\n  virtual void someMethod(); // this is polymorphic\\n  virtual ~MyClass(); // destructor\\n};"
"C++","Closures/Value_capture","Create a list of ten functions, in the simplest manner possible   (anonymous functions are encouraged),   such that the function at index    i     (you may choose to start     i     from either    0    or    1),    when run, should return the square of the index,   that is,     i  2.\\nDisplay the result of running any but the last function, to demonstrate that the function indeed remembers its value.\\n\\nDemonstrate how to create a series of independent closures based on the same template but maintain separate copies of the variable closed over.\\nIn imperative languages, one would generally use a loop with a mutable counter variable.\\nFor each function to maintain the correct number, it has to capture the value of the variable at the time it was created, rather than just a reference to the variable, which would have a different value by the time the function was run.\\nSee also: Multiple distinct objects\\nOne way to realize closures in Ada is the usage of protected objects.\\n","#include <iostream>\\n#include <functional>\\n#include <vector>\\n\\nint main() {\\n  std::vector > funcs;\\n  for (int i = 0; i < 10; i++)\\n    funcs.push_back([=]() { return i * i; });\\n  for ( std::function f : funcs ) \\n    std::cout << f( ) << std::endl ; \\n  return 0;\\n}"
"C++","Collections","\\nCollections are abstractions to represent sets of values.\\nIn statically-typed languages, the values are typically of a common data type.\\n\\nCreate a collection, and add a few values to it.\\n\\n\\nAda 95 and earlier offers arrays. Ada 2005 adds the Ada.Containers package and its children. Examples of Doubly Linked Lists and Vectors are given.\\nAda 2005 also provides hashed and ordered Maps and Sets (not shown).\\nIn Ada, arrays can be indexed on any range of discrete values. The example below creates an anonymous array indexed from -3 to -1. It initializes the three elements of the array at declaration. Then it reverses their order in the array.\\n\\nAnonymous arrays have no type associated with them that is accessible to the programmer. This means that anonymous arrays cannot be compared in the aggregate to other arrays (even those with the same index structure and contained type) or passed as a parameter to a subprogram. For these reasons, anonymous arrays are best used as singletons and global constants.\\nBecause of the limitations of anonymous arrays noted above, arrays are more typically defined in Ada as array types, as in the example below.\\nDynamic arrays can be created through the use of pointers to unconstrained arrays. While an unconstrained array's index type is defined, it does not have a pre-defined range of indices - they are specified at the time of declaration or, as would be the case in a dynamic array, at the time the memory for the array is allocated. The creation of a dynamic array is not shown here, but below is an example declaration of an unconstrained array in Ada.\\nAime collections include \""list\""s (sequences) and \""record\""s (associative arrays).\\nBoth types of collections are heterogenous and resize dynamically.\\nDeclaring a list:\\nAdding values to it:\\nRetrieving values from a list:\\nDeclaring a record:\\nAdding values to it:\\nRetrieving values from a record:\\nArrays are the closest thing to collections available as standard in Algol 68. Collections could be implemented using STRUCTs but there are none as standard. Some examples of arrays:\\nA list is an ordered collection of elements that are distinguished by their indices\\nCreating Lists\\nAccess elements in a list\\nUsing Array Notation for One-dimensional list\\nA set is an unordered collection of elements that do not contain any duplicates.\\nDefining a set:\\nAccess elements in a set:\\nNote the following limitations on sets:\\nA map is a collection of key-value pairs where each unique key maps to a single value\\nDeclaring a map:\\nAccessing a Map:\\nMap Considerations:\\nMap keys of type String are case-sensitive. Two keys that differ only by the case are considered unique and have corresponding distinct Map entries.Subsequently, the Map methods, including put, get, containsKey, and remove treat these keys as distinct.\\nBoolean, Date, DateTime, Decimal, Double, Enum, Id, Integer, Long, String, Time\\nDocumentation\\nDocumentation: http://www.autohotkey.com/docs/misc/Arrays.htm\\nStructs are not natively supported in AutoHotkey, however they are often required in DllCalls to C++ Dlls.\\nThis shows how to retrieve values from a RECT structure in AutoHotkey (from the DllCall documentation at http://www.autohotkey.com/docs/commands/DllCall.htm)\\nIn awk, the closest thing to collections would be arrays. They are created when needed at assignment\\nor by splitting a string\\nSingle elements are accessible with the bracket notation, like in C:\\nOne can iterate over the elements of an array:\\nIn BBC BASIC the only native type of 'collection' is the array; the index starts at zero and the subscript specified in the DIM is the highest value of the index. Hence in this example an array with two elements is defined:\\nWhen the objects in the collection are not simple scalar types an array of structures may be used:\\nAlthough not a native language feature, other types of collections such as linked lists may be constructed:\\nSee Arrays for basic operations on arrays, the only collection type in bc.\\nSee Also foreach\\nOne thing in C language proper that can be said to be a collection is array type.\\nAn array has a length known at compile time.\\nPlease note that c built-in pointer-arithmetic support which helps this logic. An integer may be 4 bytes, and a char 1 byte: the plus operator (+) is overloaded to multiply a incement by 4 for integer pointers and by 1 for char pointers (etc).\\nAnother construct which can be seen as a collection is a malloced array. The size of a malloced array is not known at compile time.\\nA string is another C language construct (when looked at with its standard libraries) that behaves like a collection.\\nA C language string is an array of char, and it's size may or may not be known at compile time, however a c string is terminated with a ASCII NUL (which may be stated as a constant, '\\0' or ((char)0) in the C language). The String standard library \""class\"" has many \""methods\"", however instead of being called String.method(), they are usually called strmethod().\\nArbitrarily complex data structures can be constructed, normally via language features struct and pointers. They are everywhere, but not provided by the C language itself per se.\\nC++ has a range of different collections optimized for different use cases. Note that in C++, objects of user-defined types are mostly treated just like objects of built-in types; especially there's no different treatment for collections. Thus all collections can simply be demonstrated with the built-in type int. For user-defined types, just replace int with the user-defined type. Any type which goes into a collection must be copyable and assignable (which in general is automatically the case unless you explicitly disallow it).\\nNote however that C++ collections store copies of the objects given to them, so you'll lose any polymorphic behaviour. If you need polymorphism, use a collection of pointers (or smart pointers like boost::shared_ptr).\\nThe simplest collection in C++ is the built-in array. Built-in arrays have a fixed size, and except for POD types (i.e. basically any type you culd also write in C), the members are all initialized at array creation time (if no explicit initialization is done, the default constructr is used).\\nA vector is basically a resizable array. It is optimized for adding/removing elements on the end, and fast access to elements anywhere. Inserting elements at the beginning or in the middle is possible, but in general inefficient.\\nA deque is optimized for appending and removing elements on both ends ofd the array. Accessing random elements is still efficient, but slightly less than with vector.\\nA list is optimized for insertion at an arbitrary place (provided you already have an iterator pointing to that place). Element access is efficient only in linear order.\\nA set keeps the inserted elements sorted, and also makes sure that each element occurs only once. Of course, if you want to put something into a set, it must be less-than-comparable, i.e. you must be able to compare which of two objects a and b is smaller using a<b (there's also a way to define sets with an user-defined order, in which case this restriction doesn't apply).\\nA multiset is like a set, except the same element may occur multiple times.\\nThe size of ArrayList is dynamically increased as required. ArrayLists are zero-based.\\nThe List class is the generic equivalent of the ArrayList class.\\nA List is a strongly typed list of objects that can be accessed by index ( zero-based again).\\nHashtables represent a collection of key/value pairs that are organized based on the hash code of the key.\\nKeys must be unique.\\nDictionary is a generic class.It represents a collection of key/value pairs. Keys must be unique.\\nClojure's collections are immutable: rather than modifying an existing collection, you create a new collection based on a previous one but with changes, for example an additional element.\\nCOBOL is very much a fixed length programming environment. Hierarchical fixed length records are the main data grouping in many COBOL applications.\\nArrays are historically called tables in COBOL literature and are usually defined within a hierarchy. Tables are defined with the reserved word phrases OCCURS n TIMES, and OCCURS FROM n TO m TIMES DEPENDING ON x, (commonly referred to as ODO for short).\\nThis example shows a small record layout inside a very small table. The last line of the output sample is a debug enabled run-time bounds check abend, caused after the table is decreased in size. The first run, without bounds check, runs to an erroneous completion; the second, with debug enabled, does not.\\n","int a[5]; // array of 5 ints (since int is POD, the members are not initialized)\\na[0] = 1; // indexes start at 0\\n\\nint primes[10] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 }; // arrays can be initialized on creation\\n\\n#include <string>\\nstd::string strings[4]; // std::string is no POD, therefore all array members are default-initialized\\n                        // (for std::string this means initialized with empty strings)"
"C++","Collections","\\nCollections are abstractions to represent sets of values.\\nIn statically-typed languages, the values are typically of a common data type.\\n\\nCreate a collection, and add a few values to it.\\n\\n\\nAda 95 and earlier offers arrays. Ada 2005 adds the Ada.Containers package and its children. Examples of Doubly Linked Lists and Vectors are given.\\nAda 2005 also provides hashed and ordered Maps and Sets (not shown).\\nIn Ada, arrays can be indexed on any range of discrete values. The example below creates an anonymous array indexed from -3 to -1. It initializes the three elements of the array at declaration. Then it reverses their order in the array.\\n\\nAnonymous arrays have no type associated with them that is accessible to the programmer. This means that anonymous arrays cannot be compared in the aggregate to other arrays (even those with the same index structure and contained type) or passed as a parameter to a subprogram. For these reasons, anonymous arrays are best used as singletons and global constants.\\nBecause of the limitations of anonymous arrays noted above, arrays are more typically defined in Ada as array types, as in the example below.\\nDynamic arrays can be created through the use of pointers to unconstrained arrays. While an unconstrained array's index type is defined, it does not have a pre-defined range of indices - they are specified at the time of declaration or, as would be the case in a dynamic array, at the time the memory for the array is allocated. The creation of a dynamic array is not shown here, but below is an example declaration of an unconstrained array in Ada.\\nAime collections include \""list\""s (sequences) and \""record\""s (associative arrays).\\nBoth types of collections are heterogenous and resize dynamically.\\nDeclaring a list:\\nAdding values to it:\\nRetrieving values from a list:\\nDeclaring a record:\\nAdding values to it:\\nRetrieving values from a record:\\nArrays are the closest thing to collections available as standard in Algol 68. Collections could be implemented using STRUCTs but there are none as standard. Some examples of arrays:\\nA list is an ordered collection of elements that are distinguished by their indices\\nCreating Lists\\nAccess elements in a list\\nUsing Array Notation for One-dimensional list\\nA set is an unordered collection of elements that do not contain any duplicates.\\nDefining a set:\\nAccess elements in a set:\\nNote the following limitations on sets:\\nA map is a collection of key-value pairs where each unique key maps to a single value\\nDeclaring a map:\\nAccessing a Map:\\nMap Considerations:\\nMap keys of type String are case-sensitive. Two keys that differ only by the case are considered unique and have corresponding distinct Map entries.Subsequently, the Map methods, including put, get, containsKey, and remove treat these keys as distinct.\\nBoolean, Date, DateTime, Decimal, Double, Enum, Id, Integer, Long, String, Time\\nDocumentation\\nDocumentation: http://www.autohotkey.com/docs/misc/Arrays.htm\\nStructs are not natively supported in AutoHotkey, however they are often required in DllCalls to C++ Dlls.\\nThis shows how to retrieve values from a RECT structure in AutoHotkey (from the DllCall documentation at http://www.autohotkey.com/docs/commands/DllCall.htm)\\nIn awk, the closest thing to collections would be arrays. They are created when needed at assignment\\nor by splitting a string\\nSingle elements are accessible with the bracket notation, like in C:\\nOne can iterate over the elements of an array:\\nIn BBC BASIC the only native type of 'collection' is the array; the index starts at zero and the subscript specified in the DIM is the highest value of the index. Hence in this example an array with two elements is defined:\\nWhen the objects in the collection are not simple scalar types an array of structures may be used:\\nAlthough not a native language feature, other types of collections such as linked lists may be constructed:\\nSee Arrays for basic operations on arrays, the only collection type in bc.\\nSee Also foreach\\nOne thing in C language proper that can be said to be a collection is array type.\\nAn array has a length known at compile time.\\nPlease note that c built-in pointer-arithmetic support which helps this logic. An integer may be 4 bytes, and a char 1 byte: the plus operator (+) is overloaded to multiply a incement by 4 for integer pointers and by 1 for char pointers (etc).\\nAnother construct which can be seen as a collection is a malloced array. The size of a malloced array is not known at compile time.\\nA string is another C language construct (when looked at with its standard libraries) that behaves like a collection.\\nA C language string is an array of char, and it's size may or may not be known at compile time, however a c string is terminated with a ASCII NUL (which may be stated as a constant, '\\0' or ((char)0) in the C language). The String standard library \""class\"" has many \""methods\"", however instead of being called String.method(), they are usually called strmethod().\\nArbitrarily complex data structures can be constructed, normally via language features struct and pointers. They are everywhere, but not provided by the C language itself per se.\\nC++ has a range of different collections optimized for different use cases. Note that in C++, objects of user-defined types are mostly treated just like objects of built-in types; especially there's no different treatment for collections. Thus all collections can simply be demonstrated with the built-in type int. For user-defined types, just replace int with the user-defined type. Any type which goes into a collection must be copyable and assignable (which in general is automatically the case unless you explicitly disallow it).\\nNote however that C++ collections store copies of the objects given to them, so you'll lose any polymorphic behaviour. If you need polymorphism, use a collection of pointers (or smart pointers like boost::shared_ptr).\\nThe simplest collection in C++ is the built-in array. Built-in arrays have a fixed size, and except for POD types (i.e. basically any type you culd also write in C), the members are all initialized at array creation time (if no explicit initialization is done, the default constructr is used).\\nA vector is basically a resizable array. It is optimized for adding/removing elements on the end, and fast access to elements anywhere. Inserting elements at the beginning or in the middle is possible, but in general inefficient.\\nA deque is optimized for appending and removing elements on both ends ofd the array. Accessing random elements is still efficient, but slightly less than with vector.\\nA list is optimized for insertion at an arbitrary place (provided you already have an iterator pointing to that place). Element access is efficient only in linear order.\\nA set keeps the inserted elements sorted, and also makes sure that each element occurs only once. Of course, if you want to put something into a set, it must be less-than-comparable, i.e. you must be able to compare which of two objects a and b is smaller using a<b (there's also a way to define sets with an user-defined order, in which case this restriction doesn't apply).\\nA multiset is like a set, except the same element may occur multiple times.\\nThe size of ArrayList is dynamically increased as required. ArrayLists are zero-based.\\nThe List class is the generic equivalent of the ArrayList class.\\nA List is a strongly typed list of objects that can be accessed by index ( zero-based again).\\nHashtables represent a collection of key/value pairs that are organized based on the hash code of the key.\\nKeys must be unique.\\nDictionary is a generic class.It represents a collection of key/value pairs. Keys must be unique.\\nClojure's collections are immutable: rather than modifying an existing collection, you create a new collection based on a previous one but with changes, for example an additional element.\\nCOBOL is very much a fixed length programming environment. Hierarchical fixed length records are the main data grouping in many COBOL applications.\\nArrays are historically called tables in COBOL literature and are usually defined within a hierarchy. Tables are defined with the reserved word phrases OCCURS n TIMES, and OCCURS FROM n TO m TIMES DEPENDING ON x, (commonly referred to as ODO for short).\\nThis example shows a small record layout inside a very small table. The last line of the output sample is a debug enabled run-time bounds check abend, caused after the table is decreased in size. The first run, without bounds check, runs to an erroneous completion; the second, with debug enabled, does not.\\n","#include <vector>\\n\\nstd::vector<int> v;       // empty vector\\nv.push_back(5);           // insert a 5 at the end\\nv.insert(v.begin(), 7);   // insert a 7 at the beginning"
"C++","Collections","\\nCollections are abstractions to represent sets of values.\\nIn statically-typed languages, the values are typically of a common data type.\\n\\nCreate a collection, and add a few values to it.\\n\\n\\nAda 95 and earlier offers arrays. Ada 2005 adds the Ada.Containers package and its children. Examples of Doubly Linked Lists and Vectors are given.\\nAda 2005 also provides hashed and ordered Maps and Sets (not shown).\\nIn Ada, arrays can be indexed on any range of discrete values. The example below creates an anonymous array indexed from -3 to -1. It initializes the three elements of the array at declaration. Then it reverses their order in the array.\\n\\nAnonymous arrays have no type associated with them that is accessible to the programmer. This means that anonymous arrays cannot be compared in the aggregate to other arrays (even those with the same index structure and contained type) or passed as a parameter to a subprogram. For these reasons, anonymous arrays are best used as singletons and global constants.\\nBecause of the limitations of anonymous arrays noted above, arrays are more typically defined in Ada as array types, as in the example below.\\nDynamic arrays can be created through the use of pointers to unconstrained arrays. While an unconstrained array's index type is defined, it does not have a pre-defined range of indices - they are specified at the time of declaration or, as would be the case in a dynamic array, at the time the memory for the array is allocated. The creation of a dynamic array is not shown here, but below is an example declaration of an unconstrained array in Ada.\\nAime collections include \""list\""s (sequences) and \""record\""s (associative arrays).\\nBoth types of collections are heterogenous and resize dynamically.\\nDeclaring a list:\\nAdding values to it:\\nRetrieving values from a list:\\nDeclaring a record:\\nAdding values to it:\\nRetrieving values from a record:\\nArrays are the closest thing to collections available as standard in Algol 68. Collections could be implemented using STRUCTs but there are none as standard. Some examples of arrays:\\nA list is an ordered collection of elements that are distinguished by their indices\\nCreating Lists\\nAccess elements in a list\\nUsing Array Notation for One-dimensional list\\nA set is an unordered collection of elements that do not contain any duplicates.\\nDefining a set:\\nAccess elements in a set:\\nNote the following limitations on sets:\\nA map is a collection of key-value pairs where each unique key maps to a single value\\nDeclaring a map:\\nAccessing a Map:\\nMap Considerations:\\nMap keys of type String are case-sensitive. Two keys that differ only by the case are considered unique and have corresponding distinct Map entries.Subsequently, the Map methods, including put, get, containsKey, and remove treat these keys as distinct.\\nBoolean, Date, DateTime, Decimal, Double, Enum, Id, Integer, Long, String, Time\\nDocumentation\\nDocumentation: http://www.autohotkey.com/docs/misc/Arrays.htm\\nStructs are not natively supported in AutoHotkey, however they are often required in DllCalls to C++ Dlls.\\nThis shows how to retrieve values from a RECT structure in AutoHotkey (from the DllCall documentation at http://www.autohotkey.com/docs/commands/DllCall.htm)\\nIn awk, the closest thing to collections would be arrays. They are created when needed at assignment\\nor by splitting a string\\nSingle elements are accessible with the bracket notation, like in C:\\nOne can iterate over the elements of an array:\\nIn BBC BASIC the only native type of 'collection' is the array; the index starts at zero and the subscript specified in the DIM is the highest value of the index. Hence in this example an array with two elements is defined:\\nWhen the objects in the collection are not simple scalar types an array of structures may be used:\\nAlthough not a native language feature, other types of collections such as linked lists may be constructed:\\nSee Arrays for basic operations on arrays, the only collection type in bc.\\nSee Also foreach\\nOne thing in C language proper that can be said to be a collection is array type.\\nAn array has a length known at compile time.\\nPlease note that c built-in pointer-arithmetic support which helps this logic. An integer may be 4 bytes, and a char 1 byte: the plus operator (+) is overloaded to multiply a incement by 4 for integer pointers and by 1 for char pointers (etc).\\nAnother construct which can be seen as a collection is a malloced array. The size of a malloced array is not known at compile time.\\nA string is another C language construct (when looked at with its standard libraries) that behaves like a collection.\\nA C language string is an array of char, and it's size may or may not be known at compile time, however a c string is terminated with a ASCII NUL (which may be stated as a constant, '\\0' or ((char)0) in the C language). The String standard library \""class\"" has many \""methods\"", however instead of being called String.method(), they are usually called strmethod().\\nArbitrarily complex data structures can be constructed, normally via language features struct and pointers. They are everywhere, but not provided by the C language itself per se.\\nC++ has a range of different collections optimized for different use cases. Note that in C++, objects of user-defined types are mostly treated just like objects of built-in types; especially there's no different treatment for collections. Thus all collections can simply be demonstrated with the built-in type int. For user-defined types, just replace int with the user-defined type. Any type which goes into a collection must be copyable and assignable (which in general is automatically the case unless you explicitly disallow it).\\nNote however that C++ collections store copies of the objects given to them, so you'll lose any polymorphic behaviour. If you need polymorphism, use a collection of pointers (or smart pointers like boost::shared_ptr).\\nThe simplest collection in C++ is the built-in array. Built-in arrays have a fixed size, and except for POD types (i.e. basically any type you culd also write in C), the members are all initialized at array creation time (if no explicit initialization is done, the default constructr is used).\\nA vector is basically a resizable array. It is optimized for adding/removing elements on the end, and fast access to elements anywhere. Inserting elements at the beginning or in the middle is possible, but in general inefficient.\\nA deque is optimized for appending and removing elements on both ends ofd the array. Accessing random elements is still efficient, but slightly less than with vector.\\nA list is optimized for insertion at an arbitrary place (provided you already have an iterator pointing to that place). Element access is efficient only in linear order.\\nA set keeps the inserted elements sorted, and also makes sure that each element occurs only once. Of course, if you want to put something into a set, it must be less-than-comparable, i.e. you must be able to compare which of two objects a and b is smaller using a<b (there's also a way to define sets with an user-defined order, in which case this restriction doesn't apply).\\nA multiset is like a set, except the same element may occur multiple times.\\nThe size of ArrayList is dynamically increased as required. ArrayLists are zero-based.\\nThe List class is the generic equivalent of the ArrayList class.\\nA List is a strongly typed list of objects that can be accessed by index ( zero-based again).\\nHashtables represent a collection of key/value pairs that are organized based on the hash code of the key.\\nKeys must be unique.\\nDictionary is a generic class.It represents a collection of key/value pairs. Keys must be unique.\\nClojure's collections are immutable: rather than modifying an existing collection, you create a new collection based on a previous one but with changes, for example an additional element.\\nCOBOL is very much a fixed length programming environment. Hierarchical fixed length records are the main data grouping in many COBOL applications.\\nArrays are historically called tables in COBOL literature and are usually defined within a hierarchy. Tables are defined with the reserved word phrases OCCURS n TIMES, and OCCURS FROM n TO m TIMES DEPENDING ON x, (commonly referred to as ODO for short).\\nThis example shows a small record layout inside a very small table. The last line of the output sample is a debug enabled run-time bounds check abend, caused after the table is decreased in size. The first run, without bounds check, runs to an erroneous completion; the second, with debug enabled, does not.\\n","#include <deque>\\n\\nstd::deque<int> d;        // empty deque\\nd.push_back(5);           // insert a 5 at the end\\nd.push_front(7);          // insert a 7 at the beginning\\nd.insert(v.begin()+1, 6); // insert a 6 in the middle"
"C++","Collections","\\nCollections are abstractions to represent sets of values.\\nIn statically-typed languages, the values are typically of a common data type.\\n\\nCreate a collection, and add a few values to it.\\n\\n\\nAda 95 and earlier offers arrays. Ada 2005 adds the Ada.Containers package and its children. Examples of Doubly Linked Lists and Vectors are given.\\nAda 2005 also provides hashed and ordered Maps and Sets (not shown).\\nIn Ada, arrays can be indexed on any range of discrete values. The example below creates an anonymous array indexed from -3 to -1. It initializes the three elements of the array at declaration. Then it reverses their order in the array.\\n\\nAnonymous arrays have no type associated with them that is accessible to the programmer. This means that anonymous arrays cannot be compared in the aggregate to other arrays (even those with the same index structure and contained type) or passed as a parameter to a subprogram. For these reasons, anonymous arrays are best used as singletons and global constants.\\nBecause of the limitations of anonymous arrays noted above, arrays are more typically defined in Ada as array types, as in the example below.\\nDynamic arrays can be created through the use of pointers to unconstrained arrays. While an unconstrained array's index type is defined, it does not have a pre-defined range of indices - they are specified at the time of declaration or, as would be the case in a dynamic array, at the time the memory for the array is allocated. The creation of a dynamic array is not shown here, but below is an example declaration of an unconstrained array in Ada.\\nAime collections include \""list\""s (sequences) and \""record\""s (associative arrays).\\nBoth types of collections are heterogenous and resize dynamically.\\nDeclaring a list:\\nAdding values to it:\\nRetrieving values from a list:\\nDeclaring a record:\\nAdding values to it:\\nRetrieving values from a record:\\nArrays are the closest thing to collections available as standard in Algol 68. Collections could be implemented using STRUCTs but there are none as standard. Some examples of arrays:\\nA list is an ordered collection of elements that are distinguished by their indices\\nCreating Lists\\nAccess elements in a list\\nUsing Array Notation for One-dimensional list\\nA set is an unordered collection of elements that do not contain any duplicates.\\nDefining a set:\\nAccess elements in a set:\\nNote the following limitations on sets:\\nA map is a collection of key-value pairs where each unique key maps to a single value\\nDeclaring a map:\\nAccessing a Map:\\nMap Considerations:\\nMap keys of type String are case-sensitive. Two keys that differ only by the case are considered unique and have corresponding distinct Map entries.Subsequently, the Map methods, including put, get, containsKey, and remove treat these keys as distinct.\\nBoolean, Date, DateTime, Decimal, Double, Enum, Id, Integer, Long, String, Time\\nDocumentation\\nDocumentation: http://www.autohotkey.com/docs/misc/Arrays.htm\\nStructs are not natively supported in AutoHotkey, however they are often required in DllCalls to C++ Dlls.\\nThis shows how to retrieve values from a RECT structure in AutoHotkey (from the DllCall documentation at http://www.autohotkey.com/docs/commands/DllCall.htm)\\nIn awk, the closest thing to collections would be arrays. They are created when needed at assignment\\nor by splitting a string\\nSingle elements are accessible with the bracket notation, like in C:\\nOne can iterate over the elements of an array:\\nIn BBC BASIC the only native type of 'collection' is the array; the index starts at zero and the subscript specified in the DIM is the highest value of the index. Hence in this example an array with two elements is defined:\\nWhen the objects in the collection are not simple scalar types an array of structures may be used:\\nAlthough not a native language feature, other types of collections such as linked lists may be constructed:\\nSee Arrays for basic operations on arrays, the only collection type in bc.\\nSee Also foreach\\nOne thing in C language proper that can be said to be a collection is array type.\\nAn array has a length known at compile time.\\nPlease note that c built-in pointer-arithmetic support which helps this logic. An integer may be 4 bytes, and a char 1 byte: the plus operator (+) is overloaded to multiply a incement by 4 for integer pointers and by 1 for char pointers (etc).\\nAnother construct which can be seen as a collection is a malloced array. The size of a malloced array is not known at compile time.\\nA string is another C language construct (when looked at with its standard libraries) that behaves like a collection.\\nA C language string is an array of char, and it's size may or may not be known at compile time, however a c string is terminated with a ASCII NUL (which may be stated as a constant, '\\0' or ((char)0) in the C language). The String standard library \""class\"" has many \""methods\"", however instead of being called String.method(), they are usually called strmethod().\\nArbitrarily complex data structures can be constructed, normally via language features struct and pointers. They are everywhere, but not provided by the C language itself per se.\\nC++ has a range of different collections optimized for different use cases. Note that in C++, objects of user-defined types are mostly treated just like objects of built-in types; especially there's no different treatment for collections. Thus all collections can simply be demonstrated with the built-in type int. For user-defined types, just replace int with the user-defined type. Any type which goes into a collection must be copyable and assignable (which in general is automatically the case unless you explicitly disallow it).\\nNote however that C++ collections store copies of the objects given to them, so you'll lose any polymorphic behaviour. If you need polymorphism, use a collection of pointers (or smart pointers like boost::shared_ptr).\\nThe simplest collection in C++ is the built-in array. Built-in arrays have a fixed size, and except for POD types (i.e. basically any type you culd also write in C), the members are all initialized at array creation time (if no explicit initialization is done, the default constructr is used).\\nA vector is basically a resizable array. It is optimized for adding/removing elements on the end, and fast access to elements anywhere. Inserting elements at the beginning or in the middle is possible, but in general inefficient.\\nA deque is optimized for appending and removing elements on both ends ofd the array. Accessing random elements is still efficient, but slightly less than with vector.\\nA list is optimized for insertion at an arbitrary place (provided you already have an iterator pointing to that place). Element access is efficient only in linear order.\\nA set keeps the inserted elements sorted, and also makes sure that each element occurs only once. Of course, if you want to put something into a set, it must be less-than-comparable, i.e. you must be able to compare which of two objects a and b is smaller using a<b (there's also a way to define sets with an user-defined order, in which case this restriction doesn't apply).\\nA multiset is like a set, except the same element may occur multiple times.\\nThe size of ArrayList is dynamically increased as required. ArrayLists are zero-based.\\nThe List class is the generic equivalent of the ArrayList class.\\nA List is a strongly typed list of objects that can be accessed by index ( zero-based again).\\nHashtables represent a collection of key/value pairs that are organized based on the hash code of the key.\\nKeys must be unique.\\nDictionary is a generic class.It represents a collection of key/value pairs. Keys must be unique.\\nClojure's collections are immutable: rather than modifying an existing collection, you create a new collection based on a previous one but with changes, for example an additional element.\\nCOBOL is very much a fixed length programming environment. Hierarchical fixed length records are the main data grouping in many COBOL applications.\\nArrays are historically called tables in COBOL literature and are usually defined within a hierarchy. Tables are defined with the reserved word phrases OCCURS n TIMES, and OCCURS FROM n TO m TIMES DEPENDING ON x, (commonly referred to as ODO for short).\\nThis example shows a small record layout inside a very small table. The last line of the output sample is a debug enabled run-time bounds check abend, caused after the table is decreased in size. The first run, without bounds check, runs to an erroneous completion; the second, with debug enabled, does not.\\n","#include <list>\\n\\nstd::list<int> l;         // empty list\\nl.push_back(5);           // insert a 5 at the end\\nl.push_front(7);          // insert a 7 at the beginning\\nstd::list::iterator i = l.begin();\\n++l;\\nl.insert(i, 6);           // insert a 6 in the middle"
"C++","Collections","\\nCollections are abstractions to represent sets of values.\\nIn statically-typed languages, the values are typically of a common data type.\\n\\nCreate a collection, and add a few values to it.\\n\\n\\nAda 95 and earlier offers arrays. Ada 2005 adds the Ada.Containers package and its children. Examples of Doubly Linked Lists and Vectors are given.\\nAda 2005 also provides hashed and ordered Maps and Sets (not shown).\\nIn Ada, arrays can be indexed on any range of discrete values. The example below creates an anonymous array indexed from -3 to -1. It initializes the three elements of the array at declaration. Then it reverses their order in the array.\\n\\nAnonymous arrays have no type associated with them that is accessible to the programmer. This means that anonymous arrays cannot be compared in the aggregate to other arrays (even those with the same index structure and contained type) or passed as a parameter to a subprogram. For these reasons, anonymous arrays are best used as singletons and global constants.\\nBecause of the limitations of anonymous arrays noted above, arrays are more typically defined in Ada as array types, as in the example below.\\nDynamic arrays can be created through the use of pointers to unconstrained arrays. While an unconstrained array's index type is defined, it does not have a pre-defined range of indices - they are specified at the time of declaration or, as would be the case in a dynamic array, at the time the memory for the array is allocated. The creation of a dynamic array is not shown here, but below is an example declaration of an unconstrained array in Ada.\\nAime collections include \""list\""s (sequences) and \""record\""s (associative arrays).\\nBoth types of collections are heterogenous and resize dynamically.\\nDeclaring a list:\\nAdding values to it:\\nRetrieving values from a list:\\nDeclaring a record:\\nAdding values to it:\\nRetrieving values from a record:\\nArrays are the closest thing to collections available as standard in Algol 68. Collections could be implemented using STRUCTs but there are none as standard. Some examples of arrays:\\nA list is an ordered collection of elements that are distinguished by their indices\\nCreating Lists\\nAccess elements in a list\\nUsing Array Notation for One-dimensional list\\nA set is an unordered collection of elements that do not contain any duplicates.\\nDefining a set:\\nAccess elements in a set:\\nNote the following limitations on sets:\\nA map is a collection of key-value pairs where each unique key maps to a single value\\nDeclaring a map:\\nAccessing a Map:\\nMap Considerations:\\nMap keys of type String are case-sensitive. Two keys that differ only by the case are considered unique and have corresponding distinct Map entries.Subsequently, the Map methods, including put, get, containsKey, and remove treat these keys as distinct.\\nBoolean, Date, DateTime, Decimal, Double, Enum, Id, Integer, Long, String, Time\\nDocumentation\\nDocumentation: http://www.autohotkey.com/docs/misc/Arrays.htm\\nStructs are not natively supported in AutoHotkey, however they are often required in DllCalls to C++ Dlls.\\nThis shows how to retrieve values from a RECT structure in AutoHotkey (from the DllCall documentation at http://www.autohotkey.com/docs/commands/DllCall.htm)\\nIn awk, the closest thing to collections would be arrays. They are created when needed at assignment\\nor by splitting a string\\nSingle elements are accessible with the bracket notation, like in C:\\nOne can iterate over the elements of an array:\\nIn BBC BASIC the only native type of 'collection' is the array; the index starts at zero and the subscript specified in the DIM is the highest value of the index. Hence in this example an array with two elements is defined:\\nWhen the objects in the collection are not simple scalar types an array of structures may be used:\\nAlthough not a native language feature, other types of collections such as linked lists may be constructed:\\nSee Arrays for basic operations on arrays, the only collection type in bc.\\nSee Also foreach\\nOne thing in C language proper that can be said to be a collection is array type.\\nAn array has a length known at compile time.\\nPlease note that c built-in pointer-arithmetic support which helps this logic. An integer may be 4 bytes, and a char 1 byte: the plus operator (+) is overloaded to multiply a incement by 4 for integer pointers and by 1 for char pointers (etc).\\nAnother construct which can be seen as a collection is a malloced array. The size of a malloced array is not known at compile time.\\nA string is another C language construct (when looked at with its standard libraries) that behaves like a collection.\\nA C language string is an array of char, and it's size may or may not be known at compile time, however a c string is terminated with a ASCII NUL (which may be stated as a constant, '\\0' or ((char)0) in the C language). The String standard library \""class\"" has many \""methods\"", however instead of being called String.method(), they are usually called strmethod().\\nArbitrarily complex data structures can be constructed, normally via language features struct and pointers. They are everywhere, but not provided by the C language itself per se.\\nC++ has a range of different collections optimized for different use cases. Note that in C++, objects of user-defined types are mostly treated just like objects of built-in types; especially there's no different treatment for collections. Thus all collections can simply be demonstrated with the built-in type int. For user-defined types, just replace int with the user-defined type. Any type which goes into a collection must be copyable and assignable (which in general is automatically the case unless you explicitly disallow it).\\nNote however that C++ collections store copies of the objects given to them, so you'll lose any polymorphic behaviour. If you need polymorphism, use a collection of pointers (or smart pointers like boost::shared_ptr).\\nThe simplest collection in C++ is the built-in array. Built-in arrays have a fixed size, and except for POD types (i.e. basically any type you culd also write in C), the members are all initialized at array creation time (if no explicit initialization is done, the default constructr is used).\\nA vector is basically a resizable array. It is optimized for adding/removing elements on the end, and fast access to elements anywhere. Inserting elements at the beginning or in the middle is possible, but in general inefficient.\\nA deque is optimized for appending and removing elements on both ends ofd the array. Accessing random elements is still efficient, but slightly less than with vector.\\nA list is optimized for insertion at an arbitrary place (provided you already have an iterator pointing to that place). Element access is efficient only in linear order.\\nA set keeps the inserted elements sorted, and also makes sure that each element occurs only once. Of course, if you want to put something into a set, it must be less-than-comparable, i.e. you must be able to compare which of two objects a and b is smaller using a<b (there's also a way to define sets with an user-defined order, in which case this restriction doesn't apply).\\nA multiset is like a set, except the same element may occur multiple times.\\nThe size of ArrayList is dynamically increased as required. ArrayLists are zero-based.\\nThe List class is the generic equivalent of the ArrayList class.\\nA List is a strongly typed list of objects that can be accessed by index ( zero-based again).\\nHashtables represent a collection of key/value pairs that are organized based on the hash code of the key.\\nKeys must be unique.\\nDictionary is a generic class.It represents a collection of key/value pairs. Keys must be unique.\\nClojure's collections are immutable: rather than modifying an existing collection, you create a new collection based on a previous one but with changes, for example an additional element.\\nCOBOL is very much a fixed length programming environment. Hierarchical fixed length records are the main data grouping in many COBOL applications.\\nArrays are historically called tables in COBOL literature and are usually defined within a hierarchy. Tables are defined with the reserved word phrases OCCURS n TIMES, and OCCURS FROM n TO m TIMES DEPENDING ON x, (commonly referred to as ODO for short).\\nThis example shows a small record layout inside a very small table. The last line of the output sample is a debug enabled run-time bounds check abend, caused after the table is decreased in size. The first run, without bounds check, runs to an erroneous completion; the second, with debug enabled, does not.\\n","#include <set>\\n\\nstd::set<int> s;          // empty set\\ns.insert(5);              // insert a 5\\ns.insert(7);              // insert a 7 (automatically placed after the 5)\\ns.insert(5);              // try to insert another 5 (will not change the set)"
"C++","Collections","\\nCollections are abstractions to represent sets of values.\\nIn statically-typed languages, the values are typically of a common data type.\\n\\nCreate a collection, and add a few values to it.\\n\\n\\nAda 95 and earlier offers arrays. Ada 2005 adds the Ada.Containers package and its children. Examples of Doubly Linked Lists and Vectors are given.\\nAda 2005 also provides hashed and ordered Maps and Sets (not shown).\\nIn Ada, arrays can be indexed on any range of discrete values. The example below creates an anonymous array indexed from -3 to -1. It initializes the three elements of the array at declaration. Then it reverses their order in the array.\\n\\nAnonymous arrays have no type associated with them that is accessible to the programmer. This means that anonymous arrays cannot be compared in the aggregate to other arrays (even those with the same index structure and contained type) or passed as a parameter to a subprogram. For these reasons, anonymous arrays are best used as singletons and global constants.\\nBecause of the limitations of anonymous arrays noted above, arrays are more typically defined in Ada as array types, as in the example below.\\nDynamic arrays can be created through the use of pointers to unconstrained arrays. While an unconstrained array's index type is defined, it does not have a pre-defined range of indices - they are specified at the time of declaration or, as would be the case in a dynamic array, at the time the memory for the array is allocated. The creation of a dynamic array is not shown here, but below is an example declaration of an unconstrained array in Ada.\\nAime collections include \""list\""s (sequences) and \""record\""s (associative arrays).\\nBoth types of collections are heterogenous and resize dynamically.\\nDeclaring a list:\\nAdding values to it:\\nRetrieving values from a list:\\nDeclaring a record:\\nAdding values to it:\\nRetrieving values from a record:\\nArrays are the closest thing to collections available as standard in Algol 68. Collections could be implemented using STRUCTs but there are none as standard. Some examples of arrays:\\nA list is an ordered collection of elements that are distinguished by their indices\\nCreating Lists\\nAccess elements in a list\\nUsing Array Notation for One-dimensional list\\nA set is an unordered collection of elements that do not contain any duplicates.\\nDefining a set:\\nAccess elements in a set:\\nNote the following limitations on sets:\\nA map is a collection of key-value pairs where each unique key maps to a single value\\nDeclaring a map:\\nAccessing a Map:\\nMap Considerations:\\nMap keys of type String are case-sensitive. Two keys that differ only by the case are considered unique and have corresponding distinct Map entries.Subsequently, the Map methods, including put, get, containsKey, and remove treat these keys as distinct.\\nBoolean, Date, DateTime, Decimal, Double, Enum, Id, Integer, Long, String, Time\\nDocumentation\\nDocumentation: http://www.autohotkey.com/docs/misc/Arrays.htm\\nStructs are not natively supported in AutoHotkey, however they are often required in DllCalls to C++ Dlls.\\nThis shows how to retrieve values from a RECT structure in AutoHotkey (from the DllCall documentation at http://www.autohotkey.com/docs/commands/DllCall.htm)\\nIn awk, the closest thing to collections would be arrays. They are created when needed at assignment\\nor by splitting a string\\nSingle elements are accessible with the bracket notation, like in C:\\nOne can iterate over the elements of an array:\\nIn BBC BASIC the only native type of 'collection' is the array; the index starts at zero and the subscript specified in the DIM is the highest value of the index. Hence in this example an array with two elements is defined:\\nWhen the objects in the collection are not simple scalar types an array of structures may be used:\\nAlthough not a native language feature, other types of collections such as linked lists may be constructed:\\nSee Arrays for basic operations on arrays, the only collection type in bc.\\nSee Also foreach\\nOne thing in C language proper that can be said to be a collection is array type.\\nAn array has a length known at compile time.\\nPlease note that c built-in pointer-arithmetic support which helps this logic. An integer may be 4 bytes, and a char 1 byte: the plus operator (+) is overloaded to multiply a incement by 4 for integer pointers and by 1 for char pointers (etc).\\nAnother construct which can be seen as a collection is a malloced array. The size of a malloced array is not known at compile time.\\nA string is another C language construct (when looked at with its standard libraries) that behaves like a collection.\\nA C language string is an array of char, and it's size may or may not be known at compile time, however a c string is terminated with a ASCII NUL (which may be stated as a constant, '\\0' or ((char)0) in the C language). The String standard library \""class\"" has many \""methods\"", however instead of being called String.method(), they are usually called strmethod().\\nArbitrarily complex data structures can be constructed, normally via language features struct and pointers. They are everywhere, but not provided by the C language itself per se.\\nC++ has a range of different collections optimized for different use cases. Note that in C++, objects of user-defined types are mostly treated just like objects of built-in types; especially there's no different treatment for collections. Thus all collections can simply be demonstrated with the built-in type int. For user-defined types, just replace int with the user-defined type. Any type which goes into a collection must be copyable and assignable (which in general is automatically the case unless you explicitly disallow it).\\nNote however that C++ collections store copies of the objects given to them, so you'll lose any polymorphic behaviour. If you need polymorphism, use a collection of pointers (or smart pointers like boost::shared_ptr).\\nThe simplest collection in C++ is the built-in array. Built-in arrays have a fixed size, and except for POD types (i.e. basically any type you culd also write in C), the members are all initialized at array creation time (if no explicit initialization is done, the default constructr is used).\\nA vector is basically a resizable array. It is optimized for adding/removing elements on the end, and fast access to elements anywhere. Inserting elements at the beginning or in the middle is possible, but in general inefficient.\\nA deque is optimized for appending and removing elements on both ends ofd the array. Accessing random elements is still efficient, but slightly less than with vector.\\nA list is optimized for insertion at an arbitrary place (provided you already have an iterator pointing to that place). Element access is efficient only in linear order.\\nA set keeps the inserted elements sorted, and also makes sure that each element occurs only once. Of course, if you want to put something into a set, it must be less-than-comparable, i.e. you must be able to compare which of two objects a and b is smaller using a<b (there's also a way to define sets with an user-defined order, in which case this restriction doesn't apply).\\nA multiset is like a set, except the same element may occur multiple times.\\nThe size of ArrayList is dynamically increased as required. ArrayLists are zero-based.\\nThe List class is the generic equivalent of the ArrayList class.\\nA List is a strongly typed list of objects that can be accessed by index ( zero-based again).\\nHashtables represent a collection of key/value pairs that are organized based on the hash code of the key.\\nKeys must be unique.\\nDictionary is a generic class.It represents a collection of key/value pairs. Keys must be unique.\\nClojure's collections are immutable: rather than modifying an existing collection, you create a new collection based on a previous one but with changes, for example an additional element.\\nCOBOL is very much a fixed length programming environment. Hierarchical fixed length records are the main data grouping in many COBOL applications.\\nArrays are historically called tables in COBOL literature and are usually defined within a hierarchy. Tables are defined with the reserved word phrases OCCURS n TIMES, and OCCURS FROM n TO m TIMES DEPENDING ON x, (commonly referred to as ODO for short).\\nThis example shows a small record layout inside a very small table. The last line of the output sample is a debug enabled run-time bounds check abend, caused after the table is decreased in size. The first run, without bounds check, runs to an erroneous completion; the second, with debug enabled, does not.\\n","#include <multiset>\\n\\nstd::multiset<int> m;     // empty multiset\\nm.insert(5);              // insert a 5\\nm.insert(7);              // insert a 7 (automatically placed after the 5)\\nm.insert(5);              // insert a second 5 (now m contains two 5s, followed by one 7)"
"C++","Colour_pinstripe/Display","The task is to create 1 pixel wide coloured vertical pinstripes with a sufficient number of pinstripes to span the entire width of the graphics display. The pinstripes should either follow the system palette sequence or a sequence that includes Black, Red, Green, Blue, Magenta, Cyan, Yellow, White.\\nAfter filling the top quarter of the display, we switch to a wider 2 pixel wide vertical pinstripe pattern. Halfway down the display we switch to 3 pixel wide vertical pinstripe and then finally to a 4 pixels wide vertical pinstripe for the last quarter of the display.\\nc.f. Pinstripe/Display\\nRequires the GDI+ standard library: http://www.autohotkey.com/forum/viewtopic.php?t=32238\\nIt is worth noting that this fills the whole screen; press Esc to exit.\\nWrites the image to stdout using the PPM format. You can either redirect that to a file, or pipe it to something like ImageMagick's display utility to view the result.\\nThe dimensions of the image are specified by the first two values on the stack: 1366 (\""%\"":*3-) by 768 (\""`\""8*).\\nThe following code uses the BGI graphics library of Borland's Turbo C.\\n\\nUsing Allegro's Common Graphics. As stated in the comments, I'm using line drawing here\\nwhich causes the line caps to make the edges between regions to be a bit ragged. I mention\\na couple of alternatives there which I'm too lazy to implement right now.\\nClick to see output image\\n","\\n#include <windows.h>\\n\\n//--------------------------------------------------------------------------------------------------\\nclass pinstripe\\n{\\npublic:\\n    pinstripe()                        { createColors(); }\\n    void setDimensions( int x, int y ) { _mw = x; _mh = y; }\\n    void createColors()\\n    {\\n	colors[0] = 0; colors[1] = 255; colors[2] = RGB( 0, 255, 0 );\\n	colors[3] = RGB( 0, 0, 255 ); colors[4] = RGB( 255, 0, 255 ); \\n	colors[5] = RGB( 0, 255, 255 ); colors[6] = RGB( 255, 255, 0 ); \\n	colors[7] = RGB( 255, 255, 255 );\\n    }\\n\\n    void draw( HDC dc )\\n    {\\n        HPEN pen;\\n	int lh = _mh / 4, row, cp;\\n	for( int lw = 1; lw < 5; lw++ )\\n	{\\n	    cp = 0;\\n            row = ( lw - 1 ) * lh;\\n	    for( int x = 0 + lw > 1 ? lw > 3 ? 2 : 1 : 0; x < _mw; x += lw )\\n	    {\\n		pen = CreatePen( PS_SOLID, lw, colors[cp] );\\n	        ++cp %= 8;\\n\\n		SelectObject( dc, pen );\\n		MoveToEx( dc, x, row, NULL );\\n		LineTo( dc, x, row + lh );\\n		DeleteObject( pen );\\n	    }\\n	}\\n    }\\n\\nprivate:\\n    int _mw, _mh;\\n    DWORD colors[8];\\n};\\n//--------------------------------------------------------------------------------------------------\\npinstripe pin;\\n\\n//--------------------------------------------------------------------------------------------------\\nvoid PaintWnd( HWND hWnd )\\n{\\n    PAINTSTRUCT ps;\\n    HDC hdc = BeginPaint( hWnd, &ps );\\n    pin.draw( hdc );\\n    EndPaint( hWnd, &ps );\\n}\\n//--------------------------------------------------------------------------------------------------\\nLRESULT CALLBACK WndProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )\\n{\\n    switch( msg )\\n    {\\n	case WM_DESTROY: PostQuitMessage( 0 ); break;\\n	case WM_PAINT: PaintWnd( hWnd ); break;\\n	default:\\n	    return DefWindowProc( hWnd, msg, wParam, lParam );\\n    }\\n    return 0;\\n}\\n//--------------------------------------------------------------------------------------------------\\nHWND InitAll( HINSTANCE hInstance )\\n{\\n    WNDCLASSEX wcex;\\n    ZeroMemory( &wcex, sizeof( wcex ) );\\n\\n    wcex.cbSize	       = sizeof( WNDCLASSEX );\\n    wcex.style	       = CS_HREDRAW | CS_VREDRAW;\\n    wcex.lpfnWndProc   = WndProc;\\n    wcex.hInstance     = hInstance;\\n    wcex.hCursor       = LoadCursor( NULL, IDC_ARROW );\\n    wcex.hbrBackground = ( HBRUSH )( COLOR_WINDOW + 1 );\\n    wcex.lpszClassName = \""_CLR_PS_\"";\\n\\n    RegisterClassEx( &wcex ); \\n    return CreateWindow( \""_CLR_PS_\"", \"".: Clr Pinstripe -- PJorente :.\"", WS_POPUP, CW_USEDEFAULT, 0, 200, 200, NULL, NULL, hInstance, NULL );\\n}\\n//--------------------------------------------------------------------------------------------------\\nint APIENTRY _tWinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow )\\n{\\n    srand( GetTickCount() );\\n\\n    HWND hwnd = InitAll( hInstance );\\n    if( !hwnd ) return -1;\\n\\n    int mw = GetSystemMetrics( SM_CXSCREEN ),\\n	mh = GetSystemMetrics( SM_CYSCREEN );\\n\\n    pin.setDimensions( mw, mh );\\n\\n    RECT rc = { 0, 0, mw, mh };\\n\\n    AdjustWindowRectEx( &rc, WS_POPUP, FALSE, 0 );\\n    int w = rc.right  - rc.left, \\n	h = rc.bottom - rc.top;\\n\\n    int posX = ( GetSystemMetrics( SM_CXSCREEN ) >> 1 ) - ( w >> 1 ),\\n	posY = ( GetSystemMetrics( SM_CYSCREEN ) >> 1 ) - ( h >> 1 );\\n\\n    SetWindowPos( hwnd, HWND_TOP, posX, posY, w, h, SWP_NOZORDER );\\n    ShowWindow( hwnd, nCmdShow );\\n    UpdateWindow( hwnd );\\n\\n    MSG msg;\\n    ZeroMemory( &msg, sizeof( msg ) );\\n    while( msg.message != WM_QUIT )\\n    {\\n	if( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) != 0 )\\n	{\\n	    TranslateMessage( &msg );\\n	    DispatchMessage( &msg );\\n	}\\n    }\\n    return UnregisterClass( \""_CLR_PS_\"", hInstance );\\n}\\n//--------------------------------------------------------------------------------------------------\\n"
"C++","Combinations","Given non-negative integers    m    and    n,   generate all size    m    combinations   of the integers from    0   (zero)   to    n-1    in sorted order   (each combination is sorted and the entire table is sorted).\\n\\n3   comb    5      is:\\nIf it is more \""natural\"" in your language to start counting from    1   (unity) instead of    0   (zero),\\nthe combinations can be of the integers from    1   to    n. \\n\\n\\n","#include <algorithm>\\n#include <iostream>\\n#include <string>\\n\\nvoid comb(int N, int K)\\n{\\n    std::string bitmask(K, 1); // K leading 1's\\n    bitmask.resize(N, 0); // N-K trailing 0's\\n\\n    // print integers and permute bitmask\\n    do {\\n        for (int i = 0; i < N; ++i) // [0..N-1] integers\\n        {\\n            if (bitmask[i]) std::cout << \"" \"" << i;\\n        }\\n        std::cout << std::endl;\\n    } while (std::prev_permutation(bitmask.begin(), bitmask.end()));\\n}\\n\\nint main()\\n{\\n    comb(5, 3);\\n}"
"C++","Combinations_with_repetitions","The set of combinations with repetitions is computed from a set, \\n\\n\\n\\nS\\n\\n\\n{\\displaystyle S}\\n\\n (of cardinality \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n), and a size of resulting selection, \\n\\n\\n\\nk\\n\\n\\n{\\displaystyle k}\\n\\n, by reporting the sets of cardinality \\n\\n\\n\\nk\\n\\n\\n{\\displaystyle k}\\n\\n where each member of those sets is chosen from \\n\\n\\n\\nS\\n\\n\\n{\\displaystyle S}\\n\\n.\\nIn the real world, it is about choosing sets where there is a “large” supply of each type of element and where the order of choice does not matter.\\nFor example:\\nNote that both the order of items within a pair, and the order of the pairs given in the answer is not significant; the pairs represent multisets.\\nAlso note that doughnut can also be spelled donut.\\n\\n\\n\\n\\nShould work for any discrete type: integer, modular, or enumeration.\\ncombinations.adb:\\n","\\n#include <stdio.h> \\n#include <vector> \\n#include <string>   \\n \\nusing namespace std; \\nvector<string> options{ \""iced\"", \""jam\"", \""plain\"" }; \\n \\nvoid print_vector(vector<int> v, int n, vector<string> s){ \\n        for (int i = 0; i < n; ++i) \\n                printf(\""%s\\t\"", s[v[i]].c_str()); \\n        printf(\""\\n\""); \\n} \\n \\nint combination_with_repetiton(int sabores, int bolas, const vector<string>& v_sabores){ \\n        sabores--; \\n        vector<int> v; \\n        for (int i = 0; i <= bolas; ++i) \\n                v.push_back(0); \\n        while (true){ \\n                for (int i = 0; i < bolas; ++i){                //vai um \\n                        if (v[i] > sabores){ \\n                                v[i + 1] += 1; \\n                                for (int k = i; k >= 0; --k){ \\n                                        v[k] = v[i + 1]; \\n                                } \\n                                //v[i] = v[i + 1]; \\n                        } \\n                } \\n \\n                if (v[bolas] > 0) \\n                        break; \\n                print_vector(v, bolas, v_sabores); \\n                v[0] += 1; \\n        } \\n \\n        return 1; \\n} \\n \\nint main(){ \\n        combination_with_repetiton(3, 2, options); \\n        return 0; \\n}\\n"
"C++","Comma_quibbling","Comma quibbling is a task originally set by Eric Lippert in his blog.\\n\\nWrite a function to generate a string output which is the concatenation of input words from a list/sequence where:\\n\\nTest your function with the following series of inputs showing your output here on this page:\\n\\nNote: Assume words are non-empty strings of uppercase characters for this task.\\n\\n","#include <iostream>\\n\\ntemplate\\nvoid quibble(std::ostream& o, T i, T e) {\\n  o << \""{\"";\\n  if (e != i) {\\n    T n = i++;\\n    const char* more = \""\"";\\n    while (e != i) {\\n      o << more << *n;\\n      more = \"", \"";\\n      n = i++;\\n    }\\n    o << (*more?\"" and \"":\""\"") << *n;\\n  }\\n  o << \""}\"";\\n}\\n\\nint main(int argc, char** argv) {\\n  char const* a[] = {\""ABC\"",\""DEF\"",\""G\"",\""H\""};\\n  for (int i=0; i<5; i++) {\\n    quibble(std::cout, a, a+i);\\n    std::cout << std::endl;\\n  }\\n  return 0;\\n}"
"C++","Command-line_arguments","See also Program name.\\nFor parsing command line arguments intelligently, see Parsing command-line arguments.\\nExample command line:\\n:argv is a list containing all command line arguments, including the program name.\\nIn Ada95 and later versions, command line arguments are available through the predefined package Ada.Command_Line. In Ada83, this would be implementation dependent.\\nUses Matreshka\\nThe arguments are passed to the program as a vector of strings called args\\nLinux command:\\nOutput:\\nFrom the AutoHotkey documentation:\\n\""The script sees incoming parameters as the variables %1%, %2%, and so on. In addition, %0% contains the number of parameters passed (0 if none). \""\\n\\nInvoke Babel in interactive mode with arguments using the -i switch:\\nPrint the argv list with newlines:\\n","#include <iostream>\\n\\nint main(int argc, char* argv[])\\n{\\n  std::cout << \""This program is named \"" << argv[0] << std::endl;\\n  std::cout << \""There are \"" << argc-1 << \"" arguments given.\"" << std::endl;\\n  for (int i = 1; i < argc; ++i)\\n    std::cout << \""the argument #\"" << i << \"" is \"" << argv[i] << std::endl;\\n\\n  return 0;\\n}"
"C++","Comments","Show all ways to include text in a language source file\\nthat's completely ignored by the compiler or interpreter.\\n\\n\\n\\nNote: syntax depends on the assembler software but use of a semicolon is fairly standard\\nNote: syntax depends on the assembler software but use of a semicolon is fairly standard\\nJust like Common Lisp:\\nAgena has single line comments and two styles of multi-line comments.\\nA comment in ALGOL 60 takes the place of a single instruction.\\nComments can be inserted in variety of ways:\\nincludes bold typeface.\\nlike to Wiki markup.\\n7-bit/ascii implementations.\\ndetecting reserved words.\\n6-bits/byte implementations.\\ncomment text comment\\n'comment' text 'comment'\\nCOMMENT text COMMENT\\ncomment text comment\\n.COMMENT TEXT .COMMENT\\nNotes:\\nComments in Algol W can appear anywhere whitespace is allowed. A comment starts with the reserved word 'comment' and ends with the next semi-colon. Alternatively a comment can start with a percent sign and end with the next percent sign or semi-colon.\\nA single word in the form of an identifier following the reserved word 'end' is also a comment.\\nArendelle uses C style comments\\nSee programming introduction in the Asymptote manual.\\nWhen reading data files a comment character in them can be specified as comment=\""#\"" etc. See Files in the Asymptote manual.\\nFor multi-line comments, the /* and */ must be on their own separate lines. Nothing else can be on the same line.\\nThe hash symbol # start a comment; it ends at the end of line.\\n\\nThe only truly standard method of marking a comment in BASIC is using the REM keyword. This dates back to (at least) the late 1970's, and should work with most BASICs available today:\\nThis may not be well known, but you may include text after the line number of GOTO and GOSUB statements. This is kind of a comment in absence of labels.\\nSpaces are removed from non-keyword text. BASIC keywords can be used.\\nList outputs spaces around keywords.\\nMost BASICs also support alternate comment characters,\\ncommonly an apostrophe (single quote):\\nCharacters other than apostrophe are used in some BASICs. For example, DarkBASIC uses a back-tick character (`, a.k.a. grave accent):\\nIn addition to single-line comments, a few BASICs support block comments. FreeBASIC was influenced by the C family's block comment characters:\\nBaCon accepts REM (or single quote apostrophe) for line comments.\\nC-style block comments can be used with /* and */ pairs; these comment blocks may cross line boundaries.\\nInside USEC sections, all comment styles accepted by the configured C compiler will also be ignored.\\nThere is another (unsupported) option, using a double-colon ::. However, this has issues with some syntactic constructs and therefore may raise syntax errors.\\nSince comment lines are skipped entirely by the parser multi-line comments aren't possible even with line continuation.\\n\\nLike Brainf***, all characters and whitespace which are not commands are ignored.\\nAlso, since the code/data-space is two-dimensional, comments can be placed anywhere that will be untouched by the instruction pointer and data access commands.\\nFinally, in Funge-98, the ; instruction immediately skips to the next ; instruction, which allows to isolate comments from code.\\nBracmat uses curly braces as comment delimiters. Curly braces inside comments must be balanced. Comments are so much ignored when source code is read, that they do not reappear in listings created by the built-in lst$ function, an otherwise very useful function to autoindent your code.\\nMost ASCII characters may be used for comments; only the eight characters \""+-<>[],.\"" are Brainf*** commands. Extra care must be used when using punctuation, particularly the comma or period. These are I/O operators and are actually commands rather than comments, and are instead compiled into the program if used and may have to be \""debugged\"" and removed if you forget this issue.\\nBurlesque does NOT have comments. However, you can comment code by pushing a string and popping it immediately.\\nSince strings are multi-line strings:\\nThe comment starts at the /*, and ends at the */. A comment may be used between any tokens. It cannot be used inside tokens, that is, given the code\\nthe function takes an argument of type char, named isma, not an unnamed argument of type charisma.\\nComments cannot be nested; that is, if you write\\nthe comment ends at the first */, and inside */ is again interpreted as source code (almost certainly causing a compile error). Some compilers have the option to allow nested comments, but this is not a standard feature.\\nConditional compilation also can be used to make the compiler ignore some text:\\nThe trick is that 0 is always false, therefore the text between #if 0 and #endif is never compiled. While this should never be used for actual comments, it's an easy way to comment out some code, especially because it doesn't interfere with normal (documentation) comments.\\nConditional compile \""comments\"" can be nested:\\nEven though the compiler doesn't see #if 0 text, the preprocessor does. Therefore some minimal rules still have to be followed. For example, the following code is not valid:\\nThat's because the preprocessor will interpret the apostrophe as beginning of a character constant, and will complain because that character constant isn't terminated with another apostrophe.\\nNote that the problem mentioned above cannot occur if there's valid code between the #if 0 and #endif.\\nSingle line C++-style comments\\nC++-style comments start with // and reach up to, but not including, the end of line (more exactly, up to the next unescaped newline). While formally, C++-style comments cannot be nested either, in practice they can:\\nThat's because starting with the first // everything in the line is ignored, including the second //.\\nThe fact that the newline is not part of the comment is important for multi-line macro definitions. It means that in the code\\nthe line (no more macro text) is not part of the macro definition. Also escaping the line break at the end of the comment with '\\' doesn't help, because that would make the third line part of the comment instead. Comments inside macros therefore have to be C-style.\\nClean comments are similar to C++.\\nIn contrast to C++ comments can be nested.\\nAnything from a semicolon to the end of a line is a comment.\\nThe (comment) macro will prevent a form from being evaluated, returning nil no matter what is contained in the comment. However the forms inside the comment form must be properly parseable (parentheses balanced, etc.) or an exception will be thrown.\\nFinally, the #_ reader macro will cause a form to be ignored by the reader. Unlike (comment), this does not return nil; the surrounding code is evaluated as though the ignored form isn't even there.\\nA D in the 7th column indicates a debugging line which is treated like a comment unless a compiler flag is set.\\nThis indicates a debugging line like above, but if it is used in fixed format files, it must be in the 8th column or beyond. Not necessarily. GnuCOBOL also supports D as an indicator in column 7, the >>D format works (more by trickery than spec) if the angle brackets start in column 5, the D ending up in column 7. The >>D debug marker can then be both fixed and free form compatible.\\nThis statement causes everything following it up to the next separator period to be treated as a comment. This statement was deleted in COBOL-74.\\nThere are quite a few IDENTIFICATION DIVISION obsolete and extension reserved words that will work in GnuCOBOL 2.\\nIn tags:\\nIn script:\\nCommon Lisp provides line comments (;) and block comments (#|...|#).\\nBlock comments can nest (#|...#|...|#...|#), unlike block comments in e.g. C.\\nIn a common convention, header comments are prefaced with four semicolons, top-level (function level) comments use three, comments for sections of code use two, and margin comments use one.\\nHowever, comments should not be used for inline documentation, as most defining constructs permit a documentation string (which is then available at runtime).\\nThere is no comment syntax in POSIX dc. The convention is to make a string on the stack and move it to an unused register; a no-op.\\nGNU dc added the comment syntax of many other scripting languages.\\nComments are only allowed in places such as \""on load\"" scripts. You cannot put them in form or view definitions.\\nIn addition to Pascal, Delphi also allows C++ style single line comments:\\nAll comments span to the end of the line; there are no paired-delimiter comment syntaxes. “#” begins a comment anywhere outside of quotes; “?” and “>” begin comments only if they are at the beginning of a line (except for whitespace), because those characters are also used for infix operators.\\nIn Updoc, “?” indicates the beginning of a program fragment, “>” the continuation of one, and “#” begins the expected output from its evaluation; “??” indicates special directives.\\nSingle-line comments must begin with //\\nBlock comments must be delimited with /* and */\\nThe original EDSAC made no provision for comments in source code. Modern simulators, however, accept square brackets as comment delimiters.\\nElixir does not have multiple line comments.\\nA comment is started by ; and reaches to the end of the line.\\nThere are some coding conventions for ;; align to indentation, ;;; sections, etc,\\nAnother way to add comments is to use strings at places where the result of an expression is ignored, since they simply evaluate to themselves without any effect. Note that strings can be multi-line:\\nNote that strings at the beginning of function definitions are interpreted as documentation strings for the function (i.e. Emacs will display them if asked for help about the function), e.g.\\nDue to this, it's debatable if the string at that place can be considered as comment.\\n\\nSingle line comment:\\n\\nMultiline C-style comment:\\nF# accepts C++ type line comments and OCaml type block comments\\nFalcon supports C-language style single line and block comments. A single line comment begins with two slashes (//) and ends at the end of the line. A block comment begins with a slash followed by an asterisk, and terminates when an asterisk followed by a slash is met (/*...*/).\\nSince ><> is a funge-like language, all characters not touched by the command pointer or modified by the p and g commands can be comments.\\nUnlike Brainf***, unknown commands are not ignored by the compiler, they just raise an error.\\nStandard Forth includes a number of ways to add comment text. As with everything in Forth, comment characters are actually words that control the compiler.\\nTraditionally, the paren comments are used for \""stack effect\"" notation:\\nThis comment means \""myword takes two cells on the stack and leaves one\"". Sometimes, stack effect comment names give clues about the word's function:\\nSome Forth systems implement other commenting words, such as these words from Win32Forth:\\nCompiler: ANSI FORTRAN 77 or compatible (like g77 -strict)\\nThe first six columns in Fortran are traditionally reserved for labels and certain special characters. In particular the letter \""C\"" in the first column indicates a comment:\\nSome Fortran compilers have the extension that comments starting with D are treated as non-comments if a special debugging flag is given at the compiler invocation. For example:\\nISO Fortran 90 or later have an inline comment (!) syntax:\\nIn ISO Fortran 90 or later, \""C in first column\"" comments are only allowed in the \""fixed\"" source form familiar to FORTRAN 77 programmers. The \""free\"" source form only has inline comments (!).\\nISO Fortran 95 or later has an optional conditional compilation syntax. If present, it can be used (abused?) to (in effect) comment out blocks of code:\\n\\nIn gambas, comments can be inserted by prefixing them with an apostrophe. The gambas interpreter will ignore the apostrophe and any other characters that follow it until the end of the line:\\nA shebang (#!) may be used as a comment in the first line of a file.\\nsingle-line comment:\\nmulti-line comment:\\nThe way backslash continues a comment means that comments can't usefully be put within a multi-line function definition,\\n# through to newline.\\n// works similarly but is reckoned the \""old way\"" (as of Gri 2.12.23)\\nBoth forms can be used in input data files too.\\nAny text after \""#\"" is a comment.\\nThe The Icon Programming Library established conventions for commenting library additions and functions. This included both header block comments and meta comments on procedures within library files.\\nThe comment character in IDL is the semicolon - everything starting with it and to the end of the line is a comment. Like this:\\nJava has two ways to enter normal comments, plus a third type of comment that doubles as a way to generate HTML documentation.\\nThis C-style comment starts with /* and ends with */.\\nThe two delimiters may be on the same or separate lines.\\nThis style comment may be used anywhere white space is permitted.\\nThis C++-style comment starts with // and extends to the end of line.\\nJavadoc is a standardized documentation code for Java. Its comments begin with a forward slash and two stars. Javadoc comments have different tags that signify different things in the methods and classes that they precede.\\nYour editor will probably colour this as great big comment, but it compiles and prints \""Hello World!\"". Once you've figured out how this works, try this discussion on why it's allowed.\\nfirst form\\nsecond form\\nMulti-line comments cannot be nested.\\n\\nExcept when a hash symbol (#) appears within a string, it begins a comment that continues to the end of the line:\\nThis image is a VI Snippet, an executable image of LabVIEW code. The LabVIEW version is shown on the top-right hand corner. You can download it, then drag-and-drop it onto the LabVIEW block diagram from a file browser, and it will appear as runnable, editable code.\\nIn LaTeX, comments look like this:\\nLaTeX comments start with % and continue up to and including the line break. The fact that the line break itself is commented out as well makes it useful for adding line breaks in the source code of complex macros without LaTeX interpreting them (which may cause extra space or even a paragraph break in the resulting typeset text). For example, the following results in the one word \""understandable\"":\\nWithout the percent sign after \\firstpart{stand}, it would have been the two words \""understand able\"".\\nThere are two kinds of comments:\\nand\\nLike with C, block comments don't nest.\\nIn Lingo any line starting with \""--\"" is a comment and ignored by the interpreter.\\nLotusScript has two ways to enter comments.\\nWherever the single quote (') is used, the rest of the line is treated as a comment and ignored. Multi-line comments would each need a single quote mark. This style of comment is usually used for making small in-line or single line comments.\\nA %REM marker begins a comment block, and a %END REM marker ends the comment block. This style of comment is used for making longer multi-line comments, often at the beginning of a class, sub or function.\\nThe author of LSE comments the stack effect of words with header comments as follows:\\nThere is no multi line comment. We have to use ' or \\\\nThere are three types of remarks. After statement with a dark color, in a line, with no statements, with the current pen color, and the Rem statement. Rem statement skip statements in current line, but m2000 editor render these using syntax highlight.\\n\\n","// This is a comment"
"C++","Comments","Show all ways to include text in a language source file\\nthat's completely ignored by the compiler or interpreter.\\n\\n\\n\\nNote: syntax depends on the assembler software but use of a semicolon is fairly standard\\nNote: syntax depends on the assembler software but use of a semicolon is fairly standard\\nJust like Common Lisp:\\nAgena has single line comments and two styles of multi-line comments.\\nA comment in ALGOL 60 takes the place of a single instruction.\\nComments can be inserted in variety of ways:\\nincludes bold typeface.\\nlike to Wiki markup.\\n7-bit/ascii implementations.\\ndetecting reserved words.\\n6-bits/byte implementations.\\ncomment text comment\\n'comment' text 'comment'\\nCOMMENT text COMMENT\\ncomment text comment\\n.COMMENT TEXT .COMMENT\\nNotes:\\nComments in Algol W can appear anywhere whitespace is allowed. A comment starts with the reserved word 'comment' and ends with the next semi-colon. Alternatively a comment can start with a percent sign and end with the next percent sign or semi-colon.\\nA single word in the form of an identifier following the reserved word 'end' is also a comment.\\nArendelle uses C style comments\\nSee programming introduction in the Asymptote manual.\\nWhen reading data files a comment character in them can be specified as comment=\""#\"" etc. See Files in the Asymptote manual.\\nFor multi-line comments, the /* and */ must be on their own separate lines. Nothing else can be on the same line.\\nThe hash symbol # start a comment; it ends at the end of line.\\n\\nThe only truly standard method of marking a comment in BASIC is using the REM keyword. This dates back to (at least) the late 1970's, and should work with most BASICs available today:\\nThis may not be well known, but you may include text after the line number of GOTO and GOSUB statements. This is kind of a comment in absence of labels.\\nSpaces are removed from non-keyword text. BASIC keywords can be used.\\nList outputs spaces around keywords.\\nMost BASICs also support alternate comment characters,\\ncommonly an apostrophe (single quote):\\nCharacters other than apostrophe are used in some BASICs. For example, DarkBASIC uses a back-tick character (`, a.k.a. grave accent):\\nIn addition to single-line comments, a few BASICs support block comments. FreeBASIC was influenced by the C family's block comment characters:\\nBaCon accepts REM (or single quote apostrophe) for line comments.\\nC-style block comments can be used with /* and */ pairs; these comment blocks may cross line boundaries.\\nInside USEC sections, all comment styles accepted by the configured C compiler will also be ignored.\\nThere is another (unsupported) option, using a double-colon ::. However, this has issues with some syntactic constructs and therefore may raise syntax errors.\\nSince comment lines are skipped entirely by the parser multi-line comments aren't possible even with line continuation.\\n\\nLike Brainf***, all characters and whitespace which are not commands are ignored.\\nAlso, since the code/data-space is two-dimensional, comments can be placed anywhere that will be untouched by the instruction pointer and data access commands.\\nFinally, in Funge-98, the ; instruction immediately skips to the next ; instruction, which allows to isolate comments from code.\\nBracmat uses curly braces as comment delimiters. Curly braces inside comments must be balanced. Comments are so much ignored when source code is read, that they do not reappear in listings created by the built-in lst$ function, an otherwise very useful function to autoindent your code.\\nMost ASCII characters may be used for comments; only the eight characters \""+-<>[],.\"" are Brainf*** commands. Extra care must be used when using punctuation, particularly the comma or period. These are I/O operators and are actually commands rather than comments, and are instead compiled into the program if used and may have to be \""debugged\"" and removed if you forget this issue.\\nBurlesque does NOT have comments. However, you can comment code by pushing a string and popping it immediately.\\nSince strings are multi-line strings:\\nThe comment starts at the /*, and ends at the */. A comment may be used between any tokens. It cannot be used inside tokens, that is, given the code\\nthe function takes an argument of type char, named isma, not an unnamed argument of type charisma.\\nComments cannot be nested; that is, if you write\\nthe comment ends at the first */, and inside */ is again interpreted as source code (almost certainly causing a compile error). Some compilers have the option to allow nested comments, but this is not a standard feature.\\nConditional compilation also can be used to make the compiler ignore some text:\\nThe trick is that 0 is always false, therefore the text between #if 0 and #endif is never compiled. While this should never be used for actual comments, it's an easy way to comment out some code, especially because it doesn't interfere with normal (documentation) comments.\\nConditional compile \""comments\"" can be nested:\\nEven though the compiler doesn't see #if 0 text, the preprocessor does. Therefore some minimal rules still have to be followed. For example, the following code is not valid:\\nThat's because the preprocessor will interpret the apostrophe as beginning of a character constant, and will complain because that character constant isn't terminated with another apostrophe.\\nNote that the problem mentioned above cannot occur if there's valid code between the #if 0 and #endif.\\nSingle line C++-style comments\\nC++-style comments start with // and reach up to, but not including, the end of line (more exactly, up to the next unescaped newline). While formally, C++-style comments cannot be nested either, in practice they can:\\nThat's because starting with the first // everything in the line is ignored, including the second //.\\nThe fact that the newline is not part of the comment is important for multi-line macro definitions. It means that in the code\\nthe line (no more macro text) is not part of the macro definition. Also escaping the line break at the end of the comment with '\\' doesn't help, because that would make the third line part of the comment instead. Comments inside macros therefore have to be C-style.\\nClean comments are similar to C++.\\nIn contrast to C++ comments can be nested.\\nAnything from a semicolon to the end of a line is a comment.\\nThe (comment) macro will prevent a form from being evaluated, returning nil no matter what is contained in the comment. However the forms inside the comment form must be properly parseable (parentheses balanced, etc.) or an exception will be thrown.\\nFinally, the #_ reader macro will cause a form to be ignored by the reader. Unlike (comment), this does not return nil; the surrounding code is evaluated as though the ignored form isn't even there.\\nA D in the 7th column indicates a debugging line which is treated like a comment unless a compiler flag is set.\\nThis indicates a debugging line like above, but if it is used in fixed format files, it must be in the 8th column or beyond. Not necessarily. GnuCOBOL also supports D as an indicator in column 7, the >>D format works (more by trickery than spec) if the angle brackets start in column 5, the D ending up in column 7. The >>D debug marker can then be both fixed and free form compatible.\\nThis statement causes everything following it up to the next separator period to be treated as a comment. This statement was deleted in COBOL-74.\\nThere are quite a few IDENTIFICATION DIVISION obsolete and extension reserved words that will work in GnuCOBOL 2.\\nIn tags:\\nIn script:\\nCommon Lisp provides line comments (;) and block comments (#|...|#).\\nBlock comments can nest (#|...#|...|#...|#), unlike block comments in e.g. C.\\nIn a common convention, header comments are prefaced with four semicolons, top-level (function level) comments use three, comments for sections of code use two, and margin comments use one.\\nHowever, comments should not be used for inline documentation, as most defining constructs permit a documentation string (which is then available at runtime).\\nThere is no comment syntax in POSIX dc. The convention is to make a string on the stack and move it to an unused register; a no-op.\\nGNU dc added the comment syntax of many other scripting languages.\\nComments are only allowed in places such as \""on load\"" scripts. You cannot put them in form or view definitions.\\nIn addition to Pascal, Delphi also allows C++ style single line comments:\\nAll comments span to the end of the line; there are no paired-delimiter comment syntaxes. “#” begins a comment anywhere outside of quotes; “?” and “>” begin comments only if they are at the beginning of a line (except for whitespace), because those characters are also used for infix operators.\\nIn Updoc, “?” indicates the beginning of a program fragment, “>” the continuation of one, and “#” begins the expected output from its evaluation; “??” indicates special directives.\\nSingle-line comments must begin with //\\nBlock comments must be delimited with /* and */\\nThe original EDSAC made no provision for comments in source code. Modern simulators, however, accept square brackets as comment delimiters.\\nElixir does not have multiple line comments.\\nA comment is started by ; and reaches to the end of the line.\\nThere are some coding conventions for ;; align to indentation, ;;; sections, etc,\\nAnother way to add comments is to use strings at places where the result of an expression is ignored, since they simply evaluate to themselves without any effect. Note that strings can be multi-line:\\nNote that strings at the beginning of function definitions are interpreted as documentation strings for the function (i.e. Emacs will display them if asked for help about the function), e.g.\\nDue to this, it's debatable if the string at that place can be considered as comment.\\n\\nSingle line comment:\\n\\nMultiline C-style comment:\\nF# accepts C++ type line comments and OCaml type block comments\\nFalcon supports C-language style single line and block comments. A single line comment begins with two slashes (//) and ends at the end of the line. A block comment begins with a slash followed by an asterisk, and terminates when an asterisk followed by a slash is met (/*...*/).\\nSince ><> is a funge-like language, all characters not touched by the command pointer or modified by the p and g commands can be comments.\\nUnlike Brainf***, unknown commands are not ignored by the compiler, they just raise an error.\\nStandard Forth includes a number of ways to add comment text. As with everything in Forth, comment characters are actually words that control the compiler.\\nTraditionally, the paren comments are used for \""stack effect\"" notation:\\nThis comment means \""myword takes two cells on the stack and leaves one\"". Sometimes, stack effect comment names give clues about the word's function:\\nSome Forth systems implement other commenting words, such as these words from Win32Forth:\\nCompiler: ANSI FORTRAN 77 or compatible (like g77 -strict)\\nThe first six columns in Fortran are traditionally reserved for labels and certain special characters. In particular the letter \""C\"" in the first column indicates a comment:\\nSome Fortran compilers have the extension that comments starting with D are treated as non-comments if a special debugging flag is given at the compiler invocation. For example:\\nISO Fortran 90 or later have an inline comment (!) syntax:\\nIn ISO Fortran 90 or later, \""C in first column\"" comments are only allowed in the \""fixed\"" source form familiar to FORTRAN 77 programmers. The \""free\"" source form only has inline comments (!).\\nISO Fortran 95 or later has an optional conditional compilation syntax. If present, it can be used (abused?) to (in effect) comment out blocks of code:\\n\\nIn gambas, comments can be inserted by prefixing them with an apostrophe. The gambas interpreter will ignore the apostrophe and any other characters that follow it until the end of the line:\\nA shebang (#!) may be used as a comment in the first line of a file.\\nsingle-line comment:\\nmulti-line comment:\\nThe way backslash continues a comment means that comments can't usefully be put within a multi-line function definition,\\n# through to newline.\\n// works similarly but is reckoned the \""old way\"" (as of Gri 2.12.23)\\nBoth forms can be used in input data files too.\\nAny text after \""#\"" is a comment.\\nThe The Icon Programming Library established conventions for commenting library additions and functions. This included both header block comments and meta comments on procedures within library files.\\nThe comment character in IDL is the semicolon - everything starting with it and to the end of the line is a comment. Like this:\\nJava has two ways to enter normal comments, plus a third type of comment that doubles as a way to generate HTML documentation.\\nThis C-style comment starts with /* and ends with */.\\nThe two delimiters may be on the same or separate lines.\\nThis style comment may be used anywhere white space is permitted.\\nThis C++-style comment starts with // and extends to the end of line.\\nJavadoc is a standardized documentation code for Java. Its comments begin with a forward slash and two stars. Javadoc comments have different tags that signify different things in the methods and classes that they precede.\\nYour editor will probably colour this as great big comment, but it compiles and prints \""Hello World!\"". Once you've figured out how this works, try this discussion on why it's allowed.\\nfirst form\\nsecond form\\nMulti-line comments cannot be nested.\\n\\nExcept when a hash symbol (#) appears within a string, it begins a comment that continues to the end of the line:\\nThis image is a VI Snippet, an executable image of LabVIEW code. The LabVIEW version is shown on the top-right hand corner. You can download it, then drag-and-drop it onto the LabVIEW block diagram from a file browser, and it will appear as runnable, editable code.\\nIn LaTeX, comments look like this:\\nLaTeX comments start with % and continue up to and including the line break. The fact that the line break itself is commented out as well makes it useful for adding line breaks in the source code of complex macros without LaTeX interpreting them (which may cause extra space or even a paragraph break in the resulting typeset text). For example, the following results in the one word \""understandable\"":\\nWithout the percent sign after \\firstpart{stand}, it would have been the two words \""understand able\"".\\nThere are two kinds of comments:\\nand\\nLike with C, block comments don't nest.\\nIn Lingo any line starting with \""--\"" is a comment and ignored by the interpreter.\\nLotusScript has two ways to enter comments.\\nWherever the single quote (') is used, the rest of the line is treated as a comment and ignored. Multi-line comments would each need a single quote mark. This style of comment is usually used for making small in-line or single line comments.\\nA %REM marker begins a comment block, and a %END REM marker ends the comment block. This style of comment is used for making longer multi-line comments, often at the beginning of a class, sub or function.\\nThe author of LSE comments the stack effect of words with header comments as follows:\\nThere is no multi line comment. We have to use ' or \\\\nThere are three types of remarks. After statement with a dark color, in a line, with no statements, with the current pen color, and the Rem statement. Rem statement skip statements in current line, but m2000 editor render these using syntax highlight.\\n\\n","// This is a valid comment // with a \""nested\"" comment"
"C++","Comments","Show all ways to include text in a language source file\\nthat's completely ignored by the compiler or interpreter.\\n\\n\\n\\nNote: syntax depends on the assembler software but use of a semicolon is fairly standard\\nNote: syntax depends on the assembler software but use of a semicolon is fairly standard\\nJust like Common Lisp:\\nAgena has single line comments and two styles of multi-line comments.\\nA comment in ALGOL 60 takes the place of a single instruction.\\nComments can be inserted in variety of ways:\\nincludes bold typeface.\\nlike to Wiki markup.\\n7-bit/ascii implementations.\\ndetecting reserved words.\\n6-bits/byte implementations.\\ncomment text comment\\n'comment' text 'comment'\\nCOMMENT text COMMENT\\ncomment text comment\\n.COMMENT TEXT .COMMENT\\nNotes:\\nComments in Algol W can appear anywhere whitespace is allowed. A comment starts with the reserved word 'comment' and ends with the next semi-colon. Alternatively a comment can start with a percent sign and end with the next percent sign or semi-colon.\\nA single word in the form of an identifier following the reserved word 'end' is also a comment.\\nArendelle uses C style comments\\nSee programming introduction in the Asymptote manual.\\nWhen reading data files a comment character in them can be specified as comment=\""#\"" etc. See Files in the Asymptote manual.\\nFor multi-line comments, the /* and */ must be on their own separate lines. Nothing else can be on the same line.\\nThe hash symbol # start a comment; it ends at the end of line.\\n\\nThe only truly standard method of marking a comment in BASIC is using the REM keyword. This dates back to (at least) the late 1970's, and should work with most BASICs available today:\\nThis may not be well known, but you may include text after the line number of GOTO and GOSUB statements. This is kind of a comment in absence of labels.\\nSpaces are removed from non-keyword text. BASIC keywords can be used.\\nList outputs spaces around keywords.\\nMost BASICs also support alternate comment characters,\\ncommonly an apostrophe (single quote):\\nCharacters other than apostrophe are used in some BASICs. For example, DarkBASIC uses a back-tick character (`, a.k.a. grave accent):\\nIn addition to single-line comments, a few BASICs support block comments. FreeBASIC was influenced by the C family's block comment characters:\\nBaCon accepts REM (or single quote apostrophe) for line comments.\\nC-style block comments can be used with /* and */ pairs; these comment blocks may cross line boundaries.\\nInside USEC sections, all comment styles accepted by the configured C compiler will also be ignored.\\nThere is another (unsupported) option, using a double-colon ::. However, this has issues with some syntactic constructs and therefore may raise syntax errors.\\nSince comment lines are skipped entirely by the parser multi-line comments aren't possible even with line continuation.\\n\\nLike Brainf***, all characters and whitespace which are not commands are ignored.\\nAlso, since the code/data-space is two-dimensional, comments can be placed anywhere that will be untouched by the instruction pointer and data access commands.\\nFinally, in Funge-98, the ; instruction immediately skips to the next ; instruction, which allows to isolate comments from code.\\nBracmat uses curly braces as comment delimiters. Curly braces inside comments must be balanced. Comments are so much ignored when source code is read, that they do not reappear in listings created by the built-in lst$ function, an otherwise very useful function to autoindent your code.\\nMost ASCII characters may be used for comments; only the eight characters \""+-<>[],.\"" are Brainf*** commands. Extra care must be used when using punctuation, particularly the comma or period. These are I/O operators and are actually commands rather than comments, and are instead compiled into the program if used and may have to be \""debugged\"" and removed if you forget this issue.\\nBurlesque does NOT have comments. However, you can comment code by pushing a string and popping it immediately.\\nSince strings are multi-line strings:\\nThe comment starts at the /*, and ends at the */. A comment may be used between any tokens. It cannot be used inside tokens, that is, given the code\\nthe function takes an argument of type char, named isma, not an unnamed argument of type charisma.\\nComments cannot be nested; that is, if you write\\nthe comment ends at the first */, and inside */ is again interpreted as source code (almost certainly causing a compile error). Some compilers have the option to allow nested comments, but this is not a standard feature.\\nConditional compilation also can be used to make the compiler ignore some text:\\nThe trick is that 0 is always false, therefore the text between #if 0 and #endif is never compiled. While this should never be used for actual comments, it's an easy way to comment out some code, especially because it doesn't interfere with normal (documentation) comments.\\nConditional compile \""comments\"" can be nested:\\nEven though the compiler doesn't see #if 0 text, the preprocessor does. Therefore some minimal rules still have to be followed. For example, the following code is not valid:\\nThat's because the preprocessor will interpret the apostrophe as beginning of a character constant, and will complain because that character constant isn't terminated with another apostrophe.\\nNote that the problem mentioned above cannot occur if there's valid code between the #if 0 and #endif.\\nSingle line C++-style comments\\nC++-style comments start with // and reach up to, but not including, the end of line (more exactly, up to the next unescaped newline). While formally, C++-style comments cannot be nested either, in practice they can:\\nThat's because starting with the first // everything in the line is ignored, including the second //.\\nThe fact that the newline is not part of the comment is important for multi-line macro definitions. It means that in the code\\nthe line (no more macro text) is not part of the macro definition. Also escaping the line break at the end of the comment with '\\' doesn't help, because that would make the third line part of the comment instead. Comments inside macros therefore have to be C-style.\\nClean comments are similar to C++.\\nIn contrast to C++ comments can be nested.\\nAnything from a semicolon to the end of a line is a comment.\\nThe (comment) macro will prevent a form from being evaluated, returning nil no matter what is contained in the comment. However the forms inside the comment form must be properly parseable (parentheses balanced, etc.) or an exception will be thrown.\\nFinally, the #_ reader macro will cause a form to be ignored by the reader. Unlike (comment), this does not return nil; the surrounding code is evaluated as though the ignored form isn't even there.\\nA D in the 7th column indicates a debugging line which is treated like a comment unless a compiler flag is set.\\nThis indicates a debugging line like above, but if it is used in fixed format files, it must be in the 8th column or beyond. Not necessarily. GnuCOBOL also supports D as an indicator in column 7, the >>D format works (more by trickery than spec) if the angle brackets start in column 5, the D ending up in column 7. The >>D debug marker can then be both fixed and free form compatible.\\nThis statement causes everything following it up to the next separator period to be treated as a comment. This statement was deleted in COBOL-74.\\nThere are quite a few IDENTIFICATION DIVISION obsolete and extension reserved words that will work in GnuCOBOL 2.\\nIn tags:\\nIn script:\\nCommon Lisp provides line comments (;) and block comments (#|...|#).\\nBlock comments can nest (#|...#|...|#...|#), unlike block comments in e.g. C.\\nIn a common convention, header comments are prefaced with four semicolons, top-level (function level) comments use three, comments for sections of code use two, and margin comments use one.\\nHowever, comments should not be used for inline documentation, as most defining constructs permit a documentation string (which is then available at runtime).\\nThere is no comment syntax in POSIX dc. The convention is to make a string on the stack and move it to an unused register; a no-op.\\nGNU dc added the comment syntax of many other scripting languages.\\nComments are only allowed in places such as \""on load\"" scripts. You cannot put them in form or view definitions.\\nIn addition to Pascal, Delphi also allows C++ style single line comments:\\nAll comments span to the end of the line; there are no paired-delimiter comment syntaxes. “#” begins a comment anywhere outside of quotes; “?” and “>” begin comments only if they are at the beginning of a line (except for whitespace), because those characters are also used for infix operators.\\nIn Updoc, “?” indicates the beginning of a program fragment, “>” the continuation of one, and “#” begins the expected output from its evaluation; “??” indicates special directives.\\nSingle-line comments must begin with //\\nBlock comments must be delimited with /* and */\\nThe original EDSAC made no provision for comments in source code. Modern simulators, however, accept square brackets as comment delimiters.\\nElixir does not have multiple line comments.\\nA comment is started by ; and reaches to the end of the line.\\nThere are some coding conventions for ;; align to indentation, ;;; sections, etc,\\nAnother way to add comments is to use strings at places where the result of an expression is ignored, since they simply evaluate to themselves without any effect. Note that strings can be multi-line:\\nNote that strings at the beginning of function definitions are interpreted as documentation strings for the function (i.e. Emacs will display them if asked for help about the function), e.g.\\nDue to this, it's debatable if the string at that place can be considered as comment.\\n\\nSingle line comment:\\n\\nMultiline C-style comment:\\nF# accepts C++ type line comments and OCaml type block comments\\nFalcon supports C-language style single line and block comments. A single line comment begins with two slashes (//) and ends at the end of the line. A block comment begins with a slash followed by an asterisk, and terminates when an asterisk followed by a slash is met (/*...*/).\\nSince ><> is a funge-like language, all characters not touched by the command pointer or modified by the p and g commands can be comments.\\nUnlike Brainf***, unknown commands are not ignored by the compiler, they just raise an error.\\nStandard Forth includes a number of ways to add comment text. As with everything in Forth, comment characters are actually words that control the compiler.\\nTraditionally, the paren comments are used for \""stack effect\"" notation:\\nThis comment means \""myword takes two cells on the stack and leaves one\"". Sometimes, stack effect comment names give clues about the word's function:\\nSome Forth systems implement other commenting words, such as these words from Win32Forth:\\nCompiler: ANSI FORTRAN 77 or compatible (like g77 -strict)\\nThe first six columns in Fortran are traditionally reserved for labels and certain special characters. In particular the letter \""C\"" in the first column indicates a comment:\\nSome Fortran compilers have the extension that comments starting with D are treated as non-comments if a special debugging flag is given at the compiler invocation. For example:\\nISO Fortran 90 or later have an inline comment (!) syntax:\\nIn ISO Fortran 90 or later, \""C in first column\"" comments are only allowed in the \""fixed\"" source form familiar to FORTRAN 77 programmers. The \""free\"" source form only has inline comments (!).\\nISO Fortran 95 or later has an optional conditional compilation syntax. If present, it can be used (abused?) to (in effect) comment out blocks of code:\\n\\nIn gambas, comments can be inserted by prefixing them with an apostrophe. The gambas interpreter will ignore the apostrophe and any other characters that follow it until the end of the line:\\nA shebang (#!) may be used as a comment in the first line of a file.\\nsingle-line comment:\\nmulti-line comment:\\nThe way backslash continues a comment means that comments can't usefully be put within a multi-line function definition,\\n# through to newline.\\n// works similarly but is reckoned the \""old way\"" (as of Gri 2.12.23)\\nBoth forms can be used in input data files too.\\nAny text after \""#\"" is a comment.\\nThe The Icon Programming Library established conventions for commenting library additions and functions. This included both header block comments and meta comments on procedures within library files.\\nThe comment character in IDL is the semicolon - everything starting with it and to the end of the line is a comment. Like this:\\nJava has two ways to enter normal comments, plus a third type of comment that doubles as a way to generate HTML documentation.\\nThis C-style comment starts with /* and ends with */.\\nThe two delimiters may be on the same or separate lines.\\nThis style comment may be used anywhere white space is permitted.\\nThis C++-style comment starts with // and extends to the end of line.\\nJavadoc is a standardized documentation code for Java. Its comments begin with a forward slash and two stars. Javadoc comments have different tags that signify different things in the methods and classes that they precede.\\nYour editor will probably colour this as great big comment, but it compiles and prints \""Hello World!\"". Once you've figured out how this works, try this discussion on why it's allowed.\\nfirst form\\nsecond form\\nMulti-line comments cannot be nested.\\n\\nExcept when a hash symbol (#) appears within a string, it begins a comment that continues to the end of the line:\\nThis image is a VI Snippet, an executable image of LabVIEW code. The LabVIEW version is shown on the top-right hand corner. You can download it, then drag-and-drop it onto the LabVIEW block diagram from a file browser, and it will appear as runnable, editable code.\\nIn LaTeX, comments look like this:\\nLaTeX comments start with % and continue up to and including the line break. The fact that the line break itself is commented out as well makes it useful for adding line breaks in the source code of complex macros without LaTeX interpreting them (which may cause extra space or even a paragraph break in the resulting typeset text). For example, the following results in the one word \""understandable\"":\\nWithout the percent sign after \\firstpart{stand}, it would have been the two words \""understand able\"".\\nThere are two kinds of comments:\\nand\\nLike with C, block comments don't nest.\\nIn Lingo any line starting with \""--\"" is a comment and ignored by the interpreter.\\nLotusScript has two ways to enter comments.\\nWherever the single quote (') is used, the rest of the line is treated as a comment and ignored. Multi-line comments would each need a single quote mark. This style of comment is usually used for making small in-line or single line comments.\\nA %REM marker begins a comment block, and a %END REM marker ends the comment block. This style of comment is used for making longer multi-line comments, often at the beginning of a class, sub or function.\\nThe author of LSE comments the stack effect of words with header comments as follows:\\nThere is no multi line comment. We have to use ' or \\\\nThere are three types of remarks. After statement with a dark color, in a line, with no statements, with the current pen color, and the Rem statement. Rem statement skip statements in current line, but m2000 editor render these using syntax highlight.\\n\\n","#define FOO \\\\n  (macro text) // comment\\n  (no more macro text)"
"C++","Compare_a_list_of_strings","Given a   list   of arbitrarily many strings, show how to:\\n\\nEach of those two tests should result in a single true or false value, which could be used as the condition of an    if    statement or similar.\\nIf the input list has less than two elements, the tests should always return true.\\nThere is no need to provide a complete program and output.\\nAssume that the strings are already stored in an array/list/sequence/tuple variable (whatever is most idiomatic) with the name   strings,   and just show the expressions for performing those two tests on it (plus of course any includes and custom functions etc. that it needs),   with as little distractions as possible.\\nTry to write your solution in a way that does not modify the original list,   but if it does then please add a note to make that clear to readers.\\nIf you need further guidance/clarification,   see #Perl and #Python for solutions that use implicit short-circuiting loops,   and #Perl_6 for a solution that gets away with simply using a built-in language feature. \\n\\n\\nThe program uses one ASSIST macro (XPRNT) to keep the code as short as possible.\\n","#include <algorithm>\\n#include <string>\\n\\nstd::all_of( ++(strings.begin()), strings.end(),\\n             [&](std::string a){ return a == strings.front(); } )  // All equal\\n\\nstd::is_sorted( strings.begin(), strings.end(),\\n                [](std::string a, std::string b){ return !(b < a); }) )  // Strictly ascending"
"C++","Compile-time_calculation","Some programming languages allow calculation of values at compile time.\\n\\nCalculate    10!    (ten factorial)   at compile time.\\nPrint the result when the program is run.\\nDiscuss what limitations apply to compile-time calculations in your language.\\n\\nFirst example with the assembler equivalence pseudo instruction (EQU):\\n","#include <iostream>\\n\\ntemplate struct Fac\\n{\\n    static const int result = i * Fac<i-1>::result;\\n};\\n\\ntemplate<> struct Fac<1>\\n{\\n    static const int result = 1;\\n};\\n\\n\\nint main()\\n{\\n    std::cout << \""10! = \"" << Fac<10>::result << \""\\n\"";\\n    return 0;\\n}"
"C++","Compile-time_calculation","Some programming languages allow calculation of values at compile time.\\n\\nCalculate    10!    (ten factorial)   at compile time.\\nPrint the result when the program is run.\\nDiscuss what limitations apply to compile-time calculations in your language.\\n\\nFirst example with the assembler equivalence pseudo instruction (EQU):\\n","#include <stdio.h>\\n\\nconstexpr int factorial(int n) {\\n    return n ? (n * factorial(n - 1)) : 1;\\n}\\n\\nconstexpr int f10 = factorial(10);\\n\\nint main() {\\n    printf(\""%d\\n\"", f10);\\n    return 0;\\n}"
"C++","Compile-time_calculation","Some programming languages allow calculation of values at compile time.\\n\\nCalculate    10!    (ten factorial)   at compile time.\\nPrint the result when the program is run.\\nDiscuss what limitations apply to compile-time calculations in your language.\\n\\nFirst example with the assembler equivalence pseudo instruction (EQU):\\n","_main:\\n	pushl	%ebp\\n	movl	%esp, %ebp\\n	andl	$-16, %esp\\n	subl	$16, %esp\\n	call	___main\\n	movl	$3628800, 4(%esp)\\n	movl	$LC0, (%esp)\\n	call	_printf\\n	movl	$0, %eax\\n	leave\\n	ret"
"C++","Compound_data_type","Data Structure\\nThis illustrates a data structure, a means of storing data within a program.\\n\\nCreate a compound data type:\\n\\nA compound data type is one that holds multiple independent values.\\n\\n\\n\\n","struct Point\\n{\\n  int x;\\n  int y;\\n};"
"C++","Compound_data_type","Data Structure\\nThis illustrates a data structure, a means of storing data within a program.\\n\\nCreate a compound data type:\\n\\nA compound data type is one that holds multiple independent values.\\n\\n\\n\\n","struct Point\\n{\\n  int x;\\n  int y;\\n  Point(int ax, int ay): x(ax), y(ax) {}\\n};"
"C++","Compound_data_type","Data Structure\\nThis illustrates a data structure, a means of storing data within a program.\\n\\nCreate a compound data type:\\n\\nA compound data type is one that holds multiple independent values.\\n\\n\\n\\n","template struct point\\n{\\n  Coordinate x, y;\\n};\\n\\n// A point with integer coordinates\\nPoint<int> point1 = { 3, 5 };\\n\\n// a point with floating point coordinates\\nPoint<float> point2 = { 1.7, 3.6 };"
"C++","Concurrent_computing","Using either native language concurrency syntax or freely available libraries, write a program to display the strings \""Enjoy\"" \""Rosetta\"" \""Code\"", one string per line, in random order.\\nConcurrency syntax must use threads, tasks, co-routines, or whatever concurrency is called in your language.\\n\\nNote that random generator object is local to each task. It cannot be accessed concurrently without mutual exclusion. In order to get different initial states of local generators Reset is called (see ARM A.5.2).\\nBaCon is a BASIC-to-C compiler. Assuming GCC compiler in this demonstration. Based on the C OpenMP source.\\n","#include <thread>\\n#include <iostream>\\n#include <vector>\\n#include <random>\\n#include <chrono> \\n\\nint main()\\n{\\n  std::random_device rd;\\n  std::mt19937 eng(rd()); // mt19937 generator with a hardware random seed.\\n  std::uniform_int_distribution<> dist(1,1000);\\n  std::vector threads;\\n\\n  for(const auto& str: {\""Enjoy\\n\"", \""Rosetta\\n\"", \""Code\\n\""}) {\\n    // between 1 and 1000ms per our distribution\\n    std::chrono::milliseconds duration(dist(eng)); \\n\\n    threads.emplace_back([str, duration](){                                                                    \\n      std::this_thread::sleep_for(duration);\\n      std::cout << str;\\n    });\\n  }\\n\\n  for(auto& t: threads) t.join(); \\n\\n  return 0;\\n}"
"C++","Concurrent_computing","Using either native language concurrency syntax or freely available libraries, write a program to display the strings \""Enjoy\"" \""Rosetta\"" \""Code\"", one string per line, in random order.\\nConcurrency syntax must use threads, tasks, co-routines, or whatever concurrency is called in your language.\\n\\nNote that random generator object is local to each task. It cannot be accessed concurrently without mutual exclusion. In order to get different initial states of local generators Reset is called (see ARM A.5.2).\\nBaCon is a BASIC-to-C compiler. Assuming GCC compiler in this demonstration. Based on the C OpenMP source.\\n","#include <iostream>\\n#include <ppl.h> // MSVC++\\n\\nvoid a(void) { std::cout << \""Eat\\n\"";   }\\nvoid b(void) { std::cout << \""At\\n\"";    }\\nvoid c(void) { std::cout << \""Joe's\\n\""; }\\n\\nint main()\\n{\\n    // function pointers\\n    Concurrency::parallel_invoke(&a, &b, &c);\\n\\n    // C++11 lambda functions\\n    Concurrency::parallel_invoke(\\n        []{ std::cout << \""Enjoy\\n\"";   },\\n        []{ std::cout << \""Rosetta\\n\""; },\\n        []{ std::cout << \""Code\\n\"";    }\\n    );\\n    return 0;\\n}"
"C++","Conditional_structures","These are examples of control structures. You may also be interested in:\\nList the   conditional structures   offered by a programming language.\\nCommon conditional structures are     if-then-else     and     switch.\\n\\nHere are the branch mnemonic opcodes:\\nThe ASM (Assembler Structured Macros) toolkit brings structures to IBM assembler 360.\\n6502 Assembly has 8 conditional branch instructions; each instruction will test the appropriate flag and condition and jump between -128 and 127 bytes.\\nTo understand these conditional instructions, it is helpful to remember that the comparison instructions (CMP, CPX, CPY) set the flags as if a subtraction had occurred:\\nFollowing these instructions, the accumulator will still hold 10 but the flags are set as if you had instructed the processor to perform 10 - 11.\\nThe result is -1, so the sign flag will be set, the zero flag will be cleared, the overflow flag will be cleared, and the carry flag will be set.\\nIn the following example, the branch will be taken if memory location Variable holds 200:\\nBecause you don't have to perform a comparison to set the flags, you can perform very fast checks in interative loops:\\nThis code will loop until X is zero.\\nMost assemblers will figure out the correct offset for you if you use a label in place of the offset after a branch instruction, as in the above example.\\nWhen there is no when others clause, the compiler will complain about any uncovered alternative. This defends against a common reason for bugs in other languages.\\nI.e., the following code is syntactically incorrect:\\nThe syntactically correct version:\\nSelect provides conditional acceptance of entry calls.\\nSelect can also be used to conditionally call an entry\\nA selective entry call provides a way to time-out an entry call.\\nWithout the time-out the calling task will suspend until the entry call is accepted.\\nThe entry Start on the task My_Task will be called.\\nIf My_Task accepts the entry call before the timer expires the timer is canceled. If the timeout expires before the entry call is accepted the entry call is canceled.\\n\\nAlgol 60 has invented the famous if then else block structure.\\nAlgol 60 has conditional expressions of the form:\\nAlgol 60 has conditional statements of the form:\\nAn example:\\nAlgol 60 has also a switch structure:\\nAn example:\\nSee Conditional Structures/ALGOL 68\\n\\n","template struct ifthenelse;\\n\\ntemplate struct ifthenelse\\n{\\n  typedef ThenType type;\\n};\\n\\ntemplate struct ifthenelse\\n{\\n  typedef ElseType type;\\n};\\n\\n// example usage: select type based on size\\nifthenelse              // otherwise an int will do\\n  ::type myvar;              // define variable myvar with that type"
"C++","Constrained_random_points_on_a_circle","Generate 100 <x,y> coordinate pairs such that x and y are integers sampled from the uniform distribution with the condition that \\n\\n\\n\\n10\\n≤\\n\\n\\n\\nx\\n\\n2\\n\\n\\n+\\n\\ny\\n\\n2\\n\\n\\n\\n\\n≤\\n15\\n\\n\\n{\\displaystyle 10\\leq {\\sqrt {x^{2}+y^{2}}}\\leq 15}\\n\\n. Then display/plot them. The outcome should be a \""fuzzy\"" circle. The actual number of points plotted may be less than 100, given that some pairs may be generated more than once.\\nThere are several possible approaches to accomplish this. Here are two possible algorithms.\\n1) Generate random pairs of integers and filter out those that don't satisfy this condition:\\n2) Precalculate the set of all possible points (there are 404 of them) and select randomly from this set.\\n\\nOutput:\\nSample output:\\nRequires the GDI+ standard library by tic: http://www.autohotkey.com/forum/viewtopic.php?t=32238 Works with individual pixels.\\nPre calculate and plot 100 points to the console\\nConsole output:\\n\\nThe output may be a bit distorted, since even monospace fonts take more vertical space per character than horizontal space.\\nThis uses std.complex because D built-in complex numbers will be deprecated.\\n","\\n#include <windows.h>\\n#include <list>\\n#include <iostream>\\n\\n//--------------------------------------------------------------------------------------------------\\nusing namespace std;\\n\\n//--------------------------------------------------------------------------------------------------\\nclass point\\n{\\npublic:\\n    int x, y;\\n    point()                  { x = y = 0; }\\n    point( int a, int b )    { x = a; y = b; }\\n    void set( int a, int b ) { x = a; y = b; }\\n};\\n//--------------------------------------------------------------------------------------------------\\nclass rndCircle\\n{\\npublic:\\n    void draw()\\n    {\\n	createPoints();\\n	drawPoints();\\n    }\\n\\nprivate:\\n    void createPoints()\\n    {\\n	point pt;\\n	for( int x = 0; x < 200; x++ )\\n	{\\n	    int a, b, c;\\n	    while( true )\\n	    {\\n		a = rand() % 31 - 15;\\n		b = rand() % 31 - 15;\\n		c = a * a + b * b;\\n		if( c >= 100 && c <= 225 ) break;\\n	    }\\n	    pt.set( a, b );\\n	    _ptList.push_back( pt );\\n	}\\n    }\\n\\n    void drawPoints()\\n    {\\n	HDC dc = GetDC( GetConsoleWindow() );\\n	for( list<point>::iterator it = _ptList.begin(); it != _ptList.end(); it++ )\\n	    SetPixel( dc, 300 + 10 * ( *it ).x, 300 + 10 * ( *it ).y, RGB( 255, 255, 0 ) );\\n    }\\n\\n    list<point> _ptList;\\n};\\n//--------------------------------------------------------------------------------------------------\\nint main( int argc, char* argv[] )\\n{\\n    ShowWindow( GetConsoleWindow(), SW_MAXIMIZE );\\n    srand( GetTickCount() );\\n    rndCircle c;\\n    c.draw();\\n    system( \""pause\"" );\\n    return 0;\\n}\\n//--------------------------------------------------------------------------------------------------\\n"
"C++","Continued_fraction/Arithmetic/Construct_from_rational_number","The purpose of this task is to write a function \\n\\n\\n\\n\\n\\nr\\n2\\nc\\nf\\n\\n\\n(\\n\\ni\\nn\\nt\\n\\n\\n\\n{\\displaystyle {\\mathit {r2cf}}(\\mathrm {int} }\\n\\n \\n\\n\\n\\n\\nN\\n\\n1\\n\\n\\n,\\n\\ni\\nn\\nt\\n\\n\\n\\n{\\displaystyle N_{1},\\mathrm {int} }\\n\\n \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n)\\n\\n\\n{\\displaystyle N_{2})}\\n\\n, or \\n\\n\\n\\n\\n\\nr\\n2\\nc\\nf\\n\\n\\n(\\n\\nF\\nr\\na\\nc\\nt\\ni\\no\\nn\\n\\n\\n\\n{\\displaystyle {\\mathit {r2cf}}(\\mathrm {Fraction} }\\n\\n \\n\\n\\n\\nN\\n)\\n\\n\\n{\\displaystyle N)}\\n\\n, which will output a continued fraction assuming:\\nThe function should output its results one digit at a time each time it is called, in a manner sometimes described as lazy evaluation.\\nTo achieve this it must determine: the integer part; and remainder part, of \\n\\n\\n\\n\\nN\\n\\n1\\n\\n\\n\\n\\n{\\displaystyle N_{1}}\\n\\n divided by \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle N_{2}}\\n\\n. It then sets \\n\\n\\n\\n\\nN\\n\\n1\\n\\n\\n\\n\\n{\\displaystyle N_{1}}\\n\\n to \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle N_{2}}\\n\\n and \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle N_{2}}\\n\\n to the determined remainder part. It then outputs the determined integer part. It does this until \\n\\n\\n\\n\\na\\nb\\ns\\n\\n(\\n\\nN\\n\\n2\\n\\n\\n)\\n\\n\\n{\\displaystyle \\mathrm {abs} (N_{2})}\\n\\n is zero.\\nDemonstrate the function by outputing the continued fraction for:\\n\\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n should approach \\n\\n\\n\\n[\\n1\\n;\\n2\\n,\\n2\\n,\\n2\\n,\\n2\\n,\\n…\\n]\\n\\n\\n{\\displaystyle [1;2,2,2,2,\\ldots ]}\\n\\n try ever closer rational approximations until boredom gets the better of you:\\nTry :\\nObserve how this rational number behaves differently to \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n and convince yourself that, in the same way as \\n\\n\\n\\n3.7\\n\\n\\n{\\displaystyle 3.7}\\n\\n may be represented as \\n\\n\\n\\n3.70\\n\\n\\n{\\displaystyle 3.70}\\n\\n when an extra decimal place is required, \\n\\n\\n\\n[\\n3\\n;\\n7\\n]\\n\\n\\n{\\displaystyle [3;7]}\\n\\n may be represented as \\n\\n\\n\\n[\\n3\\n;\\n7\\n,\\n∞\\n]\\n\\n\\n{\\displaystyle [3;7,\\infty ]}\\n\\n when an extra term is required.\\nC does not implement Lazy evaluation and it is this particular feature which is the real challenge of this particular example. It can however be simulated. The following example uses pointers. It seems that the same data is being passed but since the function accepts pointers, the variables are being changed. One other way to simulate laziness would be to use global variables. Then although it would seem that the same values are being passed even as constants, the job is actually getting done. In my view, that would be plain cheating.\\nAnd the run gives :\\n","#include <iostream>\\n/* Interface for all Continued Fractions\\n   Nigel Galloway, February 9th., 2013.\\n*/\\nclass ContinuedFraction {\\n	public:\\n	virtual const int nextTerm(){};\\n	virtual const bool moreTerms(){};\\n};\\n/* Create a continued fraction from a rational number\\n   Nigel Galloway, February 9th., 2013.\\n*/\\nclass r2cf : public ContinuedFraction {\\n	private: int n1, n2;\\n	public:\\n	r2cf(const int numerator, const int denominator): n1(numerator), n2(denominator){}\\n	const int nextTerm() {\\n		const int thisTerm = n1/n2;\\n		const int t2 = n2; n2 = n1 - thisTerm * n2; n1 = t2;\\n		return thisTerm;\\n	}\\n	const bool moreTerms() {return fabs(n2) > 0;}\\n};\\n/* Generate a continued fraction for sqrt of 2\\n   Nigel Galloway, February 9th., 2013.\\n*/\\nclass SQRT2 : public ContinuedFraction {\\n	private: bool first=true;\\n	public:\\n	const int nextTerm() {if (first) {first = false; return 1;} else return 2;}\\n	const bool moreTerms() {return true;}\\n};"
"C++","Continued_fraction/Arithmetic/Construct_from_rational_number","The purpose of this task is to write a function \\n\\n\\n\\n\\n\\nr\\n2\\nc\\nf\\n\\n\\n(\\n\\ni\\nn\\nt\\n\\n\\n\\n{\\displaystyle {\\mathit {r2cf}}(\\mathrm {int} }\\n\\n \\n\\n\\n\\n\\nN\\n\\n1\\n\\n\\n,\\n\\ni\\nn\\nt\\n\\n\\n\\n{\\displaystyle N_{1},\\mathrm {int} }\\n\\n \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n)\\n\\n\\n{\\displaystyle N_{2})}\\n\\n, or \\n\\n\\n\\n\\n\\nr\\n2\\nc\\nf\\n\\n\\n(\\n\\nF\\nr\\na\\nc\\nt\\ni\\no\\nn\\n\\n\\n\\n{\\displaystyle {\\mathit {r2cf}}(\\mathrm {Fraction} }\\n\\n \\n\\n\\n\\nN\\n)\\n\\n\\n{\\displaystyle N)}\\n\\n, which will output a continued fraction assuming:\\nThe function should output its results one digit at a time each time it is called, in a manner sometimes described as lazy evaluation.\\nTo achieve this it must determine: the integer part; and remainder part, of \\n\\n\\n\\n\\nN\\n\\n1\\n\\n\\n\\n\\n{\\displaystyle N_{1}}\\n\\n divided by \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle N_{2}}\\n\\n. It then sets \\n\\n\\n\\n\\nN\\n\\n1\\n\\n\\n\\n\\n{\\displaystyle N_{1}}\\n\\n to \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle N_{2}}\\n\\n and \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle N_{2}}\\n\\n to the determined remainder part. It then outputs the determined integer part. It does this until \\n\\n\\n\\n\\na\\nb\\ns\\n\\n(\\n\\nN\\n\\n2\\n\\n\\n)\\n\\n\\n{\\displaystyle \\mathrm {abs} (N_{2})}\\n\\n is zero.\\nDemonstrate the function by outputing the continued fraction for:\\n\\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n should approach \\n\\n\\n\\n[\\n1\\n;\\n2\\n,\\n2\\n,\\n2\\n,\\n2\\n,\\n…\\n]\\n\\n\\n{\\displaystyle [1;2,2,2,2,\\ldots ]}\\n\\n try ever closer rational approximations until boredom gets the better of you:\\nTry :\\nObserve how this rational number behaves differently to \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n and convince yourself that, in the same way as \\n\\n\\n\\n3.7\\n\\n\\n{\\displaystyle 3.7}\\n\\n may be represented as \\n\\n\\n\\n3.70\\n\\n\\n{\\displaystyle 3.70}\\n\\n when an extra decimal place is required, \\n\\n\\n\\n[\\n3\\n;\\n7\\n]\\n\\n\\n{\\displaystyle [3;7]}\\n\\n may be represented as \\n\\n\\n\\n[\\n3\\n;\\n7\\n,\\n∞\\n]\\n\\n\\n{\\displaystyle [3;7,\\infty ]}\\n\\n when an extra term is required.\\nC does not implement Lazy evaluation and it is this particular feature which is the real challenge of this particular example. It can however be simulated. The following example uses pointers. It seems that the same data is being passed but since the function accepts pointers, the variables are being changed. One other way to simulate laziness would be to use global variables. Then although it would seem that the same values are being passed even as constants, the job is actually getting done. In my view, that would be plain cheating.\\nAnd the run gives :\\n","int main() {\\n	for(r2cf n(1,2); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n	std::cout << std::endl;\\n	for(r2cf n(3,1); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n	std::cout << std::endl;\\n	for(r2cf n(23,8); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n	std::cout << std::endl;\\n	for(r2cf n(13,11); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n	std::cout << std::endl;\\n	for(r2cf n(22,7); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n	std::cout << std::endl;\\n	for(r2cf cf(-151,77); cf.moreTerms(); std::cout << cf.nextTerm() << \"" \"");\\n	std::cout << std::endl;\\n	return 0;\\n}"
"C++","Continued_fraction/Arithmetic/Construct_from_rational_number","The purpose of this task is to write a function \\n\\n\\n\\n\\n\\nr\\n2\\nc\\nf\\n\\n\\n(\\n\\ni\\nn\\nt\\n\\n\\n\\n{\\displaystyle {\\mathit {r2cf}}(\\mathrm {int} }\\n\\n \\n\\n\\n\\n\\nN\\n\\n1\\n\\n\\n,\\n\\ni\\nn\\nt\\n\\n\\n\\n{\\displaystyle N_{1},\\mathrm {int} }\\n\\n \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n)\\n\\n\\n{\\displaystyle N_{2})}\\n\\n, or \\n\\n\\n\\n\\n\\nr\\n2\\nc\\nf\\n\\n\\n(\\n\\nF\\nr\\na\\nc\\nt\\ni\\no\\nn\\n\\n\\n\\n{\\displaystyle {\\mathit {r2cf}}(\\mathrm {Fraction} }\\n\\n \\n\\n\\n\\nN\\n)\\n\\n\\n{\\displaystyle N)}\\n\\n, which will output a continued fraction assuming:\\nThe function should output its results one digit at a time each time it is called, in a manner sometimes described as lazy evaluation.\\nTo achieve this it must determine: the integer part; and remainder part, of \\n\\n\\n\\n\\nN\\n\\n1\\n\\n\\n\\n\\n{\\displaystyle N_{1}}\\n\\n divided by \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle N_{2}}\\n\\n. It then sets \\n\\n\\n\\n\\nN\\n\\n1\\n\\n\\n\\n\\n{\\displaystyle N_{1}}\\n\\n to \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle N_{2}}\\n\\n and \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle N_{2}}\\n\\n to the determined remainder part. It then outputs the determined integer part. It does this until \\n\\n\\n\\n\\na\\nb\\ns\\n\\n(\\n\\nN\\n\\n2\\n\\n\\n)\\n\\n\\n{\\displaystyle \\mathrm {abs} (N_{2})}\\n\\n is zero.\\nDemonstrate the function by outputing the continued fraction for:\\n\\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n should approach \\n\\n\\n\\n[\\n1\\n;\\n2\\n,\\n2\\n,\\n2\\n,\\n2\\n,\\n…\\n]\\n\\n\\n{\\displaystyle [1;2,2,2,2,\\ldots ]}\\n\\n try ever closer rational approximations until boredom gets the better of you:\\nTry :\\nObserve how this rational number behaves differently to \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n and convince yourself that, in the same way as \\n\\n\\n\\n3.7\\n\\n\\n{\\displaystyle 3.7}\\n\\n may be represented as \\n\\n\\n\\n3.70\\n\\n\\n{\\displaystyle 3.70}\\n\\n when an extra decimal place is required, \\n\\n\\n\\n[\\n3\\n;\\n7\\n]\\n\\n\\n{\\displaystyle [3;7]}\\n\\n may be represented as \\n\\n\\n\\n[\\n3\\n;\\n7\\n,\\n∞\\n]\\n\\n\\n{\\displaystyle [3;7,\\infty ]}\\n\\n when an extra term is required.\\nC does not implement Lazy evaluation and it is this particular feature which is the real challenge of this particular example. It can however be simulated. The following example uses pointers. It seems that the same data is being passed but since the function accepts pointers, the variables are being changed. One other way to simulate laziness would be to use global variables. Then although it would seem that the same values are being passed even as constants, the job is actually getting done. In my view, that would be plain cheating.\\nAnd the run gives :\\n","int main() {\\n	int i = 0;\\n	for(SQRT2 n; i++ < 20; std::cout << n.nextTerm() << \"" \"");\\n	std::cout << std::endl;\\n	for(r2cf n(14142,10000); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n	std::cout << std::endl;\\n	for(r2cf n(14142136,10000000); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n	std::cout << std::endl;\\n	return 0;\\n}"
"C++","Continued_fraction/Arithmetic/Construct_from_rational_number","The purpose of this task is to write a function \\n\\n\\n\\n\\n\\nr\\n2\\nc\\nf\\n\\n\\n(\\n\\ni\\nn\\nt\\n\\n\\n\\n{\\displaystyle {\\mathit {r2cf}}(\\mathrm {int} }\\n\\n \\n\\n\\n\\n\\nN\\n\\n1\\n\\n\\n,\\n\\ni\\nn\\nt\\n\\n\\n\\n{\\displaystyle N_{1},\\mathrm {int} }\\n\\n \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n)\\n\\n\\n{\\displaystyle N_{2})}\\n\\n, or \\n\\n\\n\\n\\n\\nr\\n2\\nc\\nf\\n\\n\\n(\\n\\nF\\nr\\na\\nc\\nt\\ni\\no\\nn\\n\\n\\n\\n{\\displaystyle {\\mathit {r2cf}}(\\mathrm {Fraction} }\\n\\n \\n\\n\\n\\nN\\n)\\n\\n\\n{\\displaystyle N)}\\n\\n, which will output a continued fraction assuming:\\nThe function should output its results one digit at a time each time it is called, in a manner sometimes described as lazy evaluation.\\nTo achieve this it must determine: the integer part; and remainder part, of \\n\\n\\n\\n\\nN\\n\\n1\\n\\n\\n\\n\\n{\\displaystyle N_{1}}\\n\\n divided by \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle N_{2}}\\n\\n. It then sets \\n\\n\\n\\n\\nN\\n\\n1\\n\\n\\n\\n\\n{\\displaystyle N_{1}}\\n\\n to \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle N_{2}}\\n\\n and \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle N_{2}}\\n\\n to the determined remainder part. It then outputs the determined integer part. It does this until \\n\\n\\n\\n\\na\\nb\\ns\\n\\n(\\n\\nN\\n\\n2\\n\\n\\n)\\n\\n\\n{\\displaystyle \\mathrm {abs} (N_{2})}\\n\\n is zero.\\nDemonstrate the function by outputing the continued fraction for:\\n\\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n should approach \\n\\n\\n\\n[\\n1\\n;\\n2\\n,\\n2\\n,\\n2\\n,\\n2\\n,\\n…\\n]\\n\\n\\n{\\displaystyle [1;2,2,2,2,\\ldots ]}\\n\\n try ever closer rational approximations until boredom gets the better of you:\\nTry :\\nObserve how this rational number behaves differently to \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n and convince yourself that, in the same way as \\n\\n\\n\\n3.7\\n\\n\\n{\\displaystyle 3.7}\\n\\n may be represented as \\n\\n\\n\\n3.70\\n\\n\\n{\\displaystyle 3.70}\\n\\n when an extra decimal place is required, \\n\\n\\n\\n[\\n3\\n;\\n7\\n]\\n\\n\\n{\\displaystyle [3;7]}\\n\\n may be represented as \\n\\n\\n\\n[\\n3\\n;\\n7\\n,\\n∞\\n]\\n\\n\\n{\\displaystyle [3;7,\\infty ]}\\n\\n when an extra term is required.\\nC does not implement Lazy evaluation and it is this particular feature which is the real challenge of this particular example. It can however be simulated. The following example uses pointers. It seems that the same data is being passed but since the function accepts pointers, the variables are being changed. One other way to simulate laziness would be to use global variables. Then although it would seem that the same values are being passed even as constants, the job is actually getting done. In my view, that would be plain cheating.\\nAnd the run gives :\\n","int main() {\\n  for(r2cf n(31,10); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  for(r2cf n(314,100); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  for(r2cf n(3142,1000); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  for(r2cf n(31428,10000); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  for(r2cf n(314285,100000); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  for(r2cf n(3142857,1000000); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  for(r2cf n(31428571,10000000); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  for(r2cf n(314285714,100000000); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  return 0;\\n}"
"C++","Continued_fraction/Arithmetic/G(matrix_NG,_Contined_Fraction_N)","This task investigates mathmatical operations that can be performed on a single continued fraction. This requires only a baby version of NG:\\nI may perform perform the following operations:\\nI output a term if the integer parts of \\n\\n\\n\\n\\n\\na\\nb\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a}{b}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{1}}{b_{1}}}}\\n\\n are equal. Otherwise I input a term from N. If I need a term from N but N has no more terms I inject \\n\\n\\n\\n∞\\n\\n\\n{\\displaystyle \\infty }\\n\\n.\\nWhen I input a term t my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\na\\n+\\n\\na\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\n\\nb\\n+\\n\\nb\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a+a_{1}*t&a_{1}\\\\b+b_{1}*t&b_{1}\\end{bmatrix}}}\\n\\n\\nWhen I output a term t my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n−\\n\\nb\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\na\\n−\\nb\\n∗\\nt\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}b_{1}&b\\\\a_{1}-b_{1}*t&a-b*t\\end{bmatrix}}}\\n\\n\\nWhen I need a term t but there are no more my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a_{1}\\\\b_{1}&b_{1}\\end{bmatrix}}}\\n\\n\\nI am done when b1 and b are zero.\\nDemonstrate your solution by calculating:\\nUsing a generator for \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n (e.g., from Continued fraction) calculate \\n\\n\\n\\n\\n\\n1\\n\\n2\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {1}{\\sqrt {2}}}}\\n\\n. You are now at the starting line for using Continued Fractions to implement Arithmetic-geometric mean without ulps and epsilons.\\nThe first step in implementing Arithmetic-geometric mean is to calculate \\n\\n\\n\\n\\n\\n\\n1\\n+\\n\\n\\n1\\n\\n2\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\frac {1+{\\frac {1}{\\sqrt {2}}}}{2}}}\\n\\n do this now to cross the starting line and begin the race.\\n","/* Interface for all matrixNG classes\\n   Nigel Galloway, February 10th., 2013.\\n*/\\nclass matrixNG {\\n  private:\\n  virtual void consumeTerm(){}\\n  virtual void consumeTerm(int n){}\\n  virtual const bool needTerm(){}\\n  protected: int cfn = 0, thisTerm;\\n             bool haveTerm = false;\\n  friend class NG;\\n};\\n/* Implement the babyNG matrix\\n   Nigel Galloway, February 10th., 2013.\\n*/\\nclass NG_4 : public matrixNG {\\n  private: int a1, a, b1, b, t;\\n  const bool needTerm() {\\n    if (b1==0 and b==0) return false;\\n    if (b1==0 or b==0) return true; else thisTerm = a/b;\\n    if (thisTerm==(int)(a1/b1)){\\n      t=a; a=b; b=t-b*thisTerm; t=a1; a1=b1; b1=t-b1*thisTerm;\\n      haveTerm=true; return false;\\n    }\\n    return true;\\n  }\\n  void consumeTerm(){a=a1; b=b1;}\\n  void consumeTerm(int n){t=a; a=a1; a1=t+a1*n; t=b; b=b1; b1=t+b1*n;}\\n  public:\\n  NG_4(int a1, int a, int b1, int b): a1(a1), a(a), b1(b1), b(b){}\\n};\\n/* Implement a Continued Fraction which returns the result of an arithmetic operation on\\n   1 or more Continued Fractions (Currently 1 or 2).\\n   Nigel Galloway, February 10th., 2013.\\n*/\\nclass NG : public ContinuedFraction {\\n  private:\\n   matrixNG* ng;\\n   ContinuedFraction* n[2];\\n  public:\\n  NG(NG_4* ng, ContinuedFraction* n1): ng(ng){n[0] = n1;}\\n  NG(NG_8* ng, ContinuedFraction* n1, ContinuedFraction* n2): ng(ng){n[0] = n1; n[1] = n2;}\\n  const int nextTerm() {ng->haveTerm = false; return ng->thisTerm;}\\n  const bool moreTerms(){\\n    while(ng->needTerm()) if(n[ng->cfn]->moreTerms()) ng->consumeTerm(n[ng->cfn]->nextTerm()); else ng->consumeTerm();\\n    return ng->haveTerm;\\n  }\\n};"
"C++","Continued_fraction/Arithmetic/G(matrix_NG,_Contined_Fraction_N)","This task investigates mathmatical operations that can be performed on a single continued fraction. This requires only a baby version of NG:\\nI may perform perform the following operations:\\nI output a term if the integer parts of \\n\\n\\n\\n\\n\\na\\nb\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a}{b}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{1}}{b_{1}}}}\\n\\n are equal. Otherwise I input a term from N. If I need a term from N but N has no more terms I inject \\n\\n\\n\\n∞\\n\\n\\n{\\displaystyle \\infty }\\n\\n.\\nWhen I input a term t my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\na\\n+\\n\\na\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\n\\nb\\n+\\n\\nb\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a+a_{1}*t&a_{1}\\\\b+b_{1}*t&b_{1}\\end{bmatrix}}}\\n\\n\\nWhen I output a term t my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n−\\n\\nb\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\na\\n−\\nb\\n∗\\nt\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}b_{1}&b\\\\a_{1}-b_{1}*t&a-b*t\\end{bmatrix}}}\\n\\n\\nWhen I need a term t but there are no more my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a_{1}\\\\b_{1}&b_{1}\\end{bmatrix}}}\\n\\n\\nI am done when b1 and b are zero.\\nDemonstrate your solution by calculating:\\nUsing a generator for \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n (e.g., from Continued fraction) calculate \\n\\n\\n\\n\\n\\n1\\n\\n2\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {1}{\\sqrt {2}}}}\\n\\n. You are now at the starting line for using Continued Fractions to implement Arithmetic-geometric mean without ulps and epsilons.\\nThe first step in implementing Arithmetic-geometric mean is to calculate \\n\\n\\n\\n\\n\\n\\n1\\n+\\n\\n\\n1\\n\\n2\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\frac {1+{\\frac {1}{\\sqrt {2}}}}{2}}}\\n\\n do this now to cross the starting line and begin the race.\\n","int main() {\\n  NG_4 a1(2,1,0,2);\\n  r2cf n1(13,11);\\n  for(NG n(&a1, &n1); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  return 0;\\n}"
"C++","Continued_fraction/Arithmetic/G(matrix_NG,_Contined_Fraction_N)","This task investigates mathmatical operations that can be performed on a single continued fraction. This requires only a baby version of NG:\\nI may perform perform the following operations:\\nI output a term if the integer parts of \\n\\n\\n\\n\\n\\na\\nb\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a}{b}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{1}}{b_{1}}}}\\n\\n are equal. Otherwise I input a term from N. If I need a term from N but N has no more terms I inject \\n\\n\\n\\n∞\\n\\n\\n{\\displaystyle \\infty }\\n\\n.\\nWhen I input a term t my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\na\\n+\\n\\na\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\n\\nb\\n+\\n\\nb\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a+a_{1}*t&a_{1}\\\\b+b_{1}*t&b_{1}\\end{bmatrix}}}\\n\\n\\nWhen I output a term t my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n−\\n\\nb\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\na\\n−\\nb\\n∗\\nt\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}b_{1}&b\\\\a_{1}-b_{1}*t&a-b*t\\end{bmatrix}}}\\n\\n\\nWhen I need a term t but there are no more my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a_{1}\\\\b_{1}&b_{1}\\end{bmatrix}}}\\n\\n\\nI am done when b1 and b are zero.\\nDemonstrate your solution by calculating:\\nUsing a generator for \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n (e.g., from Continued fraction) calculate \\n\\n\\n\\n\\n\\n1\\n\\n2\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {1}{\\sqrt {2}}}}\\n\\n. You are now at the starting line for using Continued Fractions to implement Arithmetic-geometric mean without ulps and epsilons.\\nThe first step in implementing Arithmetic-geometric mean is to calculate \\n\\n\\n\\n\\n\\n\\n1\\n+\\n\\n\\n1\\n\\n2\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\frac {1+{\\frac {1}{\\sqrt {2}}}}{2}}}\\n\\n do this now to cross the starting line and begin the race.\\n","int main() {\\n  NG_4 a2(7,0,0,22);\\n  r2cf n2(22,7);\\n  for(NG n(&a2, &n2); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  return 0;\\n}"
"C++","Continued_fraction/Arithmetic/G(matrix_NG,_Contined_Fraction_N)","This task investigates mathmatical operations that can be performed on a single continued fraction. This requires only a baby version of NG:\\nI may perform perform the following operations:\\nI output a term if the integer parts of \\n\\n\\n\\n\\n\\na\\nb\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a}{b}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{1}}{b_{1}}}}\\n\\n are equal. Otherwise I input a term from N. If I need a term from N but N has no more terms I inject \\n\\n\\n\\n∞\\n\\n\\n{\\displaystyle \\infty }\\n\\n.\\nWhen I input a term t my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\na\\n+\\n\\na\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\n\\nb\\n+\\n\\nb\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a+a_{1}*t&a_{1}\\\\b+b_{1}*t&b_{1}\\end{bmatrix}}}\\n\\n\\nWhen I output a term t my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n−\\n\\nb\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\na\\n−\\nb\\n∗\\nt\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}b_{1}&b\\\\a_{1}-b_{1}*t&a-b*t\\end{bmatrix}}}\\n\\n\\nWhen I need a term t but there are no more my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a_{1}\\\\b_{1}&b_{1}\\end{bmatrix}}}\\n\\n\\nI am done when b1 and b are zero.\\nDemonstrate your solution by calculating:\\nUsing a generator for \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n (e.g., from Continued fraction) calculate \\n\\n\\n\\n\\n\\n1\\n\\n2\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {1}{\\sqrt {2}}}}\\n\\n. You are now at the starting line for using Continued Fractions to implement Arithmetic-geometric mean without ulps and epsilons.\\nThe first step in implementing Arithmetic-geometric mean is to calculate \\n\\n\\n\\n\\n\\n\\n1\\n+\\n\\n\\n1\\n\\n2\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\frac {1+{\\frac {1}{\\sqrt {2}}}}{2}}}\\n\\n do this now to cross the starting line and begin the race.\\n","int main() {\\n  NG_4 a3(2,1,0,2);\\n  r2cf n3(22,7);\\n  for(NG n(&a3, &n3); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  return 0;\\n}"
"C++","Continued_fraction/Arithmetic/G(matrix_NG,_Contined_Fraction_N)","This task investigates mathmatical operations that can be performed on a single continued fraction. This requires only a baby version of NG:\\nI may perform perform the following operations:\\nI output a term if the integer parts of \\n\\n\\n\\n\\n\\na\\nb\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a}{b}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{1}}{b_{1}}}}\\n\\n are equal. Otherwise I input a term from N. If I need a term from N but N has no more terms I inject \\n\\n\\n\\n∞\\n\\n\\n{\\displaystyle \\infty }\\n\\n.\\nWhen I input a term t my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\na\\n+\\n\\na\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\n\\nb\\n+\\n\\nb\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a+a_{1}*t&a_{1}\\\\b+b_{1}*t&b_{1}\\end{bmatrix}}}\\n\\n\\nWhen I output a term t my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n−\\n\\nb\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\na\\n−\\nb\\n∗\\nt\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}b_{1}&b\\\\a_{1}-b_{1}*t&a-b*t\\end{bmatrix}}}\\n\\n\\nWhen I need a term t but there are no more my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a_{1}\\\\b_{1}&b_{1}\\end{bmatrix}}}\\n\\n\\nI am done when b1 and b are zero.\\nDemonstrate your solution by calculating:\\nUsing a generator for \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n (e.g., from Continued fraction) calculate \\n\\n\\n\\n\\n\\n1\\n\\n2\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {1}{\\sqrt {2}}}}\\n\\n. You are now at the starting line for using Continued Fractions to implement Arithmetic-geometric mean without ulps and epsilons.\\nThe first step in implementing Arithmetic-geometric mean is to calculate \\n\\n\\n\\n\\n\\n\\n1\\n+\\n\\n\\n1\\n\\n2\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\frac {1+{\\frac {1}{\\sqrt {2}}}}{2}}}\\n\\n do this now to cross the starting line and begin the race.\\n","int main() {\\n  NG_4 a4(1,0,0,4);\\n  r2cf n4(22,7);\\n  for(NG n(&a4, &n4); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  return 0;\\n}"
"C++","Continued_fraction/Arithmetic/G(matrix_NG,_Contined_Fraction_N)","This task investigates mathmatical operations that can be performed on a single continued fraction. This requires only a baby version of NG:\\nI may perform perform the following operations:\\nI output a term if the integer parts of \\n\\n\\n\\n\\n\\na\\nb\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a}{b}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{1}}{b_{1}}}}\\n\\n are equal. Otherwise I input a term from N. If I need a term from N but N has no more terms I inject \\n\\n\\n\\n∞\\n\\n\\n{\\displaystyle \\infty }\\n\\n.\\nWhen I input a term t my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\na\\n+\\n\\na\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\n\\nb\\n+\\n\\nb\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a+a_{1}*t&a_{1}\\\\b+b_{1}*t&b_{1}\\end{bmatrix}}}\\n\\n\\nWhen I output a term t my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n−\\n\\nb\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\na\\n−\\nb\\n∗\\nt\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}b_{1}&b\\\\a_{1}-b_{1}*t&a-b*t\\end{bmatrix}}}\\n\\n\\nWhen I need a term t but there are no more my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a_{1}\\\\b_{1}&b_{1}\\end{bmatrix}}}\\n\\n\\nI am done when b1 and b are zero.\\nDemonstrate your solution by calculating:\\nUsing a generator for \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n (e.g., from Continued fraction) calculate \\n\\n\\n\\n\\n\\n1\\n\\n2\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {1}{\\sqrt {2}}}}\\n\\n. You are now at the starting line for using Continued Fractions to implement Arithmetic-geometric mean without ulps and epsilons.\\nThe first step in implementing Arithmetic-geometric mean is to calculate \\n\\n\\n\\n\\n\\n\\n1\\n+\\n\\n\\n1\\n\\n2\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\frac {1+{\\frac {1}{\\sqrt {2}}}}{2}}}\\n\\n do this now to cross the starting line and begin the race.\\n","int main() {\\n  NG_4 a5(0,1,1,0);\\n  SQRT2 n5;\\n  int i = 0;\\n  for(NG n(&a5, &n5); n.moreTerms() and i++ < 20; std::cout << n.nextTerm() << \"" \"");\\n  std::cout << \""...\"" << std::endl;\\n  for(r2cf cf(10000000, 14142136); cf.moreTerms(); std::cout << cf.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  return 0;\\n}"
"C++","Continued_fraction/Arithmetic/G(matrix_NG,_Contined_Fraction_N)","This task investigates mathmatical operations that can be performed on a single continued fraction. This requires only a baby version of NG:\\nI may perform perform the following operations:\\nI output a term if the integer parts of \\n\\n\\n\\n\\n\\na\\nb\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a}{b}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{1}}{b_{1}}}}\\n\\n are equal. Otherwise I input a term from N. If I need a term from N but N has no more terms I inject \\n\\n\\n\\n∞\\n\\n\\n{\\displaystyle \\infty }\\n\\n.\\nWhen I input a term t my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\na\\n+\\n\\na\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\n\\nb\\n+\\n\\nb\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a+a_{1}*t&a_{1}\\\\b+b_{1}*t&b_{1}\\end{bmatrix}}}\\n\\n\\nWhen I output a term t my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n−\\n\\nb\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\na\\n−\\nb\\n∗\\nt\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}b_{1}&b\\\\a_{1}-b_{1}*t&a-b*t\\end{bmatrix}}}\\n\\n\\nWhen I need a term t but there are no more my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a_{1}\\\\b_{1}&b_{1}\\end{bmatrix}}}\\n\\n\\nI am done when b1 and b are zero.\\nDemonstrate your solution by calculating:\\nUsing a generator for \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n (e.g., from Continued fraction) calculate \\n\\n\\n\\n\\n\\n1\\n\\n2\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {1}{\\sqrt {2}}}}\\n\\n. You are now at the starting line for using Continued Fractions to implement Arithmetic-geometric mean without ulps and epsilons.\\nThe first step in implementing Arithmetic-geometric mean is to calculate \\n\\n\\n\\n\\n\\n\\n1\\n+\\n\\n\\n1\\n\\n2\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\frac {1+{\\frac {1}{\\sqrt {2}}}}{2}}}\\n\\n do this now to cross the starting line and begin the race.\\n","int main() {\\n  int i = 0;\\n  NG_4 a6(1,1,0,2);\\n  SQRT2 n6;\\n  for(NG n(&a6, &n6); n.moreTerms() and i++ < 20; std::cout << n.nextTerm() << \"" \"");\\n  std::cout << \""...\"" << std::endl;\\n  for(r2cf cf(24142136, 20000000); cf.moreTerms(); std::cout << cf.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  return 0;\\n}"
"C++","Continued_fraction/Arithmetic/G(matrix_NG,_Contined_Fraction_N1,_Contined_Fraction_N2)","This task performs the basic mathematical functions on 2 continued fractions. This requires the full version of matrix NG:\\nI may perform perform the following operations:\\nI output a term if the integer parts of \\n\\n\\n\\n\\n\\na\\nb\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a}{b}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{1}}{b_{1}}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n2\\n\\n\\n\\nb\\n\\n2\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{2}}{b_{2}}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n12\\n\\n\\n\\nb\\n\\n12\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{12}}{b_{12}}}}\\n\\n are equal. Otherwise I input a term from continued fraction N1 or continued fraction N2. If I need a term from N but N has no more terms I inject \\n\\n\\n\\n∞\\n\\n\\n{\\displaystyle \\infty }\\n\\n.\\nWhen I input a term t from continued fraction N1 I change my internal state:\\nWhen I need a term from exhausted continued fraction N1 I change my internal state:\\nWhen I input a term t from continued fraction N2 I change my internal state:\\nWhen I need a term from exhausted continued fraction N2 I change my internal state:\\nWhen I output a term t I change my internal state:\\nWhen I need to choose to input from N1 or N2 I act:\\nWhen performing arithmetic operation on two potentially infinite continued fractions it is possible to generate a rational number. eg \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n * \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n should produce 2. This will require either that I determine that my internal state is approaching infinity, or limiting the number of terms I am willing to input without producing any output.\\n[3;7] + [0;2]\\n","/* Implement matrix NG\\n   Nigel Galloway, February 12., 2013\\n*/\\nclass NG_8 : public matrixNG {\\n  private: int a12, a1, a2, a, b12, b1, b2, b, t;\\n           double ab, a1b1, a2b2, a12b12;\\n  const int chooseCFN(){return fabs(a1b1-ab) > fabs(a2b2-ab)? 0 : 1;}\\n  const bool needTerm() {\\n    if (b1==0 and b==0 and b2==0 and b12==0) return false;\\n    if (b==0){cfn = b2==0? 0:1; return true;} else ab = ((double)a)/b;\\n    if (b2==0){cfn = 1; return true;} else a2b2 = ((double)a2)/b2;\\n    if (b1==0){cfn = 0; return true;} else a1b1 = ((double)a1)/b1;\\n    if (b12==0){cfn = chooseCFN(); return true;} else a12b12 = ((double)a12)/b12;\\n    thisTerm = (int)ab;\\n    if (thisTerm==(int)a1b1 and thisTerm==(int)a2b2 and thisTerm==(int)a12b12){\\n      t=a; a=b; b=t-b*thisTerm; t=a1; a1=b1; b1=t-b1*thisTerm; t=a2; a2=b2; b2=t-b2*thisTerm; t=a12; a12=b12; b12=t-b12*thisTerm;\\n      haveTerm = true; return false;\\n    }\\n    cfn = chooseCFN();\\n    return true;\\n  }\\n  void consumeTerm(){if(cfn==0){a=a1; a2=a12; b=b1; b2=b12;} else{a=a2; a1=a12; b=b2; b1=b12;}}\\n  void consumeTerm(int n){\\n    if(cfn==0){t=a; a=a1; a1=t+a1*n; t=a2; a2=a12; a12=t+a12*n; t=b; b=b1; b1=t+b1*n; t=b2; b2=b12; b12=t+b12*n;}\\n    else{t=a; a=a2; a2=t+a2*n; t=a1; a1=a12; a12=t+a12*n; t=b; b=b2; b2=t+b2*n; t=b1; b1=b12; b12=t+b12*n;}\\n  }\\n  public:\\n  NG_8(int a12, int a1, int a2, int a, int b12, int b1, int b2, int b): a12(a12), a1(a1), a2(a2), a(a), b12(b12), b1(b1), b2(b2), b(b){\\n}};"
"C++","Continued_fraction/Arithmetic/G(matrix_NG,_Contined_Fraction_N1,_Contined_Fraction_N2)","This task performs the basic mathematical functions on 2 continued fractions. This requires the full version of matrix NG:\\nI may perform perform the following operations:\\nI output a term if the integer parts of \\n\\n\\n\\n\\n\\na\\nb\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a}{b}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{1}}{b_{1}}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n2\\n\\n\\n\\nb\\n\\n2\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{2}}{b_{2}}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n12\\n\\n\\n\\nb\\n\\n12\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{12}}{b_{12}}}}\\n\\n are equal. Otherwise I input a term from continued fraction N1 or continued fraction N2. If I need a term from N but N has no more terms I inject \\n\\n\\n\\n∞\\n\\n\\n{\\displaystyle \\infty }\\n\\n.\\nWhen I input a term t from continued fraction N1 I change my internal state:\\nWhen I need a term from exhausted continued fraction N1 I change my internal state:\\nWhen I input a term t from continued fraction N2 I change my internal state:\\nWhen I need a term from exhausted continued fraction N2 I change my internal state:\\nWhen I output a term t I change my internal state:\\nWhen I need to choose to input from N1 or N2 I act:\\nWhen performing arithmetic operation on two potentially infinite continued fractions it is possible to generate a rational number. eg \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n * \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n should produce 2. This will require either that I determine that my internal state is approaching infinity, or limiting the number of terms I am willing to input without producing any output.\\n[3;7] + [0;2]\\n","int main() {\\n  NG_8 a(0,1,1,0,0,0,0,1);\\n  r2cf n2(22,7);\\n  r2cf n1(1,2);\\n  for(NG n(&a, &n1, &n2); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n\\n  NG_4 a3(2,1,0,2);\\n  r2cf n3(22,7);\\n  for(NG n(&a3, &n3); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  return 0;\\n}"
"C++","Continued_fraction/Arithmetic/G(matrix_NG,_Contined_Fraction_N1,_Contined_Fraction_N2)","This task performs the basic mathematical functions on 2 continued fractions. This requires the full version of matrix NG:\\nI may perform perform the following operations:\\nI output a term if the integer parts of \\n\\n\\n\\n\\n\\na\\nb\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a}{b}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{1}}{b_{1}}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n2\\n\\n\\n\\nb\\n\\n2\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{2}}{b_{2}}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n12\\n\\n\\n\\nb\\n\\n12\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{12}}{b_{12}}}}\\n\\n are equal. Otherwise I input a term from continued fraction N1 or continued fraction N2. If I need a term from N but N has no more terms I inject \\n\\n\\n\\n∞\\n\\n\\n{\\displaystyle \\infty }\\n\\n.\\nWhen I input a term t from continued fraction N1 I change my internal state:\\nWhen I need a term from exhausted continued fraction N1 I change my internal state:\\nWhen I input a term t from continued fraction N2 I change my internal state:\\nWhen I need a term from exhausted continued fraction N2 I change my internal state:\\nWhen I output a term t I change my internal state:\\nWhen I need to choose to input from N1 or N2 I act:\\nWhen performing arithmetic operation on two potentially infinite continued fractions it is possible to generate a rational number. eg \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n * \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n should produce 2. This will require either that I determine that my internal state is approaching infinity, or limiting the number of terms I am willing to input without producing any output.\\n[3;7] + [0;2]\\n","int main() {\\n  NG_8 b(1,0,0,0,0,0,0,1);\\n  r2cf b1(13,11);\\n  r2cf b2(22,7);\\n  for(NG n(&b, &b1, &b2); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  for(NG n(&a, &b2, &b1); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  for(r2cf cf(286,77); cf.moreTerms(); std::cout << cf.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  return 0;\\n}"
"C++","Continued_fraction/Arithmetic/G(matrix_NG,_Contined_Fraction_N1,_Contined_Fraction_N2)","This task performs the basic mathematical functions on 2 continued fractions. This requires the full version of matrix NG:\\nI may perform perform the following operations:\\nI output a term if the integer parts of \\n\\n\\n\\n\\n\\na\\nb\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a}{b}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{1}}{b_{1}}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n2\\n\\n\\n\\nb\\n\\n2\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{2}}{b_{2}}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n12\\n\\n\\n\\nb\\n\\n12\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{12}}{b_{12}}}}\\n\\n are equal. Otherwise I input a term from continued fraction N1 or continued fraction N2. If I need a term from N but N has no more terms I inject \\n\\n\\n\\n∞\\n\\n\\n{\\displaystyle \\infty }\\n\\n.\\nWhen I input a term t from continued fraction N1 I change my internal state:\\nWhen I need a term from exhausted continued fraction N1 I change my internal state:\\nWhen I input a term t from continued fraction N2 I change my internal state:\\nWhen I need a term from exhausted continued fraction N2 I change my internal state:\\nWhen I output a term t I change my internal state:\\nWhen I need to choose to input from N1 or N2 I act:\\nWhen performing arithmetic operation on two potentially infinite continued fractions it is possible to generate a rational number. eg \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n * \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n should produce 2. This will require either that I determine that my internal state is approaching infinity, or limiting the number of terms I am willing to input without producing any output.\\n[3;7] + [0;2]\\n","int main() {\\n  NG_8 c(0,1,-1,0,0,0,0,1);\\n  r2cf c1(13,11);\\n  r2cf c2(22,7);\\n  for(NG n(&c, &c1, &c2); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  for(r2cf cf(-151,77); cf.moreTerms(); std::cout << cf.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  return 0;\\n}"
"C++","Continued_fraction/Arithmetic/G(matrix_NG,_Contined_Fraction_N1,_Contined_Fraction_N2)","This task performs the basic mathematical functions on 2 continued fractions. This requires the full version of matrix NG:\\nI may perform perform the following operations:\\nI output a term if the integer parts of \\n\\n\\n\\n\\n\\na\\nb\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a}{b}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{1}}{b_{1}}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n2\\n\\n\\n\\nb\\n\\n2\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{2}}{b_{2}}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n12\\n\\n\\n\\nb\\n\\n12\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{12}}{b_{12}}}}\\n\\n are equal. Otherwise I input a term from continued fraction N1 or continued fraction N2. If I need a term from N but N has no more terms I inject \\n\\n\\n\\n∞\\n\\n\\n{\\displaystyle \\infty }\\n\\n.\\nWhen I input a term t from continued fraction N1 I change my internal state:\\nWhen I need a term from exhausted continued fraction N1 I change my internal state:\\nWhen I input a term t from continued fraction N2 I change my internal state:\\nWhen I need a term from exhausted continued fraction N2 I change my internal state:\\nWhen I output a term t I change my internal state:\\nWhen I need to choose to input from N1 or N2 I act:\\nWhen performing arithmetic operation on two potentially infinite continued fractions it is possible to generate a rational number. eg \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n * \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n should produce 2. This will require either that I determine that my internal state is approaching infinity, or limiting the number of terms I am willing to input without producing any output.\\n[3;7] + [0;2]\\n","int main() {\\n  NG_8 d(0,1,0,0,0,0,1,0);\\n  r2cf d1(22*22,7*7);\\n  r2cf d2(22,7);\\n  for(NG n(&d, &d1, &d2); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  return 0;\\n}"
"C++","Continued_fraction/Arithmetic/G(matrix_NG,_Contined_Fraction_N1,_Contined_Fraction_N2)","This task performs the basic mathematical functions on 2 continued fractions. This requires the full version of matrix NG:\\nI may perform perform the following operations:\\nI output a term if the integer parts of \\n\\n\\n\\n\\n\\na\\nb\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a}{b}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{1}}{b_{1}}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n2\\n\\n\\n\\nb\\n\\n2\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{2}}{b_{2}}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n12\\n\\n\\n\\nb\\n\\n12\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{12}}{b_{12}}}}\\n\\n are equal. Otherwise I input a term from continued fraction N1 or continued fraction N2. If I need a term from N but N has no more terms I inject \\n\\n\\n\\n∞\\n\\n\\n{\\displaystyle \\infty }\\n\\n.\\nWhen I input a term t from continued fraction N1 I change my internal state:\\nWhen I need a term from exhausted continued fraction N1 I change my internal state:\\nWhen I input a term t from continued fraction N2 I change my internal state:\\nWhen I need a term from exhausted continued fraction N2 I change my internal state:\\nWhen I output a term t I change my internal state:\\nWhen I need to choose to input from N1 or N2 I act:\\nWhen performing arithmetic operation on two potentially infinite continued fractions it is possible to generate a rational number. eg \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n * \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n should produce 2. This will require either that I determine that my internal state is approaching infinity, or limiting the number of terms I am willing to input without producing any output.\\n[3;7] + [0;2]\\n","int main() {\\n  r2cf a1(2,7);\\n  r2cf a2(13,11);\\n  NG_8 na(0,1,1,0,0,0,0,1);\\n  NG A(&na, &a1, &a2); //[0;3,2] + [1;5,2]\\n  r2cf b1(2,7);\\n  r2cf b2(13,11);\\n  NG_8 nb(0,1,-1,0,0,0,0,1);\\n  NG B(&nb, &b1, &b2); //[0;3,2] - [1;5,2]\\n  NG_8 nc(1,0,0,0,0,0,0,1); //A*B\\n  for(NG n(&nc, &A, &B); n.moreTerms(); std::cout << n.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  for(r2cf cf(2,7); cf.moreTerms(); std::cout << cf.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  for(r2cf cf(13,11); cf.moreTerms(); std::cout << cf.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  for(r2cf cf(-7797,5929); cf.moreTerms(); std::cout << cf.nextTerm() << \"" \"");\\n  std::cout << std::endl;\\n  return 0;\\n}"
"C++","Convert_seconds_to_compound_duration","Write a function or program which:\\n\\nDemonstrate that it passes the following three test-cases:\\nTest CasesDetails\\n","\\n#include <iostream>\\n#include <vector>\\n\\nusing entry = std::pair;\\n\\nvoid print(const std::vector<entry>& entries, std::ostream& out = std::cout)\\n{\\n    bool first = true;\\n    for(const auto& e: entries) {\\n        if(!first) out << \"", \"";\\n        first = false;\\n        out << e.first << \"" \"" << e.second;\\n    }\\n    out << '\\n';\\n}\\n\\nstd::vector<entry> convert(int seconds)\\n{\\n    static const entry time_table[] = {\\n        {7*24*60*60, \""wk\""}, {24*60*60, \""d\""}, {60*60, \""hr\""}, {60, \""min\""}, {1, \""sec\""}\\n    };\\n    std::vector<entry> result;\\n    for(const auto& e: time_table) {\\n        int time = seconds / e.first;\\n        if(time != 0) result.emplace_back(time, e.second);\\n        seconds %= e.first;\\n    }\\n    return result;\\n}\\n\\nint main()\\n{\\n    std::cout << \""   7259 sec is \""; print(convert(   7259));\\n    std::cout << \""  86400 sec is \""; print(convert(  86400));\\n    std::cout << \""6000000 sec is \""; print(convert(6000000));\\n}"
"C++","Conway's_Game_of_Life","The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.\\nConway's game of life is described   here:\\nA cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.\\nWe calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:\\nAssume cells beyond the boundary are always dead.\\nThe \""game\"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.\\n\\nAlthough you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.\\n\\n\\n\\n","#include <iostream>\\n#define HEIGHT 4\\n#define WIDTH 4\\n\\nstruct Shape {\\npublic:\\n    char xCoord;\\n    char yCoord;\\n    char height;\\n    char width;\\n    char **figure;\\n};\\n\\nstruct Glider : public Shape {\\n    static const char GLIDER_SIZE = 3;\\n    Glider( char x , char y );\\n    ~Glider();\\n};\\n\\nstruct Blinker : public Shape {\\n    static const char BLINKER_HEIGHT = 3;\\n    static const char BLINKER_WIDTH = 1;\\n    Blinker( char x , char y );\\n    ~Blinker();\\n};\\n\\nclass GameOfLife {\\npublic:\\n    GameOfLife( Shape sh );\\n    void print();\\n    void update();\\n    char getState( char state , char xCoord , char yCoord , bool toggle);\\n    void iterate(unsigned int iterations);\\nprivate:\\n    char world[HEIGHT][WIDTH];\\n    char otherWorld[HEIGHT][WIDTH];\\n    bool toggle;\\n    Shape shape;\\n};\\n\\nGameOfLife::GameOfLife( Shape sh ) :\\n    shape(sh) ,\\n    toggle(true) \\n{\\n    for ( char i = 0; i < HEIGHT; i++ ) {\\n        for ( char j = 0; j < WIDTH; j++ ) {\\n            world[i][j] = '.';\\n        }\\n    }\\n    for ( char i = shape.yCoord; i - shape.yCoord < shape.height; i++ ) {\\n        for ( char j = shape.xCoord; j - shape.xCoord < shape.width; j++ ) {\\n            if ( i < HEIGHT && j < WIDTH ) {\\n                world[i][j] = \\n                    shape.figure[ i - shape.yCoord ][j - shape.xCoord ];\\n            }\\n        }\\n    }\\n}\\n\\nvoid GameOfLife::print() {\\n    if ( toggle ) {\\n        for ( char i = 0; i < HEIGHT; i++ ) {\\n            for ( char j = 0; j < WIDTH; j++ ) {\\n                std::cout << world[i][j];\\n            }\\n            std::cout << std::endl;\\n        }\\n    } else {\\n        for ( char i = 0; i < HEIGHT; i++ ) {\\n            for ( char j = 0; j < WIDTH; j++ ) {\\n                std::cout << otherWorld[i][j];\\n            }\\n            std::cout << std::endl;\\n        }\\n    }\\n    for ( char i = 0; i < WIDTH; i++ ) {\\n        std::cout << '=';\\n    }\\n    std::cout << std::endl;\\n}\\n\\nvoid GameOfLife::update() {\\n    if (toggle) {\\n        for ( char i = 0; i < HEIGHT; i++ ) {\\n            for ( char j = 0; j < WIDTH; j++ ) {\\n                otherWorld[i][j] = \\n                    GameOfLife::getState(world[i][j] , i , j , toggle);\\n            }\\n        }\\n        toggle = !toggle;\\n    } else {\\n        for ( char i = 0; i < HEIGHT; i++ ) {\\n            for ( char j = 0; j < WIDTH; j++ ) {\\n                world[i][j] = \\n                    GameOfLife::getState(otherWorld[i][j] , i , j , toggle);\\n            }\\n        }\\n        toggle = !toggle;\\n    }\\n}\\n\\nchar GameOfLife::getState( char state, char yCoord, char xCoord, bool toggle ) {\\n    char neighbors = 0;\\n    if ( toggle ) {\\n        for ( char i = yCoord - 1; i <= yCoord + 1; i++ ) {\\n            for ( char j = xCoord - 1; j <= xCoord + 1; j++ ) {\\n                if ( i == yCoord && j == xCoord ) {\\n                    continue;\\n                }\\n                if ( i > -1 && i < HEIGHT && j > -1 && j < WIDTH ) {\\n                    if ( world[i][j] == 'X' ) {\\n                        neighbors++;\\n                    }\\n                }\\n            }\\n        }\\n    } else {\\n        for ( char i = yCoord - 1; i <= yCoord + 1; i++ ) {\\n            for ( char j = xCoord - 1; j <= xCoord + 1; j++ ) {\\n                if ( i == yCoord && j == xCoord ) {\\n                    continue;\\n                }\\n                if ( i > -1 && i < HEIGHT && j > -1 && j < WIDTH ) {\\n                    if ( otherWorld[i][j] == 'X' ) {\\n                        neighbors++;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    if (state == 'X') {\\n        return ( neighbors > 1 && neighbors < 4 ) ? 'X' : '.';\\n    }\\n    else {\\n        return ( neighbors == 3 ) ? 'X' : '.';\\n    }\\n}\\n\\nvoid GameOfLife::iterate( unsigned int iterations ) {\\n    for ( int i = 0; i < iterations; i++ ) {\\n        print();\\n        update();\\n    }\\n}\\n\\nGlider::Glider( char x , char y ) {\\n    xCoord = x;\\n    yCoord = y;\\n    height = GLIDER_SIZE;\\n    width = GLIDER_SIZE;\\n    figure = new char*[GLIDER_SIZE];\\n    for ( char i = 0; i < GLIDER_SIZE; i++ ) {\\n        figure[i] = new char[GLIDER_SIZE];\\n    }\\n    for ( char i = 0; i < GLIDER_SIZE; i++ ) {\\n        for ( char j = 0; j < GLIDER_SIZE; j++ ) {\\n            figure[i][j] = '.';\\n        }\\n    }\\n    figure[0][1] = 'X';\\n    figure[1][2] = 'X';\\n    figure[2][0] = 'X';\\n    figure[2][1] = 'X';\\n    figure[2][2] = 'X';\\n}\\n\\nGlider::~Glider() {\\n    for ( char i = 0; i < GLIDER_SIZE; i++ ) {\\n        delete[] figure[i];\\n    }\\n    delete[] figure;\\n}\\n\\nBlinker::Blinker( char x , char y ) {\\n    xCoord = x;\\n    yCoord = y;\\n    height = BLINKER_HEIGHT;\\n    width = BLINKER_WIDTH;\\n    figure = new char*[BLINKER_HEIGHT];\\n    for ( char i = 0; i < BLINKER_HEIGHT; i++ ) {\\n        figure[i] = new char[BLINKER_WIDTH];\\n    }\\n    for ( char i = 0; i < BLINKER_HEIGHT; i++ ) {\\n        for ( char j = 0; j < BLINKER_WIDTH; j++ ) {\\n            figure[i][j] = 'X';\\n        }\\n    }\\n}\\n\\nBlinker::~Blinker() {\\n    for ( char i = 0; i < BLINKER_HEIGHT; i++ ) {\\n        delete[] figure[i];\\n    }\\n    delete[] figure;\\n}\\n\\nint main() {\\n    Glider glider(0,0);\\n    GameOfLife gol(glider);\\n    gol.iterate(5);\\n    Blinker blinker(1,0);\\n    GameOfLife gol2(blinker);\\n    gol2.iterate(4);\\n}\\n"
"C++","Conway's_Game_of_Life","The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.\\nConway's game of life is described   here:\\nA cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.\\nWe calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:\\nAssume cells beyond the boundary are always dead.\\nThe \""game\"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.\\n\\nAlthough you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.\\n\\n\\n\\n","\\n#include <algorithm>\\n#include <vector>\\n#include <iostream>\\n#include <string>\\n\\ntypedef unsigned char byte; \\n\\nclass world {\\npublic:\\n    world( int x, int y ) : _wid( x ), _hei( y ) {\\n        int s = _wid * _hei * sizeof( byte );\\n        _cells = new byte[s];\\n        memset( _cells, 0, s );\\n    }\\n    ~world() {\\n        delete [] _cells;\\n    }\\n    int wid() const {\\n        return _wid;\\n    }\\n    int hei() const {\\n        return _hei;\\n    }\\n    byte at( int x, int y ) const {\\n        return _cells[x + y * _wid];\\n    }\\n    void set( int x, int y, byte c ) {\\n        _cells[x + y * _wid] = c;\\n    }\\n    void swap( world* w ) {\\n        memcpy( _cells, w->_cells, _wid * _hei * sizeof( byte ) );\\n    }\\nprivate:\\n    int _wid, _hei;\\n    byte* _cells;\\n};\\nclass rule {\\npublic:\\n    rule( world* w ) : wrd( w ) {\\n        wid = wrd->wid();\\n        hei = wrd->hei();\\n        wrdT = new world( wid, hei );\\n    }\\n    ~rule() {\\n        if( wrdT ) delete wrdT;\\n    }\\n    bool hasLivingCells() {\\n        for( int y = 0; y < hei; y++ )\\n            for( int x = 0; x < wid; x++ )\\n                if( wrd->at( x, y ) ) return true;\\n        std::cout << \""*** All cells are dead!!! ***\\n\\n\"";\\n        return false;\\n    }\\n    void swapWrds() {\\n        wrd->swap( wrdT );\\n    }\\n    void setRuleB( std::vector<int>& birth ) {\\n        _birth = birth;\\n    }\\n    void setRuleS( std::vector<int>& stay ) {\\n        _stay = stay;\\n    }\\n    void applyRules() {\\n        int n;\\n        for( int y = 0; y < hei; y++ ) {\\n            for( int x = 0; x < wid; x++ ) {\\n                n = neighbours( x, y );\\n                if( wrd->at( x, y ) ) {\\n                    wrdT->set( x, y, inStay( n ) ? 1 : 0 );\\n                } else {\\n                    wrdT->set( x, y, inBirth( n ) ? 1 : 0 );\\n                }\\n            }\\n        }\\n    }\\nprivate:\\n    int neighbours( int xx, int yy ) {\\n        int n = 0, nx, ny;\\n        for( int y = -1; y < 2; y++ ) {\\n            for( int x = -1; x < 2; x++ ) {\\n                if( !x && !y ) continue;\\n                nx = ( wid + xx + x ) % wid;\\n                ny = ( hei + yy + y ) % hei;\\n                n += wrd->at( nx, ny ) > 0 ? 1 : 0;\\n            }\\n        }\\n        return n;\\n    }\\n    bool inStay( int n ) {\\n        return( _stay.end() != find( _stay.begin(), _stay.end(), n ) );\\n    }\\n    bool inBirth( int n ) {\\n        return( _birth.end() != find( _birth.begin(), _birth.end(), n ) );\\n    }\\n    int wid, hei;\\n    world *wrd, *wrdT;\\n    std::vector<int> _stay, _birth;\\n};\\nclass cellular {\\npublic:\\n    cellular( int w, int h ) : rl( 0 ) {\\n        wrd = new world( w, h );\\n    }\\n    ~cellular() {\\n        if( rl ) delete rl;\\n        delete wrd;\\n    }\\n    void start( int r ) {\\n        rl = new rule( wrd );\\n        gen = 1;\\n        std::vector<int> t;\\n        switch( r ) {\\n            case 1: // conway\\n                t.push_back( 2 ); t.push_back( 3 ); rl->setRuleS( t );\\n                t.clear(); t.push_back( 3 ); rl->setRuleB( t );\\n                break;\\n            case 2: // amoeba\\n                t.push_back( 1 ); t.push_back( 3 ); t.push_back( 5 ); t.push_back( 8 ); rl->setRuleS( t );\\n                t.clear(); t.push_back( 3 ); t.push_back( 5 ); t.push_back( 7 ); rl->setRuleB( t );\\n                break;\\n            case 3: // life34\\n                t.push_back( 3 ); t.push_back( 4 ); rl->setRuleS( t );\\n                rl->setRuleB( t );\\n                break;\\n            case 4: // maze\\n                t.push_back( 1 ); t.push_back( 2 ); t.push_back( 3 ); t.push_back( 4 ); t.push_back( 5 ); rl->setRuleS( t );\\n                t.clear(); t.push_back( 3 ); rl->setRuleB( t );\\n                break;\\n        }\\n\\n        /* just for test - shoud read from a file */\\n        /* GLIDER */\\n        wrd->set( 6, 1, 1 ); wrd->set( 7, 2, 1 );\\n        wrd->set( 5, 3, 1 ); wrd->set( 6, 3, 1 );\\n        wrd->set( 7, 3, 1 );\\n        /* BLINKER */\\n        wrd->set( 1, 3, 1 ); wrd->set( 2, 3, 1 );\\n        wrd->set( 3, 3, 1 );\\n        /******************************************/\\n        generation();\\n    }\\nprivate:\\n    void display() {\\n        system( \""cls\"" );\\n        int wid = wrd->wid(),\\n            hei = wrd->hei();\\n        std::cout << \""+\"" << std::string( wid, '-' ) << \""+\\n\"";\\n        for( int y = 0; y < hei; y++ ) {\\n            std::cout << \""|\"";\\n            for( int x = 0; x < wid; x++ ) {\\n                if( wrd->at( x, y ) ) std::cout << \""#\"";\\n                else std::cout << \"".\"";\\n            }\\n            std::cout << \""|\\n\"";\\n        }\\n        std::cout << \""+\"" << std::string( wid, '-' ) << \""+\\n\"";\\n        std::cout << \""Generation: \"" << gen << \""\\n\\nPress [RETURN] for the next generation...\"";\\n        std::cin.get();\\n    }\\n    void generation() {\\n        do {\\n            display();\\n            rl->applyRules();\\n            rl->swapWrds();\\n            gen++;\\n        }\\n        while ( rl->hasLivingCells() );\\n    }\\n    rule* rl;\\n    world* wrd;\\n    int gen; \\n};\\n\\nint main( int argc, char* argv[] ) {\\n    cellular c( 20, 12 );\\n    std::cout << \""\\n\\t*** CELLULAR AUTOMATA ***\"" << \""\\n\\n Which one you want to run?\\n\\n\\n\"";\\n    std::cout << \"" [1]\\tConway's Life\\n [2]\\tAmoeba\\n [3]\\tLife 34\\n [4]\\tMaze\\n\\n > \"";\\n    int o; \\n    do {\\n        std::cin >> o;\\n    } \\n    while( o < 1 || o > 4 );\\n    std::cin.ignore();\\n    c.start( o );\\n    return system( \""pause\"" );\\n}\\n"
"C++","Conway's_Game_of_Life","The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.\\nConway's game of life is described   here:\\nA cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.\\nWe calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:\\nAssume cells beyond the boundary are always dead.\\nThe \""game\"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.\\n\\nAlthough you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.\\n\\n\\n\\n","\\n#include <iostream>\\n#include <vector>\\n#include <numeric>\\n\\n// ----------------------------------------------------------------------------\\n\\nusing Row   = std::vector<int>;\\nusing Cells = std::vector<Row>;\\n\\n// ----------------------------------------------------------------------------\\n\\nCells board = {\\n    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\\n    {0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\\n    {0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\\n    {0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\\n    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\\n    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\\n    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\\n    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\\n    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\\n    {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, \\n};\\n\\nint numRows = 10;\\nint numCols = 20;\\n\\n// ----------------------------------------------------------------------------\\n\\nint getNeighbor(int row, int col, Cells& board) {\\n    // use modulus to get wrapping effect at board edges\\n    return board.at((row + numRows) % numRows).at((col + numCols) % numCols);\\n}\\n\\nint getCount(int row, int col, Cells& board) {\\n    int count = 0;\\n    std::vector<int> deltas {-1, 0, 1};\\n    for (int dc : deltas) {\\n        for (int dr : deltas) {\\n            if (dr || dc) {\\n                count += getNeighbor(row + dr, col + dc, board);\\n            }\\n        }\\n    }\\n    return count;\\n}\\n\\nvoid showCell(int cell) {\\n    std::cout << (cell ? \""*\"" : \"" \"");\\n}\\n\\nvoid showRow(const Row& row) {\\n    std::cout << \""|\"";\\n    for (int cell : row) {showCell(cell);}\\n    std::cout << \""|\\n\"";\\n}\\n\\nvoid showCells(Cells board) {\\n    for (const Row& row : board) { showRow(row); }\\n}\\n\\nint tick(Cells& board, int row, int col) {\\n    int count = getCount(row, col, board);\\n    bool birth = !board.at(row).at(col) && count == 3;\\n    bool survive = board.at(row).at(col) && (count == 2 || count == 3);\\n    return birth || survive;\\n}\\n\\nvoid updateCells(Cells& board) {\\n    Cells original = board;\\n    for (int row = 0; row < numRows; row++) {\\n        for (int col = 0; col < numCols; col++) {\\n            board.at(row).at(col) = tick(original, row, col);\\n        }\\n    }\\n}\\n\\nint main () {\\n    for (int gen = 0; gen < 20; gen++) {\\n        std::cout << \""\\ngeneration \"" << gen << \"":\\n\"";\\n        showCells(board);\\n        updateCells(board);\\n    }\\n}\\n"
"C++","Copy_a_string","This task is about copying a string.\\n\\nWhere it is relevant, distinguish between copying the contents of a string\\nversus making an additional reference to an existing string.\\n\\nTo copy a string, we use an MVC (Move Character). To make a reference to a string, we use a LA (Load Address).\\nStrings are immutable in ActionScript, and can safely be assigned with the assignment operator, much as they can in Java.[1]\\nAda provides three different kinds of strings.\\nThe String type is a fixed length string.\\nThe Bounded_String type is a string with variable length up to a specified maximum size.\\nThe Unbounded_String type is a variable length string with no specified maximum size.\\nThe Bounded_String type behaves a lot like C strings, while the Unbounded_String type behaves a lot like the C++ String class.\\nAda provides the ability to manipulate slices of strings.\\nAda Bounded_String type provides a number of functions for dealing with slices.\\nThe intrinsic text type is immediate, immutable\\nand cannot be referred more than once.\\nCopying an intrinsic string:\\nData of the non intrinsic byte array type can be referred more than once.\\nCopying a binary array of bytes:\\nIn ALGOL 68 strings are simply flexible length arrays of CHAR;\\n","#include <iostream>\\n#include <string>\\n\\nint main( ) {\\n   std::string original (\""This is the original\"");\\n   std::string my_copy = original;\\n   std::cout << \""This is the copy: \"" << my_copy << std::endl;\\n   original = \""Now we change the original! \"";\\n   std::cout << \""my_copy still is \"" << my_copy << std::endl;\\n}"
"C++","Count_in_factors","Write a program which counts up from   1,   displaying each number as the multiplication of its prime factors.\\nFor the purpose of this task,   1   (unity)   may be shown as itself.\\n\\n      2   is prime,   so it would be shown as itself.\\n      6   is not prime;   it would be shown as   \\n\\n\\n\\n2\\n×\\n3\\n\\n\\n{\\displaystyle 2\\times 3}\\n\\n.\\n2144   is not prime;   it would be shown as   \\n\\n\\n\\n2\\n×\\n2\\n×\\n2\\n×\\n2\\n×\\n2\\n×\\n67\\n\\n\\n{\\displaystyle 2\\times 2\\times 2\\times 2\\times 2\\times 67}\\n\\n.\\n\\n\\n","\\n#include <iostream>\\n#include <sstream>\\n#include <iomanip>\\nusing namespace std;\\n\\nvoid getPrimeFactors( int li )\\n{\\n    int f = 2; string res;\\n    if( li == 1 ) res = \""1\"";\\n    else\\n    {\\n	while( true )\\n	{\\n	    if( !( li % f ) ) \\n	    {\\n		stringstream ss; ss << f;\\n		res += ss.str();\\n		li /= f; if( li == 1 ) break;\\n		res += \"" x \"";\\n	    }\\n	    else f++;\\n	}\\n    }\\n    cout << res << \""\\n\"";\\n}\\n\\nint main( int argc, char* argv[] )\\n{\\n    for( int x = 1; x < 101; x++ )\\n    {\\n	cout << right << setw( 4 ) << x << \"": \""; \\n	getPrimeFactors( x );\\n    }\\n    cout << 2144 << \"": \""; getPrimeFactors( 2144 );\\n    cout << \""\\n\\n\"";\\n    return system( \""pause\"" );\\n}\\n"
"C++","Count_in_octal","Produce a sequential count in octal,   starting at zero,   and using an increment of a one for each consecutive number.\\nEach number should appear on a single line,   and the program should count until terminated,   or until the maximum value of the numeric type in use is reached.\\n\\n\\nThe program uses one ASSIST macro (XPRNT) to keep the code as short as possible.\\n","#include <iostream>\\n\\nint main()\\n{\\n  unsigned i = 0;\\n  do\\n  {\\n    std::cout << std::oct << i << std::endl;\\n    ++i;\\n  } while(i != 0);\\n  return 0;\\n}"
"C++","Create_a_file","In this task, the job is to create a new empty file called \""output.txt\"" of size 0 bytes\\nand an empty directory called \""docs\"". This should be done twice: once \""here\"", i.e. in the current working directory and once in the filesystem root.\\nNotes:\\nNote: file names are Operating System dependent.\\nIt may be best to to use an operating system provided library.\\nAppleScript itself has limited built-in File System access, but folders (directories) can be created by controlling the Mac OS Finder, and files can be created and accessed using the Standard Additions (osax) scripting addition included with AppleScript. Also, the Finder has no concept of the working directory (as it is a GUI). You can however target the frontmost Finder window that is open.\\nCreate a zero-byte text file on the startup disk (root directory). Note: the close command is a memory allocation housekeeping command that should be performed once file access is complete.\\nCreate a new folder (directory) on the startup disk (root directory).\\nCreate a zero-byte text file in the frontmost (open) Finder window.\\nCreate a new folder (directory) in the frontmost (open) Finder window.\\n--Apl.way 21:20, 9 June 2010 (UTC)\\nSince the TI-OS does not have a true filesystem, this task is emulated using an application variable instead of a file.\\n","#include <fstream>\\n#include <direct.h>\\n\\nint main() {\\n	std::fstream f( \""output.txt\"", std::ios::out );\\n	f.close();\\n	f.open( \""/output.txt\"", std::ios::out );\\n	f.close();\\n\\n	_mkdir( \""docs\"" );\\n	_mkdir( \""/docs\"" );\\n\\n	return 0;\\n}"
"C++","Create_a_two-dimensional_array_at_runtime","Data Structure\\nThis illustrates a data structure, a means of storing data within a program.\\nGet two integers from the user, then create a two-dimensional array where the two dimensions have the sizes given by those numbers, and which can be accessed in the most natural way possible. Write some element of that array, and then output that element. Finally destroy the array if not done by the language itself.\\nArrays are an integral part of APL. Array size, shape, and data type can be easily manipulated at runtime.\\nAppleScript has no array, but an AppleScript list can be used in a multidimensional fashion. There's no issue with their dimensions, they grow while adding elements. Memory allocation is dynamic.\\nAWK has no multidimensional array; but AWK arrays (which are Associative array indeed) can be used also in a multidimensional fashion. Since AWK arrays are associative arrays, there's no issue in their dimensions: they grow while adding new key-value pair.\\nAllocate multi-dimensional arrays with a single call to malloc. The demonstration code builds a rank 3 array.\\n\\nThis style is supported by all 'C' compilers.\\nThis style also supports more efficient memory utilization if you're only using a portion of the\\narray. If you only need the upper right half of a square array, you can do something like the following.\\nThis approach most closely matches the C99 example, as alloca allocates on the stack, rather than the heap, as malloc does.\\n\\nThe assert will allow the user to reenter the dimensions if they are not positive integers.\\nArrays in Component Pascal are started from zero index. No DISPOSE-like procedures because of garbage collection.\\n","#include <iostream>\\n\\nint main()\\n{\\n  // read values\\n  int dim1, dim2;\\n  std::cin >> dim1 >> dim2;\\n\\n  // create array\\n  double* array_data = new double[dim1*dim2];\\n  double** array = new double*[dim1];\\n  for (int i = 0; i < dim1; ++i)\\n    array[i] = array_data + dim2*i;\\n\\n  // write element\\n  array[0][0] = 3.5;\\n\\n  // output element\\n  std::cout << array[0][0] << std::endl;\\n\\n  // get rid of array\\n  delete[] array;\\n  delete[] array_data;\\n\\n  return 0;\\n}"
"C++","Create_a_two-dimensional_array_at_runtime","Data Structure\\nThis illustrates a data structure, a means of storing data within a program.\\nGet two integers from the user, then create a two-dimensional array where the two dimensions have the sizes given by those numbers, and which can be accessed in the most natural way possible. Write some element of that array, and then output that element. Finally destroy the array if not done by the language itself.\\nArrays are an integral part of APL. Array size, shape, and data type can be easily manipulated at runtime.\\nAppleScript has no array, but an AppleScript list can be used in a multidimensional fashion. There's no issue with their dimensions, they grow while adding elements. Memory allocation is dynamic.\\nAWK has no multidimensional array; but AWK arrays (which are Associative array indeed) can be used also in a multidimensional fashion. Since AWK arrays are associative arrays, there's no issue in their dimensions: they grow while adding new key-value pair.\\nAllocate multi-dimensional arrays with a single call to malloc. The demonstration code builds a rank 3 array.\\n\\nThis style is supported by all 'C' compilers.\\nThis style also supports more efficient memory utilization if you're only using a portion of the\\narray. If you only need the upper right half of a square array, you can do something like the following.\\nThis approach most closely matches the C99 example, as alloca allocates on the stack, rather than the heap, as malloc does.\\n\\nThe assert will allow the user to reenter the dimensions if they are not positive integers.\\nArrays in Component Pascal are started from zero index. No DISPOSE-like procedures because of garbage collection.\\n","#include <iostream>\\n#include <vector>\\n\\nint main()\\n{\\n  // read values\\n  int dim1, dim2;\\n  std::cin >> dim1 >> dim2;\\n\\n  // create array\\n  std::vector array(dim1, std::vector<double>(dim2));\\n\\n  // write element\\n  array[0][0] = 3.5;\\n\\n  // output element\\n  std::cout << array[0][0] << std::endl;\\n\\n  // the array is automatically freed at the end of main()\\n  return 0;\\n}"
"C++","Create_a_two-dimensional_array_at_runtime","Data Structure\\nThis illustrates a data structure, a means of storing data within a program.\\nGet two integers from the user, then create a two-dimensional array where the two dimensions have the sizes given by those numbers, and which can be accessed in the most natural way possible. Write some element of that array, and then output that element. Finally destroy the array if not done by the language itself.\\nArrays are an integral part of APL. Array size, shape, and data type can be easily manipulated at runtime.\\nAppleScript has no array, but an AppleScript list can be used in a multidimensional fashion. There's no issue with their dimensions, they grow while adding elements. Memory allocation is dynamic.\\nAWK has no multidimensional array; but AWK arrays (which are Associative array indeed) can be used also in a multidimensional fashion. Since AWK arrays are associative arrays, there's no issue in their dimensions: they grow while adding new key-value pair.\\nAllocate multi-dimensional arrays with a single call to malloc. The demonstration code builds a rank 3 array.\\n\\nThis style is supported by all 'C' compilers.\\nThis style also supports more efficient memory utilization if you're only using a portion of the\\narray. If you only need the upper right half of a square array, you can do something like the following.\\nThis approach most closely matches the C99 example, as alloca allocates on the stack, rather than the heap, as malloc does.\\n\\nThe assert will allow the user to reenter the dimensions if they are not positive integers.\\nArrays in Component Pascal are started from zero index. No DISPOSE-like procedures because of garbage collection.\\n","#include <iostream>\\n#include \\n\\ntypedef boost::multi_array two_d_array_type;\\n\\nint main()\\n{\\n    // read values\\n    int dim1, dim2;\\n    std::cin >> dim1 >> dim2;\\n\\n    // create array\\n    two_d_array_type A(boost::extents[dim1][dim2]);\\n\\n    // write element\\n    A[0][0] = 3.1415;\\n\\n    // read element\\n    std::cout << A[0][0] << std::endl;\\n\\n    return 0;\\n}"
"C++","Create_a_two-dimensional_array_at_runtime","Data Structure\\nThis illustrates a data structure, a means of storing data within a program.\\nGet two integers from the user, then create a two-dimensional array where the two dimensions have the sizes given by those numbers, and which can be accessed in the most natural way possible. Write some element of that array, and then output that element. Finally destroy the array if not done by the language itself.\\nArrays are an integral part of APL. Array size, shape, and data type can be easily manipulated at runtime.\\nAppleScript has no array, but an AppleScript list can be used in a multidimensional fashion. There's no issue with their dimensions, they grow while adding elements. Memory allocation is dynamic.\\nAWK has no multidimensional array; but AWK arrays (which are Associative array indeed) can be used also in a multidimensional fashion. Since AWK arrays are associative arrays, there's no issue in their dimensions: they grow while adding new key-value pair.\\nAllocate multi-dimensional arrays with a single call to malloc. The demonstration code builds a rank 3 array.\\n\\nThis style is supported by all 'C' compilers.\\nThis style also supports more efficient memory utilization if you're only using a portion of the\\narray. If you only need the upper right half of a square array, you can do something like the following.\\nThis approach most closely matches the C99 example, as alloca allocates on the stack, rather than the heap, as malloc does.\\n\\nThe assert will allow the user to reenter the dimensions if they are not positive integers.\\nArrays in Component Pascal are started from zero index. No DISPOSE-like procedures because of garbage collection.\\n","#include <cstdlib>\\n#include \\n#include \\n\\nint main (const int argc, const char** argv) {\\n    if (argc > 2) {\\n        using namespace boost::numeric::ublas;\\n\\n        matrix<double> m(atoi(argv[1]), atoi(argv[2])); // build\\n        for (unsigned i = 0; i < m.size1(); i++)\\n            for (unsigned j = 0; j < m.size2(); j++)\\n                m(i, j) = 1.0 + i + j; // fill\\n        std::cout << m << std::endl; // print\\n        return EXIT_SUCCESS;\\n    }\\n\\n    return EXIT_FAILURE;\\n}"
"C++","Create_an_HTML_table","Create an HTML table.\\n\\n","#include <fstream>\\n#include \\n#include <string>\\n#include <cstdlib>\\n#include <ctime>\\n#include <sstream>\\n\\nvoid makeGap( int gap , std::string & text ) {\\n   for ( int i = 0 ; i < gap ; i++ ) \\n      text.append( \"" \"" ) ;\\n}\\n\\nint main( ) {\\n   boost::array chars = { 'X' , 'Y' , 'Z' } ;\\n   int headgap = 3 ;\\n   int bodygap = 3 ;\\n   int tablegap = 6 ;\\n   int rowgap = 9 ;\\n   std::string tabletext( \""<html>\\n\"" ) ;\\n   makeGap( headgap , tabletext ) ;\\n   tabletext += \""<head>"
"C++","Create_an_HTML_table","Create an HTML table.\\n\\n","<html>\\n   <head>"
"C++","Create_an_object_at_a_given_address","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\nIn systems programing it is sometimes required to place language objects at specific memory locations, like I/O registers, hardware interrupt vectors etc.\\nTask\\nShow how language objects can be allocated at a specific machine addresses.\\nSince most OSes prohibit access to the physical memory if it is not mapped by the application, as an example, rather than a physical address, take the address of some existing object (using suitable address operations if necessary). For example, create an integer object. Print the machine address of the object. Take the address of the object and create another integer object at this address. Print the value of this object to verify that it is same as one of the origin. Change the value of the origin and verify it again.\\nIn 6502 Assembly memory is represented by either an 8-bit or a 16-bit address (i.e. $0000 - $FFFF). 8-bit address are reserved for the memory from $00 to $FF - known as zero page; access to this memory takes one less byte in the opcode and one less cycle to execute.\\nData can be stored, one byte at a time, through the store instructions, for example to store data at $1900:\\nStorage can be indexed through the use of the X or Y registers:\\nIt can also be stored via indirect indexed addressing (i.e. memory points to an address), using the Y register:\\nFinally, it can be stored via indexed indirect addressing (i.e. read the address of memory from the table stored at the parameter), using the X register:\\nIt should be noted that on the 6502 processor hardware is normally memory mapped, so this is often used for manipulating hardware.\\nIn Ada object address can be specified using the address representation clause RM 13.3:\\nIn the example above the address is specified constant. It is also possible to specify address dynamically as the following solution of the task does:\\nSample output:\\nAikido doesn't support getting the address of a variable. However, in the spirit of this task, it does support raw memory access using peek and poke. These can be used on both an integer representing an address (64 bit) or a value obtained from calling malloc.\\nIn AutoHotkey indeed no language objects can be created at a specified address. But it's very well possible to read and write memory addresses directly. All standard number types are allowed.\\nOutput:\\nA more typical embedded way of doing this is below. Note that the OS will probably not allow this due to memory protections. Embedded systems often do not have memory managers.\\nC++ supports this natively through placement new. This allows construction of complex object types in arbitrary memory locations.\\nSample output:\\nOutput:\\nA better presentation.\\noutput:\\nAs an untyped language, specific machine addresses are very easy to represent in Forth. This is usually most useful for embedded targets.\\nSome architectures may require special fetch and store operators to access ports. For example, Open Firmware defines [email protected] and l! for safe 32-bit port writes.\\n","#include <string>\\n#include <iostream>\\n\\nint main()\\n{\\n    // Allocate enough memory to hold an instance of std::string\\n    char* data = new char[sizeof(std::string)];\\n\\n    // use placement new to construct a std::string in the memory we allocated previously\\n    std::string* stringPtr = new (data) std::string(\""ABCD\"");\\n\\n    std::cout << *stringPtr << \"" 0x\"" << stringPtr << std::endl;\\n\\n    // use placement new to construct a new string object in the same memory location\\n    // remember to manually call destructor\\n    stringPtr->~basic_string();\\n    stringPtr = new (data) std::string(\""123456\"");\\n\\n    std::cout << *stringPtr << \"" 0x\"" << stringPtr << std::endl;\\n\\n    // clean up\\n    stringPtr->~basic_string();\\n    delete[] data;\\n}"
"C++","CSV_data_manipulation","CSV spreadsheet files are suitable for storing tabular data in a relatively portable way.\\nThe CSV format is flexible but somewhat ill-defined.\\nFor present purposes, authors may assume that the data fields contain no commas, backslashes, or quotation marks.\\n\\nRead a CSV file, change some values and save the changes back to a file.\\nFor this task we will use the following CSV file:\\nSuggestions\\n\\nAda has no build-in or predefined functions to read or write CSV tables. We thus define a (very simplistic) package CSV, which allows to read a row (function Line), to step from column to column (function Next), and to get the items in the column (function Item):\\nThe implementation of the package is\\nFinally, the main program which uses the package CSV:\\n","#include <map>\\n#include <vector>\\n#include <iostream>\\n#include <fstream>\\n#include <utility>\\n#include <functional>\\n#include <string>\\n#include <sstream>\\n#include <algorithm>\\n#include <cctype>\\n\\nclass CSV\\n{\\npublic:\\n    CSV(void) : m_nCols( 0 ), m_nRows( 0 )\\n    {}\\n\\n    bool open( const char* filename, char delim = ',' )\\n    {\\n        std::ifstream file( filename );\\n    \\n        clear();\\n        if ( file.is_open() )\\n        {\\n            open( file, delim );\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    void open( std::istream& istream, char delim = ',' )\\n    {\\n        std::string         line;\\n\\n        clear();\\n        while ( std::getline( istream, line ) )\\n        {\\n            unsigned int nCol = 0;\\n            std::istringstream    lineStream(line);\\n            std::string           cell;\\n\\n            while( std::getline( lineStream, cell, delim ) )\\n            {\\n                m_oData[std::make_pair( nCol, m_nRows )] = trim( cell );\\n                nCol++;\\n            }\\n            m_nCols = std::max( m_nCols, nCol );\\n            m_nRows++;\\n        }\\n    }\\n\\n    bool save( const char* pFile, char delim = ',' )\\n    {\\n        std::ofstream ofile( pFile );\\n        if ( ofile.is_open() )\\n        {\\n            save( ofile );\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    void save( std::ostream& ostream, char delim = ',' )\\n    {\\n        for ( unsigned int nRow = 0; nRow < m_nRows; nRow++ )\\n        {\\n            for ( unsigned int nCol = 0; nCol < m_nCols; nCol++ )\\n            {\\n                ostream << trim( m_oData[std::make_pair( nCol, nRow )] );\\n                if ( (nCol+1) < m_nCols )\\n                {\\n                    ostream << delim;\\n                }\\n                else\\n                {\\n                    ostream << std::endl;\\n                }\\n            }\\n        }\\n    }\\n\\n    void clear()\\n    {\\n        m_oData.clear();\\n        m_nRows = m_nCols = 0;\\n    }\\n\\n    std::string& operator()( unsigned int nCol, unsigned int nRow )\\n    {\\n        m_nCols = std::max( m_nCols, nCol+1 );\\n        m_nRows = std::max( m_nRows, nRow+1 );\\n        return m_oData[std::make_pair(nCol, nRow)];\\n    }\\n\\n    inline unsigned int GetRows() { return m_nRows; }\\n    inline unsigned int GetCols() { return m_nCols; }\\n\\nprivate:\\n    // trim string for empty spaces in begining and at the end\\n    inline std::string &trim(std::string &s) \\n    {\\n        \\n        s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun(std::isspace))));\\n        s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun(std::isspace))).base(), s.end());\\n        return s;\\n    }\\n\\nprivate:\\n    std::map, std::string> m_oData;\\n\\n    unsigned int    m_nCols;\\n    unsigned int    m_nRows;\\n};\\n\\n\\nint main()\\n{\\n    CSV oCSV;\\n\\n    oCSV.open( \""test_in.csv\"" );\\n    oCSV( 0, 0 ) = \""Column0\"";\\n    oCSV( 1, 1 ) = \""100\"";\\n    oCSV( 2, 2 ) = \""200\"";\\n    oCSV( 3, 3 ) = \""300\"";\\n    oCSV( 4, 4 ) = \""400\"";\\n    oCSV.save( \""test_out.csv\"" );\\n    return 0;\\n}"
"C++","CSV_to_HTML_translation","Consider a simplified CSV format where all rows are separated by a newline\\nand all columns are separated by commas.\\nNo commas are allowed as field data, but the data may contain\\nother characters and character sequences that would\\nnormally be   escaped   when converted to HTML\\n\\nCreate a function that takes a string representation of the CSV data\\nand returns a text string of an HTML table representing the CSV data.\\nUse the following data as the CSV text to convert, and show your output.\\n\\nOptionally allow special formatting for the first row of the table as if it is the tables header row\\n(via <thead> preferably; CSS if you must).\\n\\ncsv2html.adb:\\ntable.tmplt:\\n","#include <string>\\n#include \\n#include <iostream>\\n\\nstd::string csvToHTML( const std::string & ) ;\\n\\nint main( ) {\\n   std::string text = \""Character,Speech\\n\"" \\n                            \""The multitude,The messiah! Show us the messiah!\\n\"" \\n			    \""Brians mother,<angry>Now you listen here! He's not the messiah; he's a very naughty boy! Now go away!"
"C++","CSV_to_HTML_translation","Consider a simplified CSV format where all rows are separated by a newline\\nand all columns are separated by commas.\\nNo commas are allowed as field data, but the data may contain\\nother characters and character sequences that would\\nnormally be   escaped   when converted to HTML\\n\\nCreate a function that takes a string representation of the CSV data\\nand returns a text string of an HTML table representing the CSV data.\\nUse the following data as the CSV text to convert, and show your output.\\n\\nOptionally allow special formatting for the first row of the table as if it is the tables header row\\n(via <thead> preferably; CSS if you must).\\n\\ncsv2html.adb:\\ntable.tmplt:\\n","\\n<TABLE>\\n    <TR><TD>Character"
"C++","Cuban_primes","The name   cuban   has nothing to do with Cuba,   but has to do with the\\nfact that cubes   (3rd powers)   play a role in its definition.\\n\\n\\nCuban primes were named in 1923 by Allan Joseph Champneys Cunningham.\\n\\n\\nNote that   cuban prime   isn't capitalized   (as it doesn't refer to Cuba).\\n\\n\\n","#include <iostream> \\n#include <vector> \\n#include <chrono>\\n#include <climits>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nvector  primes{ 3, 5 };\\n\\nint main()\\n{\\n	cout.imbue(locale(\""\""));\\n	const int cutOff = 200, bigUn = 100000,\\n	          chunks = 50, little = bigUn / chunks;\\n    const char tn[] = \"" cuban prime\"";\\n	cout << \""The first \"" << cutOff << tn << \""s:\"" << endl;\\n	int c = 0;\\n	bool showEach = true;\\n	long long u = 0, v = 1;\\n	auto st = chrono::system_clock::now();\\n\\n	for (long long i = 1; i <= LLONG_MAX; i++)\\n	{\\n		bool found = false;\\n		long long mx = (long long)(ceil(sqrt(v += (u += 6))));\\n		for (long long item : primes)\\n		{\\n			if (item > mx) break;\\n			if (v % item == 0) { found = true; break; }\\n		}\\n		if (!found)\\n		{\\n			c += 1; if (showEach)\\n			{\\n				for (long long z = primes.back() + 2; z <= v - 2; z += 2)\\n				{\\n					bool fnd = false;\\n					for (long long item : primes)\\n					{\\n						if (item > mx) break;\\n						if (z % item == 0) { fnd = true; break; }\\n					}\\n					if (!fnd) primes.push_back(z);\\n				}\\n				primes.push_back(v); cout.width(11); cout << v;\\n				if (c % 10 == 0) cout << endl;\\n				if (c == cutOff)\\n				{\\n					showEach = false;\\n					cout << \""\\nProgress to the \"" << bigUn << \""th\"" << tn << \"": \"";\\n				}\\n			}\\n			if (c % little == 0) { cout << \"".\""; if (c == bigUn) break; }\\n		}\\n	}\\n	cout << \""\\nThe \"" << c << \""th\"" << tn << \"" is \"" << v;\\n	chrono::duration<double> elapsed_seconds = chrono::system_clock::now() - st;\\n	cout << \""\\nComputation time was \"" << elapsed_seconds.count() << \"" seconds\"" << endl;\\n	return 0;\\n}"
"C++","Cumulative_standard_deviation","Write a stateful function, class, generator or co-routine that takes a series of floating point numbers, one at a time, and returns the running standard deviation of the series.\\nThe task implementation should use the most natural programming style of those listed for the function in the implementation language; the task must state which is being used.\\nDo not apply Bessel's correction; the returned standard deviation should always be computed as if the sample seen so far is the entire population.\\n\\nUse this to compute the standard deviation of this demonstration set, \\n\\n\\n\\n{\\n2\\n,\\n4\\n,\\n4\\n,\\n4\\n,\\n5\\n,\\n5\\n,\\n7\\n,\\n9\\n}\\n\\n\\n{\\displaystyle \\{2,4,4,4,5,5,7,9\\}}\\n\\n, which is \\n\\n\\n\\n2\\n\\n\\n{\\displaystyle 2}\\n\\n.\\n\\n\\nFor maximum compatibility, this program uses only the basic instruction set.\\nPart of the code length is due to the square root algorithm and to the nice output.\\n","\\n#include <assert.h>\\n#include <cmath>\\n#include <vector>\\n#include <iostream>\\n\\ntemplate struct MomentsAccumulator_\\n{\\n	std::vector<double> m_;\\n	MomentsAccumulator_() : m_(N + 1, 0.0) {}\\n	void operator()(double v)\\n	{\\n		double inc = 1.0;\\n		for (auto& mi : m_)\\n		{\\n			mi += inc;\\n			inc *= v;\\n		}\\n	}\\n};\\n\\ndouble Stdev(const std::vector<double>& moments)\\n{\\n	assert(moments.size() > 2);\\n	assert(moments[0] > 0.0);\\n	const double mean = moments[1] / moments[0];\\n	const double meanSquare = moments[2] / moments[0];\\n	return sqrt(meanSquare - mean * mean);\\n}\\n\\nint main(void)\\n{\\n	std::vector<int> data({ 2, 4, 4, 4, 5, 5, 7, 9 });\\n	MomentsAccumulator_<2> accum;\\n	for (auto d : data)\\n	{\\n		accum(d);\\n		std::cout << \""Running stdev:  \"" << Stdev(accum.m_) << \""\\n\"";\\n	}\\n}\\n"
"C++","CUSIP","\\nA   CUSIP   is a nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades. The CUSIP was adopted as an American National Standard under Accredited Standards X9.6.\\n\\nEnsure the last digit   (i.e., the   check digit)   of the CUSIP code (the 1st column) is correct, against the following:\\n\\n\\n\\n","#include <iostream>\\n#include <vector>\\n\\nbool isCusip(const std::string& s) {\\n    if (s.size() != 9) return false;\\n\\n    int sum = 0;\\n    for (int i = 0; i < 7; ++i) {\\n        char c = s[i];\\n\\n        int v;\\n        if ('0' <= c && c <= '9') {\\n            v = c - '0';\\n        } else if ('A' <= c && c <= 'Z') {\\n            v = c - '@';\\n        } else if (c = '*') {\\n            v = 36;\\n        } else if (c = '#') {\\n            v = 38;\\n        } else {\\n            return false;\\n        }\\n        if (i % 2 == 1) {\\n            v *= 2;\\n        }\\n        sum += v / 10 + v % 10;\\n    }\\n    return s[8] - '0' == (10 - (sum % 10)) % 10;\\n}\\n\\nint main() {\\n    using namespace std;\\n\\n    vector<string> candidates{\\n        \""037833100\"",\\n        \""17275R102\"",\\n        \""38259P508\"",\\n        \""594918104\"",\\n        \""68389X106\"",\\n        \""68389X105\""\\n    };\\n\\n    for (auto str : candidates) {\\n        auto res = isCusip(str) ? \""correct\"" : \""incorrect\"";\\n        cout << str.c_str() << \"" -> \"" << res << \""\\n\"";\\n    }\\n\\n    return 0;\\n}"
"C++","Cycle_detection","Detect a cycle in an iterated function using Brent's algorithm.\\n\\nDetecting cycles in iterated function sequences is a sub-problem in many computer algorithms, such as factoring prime numbers. Some such algorithms are highly space efficient, such as Floyd's cycle-finding algorithm, also called the \""tortoise and the hare algorithm\"". A more time efficient algorithm than \""tortoise and hare\"" is Brent's Cycle algorithm. This task will implement Brent's algorithm.\\nSee https://en.wikipedia.org/wiki/Cycle_detection for a discussion of the theory and discussions of other algorithms that are used to solve the problem.\\nWhen testing the cycle detecting function, you need two things:\\n1) An iterated function\\n2) A starting value\\nThe iterated function used in this example is: f(x) = (x*x + 1) modulo 255.\\nThe starting value used is 3.\\nWith these as inputs, a sample program output would be:\\n3,10,101,2,5,26,167,95,101,2,5,26,167,95,101,2,5,26,167,95,101,2,5,26,167,95,101,2,5,26,167,95,101,2,5,26,167,95,101,2,5\\nCycle length = 6\\nStart index = 2\\nThe output prints the first several items in the number series produced by the iterated function, then identifies how long the cycle is (6) followed by the zero-based index of the start of the first cycle (2). From this you can see that the cycle is:\\n101,2,5,26,167,95\\n","struct ListNode {\\n      int val;\\n      ListNode *next;\\n      ListNode(int x) : val(x), next(NULL) {}\\n };\\n \\nListNode* Solution::detectCycle(ListNode* A) {\\n    ListNode* slow = A;\\n    ListNode* fast = A;\\n    ListNode* cycleNode = 0;\\n    while (slow && fast && fast->next)\\n    {\\n        slow = slow->next;\\n        fast = fast->next->next;\\n        if (slow == fast)\\n        {\\n            cycleNode = slow;\\n            break;\\n        }\\n    }\\n    if (cycleNode == 0)\\n    {\\n        return 0;\\n    }\\n    std::set setPerimeter;\\n    setPerimeter.insert(cycleNode);\\n    for (ListNode* pNode = cycleNode->next; pNode != cycleNode; pNode = pNode->next)\\n    setPerimeter.insert(pNode);\\n    for (ListNode* pNode = A; true; pNode = pNode->next)\\n    {\\n        std::set::iterator iter = setPerimeter.find(pNode);\\n        if (iter != setPerimeter.end()) \\n        {\\n            return pNode;\\n        }\\n    }\\n}"
"C++","Data_Encryption_Standard","Demonstrate the Data Encryption Standard. For a complete description of the algorithm see: The DES Algorithm Illustrated\\n\\nTask:\\nUse the\\nBonus (optional): add standard padding to match the C#, Java, Modula-2, Kotlin, and Phix entries, so the above encrypted result would instead be 0000000000000000A913F4CB0BD30F97.\\n\\n","#include <algorithm>\\n#include <array>\\n#include <bitset>\\n#include <iomanip>\\n#include <iostream>\\n#include <ostream>\\n#include <vector>\\n\\ntemplate \\nstd::ostream& operator<<(std::ostream& out, std::bitset<N>& bs) {\\n    // debug\\n    for (int i = 0; i < N; i += 8) {\\n        out << bs.test(i + 0) << bs.test(i + 1) << bs.test(i + 2) << bs.test(i + 3) << '_';\\n        if (i + 7 < N) {\\n            out << bs.test(i + 4) << bs.test(i + 5) << bs.test(i + 6) << bs.test(i + 7) << ' ';\\n        } else {\\n            out << \""0000 \"";\\n        }\\n    }\\n    return out;\\n}\\n\\nnamespace DES {\\n    typedef unsigned char ubyte;\\n    typedef std::array key_t;\\n\\n    namespace impl {\\n        const int PC1[] = {\\n            57, 49, 41, 33, 25, 17,  9,\\n             1, 58, 50, 42, 34, 26, 18,\\n            10,  2, 59, 51, 43, 35, 27,\\n            19, 11,  3, 60, 52, 44, 36,\\n            63, 55, 47, 39, 31, 23, 15,\\n             7, 62, 54, 46, 38, 30, 22,\\n            14,  6, 61, 53, 45, 37, 29,\\n            21, 13,  5, 28, 20, 12,  4\\n        };\\n\\n        const int PC2[] = {\\n            14, 17, 11, 24,  1,  5,\\n             3, 28, 15,  6, 21, 10,\\n            23, 19, 12,  4, 26,  8,\\n            16,  7, 27, 20, 13,  2,\\n            41, 52, 31, 37, 47, 55,\\n            30, 40, 51, 45, 33, 48,\\n            44, 49, 39, 56, 34, 53,\\n            46, 42, 50, 36, 29, 32\\n        };\\n\\n        const int IP[] = {\\n            58, 50, 42, 34, 26, 18, 10,  2,\\n            60, 52, 44, 36, 28, 20, 12,  4,\\n            62, 54, 46, 38, 30, 22, 14,  6,\\n            64, 56, 48, 40, 32, 24, 16,  8,\\n            57, 49, 41, 33, 25, 17,  9,  1,\\n            59, 51, 43, 35, 27, 19, 11,  3,\\n            61, 53, 45, 37, 29, 21, 13,  5,\\n            63, 55, 47, 39, 31, 23, 15,  7\\n        };\\n\\n        const int E[] = {\\n            32,  1,  2,  3,  4,  5,\\n             4,  5,  6,  7,  8,  9,\\n             8,  9, 10, 11, 12, 13,\\n            12, 13, 14, 15, 16, 17,\\n            16, 17, 18, 19, 20, 21,\\n            20, 21, 22, 23, 24, 25,\\n            24, 25, 26, 27, 28, 29,\\n            28, 29, 30, 31, 32,  1\\n        };\\n\\n        const int S[][64] = {\\n            {\\n                14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7,\\n                 0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8,\\n                 4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0,\\n                15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13\\n            },\\n            {\\n                15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10,\\n                 3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5,\\n                 0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15,\\n                13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9\\n            },\\n            {\\n                10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8,\\n                13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1,\\n                13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7,\\n                 1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12\\n            },\\n            {\\n                 7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15,\\n                13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9,\\n                10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4,\\n                 3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14\\n            },\\n            {\\n                 2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9,\\n                14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6,\\n                 4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14,\\n                11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3\\n            },\\n            {\\n                12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11,\\n                10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8,\\n                 9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6,\\n                 4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13\\n            },\\n            {\\n                 4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1,\\n                13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6,\\n                 1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2,\\n                 6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12\\n            },\\n            {\\n                13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7,\\n                 1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2,\\n                 7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8,\\n                 2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11\\n            }\\n        };\\n\\n        const int P[] = {\\n            16,  7, 20, 21,\\n            29, 12, 28, 17,\\n             1, 15, 23, 26,\\n             5, 18, 31, 10,\\n             2,  8, 24, 14,\\n            32, 27,  3,  9,\\n            19, 13, 30,  6,\\n            22, 11,  4, 25\\n        };\\n\\n        const int IP2[] = {\\n            40,  8, 48, 16, 56, 24, 64, 32,\\n            39,  7, 47, 15, 55, 23, 63, 31,\\n            38,  6, 46, 14, 54, 22, 62, 30,\\n            37,  5, 45, 13, 53, 21, 61, 29,\\n            36,  4, 44, 12, 52, 20, 60, 28,\\n            35,  3, 43, 11, 51, 19, 59, 27,\\n            34,  2, 42, 10, 50, 18, 58, 26,\\n            33,  1, 41,  9, 49, 17, 57, 25\\n        };\\n\\n        const int SHIFTS[] = { 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 };\\n\\n        std::bitset<64> toBitSet(const key_t& key) {\\n            std::bitset<64> bs;\\n            for (int i = 0; i < 8; ++i) {\\n                bs.set(8 * i + 0, key[i] & 0x80);\\n                bs.set(8 * i + 1, key[i] & 0x40);\\n                bs.set(8 * i + 2, key[i] & 0x20);\\n                bs.set(8 * i + 3, key[i] & 0x10);\\n\\n                bs.set(8 * i + 4, key[i] & 0x08);\\n                bs.set(8 * i + 5, key[i] & 0x04);\\n                bs.set(8 * i + 6, key[i] & 0x02);\\n                bs.set(8 * i + 7, key[i] & 0x01);\\n            }\\n            return bs;\\n        }\\n\\n        template \\n        std::bitset toBitSet(const std::array& src) {\\n            std::bitset bs;\\n            for (int i = 0; i < N; ++i) {\\n                bs.set(8 * i + 0, src[i] & 0x80);\\n                bs.set(8 * i + 1, src[i] & 0x40);\\n                bs.set(8 * i + 2, src[i] & 0x20);\\n                bs.set(8 * i + 3, src[i] & 0x10);\\n\\n                bs.set(8 * i + 4, src[i] & 0x08);\\n                bs.set(8 * i + 5, src[i] & 0x04);\\n                bs.set(8 * i + 6, src[i] & 0x02);\\n                bs.set(8 * i + 7, src[i] & 0x01);\\n            }\\n            return bs;\\n        }\\n\\n        template \\n        std::array toArray(const std::bitset<N>& bs) {\\n            std::array arr;\\n            std::fill_n(arr.begin(), N / 8, 0);\\n            for (int i = 0; i < N / 8; ++i) {\\n                arr[i] |= (bs[8 * i + 0] << 7);\\n                arr[i] |= (bs[8 * i + 1] << 6);\\n                arr[i] |= (bs[8 * i + 2] << 5);\\n                arr[i] |= (bs[8 * i + 3] << 4);\\n\\n                arr[i] |= (bs[8 * i + 4] << 3);\\n                arr[i] |= (bs[8 * i + 5] << 2);\\n                arr[i] |= (bs[8 * i + 6] << 1);\\n                arr[i] |= (bs[8 * i + 7] << 0);\\n            }\\n            return arr;\\n        }\\n\\n        template \\n        std::bitset<N> shiftLeft(const std::bitset<N>& bs, int len, int times) {\\n            std::bitset<N> output;\\n            for (int i = 0; i < len; ++i) {\\n                output[i] = bs[i];\\n            }\\n            for (int t = 0; t < times; ++t) {\\n                int temp = output[0];\\n                for (int i = 1; i < len; ++i) {\\n                    output[i - 1] = output[i];\\n                }\\n                output[len - 1] = temp;\\n            }\\n            return output;\\n        }\\n\\n        std::array getSubKeys(const key_t& key) {\\n            std::array c;\\n            std::array d;\\n            std::bitset<56> kp;\\n\\n            auto k = toBitSet(key);\\n\\n            /* permute 'key' using table PC1 */\\n            for (int i = 0; i < 56; ++i) {\\n                kp[i] = k[PC1[i] - 1];\\n            }\\n\\n            /* split 'kp' in half and process the resulting series of 'c' and 'd' */\\n            for (int i = 0; i < 28; ++i) {\\n                c[0][i] = kp[i];\\n                d[0][i] = kp[i + 28];\\n            }\\n\\n            /* shift the components of c and d */\\n            for (int i = 1; i < 17; ++i) {\\n                c[i] = shiftLeft(c[i - 1], 28, SHIFTS[i - 1]);\\n                d[i] = shiftLeft(d[i - 1], 28, SHIFTS[i - 1]);\\n            }\\n\\n            /* merge 'd' into 'c' */\\n            for (int i = 1; i < 17; ++i) {\\n                for (int j = 28; j < 56; ++j) {\\n                    c[i][j] = d[i][j - 28];\\n                }\\n            }\\n\\n            /* form the sub-keys and store them in 'ks'\\n             * permute 'c' using table PC2 */\\n            std::array ks;\\n            for (int i = 1; i < 17; ++i) {\\n                for (int j = 0; j < 48; ++j) {\\n                    ks[i][j] = c[i][PC2[j] - 1];\\n                }\\n            }\\n\\n            return ks;\\n        }\\n\\n        std::bitset<32> f(const std::bitset<48>& ks, std::bitset<32>& r) {\\n            // permute 'r' using table E\\n            std::bitset<48> er;\\n            for (int i = 0; i < 48; ++i) {\\n                er[i] = r[E[i] - 1];\\n            }\\n\\n            // xor 'er' with 'ks' and store back into 'er'\\n            er ^= ks;\\n\\n            // process 'er' six bits at a time and store resulting four bits in 'sr'\\n            std::bitset<32> sr;\\n            for (int i = 0; i < 8; ++i) {\\n                int j = 6 * i;\\n                std::bitset<6> b;\\n                for (int k = 0; k < 6; ++k) {\\n                    b[k] = er[j + k] != 0;\\n                }\\n                int row = 2 * b[0] + b[5];\\n                int col = 8 * b[1] + 4 * b[2] + 2 * b[3] + b[4];\\n                int m = S[i][row * 16 + col];   // apply table s\\n                int n = 1;\\n                while (m > 0) {\\n                    int p = m % 2;\\n                    sr[(i + 1) * 4 - n] = (p == 1);\\n                    m /= 2;\\n                    n++;\\n                }\\n            }\\n\\n            // permute sr using table P\\n            std::bitset<32> sp;\\n            for (int i = 0; i < 32; ++i) {\\n                sp[i] = sr[P[i] - 1];\\n            }\\n            return sp;\\n        }\\n\\n        std::array processMessage(const std::array& ks, const std::array& message) {\\n            auto m = toBitSet(message);\\n\\n            // permute 'message' using table IP\\n            std::bitset<64> mp;\\n            for (int i = 0; i < 64; ++i) {\\n                mp[i] = m[IP[i] - 1];\\n            }\\n\\n            // split 'mp' in half and process the resulting series of 'l' and 'r\\n            std::array left;\\n            std::array right;\\n            for (int i = 0; i < 32; ++i) {\\n                left[0][i] = mp[i];\\n                right[0][i] = mp[i + 32];\\n            }\\n            for (int i = 1; i < 17; ++i) {\\n                left[i] = right[i - 1];\\n                auto fs = f(ks[i], right[i - 1]);\\n                left[i - 1] ^= fs;\\n                right[i] = left[i - 1];\\n            }\\n\\n            // amalgamate r[16] and l[16] (in that order) into 'e'\\n            std::bitset<64> e;\\n            for (int i = 0; i < 32; ++i) {\\n                e[i] = right[16][i];\\n            }\\n            for (int i = 32; i < 64; ++i) {\\n                e[i] = left[16][i - 32];\\n            }\\n\\n            // permute 'e' using table IP2 ad return result as a hex string\\n            std::bitset<64> ep;\\n            for (int i = 0; i < 64; ++i) {\\n                ep[i] = e[IP2[i] - 1];\\n            }\\n            return toArray(ep);\\n        }\\n    }\\n\\n    std::vector<ubyte> encrypt(const key_t& key, const std::vector<ubyte>& message) {\\n        auto ks = impl::getSubKeys(key);\\n        std::vector<ubyte> m(message);\\n\\n        // pad the message so there are 8 byte groups\\n        ubyte padByte = 8 - m.size() % 8;\\n        for (int i = 0; i < padByte; ++i) {\\n            m.push_back(padByte);\\n        }\\n\\n        std::vector<ubyte> sb;\\n        for (size_t i = 0; i < m.size(); i += 8) {\\n            std::array part;\\n            std::copy_n(m.begin() + i, 8, part.begin());\\n            part = impl::processMessage(ks, part);\\n            std::copy(part.begin(), part.end(), std::back_inserter(sb));\\n        }\\n\\n        return sb;\\n    }\\n\\n    std::vector<ubyte> decrypt(const key_t& key, const std::vector<ubyte>& encoded) {\\n        auto ks = impl::getSubKeys(key);\\n        // reverse the subkeys\\n        std::reverse(ks.begin() + 1, ks.end());\\n\\n        std::vector<ubyte> decoded;\\n        for (int i = 0; i < encoded.size(); i += 8) {\\n            std::array part;\\n            std::copy_n(encoded.begin() + i, 8, part.begin());\\n            part = impl::processMessage(ks, part);\\n            std::copy(part.begin(), part.end(), std::back_inserter(decoded));\\n        }\\n\\n        // remove the padding bytes from the decoded message\\n        auto padByte = decoded.back();\\n        decoded.resize(decoded.size() - padByte);\\n        return decoded;\\n    }\\n\\n    std::ostream& operator<<(std::ostream& os, const key_t& key) {\\n        os << std::setfill('0') << std::uppercase << std::hex;\\n        for (int i = 0; i < 8; ++i) {\\n            os << std::setw(2) << (int)key[i];\\n        }\\n        return os;\\n    }\\n\\n    std::ostream& operator<<(std::ostream& os, const std::vector<ubyte>& msg) {\\n        os << std::setfill('0') << std::uppercase << std::hex;\\n        for (auto b : msg) {\\n            os << std::setw(2) << (int)b;\\n        }\\n        return os;\\n    }\\n}\\n\\nint main() {\\n    using namespace std;\\n    using namespace DES;\\n\\n    key_t keys[] = {\\n        {0x13, 0x34, 0x57, 0x79, 0x9B, 0xBC, 0xDF, 0xF1},\\n        {0x0E, 0x32, 0x92, 0x32, 0xEA, 0x6D, 0x0D, 0x73},\\n        {0x0E, 0x32, 0x92, 0x32, 0xEA, 0x6D, 0x0D, 0x73}\\n    };\\n    vector messages = {\\n        {0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF},\\n        {0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87},\\n        {0x59, 0x6F, 0x75, 0x72, 0x20, 0x6C, 0x69, 0x70, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x73, 0x6D, 0x6F, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x76, 0x61, 0x73, 0x65, 0x6C, 0x69, 0x6E, 0x65, 0x0D, 0x0A}\\n    };\\n\\n    for (int i = 0; i < 3; ++i) {\\n        cout << \""Key     : \"" << keys[i] << '\\n';\\n        cout << \""Message : \"" << messages[i] << '\\n';\\n\\n        auto encoded = encrypt(keys[i], messages[i]);\\n        cout << \""Encoded : \"" << encoded << endl;\\n\\n        auto decoded = decrypt(keys[i], encoded);\\n        cout << \""Decoded : \"" << decoded << endl;\\n\\n        cout << '\\n';\\n    }\\n\\n    return 0;\\n}"
"C++","Date_format","\\nDisplay the   current date   in the formats of:\\n\\n","// Display the current date in the formats of \""2007-11-10\""\\n// and \""Sunday, November 10, 2007\"". \\n\\n#include <vector>\\n#include <string>\\n#include <iostream>\\n#include <ctime>\\n\\n/** Return the current date in a string, formatted as either ISO-8601\\n *  or \""Weekday-name, Month-name Day, Year\"".\\n *\\n *  The date is initialized when the object is created and will return\\n *  the same date for the lifetime of the object.  The date returned\\n *  is the date in the local timezone.\\n */\\nclass Date\\n{\\n    struct tm ltime;\\n\\npublic:\\n    /// Default constructor.\\n    Date()\\n    {\\n        time_t t = time(0);\\n        localtime_r(&t, &ltime);\\n    }\\n    \\n    /** Return the date based on a format string.  The format string is\\n     *  fed directly into strftime().  See the strftime() documentation\\n     *  for information on the proper construction of format strings.\\n     *\\n     *  @param[in] fmt is a valid strftime() format string.\\n     *\\n     *  @return a string containing the formatted date, or a blank string\\n     *      if the format string was invalid or resulted in a string that\\n     *      exceeded the internal buffer length.\\n     */\\n    std::string getDate(const char* fmt)\\n    {\\n        char out[200];\\n        size_t result = strftime(out, sizeof out, fmt, &ltime);\\n        return std::string(out, out + result);\\n    }\\n    \\n    /** Return the date in ISO-8601 date format.\\n     *\\n     *  @return a string containing the date in ISO-8601 date format.\\n     */\\n    std::string getISODate() {return getDate(\""%F\"");}\\n    \\n    /** Return the date formatted as \""Weekday-name, Month-name Day, Year\"".\\n     *\\n     *  @return a string containing the date in the specified format.\\n     */\\n    std::string getTextDate() {return getDate(\""%A, %B %d, %Y\"");}\\n};\\n\\nint main()\\n{\\n    Date d;\\n    std::cout << d.getISODate() << std::endl;\\n    std::cout << d.getTextDate() << std::endl;\\n    return 0;\\n}"
"C++","Day_of_the_week","A company decides that whenever Xmas falls on a Sunday they will give their workers all extra paid holidays so that, together with any public holidays, workers will not have to work the following week (between the 25th of December and the first of January).\\n\\nIn what years between 2008 and 2121 will the 25th of December be a Sunday?\\nUsing any standard date handling libraries of your programming language;\\ncompare the dates calculated with the output of other languages to discover any anomalies in the handling of dates which may be due to, for example, overflow in types used to represent dates/times similar to   y2k   type problems.\\n\\nThe program uses two ASSIST macro (XDECO,XPRNT) to keep the code as short as possible.\\n","#include \\n#include <iostream>\\n\\nint main( ) {\\n   using namespace boost::gregorian ;\\n\\n   std::cout\\n      << \""Yuletide holidays must be allowed in the following years:\\n\"" ;\\n   for ( int i = 2008 ; i < 2121 ; i++ ) {\\n      greg_year gy = i ;\\n      date d  ( gy, Dec , 25 ) ;\\n      if ( d.day_of_week( ) == Sunday ) {\\n	 std::cout << i << std::endl ;\\n      }\\n   }\\n   std::cout << \""\\n\"" ;\\n   return 0 ;\\n}"
"C++","Deal_cards_for_FreeCell","Free Cell is the solitaire card game that Paul Alfille introduced to the PLATO system in 1978. Jim Horne, at Microsoft, changed the name to FreeCell and reimplemented the game for DOS, then Windows. \\nThis version introduced 32000 numbered deals. (The FreeCell FAQ tells this history.)\\nAs the game became popular, Jim Horne disclosed the algorithm, and other implementations of FreeCell began to reproduce the Microsoft deals. \\nThese deals are numbered from 1 to 32000.\\nNewer versions from Microsoft have 1 million deals, numbered from 1 to 1000000; some implementations allow numbers outside that range.\\nThe algorithm uses this linear congruential generator from Microsoft C:\\n\\nThe algorithm follows:\\nDeals can also be checked against FreeCell solutions to 1000000 games.\\n(Summon a video solution, and it displays the initial deal.)\\nWrite a program to take a deal number and deal cards in the same order as this algorithm.\\nThe program may display the cards with ASCII, with Unicode, by drawing graphics, or any other way.\\n\\n","\\n#include <windows.h>\\n#include <iostream>\\n\\n//--------------------------------------------------------------------------------------------------\\nusing namespace std;\\n\\n//--------------------------------------------------------------------------------------------------\\nclass fc_dealer\\n{\\npublic:\\n    void deal( int game )\\n    {\\n	_gn = game;\\n	fillDeck();\\n	shuffle();\\n	display();\\n    }\\n\\nprivate:\\n    void fillDeck()\\n    {\\n	int p = 0;\\n	for( int c = 0; c < 13; c++ )\\n	    for( int s = 0; s < 4; s++ )\\n		_cards[p++] = c | s << 4;\\n    }\\n\\n    void shuffle()\\n    {\\n	srand( _gn );\\n	int cc = 52, nc, lc;\\n	while( cc )\\n	{\\n	    nc = rand() % cc;\\n	    lc = _cards[--cc];\\n	    _cards[cc] = _cards[nc];\\n	    _cards[nc] = lc;\\n	}\\n    }\\n\\n    void display()\\n    {\\n	char* suit = \""CDHS\"";\\n	char* symb = \""A23456789TJQK\"";\\n	int z = 0;\\n	cout << \""GAME #\"" << _gn << endl << \""=======================\"" << endl;\\n	for( int c = 51; c >= 0; c-- )\\n	{\\n	    cout << symb[_cards[c] & 15] << suit[_cards[c] >> 4] << \"" \"";\\n	    if( ++z >= 8 )\\n	    {\\n		cout << endl;\\n		z = 0;\\n	    }\\n	}\\n    }\\n\\n    int _cards[52], _gn;\\n};\\n//--------------------------------------------------------------------------------------------------\\nint main( int argc, char* argv[] )\\n{\\n    fc_dealer dealer;\\n    int gn;\\n    while( true )\\n    {\\n	cout << endl << \""Game number please ( 0 to QUIT ): \""; cin >> gn;\\n	if( !gn ) break;\\n\\n	system( \""cls\"" );\\n	dealer.deal( gn );\\n	cout << endl << endl;\\n    }\\n    return 0;\\n}\\n//--------------------------------------------------------------------------------------------------\\n"
"C++","Deal_cards_for_FreeCell","Free Cell is the solitaire card game that Paul Alfille introduced to the PLATO system in 1978. Jim Horne, at Microsoft, changed the name to FreeCell and reimplemented the game for DOS, then Windows. \\nThis version introduced 32000 numbered deals. (The FreeCell FAQ tells this history.)\\nAs the game became popular, Jim Horne disclosed the algorithm, and other implementations of FreeCell began to reproduce the Microsoft deals. \\nThese deals are numbered from 1 to 32000.\\nNewer versions from Microsoft have 1 million deals, numbered from 1 to 1000000; some implementations allow numbers outside that range.\\nThe algorithm uses this linear congruential generator from Microsoft C:\\n\\nThe algorithm follows:\\nDeals can also be checked against FreeCell solutions to 1000000 games.\\n(Summon a video solution, and it displays the initial deal.)\\nWrite a program to take a deal number and deal cards in the same order as this algorithm.\\nThe program may display the cards with ASCII, with Unicode, by drawing graphics, or any other way.\\n\\n","#include <string>       // std::string\\n#include <iostream>     // std::cout\\n#include <sstream>      // std::stringstream\\n#include <vector>       // std::vector\\n\\nusing namespace std;\\n\\n//------------------------------------------------------------------------------\\n\\nclass Random {\\npublic:\\n        void init(uint32_t seed) { _seed = seed; }\\n        int roll() { return (_seed = (_seed * MULT + INCR) & MASK) >> 16; }\\nprivate:\\n        int _seed;\\n        enum { MULT = 214013, INCR = 2531011, MASK = (1U << 31) - 1 };\\n};\\n\\n//------------------------------------------------------------------------------\\n\\nclass Card {\\npublic:\\n        Card(int value) : _value(value) { }\\n        int suit() const { return _value % 4; }\\n        int rank() const { return _value / 4; }\\n        string str() const {\\n                stringstream s; s << _ranks[rank()] << _suits[suit()]; return s.str();\\n        }\\nprivate:\\n        int _value;\\n        const char* _suits = \""CDHS\"";\\n        const char* _ranks = \""A23456789TJQK\"";\\n};\\n\\n//------------------------------------------------------------------------------\\n\\nclass Deck {\\npublic:\\n        Deck(int seed) {\\n                _random.init(seed);\\n                for (int i = 0; i < 52; i++)\\n                        _cards.push_back(Card(51 - i));\\n                for (int i = 0; i < 51; i++) {\\n                        int j = 51 - _random.roll() % (52 - i);\\n                        swap(_cards[i], _cards[j]);\\n                }\\n        }\\n        string str() const {\\n                stringstream s;\\n                for (int i = 0; i < _cards.size(); i++)\\n                        s << _cards[i].str() << (i % 8 == 7 || i == 51 ? \""\\n\"" : \"" \"");\\n                return s.str();\\n        }\\nprivate:\\n        vector<Card>    _cards;\\n        Random          _random;\\n};\\n\\n//------------------------------------------------------------------------------\\n\\nint main(int argc, const char * argv[])\\n{\\n        {\\n                Deck deck(1);\\n                cout << \""Deck 1\"" << endl << deck.str() << endl;\\n        }\\n        {\\n                Deck deck(617);\\n                cout << \""Deck 617\"" << endl << deck.str() << endl;\\n        }\\n        return 0;\\n}\\n"
"C++","Define_a_primitive_data_type","Demonstrate how to define a type that behaves like an integer but has a lowest valid value of 1 and a highest valid value of 10. Include all bounds checking you need to write, or explain how the compiler or interpreter creates those bounds checks for you.\\nThe compiler identifies the range of valid values from the range specification 1..10 and automatically builds in bounds checking where it is needed. The compiler is smart enough to omit bounds checking when it is not needed.\\nThe compiler will omit bounds checking for the assignment of A to B above because both values are of My_Type. A cannot hold a value outside the range of 1..10, therefore the assignment cannot produce an out of bounds result.\\nBounded data types are not part of standard ALGOL 68, but can be implemented.\\nOutput:\\nAs of February 2009 no open source libraries to do this task have been located.\\nThis class relies on implicit conversions to do most int operations; however the combined operations with assignment have to be coded explicitly.\\nUse proxy on java.lang.Number so it can be used in Clojure's math operations.\\n","#include <stdexcept>\\n\\nclass tiny_int\\n{\\npublic:\\n  tiny_int(int i):\\n    value(i)\\n  {\\n    if (value < 1)\\n      throw std::out_of_range(\""tiny_int: value smaller than 1\"");\\n    if (value > 10)\\n      throw std::out_of_range(\""tiny_int: value larger than 10\"");\\n  }\\n  operator int() const\\n  {\\n    return value;\\n  }\\n  tiny_int& operator+=(int i)\\n  {\\n    // by assigning to *this instead of directly modifying value, the\\n    // constructor is called and thus the check is enforced\\n    *this = value + i;\\n    return *this;\\n  }\\n  tiny_int& operator-=(int i)\\n  {\\n    *this = value - i;\\n    return *this;\\n  }\\n  tiny_int& operator*=(int i)\\n  {\\n    *this = value * i;\\n    return *this;\\n  }\\n  tiny_int& operator/=(int i)\\n  {\\n    *this = value / i;\\n    return *this;\\n  }\\n  tiny_int& operator<<=(int i)\\n  {\\n    *this = value << i;\\n    return *this;\\n  }\\n  tiny_int& operator>>=(int i)\\n  {\\n    *this = value >> i;\\n    return *this;\\n  }\\n  tiny_int& operator&=(int i)\\n  {\\n    *this = value & i;\\n    return *this;\\n  }\\n  tiny_int& operator|=(int i)\\n  {\\n    *this = value | i;\\n    return *this;\\n  }\\nprivate:\\n  unsigned char value; // we don't need more space\\n};"
"C++","Delegates","A delegate is a helper object used by another object. The delegator may send the delegate certain messages, and provide a default implementation when there is no delegate or the delegate does not respond to a message. This pattern is heavily used in Cocoa framework on Mac OS X. See also wp:Delegation pattern.\\nObjects responsibilities:\\nDelegator:\\nDelegate:\\nShow how objects are created and used. First, without a delegate, then with a delegate that does not implement \""thing\"", and last with a delegate that implements \""thing\"".\\nAll that is needed in order to implement this is a common base type. The delegator holds a pointer to an \""untyped\"" object from the base class. Querying if the target implements the delegate interface is done using run-time type identification.\\nSample output:\\nAs Algol 68 doesn't have classes, we supply a non-OO approximation, similar to the C version.\\n","\\n#include \\n#include <string>\\n#include <iostream>\\n#include \\n\\nusing namespace std;\\nusing namespace std::tr1;\\nusing std::tr1::function;\\n\\n// interface for all delegates\\nclass IDelegate\\n{\\npublic:\\n    virtual ~IDelegate() {}\\n};\\n\\n//interface for delegates supporting thing \\nclass IThing\\n{\\npublic:\\n    virtual ~IThing() {}\\n    virtual std::string Thing() = 0;\\n};\\n\\n// Does not handle Thing\\nclass DelegateA : virtual public IDelegate\\n{\\n};\\n \\n// Handles Thing\\nclass DelegateB : public IThing, public IDelegate\\n{\\n    std::string Thing()\\n    {\\n        return \""delegate implementation\"";\\n    }\\n};\\n \\nclass Delegator\\n{\\npublic:\\n    std::string Operation()\\n    {\\n        if(Delegate) //have delegate\\n           if (IThing * pThing = dynamic_cast(Delegate.get()))\\n            //delegate provides IThing interface\\n            return pThing->Thing();\\n        \\n        return \""default implementation\"";\\n    }\\n \\n    shared_ptr<IDelegate> Delegate;\\n};\\n \\nint main()\\n{\\n    shared_ptr<DelegateA> delegateA(new DelegateA());\\n    shared_ptr<DelegateB> delegateB(new DelegateB());\\n    Delegator delegator;\\n \\n    // No delegate\\n    std::cout << delegator.Operation() << std::endl;\\n \\n    // Delegate doesn't handle \""Thing\""\\n    delegator.Delegate = delegateA;\\n    std::cout << delegator.Operation() << std::endl;\\n \\n    // Delegate handles \""Thing\""\\n    delegator.Delegate = delegateB;\\n    std::cout << delegator.Operation() << std::endl;\\n\\n/*\\nPrints:\\n\\n  default implementation\\n  default implementation\\n  delegate implementation\\n */\\n}\\n"
"C++","Delete_a_file","Delete a file called \""input.txt\"" and delete a directory called \""docs\"".\\nThis should be done twice: once \""here\"", i.e. in the current working directory and once in the filesystem root.\\n\\nThe 'drop' removes the result (true or false, indicating success or failure). It is not strictly necessary to do so, but it keeps the stack clean.\\nand then\\nNaming conventions for the file path are OS-specific. The language does not specify the encoding of the file paths, the directory separators or brackets, the file extension delimiter, the file version delimiter and syntax. The example provided works under Linux and Windows.\\nThe remove function removes either a file or a directory (the directory must be empty for this to work). Exception is thrown if this fails.\\nNote: scratch does not appear to do anything on ALGOL 68G. Also note that file names are Operating System dependent.\\nSource: DeleteFile @github by jNizM\\nAssuming we are on a Unix/Linux or at least Cygwin system:\\nSome versions of Qbasic may have had a builtin RMDIR command. However this is not documented in the manual, so we use the external MSDOS command in this example.\\nBaCon has a DELETE instruction, that accepts FILE|DIRECTORY|RECURSIVE options.\\nErrors can be caught with the CATCH GOTO label instruction (which allows RESUME from the labelled code section).\\nThe ZX Spectrum microdrive had only a main directory, and filenames did not have\\nfile extensions. Here we delete the file named INPUTTXT from the first microdrive:\\nAnd for disc drive of ZX Spectrum +3:\\nIf the names are known as constants at compile time:\\nIf the names are known only at run time:\\nISO C:\\nPOSIX:\\nTo delete files or directories in COBOL we need to use unofficial extensions. The following are built-in subroutines originally created as part of some of the COBOL products created by Micro Focus.\\nAlternate method of deleting files using the DELETE FILE statement.\\nTo delete directories we need an implementation specific extension. In clisp this is ext:delete-dir.\\nOr you can use the portability library CL-FAD:\\nPOSIX:\\nELENA 3.4 :\\nThere is no means to delete directories in ANS Forth.\\nI don't know a way of deleting directories in Fortran\\nOn most *nix systems, this must be run as sudo for the files in root to be deleted. If you don't have permissions, it will silently fail to delete those files. I would recommend against running anything you find on the internet as sudo.\\nor\\nIcon supports 'remove' for files.\\nNote Icon and Unicon accept both / and \\ for directory separators.\\nThe J standard library comes with a set of file access utilities.\\nThe function above actually uses a foreign conjunction and defined in the files library like so:\\nThis means that you can directly erase files and directories without loading the files library.\\nor\\nSynchronous\\nAsynchronous\\n","#include <cstdio>\\n#include <direct.h>\\n\\nint main() {\\n	remove( \""input.txt\"" );\\n	remove( \""/input.txt\"" );\\n	_rmdir( \""docs\"" );\\n	_rmdir( \""/docs\"" );\\n\\n	return 0;\\n}"
"C++","Department_Numbers","There is a highly organized city that has decided to assign a number to each of their departments:\\n\\nEach department can have a number between 1 and 7   (inclusive).\\nThe three department numbers are to be unique (different from each other) and must add up to the number 12.\\nThe Chief of the Police doesn't like odd numbers and wants to have an even number for his department.\\n\\nWrite a program which outputs all valid combinations.\\n\\nPossible output:\\n1 2 9 \\n5 3 4\\n\\nAs noted in the Fortran sample, once the police and sanitation departments are posited, the fire department value is fixed\\n","\\n#include <iostream>\\n#include <iomanip>\\n\\nint main( int argc, char* argv[] ) {\\n    int sol = 1;\\n    std::cout << \""\\t\\tFIRE\\t\\tPOLICE\\t\\tSANITATION\\n\"";\\n    for( int f = 1; f < 8; f++ ) {\\n        for( int p = 1; p < 8; p++ ) {\\n            for( int s = 1; s < 8; s++ ) {\\n                if( f != p && f != s && p != s && !( p & 1 ) && ( f + s + p == 12 ) ) {\\n                std::cout << \""SOLUTION #\"" << std::setw( 2 ) << sol++ << std::setw( 2 ) \\n                << \"":\\t\"" << std::setw( 2 ) << f << \""\\t\\t \"" << std::setw( 3 ) << p \\n                << \""\\t\\t\"" << std::setw( 6 ) << s << \""\\n\"";\\n                }\\n            }\\n        }\\n    }\\n    return 0;\\n}"
"C++","Detect_division_by_zero","Write a function to detect a   divide by zero error   without checking if the denominator is zero.\\n\\nDivision by zero results in the value \""Inf\"":\\n","\\n#include<iostream>\\n#include<csignal> /* for signal */\\n#include<cstdlib>\\n\\nusing namespace std;\\n\\nvoid fpe_handler(int signal)\\n{\\n    cerr << \""Floating Point Exception: division by zero\"" << endl;\\n    exit(signal);\\n}\\n\\nint main()\\n{\\n    // Register floating-point exception handler.\\n    signal(SIGFPE, fpe_handler);\\n\\n    int a = 1;\\n    int b = 0;\\n    cout << a/b << endl;\\n\\n    return 0;\\n}\\n"
"C++","Determine_if_a_string_is_numeric","Create a boolean function which takes in a string and tells whether it is a numeric string (floating point and negative numbers included) in the syntax the language uses for numeric literals or numbers converted from strings.\\n\\nThe first file is the package interface containing the declaration of the Is_Numeric function.\\nThe second file is the package body containing the implementation of the Is_Numeric function.\\nThe last file shows how the Is_Numeric function can be called.\\n","#include <sstream> // for istringstream\\n\\nusing namespace std;\\n\\nbool isNumeric( const char* pszInput, int nNumberBase )\\n{\\n	istringstream iss( pszInput );\\n\\n	if ( nNumberBase == 10 )\\n	{\\n		double dTestSink;\\n		iss >> dTestSink;\\n	}\\n	else if ( nNumberBase == 8 || nNumberBase == 16 )\\n	{\\n		int nTestSink;\\n		iss >> ( ( nNumberBase == 8 ) ? oct : hex ) >> nTestSink;\\n	}\\n	else\\n		return false;\\n\\n	// was any input successfully consumed/converted?\\n	if ( ! iss )\\n		return false;\\n\\n	// was all the input successfully consumed/converted?\\n	return ( iss.rdbuf()->in_avail() == 0 );\\n}\\n"
"C++","Determine_if_a_string_is_numeric","Create a boolean function which takes in a string and tells whether it is a numeric string (floating point and negative numbers included) in the syntax the language uses for numeric literals or numbers converted from strings.\\n\\nThe first file is the package interface containing the declaration of the Is_Numeric function.\\nThe second file is the package body containing the implementation of the Is_Numeric function.\\nThe last file shows how the Is_Numeric function can be called.\\n","\\nbool isNumeric( const char* pszInput, int nNumberBase )\\n{\\n	string base = \""0123456789ABCDEF\"";\\n	string input = pszInput;\\n\\n	return (input.find_first_not_of(base.substr(0, nNumberBase)) == string::npos);\\n}\\n"
"C++","Determine_if_a_string_is_numeric","Create a boolean function which takes in a string and tells whether it is a numeric string (floating point and negative numbers included) in the syntax the language uses for numeric literals or numbers converted from strings.\\n\\nThe first file is the package interface containing the declaration of the Is_Numeric function.\\nThe second file is the package body containing the implementation of the Is_Numeric function.\\nThe last file shows how the Is_Numeric function can be called.\\n","\\nbool isNumeric(const std::string& input) {\\n    return std::all_of(input.begin(), input.end(), ::isdigit);\\n}\\n"
"C++","Determine_if_only_one_instance_is_running","This task is to determine if there is only one instance of an application running. If the program discovers that an instance of it is already running, then it should display a message indicating that it is already running and exit.\\nThe following solution tries to open a file for reading. If the file does not exist, a 'Name_Error' is raised. The exception handler creates that file, allows the program to perform its task, and, eventually, makes sure the file is deleted. If no exception is raised, the file exists, so another instance is running, and the program stops. It also stops if the wrong exception is raised, i.e., any exception other than 'Name_Error'.\\nNote that there is a race condition: If another instance tries to open the file for reading, before the first one has created it, then more than one instance will actually run.\\nAutoHotkey has a #SingleInstance command. If you run two scripts that don't have it at the same time, it alerts the user. #SingleInstance FORCE closes the older instance when a newer one is run, and #SingleInstance IGNORE does nothing when you try to open a new instance of an already-running script.\\nChange 'UniqueLockName' to something more likely to be unique, such as a GUID.\\nThis solution opens ~/rosetta-code-lock and uses fcntl() to set a write lock on the file. Only one instance can set this lock. If fcntl() fails, this program assumes that another instance is running. This program always clears its lock when it terminates.\\nThe user might use an interrupt or other signal to terminate the program. If so, the lock file survives, but the system still clears the lock. The user can run the program again.\\nNote that the underlying file system needs to support file locking; for example if ~/ directory is on a NFS mounted partition, success in a locking fcntl() call is not always meaningful.\\nThis solution opens a file with O_CREAT|O_EXCL. If the file already exists, this program assumes that another instance is running. This solution is not as good as file locking, because the program might terminate without deleting the file.\\nThe program, when terminating, must be sure to unlink() the file. This example has unlink() at two places: at the end of main(), and at a SIGINT handler. If you interrupt the program, it will probably delete /tmp/MyUniqueName, but not if SIGINT wins a race before the program installs its handler. If you terminate the program with a different signal, then you will get stuck, because /tmp/MyUniqueName will still exist, preventing another execution of the program. One might add code to catch some other signals, but there is no way to catch SIGKILL!\\nThis program uses a regular file, with open() and unlink(). There is an older version that uses a semaphore, with sem_open() and sem_unlink(). The switch from a semaphore to a regular file was easy, because the program never used the semaphore as a semaphore; it only checked the existence of a semaphore. If you get stuck, rm /tmp/MyUniqueName might be easier than deleting a semaphore.\\nThis line needs to be near the top of the file (or in stdafx.h, if you use one.)\\nYou need a variable of type HANDLE with the same lifetime as your program. Perhaps as a member of your CWinApp object.\\nAt the earliest possible point in your program, you need to initialize it and perform your check. \""MyApp\"" should be a string unique to your application. See here for full details.\\nFinally, near the end of your program, you need to close the mutex.\\nFrom the Erlang shell, or in a program, register the application process. If this works, the process is the only one.\\n","#include <afx.h>"
"C++","Determine_if_only_one_instance_is_running","This task is to determine if there is only one instance of an application running. If the program discovers that an instance of it is already running, then it should display a message indicating that it is already running and exit.\\nThe following solution tries to open a file for reading. If the file does not exist, a 'Name_Error' is raised. The exception handler creates that file, allows the program to perform its task, and, eventually, makes sure the file is deleted. If no exception is raised, the file exists, so another instance is running, and the program stops. It also stops if the wrong exception is raised, i.e., any exception other than 'Name_Error'.\\nNote that there is a race condition: If another instance tries to open the file for reading, before the first one has created it, then more than one instance will actually run.\\nAutoHotkey has a #SingleInstance command. If you run two scripts that don't have it at the same time, it alerts the user. #SingleInstance FORCE closes the older instance when a newer one is run, and #SingleInstance IGNORE does nothing when you try to open a new instance of an already-running script.\\nChange 'UniqueLockName' to something more likely to be unique, such as a GUID.\\nThis solution opens ~/rosetta-code-lock and uses fcntl() to set a write lock on the file. Only one instance can set this lock. If fcntl() fails, this program assumes that another instance is running. This program always clears its lock when it terminates.\\nThe user might use an interrupt or other signal to terminate the program. If so, the lock file survives, but the system still clears the lock. The user can run the program again.\\nNote that the underlying file system needs to support file locking; for example if ~/ directory is on a NFS mounted partition, success in a locking fcntl() call is not always meaningful.\\nThis solution opens a file with O_CREAT|O_EXCL. If the file already exists, this program assumes that another instance is running. This solution is not as good as file locking, because the program might terminate without deleting the file.\\nThe program, when terminating, must be sure to unlink() the file. This example has unlink() at two places: at the end of main(), and at a SIGINT handler. If you interrupt the program, it will probably delete /tmp/MyUniqueName, but not if SIGINT wins a race before the program installs its handler. If you terminate the program with a different signal, then you will get stuck, because /tmp/MyUniqueName will still exist, preventing another execution of the program. One might add code to catch some other signals, but there is no way to catch SIGKILL!\\nThis program uses a regular file, with open() and unlink(). There is an older version that uses a semaphore, with sem_open() and sem_unlink(). The switch from a semaphore to a regular file was easy, because the program never used the semaphore as a semaphore; it only checked the existence of a semaphore. If you get stuck, rm /tmp/MyUniqueName might be easier than deleting a semaphore.\\nThis line needs to be near the top of the file (or in stdafx.h, if you use one.)\\nYou need a variable of type HANDLE with the same lifetime as your program. Perhaps as a member of your CWinApp object.\\nAt the earliest possible point in your program, you need to initialize it and perform your check. \""MyApp\"" should be a string unique to your application. See here for full details.\\nFinally, near the end of your program, you need to close the mutex.\\nFrom the Erlang shell, or in a program, register the application process. If this works, the process is the only one.\\n","HANDLE mutex;"
"C++","Determine_if_only_one_instance_is_running","This task is to determine if there is only one instance of an application running. If the program discovers that an instance of it is already running, then it should display a message indicating that it is already running and exit.\\nThe following solution tries to open a file for reading. If the file does not exist, a 'Name_Error' is raised. The exception handler creates that file, allows the program to perform its task, and, eventually, makes sure the file is deleted. If no exception is raised, the file exists, so another instance is running, and the program stops. It also stops if the wrong exception is raised, i.e., any exception other than 'Name_Error'.\\nNote that there is a race condition: If another instance tries to open the file for reading, before the first one has created it, then more than one instance will actually run.\\nAutoHotkey has a #SingleInstance command. If you run two scripts that don't have it at the same time, it alerts the user. #SingleInstance FORCE closes the older instance when a newer one is run, and #SingleInstance IGNORE does nothing when you try to open a new instance of an already-running script.\\nChange 'UniqueLockName' to something more likely to be unique, such as a GUID.\\nThis solution opens ~/rosetta-code-lock and uses fcntl() to set a write lock on the file. Only one instance can set this lock. If fcntl() fails, this program assumes that another instance is running. This program always clears its lock when it terminates.\\nThe user might use an interrupt or other signal to terminate the program. If so, the lock file survives, but the system still clears the lock. The user can run the program again.\\nNote that the underlying file system needs to support file locking; for example if ~/ directory is on a NFS mounted partition, success in a locking fcntl() call is not always meaningful.\\nThis solution opens a file with O_CREAT|O_EXCL. If the file already exists, this program assumes that another instance is running. This solution is not as good as file locking, because the program might terminate without deleting the file.\\nThe program, when terminating, must be sure to unlink() the file. This example has unlink() at two places: at the end of main(), and at a SIGINT handler. If you interrupt the program, it will probably delete /tmp/MyUniqueName, but not if SIGINT wins a race before the program installs its handler. If you terminate the program with a different signal, then you will get stuck, because /tmp/MyUniqueName will still exist, preventing another execution of the program. One might add code to catch some other signals, but there is no way to catch SIGKILL!\\nThis program uses a regular file, with open() and unlink(). There is an older version that uses a semaphore, with sem_open() and sem_unlink(). The switch from a semaphore to a regular file was easy, because the program never used the semaphore as a semaphore; it only checked the existence of a semaphore. If you get stuck, rm /tmp/MyUniqueName might be easier than deleting a semaphore.\\nThis line needs to be near the top of the file (or in stdafx.h, if you use one.)\\nYou need a variable of type HANDLE with the same lifetime as your program. Perhaps as a member of your CWinApp object.\\nAt the earliest possible point in your program, you need to initialize it and perform your check. \""MyApp\"" should be a string unique to your application. See here for full details.\\nFinally, near the end of your program, you need to close the mutex.\\nFrom the Erlang shell, or in a program, register the application process. If this works, the process is the only one.\\n","mutex = CreateMutex( NULL, TRUE, \""MyApp\"" );\\nif ( GetLastError() == ERROR_ALREADY_EXISTS )\\n{\\n     // There's another instance running.  What do you do?\\n}"
"C++","Determine_if_only_one_instance_is_running","This task is to determine if there is only one instance of an application running. If the program discovers that an instance of it is already running, then it should display a message indicating that it is already running and exit.\\nThe following solution tries to open a file for reading. If the file does not exist, a 'Name_Error' is raised. The exception handler creates that file, allows the program to perform its task, and, eventually, makes sure the file is deleted. If no exception is raised, the file exists, so another instance is running, and the program stops. It also stops if the wrong exception is raised, i.e., any exception other than 'Name_Error'.\\nNote that there is a race condition: If another instance tries to open the file for reading, before the first one has created it, then more than one instance will actually run.\\nAutoHotkey has a #SingleInstance command. If you run two scripts that don't have it at the same time, it alerts the user. #SingleInstance FORCE closes the older instance when a newer one is run, and #SingleInstance IGNORE does nothing when you try to open a new instance of an already-running script.\\nChange 'UniqueLockName' to something more likely to be unique, such as a GUID.\\nThis solution opens ~/rosetta-code-lock and uses fcntl() to set a write lock on the file. Only one instance can set this lock. If fcntl() fails, this program assumes that another instance is running. This program always clears its lock when it terminates.\\nThe user might use an interrupt or other signal to terminate the program. If so, the lock file survives, but the system still clears the lock. The user can run the program again.\\nNote that the underlying file system needs to support file locking; for example if ~/ directory is on a NFS mounted partition, success in a locking fcntl() call is not always meaningful.\\nThis solution opens a file with O_CREAT|O_EXCL. If the file already exists, this program assumes that another instance is running. This solution is not as good as file locking, because the program might terminate without deleting the file.\\nThe program, when terminating, must be sure to unlink() the file. This example has unlink() at two places: at the end of main(), and at a SIGINT handler. If you interrupt the program, it will probably delete /tmp/MyUniqueName, but not if SIGINT wins a race before the program installs its handler. If you terminate the program with a different signal, then you will get stuck, because /tmp/MyUniqueName will still exist, preventing another execution of the program. One might add code to catch some other signals, but there is no way to catch SIGKILL!\\nThis program uses a regular file, with open() and unlink(). There is an older version that uses a semaphore, with sem_open() and sem_unlink(). The switch from a semaphore to a regular file was easy, because the program never used the semaphore as a semaphore; it only checked the existence of a semaphore. If you get stuck, rm /tmp/MyUniqueName might be easier than deleting a semaphore.\\nThis line needs to be near the top of the file (or in stdafx.h, if you use one.)\\nYou need a variable of type HANDLE with the same lifetime as your program. Perhaps as a member of your CWinApp object.\\nAt the earliest possible point in your program, you need to initialize it and perform your check. \""MyApp\"" should be a string unique to your application. See here for full details.\\nFinally, near the end of your program, you need to close the mutex.\\nFrom the Erlang shell, or in a program, register the application process. If this works, the process is the only one.\\n","CloseHandle( mutex );"
"C++","Determine_if_two_triangles_overlap","Determine which of these pairs of triangles overlap in 2D:\\nOptionally, see what the result is when only a single corner is in contact (there is no definitively correct answer):\\n","#include <vector>\\n#include <iostream>\\n#include <stdexcept>\\nusing namespace std;\\n\\ntypedef std::pair TriPoint;\\n\\ninline double Det2D(TriPoint &p1, TriPoint &p2, TriPoint &p3) \\n{\\n	return +p1.first*(p2.second-p3.second)\\n		+p2.first*(p3.second-p1.second)\\n		+p3.first*(p1.second-p2.second);\\n}\\n\\nvoid CheckTriWinding(TriPoint &p1, TriPoint &p2, TriPoint &p3, bool allowReversed)\\n{\\n	double detTri = Det2D(p1, p2, p3);\\n	if(detTri < 0.0)\\n	{\\n		if (allowReversed)\\n		{\\n			TriPoint a = p3;\\n			p3 = p2;\\n			p2 = a;\\n		}\\n		else throw std::runtime_error(\""triangle has wrong winding direction\"");\\n	}\\n}\\n\\nbool BoundaryCollideChk(TriPoint &p1, TriPoint &p2, TriPoint &p3, double eps)\\n{\\n	return Det2D(p1, p2, p3) < eps;\\n}\\n\\nbool BoundaryDoesntCollideChk(TriPoint &p1, TriPoint &p2, TriPoint &p3, double eps)\\n{\\n	return Det2D(p1, p2, p3) <= eps;\\n}\\n\\nbool TriTri2D(TriPoint *t1,\\n	TriPoint *t2,\\n	double eps = 0.0, bool allowReversed = false, bool onBoundary = true)\\n{\\n	//Trangles must be expressed anti-clockwise\\n	CheckTriWinding(t1[0], t1[1], t1[2], allowReversed);\\n	CheckTriWinding(t2[0], t2[1], t2[2], allowReversed);\\n\\n	bool (*chkEdge)(TriPoint &, TriPoint &, TriPoint &, double) = NULL;\\n	if(onBoundary) //Points on the boundary are considered as colliding\\n		chkEdge = BoundaryCollideChk;\\n	else //Points on the boundary are not considered as colliding\\n		chkEdge = BoundaryDoesntCollideChk;\\n\\n	//For edge E of trangle 1,\\n	for(int i=0; i<3; i++)\\n	{\\n		int j=(i+1)%3;\\n\\n		//Check all points of trangle 2 lay on the external side of the edge E. If\\n		//they do, the triangles do not collide.\\n		if (chkEdge(t1[i], t1[j], t2[0], eps) &&\\n			chkEdge(t1[i], t1[j], t2[1], eps) &&\\n			chkEdge(t1[i], t1[j], t2[2], eps))\\n			return false;\\n	}\\n\\n	//For edge E of trangle 2,\\n	for(int i=0; i<3; i++)\\n	{\\n		int j=(i+1)%3;\\n\\n		//Check all points of trangle 1 lay on the external side of the edge E. If\\n		//they do, the triangles do not collide.\\n		if (chkEdge(t2[i], t2[j], t1[0], eps) &&\\n			chkEdge(t2[i], t2[j], t1[1], eps) &&\\n			chkEdge(t2[i], t2[j], t1[2], eps))\\n			return false;\\n	}\\n\\n	//The triangles collide\\n	return true;\\n}\\n\\nint main()\\n{\\n	{TriPoint t1[] = {TriPoint(0,0),TriPoint(5,0),TriPoint(0,5)};\\n	TriPoint t2[] = {TriPoint(0,0),TriPoint(5,0),TriPoint(0,6)};\\n	cout << TriTri2D(t1, t2) << \"",\"" << true << endl;}\\n\\n	{TriPoint t1[] = {TriPoint(0,0),TriPoint(0,5),TriPoint(5,0)};\\n	TriPoint t2[] = {TriPoint(0,0),TriPoint(0,5),TriPoint(5,0)};\\n	cout << TriTri2D(t1, t2, 0.0, true) << \"",\"" << true << endl;}\\n\\n	{TriPoint t1[] = {TriPoint(0,0),TriPoint(5,0),TriPoint(0,5)};\\n	TriPoint t2[] = {TriPoint(-10,0),TriPoint(-5,0),TriPoint(-1,6)};\\n	cout << TriTri2D(t1, t2) << \"",\"" << false << endl;}\\n\\n	{TriPoint t1[] = {TriPoint(0,0),TriPoint(5,0),TriPoint(2.5,5)};\\n	TriPoint t2[] = {TriPoint(0,4),TriPoint(2.5,-1),TriPoint(5,4)};\\n	cout << TriTri2D(t1, t2) << \"",\"" << true << endl;}\\n\\n	{TriPoint t1[] = {TriPoint(0,0),TriPoint(1,1),TriPoint(0,2)};\\n	TriPoint t2[] = {TriPoint(2,1),TriPoint(3,0),TriPoint(3,2)};\\n	cout << TriTri2D(t1, t2) << \"",\"" << false << endl;}\\n\\n	{TriPoint t1[] = {TriPoint(0,0),TriPoint(1,1),TriPoint(0,2)};\\n	TriPoint t2[] = {TriPoint(2,1),TriPoint(3,-2),TriPoint(3,4)};\\n	cout << TriTri2D(t1, t2) << \"",\"" << false << endl;}\\n\\n	//Barely touching\\n	{TriPoint t1[] = {TriPoint(0,0),TriPoint(1,0),TriPoint(0,1)};\\n	TriPoint t2[] = {TriPoint(1,0),TriPoint(2,0),TriPoint(1,1)};\\n	cout << TriTri2D(t1, t2, 0.0, false, true) << \"",\"" << true << endl;}\\n\\n	//Barely touching\\n	{TriPoint t1[] = {TriPoint(0,0),TriPoint(1,0),TriPoint(0,1)};\\n	TriPoint t2[] = {TriPoint(1,0),TriPoint(2,0),TriPoint(1,1)};\\n	cout << TriTri2D(t1, t2, 0.0, false, false) << \"",\"" << false << endl;}\\n\\n}"
"C++","Digital_root","The digital root, \\n\\n\\n\\nX\\n\\n\\n{\\displaystyle X}\\n\\n, of a number, \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n, is calculated:\\nThe additive persistence is the number of summations required to obtain the single digit.\\nThe task is to calculate the additive persistence and the digital root of a number, e.g.:\\nThe digital root may be calculated in bases other than 10.\\n\\n\\n","// Calculate the Digital Root and Additive Persistance of an Integer - Compiles with gcc4.7\\n//\\n// Nigel Galloway. July 23rd., 2012\\n//\\n#include <iostream>\\n#include <cmath>\\n#include <utility>\\n\\ntemplate P_ IncFirst(const P_& src) {return P_(src.first + 1, src.second);}\\n\\nstd::pair DigitalRoot(unsigned long long digits, int base = 10) \\n{\\n    int x = SumDigits(digits, base);\\n    return x < base ? std::make_pair(1, x) : IncFirst(DigitalRoot(x, base));  // x is implicitly converted to unsigned long long; this is lossless\\n}\\n\\nint main() {\\n    const unsigned long long ip[] = {961038,923594037444,670033,448944221089};\\n    for (auto i:ip){\\n        auto res = DigitalRoot(i);\\n        std::cout << i << \"" has digital root \"" << res.second << \"" and additive persistance \"" << res.first << \""\\n\"";\\n    }\\n    std::cout << \""\\n\"";\\n    const unsigned long long hip[] = {0x7e0,0x14e344,0xd60141,0x12343210};\\n    for (auto i:hip){\\n        auto res = DigitalRoot(i,16);\\n        std::cout << std::hex << i << \"" has digital root \"" << res.second << \"" and additive persistance \"" << res.first << \""\\n\"";\\n    }\\n    return 0;\\n}"
"C++","Digital_root/Multiplicative_digital_root","The multiplicative digital root (MDR) and multiplicative persistence (MP) of a number, \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n, is calculated rather like the Digital root except digits are multiplied instead of being added:\\n\\nShow all output on this page.\\n\\n\\nThe solution uses the Package \""Generic_Root\"" from the additive digital roots [[1]].\\n","\\n#include <iomanip>\\n#include <map>\\n#include <vector>\\n#include <iostream>\\nusing namespace std;\\n\\nvoid calcMDR( int n, int c, int& a, int& b )\\n{\\n    int m = n % 10; n /= 10;\\n    while( n )\\n    {\\n	m *= ( n % 10 );\\n	n /= 10;\\n    }\\n    if( m >= 10 ) calcMDR( m, ++c, a, b );\\n    else { a = m; b = c; }\\n}\\n\\nvoid table()\\n{\\n    map mp;\\n    int n = 0, a, b;\\n    bool f = true;\\n    while( f )\\n    {\\n	f = false;\\n	calcMDR( n, 1, a, b );\\n	mp[a].push_back( n );\\n	n++;\\n	for( int x = 0; x < 10; x++ )\\n	    if( mp[x].size() < 5 )\\n	    { f = true; break; }\\n    }\\n\\n    cout << \""|  MDR  |  [n0..n4]\\n+-------+------------------------------------+\\n\"";\\n    for( int x = 0; x < 10; x++ )\\n    {\\n	cout << right << \""| \"" << setw( 6 ) << x << \""| \"";\\n	for( vector<int>::iterator i = mp[x].begin(); i != mp[x].begin() + 5; i++ )\\n	    cout << setw( 6 ) << *i << \"" \"";\\n	cout << \""|\\n\"";\\n    }\\n    cout << \""+-------+------------------------------------+\\n\\n\"";\\n}\\n\\nint main( int argc, char* argv[] )\\n{\\n    cout << \""|  NUMBER  |   MDR    |    MP    |\\n+----------+----------+----------+\\n\"";\\n    int numbers[] = { 123321, 7739, 893, 899998 }, a, b;\\n    for( int x = 0; x < 4; x++ )\\n    {\\n	cout << right << \""| \""  << setw( 9 ) << numbers[x] << \""| \"";\\n	calcMDR( numbers[x], 1, a, b );\\n	cout << setw( 9 ) << a  << \""| \"" << setw( 9 ) << b << \""|\\n\"";\\n    }\\n    cout << \""+----------+----------+----------+\\n\\n\"";\\n    table();\\n    return system( \""pause\"" );\\n}\\n"
"C++","Dijkstra's_algorithm","\\nDijkstra's algorithm, conceived by Dutch computer scientist Edsger Dijkstra in 1956 and published in 1959, is a graph search algorithm that solves the single-source shortest path problem for a graph with non-negative edge path costs, producing a shortest path tree.\\nThis algorithm is often used in routing and as a subroutine in other graph algorithms.\\n\\nFor a given source vertex (node) in the graph, the algorithm finds the path with lowest cost (i.e. the shortest path) between that vertex and every other vertex.\\n\\nIf the vertices of the graph represent cities and edge path costs represent driving distances between pairs of cities connected by a direct road, Dijkstra's algorithm can be used to find the shortest route between one city and all other cities.\\nAs a result, the shortest path first is widely used in network routing protocols, most notably:\\n\\nThe inputs to Dijkstra's algorithm are a directed and weighted graph consisting of 2 or more nodes, generally represented by:\\nA destination node is not specified.\\nThe output is a set of edges depicting the shortest path to each destination node.\\n\\n\\nYou can use numbers or names to identify vertices in your program.\\n\\n\\nThis solution uses a generic package and Ada 2012 (containers, extended return statements, expression functions).\\nThe very convenient 'Img attribute is a GNAT feature.\\nThe testing main procedure :\\n","#include <iostream>\\n#include <vector>\\n#include <string>\\n#include <list>\\n\\n#include <limits> // for numeric_limits\\n\\n#include <set>\\n#include <utility> // for pair\\n#include <algorithm>\\n#include <iterator>\\n\\n\\ntypedef int vertex_t;\\ntypedef double weight_t;\\n\\nconst weight_t max_weight = std::numeric_limits<double>::infinity();\\n\\nstruct neighbor {\\n    vertex_t target;\\n    weight_t weight;\\n    neighbor(vertex_t arg_target, weight_t arg_weight)\\n        : target(arg_target), weight(arg_weight) { }\\n};\\n\\ntypedef std::vector adjacency_list_t;\\n\\n\\nvoid DijkstraComputePaths(vertex_t source,\\n                          const adjacency_list_t &adjacency_list,\\n                          std::vector &min_distance,\\n                          std::vector &previous)\\n{\\n    int n = adjacency_list.size();\\n    min_distance.clear();\\n    min_distance.resize(n, max_weight);\\n    min_distance[source] = 0;\\n    previous.clear();\\n    previous.resize(n, -1);\\n    std::set > vertex_queue;\\n    vertex_queue.insert(std::make_pair(min_distance[source], source));\\n\\n    while (!vertex_queue.empty()) \\n    {\\n        weight_t dist = vertex_queue.begin()->first;\\n        vertex_t u = vertex_queue.begin()->second;\\n        vertex_queue.erase(vertex_queue.begin());\\n\\n        // Visit each edge exiting u\\n	const std::vector<neighbor> &neighbors = adjacency_list[u];\\n        for (std::vector<neighbor>::const_iterator neighbor_iter = neighbors.begin();\\n             neighbor_iter != neighbors.end();\\n             neighbor_iter++)\\n        {\\n            vertex_t v = neighbor_iter->target;\\n            weight_t weight = neighbor_iter->weight;\\n            weight_t distance_through_u = dist + weight;\\n	    if (distance_through_u < min_distance[v]) {\\n	        vertex_queue.erase(std::make_pair(min_distance[v], v));\\n\\n	        min_distance[v] = distance_through_u;\\n	        previous[v] = u;\\n	        vertex_queue.insert(std::make_pair(min_distance[v], v));\\n\\n	    }\\n\\n        }\\n    }\\n}\\n\\n\\nstd::list DijkstraGetShortestPathTo(\\n    vertex_t vertex, const std::vector &previous)\\n{\\n    std::list path;\\n    for ( ; vertex != -1; vertex = previous[vertex])\\n        path.push_front(vertex);\\n    return path;\\n}\\n\\n\\nint main()\\n{\\n    // remember to insert edges both ways for an undirected graph\\n    adjacency_list_t adjacency_list(6);\\n    // 0 = a\\n    adjacency_list[0].push_back(neighbor(1, 7));\\n    adjacency_list[0].push_back(neighbor(2, 9));\\n    adjacency_list[0].push_back(neighbor(5, 14));\\n    // 1 = b\\n    adjacency_list[1].push_back(neighbor(0, 7));\\n    adjacency_list[1].push_back(neighbor(2, 10));\\n    adjacency_list[1].push_back(neighbor(3, 15));\\n    // 2 = c\\n    adjacency_list[2].push_back(neighbor(0, 9));\\n    adjacency_list[2].push_back(neighbor(1, 10));\\n    adjacency_list[2].push_back(neighbor(3, 11));\\n    adjacency_list[2].push_back(neighbor(5, 2));\\n    // 3 = d\\n    adjacency_list[3].push_back(neighbor(1, 15));\\n    adjacency_list[3].push_back(neighbor(2, 11));\\n    adjacency_list[3].push_back(neighbor(4, 6));\\n    // 4 = e\\n    adjacency_list[4].push_back(neighbor(3, 6));\\n    adjacency_list[4].push_back(neighbor(5, 9));\\n    // 5 = f\\n    adjacency_list[5].push_back(neighbor(0, 14));\\n    adjacency_list[5].push_back(neighbor(2, 2));\\n    adjacency_list[5].push_back(neighbor(4, 9));\\n\\n    std::vector min_distance;\\n    std::vector previous;\\n    DijkstraComputePaths(0, adjacency_list, min_distance, previous);\\n    std::cout << \""Distance from 0 to 4: \"" << min_distance[4] << std::endl;\\n    std::list path = DijkstraGetShortestPathTo(4, previous);\\n    std::cout << \""Path : \"";\\n    std::copy(path.begin(), path.end(), std::ostream_iterator(std::cout, \"" \""));\\n    std::cout << std::endl;\\n\\n    return 0;\\n}"
"C++","Dijkstra's_algorithm","\\nDijkstra's algorithm, conceived by Dutch computer scientist Edsger Dijkstra in 1956 and published in 1959, is a graph search algorithm that solves the single-source shortest path problem for a graph with non-negative edge path costs, producing a shortest path tree.\\nThis algorithm is often used in routing and as a subroutine in other graph algorithms.\\n\\nFor a given source vertex (node) in the graph, the algorithm finds the path with lowest cost (i.e. the shortest path) between that vertex and every other vertex.\\n\\nIf the vertices of the graph represent cities and edge path costs represent driving distances between pairs of cities connected by a direct road, Dijkstra's algorithm can be used to find the shortest route between one city and all other cities.\\nAs a result, the shortest path first is widely used in network routing protocols, most notably:\\n\\nThe inputs to Dijkstra's algorithm are a directed and weighted graph consisting of 2 or more nodes, generally represented by:\\nA destination node is not specified.\\nThe output is a set of edges depicting the shortest path to each destination node.\\n\\n\\nYou can use numbers or names to identify vertices in your program.\\n\\n\\nThis solution uses a generic package and Ada 2012 (containers, extended return statements, expression functions).\\nThe very convenient 'Img attribute is a GNAT feature.\\nThe testing main procedure :\\n","#include <iostream>\\n#include <vector>\\n#include <string>\\n#include <list>\\n\\n#include <limits> // for numeric_limits\\n\\n#include <queue>\\n#include <utility> // for pair\\n#include <algorithm>\\n#include <iterator>\\n\\n\\ntypedef int vertex_t;\\ntypedef double weight_t;\\n\\nconst weight_t max_weight = std::numeric_limits<double>::infinity();\\n\\nstruct neighbor {\\n    vertex_t target;\\n    weight_t weight;\\n    neighbor(vertex_t arg_target, weight_t arg_weight)\\n        : target(arg_target), weight(arg_weight) { }\\n};\\n\\ntypedef std::vector adjacency_list_t;\\ntypedef std::pair weight_vertex_pair_t;\\n\\nvoid DijkstraComputePaths(vertex_t source,\\n                          const adjacency_list_t &adjacency_list,\\n                          std::vector &min_distance,\\n                          std::vector &previous)\\n{\\n    int n = adjacency_list.size();\\n    min_distance.clear();\\n    min_distance.resize(n, max_weight);\\n    min_distance[source] = 0;\\n    previous.clear();\\n    previous.resize(n, -1);\\n    // we use greater instead of less to turn max-heap into min-heap\\n    std::priority_queue,\\n			std::greater > vertex_queue;\\n    vertex_queue.push(std::make_pair(min_distance[source], source));\\n\\n    while (!vertex_queue.empty()) \\n    {\\n        weight_t dist = vertex_queue.top().first;\\n        vertex_t u = vertex_queue.top().second;\\n        vertex_queue.pop();\\n\\n	// Because we leave old copies of the vertex in the priority queue\\n	// (with outdated higher distances), we need to ignore it when we come\\n	// across it again, by checking its distance against the minimum distance\\n	if (dist > min_distance[u])\\n	    continue;\\n\\n        // Visit each edge exiting u\\n	const std::vector<neighbor> &neighbors = adjacency_list[u];\\n        for (std::vector<neighbor>::const_iterator neighbor_iter = neighbors.begin();\\n             neighbor_iter != neighbors.end();\\n             neighbor_iter++)\\n        {\\n            vertex_t v = neighbor_iter->target;\\n            weight_t weight = neighbor_iter->weight;\\n            weight_t distance_through_u = dist + weight;\\n	    if (distance_through_u < min_distance[v]) {\\n	        min_distance[v] = distance_through_u;\\n	        previous[v] = u;\\n	        vertex_queue.push(std::make_pair(min_distance[v], v));\\n\\n	    }\\n\\n        }\\n    }\\n}\\n\\n\\nstd::list DijkstraGetShortestPathTo(\\n    vertex_t vertex, const std::vector &previous)\\n{\\n    std::list path;\\n    for ( ; vertex != -1; vertex = previous[vertex])\\n        path.push_front(vertex);\\n    return path;\\n}\\n\\n\\nint main()\\n{\\n    // remember to insert edges both ways for an undirected graph\\n    adjacency_list_t adjacency_list(6);\\n    // 0 = a\\n    adjacency_list[0].push_back(neighbor(1, 7));\\n    adjacency_list[0].push_back(neighbor(2, 9));\\n    adjacency_list[0].push_back(neighbor(5, 14));\\n    // 1 = b\\n    adjacency_list[1].push_back(neighbor(0, 7));\\n    adjacency_list[1].push_back(neighbor(2, 10));\\n    adjacency_list[1].push_back(neighbor(3, 15));\\n    // 2 = c\\n    adjacency_list[2].push_back(neighbor(0, 9));\\n    adjacency_list[2].push_back(neighbor(1, 10));\\n    adjacency_list[2].push_back(neighbor(3, 11));\\n    adjacency_list[2].push_back(neighbor(5, 2));\\n    // 3 = d\\n    adjacency_list[3].push_back(neighbor(1, 15));\\n    adjacency_list[3].push_back(neighbor(2, 11));\\n    adjacency_list[3].push_back(neighbor(4, 6));\\n    // 4 = e\\n    adjacency_list[4].push_back(neighbor(3, 6));\\n    adjacency_list[4].push_back(neighbor(5, 9));\\n    // 5 = f\\n    adjacency_list[5].push_back(neighbor(0, 14));\\n    adjacency_list[5].push_back(neighbor(2, 2));\\n    adjacency_list[5].push_back(neighbor(4, 9));\\n\\n    std::vector min_distance;\\n    std::vector previous;\\n    DijkstraComputePaths(0, adjacency_list, min_distance, previous);\\n    std::cout << \""Distance from 0 to 4: \"" << min_distance[4] << std::endl;\\n    std::list path = DijkstraGetShortestPathTo(4, previous);\\n    std::cout << \""Path : \"";\\n    std::copy(path.begin(), path.end(), std::ostream_iterator(std::cout, \"" \""));\\n    std::cout << std::endl;\\n\\n    return 0;\\n}"
"C++","Dining_philosophers","The dining philosophers problem illustrates non-composability of low-level synchronization primitives like semaphores. It is a modification of a problem posed by Edsger Dijkstra.\\nFive philosophers, Aristotle, Kant, Spinoza, Marx, and Russell (the tasks) spend their time thinking and eating spaghetti. They eat at a round table with five individual seats. For eating each philosopher needs two forks (the resources). There are five forks on the table, one left and one right of each seat. When a philosopher cannot grab both forks it sits and waits. Eating takes random time, then the philosopher puts the forks down and leaves the dining room. After spending some random time thinking about the nature of the universe, he again becomes hungry, and the circle repeats itself.\\nIt can be observed that a straightforward solution, when forks are implemented by semaphores, is exposed to deadlock. There exist two deadlock states when all five philosophers are sitting at the table holding one fork each. One deadlock state is when each philosopher has grabbed the fork left of him, and another is when each has the fork on his right.\\nThere are many solutions of the problem, program at least one, and explain how the deadlock is prevented.\\nThe following solution uses an array of mutexes in order to model the forks. The forks used by a philosopher compose a subset in the array. When the the philosopher seizes his forks from the subset the array object prevents deadlocking since it is an atomic operation.\\nIn the following solution forks are implemented as plain mutexes. The deadlock is prevented by ordering mutexes. Philosopher tasks seize them in same order 1, 2, 3, 4, 5.\\nBoth deadlocks happen when all philosophers are in the dining room. The following solution has a host of the room who chatters the last philosopher while four of them are in the room. So there are never more than four of them in there, which prevents deadlock. Now the forks can be picked up in a \""wrong\"" order, i.e. the left one first.\\nAutoHotkey doesn't support concurrency, so we fake it with timers.\\nDeadlock is prevented by releasing a single fork when the other is unobtainable.\\nLivelock is prevented by randomly trying for the opposite fork first.\\nStarvation will only occur if one (or more) of the philosophers never stops eating.\\nTry changing EnoughForks to 4 and fork supply per philosopher to 2.\\n","\\n#include <vector>\\n#include <string>\\n#include <iostream>\\n#include \\n#include \\n#include \\n#include \\n#include \\n\\ntypedef boost::mutex Fork;\\ntypedef boost::shared_ptr< Fork > ForkPtr;\\ntypedef boost::lock_guard< Fork > ForkLock;\\n\\n#define MIN_WAIT_TIME 100\\n#define NUM_MEALS     10\\n#define MAX_JITTER    50\\n\\ntemplate< typename Stream >\\nclass AtomicLogger {\\npublic:\\n\\n  AtomicLogger( Stream& stream ) :\\n    m_mutex(),\\n    m_stream( stream )\\n  {\\n  }\\n\\n  void log( const std::string& str ) {\\n    boost::mutex::scoped_lock lock( m_mutex );\\n    m_stream << str << std::endl;\\n  }\\n\\nprivate:\\n  mutable boost::mutex m_mutex;\\n  Stream& m_stream;\\n};\\ntypedef AtomicLogger< std::ostream > AtomicLoggerOstream;\\ntypedef boost::shared_ptr< AtomicLoggerOstream > AtomicLoggerOstreamPtr;\\n\\nclass Philosopher {\\npublic:\\n\\n  Philosopher( \\n	      const std::string& name, \\n	      ForkPtr fork_left, \\n	      ForkPtr fork_right, \\n	      AtomicLoggerOstreamPtr p_logger ) :\\n    m_name( name ),\\n    m_continue( true ),\\n    mp_fork_left( fork_left ),\\n    mp_fork_right( fork_right ),\\n    m_thread( boost::thread( boost::bind( &Philosopher::thread_func, \\n					  this, \\n					  &m_continue, \\n					  mp_fork_left, \\n					  mp_fork_right ) ) ),\\n    m_meals_left( NUM_MEALS ),\\n    mp_logger( p_logger )\\n  {\\n  }\\n\\n  ~Philosopher() {\\n    done_dining();\\n    wait_for_cmplt();\\n  }\\n\\n  void done_dining() { m_continue = false; }\\n\\n  void wait_for_cmplt() { m_thread.join(); }\\n\\nprivate:\\n  inline bool can_grab_fork( ForkPtr& p_fork ) { return p_fork->try_lock(); }\\n\\n  void thread_func( volatile bool* p_continue, ForkPtr fork_left, ForkPtr fork_right ) {\\n    bool failed_to_grab_fork = false;\\n\\n    while( p_continue && m_meals_left ) {\\n      mp_logger->log( boost::str( boost::format( \""%1% is thinking\"" ) % this->m_name ) );\\n      wait();\\n      mp_logger->log( boost::str( boost::format( \""%1% is hungry\"" ) % this->m_name ) );\\n\\n      // attempt to grab forks\\n      if( can_grab_fork( fork_left ) ) {\\n	ForkLock lock_left( *fork_left, boost::adopt_lock );\\n	if( can_grab_fork( fork_right ) ) {\\n	  ForkLock lock_right( *fork_right, boost::adopt_lock );\\n	  // eating\\n	  mp_logger->log( boost::str( boost::format( \""%1% is eating (%2%)...\"" ) % m_name % m_meals_left ) );\\n	  wait();\\n	  // record the meal\\n	  --m_meals_left;\\n	} else {\\n	  failed_to_grab_fork = true;\\n	}\\n      } else {\\n	failed_to_grab_fork = true;\\n      }\\n      \\n      if( failed_to_grab_fork ) {\\n	mp_logger->log( boost::str( boost::format( \""%1% couldn't get forks; waiting...\"" ) % m_name ) );\\n	failed_to_grab_fork = false;\\n	wait();\\n      }\\n    }\\n\\n    mp_logger->log( boost::str( boost::format( \""%1% is done dining\"" ) % m_name ) );\\n  }\\n	     \\n  inline void wait() {\\n    wait( MIN_WAIT_TIME + ( std::rand() % MAX_JITTER ) );\\n  }\\n	     \\n  inline void wait( boost::uint32_t time_in_ms ) { \\n    boost::this_thread::sleep( boost::posix_time::milliseconds( time_in_ms ) ); \\n  }\\n	     \\n  std::string m_name;\\n  volatile bool m_continue;\\n  ForkPtr mp_fork_left;  // must be declared before the thread\\n  ForkPtr mp_fork_right; // must be declared before the thread\\n  boost::thread m_thread;\\n  boost::uint32_t m_meals_left;\\n  AtomicLoggerOstreamPtr mp_logger;\\n};\\ntypedef boost::shared_ptr< Philosopher > PhilosopherPtr;\\n\\nint main() {\\n  const int N = 5;\\n  std::string names[] = { \""Aristotle\"", \""Spinoza\"", \""Russell\"", \""Kant\"", \""Plato\"" };\\n\\n  std::vector< PhilosopherPtr > philosophers;\\n  philosophers.reserve( N );\\n\\n  // create logger\\n  AtomicLoggerOstreamPtr p_logger( new AtomicLoggerOstream( std::cout ) );\\n\\n  // create forks\\n  std::vector< ForkPtr > forks;\\n  forks.reserve( N );\\n  for( int i = 0; i < N; ++i ) {\\n    forks.push_back( ForkPtr( new Fork() ) );\\n  }\\n\\n  // create philosophers\\n  for( int i = 0; i < N; ++i ) {\\n    philosophers.push_back( PhilosopherPtr(\\n					   new Philosopher( names[ i ], forks[ i ], forks[ (i + 1) % N ], p_logger ) ) );\\n  }\\n  \\n  // wait for them to finish\\n  for( int i = 0; i < N; ++i ) {\\n    philosophers[ i ]->wait_for_cmplt();\\n  }\\n\\n  p_logger->log( \""Everyone is done dining.\"" );\\n\\n  return 0;  \\n}\\n\\n"
"C++","Dining_philosophers","The dining philosophers problem illustrates non-composability of low-level synchronization primitives like semaphores. It is a modification of a problem posed by Edsger Dijkstra.\\nFive philosophers, Aristotle, Kant, Spinoza, Marx, and Russell (the tasks) spend their time thinking and eating spaghetti. They eat at a round table with five individual seats. For eating each philosopher needs two forks (the resources). There are five forks on the table, one left and one right of each seat. When a philosopher cannot grab both forks it sits and waits. Eating takes random time, then the philosopher puts the forks down and leaves the dining room. After spending some random time thinking about the nature of the universe, he again becomes hungry, and the circle repeats itself.\\nIt can be observed that a straightforward solution, when forks are implemented by semaphores, is exposed to deadlock. There exist two deadlock states when all five philosophers are sitting at the table holding one fork each. One deadlock state is when each philosopher has grabbed the fork left of him, and another is when each has the fork on his right.\\nThere are many solutions of the problem, program at least one, and explain how the deadlock is prevented.\\nThe following solution uses an array of mutexes in order to model the forks. The forks used by a philosopher compose a subset in the array. When the the philosopher seizes his forks from the subset the array object prevents deadlocking since it is an atomic operation.\\nIn the following solution forks are implemented as plain mutexes. The deadlock is prevented by ordering mutexes. Philosopher tasks seize them in same order 1, 2, 3, 4, 5.\\nBoth deadlocks happen when all philosophers are in the dining room. The following solution has a host of the room who chatters the last philosopher while four of them are in the room. So there are never more than four of them in there, which prevents deadlock. Now the forks can be picked up in a \""wrong\"" order, i.e. the left one first.\\nAutoHotkey doesn't support concurrency, so we fake it with timers.\\nDeadlock is prevented by releasing a single fork when the other is unobtainable.\\nLivelock is prevented by randomly trying for the opposite fork first.\\nStarvation will only occur if one (or more) of the philosophers never stops eating.\\nTry changing EnoughForks to 4 and fork supply per philosopher to 2.\\n","#include <algorithm>\\n#include <array>\\n#include <atomic>\\n#include <chrono>\\n//We are using only standard library, so snprintf instead of Boost::Format\\n#include <cstdio>\\n#include <iostream>\\n#include <mutex>\\n#include <random>\\n#include <string>\\n#include <thread>\\n\\nstd::mutex cout_mutex;\\n\\nstruct Fork {\\n    std::mutex mutex;\\n};\\n\\nstruct Dinner {\\n    std::atomic<bool> ready {false};\\n    std::array forks;\\n    ~Dinner() { std::cout << \""Dinner is over\""; }\\n};\\n\\nclass Philosopher\\n{\\n    std::mt19937 rng{std::random_device {}()};\\n\\n    const std::string name;\\n    const Dinner& dinner;\\n    Fork& left;\\n    Fork& right;\\n    std::thread worker;\\n\\n    void live();\\n    void dine();\\n    void ponder();\\n  public:\\n    Philosopher(std::string name_, const Dinner& dinn, Fork& l, Fork& r)\\n      : name(std::move(name_)), dinner(dinn) , left(l), right(r), worker(&Philosopher::live, this)\\n    {}\\n    ~Philosopher()\\n    {\\n        worker.join();\\n        std::lock_guard  cout_lock(cout_mutex);\\n        std::cout << name << \"" went to sleep.\"" << std::endl;\\n    }\\n};\\n\\nvoid Philosopher::live()\\n{\\n    while (not dinner.ready)\\n        ; //You spin me right round, baby, right round...\\n    do {//Aquire forks first\\n        //lock uses deadlock prevention mechanism to acquire mutexes safely\\n        std::lock(left.mutex, right.mutex);\\n        dine(); //Dine adopts lock on forks and releases them\\n        if(not dinner.ready) break;\\n        ponder();\\n    } while(dinner.ready);\\n}\\n\\nvoid Philosopher::dine()\\n{\\n    std::lock_guard  left_lock( left.mutex, std::adopt_lock);\\n    std::lock_guard right_lock(right.mutex, std::adopt_lock);\\n\\n    thread_local std::array foods {{\""chicken\"", \""rice\"", \""soda\""}};\\n    thread_local std::array reactions {{\\n        \""I like this %s!\"", \""This %s is good.\"", \""Mmm, %s...\""\\n    }};\\n    thread_local std::uniform_int_distribution<> dist(1, 6);\\n    std::shuffle(    foods.begin(),     foods.end(), rng);\\n    std::shuffle(reactions.begin(), reactions.end(), rng);\\n\\n    if(not dinner.ready) return;\\n    {\\n        std::lock_guard  cout_lock(cout_mutex);\\n        std::cout << name << \"" started eating.\"" << std::endl;\\n    }\\n    constexpr size_t buf_size = 64;\\n    char buffer[buf_size];\\n    for(int i = 0; i < 3; ++i) {\\n        std::this_thread::sleep_for(std::chrono::milliseconds(dist(rng)*50));\\n        snprintf(buffer, buf_size, reactions[i], foods[i]);\\n        std::lock_guard  cout_lock(cout_mutex);\\n        std::cout << name << \"": \"" << buffer << std::endl;\\n    }\\n    std::this_thread::sleep_for(std::chrono::milliseconds(dist(rng))*50);\\n    std::lock_guard  cout_lock(cout_mutex);\\n    std::cout << name << \"" finished and left.\"" << std::endl;\\n}\\n\\nvoid Philosopher::ponder()\\n{\\n    static constexpr std::array topics {{\\n        \""politics\"", \""art\"", \""meaning of life\"", \""source of morality\"", \""how many straws makes a bale\""\\n    }};\\n    thread_local std::uniform_int_distribution<> wait(1, 6);\\n    thread_local std::uniform_int_distribution<> dist(0, topics.size() - 1);\\n    while(dist(rng) > 0) {\\n        std::this_thread::sleep_for(std::chrono::milliseconds(wait(rng)*150));\\n        std::lock_guard  cout_lock(cout_mutex);\\n        std::cout << name << \"" is pondering about \"" << topics[dist(rng)] << '.' << std::endl;\\n        if(not dinner.ready) return;\\n    }\\n    std::this_thread::sleep_for(std::chrono::milliseconds(wait(rng)*150));\\n    std::lock_guard  cout_lock(cout_mutex);\\n    std::cout << name << \"" is hungry again!\"" << std::endl;\\n}\\n\\nint main()\\n{\\n    Dinner dinner;\\n    std::array philosophers {{\\n            {\""Aristotle\"", dinner, dinner.forks[0], dinner.forks[1]},\\n            {\""Kant\"",      dinner, dinner.forks[1], dinner.forks[2]},\\n            {\""Spinoza\"",   dinner, dinner.forks[2], dinner.forks[3]},\\n            {\""Marx\"",      dinner, dinner.forks[3], dinner.forks[4]},\\n            {\""Russell\"",   dinner, dinner.forks[4], dinner.forks[0]},\\n    }};\\n    std::this_thread::sleep_for(std::chrono::seconds(1));\\n    std::cout << \""Dinner started!\"" << std::endl;\\n    dinner.ready = true;\\n    std::this_thread::sleep_for(std::chrono::seconds(5));\\n    dinner.ready = false;\\n    std::lock_guard  cout_lock(cout_mutex);\\n    std::cout << \""It is dark outside...\"" << std::endl;\\n}"
"C++","Discordian_date","\\nConvert a given date from the   Gregorian calendar   to the   Discordian calendar.\\n\\ndiscordian.adb:\\n","\\n#include <iostream>\\n#include <algorithm>\\n#include <vector>\\n#include <sstream>\\n#include <iterator>\\nusing namespace std;\\nclass myTuple\\n{\\npublic:\\n    void set( int a, int b, string c ) { t.first.first = a; t.first.second = b; t.second = c; }\\n    bool operator == ( pair p ) { return p.first == t.first.first && p.second == t.first.second; }\\n    string second() { return t.second; }\\nprivate:\\n    pair, string> t;\\n};\\nclass discordian\\n{\\npublic:\\n    discordian() {\\n        myTuple t;\\n        t.set( 5, 1, \""Mungday\"" ); holyday.push_back( t ); t.set( 19, 2, \""Chaoflux\"" ); holyday.push_back( t );\\n        t.set( 29, 2, \""St. Tib's Day\"" ); holyday.push_back( t ); t.set( 19, 3, \""Mojoday\"" ); holyday.push_back( t );\\n        t.set( 3, 5, \""Discoflux\"" ); holyday.push_back( t ); t.set( 31, 5, \""Syaday\"" ); holyday.push_back( t );\\n        t.set( 15, 7, \""Confuflux\"" ); holyday.push_back( t ); t.set( 12, 8, \""Zaraday\"" ); holyday.push_back( t ); \\n        t.set( 26, 9, \""Bureflux\"" ); holyday.push_back( t ); t.set( 24, 10, \""Maladay\"" ); holyday.push_back( t ); \\n        t.set( 8, 12, \""Afflux\"" ); holyday.push_back( t ); \\n        seasons.push_back( \""Chaos\"" ); seasons.push_back( \""Discord\"" ); seasons.push_back( \""Confusion\"" ); \\n        seasons.push_back( \""Bureaucracy\"" ); seasons.push_back( \""The Aftermath\"" );\\n        wdays.push_back( \""Setting Orange\"" ); wdays.push_back( \""Sweetmorn\"" ); wdays.push_back( \""Boomtime\"" );\\n        wdays.push_back( \""Pungenday\"" ); wdays.push_back( \""Prickle-Prickle\"" ); \\n    }\\n    void convert( int d, int m, int y ) {\\n        if( d == 0 || m == 0 || m > 12 || d > getMaxDay( m, y ) ) { \\n            cout << \""\\nThis is not a date!\""; \\n            return; \\n        }\\n        vector<myTuple>::iterator f = find( holyday.begin(), holyday.end(), make_pair( d, m ) ); \\n        int dd = d, day, wday, sea,  yr = y + 1166;\\n        for( int x = 1; x < m; x++ )\\n            dd += getMaxDay( x, 1 );\\n        day = dd % 73; if( !day ) day = 73; \\n        wday = dd % 5; \\n        sea  = ( dd - 1 ) / 73;\\n        if( d == 29 && m == 2 && isLeap( y ) ) { \\n            cout << ( *f ).second() << \"" \"" << seasons[sea] << \"", Year of Our Lady of Discord \"" << yr; \\n            return; \\n        }\\n        cout << wdays[wday] << \"" \"" << seasons[sea] << \"" \"" << day;\\n        if( day > 10 && day < 14 ) cout << \""th\""; \\n        else switch( day % 10) { \\n            case 1: cout << \""st\""; break; \\n            case 2: cout << \""nd\""; break; \\n            case 3: cout << \""rd\""; break; \\n            default: cout << \""th\""; \\n        }\\n        cout << \"", Year of Our Lady of Discord \"" << yr;\\n        if( f != holyday.end() ) cout << \"" - \"" << ( *f ).second();\\n    }\\nprivate:\\n    int getMaxDay( int m, int y ) { \\n        int dd[] = { 0, 31, isLeap( y ) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; return dd[m]; \\n    }\\n    bool isLeap( int y ) { \\n        bool l = false; \\n        if( !( y % 4 ) ) { \\n            if( y % 100 ) l = true; \\n            else if( !( y % 400 ) ) l = true; \\n        }\\n        return l; \\n    }\\n    vector<myTuple> holyday; vector<string> seasons, wdays;\\n};\\nint main( int argc, char* argv[] ) {\\n    string date; discordian disc;\\n    while( true ) {\\n        cout << \""Enter a date (dd mm yyyy) or 0 to quit: \""; getline( cin, date ); if( date == \""0\"" ) break;\\n        if( date.length() == 10 ) {\\n            istringstream iss( date ); \\n            vector<string> vc;\\n            copy( istream_iterator<string>( iss ), istream_iterator<string>(), back_inserter( vc ) );\\n            disc.convert( atoi( vc[0].c_str() ), atoi( vc[1].c_str() ), atoi( vc[2].c_str() ) ); \\n            cout << \""\\n\\n\\n\"";\\n        } else cout << \""\\nIs this a date?!\\n\\n\"";\\n    }\\n    return 0;\\n}\\n"
"C++","Diversity_prediction_theorem","The wisdom of the crowd is the collective opinion of a group of individuals rather than that of a single expert.\\nWisdom-of-the-crowds research routinely attributes the superiority of crowd averages over individual judgments to the elimination of individual noise, an explanation that assumes independence of the individual judgments from each other. Thus the crowd tends to make its best decisions if it is made up of diverse opinions and ideologies.\\nScott E. Page introduced the diversity prediction theorem: \""The squared error of the collective prediction equals the average squared error minus the predictive diversity\"". Therefore, when the diversity in a group is large, the error of the crowd is small.\\n- Average Individual Error: Average of the individual squared errors\\n- Collective Error: Squared error of the collective prediction\\n- Prediction Diversity: Average squared distance from the individual predictions to the collective prediction\\nSo, The Diversity Prediction Theorem: Given a crowd of predictive models\\nCollective Error = Average Individual Error - Prediction Diversity\\nwikipedia\\npaper\\n\\nAccepts inputs from command line, prints out usage on incorrect invocation.\\nInvocation and Output :\\n","\\n#include <iostream>\\n#include <vector>\\n#include <numeric>\\n\\nfloat sum(const std::vector<float> &array)\\n{\\n    return std::accumulate(array.begin(), array.end(), 0.0);\\n}\\n\\nfloat square(float x)\\n{\\n    return x * x;\\n}\\n\\nfloat mean(const std::vector<float> &array)\\n{\\n    return sum(array) / array.size();\\n}\\n\\nfloat averageSquareDiff(float a, const std::vector<float> &predictions)\\n{\\n    std::vector<float> results;\\n    for (float x : predictions)\\n        results.push_back(square(x - a));\\n    return mean(results);\\n}\\n\\nvoid diversityTheorem(float truth, const std::vector<float> &predictions)\\n{\\n    float average = mean(predictions);\\n    std::cout\\n        << \""average-error: \"" << averageSquareDiff(truth, predictions) << \""\\n\""\\n        << \""crowd-error: \"" << square(truth - average) << \""\\n\""\\n        << \""diversity: \"" << averageSquareDiff(average, predictions) << std::endl;\\n}\\n\\nint main() {\\n    diversityTheorem(49, {48,47,51});\\n    diversityTheorem(49, {48,47,51,42});\\n    return 0;\\n}\\n"
"C++","Dot_product","Create a function/use an in-built function, to compute the   dot product,   also known as the   scalar product   of two vectors.\\nIf possible, make the vectors of arbitrary length.\\n\\nAs an example, compute the dot product of the vectors:\\n\\nIf implementing the dot product of two vectors directly:\\n\\n\\n","#include <iostream>\\n#include <numeric>\\n\\nint main()\\n{\\n    int a[] = { 1, 3, -5 };\\n    int b[] = { 4, -2, -1 };\\n\\n    std::cout << std::inner_product(a, a + sizeof(a) / sizeof(a[0]), b, 0) << std::endl;\\n\\n    return 0;\\n}"
"C++","Dot_product","Create a function/use an in-built function, to compute the   dot product,   also known as the   scalar product   of two vectors.\\nIf possible, make the vectors of arbitrary length.\\n\\nAs an example, compute the dot product of the vectors:\\n\\nIf implementing the dot product of two vectors directly:\\n\\n\\n","\\n#include <valarray>\\n#include <iostream>\\n\\nint main()\\n{\\n    std::valarray<double> xs = {1,3,-5};\\n    std::valarray<double> ys = {4,-2,-1};\\n\\n    double result = (xs * ys).sum();\\n\\n    std::cout << result << '\\n';\\n    \\n    return 0;\\n}"
"C++","Doubly-linked_list/Definition","Define the data structure for a complete Doubly Linked List.\\n\\n\\nExamples already in other doubly-linked list tasks: see Doubly-linked list/Element insertion#Ada and Doubly-linked list/Traversal#Ada.\\nAda 2005 defines doubly-linked lists in A.18.3 The Package Containers.Doubly_Linked_Lists.\\n","#include <iostream>\\n#include <list>\\n\\nint main ()\\n{\\n    std::list<int> numbers {1, 5, 7, 0, 3, 2};\\n    numbers.insert(numbers.begin(), 9); //Insert at the beginning\\n    numbers.insert(numbers.end(), 4); //Insert at the end\\n    auto it = std::next(numbers.begin(), numbers.size() / 2); //Iterator to the middle of the list\\n    numbers.insert(it, 6); //Insert in the middle\\n    for(const auto& i: numbers)\\n        std::cout << i << ' ';\\n    std::cout << '\\n';\\n}"
"C++","Doubly-linked_list/Element_definition","Define the data structure for a doubly-linked list element.\\nThe element should include a data member to hold its value and pointers to both the next element in the list and the previous element in the list.\\nThe pointers should be mutable.\\n\\n\\nUsing generics, the specification might look like this:\\nIn Ada 2005 this example can be written without declaration of an access type:\\nHere the list element is created already pointing to itself, so that no further initialization is required. The type of the element is marked as limited indicating that such elements have referential semantics and cannot be copied.\\nAda's standard container library includes a generic doubly linked list. The structure of the link element is private.\\n\\nsee Doubly-linked list/AutoHotkey\\nC++ has doubly linked list class template in standard library. However actual list noded are treated as implementation detail and encapsulated inside list. If we were to reimplement list, then node could look like that:\\nThis sort of mutable structure is not idiomatic in Clojure. Doubly-linked list/Definition#Clojure or a finger tree implementation would be better.\\nSee the functions on the Doubly-Linked List page for the usage of these structures.\\nA default constructor is implicit:\\nThis does no type-checking, under the assumption that it is being used by a containing doubly-linked list object which enforces that invariant along with others such as that element.getNext().getPrev() == element. See Doubly-Linked List#E for an actual implementation (which uses slightly more elaborate nodes than this).\\nUsing the code in Doubly-linked_list/Definition the element is defined by:\\nIn ISO Fortran 95 or later:\\nOr, using the container/list package:\\nHaskell in general doesn't have mutability so the following 'mutator' functions use lazy evaluation instead.\\nNote that unlike naive pointer manipulation which could corrupt the doubly-linked list, updateLeft and updateRight will always yield a well-formed data structure.\\nUses Unicon classes.\\nAs discussed in Doubly-linked_list/Definition#J, doubly linked lists are antithetical to J's design. Defining individual elements as independent structures is even worse. Now each element of the list must contain three arrays (everything in J is an array), all so that we can implement a list.\\nYo Dawg, we heard you like lists, so we put lists in your lists so you can list while you list.\\nNevertheless, this is doable, though it necessarily departs from the definition specified at Doubly-linked_list/Definition#J.\\nHere, when we create a new list element, we need to specify its successor node and its predecessor node and the data to be stored in the node. To start a new list we will need a node that can be the head and the tail of the list -- this will be the successor node for the last element of the list and the predecessor node for the first element of the list:\\nFor use with Java 1.4 and below, delete all \""<T>\""s and replace T's with \""Object\"".\\nInherits from LinkedList (see Singly-Linked_List_(element)#JavaScript)\\n","template \\nstruct Node\\n{\\n    Node* next;\\n    Node* prev;\\n    T data;\\n};"
"C++","Doubly-linked_list/Element_insertion","This is much like inserting into a Singly-Linked List, but with added assignments so that the backwards-pointing links remain correct.\\nDefine the procedure:\\nCreate links and form the list.\\nElement insertion using the generic doubly linked list defined in the standard Ada containers library.\\nOutput:\\nsee Doubly-linked list/AutoHotkey\\nDefine the function:\\nProduction code should also include checks that the passed links are valid (e.g. not null pointers). There should also be code to handle special cases, such as when *anchor is the end of the existing list (i.e. anchor->next is a null pointer).\\n\\nTo call the function:\\nCreate links, and form the list:\\nThis list is now {a,b}, and c is separate.\\nNow call the function:\\nThis function call changes the list from {a,b} to {a,b,c}.\\n\\nC++ already has own linked list structure. If we were to roll our own linked list, we could implement function inserting new value after specific node like that:\\n\\nThe function handles creation of nodes in addition to inserting them.\\nExample use:\\nThis sort of mutable structure is not idiomatic in Clojure. Doubly-linked list/Definition#Clojure or a finger tree implementation would be better.\\nCode is on the Doubly-Linked List page, in function insert-between.\\n","template \\nvoid insert_after(Node<T>* N, T&& data)\\n{\\n    auto node = new Node<T>{N, N->next, std::forward(data)};\\n    if(N->next != nullptr)\\n        N->next->prev = node;\\n    N->next = node;\\n}"
"C++","Doubly-linked_list/Traversal","Traverse from the beginning of a doubly-linked list to the end, and from the end to the beginning.\\n","#include <iostream>\\n#include <list>\\n\\nint main ()\\n{\\n    std::list<int> numbers {1, 5, 7, 0, 3, 2};\\n    for(const auto& i: numbers)\\n        std::cout << i << ' ';\\n    std::cout << '\\n';\\n}"
"C++","Dragon_curve","Create and display a dragon curve fractal.\\n(You may either display the curve directly or write it to an image file.)\\n\\nHere are some brief notes the algorithms used and how they might suit various languages.\\nThis always has F at even positions and S at odd. Eg. after 3 levels F_S_F_S_F_S_F_S. The +/- turns in between bend to the left or right the same as the \""successive approximation\"" method above. Read more at for instance Joel Castellanos' L-system page.\\nVariations are possible if you have only a single symbol for line draw, for example the Icon and Unicon and Xfractint code. The angles can also be broken into 45-degree parts to keep the expansion in a single direction rather than the endpoint rotating around.\\nThe string rewrites can be done recursively without building the whole string, just follow its instructions at the target level. See for example C by IFS Drawing code. The effect is the same as \""recursive with parameter\"" above but can draw other curves defined by L-systems. \\nOutput:\\nNote: each Dragon curve is composed of many smaller dragon curves (shown in a different colour).\\nExample code using mutual recursion can be found in Recursion Example of \""A Beginner's Guide to Amiga E\"".\\nApple IIe BASIC code can be found in Thomas Bannon, \""Fractals and Transformations\"", Mathematics Teacher, March 1991, pages 178-185. (At JSTOR.)\\nThe Asymptote source code includes an examples/dragon.asy which draws the dragon curve (four interlocking copies actually),\\nAs of its version 2.15 it uses the successive approximation method. Vertices are represented as an array of \""pairs\"" (complex numbers). Between each two vertices a new vertex is is introduced so as to double the segments, repeated to a desired level.\\nSee: Dragon curve/AutoHotkey\\n\\nSee also Sydney Afriat \""Dragon Curves\"" paper for various approaches in BASIC\\nAnd TRS-80 BASIC code in Dan Rollins, \""A Tiger Meets a Dragon: An examination of the mathematical properties of dragon curves and a program to print them on an IDS Paper Tiger\"", Byte Magazine, December 1983. (Based on generating a string of turns by appending middle turn and reversed copy. Options for the middle turn give the alternate paper folding curve and more too. The turns are then followed for the plot.)\\nThis is loosely based on the M4 predicate algorithm, only it produces a more compact ASCII output (which is also a little easier to implement), and it lets you choose the depth of the expansion rather than having to specify the coordinates of the viewing area.\\nIn Befunge-93 the 8-bit cell size restricts you to a maximum depth of 15, but in Befunge-98 you should be able go quite a bit deeper before other limits of the implementation come into play.\\n","\\n#include <windows.h>\\n#include <iostream>\\n\\n//-----------------------------------------------------------------------------------------\\nusing namespace std;\\n\\n//-----------------------------------------------------------------------------------------\\nconst int BMP_SIZE = 800, NORTH = 1, EAST = 2, SOUTH = 4, WEST = 8, LEN = 1;\\n\\n//-----------------------------------------------------------------------------------------\\nclass myBitmap\\n{\\npublic:\\n    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}\\n    ~myBitmap()\\n    {\\n	DeleteObject( pen ); DeleteObject( brush );\\n	DeleteDC( hdc ); DeleteObject( bmp );\\n    }\\n\\n    bool create( int w, int h )\\n    {\\n	BITMAPINFO bi;\\n	ZeroMemory( &bi, sizeof( bi ) );\\n	bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );\\n	bi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;\\n	bi.bmiHeader.biCompression = BI_RGB;\\n	bi.bmiHeader.biPlanes      = 1;\\n	bi.bmiHeader.biWidth       =  w;\\n	bi.bmiHeader.biHeight      = -h;\\n\\n	HDC dc = GetDC( GetConsoleWindow() );\\n	bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );\\n	if( !bmp ) return false;\\n\\n	hdc = CreateCompatibleDC( dc );\\n	SelectObject( hdc, bmp );\\n	ReleaseDC( GetConsoleWindow(), dc );\\n\\n	width = w; height = h;\\n	return true;\\n    }\\n\\n    void clear( BYTE clr = 0 )\\n    {\\n	memset( pBits, clr, width * height * sizeof( DWORD ) );\\n    }\\n\\n    void setBrushColor( DWORD bClr )\\n    {\\n	if( brush ) DeleteObject( brush );\\n	brush = CreateSolidBrush( bClr );\\n	SelectObject( hdc, brush );\\n    }\\n\\n    void setPenColor( DWORD c )\\n    {\\n	clr = c; createPen();\\n    }\\n\\n    void setPenWidth( int w )\\n    {\\n	wid = w; createPen();\\n    }\\n\\n    void saveBitmap( string path )\\n     {\\n	BITMAPFILEHEADER fileheader;\\n	BITMAPINFO       infoheader;\\n	BITMAP           bitmap;\\n	DWORD            wb;\\n\\n	GetObject( bmp, sizeof( bitmap ), &bitmap );\\n	DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];\\n\\n	ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );\\n	ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );\\n	ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );\\n\\n	infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;\\n	infoheader.bmiHeader.biCompression = BI_RGB;\\n	infoheader.bmiHeader.biPlanes = 1;\\n	infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );\\n	infoheader.bmiHeader.biHeight = bitmap.bmHeight;\\n	infoheader.bmiHeader.biWidth = bitmap.bmWidth;\\n	infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );\\n\\n	fileheader.bfType    = 0x4D42;\\n	fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );\\n	fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;\\n\\n	GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );\\n\\n	HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );\\n	WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );\\n	WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );\\n	WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );\\n	CloseHandle( file );\\n\\n	delete [] dwpBits;\\n    }\\n\\n    HDC getDC() const     { return hdc; }\\n    int getWidth() const  { return width; }\\n    int getHeight() const { return height; }\\n\\nprivate:\\n    void createPen()\\n    {\\n	if( pen ) DeleteObject( pen );\\n	pen = CreatePen( PS_SOLID, wid, clr );\\n	SelectObject( hdc, pen );\\n    }\\n\\n    HBITMAP bmp;\\n    HDC     hdc;\\n    HPEN    pen;\\n    HBRUSH  brush;\\n    void    *pBits;\\n    int     width, height, wid;\\n    DWORD   clr;\\n};\\n//-----------------------------------------------------------------------------------------\\nclass dragonC\\n{\\npublic:\\n    dragonC() { bmp.create( BMP_SIZE, BMP_SIZE ); dir = WEST; }\\n    void draw( int iterations ) { generate( iterations ); draw(); }\\n\\nprivate:\\n    void generate( int it )\\n    {\\n	generator.push_back( 1 );\\n	string temp;\\n\\n	for( int y = 0; y < it - 1; y++ )\\n	{\\n	    temp = generator; temp.push_back( 1 );\\n	    for( string::reverse_iterator x = generator.rbegin(); x != generator.rend(); x++ )\\n		temp.push_back( !( *x ) );\\n\\n	    generator = temp;\\n	}\\n    }\\n\\n    void draw()\\n    {\\n	HDC dc = bmp.getDC();\\n	unsigned int clr[] = { 0xff, 0xff00, 0xff0000, 0x00ffff };\\n	int mov[] = { 0, 0, 1, -1, 1, -1, 1, 0 }; int i = 0;\\n\\n	for( int t = 0; t < 4; t++ )\\n	{\\n	    int a = BMP_SIZE / 2, b = a; a += mov[i++]; b += mov[i++];\\n	    MoveToEx( dc, a, b, NULL );\\n\\n	    bmp.setPenColor( clr[t] );\\n	    for( string::iterator x = generator.begin(); x < generator.end(); x++ )\\n	    {\\n		switch( dir )\\n		{\\n		    case NORTH:\\n			if( *x ) { a += LEN; dir = EAST; }\\n			else { a -= LEN; dir = WEST; }				\\n		    break;\\n		    case EAST:\\n			if( *x ) { b += LEN; dir = SOUTH; }\\n			else { b -= LEN; dir = NORTH; }\\n		    break;\\n		    case SOUTH:\\n			if( *x ) { a -= LEN; dir = WEST; }\\n			else { a += LEN; dir = EAST; }\\n		    break;\\n		    case WEST:\\n			if( *x ) { b -= LEN; dir = NORTH; }\\n			else { b += LEN; dir = SOUTH; }\\n		}\\n	        LineTo( dc, a, b );\\n	    }\\n	}\\n	// !!! change this path !!!\\n	bmp.saveBitmap( \""f:/rc/dragonCpp.bmp\"" );\\n    }\\n	\\n    int dir;\\n    myBitmap bmp;\\n    string generator;\\n};\\n//-----------------------------------------------------------------------------------------\\nint main( int argc, char* argv[] )\\n{\\n    dragonC d; d.draw( 17 );\\n    return system( \""pause\"" );\\n}\\n//-----------------------------------------------------------------------------------------\\n"
"C++","Draw_a_clock","Draw a clock.\\n\\nMore specific:\\n\\n\\nrequires the GDI+ Library from http://www.autohotkey.com/forum/viewtopic.php?t=32238\\nthis code from http://www.autohotkey.com/forum/viewtopic.php?p=231836#231836\\ndraws a very nice clock with GDI+\\n","\\n#include <windows.h>\\n#include <string>\\n#include <math.h>\\n\\n//--------------------------------------------------------------------------------------------------\\nusing namespace std;\\n\\n//--------------------------------------------------------------------------------------------------\\nconst int BMP_SIZE = 300, MY_TIMER = 987654, CENTER = BMP_SIZE >> 1, SEC_LEN = CENTER - 20,\\n          MIN_LEN = SEC_LEN - 20, HOUR_LEN = MIN_LEN - 20;\\nconst float PI = 3.1415926536f;\\n\\n//--------------------------------------------------------------------------------------------------\\nclass vector2\\n{\\npublic:\\n    vector2() { x = y = 0; }\\n    vector2( int a, int b ) { x = a; y = b; }\\n    void set( int a, int b ) { x = a; y = b; }\\n    void rotate( float angle_r )\\n    {\\n	float _x = static_cast<float>( x ),\\n	      _y = static_cast<float>( y ),\\n	       s = sinf( angle_r ),\\n	       c = cosf( angle_r ),\\n	       a = _x * c - _y * s,\\n	       b = _x * s + _y * c;\\n\\n	x = static_cast<int>( a );\\n	y = static_cast<int>( b );\\n    }\\n    int x, y;\\n};\\n//--------------------------------------------------------------------------------------------------\\nclass myBitmap\\n{\\npublic:\\n    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}\\n    ~myBitmap()\\n    {\\n	DeleteObject( pen );\\n	DeleteObject( brush );\\n	DeleteDC( hdc );\\n	DeleteObject( bmp );\\n    }\\n\\n    bool create( int w, int h )\\n    {\\n	BITMAPINFO    bi;\\n	ZeroMemory( &bi, sizeof( bi ) );\\n	bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );\\n	bi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;\\n	bi.bmiHeader.biCompression = BI_RGB;\\n	bi.bmiHeader.biPlanes      = 1;\\n	bi.bmiHeader.biWidth       =  w;\\n	bi.bmiHeader.biHeight      = -h;\\n\\n	HDC dc = GetDC( GetConsoleWindow() );\\n	bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );\\n	if( !bmp ) return false;\\n\\n	hdc = CreateCompatibleDC( dc );\\n	SelectObject( hdc, bmp );\\n	ReleaseDC( GetConsoleWindow(), dc );\\n\\n	width = w; height = h;\\n	return true;\\n    }\\n\\n    void clear( BYTE clr = 0 )\\n    {\\n	memset( pBits, clr, width * height * sizeof( DWORD ) );\\n    }\\n\\n    void setBrushColor( DWORD bClr )\\n    {\\n	if( brush ) DeleteObject( brush );\\n	brush = CreateSolidBrush( bClr );\\n	SelectObject( hdc, brush );\\n    }\\n\\n    void setPenColor( DWORD c )\\n    {\\n	clr = c;\\n	createPen();\\n    }\\n\\n    void setPenWidth( int w )\\n    {\\n	wid = w;\\n	createPen();\\n    }\\n\\n    void saveBitmap( string path )\\n    {\\n	BITMAPFILEHEADER fileheader;\\n	BITMAPINFO       infoheader;\\n	BITMAP           bitmap;\\n	DWORD            wb;\\n\\n	GetObject( bmp, sizeof( bitmap ), &bitmap );\\n	DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];\\n	\\n        ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );\\n	ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );\\n	ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );\\n\\n	infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;\\n	infoheader.bmiHeader.biCompression = BI_RGB;\\n	infoheader.bmiHeader.biPlanes = 1;\\n	infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );\\n	infoheader.bmiHeader.biHeight = bitmap.bmHeight;\\n	infoheader.bmiHeader.biWidth = bitmap.bmWidth;\\n	infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );\\n\\n	fileheader.bfType    = 0x4D42;\\n	fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );\\n	fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;\\n\\n	GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );\\n\\n	HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );\\n	WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );\\n	WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );\\n	WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );\\n	CloseHandle( file );\\n\\n	delete [] dwpBits;\\n    }\\n\\n    HDC getDC() const     { return hdc; }\\n    int getWidth() const  { return width; }\\n    int getHeight() const { return height; }\\n\\nprivate:\\n    void createPen()\\n    {\\n	if( pen ) DeleteObject( pen );\\n	pen = CreatePen( PS_SOLID, wid, clr );\\n	SelectObject( hdc, pen );\\n    }\\n\\n    HBITMAP bmp;\\n    HDC     hdc;\\n    HPEN    pen;\\n    HBRUSH  brush;\\n    void    *pBits;\\n    int     width, height, wid;\\n    DWORD   clr;\\n};\\n//--------------------------------------------------------------------------------------------------\\nclass clock\\n{\\npublic:\\n    clock()  \\n    {\\n	_bmp.create( BMP_SIZE, BMP_SIZE );\\n	_bmp.clear( 100 );\\n	_bmp.setPenWidth( 2 );\\n	_ang = DegToRadian( 6 );\\n    }\\n	\\n    void setNow()\\n    {\\n	GetLocalTime( &_sysTime );\\n	draw();\\n    }\\n\\n    float DegToRadian( float degree ) { return degree * ( PI / 180.0f ); }\\n\\n    void setHWND( HWND hwnd ) { _hwnd = hwnd; }\\n\\nprivate:\\n    void drawTicks( HDC dc )\\n    {\\n	vector2 line;\\n	_bmp.setPenWidth( 1 );\\n	for( int x = 0; x < 60; x++ )\\n	{\\n	    line.set( 0, 50 );\\n	    line.rotate( static_cast<float>( x + 30 ) * _ang );\\n	    MoveToEx( dc, CENTER - static_cast<int>( 2.5f * static_cast<float>( line.x ) ), CENTER - static_cast<int>( 2.5f * static_cast<float>( line.y ) ), NULL );\\n	    LineTo( dc, CENTER - static_cast<int>( 2.81f * static_cast<float>( line.x ) ), CENTER - static_cast<int>( 2.81f * static_cast<float>( line.y ) ) );\\n	}\\n\\n	_bmp.setPenWidth( 3 );\\n	for( int x = 0; x < 60; x += 5 )\\n	{\\n	    line.set( 0, 50 );\\n	    line.rotate( static_cast<float>( x + 30 ) * _ang );\\n	    MoveToEx( dc, CENTER - static_cast<int>( 2.5f * static_cast<float>( line.x ) ), CENTER - static_cast<int>( 2.5f * static_cast<float>( line.y ) ), NULL );\\n	    LineTo( dc, CENTER - static_cast<int>( 2.81f * static_cast<float>( line.x ) ), CENTER - static_cast<int>( 2.81f * static_cast<float>( line.y ) ) );\\n	}\\n    }\\n\\n    void drawHands( HDC dc )\\n    {\\n	float hp = DegToRadian( ( 30.0f * static_cast<float>( _sysTime.wMinute ) ) / 60.0f );\\n	int h = ( _sysTime.wHour > 12 ? _sysTime.wHour - 12 : _sysTime.wHour ) * 5;\\n		\\n	_bmp.setPenWidth( 3 );\\n	_bmp.setPenColor( RGB( 0, 0, 255 ) );\\n	drawHand( dc, HOUR_LEN, ( _ang * static_cast<float>( 30 + h ) ) + hp );\\n\\n	_bmp.setPenColor( RGB( 0, 128, 0 ) );\\n	drawHand( dc, MIN_LEN, _ang * static_cast<float>( 30 + _sysTime.wMinute ) );\\n\\n	_bmp.setPenWidth( 2 );\\n	_bmp.setPenColor( RGB( 255, 0, 0 ) );\\n	drawHand( dc, SEC_LEN, _ang * static_cast<float>( 30 + _sysTime.wSecond ) );\\n    }\\n\\n    void drawHand( HDC dc, int len, float ang )\\n    {\\n	vector2 line;\\n	line.set( 0, len );\\n	line.rotate( ang );\\n	MoveToEx( dc, CENTER, CENTER, NULL );\\n	LineTo( dc, line.x + CENTER, line.y + CENTER );\\n    }\\n\\n    void draw()\\n    {\\n	HDC dc = _bmp.getDC();\\n\\n	_bmp.setBrushColor( RGB( 250, 250, 250 ) );\\n	Ellipse( dc, 0, 0, BMP_SIZE, BMP_SIZE );\\n	_bmp.setBrushColor( RGB( 230, 230, 230 ) );\\n	Ellipse( dc, 10, 10, BMP_SIZE - 10, BMP_SIZE - 10 );\\n\\n	drawTicks( dc );\\n	drawHands( dc );\\n\\n	_bmp.setPenColor( 0 ); _bmp.setBrushColor( 0 );\\n	Ellipse( dc, CENTER - 5, CENTER - 5, CENTER + 5, CENTER + 5 );\\n\\n	_wdc = GetDC( _hwnd );\\n	BitBlt( _wdc, 0, 0, BMP_SIZE, BMP_SIZE, dc, 0, 0, SRCCOPY );\\n	ReleaseDC( _hwnd, _wdc );\\n    }\\n\\n    myBitmap   _bmp;\\n    HWND       _hwnd;\\n    HDC        _wdc;\\n    SYSTEMTIME _sysTime;\\n    float      _ang;\\n};\\n//--------------------------------------------------------------------------------------------------\\nclass wnd\\n{\\npublic:\\n    wnd() { _inst = this; }\\n    int wnd::Run( HINSTANCE hInst )\\n    {\\n	_hInst = hInst;\\n	_hwnd = InitAll();\\n	SetTimer( _hwnd, MY_TIMER, 1000, NULL );\\n	_clock.setHWND( _hwnd );\\n\\n	ShowWindow( _hwnd, SW_SHOW );\\n	UpdateWindow( _hwnd );\\n\\n	MSG msg;\\n	ZeroMemory( &msg, sizeof( msg ) );\\n	while( msg.message != WM_QUIT )\\n	{\\n	    if( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) != 0 )\\n	    {\\n		TranslateMessage( &msg );\\n		DispatchMessage( &msg );\\n	    }\\n	}\\n	return UnregisterClass( \""_MY_CLOCK_\"", _hInst );\\n    }\\nprivate:\\n    void wnd::doPaint( HDC dc ) { _clock.setNow(); }\\n    void wnd::doTimer()         { _clock.setNow(); }\\n    static int WINAPI wnd::WndProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )\\n    {\\n	switch( msg )\\n	{\\n	    case WM_DESTROY: PostQuitMessage( 0 ); break;\\n	    case WM_PAINT:\\n	    {\\n		PAINTSTRUCT ps;\\n		HDC dc = BeginPaint( hWnd, &ps );\\n		_inst->doPaint( dc );\\n		EndPaint( hWnd, &ps );\\n		return 0;\\n	    }\\n	    case WM_TIMER: _inst->doTimer(); break;\\n	    default:\\n		return DefWindowProc( hWnd, msg, wParam, lParam );\\n	}\\n	return 0;\\n    }\\n\\n    HWND InitAll()\\n    {\\n	WNDCLASSEX wcex;\\n	ZeroMemory( &wcex, sizeof( wcex ) );\\n	wcex.cbSize           = sizeof( WNDCLASSEX );\\n	wcex.style           = CS_HREDRAW | CS_VREDRAW;\\n	wcex.lpfnWndProc   = ( WNDPROC )WndProc;\\n	wcex.hInstance     = _hInst;\\n	wcex.hCursor       = LoadCursor( NULL, IDC_ARROW );\\n	wcex.hbrBackground = ( HBRUSH )( COLOR_WINDOW + 1 );\\n	wcex.lpszClassName = \""_MY_CLOCK_\"";\\n\\n	RegisterClassEx( &wcex );\\n\\n	RECT rc = { 0, 0, BMP_SIZE, BMP_SIZE };\\n	AdjustWindowRect( &rc, WS_SYSMENU | WS_CAPTION, FALSE );\\n	int w = rc.right - rc.left, h = rc.bottom - rc.top;\\n	return CreateWindow( \""_MY_CLOCK_\"", \"".: Clock -- PJorente :.\"", WS_SYSMENU, CW_USEDEFAULT, 0, w, h, NULL, NULL, _hInst, NULL );\\n    }\\n\\n    static wnd* _inst;\\n    HINSTANCE  _hInst;\\n    HWND       _hwnd;\\n    clock      _clock;\\n};\\nwnd* wnd::_inst = 0;\\n//--------------------------------------------------------------------------------------------------\\nint APIENTRY _tWinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow )\\n{\\n    wnd myWnd;\\n    return myWnd.Run( hInstance );\\n}\\n//--------------------------------------------------------------------------------------------------\\n"
"C++","Draw_a_cuboid","Draw a cuboid with relative dimensions of  2x3x4.  The cuboid can be represented graphically, or in ASCII art, depending on the language capabilities. To fulfill the criteria of being a cuboid, three faces must be visible.\\nEither static or rotational projection is acceptable for this task.\\n\\n\\nASCII-Art output, one width unit is two characters long ('--').\\n","\\n#include<graphics.h>\\n#include<iostream>\\n\\nint main()\\n{\\n    int k;\\n    initwindow(1500,810,\""Rosetta Cuboid\"");\\n    \\n    do{\\n       std::cout<<\""Enter ratio of sides ( 0 or -ve to exit) : \"";\\n       std::cin>>k;\\n       \\n       if(k>0){\\n                bar3d(100, 100, 100 + 2*k, 100 + 4*k, 3*k, 1);\\n       }\\n       }while(k>0);\\n    \\n    return 0;\\n}\\n\\n"
"C++","Dutch_national_flag_problem","The Dutch national flag is composed of three coloured bands in the order red then white and lastly blue. The problem posed by Edsger Dijkstra is:\\nWhen the problem was first posed, Dijkstra then went on to successively refine a solution, minimising the number of swaps and the number of times the colour of a ball needed to determined and restricting the balls to end in an array, ...\\n\\n\\nThis works for ABAP Version 7.40 and above, the color blue is excluded as an option for the last entry to insure an unsorted sequence.\\n","#include <algorithm>\\n#include <iostream>\\n\\n// Dutch national flag problem\\ntemplate \\nvoid dnf_partition(BidIt first, BidIt last, const T& low, const T& high)\\n{\\n    for (BidIt next = first; next != last; ) {\\n        if (*next < low) {\\n            std::iter_swap(first++, next++);\\n        } else if (!(*next < high)) {\\n            std::iter_swap(next, --last);\\n        } else {\\n            ++next;\\n        }\\n    }\\n}\\n\\nenum Colors { RED, WHITE, BLUE };\\n\\nvoid print(const Colors *balls, size_t size)\\n{\\n    static const char *label[] = { \""red\"", \""white\"", \""blue\"" };\\n\\n    std::cout << \""Balls:\"";\\n    for (size_t i = 0; i < size; ++i) {\\n        std::cout << ' ' << label[balls[i]];\\n    }\\n    std::cout << \""\\nSorted: \"" << std::boolalpha << std::is_sorted(balls, balls + size) << '\\n';\\n}\\n\\nint main()\\n{\\n    Colors balls[] = { RED, WHITE, BLUE, RED, WHITE, BLUE, RED, WHITE, BLUE };\\n\\n    std::random_shuffle(balls, balls + 9);\\n    print(balls, 9);\\n\\n    dnf_partition(balls, balls + 9, WHITE, BLUE);\\n    print(balls, 9);\\n}"
"C++","Eertree","An eertree is a data structure designed for efficient processing of certain palindrome tasks, for instance counting the number of sub-palindromes in an input string.\\nThe data structure has commonalities to both tries and suffix trees.\\n  See links below.\\n\\nConstruct an eertree for the string \""eertree\"", then output all sub-palindromes by traversing the tree.\\n\\n\\n","#include <iostream>\\n#include <functional>\\n#include <map>\\n#include <vector>\\n\\nstruct Node {\\n    int length;\\n    std::map edges;\\n    int suffix;\\n\\n    Node(int l) : length(l), suffix(0) {\\n        /* empty */\\n    }\\n\\n    Node(int l, const std::map& m, int s) : length(l), edges(m), suffix(s) {\\n        /* empty */\\n    }\\n};\\n\\nconstexpr int evenRoot = 0;\\nconstexpr int oddRoot = 1;\\n\\nstd::vector<Node> eertree(const std::string& s) {\\n    std::vector<Node> tree = {\\n        Node(0, {}, oddRoot),\\n        Node(-1, {}, oddRoot)\\n    };\\n    int suffix = oddRoot;\\n    int n, k;\\n\\n    for (size_t i = 0; i < s.length(); ++i) {\\n        char c = s[i];\\n        for (n = suffix; ; n = tree[n].suffix) {\\n            k = tree[n].length;\\n            int b = i - k - 1;\\n            if (b >= 0 && s[b] == c) {\\n                break;\\n            }\\n        }\\n\\n        auto it = tree[n].edges.find(c);\\n        auto end = tree[n].edges.end();\\n        if (it != end) {\\n            suffix = it->second;\\n            continue;\\n        }\\n        suffix = tree.size();\\n        tree.push_back(Node(k + 2));\\n        tree[n].edges[c] = suffix;\\n        if (tree[suffix].length == 1) {\\n            tree[suffix].suffix = 0;\\n            continue;\\n        }\\n        while (true) {\\n            n = tree[n].suffix;\\n            int b = i - tree[n].length - 1;\\n            if (b >= 0 && s[b] == c) {\\n                break;\\n            }\\n        }\\n        tree[suffix].suffix = tree[n].edges[c];\\n    }\\n\\n    return tree;\\n}\\n\\nstd::vector subPalindromes(const std::vector<Node>& tree) {\\n    std::vector s;\\n\\n    std::function children;\\n    children = [&children, &tree, &s](int n, std::string p) {\\n        auto it = tree[n].edges.cbegin();\\n        auto end = tree[n].edges.cend();\\n        for (; it != end; it = std::next(it)) {\\n            auto c = it->first;\\n            auto m = it->second;\\n\\n            std::string pl = c + p + c;\\n            s.push_back(pl);\\n            children(m, pl);\\n        }\\n    };\\n    children(0, \""\"");\\n\\n    auto it = tree[1].edges.cbegin();\\n    auto end = tree[1].edges.cend();\\n    for (; it != end; it = std::next(it)) {\\n        auto c = it->first;\\n        auto n = it->second;\\n\\n        std::string ct(1, c);\\n        s.push_back(ct);\\n\\n        children(n, ct);\\n    }\\n\\n    return s;\\n}\\n\\nint main() {\\n    using namespace std;\\n\\n    auto tree = eertree(\""eertree\"");\\n    auto pal = subPalindromes(tree);\\n\\n    auto it = pal.cbegin();\\n    auto end = pal.cend();\\n\\n    cout << \""[\"";\\n    if (it != end) {\\n        cout << it->c_str();\\n        it++;\\n    }\\n    while (it != end) {\\n        cout << \"", \"" << it->c_str();\\n        it++;\\n    }\\n    cout << \""]\"" << endl;\\n\\n    return 0;\\n}"
"C++","Egyptian_division","Egyptian division is a method of dividing integers using addition and\\ndoubling that is similar to the algorithm of Ethiopian multiplication\\nAlgorithm:\\nGiven two numbers where the dividend is to be divided by the divisor:\\n\\nExample: 580 / 34\\n Table creation: \\n Initialization of sums: \\n Considering table rows, bottom-up: \\nWhen a row is considered it is shown crossed out if it is not accumulated, or bold if the row causes summations.\\nAnswer\\nSo 580 divided by 34 using the Egyptian method is 17 remainder (578 - 580) or 2.\\n\\nTask\\nThe task is to create a function that does Egyptian division. The function should\\nclosely follow the description above in using a list/array of powers of two, and\\nanother of doublings.\\n\\n\\n\\n","#include <cassert>\\n#include <iostream>\\n\\ntypedef unsigned long ulong;\\n\\n/*\\n * Remainder is an out paramerter. Use nullptr if the remainder is not needed.\\n */\\nulong egyptian_division(ulong dividend, ulong divisor, ulong* remainder) {\\n    constexpr int SIZE = 64;\\n    ulong powers[SIZE];\\n    ulong doublings[SIZE];\\n    int i = 0;\\n\\n    for (; i < SIZE; ++i) {\\n        powers[i] = 1 << i;\\n        doublings[i] = divisor << i;\\n        if (doublings[i] > dividend) {\\n            break;\\n        }\\n    }\\n\\n    ulong answer = 0;\\n    ulong accumulator = 0;\\n\\n    for (i = i - 1; i >= 0; --i) {\\n        /*\\n         * If the current value of the accumulator added to the\\n         * doublings cell would be less than or equal to the\\n         * dividend then add it to the accumulator\\n         */\\n        if (accumulator + doublings[i] <= dividend) {\\n            accumulator += doublings[i];\\n            answer += powers[i];\\n        }\\n    }\\n\\n    if (remainder) {\\n        *remainder = dividend - accumulator;\\n    }\\n    return answer;\\n}\\n\\nvoid print(ulong a, ulong b) {\\n    using namespace std;\\n\\n    ulong x, y;\\n    x = egyptian_division(a, b, &y);\\n\\n    cout << a << \"" / \"" << b << \"" = \"" << x << \"" remainder \"" << y << endl;\\n    assert(a == b * x + y);\\n}\\n\\nint main() {\\n    print(580, 34);\\n\\n    return 0;\\n}"
"C++","Elementary_cellular_automaton","An elementary cellular automaton is a one-dimensional cellular automaton where there are two possible states (labeled 0 and 1) and the rule to determine the state of a cell in the next generation depends only on the current state of the cell and its two immediate neighbors. Those three values can be encoded with three bits.\\nThe rules of evolution are then encoded with eight bits indicating the outcome of each of the eight possibilities 111, 110, 101, 100, 011, 010, 001 and 000 in this order. Thus for instance the rule 13 means that a state is updated to 1 only in the cases 011, 010 and 000, since 13 in binary is 0b00001101.\\n\\nCreate a subroutine, program or function that allows to create and visualize the evolution of any of the 256 possible elementary cellular automaton of arbitrary space length and for any given initial state. You can demonstrate your solution with any automaton of your choice.\\nThe space state should wrap: this means that the left-most cell should be considered as the right neighbor of the right-most cell, and reciprocally.\\nThis task is basically a generalization of one-dimensional cellular automata.\\n\\n\\n","#include <bitset>\\n#include <stdio.h>\\n\\n#define SIZE	           80\\n#define RULE               30\\n#define RULE_TEST(x)       (RULE & 1 << (7 & (x)))\\n\\nvoid evolve(std::bitset<SIZE> &s) {\\n    int i;\\n    std::bitset<SIZE> t(0);\\n    t[SIZE-1] = RULE_TEST( s[0] << 2 | s[SIZE-1] << 1 | s[SIZE-2] );\\n    t[     0] = RULE_TEST( s[1] << 2 | s[     0] << 1 | s[SIZE-1] );\\n    for (i = 1; i < SIZE-1; i++)\\n	t[i] = RULE_TEST( s[i+1] << 2 | s[i] << 1 | s[i-1] );\\n    for (i = 0; i < SIZE; i++) s[i] = t[i];\\n}\\nvoid show(std::bitset<SIZE> s) {\\n    int i;\\n    for (i = SIZE; --i; ) printf(\""%c\"", s[i] ? '#' : ' ');\\n    printf(\""\\n\"");\\n}\\nint main() {\\n    int i;\\n    std::bitset<SIZE> state(1);\\n    state <<= SIZE / 2;\\n    for (i=0; i<10; i++) {\\n	show(state);\\n	evolve(state);\\n    }\\n    return 0;\\n}"
"C++","Elementary_cellular_automaton/Infinite_length","The purpose of this task is to create a version of an Elementary cellular automaton whose number of cells is only limited by the memory size of the computer.\\nTo be precise, consider the state of the automaton to be made of an infinite number of cells, but with a bounded support. In other words, to describe the state of the automaton, you need a finite number of adjacent cells, along with their individual state, and you then consider that the individual state of each of all other cells is the negation of the closest individual cell among the previously defined finite number of cells.\\nExamples:\\nMore complex methods can be imagined, provided it is possible to somehow encode the infinite sections. But for this task we will stick to this simple version.\\n","\\n#include <iostream>\\n#include <iomanip>\\n#include <string>\\n\\nclass oo {\\npublic:\\n    void evolve( int l, int rule ) {\\n        std::string    cells = \""O\"";\\n        std::cout << \"" Rule #\"" << rule << \"":\\n\"";\\n        for( int x = 0; x < l; x++ ) {\\n            addNoCells( cells );\\n            std::cout << std::setw( 40 + ( static_cast<int>( cells.length() ) >> 1 ) ) << cells << \""\\n\"";\\n            step( cells, rule );\\n        }\\n    }\\nprivate:\\n    void step( std::string& cells, int rule ) {\\n        int bin;\\n        std::string newCells;\\n        for( size_t i = 0; i < cells.length() - 2; i++ ) {\\n            bin = 0;\\n            for( size_t n = i, b = 2; n < i + 3; n++, b >>= 1 ) {\\n                bin += ( ( cells[n] == 'O' ? 1 : 0 ) << b );\\n            }\\n            newCells.append( 1, rule & ( 1 << bin ) ? 'O' : '.' );\\n        }\\n        cells = newCells;\\n    }\\n    void addNoCells( std::string& s ) {\\n        char l = s.at( 0 ) == 'O' ? '.' : 'O',\\n             r = s.at( s.length() - 1 ) == 'O' ? '.' : 'O';\\n        s = l + s + r;\\n        s = l + s + r;\\n    }\\n};\\nint main( int argc, char* argv[] ) {\\n    oo o;\\n    o.evolve( 35, 90 );\\n    std::cout << \""\\n\"";\\n    return 0;\\n}\\n"
"C++","Elementary_cellular_automaton/Random_Number_Generator","Rule 30 is considered to be chaotic enough to generate good pseudo-random numbers. As a matter of fact, rule 30 is used by the Mathematica software for its default random number generator.\\nSteven Wolfram's recommendation for random number generation from rule 30 consists in extracting successive bits in a fixed position in the array of cells, as the automaton changes state.\\nThe purpose of this task is to demonstrate this. With the code written in the parent task, which you don't need to re-write here, show the ten first bytes that emerge from this recommendation. To be precise, you will start with a state of all cells but one equal to zero, and you'll follow the evolution of the particular cell whose state was initially one. Then you'll regroup those bits by packets of eight, reconstituting bytes with the first bit being the most significant.\\nYou can pick which ever length you want for the initial array but it should be visible in the code so that your output can be reproduced with an other language.\\nFor extra-credits, you will make this algorithm run as fast as possible in your language, for instance with an extensive use of bitwise logic.\\n64-bits array size, cyclic borders.\\n","#include <bitset>\\n#include <stdio.h>\\n\\n#define SIZE	           80\\n#define RULE               30\\n#define RULE_TEST(x)       (RULE & 1 << (7 & (x)))\\n\\nvoid evolve(std::bitset<SIZE> &s) {\\n    int i;\\n    std::bitset<SIZE> t(0);\\n    t[SIZE-1] = RULE_TEST( s[0] << 2 | s[SIZE-1] << 1 | s[SIZE-2] );\\n    t[     0] = RULE_TEST( s[1] << 2 | s[     0] << 1 | s[SIZE-1] );\\n    for (i = 1; i < SIZE-1; i++)\\n	t[i] = RULE_TEST( s[i+1] << 2 | s[i] << 1 | s[i-1] );\\n    for (i = 0; i < SIZE; i++) s[i] = t[i];\\n}\\nvoid show(std::bitset<SIZE> s) {\\n    int i;\\n    for (i = SIZE; i--; ) printf(\""%c\"", s[i] ? '#' : ' ');\\n    printf(\""|\\n\"");\\n}\\nunsigned char byte(std::bitset<SIZE> &s) {\\n    unsigned char b = 0;\\n    int i;\\n    for (i=8; i--; ) {\\n	b |= s[0] << i; \\n	evolve(s);\\n    }\\n    return b;\\n}\\n\\nint main() {\\n    int i;\\n    std::bitset<SIZE> state(1);\\n    for (i=10; i--; )\\n	printf(\""%u%c\"", byte(state), i ? ' ' : '\\n');\\n    return 0;\\n}"
"C++","Emirp_primes","An   emirp   (prime spelled backwards)   are primes that when reversed   (in their decimal representation)   are a different prime.\\n(This rules out palindromic primes.)\\n\\n\\nIn each list, the numbers should be in order.\\nInvoke the (same) program once per task requirement, this will show what limit is used as the upper bound for calculating surplus (regular) primes.\\nThe specific method of how to determine if a range or if specific values are to be shown will be left to the programmer.\\n\\n\\nhe solution uses the package Miller_Rabin from the Miller-Rabin primality test.\\n","#include <vector>\\n#include <iostream>\\n#include <algorithm>\\n#include <sstream>\\n#include <string>\\n#include <cmath>\\n\\nbool isPrime ( int number ) {\\n   if ( number <= 1 ) \\n      return false ;\\n   if ( number == 2 )\\n      return true ;\\n   for ( int i = 2 ; i <= std::sqrt( number ) ; i++ ) {\\n      if ( number % i == 0 )\\n	 return false ;\\n   }\\n   return true ;\\n}\\n\\nint reverseNumber ( int n ) {\\n   std::ostringstream oss ;\\n   oss << n ;\\n   std::string numberstring ( oss.str( ) ) ;\\n   std::reverse ( numberstring.begin( ) , numberstring.end( ) ) ;\\n   return std::stoi ( numberstring ) ;\\n}\\n\\nbool isEmirp ( int n ) {\\n   return isPrime ( n ) && isPrime ( reverseNumber ( n ) )\\n      && n != reverseNumber ( n ) ;\\n}\\n\\nint main( ) {\\n   std::vector<int> emirps ;\\n   int i = 1 ;\\n   while ( emirps.size( ) < 20 ) {\\n      if ( isEmirp( i ) ) {\\n         emirps.push_back( i ) ;\\n      }\\n      i++ ;\\n   }\\n   std::cout << \""The first 20 emirps:\\n\"" ;\\n   for ( int i : emirps ) \\n      std::cout << i << \"" \"" ;\\n   std::cout << '\\n' ;\\n   int newstart = 7700 ;\\n   while ( newstart < 8001 ) {\\n      if ( isEmirp ( newstart ) ) \\n	std::cout << newstart << '\\n' ;\\n      newstart++ ;\\n   }\\n   while ( emirps.size( ) < 10000 ) {\\n      if ( isEmirp ( i ) ) {\\n	 emirps.push_back( i ) ;\\n      }\\n      i++ ;\\n   }\\n   std::cout << \""the 10000th emirp is \"" << emirps[9999] << \"" !\\n\"" ;\\n\\n   return 0 ;\\n}"
"C++","Empty_directory","Starting with a path to some directory, determine whether the directory is empty.\\nAn empty directory contains no files nor subdirectories.\\nWith Unix or Windows systems, every directory contains an entry for “.” and almost every directory contains “..” (except for a root directory); an empty directory contains no other entries.\\n","\\n#include <iostream>\\n#include \\n\\nusing namespace boost::filesystem;\\n\\nint main(int argc, char *argv[])\\n{\\n    for (int i = 1; i < argc; ++i) {\\n        path p(argv[i]);\\n\\n        if (exists(p) && is_directory(p))\\n            std::cout << \""'\"" << argv[i] << \""' is\"" << (!is_empty(p) ? \"" not\"" : \""\"") << \"" empty\\n\"";\\n        else\\n            std::cout << \""dir '\"" << argv[i] << \""' could not be found\\n\"";\\n    }\\n}\\n"
"C++","Empty_string","Languages may have features for dealing specifically with empty strings\\n(those containing no characters).\\n\\n\\nAssign an empty string to a variable:\\nCheck that the string is empty:\\nThe check for a non-empty string is the same, but with \""not\"" after the n:=\\nTo check if a string is empty:\\nAutoHotkey has both \""Traditional\"" or literal text, and \""Expression\"" mode.\\nThis code demonstrates the task using both methods.\\n","#include <string>\\n\\n// ...\\n\\nstd::string str; // a string object for an empty string\\n\\nif (str.empty()) { ... } // to test if string is empty\\n\\n// we could also use the following\\nif (str.length() == 0) { ... }\\nif (str == \""\"") { ... }"
"C++","Enforced_immutability","Demonstrate any means your language has to prevent the modification of values, or to create objects that cannot be modified after they have been created.\\n\\nItems in 8th are constants if they are declared inside a word (function). Otherwise, they are mutable, unless the \""const\"" word is used:\\nThat declares that the number 123 is constant and may not be modified (not that the variable named 'one-two-three' is constant)\\nAll variables in ACL2 are constants, with the exception of those accessed using (assign ...) and accessed using (@ ...)\\nTo declare a global constant, use:\\nSubsequent attempts to redefine the constant give an error:\\nAda provides the constant keyword:\\nTypes can be declared as limited: Objects of these types cannot be changed and also not compared nor copied:\\nWhen a name is defined it can be identified as a constant value with an equality, eg pi = 355/113.\\nFor a variable an assignment \"":=\"" would be used instead, eg pi := 355/113;\\nIt should be noted that Enforced immutability goes against the nature of AHK. However, it can be achieved using objects:\\nYou could still use ObjInsert/ObjRemove functions, since they are designed to bypass any custom behaviour implemented by the object. Also, technically you could still use the SetCapacity method to truncate the object, or the GetAddress method to modify the object using memory addresses.\\nMany BASICs support the CONST keyword:\\nSome flavors of BASIC support other methods of declaring constants. For example, FreeBASIC supports C-style defines:\\nBBC BASIC doesn't have named constants. The closest you can get is to use a function:\\nAll values (expressions) in Bracmat are immutable, except those that contain = operators.\\n","#include <iostream>\\n\\nclass MyOtherClass\\n{\\npublic:\\n  const int m_x;\\n  MyOtherClass(const int initX = 0) : m_x(initX) { }\\n\\n};\\n\\nint main()\\n{\\n  MyOtherClass mocA, mocB(7);\\n\\n  std::cout << mocA.m_x << std::endl; // displays 0, the default value given for MyOtherClass's constructor.\\n  std::cout << mocB.m_x << std::endl; // displays 7, the value we provided for the constructor for mocB.\\n\\n  // Uncomment this, and the compile will fail; m_x is a const member.\\n  // mocB.m_x = 99;\\n\\n  return 0;\\n}"
"C++","Enforced_immutability","Demonstrate any means your language has to prevent the modification of values, or to create objects that cannot be modified after they have been created.\\n\\nItems in 8th are constants if they are declared inside a word (function). Otherwise, they are mutable, unless the \""const\"" word is used:\\nThat declares that the number 123 is constant and may not be modified (not that the variable named 'one-two-three' is constant)\\nAll variables in ACL2 are constants, with the exception of those accessed using (assign ...) and accessed using (@ ...)\\nTo declare a global constant, use:\\nSubsequent attempts to redefine the constant give an error:\\nAda provides the constant keyword:\\nTypes can be declared as limited: Objects of these types cannot be changed and also not compared nor copied:\\nWhen a name is defined it can be identified as a constant value with an equality, eg pi = 355/113.\\nFor a variable an assignment \"":=\"" would be used instead, eg pi := 355/113;\\nIt should be noted that Enforced immutability goes against the nature of AHK. However, it can be achieved using objects:\\nYou could still use ObjInsert/ObjRemove functions, since they are designed to bypass any custom behaviour implemented by the object. Also, technically you could still use the SetCapacity method to truncate the object, or the GetAddress method to modify the object using memory addresses.\\nMany BASICs support the CONST keyword:\\nSome flavors of BASIC support other methods of declaring constants. For example, FreeBASIC supports C-style defines:\\nBBC BASIC doesn't have named constants. The closest you can get is to use a function:\\nAll values (expressions) in Bracmat are immutable, except those that contain = operators.\\n","class MyClass\\n{\\nprivate:\\n    int x;\\n  \\npublic:\\n    int getX() const\\n    {\\n        return x;\\n    }\\n};"
"C++","Entropy","Calculate the Shannon entropy   H   of a given input string.\\nGiven the discrete random variable \\n\\n\\n\\nX\\n\\n\\n{\\displaystyle X}\\n\\n that is a string of \\n\\n\\n\\nN\\n\\n\\n{\\displaystyle N}\\n\\n \""symbols\"" (total characters) consisting of \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n different characters (n=2 for binary), the Shannon entropy of X in bits/symbol is :\\nwhere \\n\\n\\n\\nc\\no\\nu\\nn\\n\\nt\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle count_{i}}\\n\\n is the count of character \\n\\n\\n\\n\\nn\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle n_{i}}\\n\\n.\\nFor this task, use X=\""1223334444\"" as an example. The result should be 1.84644... bits/symbol. This assumes X was a random variable, which may not be the case, or it may depend on the observer.\\nThis coding problem calculates the \""specific\"" or \""intensive\"" entropy that finds its parallel in physics with \""specific entropy\"" S0 which is entropy per kg or per mole, not like physical entropy S and therefore not the \""information\"" content of a file. It comes from Boltzmann's H-theorem where \\n\\n\\n\\nS\\n=\\n\\nk\\n\\nB\\n\\n\\nN\\nH\\n\\n\\n{\\displaystyle S=k_{B}NH}\\n\\n where N=number of molecules. Boltzmann's H is the same equation as Shannon's H, and it gives the specific entropy H on a \""per molecule\"" basis.\\nThe \""total\"", \""absolute\"", or \""extensive\"" information entropy is\\nThis is not the entropy being coded here, but it is the closest to physical entropy and a measure of the information content of a string. But it does not look for any patterns that might be available for compression, so it is a very restricted, basic, and certain measure of \""information\"". Every binary file with an equal number of 1's and 0's will have S=N bits. All hex files with equal symbol frequencies will have \\n\\n\\n\\nS\\n=\\nN\\n\\nlog\\n\\n2\\n\\n\\n⁡\\n(\\n16\\n)\\n\\n\\n{\\displaystyle S=N\\log _{2}(16)}\\n\\n bits of entropy. The total entropy in bits of the example above is S= 10*18.4644 = 18.4644 bits.\\nThe H function does not look for any patterns in data or check if X was a random variable. For example, X=000000111111 gives the same calculated entropy in all senses as Y=010011100101. For most purposes it is usually more relevant to divide the gzip length by the length of the original data to get an informal measure of how much \""order\"" was in the data.\\nTwo other \""entropies\"" are useful:\\nNormalized specific entropy:\\nwhich varies from 0 to 1 and it has units of \""entropy/symbol\"" or just 1/symbol. For this example, Hn<\\sub>= 0.923.\\nNormalized total (extensive) entropy:\\nwhich varies from 0 to N and does not have units. It is simply the \""entropy\"", but it needs to be called \""total normalized extensive entropy\"" so that it is not confused with Shannon's (specific) entropy or physical entropy. For this example, Sn<\\sub>= 9.23.\\nShannon himself is the reason his \""entropy/symbol\"" H function is very confusingly called \""entropy\"". That's like calling a function that returns a speed a \""meter\"". See section 1.7 of his classic A Mathematical Theory of Communication and search on \""per symbol\"" and \""units\"" to see he always stated his entropy H has units of \""bits/symbol\"" or \""entropy/symbol\"" or \""information/symbol\"". So it is legitimate to say entropy NH is \""information\"".\\nIn keeping with Landauer's limit, the physics entropy generated from erasing N bits is \\n\\n\\n\\nS\\n=\\n\\nH\\n\\n2\\n\\n\\nN\\n\\nk\\n\\nB\\n\\n\\nln\\n⁡\\n(\\n2\\n)\\n\\n\\n{\\displaystyle S=H_{2}Nk_{B}\\ln(2)}\\n\\n if the bit storage device is perfectly efficient. This can be solved for H2*N to (arguably) get the number of bits of information that a physical entropy represents.\\n\\nUses Ada 2012.\\nExamples:\\n","#include <string>\\n#include <map>\\n#include <iostream>\\n#include <algorithm>\\n#include <cmath>\\n\\ndouble log2( double number ) {\\n   return log( number ) / log( 2 ) ;\\n}\\n\\nint main( int argc , char *argv[ ] ) {\\n   std::string teststring( argv[ 1 ] ) ;\\n   std::map frequencies ;\\n   for ( char c : teststring )\\n     frequencies[ c ] ++ ;\\n   int numlen = teststring.length( ) ;\\n   double infocontent = 0 ;\\n   for ( std::pair p : frequencies ) {\\n      double freq = static_cast<double>( p.second ) / numlen ;\\n      infocontent -= freq * log2( freq ) ;\\n   }\\n  \\n   std::cout << \""The information content of \"" << teststring \\n      << \"" is \"" << infocontent << std::endl ;\\n   return 0 ;\\n}"
"C++","Enumerations","Create an enumeration of constants with and without explicit values.\\n\\nACL2 doesn't have built-in enumerated types, but these macros add some basic support:\\nAda enumeration types have three distinct attributes, the enumeration literal, the enumeration position, and the representation value. The position value (starting with 0) is implied from the order of specification of the enumeration literals in the type declaration; it provides the ordering for the enumeration values. In the example below, apple (position 0) is less than banana (position 1) which is less than cherry (position 3) due to their positions, not due to their enumeration literal. An enumeration representation, when given, must not violate the order.\\nAda enumeration types are non-numeric discrete types. They can be used to index arrays, but there are no arithmetic operators for enumeration types; instead, there are predecessor and successor operations. Characters are implemented as an enumeration type in Ada.\\nNote: In this first example ALGOL 68's MODE does not create\\nFRUITS as a distinct enumerated type. In particular FRUITS remain\\ncompatible with INT and so FRUITS inherit/share all INT's operators\\nand procedures.\\n","enum fruits { apple, banana, cherry };\\n\\nenum fruits { apple = 0, banana = 1, cherry = 2 };"
"C++","Enumerations","Create an enumeration of constants with and without explicit values.\\n\\nACL2 doesn't have built-in enumerated types, but these macros add some basic support:\\nAda enumeration types have three distinct attributes, the enumeration literal, the enumeration position, and the representation value. The position value (starting with 0) is implied from the order of specification of the enumeration literals in the type declaration; it provides the ordering for the enumeration values. In the example below, apple (position 0) is less than banana (position 1) which is less than cherry (position 3) due to their positions, not due to their enumeration literal. An enumeration representation, when given, must not violate the order.\\nAda enumeration types are non-numeric discrete types. They can be used to index arrays, but there are no arithmetic operators for enumeration types; instead, there are predecessor and successor operations. Characters are implemented as an enumeration type in Ada.\\nNote: In this first example ALGOL 68's MODE does not create\\nFRUITS as a distinct enumerated type. In particular FRUITS remain\\ncompatible with INT and so FRUITS inherit/share all INT's operators\\nand procedures.\\n","enum class fruits { apple, banana, cherry };\\n\\nenum class fruits { apple = 0, banana = 1, cherry = 2 };"
"C++","Enumerations","Create an enumeration of constants with and without explicit values.\\n\\nACL2 doesn't have built-in enumerated types, but these macros add some basic support:\\nAda enumeration types have three distinct attributes, the enumeration literal, the enumeration position, and the representation value. The position value (starting with 0) is implied from the order of specification of the enumeration literals in the type declaration; it provides the ordering for the enumeration values. In the example below, apple (position 0) is less than banana (position 1) which is less than cherry (position 3) due to their positions, not due to their enumeration literal. An enumeration representation, when given, must not violate the order.\\nAda enumeration types are non-numeric discrete types. They can be used to index arrays, but there are no arithmetic operators for enumeration types; instead, there are predecessor and successor operations. Characters are implemented as an enumeration type in Ada.\\nNote: In this first example ALGOL 68's MODE does not create\\nFRUITS as a distinct enumerated type. In particular FRUITS remain\\ncompatible with INT and so FRUITS inherit/share all INT's operators\\nand procedures.\\n","enum class fruits : unsigned int { apple, banana, cherry };"
"C++","Enumerations","Create an enumeration of constants with and without explicit values.\\n\\nACL2 doesn't have built-in enumerated types, but these macros add some basic support:\\nAda enumeration types have three distinct attributes, the enumeration literal, the enumeration position, and the representation value. The position value (starting with 0) is implied from the order of specification of the enumeration literals in the type declaration; it provides the ordering for the enumeration values. In the example below, apple (position 0) is less than banana (position 1) which is less than cherry (position 3) due to their positions, not due to their enumeration literal. An enumeration representation, when given, must not violate the order.\\nAda enumeration types are non-numeric discrete types. They can be used to index arrays, but there are no arithmetic operators for enumeration types; instead, there are predecessor and successor operations. Characters are implemented as an enumeration type in Ada.\\nNote: In this first example ALGOL 68's MODE does not create\\nFRUITS as a distinct enumerated type. In particular FRUITS remain\\ncompatible with INT and so FRUITS inherit/share all INT's operators\\nand procedures.\\n","enum fruits : unsigned int { apple, banana, cherry };"
"C++","Environment_variables","Show how to get one of your process's environment variables.\\nThe available variables vary by system;   some of the common ones available on Unix include:\\n\\nPrint a single environment variable.\\nPrint all environment variable names and values.\\n\\nUses Matreshka.\\n","#include <cstdlib>\\n#include <cstdio>\\n\\nint main()\\n{\\n   puts(getenv(\""HOME\""));\\n   return 0;\\n}"
"C++","Equilibrium_index","An equilibrium index of a sequence is an index into the sequence such that the sum of elements at lower indices is equal to the sum of elements at higher indices.\\n\\nFor example, in a sequence   \\n\\n\\n\\nA\\n\\n\\n{\\displaystyle A}\\n\\n:\\n3   is an equilibrium index, because:\\n6   is also an equilibrium index, because:\\n(sum of zero elements is zero)\\n7   is not an equilibrium index, because it is not a valid index of sequence \\n\\n\\n\\nA\\n\\n\\n{\\displaystyle A}\\n\\n.\\n\\nWrite a function that, given a sequence, returns its equilibrium indices (if any).\\nAssume that the sequence may be very long.\\n\\nGeneric solution that returns a Vector of Indices.\\nequilibrium.ads:\\nequilibrium.adb:\\nTest program using two different versions, one with vectors and one with arrays:\\n","#include <algorithm>\\n#include <iostream>\\n#include <numeric>\\n#include <vector>\\n\\ntemplate \\nstd::vector equilibrium(T first, T last)\\n{\\n    typedef typename std::iterator_traits<T>::value_type value_t;\\n\\n    value_t left  = 0;\\n    value_t right = std::accumulate(first, last, value_t(0));\\n    std::vector result;\\n\\n    for (size_t index = 0; first != last; ++first, ++index)\\n    {\\n        right -= *first;\\n        if (left == right)\\n        {\\n            result.push_back(index);\\n        }\\n        left += *first;\\n    }\\n    return result;\\n}\\n\\ntemplate \\nvoid print(const T& value)\\n{\\n    std::cout << value << \""\\n\"";\\n}\\n\\nint main() \\n{\\n    const int data[] = { -7, 1, 5, 2, -4, 3, 0 };\\n\\n    std::vector indices(equilibrium(data, data + 7));\\n\\n    std::for_each(indices.begin(), indices.end(), print);\\n}"
"C++","Ethiopian_multiplication","Ethiopian multiplication is a method of multiplying integers using only addition, doubling, and halving.\\n\\nMethod: \\n\\nFor example:   17 × 34\\nHalving the first column:\\nDoubling the second column:\\nStrike-out rows whose first cell is even:\\nSum the remaining numbers in the right-hand column:\\nSo 17 multiplied by 34, by the Ethiopian method is 578.\\n\\nThe task is to define three named functions/methods/procedures/subroutines:\\n\\nUse these functions to create a function that does Ethiopian multiplication.\\n\\n\\n","template\\nstruct Half    \\n{              \\n        enum { Result = N >> 1 };\\n};                               \\n\\ntemplate\\nstruct Double  \\n{              \\n        enum { Result = N << 1 };\\n};                               \\n\\ntemplate\\nstruct IsEven  \\n{              \\n        static const bool Result = (N & 1) == 0;\\n};\\n\\ntemplate\\nstruct EthiopianMultiplication\\n{\\n        template\\n        struct AddIfNot\\n        {\\n                enum { Result = Plier + RunningTotal };\\n        };\\n        template\\n        struct AddIfNot \\n        {\\n                enum { Result = RunningTotal };\\n        };\\n\\n        template\\n        struct Loop\\n        {\\n                enum { Result = Loop::Result >::Result };\\n        };\\n        template\\n        struct Loop <0, Plicand, RunningTotal>\\n        {\\n                enum { Result = RunningTotal };\\n        };\\n\\n        enum { Result = Loop::Result };\\n};\\n\\n#include <iostream>\\n\\nint main(int, char **)\\n{\\n        std::cout << EthiopianMultiplication<17, 54>::Result << std::endl;\\n        return 0;\\n}"
"C++","Euler_method","Euler's method numerically approximates solutions of first-order ordinary differential equations (ODEs) with a given initial value.   It is an explicit method for solving initial value problems (IVPs), as described in the wikipedia page.\\nThe ODE has to be provided in the following form:\\nwith an initial value\\nTo get a numeric solution, we replace the derivative on the   LHS   with a finite difference approximation:\\nthen solve for \\n\\n\\n\\ny\\n(\\nt\\n+\\nh\\n)\\n\\n\\n{\\displaystyle y(t+h)}\\n\\n:\\nwhich is the same as\\nThe iterative solution rule is then:\\nwhere   \\n\\n\\n\\nh\\n\\n\\n{\\displaystyle h}\\n\\n   is the step size, the most relevant parameter for accuracy of the solution.   A smaller step size increases accuracy but also the computation cost, so it has always has to be hand-picked according to the problem at hand.\\n\\nExample: Newton's Cooling Law\\nNewton's cooling law describes how an object of initial temperature   \\n\\n\\n\\nT\\n(\\n\\nt\\n\\n0\\n\\n\\n)\\n=\\n\\nT\\n\\n0\\n\\n\\n\\n\\n{\\displaystyle T(t_{0})=T_{0}}\\n\\n   cools down in an environment of temperature   \\n\\n\\n\\n\\nT\\n\\nR\\n\\n\\n\\n\\n{\\displaystyle T_{R}}\\n\\n:\\nor\\n\\nIt says that the cooling rate   \\n\\n\\n\\n\\n\\n\\nd\\nT\\n(\\nt\\n)\\n\\n\\nd\\nt\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {dT(t)}{dt}}}\\n\\n   of the object is proportional to the current temperature difference   \\n\\n\\n\\nΔ\\nT\\n=\\n(\\nT\\n(\\nt\\n)\\n−\\n\\nT\\n\\nR\\n\\n\\n)\\n\\n\\n{\\displaystyle \\Delta T=(T(t)-T_{R})}\\n\\n   to the surrounding environment.\\nThe analytical solution, which we will compare to the numerical approximation, is\\n\\nImplement a routine of Euler's method and then to use it to solve the given example of Newton's cooling law with it for three different step sizes of:\\nand to compare with the analytical solution.\\n\\n\\nA reference solution (Common Lisp) can be seen below.   We see that bigger step sizes lead to reduced approximation accuracy.\\nThe solution is generic, usable for any floating point type. The package specification:\\nThe function Solve returns the solution of the differential equation for each of N+1 points, starting from the point T0. The implementation:\\nThe test program:\\nSample output:\\nOuput:\\nOutput:\\noutputs (steps 5 and 10)\\nLast part of output:\\nExample output:\\nThe following is in the Managed COBOL dialect:\\nExample output:\\n","#include <iomanip>\\n#include <iostream>\\n\\ntypedef double F(double,double);\\n\\n/*\\nApproximates y(t) in y'(t)=f(t,y) with y(a)=y0 and\\nt=a..b and the step size h.\\n*/\\nvoid euler(F f, double y0, double a, double b, double h)\\n{\\n    double y = y0;\\n    for (double t = a; t < b; t += h)\\n    {\\n        std::cout << std::fixed << std::setprecision(3) << t << \"" \"" << y << \""\\n\"";\\n        y += h * f(t, y);\\n    }\\n    std::cout << \""done\\n\"";\\n}\\n\\n// Example: Newton's cooling law\\ndouble newtonCoolingLaw(double, double t)\\n{\\n    return -0.07 * (t - 20);\\n}\\n\\nint main()\\n{\\n    euler(newtonCoolingLaw, 100, 0, 100,  2);\\n    euler(newtonCoolingLaw, 100, 0, 100,  5);\\n    euler(newtonCoolingLaw, 100, 0, 100, 10);\\n}"
"C++","Euler's_identity","\\nIn mathematics,   Euler's identity   (also known as   Euler's equation)   is the equality:\\nwhere\\nEuler's identity is often cited as an example of deep mathematical beauty. Three of the basic arithmetic operations occur exactly once each: addition, multiplication, and exponentiation. The identity also links five fundamental mathematical constants:\\nShow in your language that Euler's identity is true. As much as possible and practical, mimic the Euler's identity equation.\\nMost languages are limited to IEEE 754 floating point calculations so will have some error in the calculation.\\nIf that is the case, or there is some other limitation, show\\nthat   ei\\n\\n\\n\\nπ\\n\\n\\n{\\displaystyle \\pi }\\n\\n + 1   is approximately equal to zero and\\nshow the amount of error in the calculation.\\nIf your language is capable of symbolic calculations, show\\nthat   ei\\n\\n\\n\\nπ\\n\\n\\n{\\displaystyle \\pi }\\n\\n + 1   is exactly equal to zero for bonus kudos points.\\n\\nWhilst Algol 68 has complex numbers as standard, it does not have a standard complex exp function.\\n\\nWe could use the identity exp(x + iy) = exp(x)( cos y + i sin y ), however the following uses a series expansion for exp(ix).\\n","#include <iostream>\\n#include <complex>\\n\\nint main() {\\n  std::cout << std::exp(std::complex<double>(0.0, M_PI)) + 1.0 << std::endl;\\n  return 0;\\n}"
"C++","Euler's_sum_of_powers_conjecture","There is a conjecture in mathematics that held for over two hundred years before it was disproved by the finding of a counterexample in 1966 by Lander and Parkin.\\n\\nLander and Parkin are known to have used a brute-force search on a   CDC 6600   computer restricting numbers to those less than 250.\\n\\nWrite a program to search for an integer solution for:\\n\\n","#include <iostream>\\n#include <cmath>\\n#include <set>\\nusing namespace std;\\n\\nbool find() \\n{\\n	const auto MAX = 250;\\n	vector<double> pow5(MAX);\\n	for (auto i = 1; i < MAX; i++) \\n		pow5[i] = (double)i * i * i * i * i;\\n	for (auto x0 = 1; x0 < MAX; x0++) {\\n		for (auto x1 = 1; x1 < x0; x1++) {\\n			for (auto x2 = 1; x2 < x1; x2++) {\\n				for (auto x3 = 1; x3 < x2; x3++) {\\n					auto sum = pow5[x0] + pow5[x1] + pow5[x2] + pow5[x3];\\n					if (binary_search(pow5.begin(), pow5.end(), sum))\\n					{\\n						cout << x0 << \"" \"" << x1 << \"" \"" << x2 << \"" \"" << x3 << \"" \"" << pow(sum, 1.0 / 5.0) << endl;\\n						return true;\\n					}\\n				}\\n			}\\n		}\\n	}\\n	// not found\\n	return false;\\n}\\n\\nint main(void)\\n{\\n	int tm = clock();\\n	if (!find())\\n		cout << \""Nothing found!\\n\"";\\n	printf(\""time=%d milliseconds\\r\\n\"", (int)((clock() - tm) * 1000 / CLOCKS_PER_SEC));\\n	return 0;\\n}"
"C++","Euler's_sum_of_powers_conjecture","There is a conjecture in mathematics that held for over two hundred years before it was disproved by the finding of a counterexample in 1966 by Lander and Parkin.\\n\\nLander and Parkin are known to have used a brute-force search on a   CDC 6600   computer restricting numbers to those less than 250.\\n\\nWrite a program to search for an integer solution for:\\n\\n","	set<double> pow5s;\\n	for (auto i = 1; i < MAX; i++) \\n	{\\n		pow5[i] = (double)i * i * i * i * i;\\n		pow5s.insert(pow5[i]);\\n	}\\n	//...\\n        if (pow5s.find(sum) != pow5s.end())"
"C++","Euler's_sum_of_powers_conjecture","There is a conjecture in mathematics that held for over two hundred years before it was disproved by the finding of a counterexample in 1966 by Lander and Parkin.\\n\\nLander and Parkin are known to have used a brute-force search on a   CDC 6600   computer restricting numbers to those less than 250.\\n\\nWrite a program to search for an integer solution for:\\n\\n","bool find() \\n{\\n	const auto MAX = 250;\\n	vector<double> pow5(MAX);\\n	for (auto i = 1; i < MAX; i++) \\n		pow5[i] = (double)i * i * i * i * i;\\n	auto rs = 5;\\n	for (auto x0 = 1; x0 < MAX; x0++) {\\n		for (auto x1 = 1; x1 < x0; x1++) {\\n			for (auto x2 = 1; x2 < x1; x2++) {\\n				auto s2 = pow5[x0] + pow5[x1] + pow5[x2];\\n				while (rs > 0 && pow5[rs] > s2) --rs;\\n				for (auto x3 = 1; x3 < x2; x3++) {\\n					auto sum = s2 + pow5[x3];\\n					while (rs < MAX - 1 && pow5[rs] < sum) ++rs;\\n					if (pow5[rs] == sum)\\n					{\\n						cout << x0 << \"" \"" << x1 << \"" \"" << x2 << \"" \"" << x3 << \"" \"" << pow(sum, 1.0 / 5.0) << endl;\\n						return true;\\n					}\\n				}\\n			}\\n		}\\n	}\\n	// not found\\n	return false;\\n}"
"C++","Euler's_sum_of_powers_conjecture","There is a conjecture in mathematics that held for over two hundred years before it was disproved by the finding of a counterexample in 1966 by Lander and Parkin.\\n\\nLander and Parkin are known to have used a brute-force search on a   CDC 6600   computer restricting numbers to those less than 250.\\n\\nWrite a program to search for an integer solution for:\\n\\n","				for (auto x3 = 1; x3 < x2; x3++) \\n				{\\n					// go straight to the first appropriate x3, mod 30\\n					if (int err30 = (x0 + x1 + x2 + x3 - rs) % 30)\\n						x3 += 30 - err30;\\n					if (x3 >= x2)\\n						break;\\n					auto sum = s2 + pow5[x3];"
"C++","Euler's_sum_of_powers_conjecture","There is a conjecture in mathematics that held for over two hundred years before it was disproved by the finding of a counterexample in 1966 by Lander and Parkin.\\n\\nLander and Parkin are known to have used a brute-force search on a   CDC 6600   computer restricting numbers to those less than 250.\\n\\nWrite a program to search for an integer solution for:\\n\\n","template C_ Unique(const C_& src, const LT_& less)\\n{\\n	C_ retval(src);\\n	std::sort(retval.begin(), retval.end(), less);\\n	retval.erase(unique(retval.begin(), retval.end()), retval.end());\\n	return retval;\\n}\\n\\ntemplate I_ HuntFwd(const I_& hint, const I_& end, const P_& less)	// if less(x) is false, then less(x+1) must also be false\\n{\\n	I_ retval(hint);\\n	int step = 1;\\n	// expanding phase\\n	while (end - retval > step)\\n	{\\n		I_ test = retval + step;\\n		if (!less(test))\\n			break;\\n		retval = test;\\n		step <<= 1;\\n	}\\n	// contracting phase\\n	while (step > 1)\\n	{\\n		step >>= 1;\\n		if (end - retval <= step)\\n			continue;\\n		I_ test = retval + step;\\n		if (less(test))\\n			retval = test;\\n	}\\n	if (retval != end && less(retval))\\n		++retval;\\n	return retval;\\n}\\n\\nbool DPFind(int how_many)\\n{\\n	const int MAX = 1000;\\n	vector<double> pow5(MAX);\\n	for (int i = 1; i < MAX; i++)\\n		pow5[i] = (double)i * i * i * i * i;\\n	vector> diffs;\\n	for (int i = 2; i < MAX; ++i)\\n	{\\n		for (int j = 1; j < i; ++j)\\n			diffs.emplace_back(pow5[i] - pow5[j], j);\\n	}\\n	auto firstLess = [](const pair& lhs, const pair& rhs) { return lhs.first < rhs.first; };\\n	diffs = Unique(diffs, firstLess);\\n\\n	for (int x4 = 4; x4 < MAX - 1; ++x4)\\n	{\\n		for (int x3 = 3; x3 < x4; ++x3)\\n		{\\n			// if (133 * x3 == 110 * x4) continue;	// skip duplicates of first solution\\n			const auto s2 = pow5[x4] + pow5[x3];\\n			auto pd = upper_bound(diffs.begin() + 1, diffs.end(), make_pair(s2, 0), firstLess) - 1;\\n			for (int x2 = 2; x2 < x3; ++x2)\\n			{\\n				const auto sum = s2 + pow5[x2];\\n				pd = HuntFwd(pd, diffs.end(), [&](decltype(pd) it){ return it->first < sum; });\\n				if (pd != diffs.end() && pd->first == sum && pd->second < x3)	// find each solution only once\\n				{\\n					const double y = pow(pd->first + pow5[pd->second], 0.2);\\n					cout << x4 << \"" \"" << x3 << \"" \"" << x2 << \"" \"" << pd->second << \"" -> \"" << static_cast<int>(y + 0.5) << \""\\n\"";\\n					if (--how_many <= 0)\\n						return true;\\n				}\\n			}\\n		}\\n	}\\n	return false;\\n}"
"C++","Evaluate_binomial_coefficients","This programming task, is to calculate ANY binomial coefficient.\\nHowever, it has to be able to output   \\n\\n\\n\\n\\n\\n\\n(\\n\\n\\n5\\n3\\n\\n\\n)\\n\\n\\n\\n\\n\\n{\\displaystyle {\\binom {5}{3}}}\\n\\n,   which is   10.\\nThis formula is recommended:\\n\\n","double Factorial(double nValue)\\n   {\\n       double result = nValue;\\n       double result_next;\\n       double pc = nValue;\\n       do\\n       {\\n           result_next = result*(pc-1);\\n           result = result_next;\\n           pc--;\\n       }while(pc>2);\\n       nValue = result;\\n       return nValue;\\n   }\\n\\ndouble binomialCoefficient(double n, double k)\\n   {\\n       if (abs(n - k) < 1e-7 || k  < 1e-7) return 1.0;\\n       if( abs(k-1.0) < 1e-7 || abs(k - (n-1)) < 1e-7)return n;\\n       return Factorial(n) /(Factorial(k)*Factorial((n - k)));\\n   }\\n"
"C++","Evaluate_binomial_coefficients","This programming task, is to calculate ANY binomial coefficient.\\nHowever, it has to be able to output   \\n\\n\\n\\n\\n\\n\\n(\\n\\n\\n5\\n3\\n\\n\\n)\\n\\n\\n\\n\\n\\n{\\displaystyle {\\binom {5}{3}}}\\n\\n,   which is   10.\\nThis formula is recommended:\\n\\n","int main()\\n{\\n    cout<<\""The Binomial Coefficient of 5, and 3, is equal to: \""<< binomialCoefficient(5,3);\\n    cin.get();\\n}"
"C++","Even_or_odd","Test whether an integer is even or odd.\\nThere is more than one way to solve this task:\\n\\nThe 'mod' method also works, but the bit method is fastest.\\nThis could be shortened to:\\n","bool isOdd(int x) \\n{\\n    return x % 2;\\n}\\n\\nbool isEven(int x)\\n{\\n    return !(x % 2);\\n}"
"C++","Even_or_odd","Test whether an integer is even or odd.\\nThere is more than one way to solve this task:\\n\\nThe 'mod' method also works, but the bit method is fastest.\\nThis could be shortened to:\\n","\\ntemplate < typename T > \\nconstexpr inline bool isEven( const T& v )\\n{\\n    return isEven( int( v ) );\\n}\\n\\ntemplate <> \\nconstexpr inline bool isEven< int >( const int& v )\\n{\\n    return (v & 1) == 0;\\n}\\n\\ntemplate < typename T > \\nconstexpr inline bool isOdd( const T& v )\\n{\\n    return !isEven(v);\\n}\\n"
"C++","Evolutionary_algorithm","Starting with:\\n\\n\\nNote: to aid comparison, try and ensure the variables and functions mentioned in the task description appear in solutions\\n\\nA cursory examination of a few of the solutions reveals that the instructions have not been followed rigorously in some solutions. Specifically,\\nNote that some of the the solutions given retain characters in the mutated string that are correct in the target string. However, the instruction above does not state to retain any of the characters while performing the mutation. Although some may believe to do so is implied from the use of \""converges\""\\nStrictly speaking, the new parent should be selected from the new pool of mutations, and then the new parent used to generate the next set of mutations with parent characters getting retained only by not being mutated. It then becomes possible that the new set of mutations has no member that is fitter than the parent!\\nAs illustration of this error, the code for 8th has the following remark.\\nNOTE: this has been changed, the 8th version is completely random now\\nClearly, this algo will be applying the mutation function only to the parent characters that don't match to the target characters!\\nTo ensure that the new parent is never less fit than the prior parent, both the parent and all of the latest mutations are subjected to the fitness test to select the next parent.\\n\\nThe output:\\nVery simple fitness determination. For testing purposes you can add a static seed value to the RNG initializations (sample output uses '12345' for both).\\nsample output:\\n","#include <string>\\n#include <cstdlib>\\n#include <iostream>\\n#include <cassert>\\n#include <algorithm>\\n#include <vector>\\n#include <ctime>\\n\\nstd::string allowed_chars = \"" ABCDEFGHIJKLMNOPQRSTUVWXYZ\"";\\n\\n// class selection contains the fitness function, encapsulates the\\n// target string and allows access to it's length. The class is only\\n// there for access control, therefore everything is static. The\\n// string target isn't defined in the function because that way the\\n// length couldn't be accessed outside.\\nclass selection\\n{\\npublic:\\n  // this function returns 0 for the destination string, and a\\n  // negative fitness for a non-matching string. The fitness is\\n  // calculated as the negated sum of the circular distances of the\\n  // string letters with the destination letters.\\n  static int fitness(std::string candidate)\\n  {\\n    assert(target.length() == candidate.length());\\n\\n    int fitness_so_far = 0;\\n\\n    for (int i = 0; i < target.length(); ++i)\\n    {\\n      int target_pos = allowed_chars.find(target[i]);\\n      int candidate_pos = allowed_chars.find(candidate[i]);\\n      int diff = std::abs(target_pos - candidate_pos);\\n      fitness_so_far -= std::min(diff, int(allowed_chars.length()) - diff);\\n    }\\n\\n    return fitness_so_far;\\n  }\\n\\n  // get the target string length\\n  static int target_length() { return target.length(); }\\nprivate:\\n  static std::string target;\\n};\\n\\nstd::string selection::target = \""METHINKS IT IS LIKE A WEASEL\"";\\n\\n// helper function: cyclically move a character through allowed_chars\\nvoid move_char(char& c, int distance)\\n{\\n  while (distance < 0)\\n    distance += allowed_chars.length();\\n  int char_pos = allowed_chars.find(c);\\n  c = allowed_chars[(char_pos + distance) % allowed_chars.length()];\\n}\\n\\n// mutate the string by moving the characters by a small random\\n// distance with the given probability\\nstd::string mutate(std::string parent, double mutation_rate)\\n{\\n  for (int i = 0; i < parent.length(); ++i)\\n    if (std::rand()/(RAND_MAX + 1.0) < mutation_rate)\\n    {\\n      int distance = std::rand() % 3 + 1;\\n      if(std::rand()%2 == 0)\\n        move_char(parent[i], distance);\\n      else\\n        move_char(parent[i], -distance);\\n    }\\n  return parent;\\n}\\n\\n// helper function: tell if the first argument is less fit than the\\n// second\\nbool less_fit(std::string const& s1, std::string const& s2)\\n{\\n  return selection::fitness(s1) < selection::fitness(s2);\\n}\\n\\nint main()\\n{\\n  int const C = 100;\\n\\n  std::srand(time(0));\\n\\n  std::string parent;\\n  for (int i = 0; i < selection::target_length(); ++i)\\n  {\\n    parent += allowed_chars[std::rand() % allowed_chars.length()];\\n  }\\n\\n  int const initial_fitness = selection::fitness(parent);\\n\\n  for(int fitness = initial_fitness;\\n      fitness < 0;\\n      fitness = selection::fitness(parent))\\n  {\\n    std::cout << parent << \"": \"" << fitness << \""\\n\"";\\n    double const mutation_rate = 0.02 + (0.9*fitness)/initial_fitness;\\n    std::vector childs;\\n    childs.reserve(C+1);\\n\\n    childs.push_back(parent);\\n    for (int i = 0; i < C; ++i)\\n      childs.push_back(mutate(parent, mutation_rate));\\n\\n    parent = *std::max_element(childs.begin(), childs.end(), less_fit);\\n  }\\n  std::cout << \""final string: \"" << parent << \""\\n\"";\\n}"
"C++","Exceptions","These are examples of control structures. You may also be interested in:\\nThis task is to give an example of an exception handling routine\\nand to \""throw\"" a new exception.\\n\\n\\nDefine an exception\\nRaise an exception\\nRe-raising once caught exception:\\nHandle an exception\\nAda.Exceptions\\nThe standard package Ada.Exceptions provides a possibility to attach messages to exceptions, to get exception occurrence information and textual description of exceptions. The following example illustrates basic functionality of:\\nAikido provides try, catch and throw statements.\\nCatching exceptions\\nThere is one catch clause per try statement. The variable caught is whatever is thrown. It does not have to be a particular type, although there is a System.Exception class defined for system exceptions.\\nThrowing exceptions\\nYou can throw any value.\\nSimple Exception Throwing\\n","struct MyException\\n{\\n  // data with info about exception\\n};"
"C++","Exceptions","These are examples of control structures. You may also be interested in:\\nThis task is to give an example of an exception handling routine\\nand to \""throw\"" a new exception.\\n\\n\\nDefine an exception\\nRaise an exception\\nRe-raising once caught exception:\\nHandle an exception\\nAda.Exceptions\\nThe standard package Ada.Exceptions provides a possibility to attach messages to exceptions, to get exception occurrence information and textual description of exceptions. The following example illustrates basic functionality of:\\nAikido provides try, catch and throw statements.\\nCatching exceptions\\nThere is one catch clause per try statement. The variable caught is whatever is thrown. It does not have to be a particular type, although there is a System.Exception class defined for system exceptions.\\nThrowing exceptions\\nYou can throw any value.\\nSimple Exception Throwing\\n","#include <exception>\\nstruct MyException: std::exception\\n{\\n  char const* what() const throw() { return \""description\""; }\\n}"
"C++","Exceptions","These are examples of control structures. You may also be interested in:\\nThis task is to give an example of an exception handling routine\\nand to \""throw\"" a new exception.\\n\\n\\nDefine an exception\\nRaise an exception\\nRe-raising once caught exception:\\nHandle an exception\\nAda.Exceptions\\nThe standard package Ada.Exceptions provides a possibility to attach messages to exceptions, to get exception occurrence information and textual description of exceptions. The following example illustrates basic functionality of:\\nAikido provides try, catch and throw statements.\\nCatching exceptions\\nThere is one catch clause per try statement. The variable caught is whatever is thrown. It does not have to be a particular type, although there is a System.Exception class defined for system exceptions.\\nThrowing exceptions\\nYou can throw any value.\\nSimple Exception Throwing\\n","// this function can throw any type of exception\\nvoid foo()\\n{\\n  throw MyException();\\n}\\n\\n// this function can only throw the types of exceptions that are listed\\nvoid foo2() throw(MyException)\\n{\\n  throw MyException();\\n}\\n\\n// this function turns any exceptions other than MyException into std::bad_exception\\nvoid foo3() throw(MyException, std::bad_exception)\\n{\\n  throw MyException();\\n}"
"C++","Exceptions","These are examples of control structures. You may also be interested in:\\nThis task is to give an example of an exception handling routine\\nand to \""throw\"" a new exception.\\n\\n\\nDefine an exception\\nRaise an exception\\nRe-raising once caught exception:\\nHandle an exception\\nAda.Exceptions\\nThe standard package Ada.Exceptions provides a possibility to attach messages to exceptions, to get exception occurrence information and textual description of exceptions. The following example illustrates basic functionality of:\\nAikido provides try, catch and throw statements.\\nCatching exceptions\\nThere is one catch clause per try statement. The variable caught is whatever is thrown. It does not have to be a particular type, although there is a System.Exception class defined for system exceptions.\\nThrowing exceptions\\nYou can throw any value.\\nSimple Exception Throwing\\n","try {\\n  foo();\\n}\\ncatch (MyException &exc)\\n{\\n  // handle exceptions of type MyException and derived\\n}\\ncatch (std::exception &exc)\\n{\\n  // handle exceptions derived from std::exception, which were not handled by above catches\\n  // e.g.\\n  std::cerr << exc.what() << std::endl;\\n}\\ncatch (...)\\n{\\n  // handle any type of exception not handled by above catches\\n}"
"C++","Exceptions/Catch_an_exception_thrown_in_a_nested_call","Show how to create a user-defined exception   and   show how to catch an exception raised from several nested calls away.\\n\\nShow/describe what happens when the program is run.\\n\\n","#include <iostream>\\nclass U0 {};\\nclass U1 {};\\n \\nvoid baz(int i)\\n{\\n    if (!i) throw U0();\\n    else throw U1();\\n}\\nvoid bar(int i) { baz(i); }\\n \\nvoid foo()\\n{\\n    for (int i = 0; i < 2; i++)\\n    {   \\n        try {\\n            bar(i);\\n        } catch(U0 e) {\\n		std::cout<< \""Exception U0 caught\\n\"";\\n        }\\n    }\\n}\\n \\nint main() {\\n    foo();\\n    std::cout<< \""Should never get here!\\n\"";\\n    return 0;\\n}"
"C++","Execute_a_Markov_algorithm","\\nCreate an interpreter for a Markov Algorithm.\\nRules have the syntax:\\nThere is one rule per line.\\nIf there is a   .   (period)   present before the   <replacement>,   then this is a terminating rule in which case the interpreter must halt execution.\\nA ruleset consists of a sequence of rules, with optional comments.\\n\\n Rulesets \\nUse the following tests on entries:\\n\\nSample text of:\\nShould generate the output:\\n\\nA test of the terminating rule\\nSample text of:\\nShould generate:\\n\\nThis tests for correct substitution order and may trap simple regexp based replacement routines if special regexp characters are not escaped.\\nSample text of:\\nShould generate:\\n\\nThis tests for correct order of scanning of rules, and may trap replacement routines that scan in the wrong order.   It implements a general unary multiplication engine.   (Note that the input expression must be placed within underscores in this implementation.)\\nSample text of:\\nshould generate the output:\\n\\nA simple Turing machine,\\nimplementing a three-state busy beaver.\\nThe tape consists of 0s and 1s,   the states are A, B, C and H (for Halt), and the head position is indicated by writing the state letter before the character where the head is.\\nAll parts of the initial tape the machine operates on have to be given in the input.\\nBesides demonstrating that the Markov algorithm is Turing-complete, it also made me catch a bug in the C++ implementation which wasn't caught by the first four rulesets.\\nThis ruleset should turn\\ninto\\n\\nmarkov.ads:\\nmarkov.adb:\\ntest_markov.adb:\\nOutput (rulesX contains the ruleset of above examples and testX the example text):\\nOutput:\\nSave the following text to a file \""markov.bra\"":\\nTest:\\nNote: Non-use of iswhite is intentional, since depending on the locale, other chars besides space and tab might be detected by that function.\\nI should mention that this uses the regular expression machinery present in Allegro Lisp but not Common Lisp generally (though there are public domain Lisp libraries).\\nTesting:\\n","\\n#include <cstdlib>\\n#include <iostream>\\n#include <fstream>\\n#include <vector>\\n#include <string>\\n \\nstruct rule\\n{\\n  std::string pattern;\\n  std::string replacement;\\n  bool terminal;\\n  rule(std::string pat, std::string rep, bool term):\\n    pattern(pat),\\n    replacement(rep),\\n    terminal(term)\\n  {\\n  }\\n};\\n \\nstd::string const whitespace = \"" \\t\"";\\nstd::string::size_type const npos = std::string::npos;\\n \\nbool is_whitespace(char c)\\n{\\n  return whitespace.find(c) != npos;\\n}\\n\\nstd::vector<rule> read_rules(std::ifstream& rulefile)\\n{\\n  std::vector<rule> rules;\\n  std::string line;\\n  while (std::getline(rulefile, line))\\n  {\\n    std::string::size_type pos;\\n \\n    // remove comments\\n    pos = line.find('#');\\n    if (pos != npos)\\n      line.resize(pos);\\n \\n    // ignore lines consisting only of whitespace\\n    if (line.find_first_not_of(whitespace) == npos)\\n      continue;\\n \\n    // find \""->\"" surrounded by whitespace\\n    pos = line.find(\""->\"");\\n    while (pos != npos && (pos == 0 || !is_whitespace(line[pos-1])))\\n      pos = line.find(\""->\"", pos+1);\\n \\n    if (pos == npos || line.length() < pos+3 || !is_whitespace(line[pos+2]))\\n    {\\n      std::cerr << \""invalid rule: \"" << line << \""\\n\"";\\n      std::exit(EXIT_FAILURE);\\n    }\\n \\n    std::string pattern = line.substr(0, pos-1);\\n    std::string replacement = line.substr(pos+3);\\n \\n    // remove additional separating whitespace\\n    pattern.erase(pattern.find_last_not_of(whitespace)+1);\\n    replacement.erase(0, replacement.find_first_not_of(whitespace));\\n \\n    // test for terminal rule\\n    bool terminal = !replacement.empty() && replacement[0] == '.';\\n    if (terminal)\\n      replacement.erase(0,1);\\n \\n    rules.push_back(rule(pattern, replacement, terminal));\\n  }\\n\\n  return rules;\\n}\\n\\nstd::string markov(std::vector<rule> rules, std::string input)\\n{\\n  std::string& output = input;\\n  std::vector<rule>::iterator iter = rules.begin();\\n\\n  // Loop through each rule, transforming our current version\\n  // with each rule.\\n  while (iter != rules.end())\\n  {\\n    std::string::size_type pos = output.find(iter->pattern);\\n    if (pos != npos)\\n    {\\n      output.replace(pos, iter->pattern.length(), iter->replacement);\\n      if (iter->terminal)\\n        break;\\n      iter = rules.begin();\\n    }\\n    else\\n      ++iter;\\n  }\\n\\n  return output;\\n}\\n \\nint main(int argc, char* argv[])\\n{\\n  if (argc != 3)\\n  {\\n    std::cout << \""usage:\\n \"" << argv[0] << \"" rulefile text\\n\"";\\n    return EXIT_FAILURE;\\n  }\\n \\n  std::ifstream rulefile(argv[1]);\\n  std::vector<rule> rules = read_rules(rulefile);\\n\\n  std::string input(argv[2]);\\n  std::string output = markov(rules, input);\\n\\n  std::cout << output << \""\\n\"";\\n}"
"C++","Execute_a_system_command","Run either the   ls   system command   (dir   on Windows),   or the   pause   system command.\\n\\n\\nABAP report which checks if there is an external command called 'ls' for the os of the current application server. When running on Windows, it calls dir, for all other platforms ls. A new command is created if not existing and run.\\nUsing the IEEE POSIX Ada standard, P1003.5c:\\nImporting the C system() function:\\nUsing the GNAT run-time library:\\nThe simplest way to do this is using the system() function. It returns a vector of strings (the output from the command).\\nIf you don't want to process the output you can use the exec function. It writes the output to the standard output stream by default;\\nYou also have the regular fork and execv calls available:\\nOr the classic \""!\"" shell escape can be implemented as an \""!\"" operator:\\nUsing system() function:\\nUsing getline command:\\nOn Acorn computers the *CAT command catalogues the current directory, the equivalent of the Unix ls command or the DOS/Windows dir command. The BBC BASIC OSCLI command passes a string to the Command Line Interpreter to execute a system command, it is the equivalent of C's system() command.\\nWith BBC BASIC for Windows you can execute the Windows dir command:\\nAnd if running BBC BASIC on a Unix host, you can execute the ls command:\\nISO C & POSIX:\\nUsing Windows / .NET:\\nBecause of a quirk in the implementation (cmExecuteProcessCommand.cxx and ProcessUNIX.c), CMake diverts the standard output to a pipe. The effect is like running ls | cat in the shell. The ls process inherits the original standard input and standard error, but receives a new pipe for standard output. CMake then reads this pipe and copies all data to the original standard output.\\nexecute_process() can also chain commands in a pipeeline, and capture output.\\nstd.process.system() is deprecated.\\nIn ERRE language you have the SHELL command followed, eventually, by a string command.\\nSHELL itself opens a new DOS/Windows shell: you must use EXIT to end.\\nFor example\\nlists the current directory and then returns to the program.\\nEuphoria has 2 systems command functions: system() and system_exec().\\nThe Process class handles creating and running external processes. in/out/err streams can be redirected, but default to the usual stdin/stdout/stderr. So following program prints result of 'ls' to the command line:\\nexecute_command_line subroutine in Fortran 2008 and later runs a system command\\nThe SYSTEM subroutine (and function) are a GNU extension.\\nThis simple example prints the output to a console window. With its open \""Unix\"" command, FB has robust capability as a system interface to the Free BSD Unix core of Macintosh OS X 10.x.\\nOutput:\\nClick this link to run this code\\nOutput:\\nSee also: the System.Process module\\nHolyC is the official programming language for The Temple Operating System (TempleOS). The Temple Operating System interpreter executes just-in-time compiled HolyC code. All HolyC code is effectively executed as system commands.\\nFor example, to execute the Dir command:\\nThe code below selects the 'ls' or 'dir' command at runtime based on the UNIX feature.\\nUnicon extends system to allow specification of files and a wait/nowait parameter as in the examples below.\\nWill execute \""ls\"" with output to the screen.\\nwill execute it and store the result in the string array \""result\"".\\nwill execute it asynchronously and direct any output from it into the LUN \""unit\"" from whence it can be read at any (later) time.\\nThe system command interface in J is provided by the standard \""task\"" script:\\nNote that on unix systems, you can also use the 2!:x family of foreign verbs to execute system commands.\\nThere are two ways to run system commands. The simple way, which will hang the JVM (I would be interested in some kind of reason). -- this happens because the the inputStream buffer fills up and blocks until it gets read. Moving your .waitFor after reading the InputStream would fix your issue (as long as your error stream doesn't fill up)\\nAnd the right way, which uses threading to read the InputStream given by the process.\\nJavaScript does not have any facilities to interact with the OS. However, host environments can provide this ability.\\nThe Julia manual has an excellent section on this topic, which is worth a read. The short answer on Linux is:\\n","system(\""pause\"");"
"C++","Exponentiation_operator","Most programming languages have a built-in implementation of exponentiation.\\n\\nRe-implement integer exponentiation for both   intint   and   floatint   as both a procedure,   and an operator (if your language supports operator definition).\\nIf the language supports operator (or procedure) overloading, then an overloaded form should be provided for both   intint   and   floatint   variants.\\n\\nFirst we declare the specifications of the two procedures and the two corresponding operators (written as functions with quoted operators as their names):\\nNow we can create a test program:\\nFinally we can implement the procedures and operations:\\n","template\\n Number power(Number base, int exponent)\\n{\\n  int zerodir;\\n  Number factor;\\n  if (exponent < 0)\\n  {\\n    zerodir = 1;\\n    factor = Number(1)/base;\\n  }\\n  else\\n  {\\n    zerodir = -1;\\n    factor = base;\\n  }\\n\\n  Number result(1);\\n  while (exponent != 0)\\n  {\\n    if (exponent % 2 != 0)\\n    {\\n      result *= factor;\\n      exponent += zerodir;\\n    }\\n    else\\n    {\\n      factor *= factor;\\n      exponent /= 2;\\n    }\\n  }\\n  return result;\\n}"
"C++","Extract_file_extension","Filename extensions are a rudimentary but commonly used way of identifying files types.\\nWrite a function or program that\\n\\nIf your programming language (or standard library) has built-in functionality for extracting a filename extension, show how it would be used and how exactly its behavior differs from this specification.\\nFor the purposes of this task, a filename extension\\n","#include <string>\\n#include <algorithm>\\n#include <iostream>\\n#include <vector>\\n#include <regex>\\n\\nstd::string findExtension ( const std::string & filename ) {\\n   auto position = filename.find_last_of ( '.' ) ;\\n   if ( position == std::string::npos )\\n      return \""\"" ;\\n   else {\\n      std::string extension ( filename.substr( position + 1 ) ) ;\\n      if (std::regex_search (extension, std::regex(\""[^A-Za-z0-9]\"") ))\\n         return \""\"" ;\\n      else\\n         return extension ;\\n   }\\n}\\n\\nint main( ) {\\n   std::vector filenames {\""picture.jpg\"" , \""http://mywebsite.com/picture/image.png\"" ,\\n      \""myuniquefile.longextension\"" , \""IAmAFileWithoutExtension\"" , \""/path/to.my/file\"" ,\\n      \""file.odd_one\"", \""thisismine.\"" } ;\\n   std::vector extensions( filenames.size( ) ) ;\\n   std::transform( filenames.begin( ) , filenames.end( ) , extensions.begin( ) , findExtension ) ;\\n   for ( int i = 0 ; i < filenames.size( ) ; i++ )\\n      std::cout << filenames[i] << \"" has extension : \"" << extensions[i] << \"" !\\n\"" ;\\n   return 0 ;\\n}\\n"
"C++","Factorial","\\nWrite a function to return the factorial of a number.\\nSolutions can be iterative or recursive.\\nSupport for trapping negative    n    errors is optional.\\n\\n\\nThis is an iterative solution which outputs the factorial of each number supplied on standard input.\\n","#include \\n#include <algorithm>\\n\\nint factorial(int n)\\n{\\n  // last is one-past-end\\n  return std::accumulate(boost::counting_iterator<int>(1), boost::counting_iterator<int>(n+1), 1, std::multiplies<int>());\\n}"
"C++","Factorial","\\nWrite a function to return the factorial of a number.\\nSolutions can be iterative or recursive.\\nSupport for trapping negative    n    errors is optional.\\n\\n\\nThis is an iterative solution which outputs the factorial of each number supplied on standard input.\\n","long long int Factorial(long long int m_nValue)\\n   {\\n       long long int result=m_nValue;\\n       long long int result_next;\\n       long long int pc = m_nValue;\\n       do\\n       {\\n           result_next = result*(pc-1);\\n           result = result_next;\\n           pc--;\\n       }while(pc>2);\\n       m_nValue = result;\\n       return m_nValue;\\n   }"
"C++","Factorial","\\nWrite a function to return the factorial of a number.\\nSolutions can be iterative or recursive.\\nSupport for trapping negative    n    errors is optional.\\n\\n\\nThis is an iterative solution which outputs the factorial of each number supplied on standard input.\\n","template \\nstruct Factorial \\n{\\n    enum { value = N * Factorial::value };\\n};\\n \\ntemplate <>\\nstruct Factorial<0> \\n{\\n    enum { value = 1 };\\n};\\n \\n// Factorial<4>::value == 24\\n// Factorial<0>::value == 1\\nvoid foo()\\n{\\n    int x = Factorial<4>::value; // == 24\\n    int y = Factorial<0>::value; // == 1\\n}"
"C++","Factors_of_an_integer","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\nCompute the   factors   of a positive integer.\\nThese factors are the positive integers by which the number being factored can be divided to yield a positive integer result.\\n(Though the concepts function correctly for zero and negative integers, the set of factors of zero has countably infinite members, and the factors of negative integers can be obtained from the factors of related positive numbers without difficulty;   this task does not require handling of either of these cases).\\nNote that every prime number has two factors:   1   and itself.\\n\\n\\nVery compact version.\\n","#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <iterator>\\n\\nstd::vector<int> GenerateFactors(int n)\\n{\\n    std::vector<int> factors;\\n    factors.push_back(1);\\n    factors.push_back(n);\\n    for(int i = 2; i * i <= n; ++i)\\n    {\\n        if(n % i == 0)\\n        {\\n            factors.push_back(i);\\n            if(i * i != n)\\n                factors.push_back(n / i);\\n        }\\n    }\\n\\n    std::sort(factors.begin(), factors.end());\\n    return factors;\\n}\\n\\nint main()\\n{\\n    const int SampleNumbers[] = {3135, 45, 60, 81};\\n\\n    for(size_t i = 0; i < sizeof(SampleNumbers) / sizeof(int); ++i)\\n    {\\n        std::vector<int> factors = GenerateFactors(SampleNumbers[i]);\\n        std::cout << \""Factors of \"" << SampleNumbers[i] << \"" are:\\n\"";\\n        std::copy(factors.begin(), factors.end(), std::ostream_iterator<int>(std::cout, \""\\n\""));\\n        std::cout << std::endl;\\n    }\\n}"
"C++","Fast_Fourier_transform","Calculate the   FFT   (Fast Fourier Transform)   of an input sequence.\\nThe most general case allows for complex numbers at the input\\nand results in a sequence of equal length, again of complex numbers.\\nIf you need to restrict yourself to real numbers, the output should\\nbe the magnitude (i.e. sqrt(re²+im²)) of the complex result.\\nThe classic version is the recursive Cooley–Tukey FFT. Wikipedia has pseudo-code for that.\\nFurther optimizations are possible but not required.\\n\\nThe FFT function is defined as a generic function, instantiated upon\\na user instance of Ada.Numerics.Generic_Complex_Arrays.\\nExample:\\n","#include <complex>\\n#include <iostream>\\n#include <valarray>\\n\\nconst double PI = 3.141592653589793238460;\\n\\ntypedef std::complex<double> Complex;\\ntypedef std::valarray<Complex> CArray;\\n\\n// Cooley–Tukey FFT (in-place, divide-and-conquer)\\n// Higher memory requirements and redundancy although more intuitive\\nvoid fft(CArray& x)\\n{\\n    const size_t N = x.size();\\n    if (N <= 1) return;\\n\\n    // divide\\n    CArray even = x[std::slice(0, N/2, 2)];\\n    CArray  odd = x[std::slice(1, N/2, 2)];\\n\\n    // conquer\\n    fft(even);\\n    fft(odd);\\n\\n    // combine\\n    for (size_t k = 0; k < N/2; ++k)\\n    {\\n        Complex t = std::polar(1.0, -2 * PI * k / N) * odd[k];\\n        x[k    ] = even[k] + t;\\n        x[k+N/2] = even[k] - t;\\n    }\\n}\\n\\n// Cooley-Tukey FFT (in-place, breadth-first, decimation-in-frequency)\\n// Better optimized but less intuitive\\n// !!! Warning : in some cases this code make result different from not optimased version above (need to fix bug)\\n// The bug is now fixed @2017/05/30 \\nvoid fft(CArray &x)\\n{\\n	// DFT\\n	unsigned int N = x.size(), k = N, n;\\n	double thetaT = 3.14159265358979323846264338328L / N;\\n	Complex phiT = Complex(cos(thetaT), -sin(thetaT)), T;\\n	while (k > 1)\\n	{\\n		n = k;\\n		k >>= 1;\\n		phiT = phiT * phiT;\\n		T = 1.0L;\\n		for (unsigned int l = 0; l < k; l++)\\n		{\\n			for (unsigned int a = l; a < N; a += n)\\n			{\\n				unsigned int b = a + k;\\n				Complex t = x[a] - x[b];\\n				x[a] += x[b];\\n				x[b] = t * T;\\n			}\\n			T *= phiT;\\n		}\\n	}\\n	// Decimate\\n	unsigned int m = (unsigned int)log2(N);\\n	for (unsigned int a = 0; a < N; a++)\\n	{\\n		unsigned int b = a;\\n		// Reverse bits\\n		b = (((b & 0xaaaaaaaa) >> 1) | ((b & 0x55555555) << 1));\\n		b = (((b & 0xcccccccc) >> 2) | ((b & 0x33333333) << 2));\\n		b = (((b & 0xf0f0f0f0) >> 4) | ((b & 0x0f0f0f0f) << 4));\\n		b = (((b & 0xff00ff00) >> 8) | ((b & 0x00ff00ff) << 8));\\n		b = ((b >> 16) | (b << 16)) >> (32 - m);\\n		if (b > a)\\n		{\\n			Complex t = x[a];\\n			x[a] = x[b];\\n			x[b] = t;\\n		}\\n	}\\n	//// Normalize (This section make it not working correctly)\\n	//Complex f = 1.0 / sqrt(N);\\n	//for (unsigned int i = 0; i < N; i++)\\n	//	x[i] *= f;\\n}\\n\\n// inverse fft (in-place)\\nvoid ifft(CArray& x)\\n{\\n    // conjugate the complex numbers\\n    x = x.apply(std::conj);\\n\\n    // forward fft\\n    fft( x );\\n\\n    // conjugate the complex numbers again\\n    x = x.apply(std::conj);\\n\\n    // scale the numbers\\n    x /= x.size();\\n}\\n\\nint main()\\n{\\n    const Complex test[] = { 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0 };\\n    CArray data(test, 8);\\n\\n    // forward fft\\n    fft(data);\\n\\n    std::cout << \""fft\"" << std::endl;\\n    for (int i = 0; i < 8; ++i)\\n    {\\n        std::cout << data[i] << std::endl;\\n    }\\n\\n    // inverse fft\\n    ifft(data);\\n\\n    std::cout << std::endl << \""ifft\"" << std::endl;\\n    for (int i = 0; i < 8; ++i)\\n    {\\n        std::cout << data[i] << std::endl;\\n    }\\n    return 0;\\n}"
"C++","FASTA_format","In bioinformatics, long character strings are often encoded in a format called FASTA.\\nA FASTA file can contain several strings, each identified by a name marked by a > (greater than) character at the beginning of the line.\\n\\nWrite a program that reads a FASTA file such as:\\n","#include <iostream>\\n#include <fstream>\\n\\nint main( int argc, char **argv ){\\n    if( argc <= 1 ){\\n        std::cerr << \""Usage: \""<\\n\\n{{out}}\\n<pre>Rosetta_Example_1 : THERECANBENOSPACE\\nRosetta_Example_2 : THERECANBESEVERALLINESBUTTHEYALLMUSTBECONCATENATED\\n"
"C++","Faulhaber's_formula","In mathematics, Faulhaber's formula, named after Johann Faulhaber, expresses the sum of the p-th powers of the first n positive integers as a (p + 1)th-degree polynomial function of n, the coefficients involving Bernoulli numbers.\\nGenerate the first 10 closed-form expressions, starting with p = 0.\\n","#include <iostream>\\n#include <numeric>\\n#include <sstream>\\n#include <vector>\\n\\nclass Frac {\\npublic:\\n	Frac(long n, long d) {\\n		if (d == 0) {\\n			throw new std::runtime_error(\""d must not be zero\"");\\n		}\\n\\n		long nn = n;\\n		long dd = d;\\n		if (nn == 0) {\\n			dd = 1;\\n		} else if (dd < 0) {\\n			nn = -nn;\\n			dd = -dd;\\n		}\\n\\n		long g = abs(std::gcd(nn, dd));\\n		if (g > 1) {\\n			nn /= g;\\n			dd /= g;\\n		}\\n\\n		num = nn;\\n		denom = dd;\\n	}\\n\\n	Frac operator-() const {\\n		return Frac(-num, denom);\\n	}\\n\\n	Frac operator+(const Frac& rhs) const {\\n		return Frac(num*rhs.denom + denom * rhs.num, rhs.denom*denom);\\n	}\\n\\n	Frac operator-(const Frac& rhs) const {\\n		return Frac(num*rhs.denom - denom * rhs.num, rhs.denom*denom);\\n	}\\n\\n	Frac operator*(const Frac& rhs) const {\\n		return Frac(num*rhs.num, denom*rhs.denom);\\n	}\\n\\n	bool operator==(const Frac& rhs) const {\\n		return num == rhs.num && denom == rhs.denom;\\n	}\\n\\n	bool operator!=(const Frac& rhs) const {\\n		return num != rhs.num || denom != rhs.denom;\\n	}\\n\\n	bool operator<(const Frac& rhs) const {\\n		if (denom == rhs.denom) {\\n			return num < rhs.num;\\n		}\\n		return num * rhs.denom < rhs.num * denom;\\n	}\\n\\n	friend std::ostream& operator<<(std::ostream&, const Frac&);\\n\\n	static Frac ZERO() {\\n		return Frac(0, 1);\\n	}\\n\\n	static Frac ONE() {\\n		return Frac(1, 1);\\n	}\\n\\nprivate:\\n	long num;\\n	long denom;\\n};\\n\\nstd::ostream & operator<<(std::ostream & os, const Frac &f) {\\n	if (f.num == 0 || f.denom == 1) {\\n		return os << f.num;\\n	}\\n\\n	std::stringstream ss;\\n	ss << f.num << \""/\"" << f.denom;\\n	return os << ss.str();\\n}\\n\\nFrac bernoulli(int n) {\\n	if (n < 0) {\\n		throw new std::runtime_error(\""n may not be negative or zero\"");\\n	}\\n\\n	std::vector<Frac> a;\\n	for (int m = 0; m <= n; m++) {\\n		a.push_back(Frac(1, m + 1));\\n		for (int j = m; j >= 1; j--) {\\n			a[j - 1] = (a[j - 1] - a[j]) * Frac(j, 1);\\n		}\\n	}\\n\\n	// returns 'first' Bernoulli number\\n	if (n != 1) return a[0];\\n	return -a[0];\\n}\\n\\nint binomial(int n, int k) {\\n	if (n < 0 || k < 0 || n < k) {\\n		throw new std::runtime_error(\""parameters are invalid\"");\\n	}\\n	if (n == 0 || k == 0) return 1;\\n\\n	int num = 1;\\n	for (int i = k + 1; i <= n; i++) {\\n		num *= i;\\n	}\\n\\n	int denom = 1;\\n	for (int i = 2; i <= n - k; i++) {\\n		denom *= i;\\n	}\\n\\n	return num / denom;\\n}\\n\\nvoid faulhaber(int p) {\\n	using namespace std;\\n	cout << p << \"" : \"";\\n\\n	auto q = Frac(1, p + 1);\\n	int sign = -1;\\n	for (int j = 0; j < p + 1; j++) {\\n		sign *= -1;\\n		auto coeff = q * Frac(sign, 1) * Frac(binomial(p + 1, j), 1) * bernoulli(j);\\n		if (coeff == Frac::ZERO()) {\\n			continue;\\n		}\\n		if (j == 0) {\\n			if (coeff == -Frac::ONE()) {\\n				cout << \""-\"";\\n			} else if (coeff != Frac::ONE()) {\\n				cout << coeff;\\n			}\\n		} else {\\n			if (coeff == Frac::ONE()) {\\n				cout << \"" + \"";\\n			} else if (coeff == -Frac::ONE()) {\\n				cout << \"" - \"";\\n			} else if (coeff < Frac::ZERO()) {\\n				cout << \"" - \"" << -coeff;\\n			} else {\\n				cout << \"" + \"" << coeff;\\n			}\\n		}\\n		int pwr = p + 1 - j;\\n		if (pwr > 1) {\\n			cout << \""n^\"" << pwr;\\n		} else {\\n			cout << \""n\"";\\n		}\\n	}\\n	cout << endl;\\n}\\n\\nint main() {\\n	for (int i = 0; i < 10; i++) {\\n		faulhaber(i);\\n	}\\n\\n	return 0;\\n}"
"C++","Faulhaber's_triangle","Named after Johann Faulhaber, the rows of Faulhaber's triangle are the coefficients of polynomials that represent sums of integer powers, which are extracted from Faulhaber's formula:\\n\\n\\nwhere \\n\\n\\n\\n\\nB\\n\\nn\\n\\n\\n\\n\\n{\\displaystyle B_{n}}\\n\\n is the nth-Bernoulli number.\\n\\nThe first 5 rows of Faulhaber's triangle, are:\\n\\nUsing the third row of the triangle, we have:\\n\\n\\n\\n\\n\\n∑\\n\\nk\\n=\\n1\\n\\n\\nn\\n\\n\\n\\nk\\n\\n2\\n\\n\\n=\\n\\n\\n1\\n6\\n\\n\\nn\\n+\\n\\n\\n1\\n2\\n\\n\\n\\nn\\n\\n2\\n\\n\\n+\\n\\n\\n1\\n3\\n\\n\\n\\nn\\n\\n3\\n\\n\\n\\n\\n{\\displaystyle \\sum _{k=1}^{n}k^{2}={1 \\over 6}n+{1 \\over 2}n^{2}+{1 \\over 3}n^{3}}\\n\\n\\n\\n\\n","#include <exception>\\n#include <iomanip>\\n#include <iostream>\\n#include <numeric>\\n#include <sstream>\\n#include <vector>\\n\\nclass Frac {\\npublic:\\n	Frac(long n, long d) {\\n		if (d == 0) {\\n			throw new std::runtime_error(\""d must not be zero\"");\\n		}\\n\\n		long nn = n;\\n		long dd = d;\\n		if (nn == 0) {\\n			dd = 1;\\n		} else if (dd < 0) {\\n			nn = -nn;\\n			dd = -dd;\\n		}\\n\\n		long g = abs(std::gcd(nn, dd));\\n		if (g > 1) {\\n			nn /= g;\\n			dd /= g;\\n		}\\n\\n		num = nn;\\n		denom = dd;\\n	}\\n\\n	Frac operator-() const {\\n		return Frac(-num, denom);\\n	}\\n\\n	Frac operator+(const Frac& rhs) const {\\n		return Frac(num*rhs.denom + denom * rhs.num, rhs.denom*denom);\\n	}\\n\\n	Frac operator-(const Frac& rhs) const {\\n		return Frac(num*rhs.denom - denom * rhs.num, rhs.denom*denom);\\n	}\\n\\n	Frac operator*(const Frac& rhs) const {\\n		return Frac(num*rhs.num, denom*rhs.denom);\\n	}\\n\\n	friend std::ostream& operator<<(std::ostream&, const Frac&);\\n\\n	static Frac ZERO() {\\n		return Frac(0, 1);\\n	}\\n\\nprivate:\\n	long num;\\n	long denom;\\n};\\n\\nstd::ostream & operator<<(std::ostream & os, const Frac &f) {\\n	if (f.num == 0 || f.denom == 1) {\\n		return os << f.num;\\n	}\\n\\n	std::stringstream ss;\\n	ss << f.num << \""/\"" << f.denom;\\n	return os << ss.str();\\n}\\n\\nFrac bernoulli(int n) {\\n	if (n < 0) {\\n		throw new std::runtime_error(\""n may not be negative or zero\"");\\n	}\\n\\n	std::vector<Frac> a;\\n	for (int m = 0; m <= n; m++) {\\n		a.push_back(Frac(1, m + 1));\\n		for (int j = m; j >= 1; j--) {\\n			a[j - 1] = (a[j - 1] - a[j]) * Frac(j, 1);\\n		}\\n	}\\n\\n	// returns 'first' Bernoulli number\\n	if (n != 1) return a[0];\\n	return -a[0];\\n}\\n\\nint binomial(int n, int k) {\\n	if (n < 0 || k < 0 || n < k) {\\n		throw new std::runtime_error(\""parameters are invalid\"");\\n	}\\n	if (n == 0 || k == 0) return 1;\\n\\n	int num = 1;\\n	for (int i = k + 1; i <= n; i++) {\\n		num *= i;\\n	}\\n\\n	int denom = 1;\\n	for (int i = 2; i <= n - k; i++) {\\n		denom *= i;\\n	}\\n\\n	return num / denom;\\n}\\n\\nstd::vector<Frac> faulhaberTraingle(int p) {\\n	std::vector<Frac> coeffs;\\n\\n	for (int i = 0; i < p + 1; i++) {\\n		coeffs.push_back(Frac::ZERO());\\n	}\\n\\n	Frac q{ 1, p + 1 };\\n	int sign = -1;\\n	for (int j = 0; j <= p; j++) {\\n		sign *= -1;\\n		coeffs[p - j] = q * Frac(sign, 1) * Frac(binomial(p + 1, j), 1) * bernoulli(j);\\n	}\\n\\n	return coeffs;\\n}\\n\\nint main() {\\n	using namespace std;\\n\\n	for (int i = 0; i < 10; i++) {\\n		vector<Frac> coeffs = faulhaberTraingle(i);\\n		for (auto it = coeffs.begin(); it != coeffs.end(); it++) {\\n			cout << right << setw(5) << *it << \""  \"";\\n		}\\n		cout << endl;\\n	}\\n\\n	return 0;\\n}"
"C++","Feigenbaum_constant_calculation","\\nCalculate the Feigenbaum constant.\\n\\n\\n","#include <iostream>\\n\\nint main() {\\n    const int max_it = 13;\\n    const int max_it_j = 10;\\n    double a1 = 1.0, a2 = 0.0, d1 = 3.2;\\n\\n    std::cout << \"" i       d\\n\"";\\n    for (int i = 2; i <= max_it; ++i) {\\n        double a = a1 + (a1 - a2) / d1;\\n        for (int j = 1; j <= max_it_j; ++j) {\\n            double x = 0.0;\\n            double y = 0.0;\\n            for (int k = 1; k <= 1 << i; ++k) {\\n                y = 1.0 - 2.0*y*x;\\n                x = a - x * x;\\n            }\\n            a -= x / y;\\n        }\\n        double d = (a1 - a2) / (a - a1);\\n        printf(\""%2d    %.8f\\n\"", i, d);\\n        d1 = d;\\n        a2 = a1;\\n        a1 = a;\\n    }\\n\\n    return 0;\\n}"
"C++","Fibonacci_n-step_number_sequences","These number series are an expansion of the ordinary Fibonacci sequence where:\\nFor small values of \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n, Greek numeric prefixes are sometimes used to individually name each series.\\nAllied sequences can be generated where the initial values are changed:\\n\\n\\n\\n\\n\\nFirst, we specify a package Bonacci, that defines the type Sequence (of Positive numbers), a function Generate that takes a given Start sequence and outputs a generalized N-Bonacci Sequence of a spefified Length, and some constant start sequences.\\nThe implementation is quite straightforward.\\nFinally, we actually generate some sequences, as required by the task. For convenience, we define a procedure Print that outputs a sequence,\\nThe output:\\nOutput:\\n","#include <vector>\\n#include <iostream>\\n#include <numeric>\\n#include <iterator>\\n#include <memory>\\n#include <string>\\n#include <algorithm>\\n#include <iomanip>\\n\\nstd::vector<int> nacci ( const std::vector<int> & start , int arity ) {\\n   std::vector<int> result ( start ) ;\\n   int sumstart = 1 ;//summing starts at vector's begin + sumstart as\\n                     //soon as the vector is longer than arity\\n   while ( result.size( ) < 15 ) { //we print out the first 15 numbers\\n      if ( result.size( ) <= arity ) \\n	 result.push_back( std::accumulate( result.begin( ) , \\n		  result.begin( ) + result.size( ) , 0 ) ) ;\\n      else { \\n	 result.push_back( std::accumulate ( result.begin( ) +\\n	  sumstart , result.begin( ) + sumstart + arity  , 0 )) ;\\n	 sumstart++ ;\\n      }\\n   }\\n   return std::move ( result ) ;\\n}\\n\\nint main( ) {\\n   std::vector naccinames {\""fibo\"" , \""tribo\"" , \\n      \""tetra\"" , \""penta\"" , \""hexa\"" , \""hepta\"" , \""octo\"" , \""nona\"" , \""deca\"" } ;\\n   const std::vector<int> fibo { 1 , 1 } , lucas { 2 , 1 } ;\\n   for ( int i = 2 ; i < 11 ; i++ ) {\\n      std::vector<int> numberrow = nacci ( fibo , i ) ;\\n      std::cout << std::left << std::setw( 10 ) << \\n	 naccinames[ i - 2 ].append( \""nacci\"" ) <<\\n	 std::setw( 2 ) << \"" : \"" ;\\n      std::copy ( numberrow.begin( ) , numberrow.end( ) ,\\n	    std::ostream_iterator<int>( std::cout , \"" \"" ) ) ; \\n      std::cout << \""...\\n\"" ;\\n      numberrow = nacci ( lucas , i ) ;\\n      std::cout << \""Lucas-\"" << i ; \\n      if ( i < 10 )               //for formatting purposes\\n	 std::cout << \""    : \"" ;\\n      else \\n	 std::cout << \""   : \"" ;\\n      std::copy ( numberrow.begin( ) , numberrow.end( ) ,\\n	    std::ostream_iterator<int>( std::cout , \"" \"" ) ) ; \\n      std::cout << \""...\\n\"" ;\\n   }\\n   return 0 ;\\n}"
"C++","Fibonacci_n-step_number_sequences","These number series are an expansion of the ordinary Fibonacci sequence where:\\nFor small values of \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n, Greek numeric prefixes are sometimes used to individually name each series.\\nAllied sequences can be generated where the initial values are changed:\\n\\n\\n\\n\\n\\nFirst, we specify a package Bonacci, that defines the type Sequence (of Positive numbers), a function Generate that takes a given Start sequence and outputs a generalized N-Bonacci Sequence of a spefified Length, and some constant start sequences.\\nThe implementation is quite straightforward.\\nFinally, we actually generate some sequences, as required by the task. For convenience, we define a procedure Print that outputs a sequence,\\nThe output:\\nOutput:\\n","\\n#include <iostream>\\n#include <vector>\\n\\n// This class forms a simple 'generator', where operator() returns the next\\n// element in the series.  It uses a small sliding window buffer to minimize\\n// storage overhead.\\nclass nacci_t\\n{\\n    std::vector< int >  history;\\n    unsigned            windex;             // sliding window index\\n    unsigned            rindex;             // result index\\n    int                 running_sum;        // sum of values in sliding window\\n\\n  public:\\n\\n    nacci_t( unsigned int order, int a0 = 1, int a1 = 1 )\\n    :   history( order + 1 ), windex( 0 ), rindex( order - 1 ), \\n        running_sum( a0 + a1 )\\n    {\\n        // intialize sliding window\\n        history[order - 1] = a0;\\n        history[order - 0] = a1;\\n    }\\n\\n    int operator()() \\n    {\\n        int result   = history[ rindex ];   // get 'nacci number to return\\n        running_sum -= history[ windex ];   // old 'nacci falls out of window\\n\\n        history[ windex ] = running_sum;    // new 'nacci enters the window\\n        running_sum      += running_sum;    // new 'nacci added to the sum\\n\\n        if ( ++windex == history.size() ) windex = 0;\\n        if ( ++rindex == history.size() ) rindex = 0;\\n\\n        return result;\\n    }\\n};\\n\\nint main()\\n{\\n    for ( unsigned int i = 2; i <= 10; ++i )\\n    {\\n        nacci_t nacci( i ); // fibonacci sequence \\n\\n        std::cout << \""nacci( \"" << i << \"" ): \"";\\n\\n        for ( int j = 0; j < 10; ++j )\\n            std::cout << \"" \"" << nacci();\\n\\n        std::cout << std::endl;\\n    }\\n\\n    for ( unsigned int i = 2; i <= 10; ++i )\\n    {\\n        nacci_t lucas( i, 2, 1 ); // Lucas sequence \\n\\n        std::cout << \""lucas( \"" << i << \"" ): \"";\\n\\n        for ( int j = 0; j < 10; ++j )\\n            std::cout << \"" \"" << lucas();\\n\\n        std::cout << std::endl;\\n    }\\n}\\n"
"C++","Fibonacci_sequence","The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:\\n\\nWrite a function to generate the    nth    Fibonacci number.\\nSolutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).\\nThe sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:\\nsupport for negative      n      in the solution is optional.\\n\\n\\n\\nFor maximum compatibility, programs use only the basic instruction set.\\n","#include <iostream>\\n\\nint main()\\n{\\n        unsigned int a = 1, b = 1;\\n        unsigned int target = 48;\\n        for(unsigned int n = 3; n <= target; ++n)\\n        {\\n                unsigned int fib = a + b;\\n                std::cout << \""F(\""<< n << \"") = \"" << fib << std::endl;\\n                a = b;\\n                b = fib;\\n        }\\n\\n        return 0;\\n}"
"C++","Fibonacci_sequence","The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:\\n\\nWrite a function to generate the    nth    Fibonacci number.\\nSolutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).\\nThe sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:\\nsupport for negative      n      in the solution is optional.\\n\\n\\n\\nFor maximum compatibility, programs use only the basic instruction set.\\n","#include <iostream>\\n#include <gmpxx.h>\\n\\nint main()\\n{\\n        mpz_class a = mpz_class(1), b = mpz_class(1);\\n        mpz_class target = mpz_class(100);\\n        for(mpz_class n = mpz_class(3); n <= target; ++n)\\n        {\\n                mpz_class fib = b + a;\\n                if ( fib < b )\\n                {\\n                        std::cout << \""Overflow at \"" << n << std::endl;\\n                        break;\\n                }\\n                std::cout << \""F(\""<< n << \"") = \"" << fib << std::endl;\\n                a = b;\\n                b = fib;\\n        }\\n        return 0;\\n}"
"C++","Fibonacci_sequence","The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:\\n\\nWrite a function to generate the    nth    Fibonacci number.\\nSolutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).\\nThe sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:\\nsupport for negative      n      in the solution is optional.\\n\\n\\n\\nFor maximum compatibility, programs use only the basic instruction set.\\n","#include <algorithm>\\n#include <vector>\\n#include <functional>\\n#include <iostream>\\n \\nunsigned int fibonacci(unsigned int n) {\\n  if (n == 0) return 0;\\n  std::vector<int> v(n+1);\\n  v[1] = 1;\\n  transform(v.begin(), v.end()-2, v.begin()+1, v.begin()+2, std::plus<int>());\\n  // \""v\"" now contains the Fibonacci sequence from 0 up\\n  return v[n];\\n}"
"C++","Fibonacci_sequence","The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:\\n\\nWrite a function to generate the    nth    Fibonacci number.\\nSolutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).\\nThe sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:\\nsupport for negative      n      in the solution is optional.\\n\\n\\n\\nFor maximum compatibility, programs use only the basic instruction set.\\n","#include <numeric>\\n#include <vector>\\n#include <functional>\\n#include <iostream>\\n\\nunsigned int fibonacci(unsigned int n) {\\n  if (n == 0) return 0;\\n  std::vector<int> v(n, 1);\\n  adjacent_difference(v.begin(), v.end()-1, v.begin()+1, std::plus<int>());\\n  // \""array\"" now contains the Fibonacci sequence from 1 up\\n  return v[n-1];\\n}\\n"
"C++","Fibonacci_sequence","The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:\\n\\nWrite a function to generate the    nth    Fibonacci number.\\nSolutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).\\nThe sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:\\nsupport for negative      n      in the solution is optional.\\n\\n\\n\\nFor maximum compatibility, programs use only the basic instruction set.\\n","#include <iostream>\\n\\ntemplate  struct fibo\\n{\\n    enum {value=fibo<n-1>::value+fibo<n-2>::value};\\n};\\n \\ntemplate <> struct fibo<0>\\n{\\n    enum {value=0};\\n};\\n\\ntemplate <> struct fibo<1>\\n{\\n    enum {value=1};\\n};\\n\\n\\nint main(int argc, char const *argv[])\\n{\\n    std::cout<\\n\\nThe following version is based on fast exponentiation:\\n#include <iostream>\\n\\ninline void fibmul(int* f, int* g)\\n{\\n  int tmp = f[0]*g[0] + f[1]*g[1];\\n  f[1] = f[0]*g[1] + f[1]*(g[0] + g[1]);\\n  f[0] = tmp;\\n}\\n\\nint fibonacci(int n)\\n{\\n  int f[] = { 1, 0 };\\n  int g[] = { 0, 1 };\\n  while (n > 0)\\n  {\\n    if (n & 1) // n odd\\n    {\\n      fibmul(f, g);\\n      --n;\\n    }\\n    else\\n    {\\n      fibmul(g, g);\\n      n >>= 1;\\n    }\\n  }\\n  return f[1];\\n}\\n\\nint main()\\n{\\n  for (int i = 0; i < 20; ++i)\\n    std::cout << fibonacci(i) << \"" \"";\\n  std::cout << std::endl;\\n}\\n{{out}}\\n 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181\\n===Using Zeckendorf Numbers===\\nThe nth fibonacci is represented as Zeckendorf 1 followed by n-1 zeroes. [[Zeckendorf number representation#Using a C++11 User Defined Literal|Here]] I define a class N which defines the operations increment ++() and comparison <=(other N) for Zeckendorf Numbers.\\n\\n// Use Zeckendorf numbers to display Fibonacci sequence.\\n// Nigel Galloway October 23rd., 2012\\nint main(void) {\\n  char NG[22] = {'1',0};\\n  int x = -1;\\n  N G;\\n  for (int fibs = 1; fibs <= 20; fibs++) {\\n   for (;G <= N(NG); ++G) x++;\\n   NG[fibs] = '0';\\n   NG[fibs+1] = 0;\\n   std::cout << x << \"" \"";\\n  }\\n  std::cout << std::endl;\\n  return 0;\\n}\\n\\n{{out}}\\n<pre>\\n1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946\\n"
"C++","Fibonacci_sequence","The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:\\n\\nWrite a function to generate the    nth    Fibonacci number.\\nSolutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).\\nThe sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:\\nsupport for negative      n      in the solution is optional.\\n\\n\\n\\nFor maximum compatibility, programs use only the basic instruction set.\\n","#include <iostream>\\n\\ninline void fibmul(int* f, int* g)\\n{\\n  int tmp = f[0]*g[0] + f[1]*g[1];\\n  f[1] = f[0]*g[1] + f[1]*(g[0] + g[1]);\\n  f[0] = tmp;\\n}\\n\\nint fibonacci(int n)\\n{\\n  int f[] = { 1, 0 };\\n  int g[] = { 0, 1 };\\n  while (n > 0)\\n  {\\n    if (n & 1) // n odd\\n    {\\n      fibmul(f, g);\\n      --n;\\n    }\\n    else\\n    {\\n      fibmul(g, g);\\n      n >>= 1;\\n    }\\n  }\\n  return f[1];\\n}\\n\\nint main()\\n{\\n  for (int i = 0; i < 20; ++i)\\n    std::cout << fibonacci(i) << \"" \"";\\n  std::cout << std::endl;\\n}"
"C++","Fibonacci_sequence","The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:\\n\\nWrite a function to generate the    nth    Fibonacci number.\\nSolutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).\\nThe sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:\\nsupport for negative      n      in the solution is optional.\\n\\n\\n\\nFor maximum compatibility, programs use only the basic instruction set.\\n","\\n// Use Zeckendorf numbers to display Fibonacci sequence.\\n// Nigel Galloway October 23rd., 2012\\nint main(void) {\\n  char NG[22] = {'1',0};\\n  int x = -1;\\n  N G;\\n  for (int fibs = 1; fibs <= 20; fibs++) {\\n   for (;G <= N(NG); ++G) x++;\\n   NG[fibs] = '0';\\n   NG[fibs+1] = 0;\\n   std::cout << x << \"" \"";\\n  }\\n  std::cout << std::endl;\\n  return 0;\\n}\\n"
"C++","Fibonacci_sequence","The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:\\n\\nWrite a function to generate the    nth    Fibonacci number.\\nSolutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).\\nThe sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:\\nsupport for negative      n      in the solution is optional.\\n\\n\\n\\nFor maximum compatibility, programs use only the basic instruction set.\\n","\\n// Use Standard Template Library to display Fibonacci sequence.\\n// Nigel Galloway March 30th., 2013\\n#include <algorithm>\\n#include <iostream>\\n#include <iterator>\\nint main()\\n{\\n   int x = 1, y = 1;\\n   generate_n(std::ostream_iterator<int>(std::cout, \"" \""), 21, [&]{int n=x; x=y; y+=n; return n;});\\n   return 0;\\n}\\n"
"C++","Fibonacci_word","The   Fibonacci Word   may be created in a manner analogous to the   Fibonacci Sequence   as described here:\\n\\nPerform the above steps for     n = 37.\\nYou may display the first few but not the larger values of   n.\\n{Doing so will get the task's author into trouble with them what be (again!).} \\nInstead, create a table for   F_Words   1   to   37   which shows:\\n\\n\\nOutput\\n","#include <string>\\n#include <map>\\n#include <iostream>\\n#include <algorithm>\\n#include <cmath>\\n#include <iomanip>\\n\\ndouble log2( double number ) {\\n   return ( log( number ) / log( 2 ) ) ;\\n}\\n\\ndouble find_entropy( std::string & fiboword ) {\\n   std::map frequencies ;\\n   std::for_each( fiboword.begin( ) , fiboword.end( ) ,\\n	 [ & frequencies ]( char c ) { frequencies[ c ]++ ; } ) ; \\n   int numlen = fiboword.length( ) ;\\n   double infocontent = 0 ;\\n   for ( std::pair p : frequencies ) {\\n      double freq = static_cast<double>( p.second ) / numlen ;\\n      infocontent += freq * log2( freq ) ;\\n   }\\n   infocontent *= -1 ;\\n   return infocontent ;\\n}\\n\\nvoid printLine( std::string &fiboword , int n ) {\\n   std::cout << std::setw( 5 ) << std::left << n ;\\n   std::cout << std::setw( 12 ) << std::right << fiboword.size( ) ;\\n   std::cout << \""  \"" << std::setw( 16 ) << std::setprecision( 13 ) \\n      << std::left << find_entropy( fiboword ) ;\\n   std::cout << \""\\n\"" ;\\n}\\n\\nint main( ) {\\n   std::cout << std::setw( 5 ) << std::left << \""N\"" ;\\n   std::cout << std::setw( 12 ) << std::right << \""length\"" ;\\n   std::cout << \""  \"" << std::setw( 16 ) << std::left << \""entropy\"" ; \\n   std::cout << \""\\n\"" ;\\n   std::string firststring ( \""1\"" ) ;\\n   int n = 1 ;\\n   printLine( firststring , n ) ;\\n   std::string secondstring( \""0\"" ) ;\\n   n++ ;\\n   printLine( secondstring , n ) ;\\n   while ( n < 37 ) {\\n      std::string resultstring = firststring + secondstring ;\\n      firststring.assign( secondstring ) ;\\n      secondstring.assign( resultstring ) ;\\n      n++ ;\\n      printLine( resultstring , n ) ;\\n   }\\n   return 0 ;\\n}"
"C++","Fibonacci_word/fractal","The Fibonacci word may be represented as a fractal as described here:\\n\\nCreate and display a fractal similar to Fig 1.\\n\\nPrints F_Word30 currently. Segment length and F_Wordn can be adjusted.\\nWrites an EPS file that has the 26th fractal. This is probably cheating.\\nThis uses the turtle module from the Dragon Curve Task, and the module from the Grayscale Image task.\\nIt prints the level 25 word as the Python entry.\\nOutput is same as Ruby.\\nWe output an SVG or rather an HTML with an embedded SVGPoints to note:","\\n#include <windows.h>\\n#include <string>\\nusing namespace std;\\n\\nclass myBitmap\\n{\\npublic:\\n    myBitmap() : pen( NULL ) {}\\n    ~myBitmap()\\n    {\\n        DeleteObject( pen );\\n        DeleteDC( hdc );\\n        DeleteObject( bmp );\\n    }\\n \\n    bool create( int w, int h )\\n    {\\n        BITMAPINFO	bi;\\n        ZeroMemory( &bi, sizeof( bi ) );\\n        bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );\\n        bi.bmiHeader.biBitCount	   = sizeof( DWORD ) * 8;\\n	bi.bmiHeader.biCompression = BI_RGB;\\n	bi.bmiHeader.biPlanes	   = 1;\\n	bi.bmiHeader.biWidth	   =  w;\\n	bi.bmiHeader.biHeight	   = -h;\\n	HDC dc = GetDC( GetConsoleWindow() );\\n	bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );\\n	if( !bmp ) return false;\\n	hdc = CreateCompatibleDC( dc );\\n	SelectObject( hdc, bmp );\\n	ReleaseDC( GetConsoleWindow(), dc ); \\n	width = w; height = h;\\n	clear();\\n	return true;\\n    }\\n \\n    void clear()\\n    {\\n	ZeroMemory( pBits, width * height * sizeof( DWORD ) );\\n    }\\n \\n    void setPenColor( DWORD clr )\\n    {\\n	if( pen ) DeleteObject( pen );\\n	pen = CreatePen( PS_SOLID, 1, clr );\\n	SelectObject( hdc, pen );\\n    }\\n \\n    void saveBitmap( string path )\\n    {\\n	BITMAPFILEHEADER fileheader;\\n	BITMAPINFO	 infoheader;\\n	BITMAP		 bitmap;\\n	DWORD*		 dwpBits;\\n	DWORD		 wb;\\n	HANDLE		 file;\\n \\n	GetObject( bmp, sizeof( bitmap ), &bitmap );\\n	dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];\\n	ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );\\n	ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );\\n	ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );\\n \\n	infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;\\n	infoheader.bmiHeader.biCompression = BI_RGB;\\n	infoheader.bmiHeader.biPlanes = 1;\\n	infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );\\n	infoheader.bmiHeader.biHeight = bitmap.bmHeight;\\n	infoheader.bmiHeader.biWidth = bitmap.bmWidth;\\n	infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );\\n \\n	fileheader.bfType    = 0x4D42;\\n	fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );\\n	fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;\\n \\n	GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );\\n \\n	file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );\\n	WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );\\n	WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );\\n	WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );\\n	CloseHandle( file );\\n \\n	delete [] dwpBits;\\n    }\\n \\n    HDC getDC()     { return hdc; }\\n    int getWidth()  { return width; }\\n    int getHeight() { return height; }\\n \\nprivate:\\n    HBITMAP bmp;\\n    HDC	    hdc;\\n    HPEN    pen;\\n    void    *pBits;\\n    int	    width, height;\\n};\\nclass fiboFractal\\n{\\npublic:\\n    fiboFractal( int l )\\n    {\\n	bmp.create( 600, 440 );\\n	bmp.setPenColor( 0x00ff00 );\\n	createWord( l ); createFractal();\\n	bmp.saveBitmap( \""path_to_save_bitmap\"" );\\n    }\\nprivate:\\n    void createWord( int l )\\n    {\\n	string a = \""1\"", b = \""0\"", c;\\n	l -= 2;\\n	while( l-- )\\n	{ c = b + a; a = b; b = c; }\\n	fWord = c;\\n    }\\n\\n    void createFractal()\\n    {\\n	int n = 1, px = 10, dir, \\n	    py = 420, len = 1, \\n	    x = 0, y = -len, goingTo = 0;\\n\\n	HDC dc = bmp.getDC();\\n	MoveToEx( dc, px, py, NULL );\\n	for( string::iterator si = fWord.begin(); si != fWord.end(); si++ )\\n	{\\n	    px += x; py += y;\\n	    LineTo( dc, px, py );\\n	    if( !( *si - 48 ) )\\n	    {	// odd\\n		if( n & 1 ) dir = 1;	// right\\n		else dir = 0;			// left\\n		switch( goingTo )\\n		{\\n		    case 0: // up\\n		        y = 0;\\n			if( dir ){ x = len; goingTo = 1; }\\n			else { x = -len; goingTo = 3; }\\n		    break;\\n		    case 1: // right\\n			x = 0;\\n			if( dir ) { y = len; goingTo = 2; }\\n			else { y = -len; goingTo = 0; }\\n		    break;\\n		    case 2: // down\\n			y = 0;\\n			if( dir ) { x = -len; goingTo = 3; }\\n			else { x = len; goingTo = 1; }\\n		    break;\\n		    case 3: // left\\n			x = 0;\\n			if( dir ) { y = -len; goingTo = 0; }\\n			else { y = len; goingTo = 2; }\\n		}\\n            }\\n	    n++;\\n        }\\n    }\\n\\n    string fWord;\\n    myBitmap bmp;\\n};\\nint main( int argc, char* argv[] )\\n{\\n    fiboFractal ff( 23 );\\n    return system( \""pause\"" );\\n}\\n"
"C++","File_input/output","Create a file called   \""output.txt\"",   and place in it the contents of the file   \""input.txt\"",   via an intermediate variable.\\nIn other words, your program will demonstrate:\\n\\nOneliners that skip the intermediate variable are of secondary interest — operating systems have copy commands for that.\\n\\nAssuming everything is fine and no error handling is required, this solution is sufficient:\\nExpanded with proper error handling and reporting it reads:\\nThe following example reads and writes each file one character at a time. (You should of course add error reporting as in the example above.)\\nThe following solution uses stream I/O. Any file of Ada.Text_IO can be used to obtain a corresponding stream. Reading and writing streams is more efficient than reading text files directly, because it skips formatting.\\nMethod 1: the input file can be processed line by line.\\nMethod 2: the input file can be read at once if it is less than 1 GB.\\nMethod 3: the file can be copied without I/O.\\nBinary I/O is possible with this library from Laszlo.\\n(This does not handle properly binary files)\\nThe spirit of Babel is to manipulate things on the stack whenever feasible. In this example,\\nI showed how to save it into a symbolic variable (foo) but this step would not be necessary\\nfor many simple file-processing tasks, such as splitting on newlines or spaces.\\nAlso note that the >>> (slurp) and <<< (spit) operators only handle \""small\"" files - the limit is\\nconfigurable but the default limit is 100MB. If you want to open very large files or if you need\\nto perform a lot of interactive file I/O, Babel provides operators that wrap the C standard library\\nfopen()/fclose() functions.\\nThis is only meant to copy a sequential text file. It is very unlikely that this works copying a random access text file.\\nor\\nor\\nThere may be other techniques too.\\nBBC BASIC for Windows has a file copy command:\\nAlternatively the copy can be done explicitly:\\nThis linear program tries to open \""input.txt\"" as text file (or aborts).\\nIt then writes the content in text mode (i.e. minus trailing spaces) to \""output.txt\"" (or aborts).\\nA couple of remarks on the preceding example:\\nIt uses fgetc to read one character at a time. Each character is visited, even though there's nothing to do with it. Copying bigger blocks of data is much more efficient.\\nThe following example addresses those issues. To avoid buffered I/O, it uses open(), read(), write() and close(), which are part of POSIX.\\nThe long way:\\nThe short way:\\nSimpler version:\\nUsing istream- and ostream- iterators:\\nEven simpler way:\\nDefine a function that copies the content from one file to another.\\nApply this function to the world to copy a file.\\nFlags used for Micro Focus COBOL:\\nBy lines:\\nBy arbitrary blocks and for possibly-binary files:\\nIf you're on an odd platform which actually stores text/binary/... type information for files and your CL implementation will use this information, then in should be opened with :element-type :default.\\nvery plainly, with an intermediate variable:\\nvia an intermediate buffer variable:\\nCopy the content from one file to another (exceptions are handled by Tango):\\nOr a shorter example without explicitly closing the output file:\\nDelphi supports both typed and untyped as well as a textfile type for files. Delphi provides a default 128 byte buffer for text files. This may be enlarged via a call to SetTextBuff(Var F: Text; Var Buf [Size : integer]) procedure. All other files have no buffer at all and it is the programmers option to do buffering.\\nThe following file I/O procedures have existed since Turbo Pascal V-3.\\nFiles are opened using:\\nAssignFile(f,{fully qualified path and file name})\\nAssigns the file name to the file structure in preparation for opening.\\nReset(f)\\nOpens and existing file. If it does not exist EIOError is raised.\\nRewrite(f)\\nCreates a new file and opens it for I/O. If the files exists is is overwritten.\\nDelphi implemented Streams of which a variant is TFileStream and are very closely related to the Windows API for file handling.\\n- Text File I/O -\\n\\n- Untyped File I/O -\\nThis is perhaps one of the most powerful I/O functions built into Pascal. This will allow you to open and read a file of ANY type, regardless of structure, size or content. Note the usage of Reset(). This is using the optional size parameter that instructs the record size of file I/O. This could have been called with SizeOf(Buff) as the optional parameter but that would have limited flexibility. Calling it with a size of ONE byte allows you to adjust the buffer size on the fly, as conditions warrant. Also note the use of the BytesRead parameter. When included in the BlockRead() function it will return the number of bytes actually read. If this is not included, then if your directive to read n bytes is greater then the size of the file, the EOF will be encountered unexpectedly and EIOError will be raised.\\n- Typed File I/O -\\nTyped file I/O is very useful when reading and writing structures. An Address List is quiet easy to write when using this type of I/O. The same file procedures are used with some subtle differences. Bite below in the blockread and blockwrite procedures that the bytes to read or write are 1. Also note that the reset procedure is not called with a buffer size. When performing Typed File I/O the size of the type definition is the buffer size. In the BlockRead() and BlockWrite() procedures I elected to read one record. Had I declared a very large buffer of type tAddressBook of say 500 records, I could have set bytes to read as SizeOf(Buffer) thereby reading a minimum of 500 records.\\n(This version holds the entire contents in memory.)\\nELENA 3.4 :\\nRead in the whole file and write the contents to a new file.\\nBuilt in function:\\nUsing an intermediate variable for the input file content is not ideomatic in functional programming. Nevertheless...\\nHolds entire file content in memory:\\nA bit longer, but only holds a small amount of data in memory. If opening the file for writing fails, we want to clean up the file that's open for reading:\\nPossibly cheating:\\nForth traditionally has not had any file handling capabilities, preferring instead to operate on a disk image block by block. Most modern Forth systems however run under an existing operating system and provide methods for disk access.\\nNote the use of \""2 pick\"" to get the input file handle and \""3 pick\"" to get the output file handle. Local or global variables could have been used, but in this implementation simple stack manipulation was chosen. Also, only maxstring bytes are copied at a time, and the global \""pad\"" memory area is used to hold the data. For faster copies, allocating a larger buffer could be advantageous.\\nAlso, abort\"" can be used instead of throw if desired.\\nA good practice is to ask the user the file name he wants to create like in this short example\\nIt uses the access=\""stream\"" which is defined in Fortran 2003 standard and should allow to \""copy\"" also binary data easily.\\n","#include <iostream>\\n#include <fstream>\\n#include <string>\\n\\nusing namespace std;\\n\\nint main() {\\n    string line;\\n    ifstream input ( \""input.txt\"" );\\n    ofstream output (\""output.txt\"");\\n    \\n    if (output.is_open()) {\\n        if (input.is_open()){\\n            while (getline (input,line)) {\\n                output << line << endl;\\n            }\\n            input.close(); // Not necessary - will be closed when variable goes out of scope.\\n        }\\n        else {\\n            cout << \""input.txt cannot be opened!\\n\"";\\n        }\\n        output.close(); // Not necessary - will be closed when variable goes out of scope.\\n    }\\n    else {\\n        cout << \""output.txt cannot be written to!\\n\"";\\n    }\\n    return 0;\\n}"
"C++","File_input/output","Create a file called   \""output.txt\"",   and place in it the contents of the file   \""input.txt\"",   via an intermediate variable.\\nIn other words, your program will demonstrate:\\n\\nOneliners that skip the intermediate variable are of secondary interest — operating systems have copy commands for that.\\n\\nAssuming everything is fine and no error handling is required, this solution is sufficient:\\nExpanded with proper error handling and reporting it reads:\\nThe following example reads and writes each file one character at a time. (You should of course add error reporting as in the example above.)\\nThe following solution uses stream I/O. Any file of Ada.Text_IO can be used to obtain a corresponding stream. Reading and writing streams is more efficient than reading text files directly, because it skips formatting.\\nMethod 1: the input file can be processed line by line.\\nMethod 2: the input file can be read at once if it is less than 1 GB.\\nMethod 3: the file can be copied without I/O.\\nBinary I/O is possible with this library from Laszlo.\\n(This does not handle properly binary files)\\nThe spirit of Babel is to manipulate things on the stack whenever feasible. In this example,\\nI showed how to save it into a symbolic variable (foo) but this step would not be necessary\\nfor many simple file-processing tasks, such as splitting on newlines or spaces.\\nAlso note that the >>> (slurp) and <<< (spit) operators only handle \""small\"" files - the limit is\\nconfigurable but the default limit is 100MB. If you want to open very large files or if you need\\nto perform a lot of interactive file I/O, Babel provides operators that wrap the C standard library\\nfopen()/fclose() functions.\\nThis is only meant to copy a sequential text file. It is very unlikely that this works copying a random access text file.\\nor\\nor\\nThere may be other techniques too.\\nBBC BASIC for Windows has a file copy command:\\nAlternatively the copy can be done explicitly:\\nThis linear program tries to open \""input.txt\"" as text file (or aborts).\\nIt then writes the content in text mode (i.e. minus trailing spaces) to \""output.txt\"" (or aborts).\\nA couple of remarks on the preceding example:\\nIt uses fgetc to read one character at a time. Each character is visited, even though there's nothing to do with it. Copying bigger blocks of data is much more efficient.\\nThe following example addresses those issues. To avoid buffered I/O, it uses open(), read(), write() and close(), which are part of POSIX.\\nThe long way:\\nThe short way:\\nSimpler version:\\nUsing istream- and ostream- iterators:\\nEven simpler way:\\nDefine a function that copies the content from one file to another.\\nApply this function to the world to copy a file.\\nFlags used for Micro Focus COBOL:\\nBy lines:\\nBy arbitrary blocks and for possibly-binary files:\\nIf you're on an odd platform which actually stores text/binary/... type information for files and your CL implementation will use this information, then in should be opened with :element-type :default.\\nvery plainly, with an intermediate variable:\\nvia an intermediate buffer variable:\\nCopy the content from one file to another (exceptions are handled by Tango):\\nOr a shorter example without explicitly closing the output file:\\nDelphi supports both typed and untyped as well as a textfile type for files. Delphi provides a default 128 byte buffer for text files. This may be enlarged via a call to SetTextBuff(Var F: Text; Var Buf [Size : integer]) procedure. All other files have no buffer at all and it is the programmers option to do buffering.\\nThe following file I/O procedures have existed since Turbo Pascal V-3.\\nFiles are opened using:\\nAssignFile(f,{fully qualified path and file name})\\nAssigns the file name to the file structure in preparation for opening.\\nReset(f)\\nOpens and existing file. If it does not exist EIOError is raised.\\nRewrite(f)\\nCreates a new file and opens it for I/O. If the files exists is is overwritten.\\nDelphi implemented Streams of which a variant is TFileStream and are very closely related to the Windows API for file handling.\\n- Text File I/O -\\n\\n- Untyped File I/O -\\nThis is perhaps one of the most powerful I/O functions built into Pascal. This will allow you to open and read a file of ANY type, regardless of structure, size or content. Note the usage of Reset(). This is using the optional size parameter that instructs the record size of file I/O. This could have been called with SizeOf(Buff) as the optional parameter but that would have limited flexibility. Calling it with a size of ONE byte allows you to adjust the buffer size on the fly, as conditions warrant. Also note the use of the BytesRead parameter. When included in the BlockRead() function it will return the number of bytes actually read. If this is not included, then if your directive to read n bytes is greater then the size of the file, the EOF will be encountered unexpectedly and EIOError will be raised.\\n- Typed File I/O -\\nTyped file I/O is very useful when reading and writing structures. An Address List is quiet easy to write when using this type of I/O. The same file procedures are used with some subtle differences. Bite below in the blockread and blockwrite procedures that the bytes to read or write are 1. Also note that the reset procedure is not called with a buffer size. When performing Typed File I/O the size of the type definition is the buffer size. In the BlockRead() and BlockWrite() procedures I elected to read one record. Had I declared a very large buffer of type tAddressBook of say 500 records, I could have set bytes to read as SizeOf(Buffer) thereby reading a minimum of 500 records.\\n(This version holds the entire contents in memory.)\\nELENA 3.4 :\\nRead in the whole file and write the contents to a new file.\\nBuilt in function:\\nUsing an intermediate variable for the input file content is not ideomatic in functional programming. Nevertheless...\\nHolds entire file content in memory:\\nA bit longer, but only holds a small amount of data in memory. If opening the file for writing fails, we want to clean up the file that's open for reading:\\nPossibly cheating:\\nForth traditionally has not had any file handling capabilities, preferring instead to operate on a disk image block by block. Most modern Forth systems however run under an existing operating system and provide methods for disk access.\\nNote the use of \""2 pick\"" to get the input file handle and \""3 pick\"" to get the output file handle. Local or global variables could have been used, but in this implementation simple stack manipulation was chosen. Also, only maxstring bytes are copied at a time, and the global \""pad\"" memory area is used to hold the data. For faster copies, allocating a larger buffer could be advantageous.\\nAlso, abort\"" can be used instead of throw if desired.\\nA good practice is to ask the user the file name he wants to create like in this short example\\nIt uses the access=\""stream\"" which is defined in Fortran 2003 standard and should allow to \""copy\"" also binary data easily.\\n","#include <iostream>\\n#include <fstream>\\n#include <cstdlib>\\n\\nint main()\\n{\\n  std::ifstream input(\""input.txt\"");\\n  if (!input.is_open())\\n  {\\n    std::cerr << \""could not open input.txt for reading.\\n\"";\\n    return EXIT_FAILURE;\\n  }\\n  \\n  std::ofstream output(\""output.txt\"");\\n  if (!output.is_open())\\n  {\\n    std::cerr << \""could not open output.txt for writing.\\n\"";\\n    return EXIT_FAILURE;\\n  }\\n  \\n  output << input.rdbuf();\\n  if (!output)\\n  {\\n    std::cerr << \""error copying the data.\\n\"";\\n    return EXIT_FAILURE;\\n  }\\n  \\n  return EXIT_SUCCESS;\\n}"
"C++","File_input/output","Create a file called   \""output.txt\"",   and place in it the contents of the file   \""input.txt\"",   via an intermediate variable.\\nIn other words, your program will demonstrate:\\n\\nOneliners that skip the intermediate variable are of secondary interest — operating systems have copy commands for that.\\n\\nAssuming everything is fine and no error handling is required, this solution is sufficient:\\nExpanded with proper error handling and reporting it reads:\\nThe following example reads and writes each file one character at a time. (You should of course add error reporting as in the example above.)\\nThe following solution uses stream I/O. Any file of Ada.Text_IO can be used to obtain a corresponding stream. Reading and writing streams is more efficient than reading text files directly, because it skips formatting.\\nMethod 1: the input file can be processed line by line.\\nMethod 2: the input file can be read at once if it is less than 1 GB.\\nMethod 3: the file can be copied without I/O.\\nBinary I/O is possible with this library from Laszlo.\\n(This does not handle properly binary files)\\nThe spirit of Babel is to manipulate things on the stack whenever feasible. In this example,\\nI showed how to save it into a symbolic variable (foo) but this step would not be necessary\\nfor many simple file-processing tasks, such as splitting on newlines or spaces.\\nAlso note that the >>> (slurp) and <<< (spit) operators only handle \""small\"" files - the limit is\\nconfigurable but the default limit is 100MB. If you want to open very large files or if you need\\nto perform a lot of interactive file I/O, Babel provides operators that wrap the C standard library\\nfopen()/fclose() functions.\\nThis is only meant to copy a sequential text file. It is very unlikely that this works copying a random access text file.\\nor\\nor\\nThere may be other techniques too.\\nBBC BASIC for Windows has a file copy command:\\nAlternatively the copy can be done explicitly:\\nThis linear program tries to open \""input.txt\"" as text file (or aborts).\\nIt then writes the content in text mode (i.e. minus trailing spaces) to \""output.txt\"" (or aborts).\\nA couple of remarks on the preceding example:\\nIt uses fgetc to read one character at a time. Each character is visited, even though there's nothing to do with it. Copying bigger blocks of data is much more efficient.\\nThe following example addresses those issues. To avoid buffered I/O, it uses open(), read(), write() and close(), which are part of POSIX.\\nThe long way:\\nThe short way:\\nSimpler version:\\nUsing istream- and ostream- iterators:\\nEven simpler way:\\nDefine a function that copies the content from one file to another.\\nApply this function to the world to copy a file.\\nFlags used for Micro Focus COBOL:\\nBy lines:\\nBy arbitrary blocks and for possibly-binary files:\\nIf you're on an odd platform which actually stores text/binary/... type information for files and your CL implementation will use this information, then in should be opened with :element-type :default.\\nvery plainly, with an intermediate variable:\\nvia an intermediate buffer variable:\\nCopy the content from one file to another (exceptions are handled by Tango):\\nOr a shorter example without explicitly closing the output file:\\nDelphi supports both typed and untyped as well as a textfile type for files. Delphi provides a default 128 byte buffer for text files. This may be enlarged via a call to SetTextBuff(Var F: Text; Var Buf [Size : integer]) procedure. All other files have no buffer at all and it is the programmers option to do buffering.\\nThe following file I/O procedures have existed since Turbo Pascal V-3.\\nFiles are opened using:\\nAssignFile(f,{fully qualified path and file name})\\nAssigns the file name to the file structure in preparation for opening.\\nReset(f)\\nOpens and existing file. If it does not exist EIOError is raised.\\nRewrite(f)\\nCreates a new file and opens it for I/O. If the files exists is is overwritten.\\nDelphi implemented Streams of which a variant is TFileStream and are very closely related to the Windows API for file handling.\\n- Text File I/O -\\n\\n- Untyped File I/O -\\nThis is perhaps one of the most powerful I/O functions built into Pascal. This will allow you to open and read a file of ANY type, regardless of structure, size or content. Note the usage of Reset(). This is using the optional size parameter that instructs the record size of file I/O. This could have been called with SizeOf(Buff) as the optional parameter but that would have limited flexibility. Calling it with a size of ONE byte allows you to adjust the buffer size on the fly, as conditions warrant. Also note the use of the BytesRead parameter. When included in the BlockRead() function it will return the number of bytes actually read. If this is not included, then if your directive to read n bytes is greater then the size of the file, the EOF will be encountered unexpectedly and EIOError will be raised.\\n- Typed File I/O -\\nTyped file I/O is very useful when reading and writing structures. An Address List is quiet easy to write when using this type of I/O. The same file procedures are used with some subtle differences. Bite below in the blockread and blockwrite procedures that the bytes to read or write are 1. Also note that the reset procedure is not called with a buffer size. When performing Typed File I/O the size of the type definition is the buffer size. In the BlockRead() and BlockWrite() procedures I elected to read one record. Had I declared a very large buffer of type tAddressBook of say 500 records, I could have set bytes to read as SizeOf(Buffer) thereby reading a minimum of 500 records.\\n(This version holds the entire contents in memory.)\\nELENA 3.4 :\\nRead in the whole file and write the contents to a new file.\\nBuilt in function:\\nUsing an intermediate variable for the input file content is not ideomatic in functional programming. Nevertheless...\\nHolds entire file content in memory:\\nA bit longer, but only holds a small amount of data in memory. If opening the file for writing fails, we want to clean up the file that's open for reading:\\nPossibly cheating:\\nForth traditionally has not had any file handling capabilities, preferring instead to operate on a disk image block by block. Most modern Forth systems however run under an existing operating system and provide methods for disk access.\\nNote the use of \""2 pick\"" to get the input file handle and \""3 pick\"" to get the output file handle. Local or global variables could have been used, but in this implementation simple stack manipulation was chosen. Also, only maxstring bytes are copied at a time, and the global \""pad\"" memory area is used to hold the data. For faster copies, allocating a larger buffer could be advantageous.\\nAlso, abort\"" can be used instead of throw if desired.\\nA good practice is to ask the user the file name he wants to create like in this short example\\nIt uses the access=\""stream\"" which is defined in Fortran 2003 standard and should allow to \""copy\"" also binary data easily.\\n","# include <algorithm>\\n# include <fstream>\\n\\nint main() {\\n  std::ifstream ifile(\""input.txt\"");\\n  std::ofstream ofile(\""output.txt\"");\\n  std::copy(std::istreambuf_iterator<char>(ifile),\\n            std::istreambuf_iterator<char>(),\\n            std::ostreambuf_iterator<char>(ofile));\\n}"
"C++","File_input/output","Create a file called   \""output.txt\"",   and place in it the contents of the file   \""input.txt\"",   via an intermediate variable.\\nIn other words, your program will demonstrate:\\n\\nOneliners that skip the intermediate variable are of secondary interest — operating systems have copy commands for that.\\n\\nAssuming everything is fine and no error handling is required, this solution is sufficient:\\nExpanded with proper error handling and reporting it reads:\\nThe following example reads and writes each file one character at a time. (You should of course add error reporting as in the example above.)\\nThe following solution uses stream I/O. Any file of Ada.Text_IO can be used to obtain a corresponding stream. Reading and writing streams is more efficient than reading text files directly, because it skips formatting.\\nMethod 1: the input file can be processed line by line.\\nMethod 2: the input file can be read at once if it is less than 1 GB.\\nMethod 3: the file can be copied without I/O.\\nBinary I/O is possible with this library from Laszlo.\\n(This does not handle properly binary files)\\nThe spirit of Babel is to manipulate things on the stack whenever feasible. In this example,\\nI showed how to save it into a symbolic variable (foo) but this step would not be necessary\\nfor many simple file-processing tasks, such as splitting on newlines or spaces.\\nAlso note that the >>> (slurp) and <<< (spit) operators only handle \""small\"" files - the limit is\\nconfigurable but the default limit is 100MB. If you want to open very large files or if you need\\nto perform a lot of interactive file I/O, Babel provides operators that wrap the C standard library\\nfopen()/fclose() functions.\\nThis is only meant to copy a sequential text file. It is very unlikely that this works copying a random access text file.\\nor\\nor\\nThere may be other techniques too.\\nBBC BASIC for Windows has a file copy command:\\nAlternatively the copy can be done explicitly:\\nThis linear program tries to open \""input.txt\"" as text file (or aborts).\\nIt then writes the content in text mode (i.e. minus trailing spaces) to \""output.txt\"" (or aborts).\\nA couple of remarks on the preceding example:\\nIt uses fgetc to read one character at a time. Each character is visited, even though there's nothing to do with it. Copying bigger blocks of data is much more efficient.\\nThe following example addresses those issues. To avoid buffered I/O, it uses open(), read(), write() and close(), which are part of POSIX.\\nThe long way:\\nThe short way:\\nSimpler version:\\nUsing istream- and ostream- iterators:\\nEven simpler way:\\nDefine a function that copies the content from one file to another.\\nApply this function to the world to copy a file.\\nFlags used for Micro Focus COBOL:\\nBy lines:\\nBy arbitrary blocks and for possibly-binary files:\\nIf you're on an odd platform which actually stores text/binary/... type information for files and your CL implementation will use this information, then in should be opened with :element-type :default.\\nvery plainly, with an intermediate variable:\\nvia an intermediate buffer variable:\\nCopy the content from one file to another (exceptions are handled by Tango):\\nOr a shorter example without explicitly closing the output file:\\nDelphi supports both typed and untyped as well as a textfile type for files. Delphi provides a default 128 byte buffer for text files. This may be enlarged via a call to SetTextBuff(Var F: Text; Var Buf [Size : integer]) procedure. All other files have no buffer at all and it is the programmers option to do buffering.\\nThe following file I/O procedures have existed since Turbo Pascal V-3.\\nFiles are opened using:\\nAssignFile(f,{fully qualified path and file name})\\nAssigns the file name to the file structure in preparation for opening.\\nReset(f)\\nOpens and existing file. If it does not exist EIOError is raised.\\nRewrite(f)\\nCreates a new file and opens it for I/O. If the files exists is is overwritten.\\nDelphi implemented Streams of which a variant is TFileStream and are very closely related to the Windows API for file handling.\\n- Text File I/O -\\n\\n- Untyped File I/O -\\nThis is perhaps one of the most powerful I/O functions built into Pascal. This will allow you to open and read a file of ANY type, regardless of structure, size or content. Note the usage of Reset(). This is using the optional size parameter that instructs the record size of file I/O. This could have been called with SizeOf(Buff) as the optional parameter but that would have limited flexibility. Calling it with a size of ONE byte allows you to adjust the buffer size on the fly, as conditions warrant. Also note the use of the BytesRead parameter. When included in the BlockRead() function it will return the number of bytes actually read. If this is not included, then if your directive to read n bytes is greater then the size of the file, the EOF will be encountered unexpectedly and EIOError will be raised.\\n- Typed File I/O -\\nTyped file I/O is very useful when reading and writing structures. An Address List is quiet easy to write when using this type of I/O. The same file procedures are used with some subtle differences. Bite below in the blockread and blockwrite procedures that the bytes to read or write are 1. Also note that the reset procedure is not called with a buffer size. When performing Typed File I/O the size of the type definition is the buffer size. In the BlockRead() and BlockWrite() procedures I elected to read one record. Had I declared a very large buffer of type tAddressBook of say 500 records, I could have set bytes to read as SizeOf(Buffer) thereby reading a minimum of 500 records.\\n(This version holds the entire contents in memory.)\\nELENA 3.4 :\\nRead in the whole file and write the contents to a new file.\\nBuilt in function:\\nUsing an intermediate variable for the input file content is not ideomatic in functional programming. Nevertheless...\\nHolds entire file content in memory:\\nA bit longer, but only holds a small amount of data in memory. If opening the file for writing fails, we want to clean up the file that's open for reading:\\nPossibly cheating:\\nForth traditionally has not had any file handling capabilities, preferring instead to operate on a disk image block by block. Most modern Forth systems however run under an existing operating system and provide methods for disk access.\\nNote the use of \""2 pick\"" to get the input file handle and \""3 pick\"" to get the output file handle. Local or global variables could have been used, but in this implementation simple stack manipulation was chosen. Also, only maxstring bytes are copied at a time, and the global \""pad\"" memory area is used to hold the data. For faster copies, allocating a larger buffer could be advantageous.\\nAlso, abort\"" can be used instead of throw if desired.\\nA good practice is to ask the user the file name he wants to create like in this short example\\nIt uses the access=\""stream\"" which is defined in Fortran 2003 standard and should allow to \""copy\"" also binary data easily.\\n","#include <fstream>\\n\\nint main()\\n{\\n  std::ifstream input(\""input.txt\"");\\n  std::ofstream output(\""output.txt\"");\\n  output << input.rdbuf();\\n}"
"C++","Filter","Select certain elements from an Array into a new Array in a generic way.\\n\\nTo demonstrate, select all even numbers from an Array.\\nAs an option, give a second solution which filters destructively,\\nby modifying the original Array rather than creating a new Array.\\n\\nActionscript 3\\nHere is a non-recursive solution:\\n","#include <vector>\\n#include <algorithm>\\n#include <functional>\\n#include <iterator>\\n#include <iostream>\\n\\nint main() {\\n  std::vector<int> ary;\\n  for (int i = 0; i < 10; i++)\\n    ary.push_back(i);\\n  std::vector<int> evens;\\n  std::remove_copy_if(ary.begin(), ary.end(), back_inserter(evens),\\n                      std::bind2nd(std::modulus<int>(), 2)); // filter copy\\n  std::copy(evens.begin(), evens.end(),\\n            std::ostream_iterator<int>(std::cout, \""\\n\""));\\n\\n  return 0;\\n}"
"C++","Filter","Select certain elements from an Array into a new Array in a generic way.\\n\\nTo demonstrate, select all even numbers from an Array.\\nAs an option, give a second solution which filters destructively,\\nby modifying the original Array rather than creating a new Array.\\n\\nActionscript 3\\nHere is a non-recursive solution:\\n","#include <vector>\\n#include <algorithm>\\n#include <iterator>\\n#include <iostream>\\n\\nusing namespace std;\\n\\nint main() {\\n  vector<int> ary = {1, 2, 3, 4, 5, 6, 7, 8, 9};\\n  vector<int> evens;\\n\\n  copy_if(ary.begin(), ary.end(), back_inserter(evens),\\n      [](int i) { return i % 2 == 0; });\\n\\n  // print result\\n  copy(evens.begin(), evens.end(), ostream_iterator<int>(cout, \""\\n\""));\\n}"
"C++","Find_common_directory_path","Create a routine that, given a set of strings representing directory paths and a single character directory separator, will return a string representing that part of the directory tree that is common to all the directories.\\nTest your routine using the forward slash '/' character as the directory separator and the following three strings as input paths:\\nNote: The resultant path should be the valid directory '/home/user1/tmp' and not the longest common string '/home/user1/tmp/cove'.\\nIf your language has a routine that performs this function (even if it does not have a changeable separator character), then mention it as part of the task.\\n\\n\\nOutput:\\nOutput:\\nMessage box shows:\\nPrints /home/user1/tmp.\\nThis version is a little smarter than the one above... but not much. This version could be turned into an actual useful utility by changing it to compare command-line parameters, instead of built-in data.\\nAlso, under FreeBASIC, the pathSep arg to commonPath$ could be made optional, or even system-dependent.\\n","#include <algorithm>\\n#include <iostream>\\n#include <string>\\n#include <vector>\\n\\nstd::string longestPath( const std::vector & , char ) ;\\n\\nint main( ) {\\n   std::string dirs[ ] = {\\n      \""/home/user1/tmp/coverage/test\"" ,\\n      \""/home/user1/tmp/covert/operator\"" ,\\n      \""/home/user1/tmp/coven/members\"" } ;\\n   std::vector myDirs ( dirs , dirs + 3 ) ;\\n   std::cout << \""The longest common path of the given directories is \""\\n             << longestPath( myDirs , '/' ) << \""!\\n\"" ;\\n   return 0 ;\\n}\\n\\nstd::string longestPath( const std::vector & dirs , char separator ) {\\n   std::vector::const_iterator vsi = dirs.begin( ) ;\\n   int maxCharactersCommon = vsi->length( ) ;\\n   std::string compareString = *vsi ;\\n   for ( vsi = dirs.begin( ) + 1 ; vsi != dirs.end( ) ; vsi++ ) {\\n      std::pair p = \\n	 std::mismatch( compareString.begin( ) , compareString.end( ) , vsi->begin( ) ) ;\\n      if (( p.first - compareString.begin( ) ) < maxCharactersCommon ) \\n	 maxCharactersCommon = p.first - compareString.begin( ) ;\\n   }\\n   std::string::size_type found = compareString.rfind( separator , maxCharactersCommon ) ;\\n   return compareString.substr( 0 , found ) ;\\n}"
"C++","Find_limit_of_recursion","Find the limit of recursion.\\n\\n","\\n#include <iostream>\\n \\nvoid recurse(unsigned int i)\\n{\\n  std::cout<\\n"
"C++","Find_the_intersection_of_a_line_with_a_plane","Find the point of intersection for the infinite ray with direction (0,-1,-1) passing through position (0, 0, 10) with the infinite plane with a normal vector of (0, 0, 1) and which passes through [0, 0, 5].\\nStraightforward application of the intersection formula, prints usage on incorrect invocation.\\nInvocation and output:\\n","#include <iostream>\\n#include <sstream>\\n\\nclass Vector3D {\\npublic:\\n	Vector3D(double x, double y, double z) {\\n		this->x = x;\\n		this->y = y;\\n		this->z = z;\\n	}\\n\\n	double dot(const Vector3D& rhs) const {\\n		return x * rhs.x + y * rhs.y + z * rhs.z;\\n	}\\n\\n	Vector3D operator-(const Vector3D& rhs) const {\\n		return Vector3D(x - rhs.x, y - rhs.y, z - rhs.z);\\n	}\\n\\n	Vector3D operator*(double rhs) const {\\n		return Vector3D(rhs*x, rhs*y, rhs*z);\\n	}\\n\\n	friend std::ostream& operator<<(std::ostream&, const Vector3D&);\\n\\nprivate:\\n	double x, y, z;\\n};\\n\\nstd::ostream & operator<<(std::ostream & os, const Vector3D &f) {\\n	std::stringstream ss;\\n	ss << \""(\"" << f.x << \"", \"" << f.y << \"", \"" << f.z << \"")\"";\\n	return os << ss.str();\\n}\\n\\nVector3D intersectPoint(Vector3D rayVector, Vector3D rayPoint, Vector3D planeNormal, Vector3D planePoint) {\\n	Vector3D diff = rayPoint - planePoint;\\n	double prod1 = diff.dot(planeNormal);\\n	double prod2 = rayVector.dot(planeNormal);\\n	double prod3 = prod1 / prod2;\\n	return rayPoint - rayVector * prod3;\\n}\\n\\nint main() {\\n	Vector3D rv = Vector3D(0.0, -1.0, -1.0);\\n	Vector3D rp = Vector3D(0.0, 0.0, 10.0);\\n	Vector3D pn = Vector3D(0.0, 0.0, 1.0);\\n	Vector3D pp = Vector3D(0.0, 0.0, 5.0);\\n	Vector3D ip = intersectPoint(rv, rp, pn, pp);\\n\\n	std::cout << \""The ray intersects the plane at \"" << ip << std::endl;\\n\\n	return 0;\\n}"
"C++","Find_the_intersection_of_two_lines","\\nFind the point of intersection of two lines in 2D.\\n\\nThe 1st line passes though    (4,0)    and    (6,10) .\\nThe 2nd line passes though    (0,3)    and    (10,7) .\\n\\nUsing \""school maths\"".\\n","#include <iostream>\\n#include <cmath>\\n#include <assert.h>\\nusing namespace std;\\n\\n/** Calculate determinant of matrix:\\n	[a b]\\n	[c d]\\n*/\\ninline double Det(double a, double b, double c, double d)\\n{\\n	return a*d - b*c;\\n}\\n\\n///Calculate intersection of two lines.\\n///\\return true if found, false if not found or error\\nbool LineLineIntersect(double x1, double y1, //Line 1 start\\n	double x2, double y2, //Line 1 end\\n	double x3, double y3, //Line 2 start\\n	double x4, double y4, //Line 2 end\\n	double &ixOut, double &iyOut) //Output \\n{\\n	double detL1 = Det(x1, y1, x2, y2);\\n	double detL2 = Det(x3, y3, x4, y4);\\n	double x1mx2 = x1 - x2;\\n	double x3mx4 = x3 - x4;\\n	double y1my2 = y1 - y2;\\n	double y3my4 = y3 - y4;\\n\\n	double xnom = Det(detL1, x1mx2, detL2, x3mx4);\\n	double ynom = Det(detL1, y1my2, detL2, y3my4);\\n	double denom = Det(x1mx2, y1my2, x3mx4, y3my4);\\n	if(denom == 0.0)//Lines don't seem to cross\\n	{\\n		ixOut = NAN;\\n		iyOut = NAN;\\n		return false;\\n	}\\n\\n	ixOut = xnom / denom;	\\n	iyOut = ynom / denom;\\n	if(!isfinite(ixOut) || !isfinite(iyOut)) //Probably a numerical issue\\n		return false;\\n\\n	return true; //All OK\\n}\\n\\nint main()\\n{\\n	// **Simple crossing diagonal lines**\\n\\n	//Line 1\\n	double x1=4.0, y1=0.0;\\n	double x2=6.0, y2=10.0;\\n	\\n	//Line 2\\n	double x3=0.0, y3=3.0;\\n	double x4=10.0, y4=7.0;\\n\\n	double ix = -1.0, iy = -1.0;\\n	bool result = LineLineIntersect(x1, y1, x2, y2, x3, y3, x4, y4, ix, iy);\\n	cout << \""result \"" <<  result << \"",\"" << ix << \"",\"" << iy << endl;\\n\\n	double eps = 1e-6;\\n	assert(result == true);\\n	assert(fabs(ix - 5.0) < eps);\\n	assert(fabs(iy - 5.0) < eps);\\n\\n}"
"C++","Find_the_missing_permutation","Listed above are all of the permutations of the symbols   A,   B,   C,   and   D,   except   for one permutation that's   not   listed.\\n\\nFind that missing permutation.\\n\\n\\n\\nVery compact version, thanks to the clever Perl 6 \""xor\"" algorithm.\\n","#include <algorithm>\\n#include <vector>\\n#include <set>\\n#include <iterator>\\n#include <iostream>\\n#include <string>\\n\\nstatic const std::string GivenPermutations[] = {\\n  \""ABCD\"",\""CABD\"",\""ACDB\"",\""DACB\"",\\n  \""BCDA\"",\""ACBD\"",\""ADCB\"",\""CDAB\"",\\n  \""DABC\"",\""BCAD\"",\""CADB\"",\""CDBA\"",\\n  \""CBAD\"",\""ABDC\"",\""ADBC\"",\""BDCA\"",\\n  \""DCBA\"",\""BACD\"",\""BADC\"",\""BDAC\"",\\n  \""CBDA\"",\""DBCA\"",\""DCAB\""\\n};\\nstatic const size_t NumGivenPermutations = sizeof(GivenPermutations) / sizeof(*GivenPermutations);\\n\\nint main()\\n{\\n    std::vector permutations;\\n    std::string initial = \""ABCD\"";\\n    permutations.push_back(initial);\\n\\n    while(true)\\n    {\\n        std::string p = permutations.back();\\n        std::next_permutation(p.begin(), p.end());\\n        if(p == permutations.front())\\n            break;\\n        permutations.push_back(p);\\n    }\\n\\n    std::vector missing;\\n    std::set given_permutations(GivenPermutations, GivenPermutations + NumGivenPermutations);\\n    std::set_difference(permutations.begin(), permutations.end(), given_permutations.begin(),\\n        given_permutations.end(), std::back_inserter(missing));\\n    std::copy(missing.begin(), missing.end(), std::ostream_iterator(std::cout, \""\\n\""));\\n    return 0;\\n}"
"C++","Finite_state_machine","A Finite state machine (FSM) is computational abstraction which maps a finite number of states to other states within the same set, via transitions. An FSM can only be in one state at any given moment. Transitions can either be explicit or implicit; explicit transitions are triggered by an input signal and implicit transitions by the internal state of the system (that is, the current state). Implicit transitions thus represent \""automatic\"" or sequenced states that are generally processed between explicit transitions (although they can also be used to provide an optional path when no valid transition exists for a given input signal).\\nConsider the model of a simple vending machine. The machine is initially in the \""ready\"" state, which maps to exactly two states in the following way:\\nThe variables in bold-face represent transitions. Any input signal not corresponding to one of those transitions can either trigger an error or be ignored. Otherwise, the current state is updated and the process is repeated. If, for example, a deposit input signal is encountered, the FSM will move to the \""waiting\"" state, which defines these transitions:\\nThe \""dispense\"" state defines only one transition:\\nNote, however, that in this example the \""refunding\"" state doesn't actually require input in order to move to the \""ready\"" state, so an implicit transition is defined as such:\\n\\nImplement a finite state machine which handles both explicit and implicit transitions. Then demonstrate an example which models some real-world process.\\n\\n\\nWorks with 1k of RAM.\\nThere doesn't seem much point, in BASIC, implementing a 'general' FSM that would accept a list of states and transition rules as parameters, because an unstructured BASIC program in essence already is that list.\\nWithin each state, if the transition is implicit we just GOTO the next state. If it is explicit, we loop until the user presses a key corresponding to a valid transition. Invalid inputs are ignored.\\nThe line 100 GOTO 110 is superfluous, because it would go there anyway; but it is worth including it in case we wanted to modify the program later and transition somewhere else out of the dispense state.\\nNote that the program uses no variables and makes no use of the return stack: all the state is expressed in the (so to speak) state.\\n","\\n#include <map>\\n \\ntemplate \\nclass finite_state_machine\\n{\\nprotected:\\n	State\\n		current;\\n	std::map>\\n		database;\\npublic:\\n	finite_state_machine()\\n	{	\\n		set(State());\\n	}\\n	void\\n		set(State const& state)\\n	{\\n		current = state;\\n	}\\n	State\\n		get() const\\n	{\\n		return current;\\n	}\\n	void\\n		clear()\\n	{\\n		database.clear();\\n	}\\n	void\\n		add(State const& state, Transition const& transition, State const& next)\\n	{\\n		database[state][transition] = next;\\n	}	\\n/*\\n	Add a state which is also it's own transition (and thus a link in a chain of sequences)\\n*/	\\n	void\\n		add(State const& state_and_transition, State const& next)\\n	{\\n		add(state_and_transition, state_and_transition, next);\\n	}\\n	bool\\n		process(Transition const& transition)\\n	{\\n		auto const&\\n			transitions = database[current],\\n			found = transitions.find(transition);\\n		if(found == transitions.end())\\n			return false;\\n		auto const&\\n			next = found->second;\\n		set(next);\\n		return true;\\n	}\\n/*\\n	Process so-called \""automatic transitions\"" (ie: sequencing)\\n*/\\n	bool\\n		process()\\n	{\\n		return process(get());\\n	}\\n/*\\n	A set of utility functions that may be helpful for displaying valid transitions to the user, etc...\\n*/	\\n	template \\n	bool\\n		get_valid_transitions(State const& state, PushBackContainer& container)\\n	{\\n		container.clear();\\n		auto const&\\n			found = database.find(state);\\n		if(found == database.end())\\n			return false;\\n		auto const&\\n			transitions = found->second;\\n		if(transitions.size() == 0)\\n			return false;\\n		for(auto const& iterator : transitions)\\n		{\\n			auto const& \\n				transition = iterator.first;\\n			container.push_back(transition);\\n		}\\n		return true;\\n	}\\n	template \\n	bool\\n		get_valid_transitions(Container& container)\\n	{\\n		return get_valid_transitions(get(), container);\\n	}\\n};\\n \\n/*\\n	Example usage: a simple vending machine\\n*/\\n \\n#include <string>\\n#include <vector>\\n#include <iostream>\\n \\nusing namespace\\n	std;\\nvoid\\n	print(string const& message)\\n{\\n	cout << message << endl;\\n}\\nint \\n	main() \\n{  \\n	finite_state_machine<string>\\n		machine;\\n	machine.add(\""ready\"", \""quit\"", \""exit\"");\\n	machine.add(\""ready\"", \""deposit\"", \""waiting\"");\\n	machine.add(\""waiting\"", \""select\"", \""dispense\"");\\n	machine.add(\""waiting\"", \""refund\"", \""refunding\"");\\n	machine.add(\""dispense\"", \""remove\"", \""ready\"");\\n	machine.add(\""refunding\"", \""ready\"");\\n	machine.set(\""ready\"");\\n	for(;;)\\n	{\\n		string\\n			state = machine.get();\\n		if(state == \""ready\"")\\n			print(\""Please deposit coins.\"");\\n		else if(state == \""waiting\"")\\n			print(\""Please select a product.\"");\\n		else if(state == \""dispense\"")\\n			print(\""Dispensed...please remove product from tray.\"");\\n		else if(state == \""refunding\"")\\n			print(\""Refunding money...\"");	\\n		else if(state == \""exit\"")\\n			break;\\n		else\\n			print(\""Internal error: unaccounted state '\"" + state + \""'!\"");\\n	/*\\n		Handle \""automatic\"" transitions\\n	*/\\n		if(machine.process())\\n			continue;\\n		vector<string>\\n			transitions;\\n		machine.get_valid_transitions(transitions);\\n		string\\n			options;\\n		for(auto const& transition : transitions)\\n		{\\n			if(!options.empty())\\n				options += \"", \"";\\n			options += transition;\\n		}\\n		print(\""[\"" + state + \""] Input the next transition (\"" + options + \""): \"");\\n		string\\n			transition;\\n		cout << \"" > \"";\\n		cin >> transition;\\n		if(!machine.process(transition))\\n			print( \""Error: invalid transition!\"");	\\n	}\\n}\\n"
"C++","Five_weekends","The month of October in 2010 has five Fridays, five Saturdays, and five Sundays.\\n\\n\\nAlgorithm suggestions\\n\\nExtra credit\\nCount and/or show all of the years which do not have at least one five-weekend month (there should be 29).\\n\\n\\nFor maximum compatibility, this program uses only the basic instruction set (S/360)\\nand two ASSIST macros (XDECO, XPRNT) to keep the code as short as possible.\\n","#include <vector>\\n#include \\n#include <algorithm>\\n#include <iostream>\\n#include <iterator>\\nusing namespace boost::gregorian ;\\n\\nvoid print( const date &d ) {\\n   std::cout << d.year( ) << \""-\"" << d.month( ) << \""\\n\"" ;\\n}\\n\\nint main( ) {\\n   greg_month longmonths[ ] = {Jan, Mar , May , Jul ,\\n      Aug , Oct , Dec } ;\\n   int monthssize = sizeof ( longmonths ) / sizeof (greg_month ) ;\\n   typedef std::vector<date> DateVector ;\\n   DateVector weekendmonster ;\\n   std::vector years_without_5we_months ;\\n   for ( unsigned short i = 1900 ; i < 2101 ; i++ ) {\\n      bool months_found = false ; //does a given year have 5 weekend months ?\\n      for ( int j = 0 ; j < monthssize ; j++ ) {\\n	 date d ( i , longmonths[ j ] , 1 ) ;\\n	 if ( d.day_of_week( ) == Friday ) {  //for the month to have 5 weekends\\n	    weekendmonster.push_back( d ) ;\\n	    if ( months_found == false )\\n	       months_found = true ;\\n         }\\n      }\\n      if ( months_found == false ) {\\n	 years_without_5we_months.push_back( i ) ;\\n      }\\n   }\\n   std::cout << \""Between 1900 and 2100 , there are \"" << weekendmonster.size( )\\n      << \"" months with 5 complete weekends!\\n\"" ;\\n   std::cout << \""Months with 5 complete weekends are:\\n\"" ;\\n   std::for_each( weekendmonster.begin( ) , weekendmonster.end( ) , print ) ;\\n   std::cout <<  years_without_5we_months.size( ) << \"" years had no months with 5 complete weekends!\\n\"" ;\\n   std::cout << \""These are:\\n\"" ;\\n   std::copy( years_without_5we_months.begin( ) , years_without_5we_months.end( ) ,\\n	 std::ostream_iterator( std::cout , \""\\n\"" ) ) ;\\n   std::cout << std::endl ;\\n   return 0 ;\\n}"
"C++","Fivenum","Many big data or scientific programs use boxplots to show distributions of data.   In addition, sometimes saving large arrays for boxplots can be impractical and use extreme amounts of RAM.   It can be useful to save large arrays as arrays with five numbers to save memory.\\nFor example, the   R   programming language implements Tukey's five-number summary as the fivenum function.\\n\\nGiven an array of numbers, compute the five-number summary.\\n\\nWhile these five numbers can be used to draw a boxplot, statistical packages will typically need extra data. Moreover, while there is a consensus about the \""box\"" of the boxplot, there are variations among statistical packages for the whiskers.\\n\\n","#include <algorithm>\\n#include <iostream>\\n#include <ostream>\\n#include <vector>\\n\\n/////////////////////////////////////////////////////////////////////////////\\n// The following is taken from https://cpplove.blogspot.com/2012/07/printing-tuples.html\\n\\n// Define a type which holds an unsigned integer value \\ntemplate struct int_ {};\\n\\ntemplate \\nstd::ostream& print_tuple(std::ostream& out, const Tuple& t, int_<Pos>) {\\n    out << std::get< std::tuple_size<Tuple>::value - Pos >(t) << \"", \"";\\n    return print_tuple(out, t, int_());\\n}\\n\\ntemplate \\nstd::ostream& print_tuple(std::ostream& out, const Tuple& t, int_<1>) {\\n    return out << std::get(t);\\n}\\n\\ntemplate \\nstd::ostream& operator<<(std::ostream& out, const std::tuple<Args...>& t) {\\n    out << '(';\\n    print_tuple(out, t, int_());\\n    return out << ')';\\n}\\n\\n/////////////////////////////////////////////////////////////////////////////\\n\\ntemplate \\ndouble median(RI beg, RI end) {\\n    if (beg == end) throw std::runtime_error(\""Range cannot be empty\"");\\n    auto len = end - beg;\\n    auto m = len / 2;\\n    if (len % 2 == 1) {\\n        return *(beg + m);\\n    }\\n\\n    return (beg[m - 1] + beg[m]) / 2.0;\\n}\\n\\ntemplate \\nauto fivenum(C& c) {\\n    std::sort(c.begin(), c.end());\\n\\n    auto cbeg = c.cbegin();\\n    auto cend = c.cend();\\n\\n    auto len = cend - cbeg;\\n    auto m = len / 2;\\n    auto lower = (len % 2 == 1) ? m : m - 1;\\n    double r2 = median(cbeg, cbeg + lower + 1);\\n    double r3 = median(cbeg, cend);\\n    double r4 = median(cbeg + lower + 1, cend);\\n\\n    return std::make_tuple(*cbeg, r2, r3, r4, *(cend - 1));\\n}\\n\\nint main() {\\n    using namespace std;\\n    vector cs = {\\n        { 15.0, 6.0, 42.0, 41.0, 7.0, 36.0, 49.0, 40.0, 39.0, 47.0, 43.0 },\\n        { 36.0, 40.0, 7.0, 39.0, 41.0, 15.0 },\\n        {\\n            0.14082834,  0.09748790,  1.73131507,  0.87636009, -1.95059594,  0.73438555,\\n           -0.03035726,  1.46675970, -0.74621349, -0.72588772,  0.63905160,  0.61501527,\\n           -0.98983780, -1.00447874, -0.62759469,  0.66206163,  1.04312009, -0.10305385,\\n            0.75775634,  0.32566578\\n        }\\n    };\\n\\n    for (auto & c : cs) {\\n        cout << fivenum(c) << endl;\\n    }\\n\\n    return 0;\\n}"
"C++","FizzBuzz","Write a program that prints the integers from   1   to   100   (inclusive).\\n\\nBut:\\n\\nThe   FizzBuzz   problem was presented as the lowest level of comprehension required to illustrate adequacy.\\n\\n\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nThe ActionScript solution works just like the JavaScript solution (they share the ECMAScript specification). The difference is that ActionScript has the trace command to write out to a console.\\nor simply:\\n\\nSlightly different approach that makes use of the Decode function (⊥):\\nThe idea is to first calculate the residues for all numbers 1..100 after\\ndivision with both 3 and 5. This generates 100 pairs of numbers a b, where\\na is either 0,1,2 and b is either 0,1,2,3,4.\\nThese pairs are then put through the sign function which returns 0 for a 0,\\nand a 1 for anything greater than 0. Now we have binary pairs.\\nThe binary pairs are encoded with a left argument of 2 resulting in 0,1,2,3.\\nThese are treated as indices for the \""FizzBuzz vector\"" where 0 is in position 3.\\nVariable A holds this new vector of words and zeros.\\nVariable I is assigned the zeros' positions.\\nFinally A[I] is replaced with corresponding indices.\\nIf you have an aversion against mixed vectors, consider inserting ⍕¨ before the\\nfinal (i.e. left-most) assignment.\\nHere's a Dyalog-specific solution taking advantage of its anonymous function extension:\\n\\nOr, using map(), enumFromTo(), and a more functional pattern of composition:\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang#AsciiDots\\nSearch autohotkey.com: [1]\\nA short example with cascading ternary operators and graphical output. Press Esc to close the window.\\nOutput via MsgBox():\\nOutput via console, logfile and/or messagebox:\\nSee FizzBuzz/AWK\\nSee FizzBuzz/Basic#BaCon\\nAny bash hacker would do this as a one liner at the shell, so...\\nFor the sake of readability...\\nHere's a very concise approach, with only 75 characters total.\\nUnfortunately it relies on aspects of Bash which are rarely used.\\nHere's the concise approach again, this time separated into multiple lines.\\nIt's a bit silly to optimize such a small & fast program,\\nbut for the sake of algorithm analysis it's worth noting that\\nthe concise approach is reasonably efficient in several ways.\\nEach divisibility test appears in the code exactly once,\\nonly two variables are created,\\nand the approach avoids setting variables unnecessarily.\\nAs far as I can tell,\\nthe divisibility tests only fire the minimum number of times required\\nfor the general case (e.g. where the 100/3/5 constants can be changed),\\nunless you introduce more variables and test types.\\nCorrections invited.\\nI avoided analyzing the non-general case where 100/3/5 never change,\\nbecause one \""optimal\"" solution is to simply print the pre-computed answer,\\nSee FizzBuzz/Basic\\nFOR /L version:\\nLoop version:\\nFOR /L with a block instead of very-high-overhead subroutine call:\\nSee FizzBuzz/Basic\\nThis solution never uses else, because bc has no else keyword (but some implementations add else as an extension).\\nAlso see on FizzBuzz/EsoLang\\n“Ordinary” FizzBuzz solution:\\n\\nExample without double mod 5 check, using a flag instead, to check if Fizz already got printed (in this case the number n must not be printed if mod 5 is > 0):\\nSee FizzBuzz/EsoLang\\nSame code, pretty printed:\\nSee FizzBuzz/EsoLang\\nThe following C code was inspired by this ( low SignalToNoise, EasyToModify ) JavaScript:\\nWith 2 prime numbers, the C code is:\\nWith 4 prime numbers:\\nOne line version, with pretty printing\\nImplicit int main and return 0 (C99+):\\nobfuscated:\\nWithout conditionals, anything in the loop body gcc compiles with branching, duplicate tests or duplicate strings. Depends on ASCII and two's complement arithmetic:\\nTDD using delegates.\\nAlternate version not using modulo 15:\\nAlternate version that avoids using modulo. (Modulo can be expensive on some architectures.)\\nA version using std::transform:\\nVersion computing FizzBuzz at compile time with metaprogramming:\\nHardcore templates (compile with -ftemplate-depth-9000 -std=c++0x):\\nNote: it takes up lots of memory and takes several seconds to compile. To enable compilation for 7 < n <= 25, please, modify include/boost/mpl/limits/string.hpp BOOST_MPL_LIMIT_STRING_SIZE to 128 instead of 32).\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang\\nAlso compiles with Harbour (Harbour 3.2.0dev (r1405201749))\\nThe advantage of this approach is that it is trivial to add another factor:\\nI know this doesn't have the full-bodied, piquant flavor\\nexpected from COBOL, but it is a little shorter.\\nI think this shows clearly that it's resolving the problem and illuminating the rules specified\\nA solution that simply evaluates and adds.\\ncfscript version\\nSolution 1:\\nSolution 2:\\nSolution 3:\\nSolution 4:\\nSolution 5:\\nSolution 6:\\nSolution 7:\\nFirst 16 lines of output:\\nI use Allegro CL 10.1\\nOutput:\\nThe bc translation written in dc style.\\nFizzBuzz, realized using two different methods for string/character output:\\nOutput to STDOUT via single character output.\\nOutput to STDOUT, using stored strings and a separately defined string output operator:\\nused case\\nAlternate approach using pipes and cond:\\nused Stream.cycle version:\\nYet another approach:\\nused anonymous function\\nEnum.at version: Returns nil if index is out of bounds.\\nThe Stream.cycle version above, but as an overpowered FizzBuzz DSL.\\nA bit too simple:\\nA bit too clever:\\nThis is based on the VBScript example.\\nAnother example using (unnecessary) partial active pattern :D\\nMore flexible variant without divisibility tests.\\nSee FizzBuzz/EsoLang\\nNo 'MOD 15' needed.\\n","#include <iostream>\\n\\nusing namespace std;\\nint main ()\\n{\\n       for (int i = 1; i <= 100; i++) \\n       {\\n               if ((i % 15) == 0)\\n                       cout << \""FizzBuzz\\n\"";\\n               else if ((i % 3) == 0)\\n                       cout << \""Fizz\\n\"";\\n               else if ((i % 5) == 0)\\n                       cout << \""Buzz\\n\"";\\n               else\\n                       cout << i << \""\\n\"";\\n       }\\n       return 0;\\n}"
"C++","FizzBuzz","Write a program that prints the integers from   1   to   100   (inclusive).\\n\\nBut:\\n\\nThe   FizzBuzz   problem was presented as the lowest level of comprehension required to illustrate adequacy.\\n\\n\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nThe ActionScript solution works just like the JavaScript solution (they share the ECMAScript specification). The difference is that ActionScript has the trace command to write out to a console.\\nor simply:\\n\\nSlightly different approach that makes use of the Decode function (⊥):\\nThe idea is to first calculate the residues for all numbers 1..100 after\\ndivision with both 3 and 5. This generates 100 pairs of numbers a b, where\\na is either 0,1,2 and b is either 0,1,2,3,4.\\nThese pairs are then put through the sign function which returns 0 for a 0,\\nand a 1 for anything greater than 0. Now we have binary pairs.\\nThe binary pairs are encoded with a left argument of 2 resulting in 0,1,2,3.\\nThese are treated as indices for the \""FizzBuzz vector\"" where 0 is in position 3.\\nVariable A holds this new vector of words and zeros.\\nVariable I is assigned the zeros' positions.\\nFinally A[I] is replaced with corresponding indices.\\nIf you have an aversion against mixed vectors, consider inserting ⍕¨ before the\\nfinal (i.e. left-most) assignment.\\nHere's a Dyalog-specific solution taking advantage of its anonymous function extension:\\n\\nOr, using map(), enumFromTo(), and a more functional pattern of composition:\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang#AsciiDots\\nSearch autohotkey.com: [1]\\nA short example with cascading ternary operators and graphical output. Press Esc to close the window.\\nOutput via MsgBox():\\nOutput via console, logfile and/or messagebox:\\nSee FizzBuzz/AWK\\nSee FizzBuzz/Basic#BaCon\\nAny bash hacker would do this as a one liner at the shell, so...\\nFor the sake of readability...\\nHere's a very concise approach, with only 75 characters total.\\nUnfortunately it relies on aspects of Bash which are rarely used.\\nHere's the concise approach again, this time separated into multiple lines.\\nIt's a bit silly to optimize such a small & fast program,\\nbut for the sake of algorithm analysis it's worth noting that\\nthe concise approach is reasonably efficient in several ways.\\nEach divisibility test appears in the code exactly once,\\nonly two variables are created,\\nand the approach avoids setting variables unnecessarily.\\nAs far as I can tell,\\nthe divisibility tests only fire the minimum number of times required\\nfor the general case (e.g. where the 100/3/5 constants can be changed),\\nunless you introduce more variables and test types.\\nCorrections invited.\\nI avoided analyzing the non-general case where 100/3/5 never change,\\nbecause one \""optimal\"" solution is to simply print the pre-computed answer,\\nSee FizzBuzz/Basic\\nFOR /L version:\\nLoop version:\\nFOR /L with a block instead of very-high-overhead subroutine call:\\nSee FizzBuzz/Basic\\nThis solution never uses else, because bc has no else keyword (but some implementations add else as an extension).\\nAlso see on FizzBuzz/EsoLang\\n“Ordinary” FizzBuzz solution:\\n\\nExample without double mod 5 check, using a flag instead, to check if Fizz already got printed (in this case the number n must not be printed if mod 5 is > 0):\\nSee FizzBuzz/EsoLang\\nSame code, pretty printed:\\nSee FizzBuzz/EsoLang\\nThe following C code was inspired by this ( low SignalToNoise, EasyToModify ) JavaScript:\\nWith 2 prime numbers, the C code is:\\nWith 4 prime numbers:\\nOne line version, with pretty printing\\nImplicit int main and return 0 (C99+):\\nobfuscated:\\nWithout conditionals, anything in the loop body gcc compiles with branching, duplicate tests or duplicate strings. Depends on ASCII and two's complement arithmetic:\\nTDD using delegates.\\nAlternate version not using modulo 15:\\nAlternate version that avoids using modulo. (Modulo can be expensive on some architectures.)\\nA version using std::transform:\\nVersion computing FizzBuzz at compile time with metaprogramming:\\nHardcore templates (compile with -ftemplate-depth-9000 -std=c++0x):\\nNote: it takes up lots of memory and takes several seconds to compile. To enable compilation for 7 < n <= 25, please, modify include/boost/mpl/limits/string.hpp BOOST_MPL_LIMIT_STRING_SIZE to 128 instead of 32).\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang\\nAlso compiles with Harbour (Harbour 3.2.0dev (r1405201749))\\nThe advantage of this approach is that it is trivial to add another factor:\\nI know this doesn't have the full-bodied, piquant flavor\\nexpected from COBOL, but it is a little shorter.\\nI think this shows clearly that it's resolving the problem and illuminating the rules specified\\nA solution that simply evaluates and adds.\\ncfscript version\\nSolution 1:\\nSolution 2:\\nSolution 3:\\nSolution 4:\\nSolution 5:\\nSolution 6:\\nSolution 7:\\nFirst 16 lines of output:\\nI use Allegro CL 10.1\\nOutput:\\nThe bc translation written in dc style.\\nFizzBuzz, realized using two different methods for string/character output:\\nOutput to STDOUT via single character output.\\nOutput to STDOUT, using stored strings and a separately defined string output operator:\\nused case\\nAlternate approach using pipes and cond:\\nused Stream.cycle version:\\nYet another approach:\\nused anonymous function\\nEnum.at version: Returns nil if index is out of bounds.\\nThe Stream.cycle version above, but as an overpowered FizzBuzz DSL.\\nA bit too simple:\\nA bit too clever:\\nThis is based on the VBScript example.\\nAnother example using (unnecessary) partial active pattern :D\\nMore flexible variant without divisibility tests.\\nSee FizzBuzz/EsoLang\\nNo 'MOD 15' needed.\\n","#include <iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n  for (int i = 0; i <= 100; ++i)\\n  {\\n    bool fizz = (i % 3) == 0;\\n    bool buzz = (i % 5) == 0;\\n    if (fizz)\\n      cout << \""Fizz\"";\\n    if (buzz)\\n      cout << \""Buzz\"";\\n    if (!fizz && !buzz)\\n      cout << i;\\n    cout << \""\\n\"";\\n  }\\n  return 0;\\n}"
"C++","FizzBuzz","Write a program that prints the integers from   1   to   100   (inclusive).\\n\\nBut:\\n\\nThe   FizzBuzz   problem was presented as the lowest level of comprehension required to illustrate adequacy.\\n\\n\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nThe ActionScript solution works just like the JavaScript solution (they share the ECMAScript specification). The difference is that ActionScript has the trace command to write out to a console.\\nor simply:\\n\\nSlightly different approach that makes use of the Decode function (⊥):\\nThe idea is to first calculate the residues for all numbers 1..100 after\\ndivision with both 3 and 5. This generates 100 pairs of numbers a b, where\\na is either 0,1,2 and b is either 0,1,2,3,4.\\nThese pairs are then put through the sign function which returns 0 for a 0,\\nand a 1 for anything greater than 0. Now we have binary pairs.\\nThe binary pairs are encoded with a left argument of 2 resulting in 0,1,2,3.\\nThese are treated as indices for the \""FizzBuzz vector\"" where 0 is in position 3.\\nVariable A holds this new vector of words and zeros.\\nVariable I is assigned the zeros' positions.\\nFinally A[I] is replaced with corresponding indices.\\nIf you have an aversion against mixed vectors, consider inserting ⍕¨ before the\\nfinal (i.e. left-most) assignment.\\nHere's a Dyalog-specific solution taking advantage of its anonymous function extension:\\n\\nOr, using map(), enumFromTo(), and a more functional pattern of composition:\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang#AsciiDots\\nSearch autohotkey.com: [1]\\nA short example with cascading ternary operators and graphical output. Press Esc to close the window.\\nOutput via MsgBox():\\nOutput via console, logfile and/or messagebox:\\nSee FizzBuzz/AWK\\nSee FizzBuzz/Basic#BaCon\\nAny bash hacker would do this as a one liner at the shell, so...\\nFor the sake of readability...\\nHere's a very concise approach, with only 75 characters total.\\nUnfortunately it relies on aspects of Bash which are rarely used.\\nHere's the concise approach again, this time separated into multiple lines.\\nIt's a bit silly to optimize such a small & fast program,\\nbut for the sake of algorithm analysis it's worth noting that\\nthe concise approach is reasonably efficient in several ways.\\nEach divisibility test appears in the code exactly once,\\nonly two variables are created,\\nand the approach avoids setting variables unnecessarily.\\nAs far as I can tell,\\nthe divisibility tests only fire the minimum number of times required\\nfor the general case (e.g. where the 100/3/5 constants can be changed),\\nunless you introduce more variables and test types.\\nCorrections invited.\\nI avoided analyzing the non-general case where 100/3/5 never change,\\nbecause one \""optimal\"" solution is to simply print the pre-computed answer,\\nSee FizzBuzz/Basic\\nFOR /L version:\\nLoop version:\\nFOR /L with a block instead of very-high-overhead subroutine call:\\nSee FizzBuzz/Basic\\nThis solution never uses else, because bc has no else keyword (but some implementations add else as an extension).\\nAlso see on FizzBuzz/EsoLang\\n“Ordinary” FizzBuzz solution:\\n\\nExample without double mod 5 check, using a flag instead, to check if Fizz already got printed (in this case the number n must not be printed if mod 5 is > 0):\\nSee FizzBuzz/EsoLang\\nSame code, pretty printed:\\nSee FizzBuzz/EsoLang\\nThe following C code was inspired by this ( low SignalToNoise, EasyToModify ) JavaScript:\\nWith 2 prime numbers, the C code is:\\nWith 4 prime numbers:\\nOne line version, with pretty printing\\nImplicit int main and return 0 (C99+):\\nobfuscated:\\nWithout conditionals, anything in the loop body gcc compiles with branching, duplicate tests or duplicate strings. Depends on ASCII and two's complement arithmetic:\\nTDD using delegates.\\nAlternate version not using modulo 15:\\nAlternate version that avoids using modulo. (Modulo can be expensive on some architectures.)\\nA version using std::transform:\\nVersion computing FizzBuzz at compile time with metaprogramming:\\nHardcore templates (compile with -ftemplate-depth-9000 -std=c++0x):\\nNote: it takes up lots of memory and takes several seconds to compile. To enable compilation for 7 < n <= 25, please, modify include/boost/mpl/limits/string.hpp BOOST_MPL_LIMIT_STRING_SIZE to 128 instead of 32).\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang\\nAlso compiles with Harbour (Harbour 3.2.0dev (r1405201749))\\nThe advantage of this approach is that it is trivial to add another factor:\\nI know this doesn't have the full-bodied, piquant flavor\\nexpected from COBOL, but it is a little shorter.\\nI think this shows clearly that it's resolving the problem and illuminating the rules specified\\nA solution that simply evaluates and adds.\\ncfscript version\\nSolution 1:\\nSolution 2:\\nSolution 3:\\nSolution 4:\\nSolution 5:\\nSolution 6:\\nSolution 7:\\nFirst 16 lines of output:\\nI use Allegro CL 10.1\\nOutput:\\nThe bc translation written in dc style.\\nFizzBuzz, realized using two different methods for string/character output:\\nOutput to STDOUT via single character output.\\nOutput to STDOUT, using stored strings and a separately defined string output operator:\\nused case\\nAlternate approach using pipes and cond:\\nused Stream.cycle version:\\nYet another approach:\\nused anonymous function\\nEnum.at version: Returns nil if index is out of bounds.\\nThe Stream.cycle version above, but as an overpowered FizzBuzz DSL.\\nA bit too simple:\\nA bit too clever:\\nThis is based on the VBScript example.\\nAnother example using (unnecessary) partial active pattern :D\\nMore flexible variant without divisibility tests.\\nSee FizzBuzz/EsoLang\\nNo 'MOD 15' needed.\\n","#include <iostream>\\n\\nint main()\\n{\\n    int i, f = 2, b = 4; \\n\\n    for ( i = 1 ; i <= 100 ; ++i, --f, --b )\\n    {\\n        if ( f && b ) { std::cout << i;             }\\n        if ( !f )     { std::cout << \""Fizz\""; f = 3; }\\n        if ( !b )     { std::cout << \""Buzz\""; b = 5; }\\n        std::cout << std::endl;\\n    }\\n\\n    return 0;\\n}\\n"
"C++","FizzBuzz","Write a program that prints the integers from   1   to   100   (inclusive).\\n\\nBut:\\n\\nThe   FizzBuzz   problem was presented as the lowest level of comprehension required to illustrate adequacy.\\n\\n\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nThe ActionScript solution works just like the JavaScript solution (they share the ECMAScript specification). The difference is that ActionScript has the trace command to write out to a console.\\nor simply:\\n\\nSlightly different approach that makes use of the Decode function (⊥):\\nThe idea is to first calculate the residues for all numbers 1..100 after\\ndivision with both 3 and 5. This generates 100 pairs of numbers a b, where\\na is either 0,1,2 and b is either 0,1,2,3,4.\\nThese pairs are then put through the sign function which returns 0 for a 0,\\nand a 1 for anything greater than 0. Now we have binary pairs.\\nThe binary pairs are encoded with a left argument of 2 resulting in 0,1,2,3.\\nThese are treated as indices for the \""FizzBuzz vector\"" where 0 is in position 3.\\nVariable A holds this new vector of words and zeros.\\nVariable I is assigned the zeros' positions.\\nFinally A[I] is replaced with corresponding indices.\\nIf you have an aversion against mixed vectors, consider inserting ⍕¨ before the\\nfinal (i.e. left-most) assignment.\\nHere's a Dyalog-specific solution taking advantage of its anonymous function extension:\\n\\nOr, using map(), enumFromTo(), and a more functional pattern of composition:\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang#AsciiDots\\nSearch autohotkey.com: [1]\\nA short example with cascading ternary operators and graphical output. Press Esc to close the window.\\nOutput via MsgBox():\\nOutput via console, logfile and/or messagebox:\\nSee FizzBuzz/AWK\\nSee FizzBuzz/Basic#BaCon\\nAny bash hacker would do this as a one liner at the shell, so...\\nFor the sake of readability...\\nHere's a very concise approach, with only 75 characters total.\\nUnfortunately it relies on aspects of Bash which are rarely used.\\nHere's the concise approach again, this time separated into multiple lines.\\nIt's a bit silly to optimize such a small & fast program,\\nbut for the sake of algorithm analysis it's worth noting that\\nthe concise approach is reasonably efficient in several ways.\\nEach divisibility test appears in the code exactly once,\\nonly two variables are created,\\nand the approach avoids setting variables unnecessarily.\\nAs far as I can tell,\\nthe divisibility tests only fire the minimum number of times required\\nfor the general case (e.g. where the 100/3/5 constants can be changed),\\nunless you introduce more variables and test types.\\nCorrections invited.\\nI avoided analyzing the non-general case where 100/3/5 never change,\\nbecause one \""optimal\"" solution is to simply print the pre-computed answer,\\nSee FizzBuzz/Basic\\nFOR /L version:\\nLoop version:\\nFOR /L with a block instead of very-high-overhead subroutine call:\\nSee FizzBuzz/Basic\\nThis solution never uses else, because bc has no else keyword (but some implementations add else as an extension).\\nAlso see on FizzBuzz/EsoLang\\n“Ordinary” FizzBuzz solution:\\n\\nExample without double mod 5 check, using a flag instead, to check if Fizz already got printed (in this case the number n must not be printed if mod 5 is > 0):\\nSee FizzBuzz/EsoLang\\nSame code, pretty printed:\\nSee FizzBuzz/EsoLang\\nThe following C code was inspired by this ( low SignalToNoise, EasyToModify ) JavaScript:\\nWith 2 prime numbers, the C code is:\\nWith 4 prime numbers:\\nOne line version, with pretty printing\\nImplicit int main and return 0 (C99+):\\nobfuscated:\\nWithout conditionals, anything in the loop body gcc compiles with branching, duplicate tests or duplicate strings. Depends on ASCII and two's complement arithmetic:\\nTDD using delegates.\\nAlternate version not using modulo 15:\\nAlternate version that avoids using modulo. (Modulo can be expensive on some architectures.)\\nA version using std::transform:\\nVersion computing FizzBuzz at compile time with metaprogramming:\\nHardcore templates (compile with -ftemplate-depth-9000 -std=c++0x):\\nNote: it takes up lots of memory and takes several seconds to compile. To enable compilation for 7 < n <= 25, please, modify include/boost/mpl/limits/string.hpp BOOST_MPL_LIMIT_STRING_SIZE to 128 instead of 32).\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang\\nAlso compiles with Harbour (Harbour 3.2.0dev (r1405201749))\\nThe advantage of this approach is that it is trivial to add another factor:\\nI know this doesn't have the full-bodied, piquant flavor\\nexpected from COBOL, but it is a little shorter.\\nI think this shows clearly that it's resolving the problem and illuminating the rules specified\\nA solution that simply evaluates and adds.\\ncfscript version\\nSolution 1:\\nSolution 2:\\nSolution 3:\\nSolution 4:\\nSolution 5:\\nSolution 6:\\nSolution 7:\\nFirst 16 lines of output:\\nI use Allegro CL 10.1\\nOutput:\\nThe bc translation written in dc style.\\nFizzBuzz, realized using two different methods for string/character output:\\nOutput to STDOUT via single character output.\\nOutput to STDOUT, using stored strings and a separately defined string output operator:\\nused case\\nAlternate approach using pipes and cond:\\nused Stream.cycle version:\\nYet another approach:\\nused anonymous function\\nEnum.at version: Returns nil if index is out of bounds.\\nThe Stream.cycle version above, but as an overpowered FizzBuzz DSL.\\nA bit too simple:\\nA bit too clever:\\nThis is based on the VBScript example.\\nAnother example using (unnecessary) partial active pattern :D\\nMore flexible variant without divisibility tests.\\nSee FizzBuzz/EsoLang\\nNo 'MOD 15' needed.\\n","#include <iostream>                                                                                                     \\n#include <algorithm>\\n#include <vector>\\n\\nint main()\\n{\\n  std::vector<int> range(100);\\n  std::iota(range.begin(), range.end(), 1);\\n\\n  std::vector values;\\n  values.resize(range.size());\\n\\n  auto fizzbuzz = [](int i) -> std::string {\\n    if ((i%15) == 0) return \""FizzBuzz\"";\\n    if ((i%5) == 0)  return \""Buzz\"";\\n    if ((i%3) == 0)  return \""Fizz\"";\\n    return std::to_string(i);\\n  };\\n\\n  std::transform(range.begin(), range.end(), values.begin(), fizzbuzz);\\n\\n  for (auto& str: values) std::cout << str << std::endl;\\n\\n  return 0;\\n}"
"C++","FizzBuzz","Write a program that prints the integers from   1   to   100   (inclusive).\\n\\nBut:\\n\\nThe   FizzBuzz   problem was presented as the lowest level of comprehension required to illustrate adequacy.\\n\\n\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nThe ActionScript solution works just like the JavaScript solution (they share the ECMAScript specification). The difference is that ActionScript has the trace command to write out to a console.\\nor simply:\\n\\nSlightly different approach that makes use of the Decode function (⊥):\\nThe idea is to first calculate the residues for all numbers 1..100 after\\ndivision with both 3 and 5. This generates 100 pairs of numbers a b, where\\na is either 0,1,2 and b is either 0,1,2,3,4.\\nThese pairs are then put through the sign function which returns 0 for a 0,\\nand a 1 for anything greater than 0. Now we have binary pairs.\\nThe binary pairs are encoded with a left argument of 2 resulting in 0,1,2,3.\\nThese are treated as indices for the \""FizzBuzz vector\"" where 0 is in position 3.\\nVariable A holds this new vector of words and zeros.\\nVariable I is assigned the zeros' positions.\\nFinally A[I] is replaced with corresponding indices.\\nIf you have an aversion against mixed vectors, consider inserting ⍕¨ before the\\nfinal (i.e. left-most) assignment.\\nHere's a Dyalog-specific solution taking advantage of its anonymous function extension:\\n\\nOr, using map(), enumFromTo(), and a more functional pattern of composition:\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang#AsciiDots\\nSearch autohotkey.com: [1]\\nA short example with cascading ternary operators and graphical output. Press Esc to close the window.\\nOutput via MsgBox():\\nOutput via console, logfile and/or messagebox:\\nSee FizzBuzz/AWK\\nSee FizzBuzz/Basic#BaCon\\nAny bash hacker would do this as a one liner at the shell, so...\\nFor the sake of readability...\\nHere's a very concise approach, with only 75 characters total.\\nUnfortunately it relies on aspects of Bash which are rarely used.\\nHere's the concise approach again, this time separated into multiple lines.\\nIt's a bit silly to optimize such a small & fast program,\\nbut for the sake of algorithm analysis it's worth noting that\\nthe concise approach is reasonably efficient in several ways.\\nEach divisibility test appears in the code exactly once,\\nonly two variables are created,\\nand the approach avoids setting variables unnecessarily.\\nAs far as I can tell,\\nthe divisibility tests only fire the minimum number of times required\\nfor the general case (e.g. where the 100/3/5 constants can be changed),\\nunless you introduce more variables and test types.\\nCorrections invited.\\nI avoided analyzing the non-general case where 100/3/5 never change,\\nbecause one \""optimal\"" solution is to simply print the pre-computed answer,\\nSee FizzBuzz/Basic\\nFOR /L version:\\nLoop version:\\nFOR /L with a block instead of very-high-overhead subroutine call:\\nSee FizzBuzz/Basic\\nThis solution never uses else, because bc has no else keyword (but some implementations add else as an extension).\\nAlso see on FizzBuzz/EsoLang\\n“Ordinary” FizzBuzz solution:\\n\\nExample without double mod 5 check, using a flag instead, to check if Fizz already got printed (in this case the number n must not be printed if mod 5 is > 0):\\nSee FizzBuzz/EsoLang\\nSame code, pretty printed:\\nSee FizzBuzz/EsoLang\\nThe following C code was inspired by this ( low SignalToNoise, EasyToModify ) JavaScript:\\nWith 2 prime numbers, the C code is:\\nWith 4 prime numbers:\\nOne line version, with pretty printing\\nImplicit int main and return 0 (C99+):\\nobfuscated:\\nWithout conditionals, anything in the loop body gcc compiles with branching, duplicate tests or duplicate strings. Depends on ASCII and two's complement arithmetic:\\nTDD using delegates.\\nAlternate version not using modulo 15:\\nAlternate version that avoids using modulo. (Modulo can be expensive on some architectures.)\\nA version using std::transform:\\nVersion computing FizzBuzz at compile time with metaprogramming:\\nHardcore templates (compile with -ftemplate-depth-9000 -std=c++0x):\\nNote: it takes up lots of memory and takes several seconds to compile. To enable compilation for 7 < n <= 25, please, modify include/boost/mpl/limits/string.hpp BOOST_MPL_LIMIT_STRING_SIZE to 128 instead of 32).\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang\\nAlso compiles with Harbour (Harbour 3.2.0dev (r1405201749))\\nThe advantage of this approach is that it is trivial to add another factor:\\nI know this doesn't have the full-bodied, piquant flavor\\nexpected from COBOL, but it is a little shorter.\\nI think this shows clearly that it's resolving the problem and illuminating the rules specified\\nA solution that simply evaluates and adds.\\ncfscript version\\nSolution 1:\\nSolution 2:\\nSolution 3:\\nSolution 4:\\nSolution 5:\\nSolution 6:\\nSolution 7:\\nFirst 16 lines of output:\\nI use Allegro CL 10.1\\nOutput:\\nThe bc translation written in dc style.\\nFizzBuzz, realized using two different methods for string/character output:\\nOutput to STDOUT via single character output.\\nOutput to STDOUT, using stored strings and a separately defined string output operator:\\nused case\\nAlternate approach using pipes and cond:\\nused Stream.cycle version:\\nYet another approach:\\nused anonymous function\\nEnum.at version: Returns nil if index is out of bounds.\\nThe Stream.cycle version above, but as an overpowered FizzBuzz DSL.\\nA bit too simple:\\nA bit too clever:\\nThis is based on the VBScript example.\\nAnother example using (unnecessary) partial active pattern :D\\nMore flexible variant without divisibility tests.\\nSee FizzBuzz/EsoLang\\nNo 'MOD 15' needed.\\n","#include <iostream>\\n\\ntemplate  \\nstruct fizzbuzz : fizzbuzz\\n{\\n  fizzbuzz() \\n  { std::cout << n << std::endl; }\\n};\\n\\ntemplate \\nstruct fizzbuzz : fizzbuzz\\n{\\n  fizzbuzz() \\n  { std::cout << \""FizzBuzz\"" << std::endl; }\\n};\\n\\ntemplate \\nstruct fizzbuzz : fizzbuzz\\n{\\n  fizzbuzz() \\n  { std::cout << \""Fizz\"" << std::endl; }\\n};\\n\\ntemplate \\nstruct fizzbuzz : fizzbuzz\\n{\\n  fizzbuzz() \\n  { std::cout << \""Buzz\"" << std::endl; }\\n};\\n\\ntemplate <>\\nstruct fizzbuzz<0,0,0>\\n{\\n  fizzbuzz() \\n  { std::cout << 0 << std::endl; }\\n};\\n\\ntemplate \\nstruct fb_run\\n{\\n  fizzbuzz fb;\\n};\\n\\nint main()\\n{\\n  fb_run<100> fb;\\n  return 0;\\n}"
"C++","FizzBuzz","Write a program that prints the integers from   1   to   100   (inclusive).\\n\\nBut:\\n\\nThe   FizzBuzz   problem was presented as the lowest level of comprehension required to illustrate adequacy.\\n\\n\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nThe ActionScript solution works just like the JavaScript solution (they share the ECMAScript specification). The difference is that ActionScript has the trace command to write out to a console.\\nor simply:\\n\\nSlightly different approach that makes use of the Decode function (⊥):\\nThe idea is to first calculate the residues for all numbers 1..100 after\\ndivision with both 3 and 5. This generates 100 pairs of numbers a b, where\\na is either 0,1,2 and b is either 0,1,2,3,4.\\nThese pairs are then put through the sign function which returns 0 for a 0,\\nand a 1 for anything greater than 0. Now we have binary pairs.\\nThe binary pairs are encoded with a left argument of 2 resulting in 0,1,2,3.\\nThese are treated as indices for the \""FizzBuzz vector\"" where 0 is in position 3.\\nVariable A holds this new vector of words and zeros.\\nVariable I is assigned the zeros' positions.\\nFinally A[I] is replaced with corresponding indices.\\nIf you have an aversion against mixed vectors, consider inserting ⍕¨ before the\\nfinal (i.e. left-most) assignment.\\nHere's a Dyalog-specific solution taking advantage of its anonymous function extension:\\n\\nOr, using map(), enumFromTo(), and a more functional pattern of composition:\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang#AsciiDots\\nSearch autohotkey.com: [1]\\nA short example with cascading ternary operators and graphical output. Press Esc to close the window.\\nOutput via MsgBox():\\nOutput via console, logfile and/or messagebox:\\nSee FizzBuzz/AWK\\nSee FizzBuzz/Basic#BaCon\\nAny bash hacker would do this as a one liner at the shell, so...\\nFor the sake of readability...\\nHere's a very concise approach, with only 75 characters total.\\nUnfortunately it relies on aspects of Bash which are rarely used.\\nHere's the concise approach again, this time separated into multiple lines.\\nIt's a bit silly to optimize such a small & fast program,\\nbut for the sake of algorithm analysis it's worth noting that\\nthe concise approach is reasonably efficient in several ways.\\nEach divisibility test appears in the code exactly once,\\nonly two variables are created,\\nand the approach avoids setting variables unnecessarily.\\nAs far as I can tell,\\nthe divisibility tests only fire the minimum number of times required\\nfor the general case (e.g. where the 100/3/5 constants can be changed),\\nunless you introduce more variables and test types.\\nCorrections invited.\\nI avoided analyzing the non-general case where 100/3/5 never change,\\nbecause one \""optimal\"" solution is to simply print the pre-computed answer,\\nSee FizzBuzz/Basic\\nFOR /L version:\\nLoop version:\\nFOR /L with a block instead of very-high-overhead subroutine call:\\nSee FizzBuzz/Basic\\nThis solution never uses else, because bc has no else keyword (but some implementations add else as an extension).\\nAlso see on FizzBuzz/EsoLang\\n“Ordinary” FizzBuzz solution:\\n\\nExample without double mod 5 check, using a flag instead, to check if Fizz already got printed (in this case the number n must not be printed if mod 5 is > 0):\\nSee FizzBuzz/EsoLang\\nSame code, pretty printed:\\nSee FizzBuzz/EsoLang\\nThe following C code was inspired by this ( low SignalToNoise, EasyToModify ) JavaScript:\\nWith 2 prime numbers, the C code is:\\nWith 4 prime numbers:\\nOne line version, with pretty printing\\nImplicit int main and return 0 (C99+):\\nobfuscated:\\nWithout conditionals, anything in the loop body gcc compiles with branching, duplicate tests or duplicate strings. Depends on ASCII and two's complement arithmetic:\\nTDD using delegates.\\nAlternate version not using modulo 15:\\nAlternate version that avoids using modulo. (Modulo can be expensive on some architectures.)\\nA version using std::transform:\\nVersion computing FizzBuzz at compile time with metaprogramming:\\nHardcore templates (compile with -ftemplate-depth-9000 -std=c++0x):\\nNote: it takes up lots of memory and takes several seconds to compile. To enable compilation for 7 < n <= 25, please, modify include/boost/mpl/limits/string.hpp BOOST_MPL_LIMIT_STRING_SIZE to 128 instead of 32).\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang\\nAlso compiles with Harbour (Harbour 3.2.0dev (r1405201749))\\nThe advantage of this approach is that it is trivial to add another factor:\\nI know this doesn't have the full-bodied, piquant flavor\\nexpected from COBOL, but it is a little shorter.\\nI think this shows clearly that it's resolving the problem and illuminating the rules specified\\nA solution that simply evaluates and adds.\\ncfscript version\\nSolution 1:\\nSolution 2:\\nSolution 3:\\nSolution 4:\\nSolution 5:\\nSolution 6:\\nSolution 7:\\nFirst 16 lines of output:\\nI use Allegro CL 10.1\\nOutput:\\nThe bc translation written in dc style.\\nFizzBuzz, realized using two different methods for string/character output:\\nOutput to STDOUT via single character output.\\nOutput to STDOUT, using stored strings and a separately defined string output operator:\\nused case\\nAlternate approach using pipes and cond:\\nused Stream.cycle version:\\nYet another approach:\\nused anonymous function\\nEnum.at version: Returns nil if index is out of bounds.\\nThe Stream.cycle version above, but as an overpowered FizzBuzz DSL.\\nA bit too simple:\\nA bit too clever:\\nThis is based on the VBScript example.\\nAnother example using (unnecessary) partial active pattern :D\\nMore flexible variant without divisibility tests.\\nSee FizzBuzz/EsoLang\\nNo 'MOD 15' needed.\\n","#include <iostream>\\n#include <string>\\n#include <cstdlib>\\n#include \\n#include \\n#include \\n\\nusing namespace std;\\nusing namespace boost;\\n\\n///////////////////////////////////////////////////////////////////////////////\\n// exponentiation calculations\\ntemplate  struct POWER_CORE : POWER_CORE{};\\n\\ntemplate \\nstruct POWER_CORE\\n{\\n    enum : int { val = accum };\\n};\\n\\ntemplate  struct POWER : POWER_CORE<1, base, exp>{};\\n\\n///////////////////////////////////////////////////////////////////////////////\\n// # of digit calculations\\ntemplate  struct NUM_DIGITS_CORE : NUM_DIGITS_CORE{};\\n\\ntemplate \\nstruct NUM_DIGITS_CORE\\n{\\n    enum : int { val = depth};\\n};\\n\\ntemplate  struct NUM_DIGITS : NUM_DIGITS_CORE<0, i>{};\\n\\ntemplate <>\\nstruct NUM_DIGITS<0>\\n{\\n    enum : int { val = 1 };\\n};\\n\\n///////////////////////////////////////////////////////////////////////////////\\n// Convert digit to character (1 -> '1')\\ntemplate \\nstruct DIGIT_TO_CHAR\\n{\\n    enum : char{ val = i + 48 };\\n};\\n\\n///////////////////////////////////////////////////////////////////////////////\\n// Find the digit at a given offset into a number of the form 0000000017\\ntemplate  // place -> [0 .. 10]\\nstruct DIGIT_AT\\n{\\n    enum : char{ val = (i / POWER<10, place>::val) % 10 };\\n};\\n\\nstruct NULL_CHAR\\n{\\n    enum : char{ val = '\\0' };\\n};\\n\\n///////////////////////////////////////////////////////////////////////////////\\n// Convert the digit at a given offset into a number of the form '0000000017' to a character\\ntemplate  // place -> [0 .. 9]\\n    struct ALT_CHAR : DIGIT_TO_CHAR< DIGIT_AT::val >{};\\n\\n///////////////////////////////////////////////////////////////////////////////\\n// Convert the digit at a given offset into a number of the form '17' to a character\\n\\n// Template description, with specialization to generate null characters for out of range offsets\\ntemplate   \\n    struct OFFSET_CHAR_CORE_CHECKED{};\\ntemplate                 \\n    struct OFFSET_CHAR_CORE_CHECKED : NULL_CHAR{};\\ntemplate                 \\n    struct OFFSET_CHAR_CORE_CHECKED  : ALT_CHAR{};\\n\\n// Perform the range check and pass it on\\ntemplate \\n    struct OFFSET_CHAR_CORE : OFFSET_CHAR_CORE_CHECKED{};\\n\\n// Calc the number of digits and pass it on\\ntemplate \\n    struct OFFSET_CHAR : OFFSET_CHAR_CORE{};\\n\\n///////////////////////////////////////////////////////////////////////////////\\n// Integer to char* template. Works on unsigned ints.\\ntemplate \\nstruct IntToStr\\n{\\n    const static char str[];\\n    typedef typename mpl::string<\\n    OFFSET_CHAR::val,\\n    OFFSET_CHAR::val,\\n    OFFSET_CHAR::val,\\n    OFFSET_CHAR::val,\\n    OFFSET_CHAR::val,\\n    OFFSET_CHAR::val,\\n    /*OFFSET_CHAR::val,\\n    OFFSET_CHAR::val,\\n    OFFSET_CHAR::val,\\n    OFFSET_CHAR::val,*/\\n    NULL_CHAR::val>::type type;\\n};\\n\\ntemplate \\nconst char IntToStr<i>::str[] = \\n{\\n    OFFSET_CHAR::val,\\n    OFFSET_CHAR::val,\\n    OFFSET_CHAR::val,\\n    OFFSET_CHAR::val,\\n    OFFSET_CHAR::val,\\n    OFFSET_CHAR::val,\\n    OFFSET_CHAR::val,\\n    OFFSET_CHAR::val,\\n    OFFSET_CHAR::val,\\n    OFFSET_CHAR::val,\\n    NULL_CHAR::val\\n};\\n\\ntemplate \\nstruct IF\\n{\\n    typedef Then RET;\\n};\\n\\ntemplate \\nstruct IF\\n{\\n    typedef Else RET;\\n};\\n\\n\\ntemplate < typename Str1, typename Str2 >\\nstruct concat : mpl::insert_range {};\\ntemplate \\nstruct concat3 : mpl::insert_range::type > {};\\n\\ntypedef typename mpl::string<'f','i','z','z'>::type fizz;\\ntypedef typename mpl::string<'b','u','z','z'>::type buzz;\\ntypedef typename mpl::string<'\\r', '\\n'>::type mpendl;\\ntypedef typename concat::type fizzbuzz;\\n\\n// discovered boost mpl limitation on some length\\n\\ntemplate \\nstruct FizzBuzz\\n{\\n    typedef typename concat3::type, typename IF::RET >::RET >::RET, typename mpendl::type>::type type;\\n};\\n\\ntemplate <>\\nstruct FizzBuzz<1>\\n{\\n    typedef mpl::string<'1','\\r','\\n'>::type type;\\n};\\n\\nint main(int argc, char** argv)\\n{\\n    const int n = 7;\\n    std::cout << mpl::c_str::value << std::endl;\\n	return 0;\\n}"
"C++","Flipping_bits_game","Given an N by N square array of zeroes or ones in an initial\\nconfiguration, and a target configuration of zeroes and ones\\nThe task is to transform one to the other in as few moves as\\npossible by inverting whole numbered rows or whole lettered\\ncolumns at once, as one move.\\nIn an inversion any 1 becomes 0, and any 0 becomes 1 for that\\nwhole row or column.\\nCreate a program to score for the Flipping bits game.\\n\\nShow an example of a short game here, on this page, for a 3 by 3 array of bits.\\n\\nThis solution determines the size of the playground from the command line.\\n","\\n#include <time.h>\\n#include <iostream>\\n#include <string>\\n\\ntypedef unsigned char byte;\\nusing namespace std;\\n\\nclass flip\\n{\\npublic:\\n    flip() { field = 0; target = 0; }\\n    void play( int w, int h ) { wid = w; hei = h; createField(); gameLoop(); }\\n\\nprivate:\\n    void gameLoop()\\n    {\\n	int moves = 0;\\n	while( !solved() )\\n	{\\n	    display(); string r; cout << \""Enter rows letters and/or column numbers: \""; cin >> r;\\n	    for( string::iterator i = r.begin(); i != r.end(); i++ )\\n	    {\\n		byte ii = ( *i );\\n		if( ii - 1 >= '0' && ii - 1 <= '9' ) { flipCol( ii - '1' ); moves++; }\\n		else if( ii >= 'a' && ii <= 'z' ) { flipRow( ii - 'a' ); moves++; }\\n	    }\\n	}\\n	cout << endl << endl << \""** Well done! **\"" << endl << \""Used \"" << moves << \"" moves.\"" << endl << endl;\\n    }\\n\\n    void display()\\n    { system( \""cls\"" ); output( \""TARGET:\"", target ); output( \""YOU:\"", field ); }\\n\\n    void output( string t, byte* f )\\n    {\\n	cout << t << endl;\\n	cout << \"" \""; for( int x = 0; x < wid; x++ ) cout << \"" \"" << static_cast<char>( x + '1' ); cout << endl;\\n	for( int y = 0; y < hei; y++ )\\n	{\\n	    cout << static_cast<char>( y + 'a' ) << \"" \"";\\n	    for( int x = 0; x < wid; x++ )\\n		cout << static_cast<char>( f[x + y * wid] + 48 ) << \"" \"";\\n	    cout << endl;\\n	}\\n	cout << endl << endl;\\n    }\\n\\n    bool solved()\\n    {\\n	for( int y = 0; y < hei; y++ )\\n	    for( int x = 0; x < wid; x++ )\\n		if( target[x + y * wid] != field[x + y * wid] ) return false;\\n	return true;\\n    }\\n\\n    void createTarget()\\n    {\\n	for( int y = 0; y < hei; y++ )\\n	    for( int x = 0; x < wid; x++ )\\n		if( frnd() < .5f ) target[x + y * wid] = 1;\\n	        else target[x + y * wid] = 0;\\n	memcpy( field, target, wid * hei );\\n    }\\n\\n    void flipCol( int c )\\n    { for( int x = 0; x < hei; x++ ) field[c + x * wid] = !field[c + x * wid]; }\\n	\\n    void flipRow( int r )\\n    { for( int x = 0; x < wid; x++ ) field[x + r * wid] = !field[x + r * wid]; }\\n\\n    void calcStartPos()\\n    {\\n	int flips = ( rand() % wid + wid + rand() % hei + hei ) >> 1;\\n	for( int x = 0; x < flips; x++ )\\n	{ if( frnd() < .5f ) flipCol( rand() % wid ); else flipRow( rand() % hei ); }\\n    }\\n\\n    void createField()\\n    {\\n        if( field ){ delete [] field; delete [] target; }\\n        int t = wid * hei; field = new byte[t]; target = new byte[t];\\n	memset( field, 0, t ); memset( target, 0, t ); createTarget();\\n	while( true ) { calcStartPos(); if( !solved() ) break; }\\n    }\\n\\n    float frnd() { return static_cast<float>( rand() ) / static_cast<float>( RAND_MAX ); }\\n\\n    byte* field, *target; int wid, hei;\\n};\\n\\nint main( int argc, char* argv[] )\\n{ srand( time( NULL ) ); flip g; g.play( 3, 3 ); return system( \""pause\"" ); }\\n"
"C++","Flow-control_structures","These are examples of control structures. You may also be interested in:\\n\\nDocument common flow-control structures.\\nOne common example of a flow-control structure is the    goto    construct.\\nNote that   Conditional Structures   and   Loop Structures   have their own articles/categories.\\n\\n\\nCommon 360 opcodes for flow-control structures:\\nTo perform a 'goto'.\\nTo perform a 'call' to a subroutine. The first register at execution time is the next sequential address to allow a 'return'.\\nFistly a compare instruction set the condition code (cc), secondly a conditional branch is performed.\\nTo perform unconditional loops.\\nBXLE to perform loops in old Fortran style with 3 registers.\\nBXH to perform backward loops with 3 registers.\\n\\nThe jump instruction immediately jumps to any address:\\nThe indirect jump instruction immediately jumps to the address contained in the address:\\nThe jump to subroutine instruction pushes the address of the next instruction minus one onto the stack and jumps to any address:\\nA return from subroutine instruction pops the return address off the stack, adds one, and jumps to that location:\\nA break instruction causes a non-maskable interrupt (setting the interrupt flag), pushes the current program counter address plus one onto the stack, pushes the flags onto the stack, then jumps to the address in the break vector (commonly at $FFFE and $FFFF):\\nThe return from interrupt instruction pops the flags off the stack, pops the return address off the stack, adds one, and jumps to that location:\\nExit is used to break out of loops. Exit can be used with a label to break out of an inner loop to an outer loop and its enclosing outer loop\\nA sequence of operation can be aborted with an asynchronous transfer of control to an alternative:\\nThe alternative can be a delay statement or else an entry point call followed by a sequence of operations. The statement blocks at the delay or entry call and executes the sequence of the operation introduced by then abort. If blocking is lifted before completion of the sequence, the sequence is aborted and the control is transferred there.\\nSee also Exceptions to see how ALGOL 68 handles transput events.\\n","#include <iostream> \\n\\nint main()\\n{\\n LOOP:\\n  std::cout << \""Hello, World!\\n\"";\\n goto LOOP;\\n}"
"C++","Flow-control_structures","These are examples of control structures. You may also be interested in:\\n\\nDocument common flow-control structures.\\nOne common example of a flow-control structure is the    goto    construct.\\nNote that   Conditional Structures   and   Loop Structures   have their own articles/categories.\\n\\n\\nCommon 360 opcodes for flow-control structures:\\nTo perform a 'goto'.\\nTo perform a 'call' to a subroutine. The first register at execution time is the next sequential address to allow a 'return'.\\nFistly a compare instruction set the condition code (cc), secondly a conditional branch is performed.\\nTo perform unconditional loops.\\nBXLE to perform loops in old Fortran style with 3 registers.\\nBXH to perform backward loops with 3 registers.\\n\\nThe jump instruction immediately jumps to any address:\\nThe indirect jump instruction immediately jumps to the address contained in the address:\\nThe jump to subroutine instruction pushes the address of the next instruction minus one onto the stack and jumps to any address:\\nA return from subroutine instruction pops the return address off the stack, adds one, and jumps to that location:\\nA break instruction causes a non-maskable interrupt (setting the interrupt flag), pushes the current program counter address plus one onto the stack, pushes the flags onto the stack, then jumps to the address in the break vector (commonly at $FFFE and $FFFF):\\nThe return from interrupt instruction pops the flags off the stack, pops the return address off the stack, adds one, and jumps to that location:\\nExit is used to break out of loops. Exit can be used with a label to break out of an inner loop to an outer loop and its enclosing outer loop\\nA sequence of operation can be aborted with an asynchronous transfer of control to an alternative:\\nThe alternative can be a delay statement or else an entry point call followed by a sequence of operations. The statement blocks at the delay or entry call and executes the sequence of the operation introduced by then abort. If blocking is lifted before completion of the sequence, the sequence is aborted and the control is transferred there.\\nSee also Exceptions to see how ALGOL 68 handles transput events.\\n","#include <iostream>\\n#include <ostream>\\n\\nvoid foo()\\n{\\n  std::cout << \""Going to throw an exception.\\n\"";\\n  throw 7; // almost any object can be thrown, including ints\\n  std::throw << \""This output will never execute.\\n\"";\\n}\\n\\nvoid bar()\\n{\\n  std::cout << \""Going to call foo().\\n\"";\\n  foo();\\n  std::cout << \""This will be skipped by the exception coming from foo.\\n\"";\\n}\\n\\nvoid baz()\\n{\\n  try // everything thrown from inside the following code block\\n  {   // will be covered by the following catch clauses\\n    std::cout << \""Going to call bar().\\n\"";\\n    bar();\\n    std::cout << \""This will be skipped by the exception coming from foo.\\n\"";\\n  }\\n  catch(...) // a simple catch-all, but doesn't give access to the thrown exception\\n  {\\n    std::cout << \""An exception occured. I'll just throw it on.\\n\"";\\n    throw; // without an argument, the caught exception is re-thrown\\n  }\\n  std::cout << \""This will not be executed due to the re-throw in the catch block\\n\"";\\n}\\n\\nvoid foobar()\\n{\\n  try\\n  {\\n    baz();\\n  }\\n  catch(char const* s)\\n  {\\n    std::cout << \""If foo had thrown a char const*, this code would be executed.\\n\"";\\n    std::cout << \""In that case, the thrown char const* would read \"" << s << \"".\\n\"";\\n  }\\n  catch(int i)\\n  {\\n    std::cout << \""Caught an int, with value \"" << i << \"" (should be 7).\\n\"";\\n    std::cout << \""Not rethrowing the int.\\n\"";\\n  }\\n  catch(...)\\n  {\\n    std::cout << \""This catch-all doesn't get invoked because the catch(int) above\\n\""\\n              << \""already took care of the exception (even if it had rethrown the\\n\""\\n              << \""exception, this catch-all would not be invoked, because it's\\n\""\\n              << \""only invoked for exceptions coming from the try block.\\n\"";\\n  }\\n  std::cout << \""This will be executed, since the exception was handled above, and not rethrown.\\n\"";\\n}\\n\\nint main()\\n{\\n  try\\n  {\\n    foobar();\\n  }\\n  catch(...)\\n  {\\n    std::cout << \""The main function never sees the exception, because it's completely handled\\n\""\\n              << \""inside foobar(). Thus this catch-all block never gets invoked.\\n\"";\\n  }\\n}"
"C++","Floyd's_triangle","Floyd's triangle   lists the natural numbers in a right triangle aligned to the left where\\n\\nThe first few lines of a Floyd triangle looks like this:\\n\\n\\nA very concise coding, an illustration of CISC power of the S/360 operation codes. Also an example of the use of EDMK and EX instructions.\\nFor macro usage see Structured Macros .\\n","\\n#include <windows.h>\\n#include <sstream>\\n#include <iostream>\\n\\n//--------------------------------------------------------------------------------------------------\\nusing namespace std;\\n\\n//--------------------------------------------------------------------------------------------------\\nclass floyds_tri\\n{\\npublic:\\n    floyds_tri()  { lastLineLen = 0; }\\n    ~floyds_tri() { killArray(); }\\n\\n    void create( int rows )\\n    {\\n	_rows = rows;\\n	calculateLastLineLen();\\n	display();\\n    }\\n\\nprivate:\\n    void killArray()\\n    {\\n	if( lastLineLen ) \\n	    delete [] lastLineLen;\\n    }\\n\\n    void calculateLastLineLen()\\n    {\\n	killArray();\\n	lastLineLen = new BYTE[_rows];\\n\\n	int s = 1 + ( _rows * ( _rows - 1 ) ) / 2;\\n\\n	for( int x = s, ix = 0; x < s + _rows; x++, ix++ )\\n	{\\n	    ostringstream cvr;\\n	    cvr << x;\\n	    lastLineLen[ix] = static_cast<BYTE>( cvr.str().size() );\\n	}\\n    }\\n\\n    void display()\\n    {\\n	cout << endl << \""Floyd\\'s Triangle - \"" << _rows << \"" rows\"" << endl << \""===============================================\"" << endl;\\n	int number = 1;\\n	for( int r = 0; r < _rows; r++ )\\n	{\\n	    for( int c = 0; c <= r; c++ )\\n	    {\\n		ostringstream cvr;\\n		cvr << number++;\\n		string str = cvr.str();\\n		while( str.length() < lastLineLen[c] )\\n		    str = \"" \"" + str;\\n		cout << str << \"" \"";\\n	    }\\n	    cout << endl;\\n	}\\n    }\\n\\n    int _rows;\\n    BYTE* lastLineLen;\\n};\\n//--------------------------------------------------------------------------------------------------\\nint main( int argc, char* argv[] )\\n{\\n    floyds_tri t;\\n    int s;\\n    while( true )\\n    {\\n	cout << \""Enter the size of the triangle ( 0 to QUIT ): \""; cin >> s;\\n	if( !s ) return 0;\\n	if( s > 0 ) t.create( s );\\n\\n	cout << endl << endl;\\n	system( \""pause\"" );\\n    }\\n\\n    return 0;\\n}\\n//--------------------------------------------------------------------------------------------------"
"C++","Forest_fire","\\nImplement the Drossel and Schwabl definition of the forest-fire model.\\n\\nIt is basically a 2D   cellular automaton   where each cell can be in three distinct states (empty, tree and burning) and evolves according to the following rules (as given by Wikipedia)\\nNeighborhood is the   Moore neighborhood;   boundary conditions are so that on the boundary the cells are always empty (\""fixed\"" boundary condition).\\nAt the beginning, populate the lattice with empty and tree cells according to a specific probability (e.g. a cell has the probability 0.5 to be a tree). Then, let the system evolve.\\nTask's requirements do not include graphical display or the ability to change parameters (probabilities    p    and    f )   through a graphical or command line interface.\\n\\n\\nSample output:\\nOutput:\\nThis implementation uses AutoHotkey's pseudo-arrays to contain each cell.\\nThe size of the (square) map, probabilities, and characters which correspond to burning, tree, or empty can be edited at the beginning of the script.\\nSample Output using the default settings:\\nOutput:\\n\\n\\nFreeBASIC[edit]\\n'[RC] Forest Fire'written for FreeBASIC 'Program code based on BASIC256 from Rosettacode website'http://rosettacode.org/wiki/Forest_fire#BASIC256'06-10-2016 updated/tweaked the code'compile with fbc -s gui #Define M 400#Define N 640 Dim As Double     p = 0.003Dim As Double  fire = 0.00003'Dim As Double number1Dim As Integer gen, x, yDim As String press 'f0() and fn() use memory from the memory poolDim As UByte f0(), fn()ReDim f0(-1 To N +2, -1 To M +2)ReDim fn(-1 To N +2, -1 To M +2) Dim As UByte white  = 15  'color 15 is whiteDim As UByte yellow = 14  'color 14 is yellowDim As UByte black  = 0   'color 0 is blackDim As UByte green  = 2   'color 2 is greenDim As UByte red    = 4   'color 4 is red Screen 18 'Resolution 640x480 with at least 256 colorsRandomize Timer Locate 28,1BeepPrint \"" Welcome to Forest Fire\""Locate 29,1Print \"" press any key to start\""Sleep'Locate 28,1'Print \"" Welcome to Forest Fire\""Locate 29,1Print \""                       \"" ' 1 tree, 0 empty, 2 fireColor green ' this is green color for treesFor x = 1 To N  For y = 1 To M    If Rnd < 0.5 Then 'populate original tree density      f0(x,y) = 1      PSet (x,y)    End If  Next yNext x Color whiteLocate 29,1Print \"" Press any key to continue                        \""SleepLocate 29,1Print \"" Press 'space bar' to continue/pause, ESC to stop \"" Do  press = InKey  ScreenLock  For x = 1 To N    For y = 1 To M      If Not f0(x,y) And Rnd<P Then fn(x,y)=1      If f0(x,y)=2 Then fn(x,y)=0      If f0(x,y)=1 Then        fn(x,y) = 1        If f0(x-1,y-1)=2 OrElse f0(x,y-1)=2 OrElse f0(x+1,y-1)=2 Then fn(x,y)=2        If f0(x-1,y)=2 OrElse f0(x+1,y)=2 OrElse Rnd<fire Then fn(x,y)=2        If f0(x-1,y+1)=2 OrElse f0(x,y+1)=2 OrElse f0(x+1,y+1)=2 Then fn(x,y)=2      End If      'set up color and drawing      '0 empty (black),  1 tree (green), 2 fire (white)      If fn(x,y)=0 Then Color black 'empty      If fn(x,y)=1 Then Color green 'tree      If fn(x,y)=2 Then Color red   'fire      'plot x-1,y-1      PSet (x-1,y-1)    Next y  Next x  'print generation number  gen = gen + 1  Locate 28,1  Color white 'this is white color  Print \"" Generation number # \"";gen  'transfer new generation to current generation  For x = 1 To N    For y = 1 To M      f0(x,y) = fn(x,y)    Next y  Next x  ScreenUnlock   ' amount for sleep is in milliseconds, 1 = ignore key press  Sleep 50, 1  ' slow down a little ... goes too fast otherwise  If press = \"" \"" Then Sleep : press = InKey  If press = \""s\"" Then Sleep  ' return to do loop up top until \""esc\"" key is pressed.  ' clicking close windows \""X\"", closes the window immediately Loop Until press = Chr(27) OrElse press = Chr(255)+\""k\""If press = Chr(255) + \""k\"" Then End Locate 28,1Color whitePrint \"" You entered ESC - goodbye                        \""Print \"" Press any key to exit                            \""Sleep\\nGFA Basic[edit]\\n width%=80height%=50DIM world%(width%+2,height%+2,2)clock%=0'empty%=0 ! some mnemonic codes for the different statesburning%=1tree%=2'f=0.0003p=0.03max_clock%=100'@open_window@setup_worldDO  clock%=clock%+1  EXIT IF clock%>max_clock%  @display_world  @update_worldLOOP@close_window'' Setup the world'PROCEDURE setup_world  LOCAL i%,j%  '  RANDOMIZE 0  ARRAYFILL world%(),empty%  ' with Probability 0.5, create tree in cells  FOR i%=1 TO width%    FOR j%=1 TO height%      IF RND>0.5        world%(i%,j%,0)=tree%      ENDIF    NEXT j%  NEXT i%  '  cur%=0  new%=1RETURN'' Display world on window'PROCEDURE display_world  LOCAL size%,i%,j%,offsetx%,offsety%,x%,y%  '  size%=5  offsetx%=10  offsety%=20  '  VSETCOLOR 0,15,15,15 ! colour for empty  VSETCOLOR 1,15,0,0 ! colour for burning  VSETCOLOR 2,0,15,0 ! colour for tree  VSETCOLOR 3,0,0,0 ! colour for text  DEFTEXT 3  PRINT AT(1,1);\""Clock: \"";clock%  '  FOR i%=1 TO width%    FOR j%=1 TO height%      x%=offsetx%+size%*i%      y%=offsety%+size%*j%      SELECT world%(i%,j%,cur%)      CASE empty%        DEFFILL 0      CASE tree%        DEFFILL 2      CASE burning%        DEFFILL 1      ENDSELECT      PBOX x%,y%,x%+size%,y%+size%    NEXT j%  NEXT i%RETURN'' Check if a neighbour is burning'FUNCTION neighbour_burning(i%,j%)  LOCAL x%  '  IF world%(i%,j%-1,cur%)=burning%    RETURN TRUE  ENDIF  IF world%(i%,j%+1,cur%)=burning%    RETURN TRUE  ENDIF  FOR x%=-1 TO 1    IF world%(i%-1,j%+x%,cur%)=burning% OR world%(i%+1,j%+x%,cur%)=burning%      RETURN TRUE    ENDIF  NEXT x%  RETURN FALSEENDFUNC'' Update the world state'PROCEDURE update_world  LOCAL i%,j%  '  FOR i%=1 TO width%    FOR j%=1 TO height%      world%(i%,j%,new%)=world%(i%,j%,cur%)      SELECT world%(i%,j%,cur%)      CASE empty%        IF RND>1-p          world%(i%,j%,new%)=tree%        ENDIF      CASE tree%        IF @neighbour_burning(i%,j%) OR RND>1-f          world%(i%,j%,new%)=burning%        ENDIF      CASE burning%        world%(i%,j%,new%)=empty%      ENDSELECT    NEXT j%  NEXT i%  '  cur%=1-cur%  new%=1-new%RETURN'' open and clear window'PROCEDURE open_window  OPENW 1  CLEARW 1  VSETCOLOR 4,8,8,0  DEFFILL 4  PBOX 0,0,500,400RETURN'' close the window after keypress'PROCEDURE close_window  ~INP(2)  CLOSEW 1RETURN \\nPureBasic[edit]\\n; Some systems reports high CPU-load while running this code.; This may likely be due to the graphic driver used in the ; 2D-function Plot().; If experiencing this problem, please reduce the #Width & #Height; or activate the parameter #UnLoadCPU below with a parameter 1 or 2.;; This code should work with the demo version of PureBasic on both PC & Linux ; General parameters for the world#f    = 1e-6#p    = 1e-2#SeedATree  = 0.005#Width      = 400#Height     = 400 ; Setting up colours#Fire       = $080CF7#BackGround = $BFD5D3#YoungTree  = $00E300#NormalTree = $00AC00#MatureTree = $009500#OldTree    = $007600#Black      = $000000 ; Depending on your hardware, use this to control the speed/CPU-load.; 0 = No load reduction; 1 = Only active about every second frame; 2 = '1' & release the CPU after each horizontal line.#UnLoadCPU  = 0 Enumeration  #Empty  =0  #Ignited  #Burning  #Tree  #Old=#Tree+20EndEnumeration Global Dim Forest.i(#Width, #Height)Global Title$=\""Forest fire in PureBasic\""Global Cnt Macro Rnd()  (Random(2147483647)/2147483647.0)EndMacro Procedure Limit(n, min, max)  If n<min    n=min  ElseIf n>max    n=max  EndIf  ProcedureReturn nEndProcedure Procedure SpreadFire(x,y)  Protected cnt=0, i, j  For i=Limit(x-1, 0, #Width) To Limit(x+1, 0, #Width)    For j=Limit(y-1, 0, #Height) To Limit(y+1, 0, #Height)       If Forest(i,j)>=#Tree        Forest(i,j)=#Ignited      EndIf    Next  NextEndProcedure Procedure InitMap()  Protected x, y, type  For y=1 To #Height    For x=1 To #Width      If Rnd()<=#SeedATree        type=#Tree      Else        type=#Empty      EndIf      Forest(x,y)=type    Next  NextEndProcedure Procedure UpdateMap()  Protected x, y  For y=1 To #Height    For x=1 To #Width      Select Forest(x,y)        Case #Burning          Forest(x,y)=#Empty          SpreadFire(x,y)        Case #Ignited          Forest(x,y)=#Burning        Case #Empty          If Rnd()<=#p            Forest(x,y)=#Tree          EndIf        Default          If Rnd()<=#f            Forest(x,y)=#Burning          Else            Forest(x,y)+1          EndIf      EndSelect    Next  NextEndProcedure Procedure PresentMap()  Protected x, y, c    cnt+1  SetWindowTitle(0,Title$+\"", time frame=\""+Str(cnt))  StartDrawing(ImageOutput(1))  For y=0 To OutputHeight()-1    For x=0 To OutputWidth()-1      Select Forest(x,y)        Case #Empty          c=#BackGround        Case #Burning, #Ignited          c=#Fire        Default          If Forest(x,y)<#Tree+#Old            c=#YoungTree          ElseIf Forest(x,y)<#Tree+2*#Old            c=#NormalTree          ElseIf Forest(x,y)<#Tree+3*#Old            c=#MatureTree          ElseIf Forest(x,y)<#Tree+4*#Old            c=#OldTree          Else ; Tree died of old age            Forest(x,y)=#Empty            c=#Black          EndIf      EndSelect      Plot(x,y,c)    Next    CompilerIf #UnLoadCPU>1      Delay(1)    CompilerEndIf  Next  StopDrawing()  ImageGadget(1, 0, 0, #Width, #Height, ImageID(1))EndProcedure If OpenWindow(0, 10, 30, #Width, #Height, Title$, #PB_Window_MinimizeGadget)  SmartWindowRefresh(0, 1)  If CreateImage(1, #Width, #Height)    Define Event, freq    If ExamineDesktops() And DesktopFrequency(0)      freq=DesktopFrequency(0)    Else      freq=60    EndIf    AddWindowTimer(0,0,5000/freq)    InitMap()    Repeat      Event = WaitWindowEvent()      Select Event        Case #PB_Event_CloseWindow          End        Case #PB_Event_Timer          CompilerIf #UnLoadCPU>0            Delay(25)          CompilerEndIf          UpdateMap()          PresentMap()      EndSelect    ForEver  EndIf EndIf\\n\\n\\nREALbasic[edit]\\nThis example puts all of the forestry logic into a Thread class. This allows the UI to remain responsive while the Thread does all the work in the background. We create a Thread by subclassing the Thread object in the IDE, in this case creating forestfire as a subclass of the Thread object and put the following code in its Run() event:\\n\\n Sub Run()  //Handy named constants  Const empty = 0  Const tree = 1  Const fire = 2  Const ablaze = &cFF0000    //Using the &c numeric operator to indicate a color in hex  Const alive = &c00FF00  Const dead = &c804040   //Our forest  Dim worldPic As New Picture(480, 480, 32)  Dim newWorld(120, 120) As Integer  Dim oldWorld(120, 120) As Integer   //Initialize forest  Dim rand As New Random  For x as Integer = 0 to 119    For y as Integer = 0 to 119      if rand.InRange(0, 2) = 0 Or x = 119 or y = 119 or x = 0 or y = 0 Then        newWorld(x, y) = empty        worldPic.Graphics.ForeColor = dead        worldPic.Graphics.FillRect(x*4, y*4, 4, 4)      Else        newWorld(x, y) = tree        worldPic.Graphics.ForeColor = alive        worldPic.Graphics.FillRect(x*4, y*4, 4, 4)      end if    Next  Next  oldWorld = newWorld   //Burn, baby burn!  While Window1.stop = False    For x as Integer = 0 To 119      For y As Integer = 0 to 119        Dim willBurn As Integer = rand.InRange(0, Window1.burnProb.Value)        Dim willGrow As Integer = rand.InRange(0, Window1.growProb.Value)        if x = 119 or y = 119 or x = 0 or y = 0 Then          Continue        end if        Select Case oldWorld(x, y)        Case empty          If willGrow = (Window1.growProb.Value) Then            newWorld(x, y) = tree            worldPic.Graphics.ForeColor = alive            worldPic.Graphics.FillRect(x*4, y*4, 4, 4)          end if        Case tree          if oldWorld(x - 1, y) = fire Or oldWorld(x, y - 1) = fire Or oldWorld(x + 1, y) = fire Or oldWorld(x, y + 1) = fire Or oldWorld(x + 1, y + 1) = fire Or oldWorld(x - 1, y - 1) = fire Or oldWorld(x - 1, y + 1) = fire Or oldWorld(x + 1, y - 1) = fire Or willBurn = (Window1.burnProb.Value) Then            newWorld(x, y) = fire            worldPic.Graphics.ForeColor = ablaze            worldPic.Graphics.FillRect(x*4, y*4, 4, 4)          end if        Case fire          newWorld(x, y) = empty          worldPic.Graphics.ForeColor = dead          worldPic.Graphics.FillRect(x*4, y*4, 4, 4)        End Select      Next    Next    Window1.Canvas1.Graphics.DrawPicture(worldPic, 0, 0)    oldWorld = newWorld    me.Sleep(Window1.speed.Value)  WendEnd Sub \\nAs you can see, this Thread is expecting a Window object called Window1 with several other objects within it. The IDE will automatically create a Window object called Window1 when a new GUI application is created. Our Window1 has 5 objects (widgets) in it: a Canvas (for displaying graphics), three sliders, and a pushbutton.\\n\\n Sub Open()  //First method to run on the creation of a new Window. We instantiate an instance of our forestFire thread and run it.  Dim fire As New forestFire  fire.Run()End Sub stop As Boolean  //a globally accessible property of Window1. Boolean properties default to False. Sub Pushbutton1.Action()  stop = TrueEnd Sub \\n\\n\\nRun BASIC[edit]\\ngraphic #g, 200,200dim preGen(200,200)dim newGen(200,200) for gen = 1 to 200  for x = 1 to 199    for y = 1 to 199      select case preGen(x,y)        case 0          if rnd(0) > .99 then newGen(x,y) = 1  : #g \""color green ; set \""; x; \"" \""; y        case 2          newGen(x,y) = 0                       : #g \""color brown ; set \""; x; \"" \""; y        case 1          if preGen(x-1,y-1) = 2 or preGen(x-1,y)   = 2 or preGen(x-1,y+1) = 2 _          or preGen(x,y-1)   = 2 or preGen(x,y+1)   = 2 or preGen(x+1,y-1) = 2 _          or preGen(x+1,y)   = 2 or preGen(x+1,y+1) = 2 or rnd(0) > .999 then              #g \""color red ; set \""; x; \"" \""; y              newGen(x,y) = 2          end if      end select      preGen(x-1,y-1) = newGen(x-1,y-1)    next y  next xnext genrender #g\\n\\n\\nSinclair ZX81 BASIC[edit]\\nRequires 16k of RAM.\\nIn essence this is an enhanced version of my ZX Spectrum implementation (see below). The main improvement is that this version shows the ages of the trees: the age is represented using 0 to 9, then A to Z, followed theoretically by the special characters £$:?()><=+-*/;,. (in that order) and only then cycling back to 0. Realistically, no tree is likely to live that long.\\nThe subroutine at line 1000 takes a number N and returns its inverse-video string representation as I$.\\nA couple of other notes on the listing:\\n(1) some characters need to be entered in Graphics mode, which is accessed using SHIFT9. I have represented this using square brackets: so if the listing says [ROSETTA CODE], you need to go into G mode and type ROSETTA CODE (which will be displayed on the ZX81 screen in inverse video). As a special case, [a] means for you to go into G mode and then type SHIFTA. The ZX81 character set does not include either square brackets or lower-case letters, so I hope this convention will not lead to too much confusion.\\n(2) this program differs from most BASIC examples on Rosetta Code, but resembles most real BASIC programs of more than about 20 lines, in that the line numbers do not always go up smoothly in multiples of ten.\\n\\n  10 DIM F$(20,30)  20 DIM N$(20,30)  30 LET INIT=.5  40 LET F=.02  50 LET P=.05  60 PRINT AT 0,1;\""[FOREST FIRE   FOR ROSETTA CODE]\""  70 FOR I=0 TO 21  80 PRINT AT I,0;\""[ ]\""  90 PRINT AT I,31;\""[ ]\"" 100 NEXT I 110 FOR I=1 TO 30 120 PRINT AT 21,I;\""[ ]\"" 130 NEXT I 140 LET G=0 150 LET T=0 160 PRINT AT 21,1;\""[GENERATION 0]\"" 170 PRINT AT 21,20;\""[COVER]\"" 180 FOR I=1 TO 20 190 FOR J=1 TO 30 200 IF RND>=INIT THEN GOTO 240 210 PRINT AT I,J;\""0\"" 220 LET F$(I,J)=\""0\"" 230 LET T=T+1 240 NEXT J 250 NEXT I 300 PRINT AT 21,26;\""[      ]\"" 310 LET N=INT (.5+T/6) 320 GOSUB 1000 330 PRINT AT 21,26;I$;\""[ PC]\"" 340 FOR I=1 TO 20 350 PRINT AT I,0;\""[>]\"" 360 FOR J=1 TO 30 380 IF F$(I,J)<>\""[a]\"" THEN GOTO 410 390 LET N$(I,J)=\"" \"" 400 GOTO 530 410 IF F$(I,J)<>\"" \"" THEN GOTO 433 420 IF RND<=P THEN LET N$(I,J)=\""0\"" 430 GOTO 530 433 LET N$(I,J)=CHR$ (1+CODE F$(I,J)) 437 IF N$(I,J)>\""Z\"" THEN LET N$(I,J)=\""£\"" 440 FOR K=I-1 TO I+1 450 FOR L=J-1 TO J+1 460 IF K=0 OR L=0 OR K=21 OR L=21 THEN GOTO 480 470 IF F$(K,L)=\""[a]\"" THEN GOTO 510 480 NEXT L 490 NEXT K 500 GOTO 520 510 LET N$(I,J)=\""[a]\"" 520 IF RND<=F THEN LET N$(I,J)=\""[a]\"" 530 NEXT J 540 PRINT AT I,0;\""[ ]\"" 550 NEXT I 552 LET G=G+1 554 LET N=G 556 GOSUB 1000 558 PRINT AT 21,12;I$ 560 LET T=0 570 FOR I=1 TO 20 575 PRINT AT I,31;\""[<]\"" 580 FOR J=1 TO 30 590 IF N$(I,J)<>\""[a]\"" AND N$(I,J)<>\"" \"" THEN LET T=T+1 600 NEXT J 610 LET F$(I)=N$(I) 620 PRINT AT I,1;F$(I) 625 PRINT AT I,31;\""[ ]\"" 630 GOTO 3001000 LET S$=STR$ N1010 LET I$=\""\""1020 FOR K=1 TO LEN S$1030 LET I$=I$+CHR$ (128+CODE S$(K))1040 NEXT K1050 RETURN\\n\\nOutput:\\nThis example puts all of the forestry logic into a Thread class. This allows the UI to remain responsive while the Thread does all the work in the background. We create a Thread by subclassing the Thread object in the IDE, in this case creating forestfire as a subclass of the Thread object and put the following code in its Run() event:\\nAs you can see, this Thread is expecting a Window object called Window1 with several other objects within it. The IDE will automatically create a Window object called Window1 when a new GUI application is created. Our Window1 has 5 objects (widgets) in it: a Canvas (for displaying graphics), three sliders, and a pushbutton.\\n\\n\\nRequires 16k of RAM.\\nIn essence this is an enhanced version of my ZX Spectrum implementation (see below). The main improvement is that this version shows the ages of the trees: the age is represented using 0 to 9, then A to Z, followed theoretically by the special characters £$:?()><=+-*/;,. (in that order) and only then cycling back to 0. Realistically, no tree is likely to live that long.\\nThe subroutine at line 1000 takes a number N and returns its inverse-video string representation as I$.\\nA couple of other notes on the listing:\\n(1) some characters need to be entered in Graphics mode, which is accessed using SHIFT9. I have represented this using square brackets: so if the listing says [ROSETTA CODE], you need to go into G mode and type ROSETTA CODE (which will be displayed on the ZX81 screen in inverse video). As a special case, [a] means for you to go into G mode and then type SHIFTA. The ZX81 character set does not include either square brackets or lower-case letters, so I hope this convention will not lead to too much confusion.\\n(2) this program differs from most BASIC examples on Rosetta Code, but resembles most real BASIC programs of more than about 20 lines, in that the line numbers do not always go up smoothly in multiples of ten.\\n","\\n#include <windows.h>\\n#include <string>\\n\\n//--------------------------------------------------------------------------------------------------\\nusing namespace std;\\n\\n//--------------------------------------------------------------------------------------------------\\nenum states { NONE, TREE, FIRE };\\nconst int MAX_SIDE = 500;\\n\\n//--------------------------------------------------------------------------------------------------\\nclass myBitmap\\n{\\npublic:\\n    myBitmap() : pen( NULL ) {}\\n    ~myBitmap()\\n    {\\n	DeleteObject( pen );\\n	DeleteDC( hdc );\\n	DeleteObject( bmp );\\n    }\\n\\n    bool create( int w, int h )\\n    {\\n	BITMAPINFO	bi;\\n	ZeroMemory( &bi, sizeof( bi ) );\\n\\n	bi.bmiHeader.biSize	   = sizeof( bi.bmiHeader );\\n	bi.bmiHeader.biBitCount	   = sizeof( DWORD ) * 8;\\n	bi.bmiHeader.biCompression = BI_RGB;\\n	bi.bmiHeader.biPlanes	   = 1;\\n	bi.bmiHeader.biWidth	   =  w;\\n	bi.bmiHeader.biHeight	   = -h;\\n\\n	HDC dc = GetDC( GetConsoleWindow() );\\n	bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );\\n	if( !bmp ) return false;\\n\\n	hdc = CreateCompatibleDC( dc );\\n	SelectObject( hdc, bmp );\\n	ReleaseDC( GetConsoleWindow(), dc ); \\n\\n	width = w; height = h;\\n\\n	return true;\\n    }\\n\\n    void clear()\\n    {\\n	ZeroMemory( pBits, width * height * sizeof( DWORD ) );\\n    }\\n\\n    void setPenColor( DWORD clr )\\n    {\\n	if( pen ) DeleteObject( pen );\\n	pen = CreatePen( PS_SOLID, 1, clr );\\n	SelectObject( hdc, pen );\\n    }\\n\\n    void saveBitmap( string path )\\n    {\\n	BITMAPFILEHEADER fileheader;\\n	BITMAPINFO	 infoheader;\\n	BITMAP		 bitmap;\\n	DWORD		 wb;\\n\\n	GetObject( bmp, sizeof( bitmap ), &bitmap );\\n\\n	DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];\\n	ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );\\n	ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );\\n	ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );\\n\\n	infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;\\n	infoheader.bmiHeader.biCompression = BI_RGB;\\n	infoheader.bmiHeader.biPlanes = 1;\\n	infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );\\n	infoheader.bmiHeader.biHeight = bitmap.bmHeight;\\n	infoheader.bmiHeader.biWidth = bitmap.bmWidth;\\n	infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );\\n\\n	fileheader.bfType    = 0x4D42;\\n	fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );\\n	fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;\\n\\n	GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );\\n\\n	HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );\\n	WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );\\n	WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );\\n	WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );\\n	CloseHandle( file );\\n\\n	delete [] dwpBits;\\n    }\\n\\n    HDC getDC() const     { return hdc; }\\n    int getWidth() const  { return width; }\\n    int getHeight() const { return height; }\\n\\nprivate:\\n    HBITMAP bmp;\\n    HDC	    hdc;\\n    HPEN    pen;\\n    void	*pBits;\\n    int	    width, height;\\n};\\n//--------------------------------------------------------------------------------------------------\\nclass forest\\n{\\npublic:\\n    forest()\\n    {\\n	_bmp.create( MAX_SIDE, MAX_SIDE ); \\n	initForest( 0.05f, 0.005f );\\n    }\\n\\n    void initForest( float p, float f )\\n    {\\n	_p = p; _f = f;\\n	seedForest();\\n    }\\n\\n    void mainLoop()\\n    {\\n	display();\\n	simulate();\\n    }\\n\\n    void setHWND( HWND hwnd ) { _hwnd = hwnd; }\\n\\nprivate:\\n    float probRand() { return ( float )rand() / 32768.0f; }\\n	\\n    void display()\\n    {\\n	HDC bdc = _bmp.getDC();\\n	DWORD clr;\\n\\n	for( int y = 0; y < MAX_SIDE; y++ )\\n	{\\n	    for( int x = 0; x < MAX_SIDE; x++ )\\n	    {\\n		switch( _forest[x][y] )\\n		{\\n		    case FIRE: clr = 255; break;\\n		    case TREE: clr = RGB( 0, 255, 0 ); break;\\n		    default: clr = 0;\\n		}\\n\\n		SetPixel( bdc, x, y, clr );\\n	    }\\n	}\\n\\n	HDC dc = GetDC( _hwnd );\\n	BitBlt( dc, 0, 0, MAX_SIDE, MAX_SIDE, _bmp.getDC(), 0, 0, SRCCOPY );\\n	ReleaseDC( _hwnd, dc );\\n    }\\n\\n    void seedForest()\\n    {\\n	ZeroMemory( _forestT, sizeof( _forestT ) );\\n	ZeroMemory( _forest, sizeof( _forest ) );\\n	for( int y = 0; y < MAX_SIDE; y++ )\\n	    for( int x = 0; x < MAX_SIDE; x++ )\\n		if( probRand() < _p ) _forest[x][y] = TREE;\\n    }\\n\\n    bool getNeighbors( int x, int y )\\n    {\\n	int a, b;\\n	for( int yy = -1; yy < 2; yy++ )\\n	    for( int xx = -1; xx < 2; xx++ )\\n	    {\\n		if( !xx && !yy ) continue;\\n		a = x + xx; b = y + yy;\\n		if( a < MAX_SIDE && b < MAX_SIDE && a > -1 && b > -1 )\\n		if( _forest[a][b] == FIRE ) return true;\\n	    }\\n\\n	return false;\\n    }\\n\\n    void simulate()\\n    {\\n	for( int y = 0; y < MAX_SIDE; y++ )\\n	{\\n	    for( int x = 0; x < MAX_SIDE; x++ )\\n	    {\\n		switch( _forest[x][y] )\\n		{\\n		    case FIRE: _forestT[x][y] = NONE; break;\\n		    case NONE: if( probRand() < _p ) _forestT[x][y] = TREE; break;\\n		    case TREE: if( getNeighbors( x, y ) || probRand() < _f ) _forestT[x][y] = FIRE;\\n		}\\n	    }\\n	}\\n\\n	for( int y = 0; y < MAX_SIDE; y++ )\\n	    for( int x = 0; x < MAX_SIDE; x++ )\\n		_forest[x][y] = _forestT[x][y];\\n    }\\n\\n    myBitmap _bmp;\\n    HWND     _hwnd;\\n    BYTE     _forest[MAX_SIDE][MAX_SIDE], _forestT[MAX_SIDE][MAX_SIDE];\\n    float    _p, _f;\\n};\\n//--------------------------------------------------------------------------------------------------\\nclass wnd\\n{\\npublic:\\n    int wnd::Run( HINSTANCE hInst )\\n    {\\n	_hInst = hInst;\\n	_hwnd = InitAll();\\n\\n	_ff.setHWND( _hwnd );\\n	_ff.initForest( 0.02f, 0.001f );\\n\\n	ShowWindow( _hwnd, SW_SHOW );\\n	UpdateWindow( _hwnd );\\n\\n	MSG msg;\\n	ZeroMemory( &msg, sizeof( msg ) );\\n	while( msg.message != WM_QUIT )\\n	{\\n	    if( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) != 0 )\\n	    {\\n		TranslateMessage( &msg );\\n		DispatchMessage( &msg );\\n	    }\\n	    else\\n	    {\\n		_ff.mainLoop();\\n	    }\\n	}\\n	return UnregisterClass( \""_FOREST_FIRE_\"", _hInst );\\n    }\\nprivate:\\n    static int WINAPI wnd::WndProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )\\n    {\\n	switch( msg )\\n	{\\n	    case WM_DESTROY: PostQuitMessage( 0 ); break;\\n	    default:\\n		return DefWindowProc( hWnd, msg, wParam, lParam );\\n	}\\n	return 0;\\n    }\\n\\n    HWND InitAll()\\n    {\\n	WNDCLASSEX wcex;\\n	ZeroMemory( &wcex, sizeof( wcex ) );\\n	wcex.cbSize	       = sizeof( WNDCLASSEX );\\n	wcex.style	       = CS_HREDRAW | CS_VREDRAW;\\n	wcex.lpfnWndProc   = ( WNDPROC )WndProc;\\n	wcex.hInstance     = _hInst;\\n	wcex.hCursor       = LoadCursor( NULL, IDC_ARROW );\\n	wcex.hbrBackground = ( HBRUSH )( COLOR_WINDOW + 1 );\\n	wcex.lpszClassName = \""_FOREST_FIRE_\"";\\n\\n	RegisterClassEx( &wcex );\\n \\n	return CreateWindow( \""_FOREST_FIRE_\"", \"".: Forest Fire -- PJorente :.\"", WS_SYSMENU, CW_USEDEFAULT, 0, MAX_SIDE, MAX_SIDE, NULL, NULL, _hInst, NULL );\\n    }\\n\\n    HINSTANCE _hInst;\\n    HWND      _hwnd;\\n    forest    _ff;\\n};\\n//--------------------------------------------------------------------------------------------------\\nint APIENTRY _tWinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow )\\n{\\n    srand( GetTickCount() );\\n    wnd myWnd;\\n    return myWnd.Run( hInstance );\\n}\\n//--------------------------------------------------------------------------------------------------\\n"
"C++","Fork","Spawn a new process which can run simultaneously with, and independently of, the original parent process.\\n\\nOutput:\\n","#include<iostream>\\n#include<unistd.h>\\n\\nint main()\\n{\\n  pid_t pid = fork();\\n\\n  if (pid == 0)\\n  {\\n    std::cout << \""This is the new process\\n\"";\\n  }\\n  else if (pid > 0)\\n  {\\n    std::cout << \""This is the original process\\n\"";\\n  }\\n  else\\n  {\\n    std::cerr << \""ERROR: Something went wrong\\n\"";\\n  }\\n\\n  return 0;\\n}"
"C++","Formatted_numeric_output","Express a number in decimal as a fixed-length string with leading zeros.\\n\\nFor example, the number   7.125   could be expressed as   00007.125.\\n\\n","#include <iostream>\\n#include <iomanip>\\n\\nint main()\\n{\\n  std::cout << std::setfill('0') << std::setw(9) << std::fixed << std::setprecision(3) << 7.125 << std::endl;\\n  return 0;\\n}"
"C++","Forward_difference","Provide code that produces a list of numbers which is the   nth  order forward difference, given a non-negative integer (specifying the order) and a list of numbers.\\n\\nThe first-order forward difference of a list of numbers   A   is a new list   B,   where   Bn = An+1 - An.\\nList   B   should have one fewer element as a result.\\nThe second-order forward difference of   A   will be:\\nThe same as the first-order forward difference of   B.\\nThat new list will have two fewer elements than   A   and one less than   B.\\nThe goal of this task is to repeat this process up to the desired order.\\nFor a more formal description, see the related   Mathworld article.\\n\\n\\n","#include <vector>\\n#include <iterator>\\n#include <algorithm>\\n\\n// calculate first order forward difference\\n// requires:\\n// * InputIterator is an input iterator\\n// * OutputIterator is an output iterator\\n// * The value type of InputIterator is copy-constructible and assignable\\n// * The value type of InputIterator supports operator -\\n// * The result type of operator- is assignable to the value_type of OutputIterator\\n// returns: The iterator following the output sequence\\ntemplate\\n OutputIterator forward_difference(InputIterator first, InputIterator last,\\n                                   OutputIterator dest)\\n{\\n  // special case: for empty sequence, do nothing\\n  if (first == last)\\n    return dest;\\n\\n  typedef typename std::iterator_traits<InputIterator>::value_type value_type;\\n\\n  value_type temp = *first++;\\n  while (first != last)\\n  {\\n    value_type temp2 = *first++;\\n    *dest++ = temp2 - temp;\\n    temp = temp2;\\n  }\\n\\n  return dest;\\n}\\n\\n// calculate n-th order forward difference.\\n// requires:\\n// * InputIterator is an input iterator\\n// * OutputIterator is an output iterator\\n// * The value type of InputIterator is copy-constructible and assignable\\n// * The value type of InputIterator supports operator -\\n// * The result type of operator- is assignable to the value_type of InputIterator\\n// * The result type of operator- is assignable to the value_type of OutputIterator\\n// * order >= 0\\n// returns: The iterator following the output sequence\\ntemplate\\n OutputIterator nth_forward_difference(int order,\\n                                       InputIterator first, InputIterator last,\\n                                       OutputIterator dest)\\n{\\n  // special case: If order == 0, just copy input to output\\n  if (order == 0)\\n    return std::copy(first, last, dest);\\n\\n  // second special case: If order == 1, just forward to the first-order function\\n  if (order == 1)\\n    return forward_difference(first, last, dest);\\n\\n  // intermediate results are stored in a vector\\n  typedef typename std::iterator_traits<InputIterator>::value_type value_type;\\n  std::vector temp_storage;\\n\\n  // fill the vector with the result of the first order forward difference\\n  forward_difference(first, last, std::back_inserter(temp_storage));\\n\\n  // the next n-2 iterations work directly on the vector\\n  typename std::vector::iterator begin = temp_storage.begin(),\\n                                             end = temp_storage.end();\\n  for (int i = 1; i < order-1; ++i)\\n    end = forward_difference(begin, end, begin);\\n\\n  // the final iteration writes directly to the output iterator\\n  return forward_difference(begin, end, dest);\\n}\\n\\n// example usage code\\n#include <iostream>\\n\\nint main()\\n{\\n  double array[10] = { 90.0, 47.0, 58.0, 29.0, 22.0, 32.0, 55.0, 5.0, 55.0, 73.0 };\\n\\n  // this stores the results in the vector dest\\n  std::vector<double> dest;\\n  nth_forward_difference(1, array, array+10, std::back_inserter(dest));\\n\\n  // output dest\\n  std::copy(dest.begin(), dest.end(), std::ostream_iterator<double>(std::cout, \"" \""));\\n  std::cout << std::endl;\\n\\n  // however, the results can also be output as they are calculated\\n  nth_forward_difference(2, array, array+10, std::ostream_iterator<double>(std::cout, \"" \""));\\n  std::cout << std::endl;\\n\\n  nth_forward_difference(9, array, array+10, std::ostream_iterator<double>(std::cout, \"" \""));\\n  std::cout << std::endl;\\n\\n  nth_forward_difference(10, array, array+10, std::ostream_iterator<double>(std::cout, \"" \""));\\n  std::cout << std::endl;\\n\\n  nth_forward_difference(0, array, array+10, std::ostream_iterator<double>(std::cout, \"" \""));\\n  std::cout << std::endl;\\n\\n  // finally, the results can also be written into the original array\\n  // (which of course destroys the original content)\\n  double* end = nth_forward_difference(3, array, array+10, array);\\n\\n  for (double* p = array; p < end; ++p)\\n    std::cout << *p << \"" \"";\\n  std::cout << std::endl;\\n\\n  return 0;\\n}"
"C++","Forward_difference","Provide code that produces a list of numbers which is the   nth  order forward difference, given a non-negative integer (specifying the order) and a list of numbers.\\n\\nThe first-order forward difference of a list of numbers   A   is a new list   B,   where   Bn = An+1 - An.\\nList   B   should have one fewer element as a result.\\nThe second-order forward difference of   A   will be:\\nThe same as the first-order forward difference of   B.\\nThat new list will have two fewer elements than   A   and one less than   B.\\nThe goal of this task is to repeat this process up to the desired order.\\nFor a more formal description, see the related   Mathworld article.\\n\\n\\n","\\n#include <iostream>\\n#include <numeric>\\n// Calculate the Forward Difference of a series if integers showing each order\\n//\\n// Nigel Galloway. August 20th., 2012\\n//\\nint main() {\\n    int x[] = {NULL,-43,11,-29,-7,10,23,-50,50,18};\\n    const int N = sizeof(x) / sizeof(int) - 1;\\n    for (int ord = 0; ord < N - 1; ord++) {\\n        std::adjacent_difference(x+1, x + N + 1 - ord, x);\\n        for (int i = 1; i < N - ord; i++) std::cout << x[i] << ' ';\\n        std::cout << std::endl;\\n    }\\n    return 0;\\n}\\n"
"C++","Forward_difference","Provide code that produces a list of numbers which is the   nth  order forward difference, given a non-negative integer (specifying the order) and a list of numbers.\\n\\nThe first-order forward difference of a list of numbers   A   is a new list   B,   where   Bn = An+1 - An.\\nList   B   should have one fewer element as a result.\\nThe second-order forward difference of   A   will be:\\nThe same as the first-order forward difference of   B.\\nThat new list will have two fewer elements than   A   and one less than   B.\\nThe goal of this task is to repeat this process up to the desired order.\\nFor a more formal description, see the related   Mathworld article.\\n\\n\\n","\\n#include <iostream>\\n#include <numeric>\\n// Calculate the Forward Difference of a series if integers\\n//\\n// Nigel Galloway. August 20th., 2012\\n//\\nint main() {\\n    int x[] = {NULL,-43,11,-29,-7,10,23,-50,50,18};\\n    const int N = sizeof(x) / sizeof(int) - 1;\\n    for (int ord = 0; ord < N - 1; ord++) std::adjacent_difference(x+1, x + N + 1 - ord, x);\\n    std::cout << x[1] << std::endl;\\n    return 0;\\n}\\n"
"C++","Forward_difference","Provide code that produces a list of numbers which is the   nth  order forward difference, given a non-negative integer (specifying the order) and a list of numbers.\\n\\nThe first-order forward difference of a list of numbers   A   is a new list   B,   where   Bn = An+1 - An.\\nList   B   should have one fewer element as a result.\\nThe second-order forward difference of   A   will be:\\nThe same as the first-order forward difference of   B.\\nThat new list will have two fewer elements than   A   and one less than   B.\\nThe goal of this task is to repeat this process up to the desired order.\\nFor a more formal description, see the related   Mathworld article.\\n\\n\\n","\\n#include <iostream>\\n#include <algorithm>\\n// Calculate the Forward Difference of a series if integers using Pascal's Triangle\\n// For this example the 9th line of Pascal's Triangle is stored in P.\\n// \\n// Nigel Galloway. August 20th., 2012\\n//\\nint main() {\\n    const int P[] = {1,-8,28,-56,70,-56,28,-8,1};\\n    int x[] = {-43,11,-29,-7,10,23,-50,50,18};\\n    std::transform(x, x + sizeof(x) / sizeof(int), P, x, std::multiplies<int>());\\n    std::cout << std::accumulate(x, x + sizeof(x) / sizeof(int), 0) << std::endl;\\n    return 0;\\n}\\n"
"C++","Fractal_tree","Generate and draw a fractal tree.\\n\\n\\nImage - Link, since uploads seem to be disabled currently.\\n","\\n#include <windows.h>\\n#include <string>\\n#include <math.h>\\n\\n//--------------------------------------------------------------------------------------------------\\nusing namespace std;\\n\\n//--------------------------------------------------------------------------------------------------\\nconst float PI = 3.1415926536f;\\n\\n//--------------------------------------------------------------------------------------------------\\nclass myBitmap\\n{\\npublic:\\n    myBitmap() : pen( NULL ) {}\\n    ~myBitmap()\\n    {\\n	DeleteObject( pen );\\n	DeleteDC( hdc );\\n	DeleteObject( bmp );\\n    }\\n\\n    bool create( int w, int h )\\n    {\\n	BITMAPINFO	bi;\\n	void		*pBits;\\n	ZeroMemory( &bi, sizeof( bi ) );\\n	bi.bmiHeader.biSize	   = sizeof( bi.bmiHeader );\\n	bi.bmiHeader.biBitCount	   = sizeof( DWORD ) * 8;\\n	bi.bmiHeader.biCompression = BI_RGB;\\n	bi.bmiHeader.biPlanes	   = 1;\\n	bi.bmiHeader.biWidth	   =  w;\\n	bi.bmiHeader.biHeight	   = -h;\\n\\n	HDC dc = GetDC( GetConsoleWindow() );\\n	bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );\\n	if( !bmp ) return false;\\n\\n	hdc = CreateCompatibleDC( dc );\\n	SelectObject( hdc, bmp );\\n	ReleaseDC( GetConsoleWindow(), dc ); \\n\\n	width = w; height = h;\\n\\n	return true;\\n    }\\n\\n    void setPenColor( DWORD clr )\\n    {\\n	if( pen ) DeleteObject( pen );\\n	pen = CreatePen( PS_SOLID, 1, clr );\\n	SelectObject( hdc, pen );\\n    }\\n\\n    void saveBitmap( string path )\\n    {\\n	BITMAPFILEHEADER	fileheader;\\n	BITMAPINFO			infoheader;\\n	BITMAP				bitmap;\\n	DWORD*				dwpBits;\\n	DWORD				wb;\\n	HANDLE				file;\\n\\n	GetObject( bmp, sizeof( bitmap ), &bitmap );\\n\\n	dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];\\n	ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );\\n	ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );\\n	ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );\\n\\n	infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;\\n	infoheader.bmiHeader.biCompression = BI_RGB;\\n	infoheader.bmiHeader.biPlanes = 1;\\n	infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );\\n	infoheader.bmiHeader.biHeight = bitmap.bmHeight;\\n	infoheader.bmiHeader.biWidth = bitmap.bmWidth;\\n	infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );\\n\\n	fileheader.bfType    = 0x4D42;\\n	fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );\\n	fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;\\n\\n	GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );\\n\\n	file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );\\n	WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );\\n	WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );\\n	WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );\\n	CloseHandle( file );\\n\\n	delete [] dwpBits;\\n    }\\n\\n    HDC getDC()     { return hdc; }\\n    int getWidth()  { return width; }\\n    int getHeight() { return height; }\\n\\nprivate:\\n    HBITMAP bmp;\\n    HDC	    hdc;\\n    HPEN    pen;\\n    int     width, height;\\n};\\n//--------------------------------------------------------------------------------------------------\\nclass vector2\\n{\\npublic:\\n    vector2() { x = y = 0; }\\n    vector2( int a, int b ) { x = a; y = b; }\\n    void set( int a, int b ) { x = a; y = b; }\\n    void rotate( float angle_r )\\n    {\\n	float _x = static_cast<float>( x ),\\n	      _y = static_cast<float>( y ),\\n	       s = sinf( angle_r ), \\n	       c = cosf( angle_r ),\\n	       a = _x * c - _y * s, \\n	       b = _x * s + _y * c;\\n\\n	x = static_cast<int>( a ); \\n	y = static_cast<int>( b );\\n    }\\n\\n    int x, y;\\n};\\n//--------------------------------------------------------------------------------------------------\\nclass fractalTree\\n{\\npublic:\\n    fractalTree()		      { _ang = DegToRadian( 24.0f ); }\\n    float DegToRadian( float degree ) { return degree * ( PI / 180.0f ); }\\n\\n    void create( myBitmap* bmp )\\n    {\\n	_bmp = bmp;\\n	float line_len = 130.0f;\\n\\n	vector2 sp( _bmp->getWidth() / 2, _bmp->getHeight() - 1 );\\n	MoveToEx( _bmp->getDC(), sp.x, sp.y, NULL );\\n	sp.y -= static_cast<int>( line_len );\\n	LineTo( _bmp->getDC(), sp.x, sp.y);\\n\\n	drawRL( &sp, line_len, 0, true );\\n	drawRL( &sp, line_len, 0, false );\\n    }\\n\\nprivate:\\n    void drawRL( vector2* sp, float line_len, float a, bool rg )\\n    {\\n	line_len *= .75f;\\n	if( line_len < 2.0f ) return;\\n\\n	MoveToEx( _bmp->getDC(), sp->x, sp->y, NULL );\\n	vector2 r( 0, static_cast<int>( line_len ) );\\n\\n        if( rg ) a -= _ang;\\n        else a += _ang; \\n\\n	r.rotate( a );\\n	r.x += sp->x; r.y = sp->y - r.y;\\n\\n	LineTo( _bmp->getDC(), r.x, r.y );\\n\\n	drawRL( &r, line_len, a, true );\\n	drawRL( &r, line_len, a, false );\\n    }\\n\\n    myBitmap* _bmp;\\n    float     _ang;\\n};\\n//--------------------------------------------------------------------------------------------------\\nint main( int argc, char* argv[] )\\n{\\n    ShowWindow( GetConsoleWindow(), SW_MAXIMIZE );\\n\\n    myBitmap bmp;\\n    bmp.create( 640, 512 );\\n    bmp.setPenColor( RGB( 255, 255, 0 ) );\\n\\n    fractalTree tree;\\n    tree.create( &bmp );\\n	\\n    BitBlt( GetDC( GetConsoleWindow() ), 0, 20, 648, 512, bmp.getDC(), 0, 0, SRCCOPY );\\n\\n    bmp.saveBitmap( \""f://rc//fracTree.bmp\"" );\\n	\\n    system( \""pause\"" );\\n	\\n    return 0;\\n}\\n//--------------------------------------------------------------------------------------------------\\n"
"C++","Fractran","FRACTRAN is a Turing-complete esoteric programming language invented by the mathematician John Horton Conway.\\nA FRACTRAN program is an ordered list of positive fractions \\n\\n\\n\\nP\\n=\\n(\\n\\nf\\n\\n1\\n\\n\\n,\\n\\nf\\n\\n2\\n\\n\\n,\\n…\\n,\\n\\nf\\n\\nm\\n\\n\\n)\\n\\n\\n{\\displaystyle P=(f_{1},f_{2},\\ldots ,f_{m})}\\n\\n, together with an initial positive integer input \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n.\\n\\nThe program is run by updating the integer \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n as follows:\\n\\nConway gave a program for primes in FRACTRAN:\\nStarting with \\n\\n\\n\\nn\\n=\\n2\\n\\n\\n{\\displaystyle n=2}\\n\\n, this FRACTRAN program will change \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n to \\n\\n\\n\\n15\\n=\\n2\\n×\\n(\\n15\\n\\n/\\n\\n2\\n)\\n\\n\\n{\\displaystyle 15=2\\times (15/2)}\\n\\n, then \\n\\n\\n\\n825\\n=\\n15\\n×\\n(\\n55\\n\\n/\\n\\n1\\n)\\n\\n\\n{\\displaystyle 825=15\\times (55/1)}\\n\\n, generating the following sequence of integers:\\nAfter 2, this sequence contains the following powers of 2:\\nwhich are the prime powers of 2.\\n\\nWrite a program that reads a list of fractions in a natural format from the keyboard or from a string,\\nto parse it into a sequence of fractions (i.e. two integers),\\nand runs the FRACTRAN starting from a provided integer, writing the result at each step.\\nIt is also required that the number of steps is limited (by a parameter easy to find).\\n\\nUse this program to derive the first 20 or so prime numbers.\\n\\nFor more on how to program FRACTRAN as a universal programming language, see:\\n\\n","\\n#include <iostream>\\n#include <sstream>\\n#include <iterator>\\n#include <vector>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nclass fractran\\n{\\npublic:\\n    void run( std::string p, int s, int l  )\\n    {\\n        start = s; limit = l;\\n        istringstream iss( p ); vector<string> tmp;\\n        copy( istream_iterator<string>( iss ), istream_iterator<string>(), back_inserter( tmp ) );\\n\\n        string item; vector< pair > v;\\n	pair a;\\n	for( vector<string>::iterator i = tmp.begin(); i != tmp.end(); i++ )\\n	{\\n	    string::size_type pos = ( *i ).find( '/', 0 );\\n	    if( pos != std::string::npos )\\n	    {\\n		a = make_pair( atof( ( ( *i ).substr( 0, pos ) ).c_str() ), atof( ( ( *i ).substr( pos + 1 ) ).c_str() ) );\\n		v.push_back( a );\\n	    }\\n	}\\n		\\n	exec( &v );\\n    }\\n\\nprivate:\\n    void exec( vector< pair >* v )\\n    {\\n	int cnt = 0;\\n	while( cnt < limit )\\n	{\\n	    cout << cnt << \"" : \"" << start << \""\\n\"";\\n	    cnt++;\\n	    vector< pair >::iterator it = v->begin();\\n	    bool found = false; float r;\\n	    while( it != v->end() )\\n	    {\\n		r  = start * ( ( *it ).first / ( *it ).second );\\n		if( r == floor( r ) )\\n		{\\n		    found = true;\\n		    break;\\n		}\\n		++it;\\n	    }\\n\\n	    if( found ) start = ( int )r;\\n	    else break;\\n	}\\n    }\\n    int start, limit;\\n};\\nint main( int argc, char* argv[] )\\n{\\n    fractran f; f.run( \""17/91 78/85 19/51 23/38 29/33 77/29 95/23 77/19 1/17 11/13 13/11 15/14 15/2 55/1\"", 2, 15 );\\n    cin.get();\\n    return 0;\\n}\\n"
"C++","Function_composition","Create a function, compose,   whose two arguments   f   and   g,   are both functions with one argument.\\n\\nThe result of compose is to be a function of one argument, (lets call the argument   x),   which works like applying function    f    to the result of applying function    g    to    x.\\n\\n\\nReference: Function composition\\nHint: In some languages, implementing compose correctly requires creating a closure.\\n\\nActionScript supports closures, making function composition very straightforward.\\nThe interface of a generic functions package. The package can be instantiated with any type that has value semantics. Functions are composed using the operation '*'. The same operation applied to an argument evaluates it there: f * x. Functions can be composed with pointers to Ada functions. (In Ada functions are not first-class):\\nHere is an implementation;\\nThe following is an example of use:\\n","#include <functional>\\n#include <cmath>\\n#include <iostream>\\n\\n// functor class to be returned by compose function\\ntemplate \\nclass compose_functor :\\n  public std::unary_function\\n{\\nprotected:\\n  Fun1 f;\\n  Fun2 g;\\n\\npublic:\\n  compose_functor(const Fun1& _f, const Fun2& _g)\\n    : f(_f), g(_g) { }\\n\\n  typename Fun1::result_type\\n  operator()(const typename Fun2::argument_type& x) const\\n  { return f(g(x)); }\\n};\\n\\n// we wrap it in a function so the compiler infers the template arguments\\n// whereas if we used the class directly we would have to specify them explicitly\\ntemplate \\ninline compose_functor\\ncompose(const Fun1& f, const Fun2& g)\\n{ return compose_functor(f, g); }\\n\\nint main() {\\n  std::cout << compose(std::ptr_fun(::sin), std::ptr_fun(::asin))(0.5) << std::endl;\\n\\n  return 0;\\n}"
"C++","Function_composition","Create a function, compose,   whose two arguments   f   and   g,   are both functions with one argument.\\n\\nThe result of compose is to be a function of one argument, (lets call the argument   x),   which works like applying function    f    to the result of applying function    g    to    x.\\n\\n\\nReference: Function composition\\nHint: In some languages, implementing compose correctly requires creating a closure.\\n\\nActionScript supports closures, making function composition very straightforward.\\nThe interface of a generic functions package. The package can be instantiated with any type that has value semantics. Functions are composed using the operation '*'. The same operation applied to an argument evaluates it there: f * x. Functions can be composed with pointers to Ada functions. (In Ada functions are not first-class):\\nHere is an implementation;\\nThe following is an example of use:\\n","#include <iostream>\\n#include <functional>\\n#include <cmath>\\n\\ntemplate \\nstd::function compose(std::function f, std::function g) {\\n  return [f,g](A x) { return f(g(x)); };\\n}\\n\\nint main() {\\n  std::function f = sin;\\n  std::function g = asin;\\n  std::cout << compose(f, g)(0.5) << std::endl;\\n\\n  return 0;\\n}"
"C++","Function_composition","Create a function, compose,   whose two arguments   f   and   g,   are both functions with one argument.\\n\\nThe result of compose is to be a function of one argument, (lets call the argument   x),   which works like applying function    f    to the result of applying function    g    to    x.\\n\\n\\nReference: Function composition\\nHint: In some languages, implementing compose correctly requires creating a closure.\\n\\nActionScript supports closures, making function composition very straightforward.\\nThe interface of a generic functions package. The package can be instantiated with any type that has value semantics. Functions are composed using the operation '*'. The same operation applied to an argument evaluates it there: f * x. Functions can be composed with pointers to Ada functions. (In Ada functions are not first-class):\\nHere is an implementation;\\nThe following is an example of use:\\n","\\n#include <iostream>\\n#include <math.h>\\n \\ntemplate \\ndecltype(auto) compose(F&& f, G&& g)\\n{\\n    return [=](auto x) { return f(g(x)); };\\n}\\n \\nint main() {\\n  std::cout << compose(sin, asin)(0.5) << \""\\n\"";\\n  return 0;\\n}\\n"
"C++","Function_composition","Create a function, compose,   whose two arguments   f   and   g,   are both functions with one argument.\\n\\nThe result of compose is to be a function of one argument, (lets call the argument   x),   which works like applying function    f    to the result of applying function    g    to    x.\\n\\n\\nReference: Function composition\\nHint: In some languages, implementing compose correctly requires creating a closure.\\n\\nActionScript supports closures, making function composition very straightforward.\\nThe interface of a generic functions package. The package can be instantiated with any type that has value semantics. Functions are composed using the operation '*'. The same operation applied to an argument evaluates it there: f * x. Functions can be composed with pointers to Ada functions. (In Ada functions are not first-class):\\nHere is an implementation;\\nThe following is an example of use:\\n","#include <iostream>\\n#include <cmath>\\n#include \\n\\nint main() {\\n  std::cout << __gnu_cxx::compose1(std::ptr_fun(::sin), std::ptr_fun(::asin))(0.5) << std::endl;\\n\\n  return 0;\\n}"
"C++","Function_definition","A function is a body of code that returns a value.\\nThe value returned may depend on arguments provided to the function.\\n\\nWrite a definition of a function called \""multiply\"" that takes two arguments and returns their product.\\n(Argument types should be chosen so as not to distract from showing how functions are created and values returned).\\n\\n\\nLinkage conventions are: register 1 : the parameter list, register 0 : the return value,\\nand register 14 : the return address.\\nAs with other low-level languages, 6502 assembler has subroutines rather than functions in the strict sense. This implementation of MULTIPLY behaves rather like a function, however: it expects two 'parameters' to be passed in the index registers X and Y and it returns the answer in the accumulator. Note that the 6502 has no MUL instruction, so multiplication is carried out by repeated addition.\\nLike other assembly languages, 8051 doesn't have functions but instead has symbolic references to code. Function arguments are passed via registers decided on beforehand.\\nand an implementation of:\\n\\nThe Ada 2012 standard provides an even simpler way to define and implement functions:\\n\\nAda supports generic functions which can take generic formal parameters like the numeric type to use:\\nimplemented as:\\nTo use this, you need to instantiate the function for each type e.g.\\nThis implementation takes two integers and returns an integer. Note that a function is distinguished from a procedure, which does not return a value.\\nExplicit definition has the syntax:\\nInside functions, the variable args contains the sequence of arguments.\\nx, y and z contain the first, second and third argument.\\nWorks on arrays of any rank (any number of dimensions): atoms, lists, tables, etc.\\nApplesoft BASIC functions are unary meaning they only take one argument. As the task asks for a multiply function which takes two arguments this poses a problem. To get around this, the multiply function MU takes one argument as the offset into an array of parameters.\\nFunction names in Applesoft BASIC can be longer than two characters but only the first two characters are significant. Function names cannot contain any keywords.\\nwith a macro and a variable number of parameters:\\n\\nIn Commodore BASIC function definition can consist of any mathematical operation other functions or commands which result in a numeric expression. The definition is limited to single statement, and it accepts only a single argument. When using the function, keyword fn must precede the function name, which itself must be uniquely distinguishable by its first two characters.\\nWindows batch files only have procedures, not functions. Instead, environmental variables can be used as a global shared state.\\nBBC BASIC supports both single-line and multi-line function definitions. Note that the function name must begin with FN.\\nSingle-line function:\\nMultiline function:\\nMacros can be defined at the top of a program and the compiler will replace the function calls with the function itself before compiling the program (the source file will not change).\\nParentheses should be added around parameters in the function definition to avoid order of operations errors when someone uses the macro as such:\\nA program with that call would be compiled as if this were coded instead:\\nAnother advantage of macros is that they work with all types alike. For example, the above macro can be used both to multiply double values (like the function above), and to multiply int values (giving an int, which the function doesn't).\\nAnonymous function:\\nC++ functions basically are the same as in C. Also macros exist, however they are discouraged in C++ in favour of inline functions and function templates.\\nAn inline function differs from the normal function by the keyword inline and the fact that it has to be included in every translation unit which uses it (i.e. it normally is written directly in the header). It allows the compiler to eliminate the function without having the disadvantages of macros (like unintended double evaluation and not respecting scope), because the substitution doesn't happen at source level, but during compilation. An inline version of the above function is:\\nIf not only doubles, but numbers of arbitrary types are to be multiplied, a function template can be used:\\nOf course, both inline and template may be combined (the inline then has to follow the template<...>), but since templates have to be in the header anyway (while the standard allows them to be compiled separately using the keyword export, almost no compiler implements that), the compiler usually can inline the template even without the keyword.\\n\\nOr with multiple arities (in the manner of the actual * function):\\nIn COBOL, multiply is a reserved word, so the requirements must be relaxed to allow a different function name. The following uses a program:\\nThis example uses user-defined functions, which were added in COBOL 2002.\\nAs CoffeeScript. In addition, Coco provides some syntactic sugar for accessing the arguments array reminiscent of Perl's @_:\\nFurthermore, when no parameter list is defined, the first argument is available as it:\\nCommon Lisp has ordinary functions and generic functions.\\nOrdinary functions operate on the values of argument expressions. Lisp functions terminate by returning one or more values, or by executing a non-local dynamic control transfer, in which case values are not returned.\\nIn Lisp we can express optimizations of calls to a function using compiler macros. For instance, suppose we know that the multiply function, which may be in another module, simply multiplies numbers together. We can replace a call to multiply by a constant, if the arguments are constant expressions. Like the usual kind of Lisp macro, the compiler macro takes the argument forms as arguments, not the argument values. The special keyword &whole gives the macro access to the entire expression, which is convenient for the unhandled cases, whereby no transformation takes place:\\nLisp implementations do not have to honor compiler macros. Usually compilers make use of them, but evaluators do not.\\nHere is test of the macro using a CLISP interactive session. Note that the multiply function is not actually defined, yet it compiles and executes anyway, which shows that the macro provided the translation something.\\nLisp's generic functions are part of the object system. Generic functions are compiled to ordinary functions, and so are called in the ordinary way. Internally, however, they have the special behavior of dispatching one or more methods based on specializable parameters.\\nMethods can be defined right inside the DEFGENERIC construct, but usually are written with separate DEFMETHODS.\\nAlso, the DEFGENERIC is optional, since the first DEFMETHOD will define the generic function, but good practice.\\nBoth the compile-time and run-time output:\\nFor dc, the functions (called macros) are limited to names from 'a' to 'z'\\nCreate a function called 'm'\\nUse it (lm loads the function in 'm',x executes it, f shows the the stack.)\\n(This does not necessarily return a product, but whatever the \""multiply\"" method of a returns. The parameters could be guarded to only accept standard numbers.)\\nIt is also possible to write short anonymous function definitions which do not need explicit returns:\\nThis definition is identical to the previous except that the function object will not know its own name.\\nAnonymous function:\\nAnonymous function / closure:\\nRoot closure:\\n","inline double multiply(double a, double b)\\n{\\n   return a*b;\\n}"
"C++","Function_definition","A function is a body of code that returns a value.\\nThe value returned may depend on arguments provided to the function.\\n\\nWrite a definition of a function called \""multiply\"" that takes two arguments and returns their product.\\n(Argument types should be chosen so as not to distract from showing how functions are created and values returned).\\n\\n\\nLinkage conventions are: register 1 : the parameter list, register 0 : the return value,\\nand register 14 : the return address.\\nAs with other low-level languages, 6502 assembler has subroutines rather than functions in the strict sense. This implementation of MULTIPLY behaves rather like a function, however: it expects two 'parameters' to be passed in the index registers X and Y and it returns the answer in the accumulator. Note that the 6502 has no MUL instruction, so multiplication is carried out by repeated addition.\\nLike other assembly languages, 8051 doesn't have functions but instead has symbolic references to code. Function arguments are passed via registers decided on beforehand.\\nand an implementation of:\\n\\nThe Ada 2012 standard provides an even simpler way to define and implement functions:\\n\\nAda supports generic functions which can take generic formal parameters like the numeric type to use:\\nimplemented as:\\nTo use this, you need to instantiate the function for each type e.g.\\nThis implementation takes two integers and returns an integer. Note that a function is distinguished from a procedure, which does not return a value.\\nExplicit definition has the syntax:\\nInside functions, the variable args contains the sequence of arguments.\\nx, y and z contain the first, second and third argument.\\nWorks on arrays of any rank (any number of dimensions): atoms, lists, tables, etc.\\nApplesoft BASIC functions are unary meaning they only take one argument. As the task asks for a multiply function which takes two arguments this poses a problem. To get around this, the multiply function MU takes one argument as the offset into an array of parameters.\\nFunction names in Applesoft BASIC can be longer than two characters but only the first two characters are significant. Function names cannot contain any keywords.\\nwith a macro and a variable number of parameters:\\n\\nIn Commodore BASIC function definition can consist of any mathematical operation other functions or commands which result in a numeric expression. The definition is limited to single statement, and it accepts only a single argument. When using the function, keyword fn must precede the function name, which itself must be uniquely distinguishable by its first two characters.\\nWindows batch files only have procedures, not functions. Instead, environmental variables can be used as a global shared state.\\nBBC BASIC supports both single-line and multi-line function definitions. Note that the function name must begin with FN.\\nSingle-line function:\\nMultiline function:\\nMacros can be defined at the top of a program and the compiler will replace the function calls with the function itself before compiling the program (the source file will not change).\\nParentheses should be added around parameters in the function definition to avoid order of operations errors when someone uses the macro as such:\\nA program with that call would be compiled as if this were coded instead:\\nAnother advantage of macros is that they work with all types alike. For example, the above macro can be used both to multiply double values (like the function above), and to multiply int values (giving an int, which the function doesn't).\\nAnonymous function:\\nC++ functions basically are the same as in C. Also macros exist, however they are discouraged in C++ in favour of inline functions and function templates.\\nAn inline function differs from the normal function by the keyword inline and the fact that it has to be included in every translation unit which uses it (i.e. it normally is written directly in the header). It allows the compiler to eliminate the function without having the disadvantages of macros (like unintended double evaluation and not respecting scope), because the substitution doesn't happen at source level, but during compilation. An inline version of the above function is:\\nIf not only doubles, but numbers of arbitrary types are to be multiplied, a function template can be used:\\nOf course, both inline and template may be combined (the inline then has to follow the template<...>), but since templates have to be in the header anyway (while the standard allows them to be compiled separately using the keyword export, almost no compiler implements that), the compiler usually can inline the template even without the keyword.\\n\\nOr with multiple arities (in the manner of the actual * function):\\nIn COBOL, multiply is a reserved word, so the requirements must be relaxed to allow a different function name. The following uses a program:\\nThis example uses user-defined functions, which were added in COBOL 2002.\\nAs CoffeeScript. In addition, Coco provides some syntactic sugar for accessing the arguments array reminiscent of Perl's @_:\\nFurthermore, when no parameter list is defined, the first argument is available as it:\\nCommon Lisp has ordinary functions and generic functions.\\nOrdinary functions operate on the values of argument expressions. Lisp functions terminate by returning one or more values, or by executing a non-local dynamic control transfer, in which case values are not returned.\\nIn Lisp we can express optimizations of calls to a function using compiler macros. For instance, suppose we know that the multiply function, which may be in another module, simply multiplies numbers together. We can replace a call to multiply by a constant, if the arguments are constant expressions. Like the usual kind of Lisp macro, the compiler macro takes the argument forms as arguments, not the argument values. The special keyword &whole gives the macro access to the entire expression, which is convenient for the unhandled cases, whereby no transformation takes place:\\nLisp implementations do not have to honor compiler macros. Usually compilers make use of them, but evaluators do not.\\nHere is test of the macro using a CLISP interactive session. Note that the multiply function is not actually defined, yet it compiles and executes anyway, which shows that the macro provided the translation something.\\nLisp's generic functions are part of the object system. Generic functions are compiled to ordinary functions, and so are called in the ordinary way. Internally, however, they have the special behavior of dispatching one or more methods based on specializable parameters.\\nMethods can be defined right inside the DEFGENERIC construct, but usually are written with separate DEFMETHODS.\\nAlso, the DEFGENERIC is optional, since the first DEFMETHOD will define the generic function, but good practice.\\nBoth the compile-time and run-time output:\\nFor dc, the functions (called macros) are limited to names from 'a' to 'z'\\nCreate a function called 'm'\\nUse it (lm loads the function in 'm',x executes it, f shows the the stack.)\\n(This does not necessarily return a product, but whatever the \""multiply\"" method of a returns. The parameters could be guarded to only accept standard numbers.)\\nIt is also possible to write short anonymous function definitions which do not need explicit returns:\\nThis definition is identical to the previous except that the function object will not know its own name.\\nAnonymous function:\\nAnonymous function / closure:\\nRoot closure:\\n","template\\n  Number multiply(Number a, Number b)\\n{\\n   return a*b;\\n}"
"C++","Galton_box_animation","Generate an animated simulation of Sir Francis Galton's device.\\nIn a Galton box, there are a set of pins arranged in a triangular pattern.\\nA number of balls are dropped so that they fall in line with the top pin, deflecting to the left or the right of the pin. The ball continues to fall to the left or right of subsequent pins before arriving at one of the collection points between and to the sides of the bottom row of pins.\\nFor the purpose of this task the box should have at least 5 pins on the bottom row.\\nYour solution can use graphics or ASCII animation.\\nProvide a sample of the output/display such as a screenshot.\\nYour solution can have either one or more balls in flight at the same time.\\nIf multiple balls are in flight, ensure they don't interfere with each other.\\nYour solution should allow users to specify the number of balls or it should run until full or a preset limit. Optionally, display the number of balls.\\nUses an edit box for the (text based) animation\\nWindows GDI version.\\nTo keep the code simpler some corner cases are ignored.\\n","\\n#include \""stdafx.h\""\\n#include <windows.h>\\n#include <stdlib.h>\\n\\nconst int BMP_WID = 410, BMP_HEI = 230, MAX_BALLS = 120;\\n\\nclass myBitmap {\\npublic:\\n    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}\\n    ~myBitmap() {\\n        DeleteObject( pen ); DeleteObject( brush );\\n        DeleteDC( hdc ); DeleteObject( bmp );\\n    }\\n    bool create( int w, int h ) {\\n        BITMAPINFO bi;\\n        ZeroMemory( &bi, sizeof( bi ) );\\n        bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );\\n        bi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;\\n        bi.bmiHeader.biCompression = BI_RGB;\\n        bi.bmiHeader.biPlanes      = 1;\\n        bi.bmiHeader.biWidth       =  w;\\n        bi.bmiHeader.biHeight      = -h;\\n\\n        HDC dc = GetDC( GetConsoleWindow() );\\n        bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );\\n        if( !bmp ) return false;\\n        hdc = CreateCompatibleDC( dc );\\n        SelectObject( hdc, bmp );\\n        ReleaseDC( GetConsoleWindow(), dc );\\n        width = w; height = h;\\n        return true;\\n    }\\n    void clear( BYTE clr = 0 ) {\\n        memset( pBits, clr, width * height * sizeof( DWORD ) );\\n    }\\n    void setBrushColor( DWORD bClr ) {\\n        if( brush ) DeleteObject( brush );\\n        brush = CreateSolidBrush( bClr );\\n        SelectObject( hdc, brush );\\n    }\\n    void setPenColor( DWORD c ) {\\n        clr = c; createPen();\\n    }\\n    void setPenWidth( int w ) {\\n        wid = w; createPen();\\n    }\\n    HDC getDC() const     { return hdc; }\\n    int getWidth() const  { return width; }\\n    int getHeight() const { return height; }\\nprivate:\\n    void createPen() {\\n        if( pen ) DeleteObject( pen );\\n        pen = CreatePen( PS_SOLID, wid, clr );\\n        SelectObject( hdc, pen );\\n    }\\n    HBITMAP bmp;\\n    HDC     hdc;\\n    HPEN    pen;\\n    HBRUSH  brush;\\n    void    *pBits;\\n    int     width, height, wid;\\n    DWORD   clr;\\n};\\nclass point {\\npublic:\\n    int x; float y;\\n    void set( int a, float b ) { x = a; y = b; }\\n};\\ntypedef struct {\\n    point position, offset;\\n    bool alive, start;\\n}ball;\\nclass galton {\\npublic :\\n    galton() {\\n        bmp.create( BMP_WID, BMP_HEI );\\n        initialize();\\n    }\\n    void setHWND( HWND hwnd ) { _hwnd = hwnd; }\\n    void simulate() {\\n        draw(); update(); Sleep( 1 );\\n    }\\nprivate:\\n    void draw() {\\n        bmp.clear();\\n        bmp.setPenColor( RGB( 0, 255, 0 ) );\\n        bmp.setBrushColor( RGB( 0, 255, 0 ) );\\n        int xx, yy;\\n        for( int y = 3; y < 14; y++ ) {\\n            yy = 10 * y;\\n            for( int x = 0; x < 41; x++ ) {\\n                xx = 10 * x;\\n                if( pins[y][x] )\\n                    Rectangle( bmp.getDC(), xx - 3, yy - 3, xx + 3, yy + 3 );\\n            }\\n        }\\n        bmp.setPenColor( RGB( 255, 0, 0 ) );\\n        bmp.setBrushColor( RGB( 255, 0, 0 ) );\\n        ball* b; \\n        for( int x = 0; x < MAX_BALLS; x++ ) {\\n            b = &balls[x];\\n            if( b->alive )\\n                Rectangle( bmp.getDC(), static_cast<int>( b->position.x - 3 ), static_cast<int>( b->position.y - 3 ), \\n                                        static_cast<int>( b->position.x + 3 ), static_cast<int>( b->position.y + 3 ) );\\n        }\\n        for( int x = 0; x < 70; x++ ) {\\n            if( cols[x] > 0 ) {\\n                xx = 10 * x;\\n                Rectangle( bmp.getDC(), xx - 3, 160, xx + 3, 160 + cols[x] );\\n            }\\n        }\\n        HDC dc = GetDC( _hwnd );\\n        BitBlt( dc, 0, 0, BMP_WID, BMP_HEI, bmp.getDC(), 0, 0, SRCCOPY );\\n        ReleaseDC( _hwnd, dc );\\n    }\\n    void update() {\\n        ball* b;\\n        for( int x = 0; x < MAX_BALLS; x++ ) {\\n            b = &balls[x];\\n            if( b->alive ) {\\n                b->position.x += b->offset.x; b->position.y += b->offset.y;\\n                if( x < MAX_BALLS - 1 && !b->start && b->position.y > 50.0f ) {\\n                    b->start = true;\\n                    balls[x + 1].alive = true;\\n                }\\n                int c = ( int )b->position.x, d = ( int )b->position.y + 6;\\n                if( d > 10 || d < 41 ) {\\n                    if( pins[d / 10][c / 10] ) {\\n                        if( rand() % 30 < 15 ) b->position.x -= 10;\\n                        else b->position.x += 10;\\n                    }\\n                }\\n                if( b->position.y > 160 ) {\\n                    b->alive = false;\\n                    cols[c / 10] += 1;\\n                }\\n            }\\n        }\\n    }\\n    void initialize() {\\n        for( int x = 0; x < MAX_BALLS; x++ ) {\\n            balls[x].position.set( 200, -10 );\\n            balls[x].offset.set( 0, 0.5f );\\n            balls[x].alive = balls[x].start = false;\\n        }\\n        balls[0].alive = true;\\n        for( int x = 0; x < 70; x++ )\\n            cols[x] = 0;\\n        for( int y = 0; y < 70; y++ )\\n            for( int x = 0; x < 41; x++ )\\n                pins[x][y] = false;\\n        int p;\\n        for( int y = 0; y < 11; y++ ) {\\n            p = ( 41 / 2 ) - y;\\n            for( int z = 0; z < y + 1; z++ ) {\\n                pins[3 + y][p] = true;\\n                p += 2;\\n            }\\n        }\\n    }\\n    myBitmap bmp;\\n    HWND _hwnd;\\n    bool pins[70][40];\\n    ball balls[MAX_BALLS];\\n    int cols[70];\\n};\\nclass wnd {\\npublic:\\n    int wnd::Run( HINSTANCE hInst ) {\\n        _hInst = hInst;\\n        _hwnd = InitAll();\\n        _gtn.setHWND( _hwnd );\\n        ShowWindow( _hwnd, SW_SHOW );\\n        UpdateWindow( _hwnd );\\n        MSG msg;\\n        ZeroMemory( &msg, sizeof( msg ) );\\n        while( msg.message != WM_QUIT ) {\\n            if( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) != 0 ) {\\n                TranslateMessage( &msg );\\n                DispatchMessage( &msg );\\n            } else _gtn.simulate();\\n        }\\n        return UnregisterClass( \""_GALTON_\"", _hInst );\\n    }\\nprivate:\\n    static int WINAPI wnd::WndProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam ) {\\n        switch( msg ) {\\n            case WM_DESTROY: PostQuitMessage( 0 ); break;\\n            default:\\n                return static_cast<int>( DefWindowProc( hWnd, msg, wParam, lParam ) );\\n        }\\n        return 0;\\n    }\\n    HWND InitAll() {\\n        WNDCLASSEX wcex;\\n        ZeroMemory( &wcex, sizeof( wcex ) );\\n        wcex.cbSize           = sizeof( WNDCLASSEX );\\n        wcex.style           = CS_HREDRAW | CS_VREDRAW;\\n        wcex.lpfnWndProc   = ( WNDPROC )WndProc;\\n        wcex.hInstance     = _hInst;\\n        wcex.hCursor       = LoadCursor( NULL, IDC_ARROW );\\n        wcex.hbrBackground = ( HBRUSH )( COLOR_WINDOW + 1 );\\n        wcex.lpszClassName = \""_GALTON_\"";\\n        RegisterClassEx( &wcex );\\n        RECT rc;\\n        SetRect( &rc, 0, 0, BMP_WID, BMP_HEI );\\n        AdjustWindowRect( &rc, WS_CAPTION, FALSE );\\n        return CreateWindow( \""_GALTON_\"", \"".: Galton Box -- PJorente :.\"", WS_SYSMENU, CW_USEDEFAULT, 0, rc.right - rc.left, rc.bottom - rc.top, NULL, NULL, _hInst, NULL );\\n    }\\n    HINSTANCE _hInst;\\n    HWND      _hwnd;\\n    galton    _gtn;\\n};\\nint APIENTRY WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow ) {\\n    srand( GetTickCount() );\\n    wnd myWnd; \\n    return myWnd.Run( hInstance );\\n}\\n"
"C++","General_FizzBuzz","Write a generalized version of FizzBuzz that works for any list of factors, along with their words.\\nThis is basically a \""fizzbuzz\"" implementation where the user supplies the parameters.\\nThe user will enter the max number, then they will enter the factors to be calculated along with the corresponding word to be printed.\\nFor simplicity's sake, assume the user will input an integer as the max number and 3 factors, each with a word associated with them.\\n\\nFor example, given:\\nIn other words: For this example, print the numbers 1 through 20, replacing every multiple of 3 with \""Fizz\"", every multiple of 5 with \""Buzz\"", and every multiple of 7 with \""Baxx\"".\\nIn the case where a number is a multiple of at least two factors, print each of the words associated with those factors in the order of least to greatest factor.\\nFor instance, the number 15 is a multiple of both 3 and 5; print \""FizzBuzz\"".\\nIf the max number was 105 instead of 20, you would print \""FizzBuzzBaxx\"" because it's a multiple of 3, 5, and 7.\\n","\\n#include <algorithm>\\n#include <iostream>\\n#include <vector>\\n#include <string>\\n\\nclass pair  {\\npublic:\\n    pair( int s, std::string z )            { p = std::make_pair( s, z ); }\\n    bool operator < ( const pair& o ) const { return i() < o.i(); }\\n    int i() const                           { return p.first; }\\n    std::string s() const                   { return p.second; }\\nprivate:\\n    std::pair p;\\n};\\nvoid gFizzBuzz( int c, std::vector<pair>& v ) {\\n    bool output;\\n    for( int x = 1; x <= c; x++ ) {\\n        output = false;\\n        for( std::vector<pair>::iterator i = v.begin(); i != v.end(); i++ ) {\\n            if( !( x % ( *i ).i() ) ) {\\n                std::cout << ( *i ).s();\\n                output = true;\\n            }\\n        }\\n        if( !output ) std::cout << x;\\n        std::cout << \""\\n\"";\\n    }\\n}\\nint main( int argc, char* argv[] ) {\\n    std::vector<pair> v;\\n    v.push_back( pair( 7, \""Baxx\"" ) );\\n    v.push_back( pair( 3, \""Fizz\"" ) );\\n    v.push_back( pair( 5, \""Buzz\"" ) );\\n    std::sort( v.begin(), v.end() );\\n    gFizzBuzz( 20, v );\\n    return 0;\\n}\\n"
"C++","Generate_Chess960_starting_position","Chess960 is a variant of chess created by world champion Bobby Fischer. Unlike other variants of the game, Chess960 does not require a different material, but instead relies on a random initial position, with a few constraints:\\n\\nWith those constraints there are 960 possible starting positions, thus the name of the variant.\\n\\nThe purpose of this task is to write a program that can randomly generate any one of the 960 Chess960 initial positions. You will show the result as the first rank displayed with Chess symbols in Unicode: ♔♕♖♗♘ or with the letters King Queen Rook Bishop kNight.\\n\\n","#include <iostream>\\n#include <string>\\n#include <time.h>\\nusing namespace std;\\n\\nnamespace\\n{\\n    void placeRandomly(char* p, char c)\\n    {\\n	int loc = rand() % 8;\\n	if (!p[loc])\\n	    p[loc] = c;\\n	else\\n	    placeRandomly(p, c);    // try again\\n    }\\n    int placeFirst(char* p, char c, int loc = 0)\\n    {\\n	while (p[loc]) ++loc;\\n	p[loc] = c;\\n        return loc;\\n    }\\n\\n    string startPos()\\n    {\\n	char p[8]; memset( p, 0, 8 );\\n\\n	// bishops on opposite color\\n	p[2 * (rand() % 4)] = 'B';\\n	p[2 * (rand() % 4) + 1] = 'B';\\n\\n	// queen knight knight, anywhere\\n	for (char c : \""QNN\"")\\n	    placeRandomly(p, c);\\n\\n	// rook king rook, in that order\\n	placeFirst(p, 'R', placeFirst(p, 'K', placeFirst(p, 'R')));\\n\\n	return string(p, 8);\\n    }\\n}   // leave local\\n\\nnamespace chess960\\n{\\n    void generate( int c )\\n    {\\n	for( int x = 0; x < c; x++ )\\n	    cout << startPos() << \""\\n\"";\\n    }\\n}\\n\\nint main( int argc, char* argv[] )\\n{\\n    srand( time( NULL ) );\\n    chess960::generate( 10 );\\n    cout << \""\\n\\n\"";\\n    return system( \""pause\"" );\\n}\\n"
"C++","Generate_lower_case_ASCII_alphabet","Generate an array, list, lazy sequence, or even an indexable string of all the lower case ASCII characters, from  a  to  z. If the standard library contains such a sequence, show how to access it, but don't fail to show how to generate a similar sequence.\\nFor this basic task use a reliable style of coding, a style fit for a very large program, and use strong typing if available. It's bug prone to enumerate all the lowercase characters manually in the code. During code review it's not immediate obvious to spot the bug in a Tcl line like this contained in a page of code:\\n\\nThis creates the list in the queue\\nIn EBCDIC coding there are more than 24 characters between a and z.\\nSo we have to get rid of characters between i and j and also between r and s.\\n","#include <string>\\n#include <numeric>\\n\\nint main() {\\n    std::string lower(26,' ');\\n\\n    std::iota(lower.begin(), lower.end(), 'a');\\n}"
"C++","Generate_random_chess_position","The purpose of this task is to generate a random chess position in FEN format. The position does not have to be realistic or even balanced, but it must comply to the following rules:\\n\\nNo requirement is made regarding the probability distribution of your method, but your program should be able to span a reasonably representative sample of all possible positions. For instance, programs that would always generate positions with say five pieces on the board, or with kings on a corner, would not be considered truly random.\\n\\n","\\n#include <ctime>\\n#include <iostream>\\n#include <string>\\n#include <algorithm>\\n\\nclass chessBoard {\\npublic:\\n    void generateRNDBoard( int brds ) {\\n        int a, b, i; char c;\\n        for( int cc = 0; cc < brds; cc++ ) {\\n            memset( brd, 0, 64 );\\n            std::string pieces = \""PPPPPPPPNNBBRRQKppppppppnnbbrrqk\"";\\n            random_shuffle( pieces.begin(), pieces.end() );\\n\\n            while( pieces.length() ) {\\n                i = rand() % pieces.length(); c = pieces.at( i );\\n                while( true ) {\\n                    a = rand() % 8; b = rand() % 8;\\n                    if( brd[a][b] == 0 ) {\\n                        if( c == 'P' && !b || c == 'p' && b == 7 || \\n                          ( ( c == 'K' || c == 'k' ) && search( c == 'k' ? 'K' : 'k', a, b ) ) ) continue;\\n                        break;\\n                    }\\n                }\\n                brd[a][b] = c;\\n                pieces = pieces.substr( 0, i ) + pieces.substr( i + 1 );\\n            }\\n            print();\\n        }\\n    }\\nprivate:\\n    bool search( char c, int a, int b ) {\\n        for( int y = -1; y < 2; y++ ) {\\n            for( int x = -1; x < 2; x++ ) {\\n                if( !x && !y ) continue;\\n                if( a + x > -1 && a + x < 8 && b + y >-1 && b + y < 8 ) {\\n                    if( brd[a + x][b + y] == c ) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    void print() {\\n        int e = 0;\\n        for( int y = 0; y < 8; y++ ) {\\n            for( int x = 0; x < 8; x++ ) {\\n                if( brd[x][y] == 0 ) e++;\\n                else {\\n                    if( e > 0 ) { std::cout << e; e = 0; }\\n                    std::cout << brd[x][y];\\n                }\\n            }\\n            if( e > 0 ) { std::cout << e; e = 0; } \\n            if( y < 7 ) std::cout << \""/\"";\\n        }\\n        std::cout << \"" w - - 0 1\\n\\n\"";\\n\\n        for( int y = 0; y < 8; y++ ) {\\n            for( int x = 0; x < 8; x++ ) {\\n                if( brd[x][y] == 0 ) std::cout << \"".\"";\\n                else std::cout << brd[x][y];\\n            }\\n            std::cout << \""\\n\"";\\n        }\\n\\n        std::cout << \""\\n\\n\"";\\n    }\\n    char brd[8][8];\\n};\\nint main( int argc, char* argv[] ) {\\n    srand( ( unsigned )time( 0 ) );\\n    chessBoard c;\\n    c.generateRNDBoard( 2 );\\n    return 0;\\n}\\n"
"C++","Generator/Exponential","A generator is an executable entity (like a function or procedure) that contains code that yields a sequence of values, one at a time, so that each time you call the generator, the next value in the sequence is provided.\\nGenerators are often built on top of coroutines or objects so that the internal state of the object is handled “naturally”.\\nGenerators are often used in situations where a sequence is potentially infinite, and where it is possible to construct the next value of the sequence with only minimal state.\\n\\n\\nNote that this task requires the use of generators in the calculation of the result.\\n\\n\\nTo modify the internal state, the function uses an access parameter.\\nFor a different approach, see the Random packages of the Ada compiler, which use the so-called \""Rosen trick\"".\\nWith the next release of Ada 2012 functions are allowed to have in-out parameters, which would solve this problem, too.\\nYou could also use procedures instead of functions.\\ngenerator.ads:\\ngenerator-filtered.ads:\\ngenerator.adb:\\ngenerator-filtered.adb:\\nexample use:\\n","#include <iostream>\\nusing namespace std;\\n\\ntemplate\\nclass Generator\\n{\\npublic:\\n  virtual T operator()() = 0;\\n};\\n\\n// Does nothing unspecialized\\ntemplate\\nclass PowersGenerator: Generator<T> {};\\n\\n// Specialize with other types, or provide a generic version of pow\\ntemplate\\nclass PowersGenerator: Generator<int>\\n{\\npublic:\\n  int i;\\n  PowersGenerator() { i = 1; }\\n  virtual int operator()() \\n  { \\n    int o = 1; \\n    for(int j = 0; j < P; ++j) o *= i; \\n    ++i;\\n    return o; \\n  }\\n};\\n\\n// Only works with non-decreasing generators\\ntemplate\\nclass Filter: Generator<T>\\n{\\npublic:\\n  G gen;\\n  F filter;\\n  T lastG, lastF;\\n\\n  Filter() { lastG = gen(); lastF = filter(); }\\n\\n  virtual T operator()() \\n  {\\n    while(lastG >= lastF)\\n    {\\n      if(lastG == lastF)\\n        lastG = gen();\\n      lastF = filter();\\n    }\\n\\n    T out = lastG;\\n    lastG = gen();\\n    return out;\\n  }\\n};\\n\\nint main()\\n{\\n  Filter, PowersGenerator> gen;\\n\\n  for(int i = 0; i < 20; ++i)\\n    gen();\\n\\n  for(int i = 20; i < 30; ++i)\\n    cout << i << \"": \"" << gen() << endl;\\n}"
"C++","Generic_swap","Write a generic swap function or operator which exchanges the values of two variables (or, more generally, any two storage places that can be assigned), regardless of their types.\\nIf your solution language is statically typed please describe the way your language provides genericity.\\nIf variables are typed in the given language, it is permissible that the two variables be constrained to having a mutually compatible type, such that each is permitted to hold the value previously stored in the other without a type violation.\\nThat is to say, solutions do not have to be capable of exchanging, say, a string and integer value, if the underlying storage locations are not attributed with types that permit such an exchange.\\nGeneric swap is a task which brings together a few separate issues in programming language semantics.\\nDynamically typed languages deal with values in a generic way quite readily, but do not necessarily make it easy to write a function to destructively swap two variables, because this requires indirection upon storage places or upon the syntax designating storage places.\\nFunctional languages, whether static or dynamic, do not necessarily allow a destructive operation such as swapping two variables regardless of their generic capabilities.\\nSome static languages have difficulties with generic programming due to a lack of support for (Parametric Polymorphism).\\nDo your best!\\n\\nThree consecutive exclusive OR's swap variable contents\\nOr to swap between the stack and a var:\\nThe generic parameters for an Ada generic procedure are defined in a procedure specification, while the algorithm is defined in a procedure body. The first code snippet is the procedure specification. The second code snippet is the procedure body.\\nTo use the generic swap procedure, you need to instantiate the procedure for each type that you intend to use.\\nAime is statically typed. A generic swap utility may nonetheless be defined in terms of parameters of unspecified type and pass by reference.\\nA generic swap operator =:= was proposed in ALGOL Bulletin for standard ALGOL 68 so that the compiler could optimise the operation. However such an operator was not adopted and needs to be manually defined for each mode required.\\n","template void swap(T& left, T& right)\\n{\\n  T tmp(left);\\n  left = right;\\n  right = tmp;\\n}"
"C++","Generic_swap","Write a generic swap function or operator which exchanges the values of two variables (or, more generally, any two storage places that can be assigned), regardless of their types.\\nIf your solution language is statically typed please describe the way your language provides genericity.\\nIf variables are typed in the given language, it is permissible that the two variables be constrained to having a mutually compatible type, such that each is permitted to hold the value previously stored in the other without a type violation.\\nThat is to say, solutions do not have to be capable of exchanging, say, a string and integer value, if the underlying storage locations are not attributed with types that permit such an exchange.\\nGeneric swap is a task which brings together a few separate issues in programming language semantics.\\nDynamically typed languages deal with values in a generic way quite readily, but do not necessarily make it easy to write a function to destructively swap two variables, because this requires indirection upon storage places or upon the syntax designating storage places.\\nFunctional languages, whether static or dynamic, do not necessarily allow a destructive operation such as swapping two variables regardless of their generic capabilities.\\nSome static languages have difficulties with generic programming due to a lack of support for (Parametric Polymorphism).\\nDo your best!\\n\\nThree consecutive exclusive OR's swap variable contents\\nOr to swap between the stack and a var:\\nThe generic parameters for an Ada generic procedure are defined in a procedure specification, while the algorithm is defined in a procedure body. The first code snippet is the procedure specification. The second code snippet is the procedure body.\\nTo use the generic swap procedure, you need to instantiate the procedure for each type that you intend to use.\\nAime is statically typed. A generic swap utility may nonetheless be defined in terms of parameters of unspecified type and pass by reference.\\nA generic swap operator =:= was proposed in ALGOL Bulletin for standard ALGOL 68 so that the compiler could optimise the operation. However such an operator was not adopted and needs to be manually defined for each mode required.\\n","std::swap(x,y);"
"C++","Generic_swap","Write a generic swap function or operator which exchanges the values of two variables (or, more generally, any two storage places that can be assigned), regardless of their types.\\nIf your solution language is statically typed please describe the way your language provides genericity.\\nIf variables are typed in the given language, it is permissible that the two variables be constrained to having a mutually compatible type, such that each is permitted to hold the value previously stored in the other without a type violation.\\nThat is to say, solutions do not have to be capable of exchanging, say, a string and integer value, if the underlying storage locations are not attributed with types that permit such an exchange.\\nGeneric swap is a task which brings together a few separate issues in programming language semantics.\\nDynamically typed languages deal with values in a generic way quite readily, but do not necessarily make it easy to write a function to destructively swap two variables, because this requires indirection upon storage places or upon the syntax designating storage places.\\nFunctional languages, whether static or dynamic, do not necessarily allow a destructive operation such as swapping two variables regardless of their generic capabilities.\\nSome static languages have difficulties with generic programming due to a lack of support for (Parametric Polymorphism).\\nDo your best!\\n\\nThree consecutive exclusive OR's swap variable contents\\nOr to swap between the stack and a var:\\nThe generic parameters for an Ada generic procedure are defined in a procedure specification, while the algorithm is defined in a procedure body. The first code snippet is the procedure specification. The second code snippet is the procedure body.\\nTo use the generic swap procedure, you need to instantiate the procedure for each type that you intend to use.\\nAime is statically typed. A generic swap utility may nonetheless be defined in terms of parameters of unspecified type and pass by reference.\\nA generic swap operator =:= was proposed in ALGOL Bulletin for standard ALGOL 68 so that the compiler could optimise the operation. However such an operator was not adopted and needs to be manually defined for each mode required.\\n","template\\nvoid swap(T &lhs, T &rhs){\\n  T tmp = std::move(lhs);\\n  lhs = std::move(rhs);\\n  rhs = std::move(tmp);\\n}"
"C++","Globally_replace_text_in_several_files","Replace every occurring instance of a piece of text in a group of text files with another one.\\n\\nFor this task we want to replace the text   \""Goodbye London!\""   with   \""Hello New York!\""   for a list of files.\\n\\nOuput:\\nPass the files on the command line (i.e. global-replace *.txt).\\nModern C++ version:\\n","#include <fstream>\\n#include <iterator>\\n#include \\n#include <string>\\n#include <iostream>\\n\\nint main( int argc , char *argv[ ] ) {\\n   boost::regex to_be_replaced( \""Goodbye London\\\\s*!\"" ) ;\\n   std::string replacement( \""Hello New York!\"" ) ;\\n   for ( int i = 1 ; i < argc ; i++ ) {\\n      std::ifstream infile ( argv[ i ] ) ;\\n      if ( infile ) {\\n	 std::string filetext( (std::istreambuf_iterator<char>( infile )) ,\\n	       std::istreambuf_iterator<char>( ) ) ;\\n	 std::string changed ( boost::regex_replace( filetext , to_be_replaced , replacement )) ;\\n	 infile.close( ) ;\\n	 std::ofstream outfile( argv[ i ] , std::ios_base::out | std::ios_base::trunc ) ;\\n	 if ( outfile.is_open( ) ) { \\n	    outfile << changed ;\\n	    outfile.close( ) ;\\n	 }\\n      }\\n      else \\n	 std::cout << \""Can't find file \"" << argv[ i ] << \"" !\\n\"" ;\\n   }\\n   return 0 ;\\n}"
"C++","Globally_replace_text_in_several_files","Replace every occurring instance of a piece of text in a group of text files with another one.\\n\\nFor this task we want to replace the text   \""Goodbye London!\""   with   \""Hello New York!\""   for a list of files.\\n\\nOuput:\\nPass the files on the command line (i.e. global-replace *.txt).\\nModern C++ version:\\n","#include <regex>\\n#include <fstream>\\n\\nusing namespace std;\\nusing ist = istreambuf_iterator<char>;\\nusing ost = ostreambuf_iterator<char>;\\n\\nint main(){\\n    auto from = \""Goodbye London!\"", to = \""Hello New York!\"";\\n    for(auto filename : {\""a.txt\"", \""b.txt\"", \""c.txt\""}) {\\n        ifstream infile {filename};\\n        string content {ist {infile}, ist{}};\\n        infile.close();\\n        ofstream outfile {filename};\\n        regex_replace(ost {outfile}, begin(content), end(content), regex {from}, to);\\n    }\\n    return 0;\\n}\\n"
"C++","Go_Fish/C++","AI is really not that clever but it gets its job done (well, pretty much!).\\nIt follows three simple rules:\\nAs I said, simple...\\n\\n","\\n#include <time.h>\\n#include <map>\\n#include <vector>\\n#include <algorithm>\\n#include <string>\\n#include <iostream>\\n\\nconst std::string s = \""CDHS\"", v = \""A23456789TJQK\"";\\nconst int handCards = 9, drawCards = 3;\\n\\nclass card {\\npublic:\\n    friend std::ostream& operator<< (std::ostream& os, const card& c ) { \\n        os << v[c.val] << s[c.suit]; \\n        return os;\\n    }\\n    bool isValid()                       { return val > -1; }\\n    void set( char s, char v )           { suit = s; val = v; }\\n    char getRank()                       { return v[val]; }\\n    bool operator == ( const char o )    { return v[val] == o; }\\n    bool operator < ( const card& a )    { if( val == a.val ) return suit < a.suit; return val < a.val; }\\nprivate:\\n    char                                 suit, val;\\n};\\nclass deck {\\npublic:\\n    static deck* instance() {\\n        if( !inst ) inst = new deck();\\n        return inst;\\n    }\\n    void destroy() {\\n        delete inst;\\n        inst = 0;\\n    }\\n    card draw() {\\n        card c;\\n        if( cards.size() > 0 ) { \\n            c = cards.back();\\n            cards.pop_back();\\n            return c; \\n        }\\n        c.set( -1, -1 );\\n        return c;\\n    }\\nprivate:\\n    deck() { \\n        newDeck(); \\n    }\\n    void newDeck() {\\n        card c; \\n        for( char s = 0; s < 4; s++ ) {\\n            for( char v = 0; v < 13; v++ ) {\\n                c.set( s, v ); \\n                cards.push_back( c ); \\n            }\\n        }\\n        random_shuffle( cards.begin(), cards.end() );\\n        random_shuffle( cards.begin(), cards.end() );\\n    }\\n    static deck* inst;\\n    std::vector<card> cards;\\n};\\nclass player {\\npublic:\\n    player( std::string n ) : nm( n ) { \\n        for( int x = 0; x < handCards; x++ )\\n            hand.push_back( deck::instance()->draw() );\\n        sort( hand.begin(), hand.end() );  \\n    }\\n    void outputHand() { \\n        for( std::vector<card>::iterator x = hand.begin(); x != hand.end(); x++ ) \\n            std::cout << ( *x ) << \"" \"";\\n        std::cout << \""\\n\""; \\n    }\\n    bool addCard( card c ) { \\n        hand.push_back( c );\\n        return checkForBook();\\n    }\\n    std::string name() { \\n        return nm; \\n    }\\n    bool holds( char c ) { \\n        return( hand.end() != find( hand.begin(), hand.end(), c ) ); \\n    }\\n    card takeCard( char c ) {\\n        std::vector<card>::iterator it = find( hand.begin(), hand.end(), c );\\n        std::swap( ( *it ), hand.back() );\\n        card d = hand.back();\\n        hand.pop_back();\\n        hasCards();\\n        sort( hand.begin(), hand.end() ); \\n        return d;\\n    }\\n    size_t getBooksCount() {\\n        return books.size();\\n    }\\n    void listBooks() {\\n        for( std::vector<char>::iterator it = books.begin(); it != books.end(); it++ )\\n            std::cout << ( *it ) << \""'s \"";\\n        std::cout << \""\\n\"";\\n    }\\n    bool checkForBook() {\\n        bool ret = false;\\n        std::map countMap;\\n        for( std::vector<card>::iterator it = hand.begin(); it != hand.end(); it++ )\\n            countMap[( *it ).getRank()]++;\\n        for( std::map::iterator it = countMap.begin(); it != countMap.end(); it++ ) {\\n            if( ( *it ).second == 4 ) {\\n                do {\\n                    takeCard( ( *it ).first );\\n                } while( holds( ( *it ).first ) );\\n                books.push_back( ( *it ).first );\\n                ( *it ).second = 0;\\n                ret = true;\\n            }\\n        }\\n        sort( hand.begin(), hand.end() );\\n        return ret;\\n    }\\n    bool hasCards() {\\n        if( hand.size() < 1 ) {\\n            card c;\\n            for( int x = 0; x < drawCards; x++ ) {\\n                c = deck::instance()->draw();\\n                if( c.isValid() ) addCard( c );\\n                else break;\\n            }\\n        }\\n        return( hand.size() > 0 );\\n    }\\nprotected:\\n    std::string nm; \\n    std::vector<card> hand;\\n    std::vector<char> books;\\n};\\nclass aiPlayer : public player {\\npublic:\\n    aiPlayer( std::string n ) : player( n ), askedIdx( -1 ), lastAsked( 0 ), nextToAsk( -1 ) { }\\n    void rememberCard( char c ) {\\n        if( asked.end() != find( asked.begin(), asked.end(), c ) || !asked.size() )\\n            asked.push_back( c );  \\n    }\\n    char makeMove() {\\n        if( askedIdx < 0 || askedIdx >= static_cast<int>( hand.size() ) ) {\\n            askedIdx = rand() % static_cast<int>( hand.size() );\\n        }\\n\\n        char c;\\n        if( nextToAsk > -1 ) {\\n            c = nextToAsk;\\n            nextToAsk = -1;\\n        } else {\\n            while( hand[askedIdx].getRank() == lastAsked ) {\\n                if( ++askedIdx == hand.size() ) {\\n                    askedIdx = 0;\\n                    break;\\n                }\\n            }\\n            c = hand[askedIdx].getRank();\\n            if( rand() % 100 > 25 && asked.size() ) {\\n                for( std::vector<char>::iterator it = asked.begin(); it != asked.end(); it++ ) {\\n		    if( holds( *it ) ) {\\n			c = ( *it );\\n			break;\\n		    }\\n		}\\n            }\\n        }\\n        lastAsked = c;\\n        return c;\\n    }\\n    void clearMemory( char c ) {\\n        std::vector<char>::iterator it = find( asked.begin(), asked.end(), c );\\n        if( asked.end() != it ) {\\n            std::swap( ( *it ), asked.back() );\\n            asked.pop_back();\\n        }\\n    }\\n    bool addCard( card c ) {\\n        if( !holds( c.getRank() ) )\\n            nextToAsk = c.getRank();\\n        return player::addCard( c );\\n    }\\nprivate:\\n    std::vector<char> asked;\\n    char nextToAsk, lastAsked;\\n    int askedIdx;\\n};\\nclass goFish {\\npublic:\\n    goFish() {\\n        plr = true; \\n        std::string n; \\n        std::cout << \""Hi there, enter your name: \""; std::cin >> n; \\n        p1 = new player( n ); \\n        p2 = new aiPlayer( \""JJ\"" );\\n    }\\n    ~goFish() { \\n        if( p1 ) delete p1; \\n        if( p2 ) delete p2;\\n        deck::instance()->destroy();\\n    }\\n    void play() {\\n        while( true ) {\\n            if( process( getInput() ) ) break;\\n        }\\n        std::cout << \""\\n\\n\"";\\n        showBooks();\\n        if( p1->getBooksCount() > p2->getBooksCount() ) {\\n            std::cout << \""\\n\\n\\t*** !!! CONGRATULATIONS !!! ***\\n\\n\\n\"";\\n        } else {\\n            std::cout << \""\\n\\n\\t*** !!! YOU LOSE - HA HA HA !!! ***\\n\\n\\n\"";\\n        }\\n    }\\nprivate:\\n    void showBooks() {\\n        if( p1->getBooksCount() > 0 ) {\\n            std::cout << \""\\nYour Book(s): \"";\\n            p1->listBooks();\\n        }\\n        if( p2->getBooksCount() > 0 ) {\\n            std::cout << \""\\nMy Book(s): \"";\\n            p2->listBooks();\\n        }\\n    }\\n    void showPlayerCards() {\\n        std::cout << \""\\n\\n\"" << p1->name() << \"", these are your cards:\\n\"";\\n        p1->outputHand();\\n        showBooks();\\n    }\\n    char getInput() {\\n        char c;\\n        if( plr ) {\\n            if( !p1->hasCards() ) return -1;\\n            showPlayerCards();\\n            std::string w;\\n            while( true ) {\\n                std::cout << \""\\nWhat card(rank) do you want? \""; std::cin >> w;\\n                c = toupper( w[0] );\\n                if( p1->holds( c ) ) break; \\n                std::cout << p1->name() << \"", you can't ask for a card you don't have!\\n\\n\""; \\n            }\\n        } else {\\n            if( !p2->hasCards() ) return -1;\\n            c = p2->makeMove();\\n            showPlayerCards();\\n            std::string r;\\n            std::cout << \""\\nDo you have any \"" << c << \""'s? (Y)es / (G)o Fish \"";\\n            do {\\n                std::getline( std::cin, r );\\n                r = toupper( r[0] );\\n            }\\n            while( r[0] != 'Y' && r[0] != 'G' );\\n            bool hasIt = p1->holds( c );\\n            if( hasIt && r[0] == 'G' )\\n                std::cout << \""Are you trying to cheat me?! I know you do...\\n\"";\\n            if( !hasIt && r[0] == 'Y' )\\n                std::cout << \""Nooooo, you don't have it!!!\\n\"";\\n        }\\n        return c;\\n    }\\n    bool process( char c ) {\\n        if( c < 0 ) return true;\\n        if( plr ) p2->rememberCard( c );\\n\\n        player *a, *b;\\n        a = plr ? p2 : p1;\\n        b = plr ? p1 : p2;\\n        bool r;\\n        if( a->holds( c ) ) {\\n            while( a->holds( c ) ) {\\n                r = b->addCard( a->takeCard( c ) );\\n            }\\n            if( plr && r )p2->clearMemory( c );\\n        } else {\\n            fish();\\n            plr = !plr;\\n        }\\n        return false;\\n    }\\n    void fish() {\\n        std::cout << \""\\n\\n\\t  *** GO FISH! ***\\n\\n\"";\\n        card c = deck::instance()->draw();\\n        if( plr ) {\\n            std::cout << \""Your new card: \"" << c << \"".\\n\\n******** Your turn is over! ********\\n\"" << std::string( 36, '-' ) << \""\\n\\n\"";\\n            if( p1->addCard( c ) ) p2->clearMemory( c.getRank() );\\n        } else {\\n            std::cout << \""\\n********* My turn is over! *********\\n\"" << std::string( 36, '-' ) << \""\\n\\n\"";\\n            p2->addCard( c );\\n        }\\n    }\\n\\n    player        *p1;\\n    aiPlayer    *p2;\\n    bool        plr;\\n};\\ndeck* deck::inst = 0;\\nint main( int argc, char* argv[] ) {\\n    srand( static_cast<unsigned>( time( NULL ) ) ); \\n    goFish f;  f.play(); \\n    return 0;\\n}\\n"
"C++","Gray_code","Create functions to encode a number to and decode a number from Gray code.\\nDisplay the normal binary representations, Gray code representations, and decoded Gray code values for all 5-bit binary numbers (0-31 inclusive, leading 0's not necessary).\\nThere are many possible Gray codes. The following encodes what is called \""binary reflected Gray code.\""\\nEncoding (MSB is bit 0, b is binary, g is Gray code):\\nOr:\\nDecoding (MSB is bit 0, b is binary, g is Gray code):\\nDemonstrates the use of shift operators. Code scalable to 6, 7 or 8 bits.\\nValues are implemented with 8 bits according to representation clause\\nof Unsigned_8 (check package Interfaces).\\nCheck compactness of assembly code generated by GNAT :http://pastebin.com/qtNjeQk9\\n","\\n#include <bitset>\\n#include <iostream>\\n#include <string>\\n#include <assert.h>\\n\\nuint32_t gray_encode(uint32_t b)\\n{\\n    return b ^ (b >> 1);\\n}\\n\\nuint32_t gray_decode(uint32_t g)\\n{\\n    for (uint32_t bit = 1U << 31; bit > 1; bit >>= 1)\\n    {\\n        if (g & bit) g ^= bit >> 1;\\n    }\\n    return g;\\n}\\n\\nstd::string to_binary(int value) // utility function\\n{\\n    const std::bitset<32> bs(value);\\n    const std::string str(bs.to_string());\\n    const size_t pos(str.find('1'));\\n    return pos == std::string::npos ? \""0\"" : str.substr(pos);\\n}\\n\\nint main()\\n{\\n    std::cout << \""Number\\tBinary\\tGray\\tDecoded\\n\"";\\n    for (uint32_t n = 0; n < 32; ++n)\\n    {\\n        uint32_t g = gray_encode(n);\\n        assert(gray_decode(g) == n);\\n\\n        std::cout << n << \""\\t\"" << to_binary(n) << \""\\t\"" << to_binary(g) << \""\\t\"" << g << \""\\n\"";\\n    }\\n}"
"C++","Greatest_common_divisor","Find the greatest common divisor of two integers.\\n\\nFor maximum compatibility, this program uses only the basic instruction set (S/360)\\nwith 2 ASSIST macros (XDECO,XPRNT).\\n","#include \\n#include <iostream>\\n\\nint main( ) {\\n   std::cout << \""The least common multiple of 12 and 18 is \"" << \\n      boost::math::lcm( 12 , 18 ) << \"" ,\\n\""\\n      << \""and the greatest common divisor \"" << boost::math::gcd( 12 , 18 ) << \"" !\"" << std::endl ;\\n   return 0 ;\\n}"
"C++","Greatest_element_of_a_list","Create a function that returns the maximum value in a provided set of values,\\nwhere the number of values may not be known until run-time.\\n\\nOutput: 5\\nThe keys for this task are initializing the compared value to the 'First value of the element type, and use of an unconstrained array type.\\nA generic function Max to deal with any floating-point type.\\nImplementation of:\\nWhen the argument array is empty, Constraint_Error exception is propagated, because array indexing is checked in Ada. Note also use of the floating-type attribute Max.\\nor\\n","#include <algorithm>\\n#include <cassert>\\n\\ntemplate Ty max(unsigned int count, Ty values[]) {\\n     assert(count > 0);\\n     return *std::max_element(values, values + count);\\n}"
"C++","Greatest_subsequential_sum","Given a sequence of integers, find a continuous subsequence which maximizes the sum of its elements, that is, the elements of no other single subsequence add up to a value larger than this one.\\n\\nAn empty subsequence is considered to have the sum of   0;   thus if all elements are negative, the result must be the empty sequence.\\n\\n","#include <utility>   // for std::pair\\n#include <iterator>  // for std::iterator_traits\\n#include <iostream>  // for std::cout\\n#include <ostream>   // for output operator and std::endl\\n#include <algorithm> // for std::copy\\n#include <iterator>  // for std::output_iterator\\n\\n// Function template max_subseq\\n//\\n// Given a sequence of integers, find a subsequence which maximizes\\n// the sum of its elements, that is, the elements of no other single\\n// subsequence add up to a value larger than this one.\\n//\\n// Requirements:\\n// * ForwardIterator is a forward iterator\\n// * ForwardIterator's value_type is less-than comparable and addable\\n// * default-construction of value_type gives the neutral element\\n//   (zero)\\n// * operator+ and operator< are compatible (i.e. if a>zero and\\n//   b>zero, then a+b>zero, and if a\\n std::pair\\n max_subseq(ForwardIterator begin, ForwardIterator end)\\n{\\n  typedef typename std::iterator_traits<ForwardIterator>::value_type\\n    value_type;\\n\\n  ForwardIterator seq_begin = begin, seq_end = seq_begin;\\n  value_type seq_sum = value_type();\\n  ForwardIterator current_begin = begin;\\n  value_type current_sum = value_type();\\n\\n  value_type zero = value_type();\\n\\n  for (ForwardIterator iter = begin; iter != end; ++iter)\\n  {\\n    value_type value = *iter;\\n    if (zero < value)\\n    {\\n      if (current_sum < zero)\\n      {\\n        current_sum = zero;\\n        current_begin = iter;\\n      }\\n    }\\n    else\\n    {\\n      if (seq_sum < current_sum)\\n      {\\n        seq_begin = current_begin;\\n        seq_end = iter;\\n        seq_sum = current_sum;\\n      }\\n    }\\n    current_sum += value;\\n  }\\n\\n  if (seq_sum < current_sum)\\n  {\\n    seq_begin = current_begin;\\n    seq_end = end;\\n    seq_sum = current_sum;\\n  }\\n\\n  return std::make_pair(seq_begin, seq_end);\\n}\\n\\n// the test array\\nint array[] = { -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 };\\n\\n// function template to find the one-past-end pointer to the array\\ntemplate int* end(T (&arr)[N]) { return arr+N; }\\n\\nint main()\\n{\\n  // find the subsequence\\n  std::pair seq = max_subseq(array, end(array));\\n\\n  // output it\\n  std::copy(seq.first, seq.second, std::ostream_iterator<int>(std::cout, \"" \""));\\n  std::cout << std::endl;\\n\\n  return 0;\\n}"
"C++","Greed","This task is about making a clone of the game \""GREED\"" by Matthew Day.\\nThis game is played on a grid of 79 column by 22 rows of random numbers from 1 to 9. The player location is signified by the '@' symbol.\\nThe object of Greed is to erase as much of the screen as possible by moving around (all 8 directions are allowed) in this grid. When you move in a direction, you erase N number of grid squares in that direction, N being the first number in that direction. Your score reflects the total number of squares eaten.\\nYou may not make a move that places you off the grid or over a previously eaten square.\\nThe game is over if there is no more valid moves.\\nVideo on YouTube\\n\\nWindows console version.\\nNote that this version uses the Z key (rather than the Y key) to move diagonally downwards to the left.\\nSee Greed/Java.\\n\\nThis REXX version's only dependency is that the DOS command   cls   is used to clear the terminal screen.\\nNo attempt was made to validate the input the input arguments (parameters) for this REXX program.\\nPointers (above and to the right of) the grid are included to help identify where the current location is.\\nA note on the OUTPUT sections:   each (cleared) screen displayed is shown below as a separate OUTPUT section.\\nThe following are the screen shots when inputs used   (size of the grid)   are:      22   10 \\n","\\n#include <windows.h>\\n#include <iostream>\\n#include <ctime>\\n\\nconst int WID = 79, HEI = 22;\\nconst float NCOUNT = ( float )( WID * HEI );\\n\\nclass coord : public COORD {\\npublic:\\n    coord( short x = 0, short y = 0 ) { set( x, y ); }\\n    void set( short x, short y ) { X = x; Y = y; }\\n};\\nclass winConsole {\\npublic:\\n    static winConsole* getInstamnce() { if( 0 == inst ) { inst = new winConsole(); } return inst; }\\n    void showCursor( bool s ) { CONSOLE_CURSOR_INFO ci = { 1, s }; SetConsoleCursorInfo( conOut, &ci ); }\\n    void setColor( WORD clr ) { SetConsoleTextAttribute( conOut, clr ); }\\n    void setCursor( coord p ) { SetConsoleCursorPosition( conOut, p ); }\\n    void flush() { FlushConsoleInputBuffer( conIn ); }\\n    void kill() { delete inst; }\\nprivate:\\n    winConsole() { conOut = GetStdHandle( STD_OUTPUT_HANDLE ); \\n                   conIn  = GetStdHandle( STD_INPUT_HANDLE ); showCursor( false ); }\\n    static winConsole* inst;\\n    HANDLE conOut, conIn;\\n};\\nclass greed {\\npublic:\\n    greed() { console = winConsole::getInstamnce(); }\\n    ~greed() { console->kill(); }\\n    void play() {\\n        char g; do {\\n            console->showCursor( false ); createBoard();\\n            do { displayBoard(); getInput(); } while( existsMoves() );\\n            displayBoard(); console->setCursor( coord( 0, 24 ) ); console->setColor( 0x07 );\\n            console->setCursor( coord( 19,  8 ) ); std::cout << \""+----------------------------------------+\"";\\n            console->setCursor( coord( 19,  9 ) ); std::cout << \""|               GAME OVER                |\"";\\n            console->setCursor( coord( 19, 10 ) ); std::cout << \""|            PLAY AGAIN(Y/N)?            |\"";\\n            console->setCursor( coord( 19, 11 ) ); std::cout << \""+----------------------------------------+\"";\\n            console->setCursor( coord( 48, 10 ) ); console->showCursor( true ); console->flush(); std::cin >> g;\\n        } while( g == 'Y' || g == 'y' );\\n    }\\nprivate:\\n    void createBoard() {\\n        for( int y = 0; y < HEI; y++ ) {\\n            for( int x = 0; x < WID; x++ ) {\\n                brd[x + WID * y] = rand() % 9 + 1;\\n            }\\n        }\\n        cursor.set( rand() % WID, rand() % HEI );\\n        brd[cursor.X + WID * cursor.Y] = 0; score = 0;\\n        printScore();\\n    }\\n    void displayBoard() {\\n        console->setCursor( coord() ); int i;\\n		for( int y = 0; y < HEI; y++ ) {\\n            for( int x = 0; x < WID; x++ ) {\\n                i = brd[x + WID * y]; console->setColor( 6 + i );\\n                if( !i ) std::cout << \"" \""; else std::cout << i;\\n            }\\n            std::cout << \""\\n\"";\\n        }\\n        console->setColor( 15 ); console->setCursor( cursor ); std::cout << \""@\"";\\n    }\\n    void getInput() { \\n        while( 1 ) {\\n            if( ( GetAsyncKeyState( 'Q' ) & 0x8000 ) && cursor.X > 0 && cursor.Y > 0 ) { execute( -1, -1 ); break; }\\n            if( ( GetAsyncKeyState( 'W' ) & 0x8000 ) &&  cursor.Y > 0 ) { execute( 0, -1 ); break; }\\n            if( ( GetAsyncKeyState( 'E' ) & 0x8000 ) && cursor.X < WID - 1 && cursor.Y > 0 ) { execute( 1, -1 ); break; }\\n            if( ( GetAsyncKeyState( 'A' ) & 0x8000 ) && cursor.X > 0 ) { execute( -1, 0 ); break; }\\n            if( ( GetAsyncKeyState( 'D' ) & 0x8000 ) && cursor.X < WID - 1 ) { execute( 1, 0 ); break; }\\n            if( ( GetAsyncKeyState( 'Y' ) & 0x8000 ) && cursor.X > 0 && cursor.Y < HEI - 1 ) { execute( -1, 1 ); break; }\\n            if( ( GetAsyncKeyState( 'X' ) & 0x8000 ) && cursor.Y < HEI - 1 ) { execute( 0, 1 ); break; }\\n            if( ( GetAsyncKeyState( 'C' ) & 0x8000 ) && cursor.X < WID - 1 && cursor.Y < HEI - 1 ) { execute( 1, 1 ); break; }\\n        }\\n        console->flush(); printScore();\\n    }\\n    void printScore() {\\n        console->setCursor( coord( 0, 24 ) ); console->setColor( 0x2a );\\n        std::cout << \""      SCORE: \"" << score << \"" : \"" << score * 100.f / NCOUNT << \""%      \"";\\n    }\\n    void execute( int x, int y ) {\\n        int i = brd[cursor.X + x + WID * ( cursor.Y + y )];\\n        if( countSteps( i, x, y ) ) {\\n            score += i;\\n            while( i ) {\\n                --i; cursor.X += x; cursor.Y += y;\\n                brd[cursor.X + WID * cursor.Y] = 0;\\n            }\\n        }\\n    }\\n    bool countSteps( int i, int x, int y ) {\\n        coord t( cursor.X, cursor.Y );\\n        while( i ) {\\n            --i; t.X += x; t.Y += y;\\n            if( t.X < 0 || t.Y < 0 || t.X >= WID || t.Y >= HEI || !brd[t.X + WID * t.Y] ) return false;\\n        }\\n        return true;\\n    }\\n    bool existsMoves() {\\n        int i;\\n        for( int y = -1; y < 2; y++ ) {\\n            for( int x = -1; x < 2; x++ ) {\\n                if( !x && !y ) continue;\\n                i = brd[cursor.X + x + WID * ( cursor.Y + y )];\\n                if( i > 0 && countSteps( i, x, y ) ) return true;\\n            }\\n        }\\n        return false;\\n    }\\n    winConsole* console;\\n    int brd[WID * HEI];\\n    float score; coord cursor;\\n};\\nwinConsole* winConsole::inst = 0;\\nint main( int argc, char* argv[] ) {\\n    srand( ( unsigned )time( 0 ) );\\n    SetConsoleTitle( \""Greed\"" );\\n    greed g; g.play(); return 0;\\n}\\n"
"C++","Greyscale_bars/Display","The task is to display a series of vertical greyscale bars (contrast bars) with a sufficient number of bars to span the entire width of the display.\\nFor the top quarter of the display, the left hand bar should be black, and we then incrementally step through six shades of grey until we have a white bar on the right hand side of the display. (This gives a total of 8 bars)\\nFor the second quarter down, we start with white and step down through 14 shades of gray, getting darker until we have black on the right hand side of the display. (This gives a total of 16 bars).\\nHalfway down the display, we start with black, and produce 32 bars, ending in white, and for the last quarter, we start with white and step through 62 shades of grey, before finally arriving at black in the bottom right hand corner, producing a total of 64 bars for the bottom quarter.\\nRequires the GDI+ Standard Library by tic: http://www.autohotkey.com/forum/viewtopic.php?t=32238\\n\\nusing Qt 4.6\\n\\nClick here for image of the output\\n","#ifndef MYWIDGET_H\\n#define MYWIDGET_H\\n#include <QWidget>\\n\\nclass QPaintEvent ;\\n\\nclass MyWidget : public QWidget {\\npublic :\\n   MyWidget( ) ;\\n\\nprotected :\\n   void paintEvent( QPaintEvent * ) ;\\n} ;\\n#endif"
"C++","Greyscale_bars/Display","The task is to display a series of vertical greyscale bars (contrast bars) with a sufficient number of bars to span the entire width of the display.\\nFor the top quarter of the display, the left hand bar should be black, and we then incrementally step through six shades of grey until we have a white bar on the right hand side of the display. (This gives a total of 8 bars)\\nFor the second quarter down, we start with white and step down through 14 shades of gray, getting darker until we have black on the right hand side of the display. (This gives a total of 16 bars).\\nHalfway down the display, we start with black, and produce 32 bars, ending in white, and for the last quarter, we start with white and step through 62 shades of grey, before finally arriving at black in the bottom right hand corner, producing a total of 64 bars for the bottom quarter.\\nRequires the GDI+ Standard Library by tic: http://www.autohotkey.com/forum/viewtopic.php?t=32238\\n\\nusing Qt 4.6\\n\\nClick here for image of the output\\n","#include <QtGui>\\n#include \""greytones.h\""\\n\\nMyWidget::MyWidget( ) {\\n   setGeometry( 0, 0 , 640 , 480 ) ;\\n}\\n\\nvoid MyWidget::paintEvent ( QPaintEvent * ) {\\n   QBrush myBrush( Qt::SolidPattern ) ;\\n   QPainter myPaint( this ) ;\\n   int run = 0 ; //how often have we run through the loop ?\\n   int colorcomp = 0 ;\\n   for ( int columncount = 8 ; columncount < 128 ; columncount *= 2 ) {\\n      int colorgap = 255 / columncount ;\\n      int columnwidth = 640 / columncount ; // 640 being the window width\\n      int columnheight = 480 / 4 ; //we're looking at quarters\\n      if ( run % 2 == 0 ) { //we start with black columns \\n	 colorcomp = 0 ;\\n      }\\n      else { //we start with white columns \\n	 colorcomp = 255 ;\\n	 colorgap *= -1 ; //we keep subtracting color values \\n      }\\n      int ystart = 0 + columnheight * run ; //determines the y coordinate of the first column per row\\n      int xstart = 0 ;\\n      for ( int i = 0 ; i < columncount ; i++ ) {\\n	 myBrush.setColor( QColor( colorcomp, colorcomp , colorcomp ) ) ;\\n	 myPaint.fillRect( xstart , ystart , columnwidth , columnheight , myBrush ) ;\\n	 xstart += columnwidth ;\\n	 colorcomp += colorgap ; //we choose the next color \\n      }\\n      run++ ;\\n   }\\n}"
"C++","Greyscale_bars/Display","The task is to display a series of vertical greyscale bars (contrast bars) with a sufficient number of bars to span the entire width of the display.\\nFor the top quarter of the display, the left hand bar should be black, and we then incrementally step through six shades of grey until we have a white bar on the right hand side of the display. (This gives a total of 8 bars)\\nFor the second quarter down, we start with white and step down through 14 shades of gray, getting darker until we have black on the right hand side of the display. (This gives a total of 16 bars).\\nHalfway down the display, we start with black, and produce 32 bars, ending in white, and for the last quarter, we start with white and step through 62 shades of grey, before finally arriving at black in the bottom right hand corner, producing a total of 64 bars for the bottom quarter.\\nRequires the GDI+ Standard Library by tic: http://www.autohotkey.com/forum/viewtopic.php?t=32238\\n\\nusing Qt 4.6\\n\\nClick here for image of the output\\n","#include <QApplication>\\n#include \""greytones.h\""\\n\\nint main( int argc, char * argv[ ] ) {\\n   QApplication app( argc , argv ) ;\\n   MyWidget window ;\\n   window.setWindowTitle( QApplication::translate( \""greyScales\"" , \""grey scales demonstration\"" ) ) ;\\n   window.show( ) ;\\n   return app.exec( ) ;\\n}"
"C++","Guess_the_number","Write a program where the program chooses a number between   1   and   10.\\nA player is then prompted to enter a guess.   If the player guesses wrong,   then the prompt appears again until the guess is correct.\\nWhen the player has made a successful guess the computer will issue a   \""Well guessed!\""   message,   and the program exits.\\nA   conditional loop   may be used to repeat the guessing until the user is correct.\\n\\n\\nSample output:\\n\\nOr, constraining mutation, and abstracting a little to an until(predicate, function, value) pattern\\nZX Spectrum Basic has no conditional loop constructs, so we have to emulate them here using IF and GO TO.\\nThe value is generated by the clk function, which returns a (probably) non-integral rational number. The den function retrieves the denominators of this number. The rational number, multiplied by its denominator, becomes an natural number.\\nOutput:\\n","#include <iostream>\\n#include <cstdlib>\\n#include <ctime>\\n\\nint main()\\n{\\n    srand(time(0));\\n    int n = 1 + (rand() % 10);\\n    int g;\\n    std::cout << \""I'm thinking of a number between 1 and 10.\\nTry to guess it! \"";\\n    while(true)\\n    {\\n        std::cin >> g;\\n        if (g == n)\\n            break;\\n        else\\n            std::cout << \""That's not my number.\\nTry another guess! \"";\\n    }\\n    std::cout << \""You've guessed my number!\"";\\n    return 0;\\n}\\n\\n"
"C++","Guess_the_number/With_feedback","Write a game (computer program) that follows the following rules:\\n\\n\\n","#include <iostream>\\n#include <cstdlib>\\n#include <ctime>\\n\\nint main()\\n{\\n    std::srand(std::time(0));\\n    int lower, upper, guess;\\n    std::cout << \""Enter lower limit: \"";\\n    std::cin >> lower;\\n    std::cout << \""Enter upper limit: \"";\\n    std::cin >> upper;\\n    int random_number = lower + std::rand() % ((upper + 1) - lower);\\n\\n    do\\n    {\\n        std::cout << \""Guess what number I have: \"";\\n        std::cin >> guess;\\n        if (guess > random_number)\\n            std::cout << \""Your guess is too high\\n\"";\\n        else if (guess < random_number)\\n            std::cout << \""Your guess is too low\\n\"";\\n        else\\n            std::cout << \""You got it!\\n\"";\\n    } while (guess != random_number);\\n\\n    return 0;\\n}"
"C++","Guess_the_number/With_feedback_(player)","Write a player for the game that follows the following rules:\\nThe computer should guess intelligently based on the accumulated scores given. One way is to use a Binary search based algorithm.\\n\\n\\nWorks with the AutoHotkey entry at: Guess the number/With feedback\\n","#include <iostream>\\n#include <algorithm>\\n#include <string>\\n#include <iterator>\\n \\nstruct GuessNumberIterator : std::iterator {\\n  int i;\\n  GuessNumberIterator() { }\\n  GuessNumberIterator(int _i) : i(_i) { }\\n  GuessNumberIterator& operator++() { ++i; return *this; }\\n  GuessNumberIterator operator++(int) {\\n    GuessNumberIterator tmp = *this; ++(*this); return tmp; }\\n  bool operator==(const GuessNumberIterator& y) { return i == y.i; }\\n  bool operator!=(const GuessNumberIterator& y) { return i != y.i; }\\n  int operator*() {\\n    std::cout << \""Is your number less than or equal to \"" << i << \""? \"";\\n    std::string s;\\n    std::cin >> s;\\n    return (s != \""\"" && (s[0] == 'y' || s[0] == 'Y')) ? 0 : -1;\\n  }\\n  GuessNumberIterator& operator--() { --i; return *this; }\\n  GuessNumberIterator operator--(int) {\\n    GuessNumberIterator tmp = *this; --(*this); return tmp; }\\n  GuessNumberIterator& operator+=(int n) { i += n; return *this; }\\n  GuessNumberIterator& operator-=(int n) { i -= n; return *this; }\\n  GuessNumberIterator operator+(int n) {\\n    GuessNumberIterator tmp = *this; return tmp += n; }\\n  GuessNumberIterator operator-(int n) {\\n    GuessNumberIterator tmp = *this; return tmp -= n; }\\n  int operator-(const GuessNumberIterator &y) { return i - y.i; }\\n  int operator[](int n) { return *(*this + n); }\\n  bool operator<(const GuessNumberIterator &y) { return i < y.i; }\\n  bool operator>(const GuessNumberIterator &y) { return i > y.i; }\\n  bool operator<=(const GuessNumberIterator &y) { return i <= y.i; }\\n  bool operator>=(const GuessNumberIterator &y) { return i >= y.i; }\\n};\\ninline GuessNumberIterator operator+(int n, GuessNumberIterator &i) { return i + n; }\\n \\nconst int lower = 0;\\nconst int upper = 100;\\n \\nint main() {\\n  std::cout << \""Instructions:\\n\""\\n	    << \""Think of integer number from \"" << lower << \"" (inclusive) to \""\\n	    << upper << \"" (exclusive) and\\n\""\\n	    << \""I will guess it. After each guess, I will ask you if it is less than\\n\""\\n	    << \""or equal to some number, and you will respond with \\\""yes\\\"" or \\\""no\\\"".\\n\"";\\n  int answer = std::lower_bound(GuessNumberIterator(lower), GuessNumberIterator(upper), 0).i;\\n  std::cout << \""Your number is \"" << answer << \"".\\n\"";\\n  return 0;\\n}"
"C++","GUI_component_interaction","\\nAlmost every application needs to communicate with the user in some way.\\nTherefore, a substantial part of the code deals with the interaction\\nof program logic with GUI components.\\nTypically, the following is needed:\\n\\nFor a minimal \""application\"", write a program that presents a form with three components to the user:\\n\\nThe field is initialized to zero.\\nThe user may manually enter a new value into the field,\\nor increment its value with the \""increment\"" button.\\nEntering a non-numeric value should be either impossible,\\nor issue an error message.\\nPressing the \""random\"" button presents a confirmation dialog,\\nand resets the field's value to a random value if the answer is \""Yes\"".\\n(This task may be regarded as an extension of the task Simple windowed application).\\ninteraction.adb:\\n","#ifndef INTERACTION_H\\n#define INTERACTION_H\\n#include <QWidget>\\n\\nclass QPushButton ;\\nclass QLineEdit ;\\nclass QVBoxLayout ;\\nclass MyWidget : public QWidget {\\n   Q_OBJECT \\n\\npublic :\\n   MyWidget( QWidget *parent = 0 ) ;\\nprivate :\\n   QLineEdit *entryField ;\\n   QPushButton *increaseButton ;\\n   QPushButton *randomButton ;\\n   QVBoxLayout *myLayout ;\\nprivate slots :\\n   void doIncrement( ) ;\\n   void findRandomNumber( ) ;\\n} ;\\n#endif"
"C++","GUI_component_interaction","\\nAlmost every application needs to communicate with the user in some way.\\nTherefore, a substantial part of the code deals with the interaction\\nof program logic with GUI components.\\nTypically, the following is needed:\\n\\nFor a minimal \""application\"", write a program that presents a form with three components to the user:\\n\\nThe field is initialized to zero.\\nThe user may manually enter a new value into the field,\\nor increment its value with the \""increment\"" button.\\nEntering a non-numeric value should be either impossible,\\nor issue an error message.\\nPressing the \""random\"" button presents a confirmation dialog,\\nand resets the field's value to a random value if the answer is \""Yes\"".\\n(This task may be regarded as an extension of the task Simple windowed application).\\ninteraction.adb:\\n","#include <QPushButton>\\n#include <QLineEdit>\\n#include <QMessageBox>\\n#include <QString>\\n#include <QRegExpValidator>\\n#include <QVBoxLayout>\\n#include <QRegExp>\\n#include <ctime> //for the srand initialization\\n#include <cstdlib> //for the random number\\n#include \""interaction.h\"" \\n\\nMyWidget::MyWidget (QWidget *parent ) : QWidget( parent ) {\\n   myLayout = new QVBoxLayout( ) ;\\n   entryField = new QLineEdit( \""0\"" ) ;\\n   QRegExp rx( \""\\\\d+\"" ) ;\\n   QValidator *myvalidator = new QRegExpValidator( rx , this ) ;\\n   entryField->setValidator( myvalidator ) ;\\n   increaseButton = new QPushButton( \""increase\"" ) ;\\n   connect( increaseButton, SIGNAL( clicked( ) ) ,\\n	 this , SLOT( doIncrement( ) )) ;\\n   randomButton = new QPushButton( \""random\"" ) ;\\n   connect( randomButton , SIGNAL( clicked( ) ) ,\\n	 this , SLOT ( findRandomNumber( ) )) ;\\n   myLayout->addWidget( entryField ) ;\\n   myLayout->addWidget( increaseButton ) ;\\n   myLayout->addWidget( randomButton ) ;\\n   setLayout( myLayout ) ;\\n}\\n\\nvoid MyWidget::doIncrement( ) {\\n   bool ok ;\\n   int zahl = entryField->text( ).toInt( &ok, 10 ) ;\\n   entryField->setText( QString( \""%1\"").arg( ++zahl ) ) ;\\n}\\n\\nvoid MyWidget::findRandomNumber( ) {\\n   QMessageBox msgBox( this ) ;\\n   msgBox.setText( \""Do you want to create a random number ?\"" ) ;\\n   msgBox.setStandardButtons( QMessageBox::Yes | QMessageBox::No ) ;\\n   int ret = msgBox.exec( ) ;\\n   switch ( ret ) {\\n      case QMessageBox::Yes :\\n	 srand( time( 0 ) ) ;\\n	 int zahl = random( ) ;\\n	 entryField->setText( QString( \""%1\"" ).arg( zahl )) ;\\n	 break ;\\n   }\\n}"
"C++","GUI_component_interaction","\\nAlmost every application needs to communicate with the user in some way.\\nTherefore, a substantial part of the code deals with the interaction\\nof program logic with GUI components.\\nTypically, the following is needed:\\n\\nFor a minimal \""application\"", write a program that presents a form with three components to the user:\\n\\nThe field is initialized to zero.\\nThe user may manually enter a new value into the field,\\nor increment its value with the \""increment\"" button.\\nEntering a non-numeric value should be either impossible,\\nor issue an error message.\\nPressing the \""random\"" button presents a confirmation dialog,\\nand resets the field's value to a random value if the answer is \""Yes\"".\\n(This task may be regarded as an extension of the task Simple windowed application).\\ninteraction.adb:\\n","#include <QApplication>\\n#include \""interaction.h\""\\n\\nint main( int argc , char *argv[ ] ) {\\n   QApplication app( argc, argv ) ;\\n   MyWidget theWidget ;\\n   theWidget.show( ) ;\\n   return app.exec( ) ;\\n}"
"C++","GUI_component_interaction","\\nAlmost every application needs to communicate with the user in some way.\\nTherefore, a substantial part of the code deals with the interaction\\nof program logic with GUI components.\\nTypically, the following is needed:\\n\\nFor a minimal \""application\"", write a program that presents a form with three components to the user:\\n\\nThe field is initialized to zero.\\nThe user may manually enter a new value into the field,\\nor increment its value with the \""increment\"" button.\\nEntering a non-numeric value should be either impossible,\\nor issue an error message.\\nPressing the \""random\"" button presents a confirmation dialog,\\nand resets the field's value to a random value if the answer is \""Yes\"".\\n(This task may be regarded as an extension of the task Simple windowed application).\\ninteraction.adb:\\n","#include <QApplication>\\n#include <QWidget>\\n#include <QVBoxLayout>\\n#include <QPushButton>\\n#include <QLineEdit>\\n#include <QIntValidator>\\n#include <QMessageBox>\\n#include <QTime>\\n\\nint main(int argc, char **argv) {\\n    qsrand(QTime::currentTime().msec());\\n\\n    QApplication app(argc, argv);\\n\\n    auto *edit = new QLineEdit(\""0\"");\\n    edit->setValidator(new QIntValidator());\\n\\n    auto *incButton = new QPushButton(\""&Increment\"");\\n    QObject::connect(incButton, &QPushButton::clicked, \\n            [edit]() { edit->setText( QString::number(edit->text().toInt() + 1)); } );\\n\\n    auto *rndButton = new QPushButton(\""&Random\"");\\n    QObject::connect(rndButton, &QPushButton::clicked, \\n            [edit]() { \\n                auto result = QMessageBox(\\n                    QMessageBox::Warning,\\n                    \""Random\"",\\n                    \""Overwrite current value with a random number ?\"",\\n                    QMessageBox::Ok | QMessageBox::Cancel\\n                ).exec();\\n\\n                if (result == QMessageBox::Ok)\\n                    edit->setText( QString::number(qrand())); \\n            } );\\n\\n    auto *vbox = new QVBoxLayout;\\n    vbox->addWidget(edit);\\n    vbox->addWidget(incButton);\\n    vbox->addWidget(rndButton);\\n\\n    QWidget mainWindow;\\n    mainWindow.setLayout(vbox);\\n    mainWindow.show();\\n\\n    return app.exec();\\n}"
"C++","GUI_enabling/disabling_of_controls","In addition to fundamental GUI component interaction, an application should\\ndynamically enable and disable GUI components, to give some guidance to the\\nuser, and prohibit (inter)actions which are inappropriate in the current state\\nof the application.\\n\\nSimilar to the task GUI component interaction, write a program\\nthat presents a form with three components to the user:\\n\\nThe field is initialized to zero.\\nThe user may manually enter a new value into the field,\\nincrement its value with the \""increment\"" button,\\nor decrement the value with the \""decrement\"" button.\\nThe input field should be enabled only when its value is zero.\\nThe \""increment\"" button only as long as the field's value is less then 10:\\nWhen the value 10 is reached, the button should go into a disabled state.\\nAnalogously, the \""decrement\"" button should be enabled only as long as\\nthe value is greater than zero.\\nEffectively, the user can now either increment up to 10, or down to zero.\\nManually entering values outside that range is still legal,\\nbut the buttons should reflect that and enable/disable accordingly.\\n\\ndisabling.adb:\\n","#ifndef TASK_H\\n#define TASK_H\\n\\n#include <QWidget>\\n\\nclass QPushButton ;\\nclass QString ;\\nclass QLineEdit ;\\nclass QLabel ;\\nclass QVBoxLayout ;\\nclass QHBoxLayout ;\\n\\nclass MyWidget : public QWidget {\\n    \\n    Q_OBJECT\\npublic:\\n   MyWidget( QWidget *parent = 0 ) ;\\nprivate slots:\\n   void buttonChange( const QString & ) ;\\n   void addField( ) ;\\n   void subtractField( ) ;\\nprivate :\\n   QVBoxLayout *thisWidgetLayout ;\\n   QLabel *instruction ;\\n   QPushButton *increment ;\\n   QPushButton *decrement ;\\n   QLineEdit *entryField ;\\n   QHBoxLayout *lowerPart ;\\n} ;\\n#endif"
"C++","GUI_enabling/disabling_of_controls","In addition to fundamental GUI component interaction, an application should\\ndynamically enable and disable GUI components, to give some guidance to the\\nuser, and prohibit (inter)actions which are inappropriate in the current state\\nof the application.\\n\\nSimilar to the task GUI component interaction, write a program\\nthat presents a form with three components to the user:\\n\\nThe field is initialized to zero.\\nThe user may manually enter a new value into the field,\\nincrement its value with the \""increment\"" button,\\nor decrement the value with the \""decrement\"" button.\\nThe input field should be enabled only when its value is zero.\\nThe \""increment\"" button only as long as the field's value is less then 10:\\nWhen the value 10 is reached, the button should go into a disabled state.\\nAnalogously, the \""decrement\"" button should be enabled only as long as\\nthe value is greater than zero.\\nEffectively, the user can now either increment up to 10, or down to zero.\\nManually entering values outside that range is still legal,\\nbut the buttons should reflect that and enable/disable accordingly.\\n\\ndisabling.adb:\\n","#include <QtGui>\\n#include <QString>\\n#include \""task.h\"" \\n\\nMyWidget::MyWidget ( QWidget *parent ) \\n   : QWidget( parent ) {\\n   thisWidgetLayout = new QVBoxLayout ( this )  ;\\n   instruction = new QLabel ;\\n   instruction->setText( \""Enter a number between 1 and 10 ! Numbers above 10 are decremented, below 0 incremented!\"" ) ;\\n   instruction->setWordWrap( true ) ;\\n   lowerPart = new QHBoxLayout ;\\n   entryField = new QLineEdit( \""0\"" ) ;\\n   increment = new QPushButton( \""Increment\"" ) ;\\n   decrement = new QPushButton( \""Decrement\"" ) ;\\n   increment->setDefault( true ) ;\\n   connect( entryField , SIGNAL ( textChanged ( const QString &  ) ) , \\n	    this , SLOT ( buttonChange( const QString & )) ) ;\\n   connect( entryField , SIGNAL ( textEdited ( const QString &  ) ) , \\n	    this , SLOT ( buttonChange( const QString & )) ) ;\\n   connect( increment , SIGNAL ( clicked( ) ) , this ,\\n	 SLOT ( addField( ) )) ;\\n   connect( decrement , SIGNAL ( clicked( ) ) , this ,\\n	 SLOT ( subtractField( ))) ;\\n   lowerPart->addWidget( entryField ) ;\\n   lowerPart->addWidget( increment ) ;\\n   lowerPart->addWidget( decrement ) ;\\n   thisWidgetLayout->addWidget( instruction ) ;\\n   thisWidgetLayout->addLayout( lowerPart ) ;\\n   setLayout( thisWidgetLayout ) ;\\n}\\n\\nvoid MyWidget::buttonChange( const QString & text ) {\\n   bool ok ;\\n   increment->setEnabled( text.toInt( &ok, 10 ) < 10 ) ;\\n   increment->setDisabled( text.toInt( &ok, 10 ) > 9 ) ;\\n   decrement->setEnabled( text.toInt( &ok, 10 ) > 0 ) ;\\n   decrement->setDisabled( text.toInt( &ok, 10 ) <= 0 ) ;\\n   if ( ! ( text == \""0\"" ) ) \\n      entryField->setReadOnly( true ) ;\\n}\\n\\nvoid MyWidget::addField( ) { \\n   bool ok ;\\n   int number = entryField->text( ).toInt( &ok , 10 ) ;\\n   number++ ;\\n   entryField->setText( QString(\""%1\"").arg( number )) ;\\n}\\n\\nvoid MyWidget::subtractField( ) {\\n   bool ok ;\\n   int number = entryField->text( ).toInt( &ok , 10 ) ;\\n   number-- ;\\n   entryField->setText( QString(\""%1\"").arg( number )) ;\\n}"
"C++","GUI_enabling/disabling_of_controls","In addition to fundamental GUI component interaction, an application should\\ndynamically enable and disable GUI components, to give some guidance to the\\nuser, and prohibit (inter)actions which are inappropriate in the current state\\nof the application.\\n\\nSimilar to the task GUI component interaction, write a program\\nthat presents a form with three components to the user:\\n\\nThe field is initialized to zero.\\nThe user may manually enter a new value into the field,\\nincrement its value with the \""increment\"" button,\\nor decrement the value with the \""decrement\"" button.\\nThe input field should be enabled only when its value is zero.\\nThe \""increment\"" button only as long as the field's value is less then 10:\\nWhen the value 10 is reached, the button should go into a disabled state.\\nAnalogously, the \""decrement\"" button should be enabled only as long as\\nthe value is greater than zero.\\nEffectively, the user can now either increment up to 10, or down to zero.\\nManually entering values outside that range is still legal,\\nbut the buttons should reflect that and enable/disable accordingly.\\n\\ndisabling.adb:\\n","#include <QApplication>\\n#include \""task.h\""\\n\\nint main( int argc, char *argv[ ] ) {\\n   QApplication app( argc , argv ) ;\\n   MyWidget theWidget ;\\n   theWidget.show( ) ;\\n   return app.exec( ) ;\\n}"
"C++","Hailstone_sequence","The Hailstone sequence of numbers can be generated from a starting positive integer,   n   by:\\n\\nThe (unproven) Collatz conjecture is that the hailstone sequence for any starting number always terminates.\\n\\nThe hailstone sequence is also known as   hailstone numbers   (because the values are usually subject to multiple descents and ascents like hailstones in a cloud).\\nThis sequence is also known as the   Collatz sequence.\\n\\n\\n\\n","#include <iostream>\\n#include <vector>\\n#include <utility>\\n\\nstd::vector<int> hailstone(int i)\\n{\\n    std::vector<int> v;\\n    while(true){ \\n        v.push_back(i);\\n        if (1 == i) break; \\n        i = (i % 2) ? (3 * i + 1) : (i / 2);\\n    }\\n    return v;\\n}\\n\\nstd::pair find_longest_hailstone_seq(int n)\\n{\\n    std::pair maxseq(0, 0);\\n    int l; \\n    for(int i = 1; i < n; ++i){\\n        l = hailstone(i).size(); \\n        if (l > maxseq.second) maxseq = std::make_pair(i, l);\\n    }   \\n    return maxseq;\\n}\\n\\nint main () {\\n\\n// Use the routine to show that the hailstone sequence for the number 27 \\n    std::vector<int> h27;\\n    h27 = hailstone(27); \\n// has 112 elements \\n    int l = h27.size();\\n    std::cout << \""length of hailstone(27) is \"" << l;\\n// starting with 27, 82, 41, 124 and \\n    std::cout << \"" first four elements of hailstone(27) are \"";\\n    std::cout << h27[0] << \"" \"" << h27[1] << \"" \"" \\n              << h27[2] << \"" \"" << h27[3] << std::endl;\\n// ending with 8, 4, 2, 1\\n    std::cout << \"" last four elements of hailstone(27) are \""\\n              << h27[l-4] << \"" \"" << h27[l-3] << \"" \"" \\n              << h27[l-2] << \"" \"" << h27[l-1] << std::endl;\\n\\n    std::pair m = find_longest_hailstone_seq(100000); \\n\\n    std::cout << \""the longest hailstone sequence under 100,000 is \"" << m.first \\n              << \"" with \"" << m.second << \"" elements.\"" <\\n\\n{{out}}\\n<pre>\\n length of hailstone(27) is 112 first four elements of hailstone(27) are 27 82 41 124\\n last four elements of hailstone(27) are 8 4 2 1\\n the longest hailstone sequence under 100,000 is 77031 with 351 elements.\\n"
"C++","Hamming_numbers","Hamming numbers are numbers of the form  \\nwhere\\nHamming numbers   are also known as   ugly numbers   and also   5-smooth numbers   (numbers whose prime divisors are less or equal to 5).\\n\\nGenerate the sequence of Hamming numbers, in increasing order.   In particular:\\n\\n\\n","\\n#include <iostream>\\n#include <vector>\\n// Hamming like sequences Generator\\n//\\n// Nigel Galloway. August 13th., 2012\\n//\\nclass Ham {\\nprivate:\\n	std::vector _H, _hp, _hv, _x;\\npublic:\\n	bool operator!=(const Ham& other) const {return true;}\\n	Ham begin() const {return *this;}\\n        Ham end() const {return *this;}\\n	unsigned int operator*() const {return _x.back();}\\n	Ham(const std::vector &pfs):_H(pfs),_hp(pfs.size(),0),_hv({pfs}),_x({1}){}\\n	const Ham& operator++() {\\n	  for (int i=0; i<_H.size(); i++) for (;_hv[i]<=_x.back();_hv[i]=_x[++_hp[i]]*_H[i]);\\n	  _x.push_back(_hv[0]);\\n	  for (int i=1; i<_H.size(); i++) if (_hv[i]<_x.back()) _x.back()=_hv[i];\\n	  return *this;\\n	}\\n};\\n"
"C++","Hamming_numbers","Hamming numbers are numbers of the form  \\nwhere\\nHamming numbers   are also known as   ugly numbers   and also   5-smooth numbers   (numbers whose prime divisors are less or equal to 5).\\n\\nGenerate the sequence of Hamming numbers, in increasing order.   In particular:\\n\\n\\n","\\nint main() {\\n  int count = 1;\\n  for (unsigned int i : Ham({2,3,5})) {\\n    if (count <= 62) std::cout << i << ' ';\\n    if (count++ == 1691) {\\n      std::cout << \""\\nThe one thousand six hundred and ninety first Hamming Number is \"" << i << std::endl;\\n      break;\\n    }\\n  }\\n  return 0;\\n}\\n"
"C++","Hamming_numbers","Hamming numbers are numbers of the form  \\nwhere\\nHamming numbers   are also known as   ugly numbers   and also   5-smooth numbers   (numbers whose prime divisors are less or equal to 5).\\n\\nGenerate the sequence of Hamming numbers, in increasing order.   In particular:\\n\\n\\n","\\nint main() {\\n  int count = 1;\\n  for (unsigned int i : Ham({2,3,5,7})) {\\n    std::cout << i << ' ';\\n    if (count++ == 64) break;\\n  }\\n  std::cout << std::endl;\\n  return 0;\\n}\\n"
"C++","Hamming_numbers","Hamming numbers are numbers of the form  \\nwhere\\nHamming numbers   are also known as   ugly numbers   and also   5-smooth numbers   (numbers whose prime divisors are less or equal to 5).\\n\\nGenerate the sequence of Hamming numbers, in increasing order.   In particular:\\n\\n\\n","#include <chrono>\\n#include <iostream>\\n#include <gmpxx.h>\\n#include <functional>\\n#include <memory>\\n\\ntemplate\\nclass Lazy {\\npublic:\\n	T _v;\\nprivate:\\n	std::function _f;\\n\\npublic:\\n	explicit Lazy(std::function thnk)\\n		: _v(T()), _f(thnk) {};\\n	T value() { // not thread safe!\\n		if (this->_f != nullptr) {\\n			this->_v = this->_f();\\n			this->_f = nullptr;\\n		}\\n		return this->_v;\\n	}\\n};\\n\\ntemplate\\nclass LazyList {\\npublic:\\n	T head;\\n	std::shared_ptr> tail;\\n	LazyList(): head(T()) {} // only used in initializing Lazy...\\n	LazyList(T head, std::function thnk)\\n		: head(head), tail(std::make_shared>(thnk)) {}\\n	// default Copy/Move constructors and assignment operators seem to work well enough\\n	bool isEmpty() { return this->tail == nullptr; }\\n};\\n\\ntypedef std::shared_ptr PBI;\\ntypedef LazyList<PBI> LL;\\ntypedef std::function FLL2LL;\\n\\nLL merge(LL a, LL b) {\\n	auto ha = a.head; auto hb = b.head;\\n	if (*ha < *hb) {\\n		return LL(ha, [=]() { return merge(a.tail->value(), b); });\\n	} else {\\n		return LL(hb, [=]() { return merge(a, b.tail->value()); });\\n	}\\n}\\n\\nLL smult(int m, LL s) {\\n	const auto im = mpz_class(m);\\n	const auto psmlt =\\n			std::make_shared<FLL2LL>([](LL ss) { return ss; });\\n	*psmlt = [=](LL ss) {\\n		return LL(std::make_shared(*ss.head * im),\\n				  [=]() { return (*psmlt)(ss.tail->value()); });\\n	};\\n	return (*psmlt)(s); // worker wrapper pattern with recursive closure as worker...\\n}\\n\\nLL u(LL s, int n) {\\n	const auto r = std::make_shared<LL>(LL()); // interior mutable...\\n	*r = smult(n, LL(std::make_shared(1), [=]() { return *r; }));\\n	if (!s.isEmpty()) { *r = merge(s, *r); }\\n	return *r;\\n}\\n\\nLL hammings() {\\n	auto r = LL();\\n	for (auto pn : std::vector<int>({5, 3, 2})) {\\n		r = u(r, pn);\\n	}\\n	return LL(std::make_shared(1), [=]() { return r; });\\n}\\n\\nint main() {\\n	auto hmgs = hammings();\\n	for (auto i = 0; i < 20; ++i) {\\n		std::cout << *hmgs.head << \"" \"";\\n		hmgs = hmgs.tail->value();\\n	}\\n	std::cout << \""\\n\"";\\n\\n	hmgs = hammings();\\n	for (auto i = 1; i < 1691; ++i) hmgs = hmgs.tail->value();\\n	std::cout << *hmgs.head << \""\\n\"";\\n\\n	auto start = std::chrono::steady_clock::now();\\n	hmgs = hammings();\\n	for (auto i = 1; i < 1000000; ++i) hmgs = hmgs.tail->value();\\n	auto stop = std::chrono::steady_clock::now();\\n\\n	auto ms = std::chrono::duration_cast(stop - start);\\n	std::cout << *hmgs.head << \"" in \"" << ms.count() << \""milliseconds.\\n\"";\\n}"
"C++","Hamming_numbers","Hamming numbers are numbers of the form  \\nwhere\\nHamming numbers   are also known as   ugly numbers   and also   5-smooth numbers   (numbers whose prime divisors are less or equal to 5).\\n\\nGenerate the sequence of Hamming numbers, in increasing order.   In particular:\\n\\n\\n","#include <chrono>\\n#include <iostream>\\n#include <vector>\\n#include <gmpxx.h>\\n\\nclass Hammings {\\nprivate:\\n	const mpz_class _two = 2, _three = 3, _five = 5;\\n	std::vector _m = {}, _h = {1};\\n	mpz_class _x5 = 5, _x53 = 9, _mrg = 3, _x532 = 2;\\n	int _i = 1, _j = 0;\\npublic:\\n	Hammings() {_m.reserve(65536); _h.reserve(65536); };\\n	bool operator!=(const Hammings& other) const { return true; }\\n	Hammings begin() const { return *this; }\\n	Hammings end() const { return *this; }\\n	mpz_class operator*() { return _h.back(); }\\n	const Hammings& operator++() {\\n		if (_i > _h.capacity() / 2) {\\n			_h.erase(_h.begin(), _h.begin() + _i);\\n			_i = 0;\\n		}\\n		if (_x532 < _mrg) {\\n			_h.push_back(_x532);\\n			_x532 = _h[_i++] * _two;\\n		} else {\\n			_h.push_back(_mrg);\\n			if (_x53 < _x5) {\\n				_mrg = _x53;\\n				_x53 = _m[_j++] * _three;\\n			} else {\\n				_mrg = _x5;\\n				_x5 = _x5 * _five;\\n			}\\n			if (_j > _m.capacity() / 2) {\\n				_m.erase(_m.begin(), _m.begin() + _j);\\n				_j = 0;\\n			}\\n			_m.push_back(_mrg);\\n		}\\n		return *this;\\n	}\\n};\\n\\nint main() {\\n	auto cnt = 1;\\n	for (auto hmg : Hammings()) {\\n		if (cnt <= 20) std::cout << hmg << \"" \"";\\n		if (cnt == 20) std::cout << \""\\n\"";\\n		if (cnt++ >= 1691) {\\n			std::cout << hmg << \""\\n\"";\\n			break;\\n		}\\n	}\\n\\n	auto start = std::chrono::steady_clock::now();\\n	hmgs = hammings();\\n	auto&& hmgitr = Hammings();\\n	for (auto i = 1; i < 1000000; ++i) ++hmgitr;\\n	auto stop = std::chrono::steady_clock::now();\\n\\n	auto ms = std::chrono::duration_cast(stop - start);\\n	std::cout << *hmgitr << \"" in \"" << ms.count() << \""milliseconds.\\n\"";\\n}"
"C++","Handle_a_signal","Most operating systems provide interrupt facilities, sometimes called signals either generated by the user or as a result of program failure or reaching a limit like file space.\\nUnhandled signals generally terminate a program in a disorderly manner.\\nSignal handlers are created so that the program behaves in a well-defined manner upon receipt of a signal.\\nProvide a program that displays an integer on each line of output at the rate of about one per half second.\\nUpon receipt of the SIGINT signal (often generated by the user typing ctrl-C ( or better yet, SIGQUIT ctrl-\\ )) the program will cease outputting integers, output the number of seconds the program has run, and then the program will quit.\\n\\nSignal Handler\\nAda signal handlers must be defined at the library level.\\nThe following package defines a simple signal handler for the SigInt signal.\\nA signal may be received at any time in a program. Ada signal handling requires a task to suspend on an entry call for the handler which is executed only when the signal has been received. The following program uses the interrupt handler defined above to deal with receipt of SigInt.\\n","#include <chrono>\\n#include <csignal>\\n#include <ctime>\\n#include <iostream>\\n#include <thread>\\n\\nvolatile sig_atomic_t gotint = 0;\\n\\nvoid handler(int signum) {\\n	// Set a flag for handling the signal, as other methods like printf are not safe here\\n	gotint = 1;\\n}\\n\\nint main() {\\n	using namespace std;\\n\\n	signal(SIGINT, handler);\\n\\n	int i = 0;\\n	clock_t startTime = clock();\\n	while (true) {\\n		if (gotint) break;\\n		std::this_thread::sleep_for(std::chrono::milliseconds(500));\\n		if (gotint) break;\\n		cout << ++i << endl;\\n	}\\n	clock_t endTime = clock();\\n\\n	double dt = (endTime - startTime) / (double)CLOCKS_PER_SEC;\\n	cout << \""Program has run for \"" << dt << \"" seconds\"" << endl;\\n\\n	return 0;\\n}"
"C++","Happy_numbers","From Wikipedia, the free encyclopedia:\\nDisplay an example of your output here.\\n\\nFind and print the first 8 happy numbers.\\n\\n\\n","#include <map>\\n#include <set>\\n\\nbool happy(int number) {\\n  static std::map cache;\\n\\n  std::set<int> cycle;\\n  while (number != 1 && !cycle.count(number)) {\\n    if (cache.count(number)) {\\n      number = cache[number] ? 1 : 0;\\n      break;\\n    }\\n    cycle.insert(number);\\n    int newnumber = 0;\\n    while (number > 0) {\\n      int digit = number % 10;\\n      newnumber += digit * digit;\\n      number /= 10;\\n    }\\n    number = newnumber;\\n  }\\n  bool happiness = number == 1;\\n  for (std::set<int>::const_iterator it = cycle.begin();\\n       it != cycle.end(); it++)\\n    cache[*it] = happiness;\\n  return happiness;\\n}\\n\\n#include <iostream>\\n\\nint main() {\\n  for (int i = 1; i < 50; i++)\\n    if (happy(i))\\n      std::cout << i << std::endl;\\n  return 0;\\n}"
"C++","Happy_numbers","From Wikipedia, the free encyclopedia:\\nDisplay an example of your output here.\\n\\nFind and print the first 8 happy numbers.\\n\\n\\n","unsigned int happy_iteration(unsigned int n)\\n{\\n  unsigned int result = 0;\\n  while (n > 0)\\n  {\\n    unsigned int lastdig = n % 10;\\n    result += lastdig*lastdig;\\n    n /= 10;\\n  }\\n  return result;\\n}\\n\\nbool is_happy(unsigned int n)\\n{\\n  unsigned int n2 = happy_iteration(n);\\n  while (n != n2)\\n  {\\n    n = happy_iteration(n);\\n    n2 = happy_iteration(happy_iteration(n2));\\n  }\\n  return n == 1;\\n}\\n\\n#include <iostream>\\n\\nint main()\\n{\\n  unsigned int current_number = 1;\\n\\n  unsigned int happy_count = 0;\\n  while (happy_count != 8)\\n  {\\n    if (is_happy(current_number))\\n    {\\n      std::cout << current_number << \"" \"";\\n      ++happy_count;\\n    }\\n    ++current_number;\\n  }\\n  std::cout << std::endl;\\n}"
"C++","Harshad_or_Niven_series","The Harshad or Niven numbers are positive integers ≥ 1 that are divisible by the sum of their digits.\\nFor example,   42   is a Harshad number as   42   is divisible by   (4 + 2)   without remainder.\\nAssume that the series is defined as the numbers in increasing order.\\n\\nThe task is to create a function/method/procedure to generate successive members of the Harshad sequence.\\nUse it to list the first twenty members of the sequence and list the first Harshad number greater than 1000.\\nShow your output here.\\n\\n","#include <vector>\\n#include <iostream>\\n\\nint sumDigits ( int number ) {\\n   int sum = 0 ;\\n   while ( number != 0 ) {\\n      sum += number % 10 ;\\n      number /= 10 ;\\n   }\\n   return sum ;\\n}\\n\\nbool isHarshad ( int number ) {\\n   return number % ( sumDigits ( number ) ) == 0 ;\\n}\\n\\nint main( ) {\\n   std::vector<int> harshads ;\\n   int i = 0 ;\\n   while ( harshads.size( ) != 20 ) {\\n      i++ ;\\n      if ( isHarshad ( i ) ) \\n	 harshads.push_back( i ) ;\\n   }\\n   std::cout << \""The first 20 Harshad numbers:\\n\"" ;\\n   for ( int number : harshads )\\n      std::cout << number << \"" \"" ;\\n   std::cout << std::endl ;\\n   int start = 1001 ;\\n   while ( ! ( isHarshad ( start ) ) ) \\n      start++ ;\\n   std::cout << \""The smallest Harshad number greater than 1000 : \"" << start << '\\n' ;\\n   return 0 ;\\n}"
"C++","Hash_from_two_arrays","Using two Arrays of equal length, create a Hash object\\nwhere the elements from one array (the keys) are linked\\nto the elements of the other (the values)\\n\\n\\nAwk arrays are used for both lists and hash maps.\\n","#include \\n#include <string>\\n\\nint main()\\n{\\n  std::string keys[] = { \""1\"", \""2\"", \""3\"" };\\n  std::string vals[] = { \""a\"", \""b\"", \""c\"" };\\n \\n  std::unordered_map hash;\\n  for( int i = 0 ; i < 3 ; i++ )\\n     hash[ keys[i] ] = vals[i] ;\\n}"
"C++","Hash_from_two_arrays","Using two Arrays of equal length, create a Hash object\\nwhere the elements from one array (the keys) are linked\\nto the elements of the other (the values)\\n\\n\\nAwk arrays are used for both lists and hash maps.\\n","#include \\n#include \\n#include <string> \\n \\nint main()\\n{\\n  std::string keys[] = { \""1\"", \""2\"", \""3\"" };\\n  std::string vals[] = { \""foo\"", \""bar\"", \""baz\"" };\\n    \\n  std::unordered_map hash(ranges::view::zip(keys, vals));\\n}\\n"
"C++","Hash_join","An inner join is an operation that combines two data tables into one table, based on matching column values. The simplest way of implementing this operation is the nested loop join algorithm, but a more scalable alternative is the hash join algorithm.\\nImplement the \""hash join\"" algorithm, and demonstrate that it passes the test-case listed below.\\nYou should represent the tables as data structures that feel natural in your programming language.\\nThe \""hash join\"" algorithm consists of two steps:\\n\\nIn pseudo-code, the algorithm could be expressed as follows:\\nThe order of the rows in the output table is not significant.\\nIf you're using numerically indexed arrays to represent table rows (rather than referring to columns by name), you could represent the output rows in the form [[27, \""Jonah\""], [\""Jonah\"", \""Whales\""]].\\nNative AppleScript records lack introspection, but from Yosemite onwards we can read and write them a little more flexibly through the Foundation classes.\\nThe vertical bars distinguish AppleScript reserved words (name and character here) from field name literal strings.\\n","#include <iostream>\\n#include <string>\\n#include <vector>\\n#include \\n\\nusing tab_t = std::vector>;\\ntab_t tab1 {\\n// Age  Name\\n  {\""27\"", \""Jonah\""}\\n, {\""18\"", \""Alan\""}\\n, {\""28\"", \""Glory\""}\\n, {\""18\"", \""Popeye\""}\\n, {\""28\"", \""Alan\""}\\n};\\n\\ntab_t tab2 {\\n// Character  Nemesis\\n  {\""Jonah\"", \""Whales\""}\\n, {\""Jonah\"", \""Spiders\""}\\n, {\""Alan\"", \""Ghosts\""}\\n, {\""Alan\"", \""Zombies\""}\\n, {\""Glory\"", \""Buffy\""}\\n};\\n\\nstd::ostream& operator<<(std::ostream& o, const tab_t& t) {\\n  for(size_t i = 0; i < t.size(); ++i) {\\n    o << i << \"":\"";\\n    for(const auto& e : t[i]) \\n      o << '\\t' << e;\\n    o << std::endl;\\n  }\\n  return o;\\n}\\n\\ntab_t Join(const tab_t& a, size_t columna, const tab_t& b, size_t columnb) {\\n  std::unordered_multimap hashmap;\\n  // hash\\n  for(size_t i = 0; i < a.size(); ++i) {\\n    hashmap.insert(std::make_pair(a[i][columna], i));\\n  }\\n  // map\\n  tab_t result;\\n  for(size_t i = 0; i < b.size(); ++i) {\\n    auto range = hashmap.equal_range(b[i][columnb]);\\n    for(auto it = range.first; it != range.second; ++it) {\\n      tab_t::value_type row;\\n      row.insert(row.end() , a[it->second].begin() , a[it->second].end());\\n      row.insert(row.end() , b[i].begin()          , b[i].end());\\n      result.push_back(std::move(row));\\n    }\\n  }\\n  return result;\\n}\\n\\nint main(int argc, char const *argv[])\\n{\\n  using namespace std;\\n  int ret = 0;\\n  cout << \""Table A: \""       << endl << tab1 << endl;\\n  cout << \""Table B: \""       << endl << tab2 << endl;\\n  auto tab3 = Join(tab1, 1, tab2, 0);\\n  cout << \""Joined tables: \"" << endl << tab3 << endl;\\n  return ret;\\n}\\n\\n"
"C++","Haversine_formula","\\nThe haversine formula is an equation important in navigation, giving great-circle distances between two points on a sphere from their longitudes and latitudes.\\nIt is a special case of a more general formula in spherical trigonometry, the law of haversines, relating the sides and angles of spherical \""triangles\"".\\n\\nImplement a great-circle distance function, or use a library function,\\nto show the great-circle distance between:\\n\\nMost of the examples below adopted Kaimbridge's recommended value of\\n6372.8 km for the earth radius. However, the derivation of this\\nellipsoidal quadratic mean radius\\nis wrong (the averaging over azimuth is biased). When applying these\\nexamples in real applications, it is better to use the\\nmean earth radius,\\n6371 km. This value is recommended by the International Union of\\nGeodesy and Geophysics and it minimizes the RMS relative error between the\\ngreat circle and geodesic distance.\\n\\n","\\n#define _USE_MATH_DEFINES\\n\\n#include <math.h>\\n#include <iostream>\\n\\nconst static double EarthRadiusKm = 6372.8;\\n\\ninline double DegreeToRadian(double angle)\\n{\\n	return M_PI * angle / 180.0;\\n}\\n\\nclass Coordinate\\n{\\npublic:\\n	Coordinate(double latitude ,double longitude):myLatitude(latitude), myLongitude(longitude)\\n	{}\\n\\n	double Latitude() const\\n	{\\n		return myLatitude;\\n	}\\n\\n	double Longitude() const\\n	{\\n		return myLongitude;\\n	}\\n\\nprivate:\\n\\n	double myLatitude;\\n	double myLongitude;\\n};\\n\\ndouble HaversineDistance(const Coordinate& p1, const Coordinate& p2)\\n{\\n	double latRad1 = DegreeToRadian(p1.Latitude());\\n	double latRad2 = DegreeToRadian(p2.Latitude());\\n	double lonRad1 = DegreeToRadian(p1.Longitude());\\n	double lonRad2 = DegreeToRadian(p2.Longitude());\\n\\n	double diffLa = latRad2 - latRad1;\\n	double doffLo = lonRad2 - lonRad1;\\n\\n	double computation = asin(sqrt(sin(diffLa / 2) * sin(diffLa / 2) + cos(latRad1) * cos(latRad2) * sin(doffLo / 2) * sin(doffLo / 2)));\\n	return 2 * EarthRadiusKm * computation;\\n}\\n\\nint main()\\n{\\n	Coordinate c1(36.12, -86.67);\\n	Coordinate c2(33.94, -118.4);\\n\\n	std::cout << \""Distance = \"" << HaversineDistance(c1, c2) << std::endl;\\n	return 0;\\n}\\n"
"C++","Hello_world/Graphical","\\nDisplay the string       Goodbye, World!       on a GUI object   (alert box, plain window, text area, etc.).\\n\\n\\nThe code below is a gentle re-write (including a bug fix) of that in\\nthe Algol 68 Genie documentation.\\nThis solution requires no code blocks as the text is entered directly into the Title properties TextBox of the Designer.\\nVIEW THE DESIGNER\\nThis solution uses three blocks to assign the text to the Title bar:\\nScreen1.Initialize and\\nset Screen1.Title to \""Goodbye World!\""\\nVIEW THE BLOCKS AND ANDROID APP SCREEN\\nAwk has no GUI, but can execute system-commands.\\nE.g. the Windows-commandline provides a command for a messagebox, \\nsee below\\nat Batch_File\\nand UNIX_Shell.\\nThis example is almost identical to the TI-83 BASIC version.\\nUses HUG (High level Universal GUI) shipped in hug.bac\\nTo configure the \""Graphical screen\""\\nViewWindow parameters depend on the calculator resolution (These are the most common). \\nTo print text on the \""Graphical screen\"" of the calculator:\\nFrom Window 7 and later, pure Batch File does not completely provide GUI. However, MSHTA.EXE provides command-line JavaScript/VBScript access.\\nWhere hWnd is a valid window handle corresponding to a control in the application\\nOr simplest way:\\nAll Win32 APIs work in C++ the same way as they do in C. See the C example.\\nWhere pWnd is a pointer to a CWnd object corresponding to a valid window in the application.\\nThe following are in the Managed COBOL dialect.\\ngui.xaml.cbl:\\ngui.xaml:\\nThe program gets the lines and columns of the screen and positions the text in the middle. Program waits for a return key.\\nThis can be done using the extension package ltk that provides an interface to the Tk library.\\nThis can also be done using the CLIM 2.0 specification. The following code runs on both SBCL and the LispWorks\\nIDE:\\n(This works entered into the interactive shell):\\nThis is a complete application. If it were part of a larger application, the portions related to interp would be removed.\\nMessageBox:\\nLabel:\\nTitled Form + Surface Output:\\nELENA 3.3 :\\nAllows entry of any name into a text field (using \""World\"" as the default entry). Then, when the \""Say Goodbye\"" button is pressed, sets a text label to the value \""Goodbye, <name>!\"".\\n\\nJust display the text in a message box.\\nTo be pasted in the listener :\\nAlternative:\\nHere are solutions for Microsoft Windows, using the MessageBox API function. Both programs use modules provided by the compiler vendor.\\nCompile with af90 hello.f90 user32.lib or for a 64-bit executable af90 -i8 -m64 hello.f90 user32.lib.\\nCompile with ifort hello.f90.\\nUsing gtk-fortran library\\nCompile with\\ngfortran gtk2_mini.f90 -o gtk2_mini.x `pkg-config --cflags --libs gtk-2-fortran`\\nGraphics Mode\\nWindows API\\nThis brings up an infinitely-rescalable graphic window containing \""Goodbye, World\"" drawn graphically.\\nAll Frink graphics can be written to arbitrary coordinates; Frink will automatically scale and center any drawn graphics to be visible in the window (greatly simplifying programming,) so the exact coordinates used below are rather arbitrary. (This means that if you wrote \""Hello World\"" instead of \""Goodbye, World\"", you could just change that string and everything would still center perfectly.)\\nThe graphics are infinitely-scalable and can be rendered at full quality to any resolution. This program \""shows off\"" by rotating the text by 10 degrees, and also rendering it to a printer (which can include tiling across multiple pages) and rendering to a graphics file. (Frink can automatically render the same graphics object to many image formats, including PNG, JPG, SVG, HTML5 canvas, animated GIF, bitmapped image in memory, and more.)\\nHere we display the message on the system notepad:\\nRun in GHCi interpreter:\\nWith an alert box:\\nBy drawing directly to the screen:\\ngraphics is required \\n40×40 isn't great resolution, but it's enough!\\nUsing Java 8 lambdas syntax:\\nIn the following, which generates SVG in a way that can be readily viewed using a web browser, the \""Goodbye, World!\"" text is shaded using a linear gradient.\\nThe approach used here to generate SVG is based on these principles:\\nPart 1: Generic SVG-related functions\\nPart 2: \""Goodbye, World!\""\\n","#include <gtkmm.h>\\nint main(int argc, char *argv[])\\n{\\n   Gtk::Main app(argc, argv);\\n   Gtk::MessageDialog msg(\""Goodbye, World!\"");\\n   msg.run();\\n}"
"C++","Hello_world/Graphical","\\nDisplay the string       Goodbye, World!       on a GUI object   (alert box, plain window, text area, etc.).\\n\\n\\nThe code below is a gentle re-write (including a bug fix) of that in\\nthe Algol 68 Genie documentation.\\nThis solution requires no code blocks as the text is entered directly into the Title properties TextBox of the Designer.\\nVIEW THE DESIGNER\\nThis solution uses three blocks to assign the text to the Title bar:\\nScreen1.Initialize and\\nset Screen1.Title to \""Goodbye World!\""\\nVIEW THE BLOCKS AND ANDROID APP SCREEN\\nAwk has no GUI, but can execute system-commands.\\nE.g. the Windows-commandline provides a command for a messagebox, \\nsee below\\nat Batch_File\\nand UNIX_Shell.\\nThis example is almost identical to the TI-83 BASIC version.\\nUses HUG (High level Universal GUI) shipped in hug.bac\\nTo configure the \""Graphical screen\""\\nViewWindow parameters depend on the calculator resolution (These are the most common). \\nTo print text on the \""Graphical screen\"" of the calculator:\\nFrom Window 7 and later, pure Batch File does not completely provide GUI. However, MSHTA.EXE provides command-line JavaScript/VBScript access.\\nWhere hWnd is a valid window handle corresponding to a control in the application\\nOr simplest way:\\nAll Win32 APIs work in C++ the same way as they do in C. See the C example.\\nWhere pWnd is a pointer to a CWnd object corresponding to a valid window in the application.\\nThe following are in the Managed COBOL dialect.\\ngui.xaml.cbl:\\ngui.xaml:\\nThe program gets the lines and columns of the screen and positions the text in the middle. Program waits for a return key.\\nThis can be done using the extension package ltk that provides an interface to the Tk library.\\nThis can also be done using the CLIM 2.0 specification. The following code runs on both SBCL and the LispWorks\\nIDE:\\n(This works entered into the interactive shell):\\nThis is a complete application. If it were part of a larger application, the portions related to interp would be removed.\\nMessageBox:\\nLabel:\\nTitled Form + Surface Output:\\nELENA 3.3 :\\nAllows entry of any name into a text field (using \""World\"" as the default entry). Then, when the \""Say Goodbye\"" button is pressed, sets a text label to the value \""Goodbye, <name>!\"".\\n\\nJust display the text in a message box.\\nTo be pasted in the listener :\\nAlternative:\\nHere are solutions for Microsoft Windows, using the MessageBox API function. Both programs use modules provided by the compiler vendor.\\nCompile with af90 hello.f90 user32.lib or for a 64-bit executable af90 -i8 -m64 hello.f90 user32.lib.\\nCompile with ifort hello.f90.\\nUsing gtk-fortran library\\nCompile with\\ngfortran gtk2_mini.f90 -o gtk2_mini.x `pkg-config --cflags --libs gtk-2-fortran`\\nGraphics Mode\\nWindows API\\nThis brings up an infinitely-rescalable graphic window containing \""Goodbye, World\"" drawn graphically.\\nAll Frink graphics can be written to arbitrary coordinates; Frink will automatically scale and center any drawn graphics to be visible in the window (greatly simplifying programming,) so the exact coordinates used below are rather arbitrary. (This means that if you wrote \""Hello World\"" instead of \""Goodbye, World\"", you could just change that string and everything would still center perfectly.)\\nThe graphics are infinitely-scalable and can be rendered at full quality to any resolution. This program \""shows off\"" by rotating the text by 10 degrees, and also rendering it to a printer (which can include tiling across multiple pages) and rendering to a graphics file. (Frink can automatically render the same graphics object to many image formats, including PNG, JPG, SVG, HTML5 canvas, animated GIF, bitmapped image in memory, and more.)\\nHere we display the message on the system notepad:\\nRun in GHCi interpreter:\\nWith an alert box:\\nBy drawing directly to the screen:\\ngraphics is required \\n40×40 isn't great resolution, but it's enough!\\nUsing Java 8 lambdas syntax:\\nIn the following, which generates SVG in a way that can be readily viewed using a web browser, the \""Goodbye, World!\"" text is shaded using a linear gradient.\\nThe approach used here to generate SVG is based on these principles:\\nPart 1: Generic SVG-related functions\\nPart 2: \""Goodbye, World!\""\\n","#include \""afx.h\""\\nvoid ShowGoodbyeWorld(CWnd* pWnd)\\n{\\n    pWnd->SetWindowText(_T(\""Goodbye, World!\""));\\n}"
"C++","Hello_world/Graphical","\\nDisplay the string       Goodbye, World!       on a GUI object   (alert box, plain window, text area, etc.).\\n\\n\\nThe code below is a gentle re-write (including a bug fix) of that in\\nthe Algol 68 Genie documentation.\\nThis solution requires no code blocks as the text is entered directly into the Title properties TextBox of the Designer.\\nVIEW THE DESIGNER\\nThis solution uses three blocks to assign the text to the Title bar:\\nScreen1.Initialize and\\nset Screen1.Title to \""Goodbye World!\""\\nVIEW THE BLOCKS AND ANDROID APP SCREEN\\nAwk has no GUI, but can execute system-commands.\\nE.g. the Windows-commandline provides a command for a messagebox, \\nsee below\\nat Batch_File\\nand UNIX_Shell.\\nThis example is almost identical to the TI-83 BASIC version.\\nUses HUG (High level Universal GUI) shipped in hug.bac\\nTo configure the \""Graphical screen\""\\nViewWindow parameters depend on the calculator resolution (These are the most common). \\nTo print text on the \""Graphical screen\"" of the calculator:\\nFrom Window 7 and later, pure Batch File does not completely provide GUI. However, MSHTA.EXE provides command-line JavaScript/VBScript access.\\nWhere hWnd is a valid window handle corresponding to a control in the application\\nOr simplest way:\\nAll Win32 APIs work in C++ the same way as they do in C. See the C example.\\nWhere pWnd is a pointer to a CWnd object corresponding to a valid window in the application.\\nThe following are in the Managed COBOL dialect.\\ngui.xaml.cbl:\\ngui.xaml:\\nThe program gets the lines and columns of the screen and positions the text in the middle. Program waits for a return key.\\nThis can be done using the extension package ltk that provides an interface to the Tk library.\\nThis can also be done using the CLIM 2.0 specification. The following code runs on both SBCL and the LispWorks\\nIDE:\\n(This works entered into the interactive shell):\\nThis is a complete application. If it were part of a larger application, the portions related to interp would be removed.\\nMessageBox:\\nLabel:\\nTitled Form + Surface Output:\\nELENA 3.3 :\\nAllows entry of any name into a text field (using \""World\"" as the default entry). Then, when the \""Say Goodbye\"" button is pressed, sets a text label to the value \""Goodbye, <name>!\"".\\n\\nJust display the text in a message box.\\nTo be pasted in the listener :\\nAlternative:\\nHere are solutions for Microsoft Windows, using the MessageBox API function. Both programs use modules provided by the compiler vendor.\\nCompile with af90 hello.f90 user32.lib or for a 64-bit executable af90 -i8 -m64 hello.f90 user32.lib.\\nCompile with ifort hello.f90.\\nUsing gtk-fortran library\\nCompile with\\ngfortran gtk2_mini.f90 -o gtk2_mini.x `pkg-config --cflags --libs gtk-2-fortran`\\nGraphics Mode\\nWindows API\\nThis brings up an infinitely-rescalable graphic window containing \""Goodbye, World\"" drawn graphically.\\nAll Frink graphics can be written to arbitrary coordinates; Frink will automatically scale and center any drawn graphics to be visible in the window (greatly simplifying programming,) so the exact coordinates used below are rather arbitrary. (This means that if you wrote \""Hello World\"" instead of \""Goodbye, World\"", you could just change that string and everything would still center perfectly.)\\nThe graphics are infinitely-scalable and can be rendered at full quality to any resolution. This program \""shows off\"" by rotating the text by 10 degrees, and also rendering it to a printer (which can include tiling across multiple pages) and rendering to a graphics file. (Frink can automatically render the same graphics object to many image formats, including PNG, JPG, SVG, HTML5 canvas, animated GIF, bitmapped image in memory, and more.)\\nHere we display the message on the system notepad:\\nRun in GHCi interpreter:\\nWith an alert box:\\nBy drawing directly to the screen:\\ngraphics is required \\n40×40 isn't great resolution, but it's enough!\\nUsing Java 8 lambdas syntax:\\nIn the following, which generates SVG in a way that can be readily viewed using a web browser, the \""Goodbye, World!\"" text is shaded using a linear gradient.\\nThe approach used here to generate SVG is based on these principles:\\nPart 1: Generic SVG-related functions\\nPart 2: \""Goodbye, World!\""\\n","\\n#include \\n#include \\n#include \\n\\nint main(int argc, char **argv) {\\n  Fl_Window *window = new Fl_Window(300,180);\\n  Fl_Box *box = new Fl_Box(20,40,260,100,\""Goodbye, World!\"");\\n  box->box(FL_UP_BOX);\\n  box->labelsize(36);\\n  box->labelfont(FL_BOLD+FL_ITALIC);\\n  box->labeltype(FL_SHADOW_LABEL);\\n  window->end();\\n  window->show(argc, argv);\\n  return Fl::run();\\n}\\n"
"C++","Hello_world/Line_printer","Cause a line printer attached to the computer to print a line containing the message:    Hello World! \\n\\nA line printer is not the same as standard output.\\nA   line printer   was an older-style printer which prints one line at a time to a continuous ream of paper.\\nWith some systems, a line printer can be any device attached to an appropriate port (such as a parallel port).\\n\\nAssuming that the line printer is attached to /dev/lp0\\nThis task is VERY system and hardware dependent. The code below works\\nwith Algol 68 Genie and a Linux system without /dev/lp0 but with a\\nremote printer interfaced via CUPS. Extending it to other\\nenvironments is left as an exercise for the reader.\\n","#include <iostream>\\n#include <fstream>\\n\\nint main(){\\n  std::ofstream lprFile;\\n  lprFile.open( \""/dev/lp0\"" );\\n  lprFile << \""Hello World!\\n\"";\\n  lprFile.close();\\n  return 0;\\n}"
"C++","Hello_world/Newbie","Guide a new user of a language through the steps necessary\\nto install the programming language and selection of a text editor if needed,\\nto run the languages' example in the Hello world/Text task.\\n\\n\\nFor information on installing and using algol68g, read Learning ALGOL 68 Genie by Marcel van der Veer.\\nWhile algol68g is available for Mac OS X, this example currently does not provide instructions on running the \""Hello, World\"" program on OS X.\\n1. Download algol68g.\\n2. Install algol68g on Linux, or unzip it to a convenient location on Windows.\\n3. Use your favorite text editor.\\n4. Save the file with the extension .a68.\\n5. Open a command prompt/terminal. Execute \""a68g path/to/file/filename.a68\"" on Linux, or \""path/to/a68g/a68g.exe path/to/file/filename.a68\"" on Windows.\\nReplace the paths above with their corresponding paths on your system.\\nThe output will appear in the command prompt/terminal.\\n{\\nThe Tutorial and Overview, which is part of the AutoHotkey Documentation,\\ncovers the basics of AutoHotkey.\\nThe documentation is available online and is included as a .chm help file\\nwith installation. Installation and \""Hello World\"" are summarized here.\\n1) Download and install AutoHotkey.\\n2) Download and install the SciTE4AutoHotkey editor (recommended), or use your favorite texteditor.\\n4) Save the file with the extension .ahk.\\n5) Double-click the file to launch it. A message box appears displaying \""Hello World!\"" and an icon appears in the taskbar notification area.\\n6) To exit or edit the script, right-click the green \""H\"" icon in the taskbar notification area. Closing the message box will also exit this particular script.\\nAWK is a standard tool in Unix / most Linux-distributions.\\nSo, it should be already installed. \\nTo run awk, either provide code on shell (using single quotes).\\nOr put code to file and load it from file.\\nSelect one of the awk-implementations to download.\\nE.g. gnuwin32.sourceforge.net provides gawk, mawk and nawk. \\nThe most current gawk is at gnu.org, but only as source. \\nTo get a ready-made executable, look at code.google.com - gawk v4.1.0 currently.\\nDownload, extract the executable file and \""install\"" it.\\nIn most cases, installation can be done by just\\nmoving that exe-file to a convincent place,\\ne.g. a directory that is already in the PATH.\\nOtherwise, the PATH can be changed in the Windows-Systemsettings,\\nunder environment-variables.\\nAlternatively, keep the awk-program in the same directory\\nas the scripts you are going to write / run.\\nTry to run it, from a commandline:\\nor\\nor\\nto display its version-number.\\nTo do a simple calculation, try a one-liner like this:\\nNote the use of double-quotes, and curly-braces. \\nUsing the windows-commandline, single-quotes cannot be used.\\nThat means one-liners using strings need awkward quoting:\\nAs a workaround, you can assign variables just before the script:\\nSo in most cases, running scripts from files is easier.\\nWhere hello.awk contains\\n","#include <iostream>\\nint main() {\\n    using namespace std;\\n    cout << \""Hello, World!\"" << endl;\\n    return 0;\\n}"
"C++","Hello_world/Newline_omission","Some languages automatically insert a newline after outputting a string, unless measures are taken to prevent its output.\\n\\nDisplay the string   Goodbye, World!   without a trailing newline.\\n\\n\\nThis example will implicitly include a final, implementation defined, terminator (usually a linefeed) if the output is a file (RM A.10.7-8) such as stdout on UNIX systems.\\nUsing Ada.Text_IO.Text_Streams instead allows us to control the termination.\\nThis works with Algol68 Genie 2.8.2 and above. Earlier versions appended a gratuitous newline on unflushed output when the program terminated.\\nBaCon supports BASIC PRINT ending with trailing semicolon to prevent a newline and also supports a FORMAT clause that uses printf specifications and special character escapes (with no \\n, there is no newline).\\nOutput:\\nOutput all on a single line.\\nUnder normal circumstances, when delayed expansion is disabled\\nThe quoted form guarantees there are no hidden trailing spaces after World!\\nIf delayed expansion is enabled, then the ! must be escaped\\nEscape once if quoted form, twice if unquoted.\\nbeeswax prints everything without appending a newline character. beeswax has an instruction to explicitely print a newline character: N.\\nIn Befunge, a newline has to be explicitly output when required, so you can just not include one if it's not wanted.\\nOne option was to copy the code from the regular Hello World version and omit the last period, but one of the nicer things about the language is that no matter how simple your program is, if it's more than a few characters long, it's probably unique. So here's yet another version of Goodbye, World in Brainf***.\\nIn C, we do not get a newline unless we embed one:\\nHowever ISO C leaves it up to implementations to define whether or not the last line of a text stream requires a new-line. This means that the C can be targetted to environments where this task is impossible to implement, at least with a direct text stream manipulation like this.\\nNode JS:\\nOne Line version:\\nGoodbye World Program:\\nELENA 3.4:\\n\\nOutput:\\nIn erlang a newline must be specified in the format string.\\nWith the print() function:\\nOr via \""fast print\"":\\nFOCAL does not insert a newline unless we specifically request one.\\nThe \""advance\"" facility was introduced with F90, as was the ability to specify format instructions (the '(A)' part) without a separate FORMAT statement. Earlier, there was a common extension:\\nIn this, the FORMAT instruction is to accept alphabetic text (the A) from the WRITE statement, followed by the special $ item (of no mnemonic form) which signified that there was not to be any new line action at the end of the output. This sort of thing is useful when writing a prompt to the screen so that the input of the response appears on the same screen line. The text could also have been incorporated into the FORMAT statement, which would be useful if there were many WRITE statements scattered about that were to send forth the same text.\\nThese facilities only became of interest when, instead of card decks and lineprinters, I/O involved a keyboard and screen with both input and output appearing on the same screen. Thus, in earlier Fortran usage, the issue would not arise for output to a lineprinter, because it was already the case: a line written to the lineprinter was not followed by a end-of-line/start-new-line sort of action by the lineprinter. It stayed put on the line just written. It was the following output to the lineprinter that would state \""advance one\"" (or two, or, no) lines at the start of its output. This was the \""carriage control character\"", and a 1 signified \""skip to top-of-form\"" which is to say, start a new page.\\nIn other words, the Fortran approach for output was <carriage control><output text> rather than the <output text><carriage control> sequence, that now has to be suppressed by the \""advance = 'no'\"" facility.\\nClick this link to run this code\\nOutput:\\nIn Graphical User Interface Support Script, we specify a newline, if we want one. The following will not produce a newline:\\nNative output in Icon and Unicon is performed via the write and writes procedures. The write procedure terminates each line with both a return and newline (for consistency across platforms). The writes procedure omits this. Additionally, the programming library has a series of printf procedures as well.\\nOn a linux system, you can use 1!:3 because stdout is a file:\\nHowever, J works in environments other than Linux, so...\\nSolution:prompt from the misc package.\\nNotes: J programs are normally run from a REPL, or session manager, which comes in several flavors. The traditional commandline-based terminal (jconsole), one of several desktop applications (jqt for the current version of J, jgtk and jwd for older but still supported versions), a web-based frontend (jhs), and various mobile apps (J for iOS, Android).\\nThe specific session manager being used changes the context and therefore answer to this task. For example, when using J from a browser (including mobile browsers) newlines are omitted by default. Further, J provides strong tools for coalescing results and manipulating them prior to output, so newline elimination would typically happen before output rather than after.\\nWith that said, prompt handles the most common cases (using binary output for jconsole, so no newline is appended; adjusting the REPL prompt in the desktop apps to to elide the newline which is normally included by default, etc).\\nFor truly automated processes, you'd almost always want this kind of functionality (omitting the newline when printing) in a file- or stream-oriented application. For those cases, the simple text 1!:3 file will append the text to the referenced file verbatim, without inserting any extra newlines.\\nSo, if a J programmer were asked to solve this task, the right approach would be to ask why that is needed, and then craft a solution appropriate to that situation.\\nNode JS:\\nThe \""-j\"" command-line option suppresses the newline that would otherwise be printed, e.g. if \""$\"" is the command-line prompt:\\nThe trailing \""$\"" is the command-line prompt.\\nSimilarly:\\nEvaluated from the command line as:\\n","#include <iostream>\\n\\nint main() {\\n  std::cout << \""Goodbye, World!\"";\\n  return 0;\\n}"
"C++","Hello_world/Standard_error","A common practice in computing is to send error messages\\nto a different output stream than normal text console messages.\\nThe normal messages print to what is called \""standard output\"" or \""standard out\"".\\nThe error messages print to \""standard error\"".\\nThis separation can be used to redirect error messages to a different place than normal messages.\\n\\nShow how to print a message to standard error by printing     Goodbye, World!     on that stream.\\n\\nThe procedures print and printf output to stand out,\\nwhereas put and putf can output to any open file, including stand error.\\n","#include <iostream>\\n\\nint main() {\\n  std::cerr << \""Goodbye, World!\\n\"";\\n}"
"C++","Hello_world/Text","Display the string Hello world! on a text console.\\n\\nUsing native SVC (Supervisor Call) to write to system console:\\nUsing WTO Macro to generate SVC 35 and message area:\\nWith A86 or NASM syntax:\\nor:\\nNote, that \""Hello, World!\"" prints twice in interactive mode.\\nOne time as side-effect and one as the return value of echo.\\nTo show in Script Editor Result pane:\\nTo show in Script Editor Event Log pane:\\nImportant Note: Although Applesoft BASIC allowed the storage and output of mixed-case strings, the ability to enter mixed-case via the keyboard and to output mixed-case on the default display was not offered as standard equipment on the original Apple II/II+. Since Applesoft WAS the default programming language for the Apple II+, perhaps some flexibility in the task specification could be offered, for this and for other systems that lacked proper mixed-case I/O capabilities in at least one popular configuration.\\ncompile with: arc hello_world.arg -o hello_world.c && gcc -o hello_world hello_world.c\\nscript launched from windows explorer\\nscripts run from shell\\n[requires Windows XP or higher; older Versions of Windows don´t have the \""AttachConsole\"" function]\\n\\n\""BEGIN\"" is a \""special pattern\"" - code within \""{}\"" is executed before the input file is read, even if there is no input. \""END\"" is a similar pattern, for after completion of main processing.\\nFor a file containing data, the work can be done in the \""body\"". The \""//\"" is \""match anything\"" so gets the first data, the \""exit\"" halts processing the file (any \""END\"" would then be executed). Or instead of //, simply 1 is true.\\n\\nFor a \""single record\"" file.\\nFor a \""single record\"" file containing - Hello world! -. The \""default\"" action for a \""pattern match\"" (the \""/\"" and \""/\"" define a \""pattern\"" to match data) is to \""print\"" the record.\\nNote that the i here is the imaginary i, not the lowercase letter i.\\nor just\\nUnder normal circumstances, when delayed expansion is disabled\\nIf delayed expansion is enabled, then the ! must be escaped twice\\nStraightforward:\\nLess obvious way:\\nEven less obvious, demonstrating the creation and execution order of instruction pointers, and the hexagonal layout of beeswax programs:\\nTo print text, we need the ascii-value of each character to output.\\nSo, we wanna make a series of round numbers going like:\\nforming all the letters we need if we just add up a bit\\nCommented version:\\nUncommented:\\nIt can most likely be optimized, but this is a nice way to show\\nhow character printing works in Brainf*** :)\\nThe mged utility can output text to the terminal:\\nAlthough please note that sh actually does not print anything.\\nOr:\\nOr, the eternal favourite :)\\nor better yet...\\n","#include <iostream>\\n\\nint main () {\\n  std::cout << \""Hello world!\"" << std::endl;\\n}"
"C++","Here_document","A   here document   (or \""heredoc\"")   is a way of specifying a text block, preserving the line breaks, indentation and other whitespace within the text.\\nDepending on the language being used, a   here document   is constructed using a command followed by \""<<\"" (or some other symbol) followed by a token string.\\nThe text block will then start on the next line, and will be followed by the chosen token at the beginning of the following line, which is used to mark the end of the text block.\\n\\nDemonstrate the use of   here documents   within the language.\\n\\n\\nMultiline strings are simply parsed using \""quote\"", which parses first a character to use as a separator, and scans until that character is found:\\n","#include <iostream> // Only for cout to demonstrate\\n\\nint main()\\n{\\n  std::cout <<\\nR\""EOF(  A  raw  string  begins  with  R,  then a double-quote (\""),  then an optional\\nidentifier (here I've used \""EOF\""),  then an opening parenthesis ('(').  If you\\nuse  an  identifier,  it  cannot  be longer than 16 characters,  and it cannot\\ncontain a space,  either opening or closing parentheses, a backslash, a tab, a\\nvertical tab, a form feed, or a newline.\\n\\n  It  ends with a closing parenthesis (')'),  the identifer (if you used one),\\nand a double-quote.\\n\\n  All  characters are okay in a raw string,  no escape sequences are necessary\\nor recognized, and all whitespace is preserved.\\n)EOF\"";\\n}"
"C++","Heronian_triangles","Hero's formula for the area of a triangle given the length of its three sides    a,   b,   and   c   is given by:\\nwhere   s   is half the perimeter of the triangle; that is,\\n\\nHeronian triangles\\nare triangles whose sides and area are all integers.\\n\\nNote that any triangle whose sides are all an integer multiple of   3, 4, 5;   such as   6, 8, 10,   will also be a Heronian triangle.\\nDefine a Primitive Heronian triangle as a Heronian triangle where the greatest common divisor\\nof all three sides is   1   (unity).\\nThis will exclude, for example, triangle   6, 8, 10.\\n\\n\\nShow all output here.\\nNote: when generating triangles it may help to restrict \\n\\n\\n\\na\\n<=\\nb\\n<=\\nc\\n\\n\\n{\\displaystyle a<=b<=c}\\n\\n\\n\\n","#include <algorithm>\\n#include <cmath>\\n#include <iostream>\\n#include <tuple>\\n#include <vector>\\n\\nint gcd(int a, int b)\\n{\\n    int rem = 1, dividend, divisor;\\n    std::tie(divisor, dividend) = std::minmax(a, b);\\n    while (rem != 0) {\\n        rem = dividend % divisor;\\n        if (rem != 0) {\\n            dividend = divisor;\\n            divisor = rem;\\n        }\\n    }\\n    return divisor;\\n}\\n\\nstruct Triangle\\n{\\n    int a;\\n    int b;\\n    int c;\\n};\\n\\nint perimeter(const Triangle& triangle)\\n{\\n    return triangle.a + triangle.b + triangle.c;\\n}\\n\\ndouble area(const Triangle& t)\\n{\\n    double p_2 = perimeter(t) / 2.;\\n    double area_sq = p_2 * ( p_2 - t.a ) * ( p_2 - t.b ) * ( p_2 - t.c );\\n    return sqrt(area_sq);\\n}\\n\\nstd::vector<Triangle> generate_triangles(int side_limit = 200)\\n{\\n    std::vector<Triangle> result;\\n    for(int a = 1; a <= side_limit; ++a)\\n        for(int b = 1; b <= a; ++b)\\n            for(int c = a+1-b; c <= b; ++c) // skip too-small values of c, which will violate triangle inequality\\n            {\\n                Triangle t{a, b, c};\\n                double t_area = area(t);\\n                if(t_area == 0) continue;\\n                if( std::floor(t_area) == std::ceil(t_area) && gcd(a, gcd(b, c)) == 1)\\n                    result.push_back(t);\\n            }\\n    return result;\\n}\\n\\nbool compare(const Triangle& lhs, const Triangle& rhs)\\n{\\n    return std::make_tuple(area(lhs), perimeter(lhs), std::max(lhs.a, std::max(lhs.b, lhs.c))) <\\n           std::make_tuple(area(rhs), perimeter(rhs), std::max(rhs.a, std::max(rhs.b, rhs.c)));\\n}\\n\\nstruct area_compare\\n{\\n    bool operator()(const Triangle& t, int i) { return area(t) < i; }\\n    bool operator()(int i, const Triangle& t) { return i < area(t); }\\n};\\n\\nint main()\\n{\\n    auto tri = generate_triangles();\\n    std::cout << \""There are \"" << tri.size() << \"" primitive Heronian triangles with sides up to 200\\n\\n\"";\\n\\n    std::cout << \""First ten when ordered by increasing area, then perimeter, then maximum sides:\\n\"";\\n    std::sort(tri.begin(), tri.end(), compare);\\n    std::cout << \""area\\tperimeter\\tsides\\n\"";\\n    for(int i = 0; i < 10; ++i)\\n        std::cout << area(tri[i]) << '\\t' << perimeter(tri[i]) << \""\\t\\t\"" <<\\n                     tri[i].a << 'x' << tri[i].b << 'x' << tri[i].c << '\\n';\\n\\n    std::cout << \""\\nAll with area 210 subject to the previous ordering:\\n\"";\\n    auto range = std::equal_range(tri.begin(), tri.end(), 210, area_compare());\\n    std::cout << \""area\\tperimeter\\tsides\\n\"";\\n    for(auto it = range.first; it != range.second; ++it)\\n        std::cout << area(*it) << '\\t' << perimeter(*it) << \""\\t\\t\"" <<\\n                     it->a << 'x' << it->b << 'x' << it->c << '\\n';\\n}"
"C++","Hickerson_series_of_almost_integers","The following function, due to D Hickerson, is said to generate \""Almost integers\"" by the \""Almost Integer\"" page of Wolfram Mathworld. (December 31 2013).\\nThe function is:\\nIt is said to produce \""almost integers\"" for n between 1 and 17.\\nThe purpose of the task is to verify this assertion.\\nAssume that an \""almost integer\"" has either a nine or a zero as its first digit after the decimal point of its decimal string representation\\nThe task is to calculate all values of the function checking and stating which are \""almost integers\"".\\nNote: Use extended/arbitrary precision numbers in your calculation if necessary to ensure you have adequate precision of results as for example:\\n","#include <iostream>\\n#include <iomanip>\\n#include \\n#include \\ntypedef boost::multiprecision::cpp_dec_float_50 decfloat;\\n\\nint main()\\n{\\n    const decfloat ln_two = boost::math::constants::ln_two<decfloat>();\\n    decfloat numerator = 1, denominator = ln_two;\\n    \\n    for(int n = 1; n <= 17; n++) {\\n        decfloat h = (numerator *= n) / (denominator *= ln_two) / 2;\\n        decfloat tenths_dig = floor((h - floor(h)) * 10);\\n        std::cout << \""h(\"" << std::setw(2) << n << \"") = \"" << std::setw(25) << std::fixed << h << \\n            (tenths_dig == 0 || tenths_dig == 9 ? \"" is \"" : \"" is NOT \"") << \""an almost-integer.\\n\"";\\n    }\\n}\\n"
"C++","Higher-order_functions","Pass a function as an argument to another function.\\n\\n\\n","\\n// Use <functional> for C++11\\n#include \\n#include <iostream>\\n\\nusing namespace std;\\nusing namespace std::tr1;\\n\\nvoid first(function f)\\n{\\n  f();\\n}\\n\\nvoid second()\\n{\\n  cout << \""second\\n\"";\\n}\\n\\nint main()\\n{\\n  first(second);\\n}\\n"
"C++","Higher-order_functions","Pass a function as an argument to another function.\\n\\n\\n","#include <iostream>\\n#include <functional>\\n\\ntemplate\\ntypename Func::result_type first(Func func, typename Func::argument_type arg)\\n{\\n  return func(arg);\\n}\\n\\nclass second : public std::unary_function\\n{\\npublic:\\n  result_type operator()(argument_type arg) const\\n  {\\n    return arg * arg;\\n  }\\n};\\n\\nint main()\\n{\\n  std::cout << first(second(), 2) << std::endl;\\n  return 0;\\n}"
"C++","Hofstadter_Figure-Figure_sequences","These two sequences of positive integers are defined as:\\n\\nThe sequence \\n\\n\\n\\nS\\n(\\nn\\n)\\n\\n\\n{\\displaystyle S(n)}\\n\\n is further defined as the sequence of positive integers not present in \\n\\n\\n\\nR\\n(\\nn\\n)\\n\\n\\n{\\displaystyle R(n)}\\n\\n.\\nSequence \\n\\n\\n\\nR\\n\\n\\n{\\displaystyle R}\\n\\n starts:\\nSequence \\n\\n\\n\\nS\\n\\n\\n{\\displaystyle S}\\n\\n starts:\\n\\n\\n\\nSpecifying a package providing the functions FFR and FFS:\\nThe implementation of the package internally uses functions which generate an array of Figures or Spaces:\\nFinally, a test program for the package, solving the task at hand:\\nThe output of the test program:\\n","#include <iomanip>\\n#include <iostream>\\n#include <set>\\n#include <vector>\\n\\nusing namespace std;\\n\\nunsigned hofstadter(unsigned rlistSize, unsigned slistSize)\\n{\\n    auto n = rlistSize > slistSize ? rlistSize : slistSize;\\n    auto rlist = new vector<unsigned> { 1, 3, 7 };\\n    auto slist = new vector<unsigned> { 2, 4, 5, 6 };\\n    auto list = rlistSize > 0 ? rlist : slist;\\n    auto target_size = rlistSize > 0 ? rlistSize : slistSize;\\n\\n    while (list->size() > target_size) list->pop_back();\\n\\n    while (list->size() < target_size)\\n    {\\n        auto lastIndex = rlist->size() - 1;\\n        auto lastr = (*rlist)[lastIndex];\\n        auto r = lastr + (*slist)[lastIndex];\\n        rlist->push_back(r);\\n        for (auto s = lastr + 1; s < r && list->size() < target_size;)\\n            slist->push_back(s++);\\n    }\\n\\n    auto v = (*list)[n - 1];\\n    delete rlist;\\n    delete slist;\\n    return v;\\n}\\n\\nostream& operator<<(ostream& os, const set<unsigned>& s)\\n{\\n    cout << '(' << s.size() << \""):\"";\\n    auto i = 0;\\n    for (auto c = s.begin(); c != s.end();)\\n    {\\n        if (i++ % 20 == 0) os << endl;\\n        os << setw(5) << *c++;\\n    }\\n    return os;\\n}\\n\\nint main(int argc, const char* argv[])\\n{\\n    const auto v1 = atoi(argv[1]);\\n    const auto v2 = atoi(argv[2]);\\n    set<unsigned> r, s;\\n    for (auto n = 1; n <= v2; n++)\\n    {\\n        if (n <= v1)\\n            r.insert(hofstadter(n, 0));\\n        s.insert(hofstadter(0, n));\\n    }\\n    cout << \""R\"" << r << endl;\\n    cout << \""S\"" << s << endl;\\n\\n    int m = max(*r.rbegin(), *s.rbegin());\\n    for (auto n = 1; n <= m; n++)\\n        if (r.count(n) == s.count(n))\\n            clog << \""integer \"" << n << \"" either in both or neither set\"" << endl;\\n\\n    return 0;\\n}"
"C++","Hofstadter_Figure-Figure_sequences","These two sequences of positive integers are defined as:\\n\\nThe sequence \\n\\n\\n\\nS\\n(\\nn\\n)\\n\\n\\n{\\displaystyle S(n)}\\n\\n is further defined as the sequence of positive integers not present in \\n\\n\\n\\nR\\n(\\nn\\n)\\n\\n\\n{\\displaystyle R(n)}\\n\\n.\\nSequence \\n\\n\\n\\nR\\n\\n\\n{\\displaystyle R}\\n\\n starts:\\nSequence \\n\\n\\n\\nS\\n\\n\\n{\\displaystyle S}\\n\\n starts:\\n\\n\\n\\nSpecifying a package providing the functions FFR and FFS:\\nThe implementation of the package internally uses functions which generate an array of Figures or Spaces:\\nFinally, a test program for the package, solving the task at hand:\\nThe output of the test program:\\n","% ./hofstadter 40 100 2> /dev/null\\nR(40):\\n    1    3    7   12   18   26   35   45   56   69   83   98  114  131  150  170  191  213  236  260\\n  285  312  340  369  399  430  462  495  529  565  602  640  679  719  760  802  845  889  935  982\\nS(100):\\n    2    4    5    6    8    9   10   11   13   14   15   16   17   19   20   21   22   23   24   25\\n   27   28   29   30   31   32   33   34   36   37   38   39   40   41   42   43   44   46   47   48\\n   49   50   51   52   53   54   55   57   58   59   60   61   62   63   64   65   66   67   68   70\\n   71   72   73   74   75   76   77   78   79   80   81   82   84   85   86   87   88   89   90   91\\n   92   93   94   95   96   97   99  100  101  102  103  104  105  106  107  108  109  110  111  112"
"C++","Hofstadter_Q_sequence","\\n","#include <iostream>\\n \\nint main() {\\n   const int size = 100000;\\n   int hofstadters[size] = { 1, 1 };  \\n   for (int i = 3 ; i < size; i++) \\n      hofstadters[ i - 1 ] = hofstadters[ i - 1 - hofstadters[ i - 1 - 1 ]] +\\n                             hofstadters[ i - 1 - hofstadters[ i - 2 - 1 ]];\\n   std::cout << \""The first 10 numbers are: \"";\\n   for (int i = 0; i < 10; i++) \\n      std::cout << hofstadters[ i ] << ' ';\\n   std::cout << std::endl << \""The 1000'th term is \"" << hofstadters[ 999 ] << \"" !\"" << std::endl;\\n   int less_than_preceding = 0;\\n   for (int i = 0; i < size - 1; i++)\\n      if (hofstadters[ i + 1 ] < hofstadters[ i ]) \\n	     less_than_preceding++;\\n   std::cout << \""In array of size: \"" << size << \"", \"";\\n   std::cout << less_than_preceding << \"" times a number was preceded by a greater number!\"" << std::endl;\\n   return 0;\\n}"
"C++","Hofstadter-Conway_$10,000_sequence","The definition of the sequence is colloquially described as:\\nNote that indexing for the description above starts from alternately the left and right ends of the list and starts from an index of one.\\nA less wordy description of the sequence is:\\nThe sequence begins:\\nInteresting features of the sequence are that:\\n\\nThe sequence is so named because John Conway offered a prize of $10,000 to the first person who could\\nfind the first position,   p   in the sequence where\\nIt was later found that Hofstadter had also done prior work on the sequence.\\nThe 'prize' was won quite quickly by Dr. Colin L. Mallows who proved the properties of the sequence and allowed him to find the value of   n   (which is much smaller than the 3,173,375,556 quoted in the NYT article).\\n\\n\\n\\n\\nFor maximum compatibility, this program uses only the basic instruction set (S/360)\\nwith 2 ASSIST macros (XDECO,XPRNT).\\nThe program addresses the problem for l=2**12 (4K). For l=2**20 (1M) you must\\nallocate dynamic storage instead using static storage.\\n","\\n#include <deque>\\n#include <iostream>\\n\\nint hcseq(int n)\\n{\\n  static std::deque<int> seq(2, 1);\\n  while (seq.size() < n)\\n  {\\n    int x = seq.back();\\n    seq.push_back(seq[x-1] + seq[seq.size()-x]);\\n  }\\n  return seq[n-1];\\n}\\n\\nint main()\\n{\\n  int pow2 = 1;\\n  for (int i = 0; i < 20; ++i)\\n  {\\n    int pow2next = 2*pow2;\\n    double max = 0;\\n    for (int n = pow2; n < pow2next; ++n)\\n    {\\n      double anon = hcseq(n)/double(n);\\n      if (anon > max)\\n        max = anon;\\n    }\\n    std::cout << \""maximum of a(n)/n between 2^\"" << i\\n              << \"" (\"" << pow2 << \"") and 2^\"" << i+1\\n              << \"" (\"" << pow2next << \"") is \"" << max << \""\\n\"";\\n    pow2 = pow2next;\\n  }\\n}\\n"
"C++","Horner's_rule_for_polynomial_evaluation","A fast scheme for evaluating a polynomial such as:\\nwhen\\nis to arrange the computation as follows:\\nAnd compute the result from the innermost brackets outwards as in this pseudocode:\\nTask Description\\nCf. Formal power series\\n","#include <iostream>\\n#include <vector>\\n\\nusing namespace std;\\n\\ndouble horner(vector<double> v, double x)\\n{\\n  double s = 0;\\n  \\n  for( vector<double>::const_reverse_iterator i = v.rbegin(); i != v.rend(); i++ )\\n    s = s*x + *i;\\n  return s;\\n}\\n\\nint main()\\n{\\n  double c[] = { -19, 7, -4, 6 };\\n  vector<double> v(c, c + sizeof(c)/sizeof(double));\\n  cout << horner(v, 3.0) << endl;\\n  return 0;\\n}"
"C++","Horner's_rule_for_polynomial_evaluation","A fast scheme for evaluating a polynomial such as:\\nwhen\\nis to arrange the computation as follows:\\nAnd compute the result from the innermost brackets outwards as in this pseudocode:\\nTask Description\\nCf. Formal power series\\n","\\n#include <iostream>\\n\\ntemplate\\n double horner(BidirIter begin, BidirIter end, double x)\\n{\\n  double result = 0;\\n  while (end != begin)\\n    result = result*x + *--end;\\n  return result;\\n}\\n\\nint main()\\n{\\n  double c[] = { -19, 7, -4, 6 };\\n  std::cout << horner(c, c + 4, 3) << std::endl;\\n}\\n"
"C++","HTTP","Access and print a URL's content (the located resource) to the console.\\nThere is a separate task for HTTPS Requests.\\n\\nThis works for ABAP Version 7.40 and above\\n","\\n#include <winsock2.h>\\n#include <ws2tcpip.h>\\n#include <iostream>\\n\\nint main() {\\n	WSADATA wsaData;\\n	WSAStartup( MAKEWORD( 2, 2 ), &wsaData );\\n\\n	addrinfo *result = NULL;\\n	addrinfo hints;\\n\\n	ZeroMemory( &hints, sizeof( hints ) );\\n	hints.ai_family = AF_UNSPEC;\\n	hints.ai_socktype = SOCK_STREAM;\\n	hints.ai_protocol = IPPROTO_TCP;\\n\\n	getaddrinfo( \""74.125.45.100\"", \""80\"", &hints, &result ); // http://www.google.com\\n\\n	SOCKET s = socket( result->ai_family, result->ai_socktype, result->ai_protocol );\\n\\n	connect( s, result->ai_addr, (int)result->ai_addrlen );\\n\\n	freeaddrinfo( result );\\n\\n	send( s, \""GET / HTTP/1.0\\n\\n\"", 16, 0 );\\n\\n	char buffer[512];\\n	int bytes;\\n\\n	do {\\n		bytes = recv( s, buffer, 512, 0 );\\n\\n		if ( bytes > 0 )\\n			std::cout.write(buffer, bytes);\\n	} while ( bytes > 0 );\\n\\n	return 0;\\n}\\n"
"C++","HTTP","Access and print a URL's content (the located resource) to the console.\\nThere is a separate task for HTTPS Requests.\\n\\nThis works for ABAP Version 7.40 and above\\n","\\n#include \\n\\nusing namespace Upp;\\n\\nCONSOLE_APP_MAIN\\n{\\n	Cout() << HttpClient(\""www.rosettacode.org\"").ExecuteRedirect();\\n}\\n"
"C++","Huffman_coding","Huffman encoding is a way to assign binary codes to symbols that reduces the overall number of bits used to encode a typical string of those symbols.\\nFor example, if you use letters as symbols and have details of the frequency of occurrence of those letters in typical strings, then you could just encode each letter with a fixed number of bits, such as in ASCII codes. You can do better than this by encoding more frequently occurring letters such as e and a, with smaller bit strings; and less frequently occurring letters such as q and x with longer bit strings.\\nAny string of letters will be encoded as a string of bits that are no-longer of the same length per letter. To successfully decode such as string, the smaller codes assigned to letters such as 'e' cannot occur as a prefix in the larger codes such as that for 'x'.\\nThe Huffman coding scheme takes each symbol and its weight (or frequency of occurrence), and generates proper encodings for each symbol taking account of the weights of each symbol, so that higher weighted symbols have fewer bits in their encoding. (See the WP article for more information).\\nA Huffman encoding can be computed by first creating a tree of nodes:\\n\\nTraverse the constructed binary tree from root to leaves assigning and accumulating a '0' for one branch and a '1' for the other at each node. The accumulated zeros and ones at each leaf constitute a Huffman encoding for those symbols and weights:\\n\\nUsing the characters and their frequency from the string:\\ncreate a program to generate a Huffman encoding for each character as a table.\\n\\nhuffman.ads:\\nhuffman.adb:\\nexample main.adb:\\n","#include <iostream>\\n#include <queue>\\n#include <map>\\n#include <climits> // for CHAR_BIT\\n#include <iterator>\\n#include <algorithm>\\n\\nconst int UniqueSymbols = 1 << CHAR_BIT;\\nconst char* SampleString = \""this is an example for huffman encoding\"";\\n\\ntypedef std::vector<bool> HuffCode;\\ntypedef std::map HuffCodeMap;\\n\\nclass INode\\n{\\npublic:\\n    const int f;\\n\\n    virtual ~INode() {}\\n\\nprotected:\\n    INode(int f) : f(f) {}\\n};\\n\\nclass InternalNode : public INode\\n{\\npublic:\\n    INode *const left;\\n    INode *const right;\\n\\n    InternalNode(INode* c0, INode* c1) : INode(c0->f + c1->f), left(c0), right(c1) {}\\n    ~InternalNode()\\n    {\\n        delete left;\\n        delete right;\\n    }\\n};\\n\\nclass LeafNode : public INode\\n{\\npublic:\\n    const char c;\\n\\n    LeafNode(int f, char c) : INode(f), c(c) {}\\n};\\n\\nstruct NodeCmp\\n{\\n    bool operator()(const INode* lhs, const INode* rhs) const { return lhs->f > rhs->f; }\\n};\\n\\nINode* BuildTree(const int (&frequencies)[UniqueSymbols])\\n{\\n    std::priority_queue, NodeCmp> trees;\\n\\n    for (int i = 0; i < UniqueSymbols; ++i)\\n    {\\n        if(frequencies[i] != 0)\\n            trees.push(new LeafNode(frequencies[i], (char)i));\\n    }\\n    while (trees.size() > 1)\\n    {\\n        INode* childR = trees.top();\\n        trees.pop();\\n\\n        INode* childL = trees.top();\\n        trees.pop();\\n\\n        INode* parent = new InternalNode(childR, childL);\\n        trees.push(parent);\\n    }\\n    return trees.top();\\n}\\n\\nvoid GenerateCodes(const INode* node, const HuffCode& prefix, HuffCodeMap& outCodes)\\n{\\n    if (const LeafNode* lf = dynamic_cast(node))\\n    {\\n        outCodes[lf->c] = prefix;\\n    }\\n    else if (const InternalNode* in = dynamic_cast(node))\\n    {\\n        HuffCode leftPrefix = prefix;\\n        leftPrefix.push_back(false);\\n        GenerateCodes(in->left, leftPrefix, outCodes);\\n\\n        HuffCode rightPrefix = prefix;\\n        rightPrefix.push_back(true);\\n        GenerateCodes(in->right, rightPrefix, outCodes);\\n    }\\n}\\n\\nint main()\\n{\\n    // Build frequency table\\n    int frequencies[UniqueSymbols] = {0};\\n    const char* ptr = SampleString;\\n    while (*ptr != '\\0')\\n        ++frequencies[*ptr++];\\n\\n    INode* root = BuildTree(frequencies);\\n    \\n    HuffCodeMap codes;\\n    GenerateCodes(root, HuffCode(), codes);\\n    delete root;\\n\\n    for (HuffCodeMap::const_iterator it = codes.begin(); it != codes.end(); ++it)\\n    {\\n        std::cout << it->first << \"" \"";\\n        std::copy(it->second.begin(), it->second.end(),\\n                  std::ostream_iterator<bool>(std::cout));\\n        std::cout << std::endl;\\n    }\\n    return 0;\\n}"
"C++","I_before_E_except_after_C","The phrase      \""I before E, except after C\""     is a\\nwidely known mnemonic which is supposed to help when spelling English words.\\n\\nUsing the word list from   http://wiki.puzzlers.org/pub/wordlists/unixdict.txt,\\ncheck if the two sub-clauses of the phrase are plausible individually:\\n\\nIf both sub-phrases are plausible then the original phrase can be said to be plausible.\\nSomething is plausible if the number of words having the feature is more than two times the number of words having the opposite feature (where feature is 'ie' or 'ei' preceded or not by 'c' as appropriate).\\n\\nAs a stretch goal use the entries from the table of Word Frequencies in Written and Spoken English: based on the British National Corpus, (selecting those rows with three space or tab separated words only), to see if the phrase is plausible when word frequencies are taken into account.\\n\\nShow your output here as well as your program.\\n\\n\\n","#include <iostream>\\n#include <fstream>\\n#include <string>\\n#include <tuple>\\n#include <vector>\\n#include <stdexcept>\\n#include \\n\\n\\n\\nstruct Claim {\\n        Claim(const std::string& name) : name_(name), pro_(0), against_(0), propats_(), againstpats_() {\\n        }\\n        \\n        void add_pro(const std::string& pat) { \\n               propats_.push_back(std::make_tuple(boost::regex(pat), pat[0] == '^')); \\n        }\\n        void add_against(const std::string& pat) { \\n               againstpats_.push_back(std::make_tuple(boost::regex(pat), pat[0] == '^')); \\n        }\\n        bool plausible() const { return pro_ > against_*2; }\\n        void check(const char * buf, uint32_t len) {\\n                for (auto i = propats_.begin(), ii = propats_.end(); i != ii; ++i) {\\n                        uint32_t pos = 0;\\n                        boost::cmatch m;\\n                        if (std::get<1>(*i) && pos > 0) continue;\\n                        while (pos < len && boost::regex_search(buf+pos, buf+len, m, std::get<0>(*i))) {\\n                                ++pro_;\\n                                if (pos > 0) std::cerr << name_ << \"" [pro] multiple matches in: \"" << buf << \""\\n\"";\\n                                pos += m.position() + m.length();\\n                        }\\n                }\\n                for (auto i = againstpats_.begin(), ii = againstpats_.end(); i != ii; ++i) {\\n                        uint32_t pos = 0;\\n                        boost::cmatch m;\\n                        if (std::get<1>(*i) && pos > 0) continue;\\n                        while (pos < len && boost::regex_search(buf+pos, buf+len, m, std::get<0>(*i))) {\\n                                ++against_;\\n                                if (pos > 0) std::cerr << name_ << \"" [against] multiple matches in: \"" << buf << \""\\n\"";\\n                                pos += m.position() + m.length();\\n                        }\\n                }\\n        }\\n        friend std::ostream& operator<<(std::ostream& os, const Claim& c);\\nprivate:\\n        std::string name_;\\n        uint32_t pro_;\\n        uint32_t against_;\\n        // tuple\\n        std::vector> propats_;\\n        std::vector> againstpats_;\\n};\\n\\nstd::ostream& operator<<(std::ostream& os, const Claim& c) {\\n        os << c.name_ << \"": matches: \"" << c.pro_ << \"" vs. counter matches: \"" << c.against_ << \"". \"";\\n        os << \""Plausibility: \"" << (c.plausible() ? \""yes\"" : \""no\"") << \"".\"";\\n        return os;\\n}\\n\\n\\nint main(int argc, char ** argv) {\\n        try {\\n                if (argc < 2) throw std::runtime_error(\""No input file.\"");\\n                std::ifstream is(argv[1]);\\n                if (! is) throw std::runtime_error(\""Input file not valid.\"");\\n\\n                Claim ieclaim(\""[^c]ie\"");\\n                ieclaim.add_pro(\""[^c]ie\"");\\n                ieclaim.add_pro(\""^ie\"");\\n                ieclaim.add_against(\""[^c]ei\"");\\n                ieclaim.add_against(\""^ei\"");\\n\\n                Claim ceiclaim(\""cei\"");\\n                ceiclaim.add_pro(\""cei\"");\\n                ceiclaim.add_against(\""cie\"");\\n\\n                {\\n                        const uint32_t MAXLEN = 32;\\n                        char buf[MAXLEN];\\n                        uint32_t longest = 0;\\n                        while (is) {\\n                                is.getline(buf, sizeof(buf));\\n                                if (is.gcount() <= 0) break;\\n                                else if (is.gcount() > longest) longest = is.gcount();\\n                                ieclaim.check(buf, is.gcount());\\n                                ceiclaim.check(buf, is.gcount());\\n                        }\\n                        if (longest >= MAXLEN) throw std::runtime_error(\""Buffer too small.\"");\\n                }\\n\\n                std::cout << ieclaim << \""\\n\"";\\n                std::cout << ceiclaim << \""\\n\"";\\n                std::cout << \""Overall plausibility: \"" << (ieclaim.plausible() && ceiclaim.plausible() ? \""yes\"" : \""no\"") << \""\\n\"";\\n\\n\\n        } catch (const std::exception& ex) {\\n                std::cerr << \""*** Error: \"" << ex.what() << \""\\n\"";\\n                return -1;\\n        }\\n        return 0;\\n}\\n"
"C++","IBAN","\\nThe   International Bank Account Number (IBAN)   is an internationally agreed means of identifying bank accounts across national borders with a reduced risk of propagating transcription errors.\\nThe IBAN consists of up to 34 alphanumeric characters:\\n\\nThe check digits enable a sanity check of the bank account number to confirm its integrity even before submitting a transaction.\\n\\nValidate the following fictitious IBAN:    GB82 WEST 1234 5698 7654 32 \\n\\nDetails of the algorithm can be found on the Wikipedia page.\\n\\n","#include <string>\\n#include <iostream>\\n#include \\n#include <map>\\n#include <algorithm>\\n#include <cctype>\\nusing namespace boost::algorithm ;\\n\\nbool isValid ( const std::string &ibanstring ) \\n{\\n   static std::map countrycodes \\n                           { {\""AL\"" , 28} , {\""AD\"" , 24} , {\""AT\"" , 20} , {\""AZ\"" , 28 } ,\\n			   {\""BE\"" , 16} , {\""BH\"" , 22} , {\""BA\"" , 20} , {\""BR\"" , 29 } ,\\n			   {\""BG\"" , 22} , {\""CR\"" , 21} , {\""HR\"" , 21} , {\""CY\"" , 28 } ,\\n			   {\""CZ\"" , 24} , {\""DK\"" , 18} , {\""DO\"" , 28} , {\""EE\"" , 20 } ,\\n			   {\""FO\"" , 18} , {\""FI\"" , 18} , {\""FR\"" , 27} , {\""GE\"" , 22 } ,\\n                           {\""DE\"" , 22} , {\""GI\"" , 23} , {\""GR\"" , 27} , {\""GL\"" , 18 } ,\\n                           {\""GT\"" , 28} , {\""HU\"" , 28} , {\""IS\"" , 26} , {\""IE\"" , 22 } , \\n			   {\""IL\"" , 23} , {\""IT\"" , 27} , {\""KZ\"" , 20} , {\""KW\"" , 30 } ,\\n			   {\""LV\"" , 21} , {\""LB\"" , 28} , {\""LI\"" , 21} , {\""LT\"" , 20 } , \\n			   {\""LU\"" , 20} , {\""MK\"" , 19} , {\""MT\"" , 31} , {\""MR\"" , 27 } , \\n			   {\""MU\"" , 30} , {\""MC\"" , 27} , {\""MD\"" , 24} , {\""ME\"" , 22 } , \\n			   {\""NL\"" , 18} , {\""NO\"" , 15} , {\""PK\"" , 24} , {\""PS\"" , 29 } , \\n			   {\""PL\"" , 28} , {\""PT\"" , 25} , {\""RO\"" , 24} , {\""SM\"" , 27 } , \\n			   {\""SA\"" , 24} , {\""RS\"" , 22} , {\""SK\"" , 24} , {\""SI\"" , 19 } , \\n			   {\""ES\"" , 24} , {\""SE\"" , 24} , {\""CH\"" , 21} , {\""TN\"" , 24 } ,\\n			   {\""TR\"" , 26} , {\""AE\"" , 23} , {\""GB\"" , 22} , {\""VG\"" , 24 } } ;\\n   std::string teststring( ibanstring ) ;\\n   erase_all( teststring , \"" \"" ) ; //defined in boost/algorithm/string.hpp\\n   if ( countrycodes.find( teststring.substr(0 , 2 )) == countrycodes.end( ) ) \\n      return false ;\\n   if ( teststring.length( ) != countrycodes[ teststring.substr( 0 , 2 ) ] ) \\n      return false ;\\n   if (!all(teststring, is_alnum())) \\n      return false ;\\n   to_upper( teststring ) ;\\n   std::rotate(teststring.begin(), teststring.begin() + 4, teststring.end());\\n\\n   std::string numberstring ;//will contain the letter substitutions\\n   for (const auto& c : teststring)\\n   {\\n      if (std::isdigit(c)) \\n	 numberstring += c  ;\\n      if (std::isupper(c)) \\n	 numberstring += std::to_string(static_cast<int>(c) - 55);\\n   }\\n   //implements a stepwise check for mod 97 in chunks of 9 at the first time\\n   // , then in chunks of seven prepended by the last mod 97 operation converted\\n   //to a string\\n   int segstart = 0 ;\\n   int step = 9 ;\\n   std::string prepended ;\\n   long number = 0 ;\\n   while ( segstart  < numberstring.length( ) - step ) {\\n      number = std::stol( prepended + numberstring.substr( segstart , step ) ) ;\\n      int remainder = number % 97 ;\\n      prepended =  std::to_string( remainder ) ;\\n      if ( remainder < 10 ) \\n	 prepended = \""0\"" + prepended ;\\n      segstart = segstart + step ;\\n      step = 7 ;\\n   }\\n   number = std::stol( prepended + numberstring.substr( segstart )) ;\\n   return ( number % 97 == 1 ) ;\\n}\\n\\nvoid SayValidity(const std::string& iban)\\n{\\n    std::cout << iban << (isValid(iban) ? \"" is \"" : \"" is not \"") << \""valid\\n\"";\\n}\\n\\nint main( ) \\n{\\n   SayValidity(\""GB82 WEST 1234 5698 7654 32\"");\\n   SayValidity(\""GB82TEST12345698765432\"");\\n   return 0 ;\\n}"
"C++","Identity_matrix","Build an   identity matrix   of a size known at run-time.\\n\\nAn identity matrix is a square matrix of size n × n,\\nwhere the diagonal elements are all 1s (ones),\\nand all the other elements are all 0s (zeroes).\\n\\n\\n\\n\\n\\n\\nI\\n\\nn\\n\\n\\n=\\n\\n\\n[\\n\\n\\n\\n1\\n\\n\\n0\\n\\n\\n0\\n\\n\\n⋯\\n\\n\\n0\\n\\n\\n\\n\\n0\\n\\n\\n1\\n\\n\\n0\\n\\n\\n⋯\\n\\n\\n0\\n\\n\\n\\n\\n0\\n\\n\\n0\\n\\n\\n1\\n\\n\\n⋯\\n\\n\\n0\\n\\n\\n\\n\\n⋮\\n\\n\\n⋮\\n\\n\\n⋮\\n\\n\\n⋱\\n\\n\\n⋮\\n\\n\\n\\n\\n0\\n\\n\\n0\\n\\n\\n0\\n\\n\\n⋯\\n\\n\\n1\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle I_{n}={\\begin{bmatrix}1&0&0&\\cdots &0\\\\0&1&0&\\cdots &0\\\\0&0&1&\\cdots &0\\\\\\vdots &\\vdots &\\vdots &\\ddots &\\vdots \\\\0&0&0&\\cdots &1\\\\\\end{bmatrix}}}\\n\\n\\n\\n\\n","template\\nclass matrix\\n{\\npublic:\\n    matrix( unsigned int nSize ) : \\n      m_oData(nSize * nSize, 0), m_nSize(nSize) {}\\n\\n      inline T& operator()(unsigned int x, unsigned int y)\\n      {\\n          return m_oData[x+m_nSize*y];\\n      }\\n\\n      void identity()\\n      {\\n          int nCount = 0;\\n          int nStride = m_nSize + 1;\\n          std::generate( m_oData.begin(), m_oData.end(), \\n              [&]() { return !(nCount++%nStride); } );\\n      }\\n\\n      inline unsigned int size() { return m_nSize; }\\n\\nprivate:\\n    std::vector<T>    m_oData;\\n    unsigned int      m_nSize;\\n};\\n\\nint main()\\n{\\n    int nSize;\\n    std::cout << \""Enter matrix size (N): \"";\\n    std::cin >> nSize;\\n\\n    matrix<int> oMatrix( nSize );\\n\\n    oMatrix.identity();\\n\\n    for ( unsigned int y = 0; y < oMatrix.size(); y++ )\\n    {\\n        for ( unsigned int x = 0; x < oMatrix.size(); x++ )\\n        {\\n            std::cout << oMatrix(x,y) << \"" \"";\\n        }\\n        std::cout << std::endl;\\n    }\\n    return 0;\\n}\\n"
"C++","Identity_matrix","Build an   identity matrix   of a size known at run-time.\\n\\nAn identity matrix is a square matrix of size n × n,\\nwhere the diagonal elements are all 1s (ones),\\nand all the other elements are all 0s (zeroes).\\n\\n\\n\\n\\n\\n\\nI\\n\\nn\\n\\n\\n=\\n\\n\\n[\\n\\n\\n\\n1\\n\\n\\n0\\n\\n\\n0\\n\\n\\n⋯\\n\\n\\n0\\n\\n\\n\\n\\n0\\n\\n\\n1\\n\\n\\n0\\n\\n\\n⋯\\n\\n\\n0\\n\\n\\n\\n\\n0\\n\\n\\n0\\n\\n\\n1\\n\\n\\n⋯\\n\\n\\n0\\n\\n\\n\\n\\n⋮\\n\\n\\n⋮\\n\\n\\n⋮\\n\\n\\n⋱\\n\\n\\n⋮\\n\\n\\n\\n\\n0\\n\\n\\n0\\n\\n\\n0\\n\\n\\n⋯\\n\\n\\n1\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle I_{n}={\\begin{bmatrix}1&0&0&\\cdots &0\\\\0&1&0&\\cdots &0\\\\0&0&1&\\cdots &0\\\\\\vdots &\\vdots &\\vdots &\\ddots &\\vdots \\\\0&0&0&\\cdots &1\\\\\\end{bmatrix}}}\\n\\n\\n\\n\\n","\\n#include \\n\\nint main()\\n{\\n    using namespace boost::numeric::ublas;\\n    \\n    int nSize;\\n    std::cout << \""Enter matrix size (N): \"";\\n    std::cin >> nSize;\\n\\n    identity_matrix<int> oMatrix( nSize );\\n\\n    for ( unsigned int y = 0; y < oMatrix.size2(); y++ )\\n    {\\n        for ( unsigned int x = 0; x < oMatrix.size1(); x++ )\\n        {\\n            std::cout << oMatrix(x,y) << \"" \"";\\n        }\\n        std::cout << std::endl;\\n    }\\n\\n    return 0;\\n}\\n"
"C++","Image_noise","Generate a random black and white   320x240   image continuously,\\nshowing FPS (frames per second).\\n\\n\\nnoise.ads:\\nnoise.adb:\\ntest_noise.adb:\\nNote that since the calculator's screen is 96x64, this example uses those dimensions instead of 320x240.\\nInstead of naively drawing each pixel to the screen, this implementation directly writes random numbers to the buffer, which randomly sets each pixel. Because Axe does not have native clock support, the FPS counter is simulated by counting \""ticks\"" at the known interrupt rate of 107.79 Hz (rounded to 108).\\nIt is possible to notice some vertical line patterns in the noise. This is likely due to the pseudorandom number generator and not the drawing method.\\nThis example gets steady 48 FPS on a TI-84 Plus Silver Edition running at 15 MHz. It gets 26 FPS when running at 6 MHz. Some pixels appear gray because the duration of each frame is shorter than the screen's notoriously slow response time. If a pixel is toggled very quickly, it never has time to fully transition to white or black.\\n\\nDepending on your hardware, you might be able to get thousands of frames per second. Compiled with gcc -lglut -lGL -g -Wall -O2.\\n\\nMax 185 FPS on .NET 4.0/Windows 7 64-bit on Athlon II X4 620 - ATI Radeon X1200.\\nnoise_sdl.lisp:\\n\\nThis D version shows about 155 FPS, while on the same PC the C version shows about 180 FPS.\\nGenerating random bits with the C core.stdc.stdlib.rand the performance becomes about the same of the C version.\\nCurrently, Euler Math Toolbox does not have optimized routines to plot matrices with color information. The frames per second are consequently not really good.\\nThis implementation includes two methods to update the pixels values. One uses unsafe methods and can do 350 fps on my machine, the second uses safe code to marshal the new values onto the bitmap data and can do 240 fps on the same machine.\\n~150 FPS\\n\\nA second example that is somewhat more optimized but maybe more complicated.\\n(~3000fps on a Thinkpad x220 laptop)\\n\\nThis uses the GLFW-b bindings for GLFW 3 support:\\nIcon/Unicon provide a portable graphics interface that runs on multiple platforms. The frame rates will be lower than many of the other languages.\\nThere are several possible approaches to painting this random noise.\\nprintf.icn provides a family of print formatting routines\\nThe script auto-starts when run (that last line p_run'' is responsible for the auto-start.\\nAverage FPS are displayed when the window is closed.\\nWith this revision, on my laptop, I typically get in the range of 58..59 FPS, with a cpu load from J of about 3% (sometimes as much as 5%, sometimes as low as 0.1%). I am probably limited by v-sync, and (hypothetically speaking) if I tuned my opengl drivers I perhaps could get significantly faster fps. However, since my screen only refreshes approximately 60 times per second, anything over that would be meaningless.\\nAbout some of the constants: 160 120 corresponds to a 320 by 240 rendering area (this J version 6 mechanism will be obsolete soon, but I think we should wait for the new code bases stabilize before replacing this code), and the rendering area is not resizable. 53050 was picked because on average half of the pixels will be dark and half of them will be light: We have a black background and 53050 random pixel coordinates (out of 75800 total pixels) being set to being light -- because so many of them will randomly overlap we have on average approximately 50% of each. It would be more efficient to use a pixel shader, pushing the randomizing process into the graphics hardware. But, with this small of a display, efficiency is not really an issue with this approach.\\nThis could be done more concisely, but the version below features the following enhancements:\\n- Resizable window\\n- Real-time blurring of noise behind the FPS display\\n- Cycling through FPS display modes using mouse clicks\\n- Very fast: 1000+ FPS on a 2.8 GHz Core Duo (with 64-bit JRE). This is capped because the maximum resolution of the timers available is 1 ms\\njsFiddle Demo\\nAbout 59 frames/second on Firefox 4.\\nWith Gtk, gets about 80 frames per second on a older, dual core 3 Ghz processor.\\n","\\n#include <windows.h>\\n#include <sstream>\\n#include <tchar.h>\\n//--------------------------------------------------------------------------------------------------\\nusing namespace std;\\n\\n//--------------------------------------------------------------------------------------------------\\nconst unsigned int BMP_WID = 320, BMP_HEI = 240, WHITE = 16777215, BLACK = 0;\\n\\n//--------------------------------------------------------------------------------------------------\\nclass myBitmap\\n{\\npublic:\\n    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}\\n    ~myBitmap()\\n    {\\n	DeleteObject( pen ); DeleteObject( brush );\\n	DeleteDC( hdc ); DeleteObject( bmp );\\n    }\\n\\n    bool create( int w, int h )\\n    {\\n	BITMAPINFO    bi;\\n	ZeroMemory( &bi, sizeof( bi ) );\\n	bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );\\n	bi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;\\n	bi.bmiHeader.biCompression = BI_RGB;\\n	bi.bmiHeader.biPlanes      = 1;\\n	bi.bmiHeader.biWidth       =  w;\\n	bi.bmiHeader.biHeight      = -h;\\n	HDC dc = GetDC( GetConsoleWindow() );\\n	bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );\\n	if( !bmp ) return false;\\n	hdc = CreateCompatibleDC( dc );\\n	SelectObject( hdc, bmp );\\n	ReleaseDC( GetConsoleWindow(), dc );\\n	width = w; height = h;\\n	return true;\\n    }\\n\\n    void clear( BYTE clr = 0 )\\n    {\\n	memset( pBits, clr, width * height * sizeof( DWORD ) );\\n    }\\n\\n    void setBrushColor( DWORD bClr )\\n    {\\n	if( brush ) DeleteObject( brush );\\n	brush = CreateSolidBrush( bClr );\\n	SelectObject( hdc, brush );\\n    }\\n\\n    void setPenColor( DWORD c ) { clr = c; createPen(); }\\n    void setPenWidth( int w ) { wid = w; createPen(); }\\n   \\n    void saveBitmap( string path )\\n    {\\n	BITMAPFILEHEADER fileheader;\\n	BITMAPINFO       infoheader;\\n	BITMAP           bitmap;\\n	DWORD            wb;\\n\\n	GetObject( bmp, sizeof( bitmap ), &bitmap );\\n	DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];\\n	ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );\\n	ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );\\n	ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );\\n	infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;\\n	infoheader.bmiHeader.biCompression = BI_RGB;\\n	infoheader.bmiHeader.biPlanes = 1;\\n	infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );\\n	infoheader.bmiHeader.biHeight = bitmap.bmHeight;\\n	infoheader.bmiHeader.biWidth = bitmap.bmWidth;\\n	infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );\\n	fileheader.bfType    = 0x4D42;\\n	fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );\\n	fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;\\n	GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );\\n	HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );\\n	WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );\\n	WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );\\n	WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );\\n	CloseHandle( file );\\n\\n	delete [] dwpBits;\\n    }\\n\\n    void* getBits( void ) const { return pBits; }\\n    HDC getDC() const     { return hdc; }\\n    int getWidth() const  { return width; }\\n    int getHeight() const { return height; }\\n\\nprivate:\\n    void createPen()\\n    {\\n	if( pen ) DeleteObject( pen );\\n	pen = CreatePen( PS_SOLID, wid, clr );\\n	SelectObject( hdc, pen );\\n    }\\n\\n    HBITMAP bmp;\\n    HDC     hdc;\\n    HPEN    pen;\\n    HBRUSH  brush;\\n    void*   pBits;\\n    int     width, height, wid;\\n    DWORD   clr;\\n};\\n//--------------------------------------------------------------------------------------------------\\nclass bmpNoise\\n{\\npublic:\\n    bmpNoise()\\n    {\\n	QueryPerformanceFrequency( &_frequency );\\n	_bmp.create( BMP_WID, BMP_HEI );\\n	_frameTime = _fps = 0; _start = getTime(); _frames = 0;\\n    }\\n\\n    void mainLoop()\\n    {\\n	float now = getTime();\\n	if( now - _start > 1.0f ) { _fps = static_cast<float>( _frames ) / ( now - _start ); _start = now; _frames = 0; }\\n	HDC wdc, dc = _bmp.getDC();\\n	unsigned int* bits = reinterpret_cast( _bmp.getBits() );\\n\\n	for( int y = 0; y < BMP_HEI; y++ )\\n	{\\n	    for( int x = 0; x < BMP_WID; x++ )\\n	    {\\n		if( rand() % 10 < 5 ) memset( bits, 255, 3 );\\n		else memset( bits, 0, 3 );\\n		bits++;\\n	    }\\n	}\\n	ostringstream o; o << _fps; TextOut( dc, 0, 0, o.str().c_str(), o.str().size() );\\n\\n	wdc = GetDC( _hwnd );\\n	BitBlt( wdc, 0, 0, BMP_WID, BMP_HEI, dc, 0, 0, SRCCOPY );\\n	ReleaseDC( _hwnd, wdc );\\n	_frames++; _frameTime = getTime() - now;\\n	if( _frameTime > 1.0f ) _frameTime = 1.0f;\\n    }\\n	\\n    void setHWND( HWND hwnd ) { _hwnd = hwnd; }\\n\\nprivate:\\n    float getTime()\\n    {\\n	LARGE_INTEGER liTime; QueryPerformanceCounter( &liTime );\\n	return liTime.QuadPart  / ( float )_frequency.QuadPart;\\n    }\\n    myBitmap      _bmp;\\n    HWND          _hwnd;\\n    float         _start, _fps, _frameTime;\\n    unsigned int  _frames;\\n    LARGE_INTEGER _frequency;\\n};\\n//--------------------------------------------------------------------------------------------------\\nclass wnd\\n{\\npublic:\\n    wnd() { _inst = this; }\\n    int wnd::Run( HINSTANCE hInst )\\n    {\\n	_hInst = hInst; _hwnd = InitAll();\\n        _noise.setHWND( _hwnd );\\n	ShowWindow( _hwnd, SW_SHOW );\\n	UpdateWindow( _hwnd );\\n\\n	MSG msg;\\n	ZeroMemory( &msg, sizeof( msg ) );\\n	while( msg.message != WM_QUIT )\\n	{\\n	    if( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) != 0 )\\n	    {\\n		TranslateMessage( &msg );\\n		DispatchMessage( &msg );\\n	    }\\n	    else\\n	    {\\n		_noise.mainLoop();\\n	    }\\n	}\\n	return UnregisterClass( \""_MY_NOISE_\"", _hInst );\\n    }\\nprivate:\\n    static int WINAPI wnd::WndProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )\\n    {\\n	switch( msg )\\n	{\\n	    case WM_DESTROY: PostQuitMessage( 0 ); break;\\n	    default:\\n	        return DefWindowProc( hWnd, msg, wParam, lParam );\\n	}\\n	return 0;\\n    }\\n\\n    HWND InitAll()\\n    {\\n	WNDCLASSEX wcex;\\n	ZeroMemory( &wcex, sizeof( wcex ) );\\n	wcex.cbSize           = sizeof( WNDCLASSEX );\\n	wcex.style           = CS_HREDRAW | CS_VREDRAW;\\n	wcex.lpfnWndProc   = ( WNDPROC )WndProc;\\n	wcex.hInstance     = _hInst;\\n	wcex.hCursor       = LoadCursor( NULL, IDC_ARROW );\\n	wcex.hbrBackground = ( HBRUSH )( COLOR_WINDOW + 1 );\\n	wcex.lpszClassName = \""_MY_NOISE_\"";\\n\\n	RegisterClassEx( &wcex );\\n\\n	RECT rc = { 0, 0, BMP_WID, BMP_HEI };\\n	AdjustWindowRect( &rc, WS_SYSMENU | WS_CAPTION, FALSE );\\n	int w = rc.right - rc.left, h = rc.bottom - rc.top;\\n	return CreateWindow( \""_MY_NOISE_\"", \"".: Noise image -- PJorente :.\"", WS_SYSMENU, CW_USEDEFAULT, 0, w, h, NULL, NULL, _hInst, NULL );\\n    }\\n\\n    static wnd* _inst;\\n    HINSTANCE   _hInst;\\n    HWND        _hwnd;\\n    bmpNoise    _noise;\\n};\\nwnd* wnd::_inst = 0;\\n//--------------------------------------------------------------------------------------------------\\nint APIENTRY _tWinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow )\\n{\\n    srand( GetTickCount() ); wnd myWnd;\\n    return myWnd.Run( hInstance );\\n}\\n//--------------------------------------------------------------------------------------------------\\n"
"C++","Imaginary_base_numbers","Imaginary base numbers are a non-standard positional numeral system which uses an imaginary number as its radix. The most common is quater-imaginary with radix 2i.\\nThe quater-imaginary numeral system was first proposed by Donald Knuth in 1955 as a submission for a high school science talent search. [Ref.]\\nOther imaginary bases are possible too but are not as widely discussed and aren't specifically named.\\nTask: Write a set of procedures (functions, subroutines, however they are referred to in your language) to convert base 10 numbers to an imaginary base and back.\\nAt a minimum, support quater-imaginary (base 2i).\\nFor extra kudos, support positive or negative bases 2i through 6i (or higher).\\nAs a stretch goal, support converting non-integer numbers ( E.G. 227.65625+10.859375i ) to an imaginary base.\\nSee Wikipedia: Quater-imaginary_base for more details.\\nFor reference, here are some some decimal and complex numbers converted to quater-imaginary.\\n","#include <algorithm>\\n#include <complex>\\n#include <iomanip>\\n#include <iostream>\\n\\nstd::complex<double> inv(const std::complex<double>& c) {\\n    double denom = c.real() * c.real() + c.imag() * c.imag();\\n    return std::complex<double>(c.real() / denom, -c.imag() / denom);\\n}\\n\\nclass QuaterImaginary {\\npublic:\\n    QuaterImaginary(const std::string& s) : b2i(s) {\\n        static std::string base(\""0123.\"");\\n\\n        if (b2i.empty()\\n            || std::any_of(s.cbegin(), s.cend(), [](char c) { return base.find(c) == std::string::npos; })\\n            || std::count(s.cbegin(), s.cend(), '.') > 1) {\\n            throw std::runtime_error(\""Invalid base 2i number\"");\\n        }\\n    }\\n\\n    QuaterImaginary& operator=(const QuaterImaginary& q) {\\n        b2i = q.b2i;\\n        return *this;\\n    }\\n\\n    std::complex<double> toComplex() const {\\n        int pointPos = b2i.find('.');\\n        int posLen = (pointPos != std::string::npos) ? pointPos : b2i.length();\\n        std::complex<double> sum(0.0, 0.0);\\n        std::complex<double> prod(1.0, 0.0);\\n        for (int j = 0; j < posLen; j++) {\\n            double k = (b2i[posLen - 1 - j] - '0');\\n            if (k > 0.0) {\\n                sum += prod * k;\\n            }\\n            prod *= twoI;\\n        }\\n        if (pointPos != -1) {\\n            prod = invTwoI;\\n            for (size_t j = posLen + 1; j < b2i.length(); j++) {\\n                double k = (b2i[j] - '0');\\n                if (k > 0.0) {\\n                    sum += prod * k;\\n                }\\n                prod *= invTwoI;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n    friend std::ostream& operator<<(std::ostream&, const QuaterImaginary&);\\n\\nprivate:\\n    const std::complex<double> twoI{ 0.0, 2.0 };\\n    const std::complex<double> invTwoI = inv(twoI);\\n\\n    std::string b2i;\\n};\\n\\nstd::ostream& operator<<(std::ostream& os, const QuaterImaginary& q) {\\n    return os << q.b2i;\\n}\\n\\n// only works properly if 'real' and 'imag' are both integral\\nQuaterImaginary toQuaterImaginary(const std::complex<double>& c) {\\n    if (c.real() == 0.0 && c.imag() == 0.0) return QuaterImaginary(\""0\"");\\n\\n    int re = (int)c.real();\\n    int im = (int)c.imag();\\n    int fi = -1;\\n    std::stringstream ss;\\n    while (re != 0) {\\n        int rem = re % -4;\\n        re /= -4;\\n        if (rem < 0) {\\n            rem = 4 + rem;\\n            re++;\\n        }\\n        ss << rem << 0;\\n    }\\n    if (im != 0) {\\n        double f = (std::complex<double>(0.0, c.imag()) / std::complex<double>(0.0, 2.0)).real();\\n        im = (int)ceil(f);\\n        f = -4.0 * (f - im);\\n        size_t index = 1;\\n        while (im != 0) {\\n            int rem = im % -4;\\n            im /= -4;\\n            if (rem < 0) {\\n                rem = 4 + rem;\\n                im++;\\n            }\\n            if (index < ss.str().length()) {\\n                ss.str()[index] = (char)(rem + 48);\\n            } else {\\n                ss << 0 << rem;\\n            }\\n            index += 2;\\n        }\\n        fi = (int)f;\\n    }\\n\\n    auto r = ss.str();\\n    std::reverse(r.begin(), r.end());\\n    ss.str(\""\"");\\n    ss.clear();\\n    ss << r;\\n    if (fi != -1) ss << '.' << fi;\\n    r = ss.str();\\n    r.erase(r.begin(), std::find_if(r.begin(), r.end(), [](char c) { return c != '0'; }));\\n    if (r[0] == '.')r = \""0\"" + r;\\n    return QuaterImaginary(r);\\n}\\n\\nint main() {\\n    using namespace std;\\n\\n    for (int i = 1; i <= 16; i++) {\\n        complex<double> c1(i, 0);\\n        QuaterImaginary qi = toQuaterImaginary(c1);\\n        complex<double> c2 = qi.toComplex();\\n        cout << setw(8) << c1 << \"" -> \"" << setw(8) << qi << \"" -> \"" << setw(8) << c2 << \""     \"";\\n        c1 = -c1;\\n        qi = toQuaterImaginary(c1);\\n        c2 = qi.toComplex();\\n        cout << setw(8) << c1 << \"" -> \"" << setw(8) << qi << \"" -> \"" << setw(8) << c2 << endl;\\n    }\\n    cout << endl;\\n\\n    for (int i = 1; i <= 16; i++) {\\n        complex<double> c1(0, i);\\n        QuaterImaginary qi = toQuaterImaginary(c1);\\n        complex<double> c2 = qi.toComplex();\\n        cout << setw(8) << c1 << \"" -> \"" << setw(8) << qi << \"" -> \"" << setw(8) << c2 << \""     \"";\\n        c1 = -c1;\\n        qi = toQuaterImaginary(c1);\\n        c2 = qi.toComplex();\\n        cout << setw(8) << c1 << \"" -> \"" << setw(8) << qi << \"" -> \"" << setw(8) << c2 << endl;\\n    }\\n\\n    return 0;\\n}"
"C++","Increment_a_numerical_string","Increment a numerical string.\\n\\n","// standard C++ string stream operators\\n#include <cstdlib>\\n#include <string>\\n#include <sstream>\\n\\n// inside a function or method...\\nstd::string s = \""12345\"";\\n\\nint i;\\nstd::istringstream(s) >> i;\\ni++;\\n//or:\\n//int i = std::atoi(s.c_str()) + 1;\\n\\nstd::ostringstream oss;\\nif (oss << i) s = oss.str();"
"C++","Increment_a_numerical_string","Increment a numerical string.\\n\\n","#include <string>\\n\\nstd::string s = \""12345\"";\\ns = std::to_string(1+std::stoi(s));"
"C++","Increment_a_numerical_string","Increment a numerical string.\\n\\n","// Boost\\n#include <cstdlib>\\n#include <string>\\n#include \\n\\n// inside a function or method...\\nstd::string s = \""12345\"";\\nint i = boost::lexical_cast<int>(s) + 1;\\ns = boost::lexical_cast(i);"
"C++","Increment_a_numerical_string","Increment a numerical string.\\n\\n","// Qt\\nQString num1 = \""12345\"";\\nQString num2 = QString(\""%1\"").arg(v1.toInt()+1);"
"C++","Increment_a_numerical_string","Increment a numerical string.\\n\\n","// MFC\\nCString s = \""12345\"";\\nint i = _ttoi(s) + 1;\\nint i = _tcstoul(s, NULL, 10) + 1; \\ns.Format(\""%d\"", i);"
"C++","Increment_a_numerical_string","Increment a numerical string.\\n\\n","#include <string>\\n#include <iostream>\\n#include <ostream>\\n\\nvoid increment_numerical_string(std::string& s)\\n{\\n    std::string::reverse_iterator iter = s.rbegin(), end = s.rend();\\n    int carry = 1;\\n    while (carry && iter != end)\\n    {\\n        int value = (*iter - '0') + carry;\\n        carry = (value / 10);\\n        *iter = '0' + (value % 10);\\n        ++iter;\\n    }\\n    if (carry)\\n        s.insert(0, \""1\"");\\n}\\n\\nint main()\\n{\\n    std::string big_number = \""123456789012345678901234567899\"";\\n    std::cout << \""before increment: \"" << big_number << \""\\n\"";\\n    increment_numerical_string(big_number);\\n    std::cout << \""after increment:  \"" << big_number << \""\\n\"";\\n}"
"C++","Infinity","Write a function which tests if infinity is supported for floating point numbers (this step should be omitted for languages where the language specification already demands the existence of infinity, e.g. by demanding IEEE numbers), and if so, returns positive infinity.   Otherwise, return the largest possible positive floating point number.\\nFor languages with several floating point types, use the type of the literal constant   1.5   as floating point type.\\n\\n\\nActionScript has the built in function isFinite() to test if a number is finite or not.\\nThe language-defined attribute Machine_Overflows is defined for each floating-point type. It is true when an overflow or divide-by-zero results in Constraint_Error exception propagation. When the underlying machine type is incapable to implement this semantics the attribute is false. It is to expect that on the machines with IEEE 754 hardware Machine_Overflows is true. The language-defined attributes Succ and Pred yield the value next or previous to the argument, correspondingly.\\nSample output on a machine where Float is IEEE 754:\\nNote that the code above does not work for user-defined types, which may have range of values narrower than one of the underlying hardware type. This case represents one of the reasons why Ada programmers are advised not to use predefined floating-point types. There is a danger that the implementation of might be IEEE 754, and so the program semantics could be broken.\\nHere is the code that should work for any type on any machine:\\nSample output. Note that the compiler is required to generate Constraint_Error even if the hardware is IEEE 754. So the upper and lower bounds are 10.0 and -10.0:\\nThere is a simple way to strip IEEE 754 ideals (non-numeric values) from a predefined floating-point type such as Float or Long_Float:\\nThe subtype Safe_Float keeps all the range of Float, yet behaves properly upon overflow, underflow and zero-divide.\\nALGOL 68R (from Royal Radar Establishment) has an infinity variable as part of the standard prelude, on the ICL 1900 Series mainframes the value of infinity is 5.79860446188₁₀76 (the same as max float).\\nNote: The underlying hardware may sometimes support an infinity, but the ALGOL 68 standard itself does not, and gives no way of setting a variable to either ±∞.\\nALGOL 68 does have some 7 built in exceptions, these might be used to detect exceptions during transput, and so if the underlying hardware does support ∞, then it would be detected with a on value error while printing and if mended would appear as a field full of error char.\\nOutput:\\nThis has been tested with GAWK 3.1.7 and MAWK, both return\\nOutput:\\nA previous solution used atof(\""infinity\""), which returned infinity with some C libraries but returned zero with MinGW.\\nC89 has a macro HUGE_VAL in <math.h>. HUGE_VAL is a double. HUGE_VAL will be infinity if infinity exists, else it will be the largest possible number. HUGE_VAL is a double.\\nThe output from the above program might be \""inf\"", \""1.#INF\"", or something else.\\nC99 also has a macro for infinity:\\nOutput:\\nJava's floating-point types (float, double) all support infinity. Clojure has literals for infinity:\\nThe largest possible number in Java (without using the Big classes) is also in the Double class\\n(def biggestNumber Double/MAX_VALUE). Its value is (1+(1-2^(-52)))*2^1023 or 1.7976931348623157*10^308 (a.k.a. \""big\""). Other number classes (Integer, Long, Float, Byte, and Short) have maximum values that can be accessed in the same way.\\nCoffeeScript compiles to JavaScript, and as such it inherits the properties of JavaScript.\\nJavaScript has a special global property called \""Infinity\"":\\nas well as constants in the Number class:\\nThe global isFinite function tests for finiteness:\\nCommon Lisp does not specify an infinity value. Some implementations may have support for IEEE infinity, however. For instance, CMUCL supports IEEE Special Values. Common Lisp does specify that implementations define constants with most (and least) positive (and negative) values. These may vary between implementations.\\nBlackBox Component Builder\\nExecute: ^Q Infinity.Do\\nOutput:\\nDelphi defines the following constants in Math:\\nTest for infinite value using:\\n\\nOutput:\\nNo infinity available. Largest floating point number is supposed to be 1.80e308 (IEEE 754-1985 double precision 64 bits) but that did not work. However 1.79e308 is fine, so max float is somewhere close to 1.80e308.\\nEvery type has its \""infinity\"" constant: MAXINT for 16-bit integer, MAXREAL for single precision\\nfloating and MAXLONGREAL for double precision floating. An infinity test can be achieved with\\nan EXCEPTION:\\n","#include <limits>\\n\\ndouble inf()\\n{\\n  if (std::numeric_limits<double>::has_infinity)\\n    return std::numeric_limits<double>::infinity();\\n  else\\n    return std::numeric_limits<double>::max();\\n}"
"C++","Inheritance/Multiple","Multiple inheritance allows to specify that one  class is a subclass of several other classes.\\nSome languages allow multiple inheritance for arbitrary classes,\\nothers restrict it to interfaces, some don't allow it at all.\\nWrite two classes (or interfaces) Camera and MobilePhone,\\nthen write a class CameraPhone which is both a Camera and\\na MobilePhone.\\nThere is no need to implement any functions for those classes.\\nAda 2005 has added interfaces, allowing a limited form of multiple inheritance.\\nAikido does not support multiple inheritance, but does allow multiple implementation of interfaces.\\nIn C# you may inherit from only one class, but you can inherit\\nfrom multiple interfaces.\\nAlso, in C# it is standard practice to start all interface names\\nwith a capital 'I' so I have altered the name of the interface.\\nIn the example we inherit from a class and an interface.\\nWhile D does not have multiple base class inheritance, you can inherit from multiple interfaces.\\nD also supports the non-virtual interface pattern, where an interface may have non-virtual methods with defined implementations.\\nIn addition, D's alias this feature allows one to create a type that, while it does not technically derive from two different classes, behaves as if it did.\\nYou can currently only have a single alias this, but multiple alias this is planned. Nested alias this works today, but is somewhat finicky.\\nLastly, D has template and string mixins. These can be used for static polymorphism, where a piece of code is written once and has a single definition, but is used in multiple places. It does not enable any sort of dynamic polymorphism that is not covered above.\\nUsing D's CTFE and reflection capabilities, string mixins can copy the interface of other types, and thus be used for proxies and mocks.\\nDelphi doesn't support multiple inheritance, but it does have multiple interfaces.\\nSee Delphi.\\nE does not have multiple inheritance as a built-in feature.\\nIn fact, E only has inheritance at all as a light syntactic sugar over delegation (message forwarding).\\nHowever, using that facility it is possible to implement multiple inheritance.\\nThis is a quick simple implementation of multiple inheritance.\\nIt simply searches (depth-first and inefficiently) the inheritance tree for a method;\\nit does not do anything about diamond inheritance.\\nThese shortcomings could be fixed if more powerful multiple inheritance were needed.\\nThe task example:\\nAnd testing that it works as intended:\\nHaving two class—one for CAMERA and the other for a MOBILE_PHONE ...\\nWe can create a new CAMERA_PHONE, which inherits directly from both CAMERA and MOBILE_PHONE.\\nNOTE: There is no reasonable limit to the number of classes we can inherit from in a single class. The compiler helps us to navigate issues like repeated inheritance and the \""diamond of death\"" easily and quickly.\\nELENA only permits inheritance from one parent class. However, mixins are supported\\nAlternatively a group object may be created\\nFantom only permits inheritance from one parent class.\\nHowever, Fantom supports 'mixins': a mixin is a collection\\nof implemented methods to be added to the child class.\\nAny number of mixins can be added to any given child class.\\nIt is an error for method names to conflict.\\nA class can only inherit from one other class, but it can implement any number of interfaces.\\nGo abandons traditional object oriented concepts of inheritance hierarchies, yet it does have features for composing both structs and interfaces.\\n","class Camera\\n{\\n  // ...\\n};\\n\\nclass MobilePhone\\n{\\n  // ...\\n};\\n\\nclass CameraPhone:\\n  public Camera,\\n  public MobilePhone\\n{\\n  // ...\\n};"
"C++","Inheritance/Single","Inheritance is an operation of type algebra that creates a new type from one or several parent types. The obtained type is called derived type. It inherits some of the properties of its parent types. Usually inherited properties are:\\nThe  class of the new type is a subclass of the classes rooted in the parent types. When all (in certain sense) properties of the parents are preserved by the derived type, it is said to be a Liskov subtype. When properties are preserved then the derived type is substitutable for its parents in all contexts. Usually full substitutability is achievable only in some contexts.\\nInheritance is\\nSome single inheritance languages usually allow multiple inheritance for certain abstract types, interfaces in particular.\\nInheritance can be considered as a relation parent-child. Parent types are sometimes called supertype, the derived ones are subtype. This relation is transitive and reflexive. Types bound by the relation form a wp:Directed_acyclic_graph directed acyclic graph (ignoring reflexivity). With single inheritance it becomes a tree.\\nTask: Show a tree of types which inherit from each other. The top of the tree should be a class called Animal. The second level should have Dog and Cat. Under Dog should be Lab and Collie. None of the classes need to have any functions, the only thing they need to do is inherit from the specified superclasses (overriding functions should be shown in Polymorphism). The tree should look like this:\\nAutoHotkey_L is prototype-based. However, for convenience, class-syntax may be used to create a base object.\\nThis is not very useful in clojure\\nMore useful:\\nuse:\\nOn the subject of inheritance, it is worth noting that Coco's super works differently from CoffeeScript's. In particular, the constructor of a subclass should generally say super ..., not just super. Here is a translation of the example from the CoffeeScript documentation:\\nUsing CLOS classes, we have the following:\\nAlternatively, since there is no multiple inheritance in the task requirement, structures could also be used:\\n(Structures are less flexible than CLOS objects but often somewhat more efficiently implemented, due to those restrictions.)\\nInheritance is not required for object-oriented programming in Lisp. It is used for code reuse, because it allows common utilities and protocol conventions to be factored out into base class methods. However, a class doesn't have to inherit from a base class just so that some existing methods can work with instances of that class.\\nFurthermore, all of the \""basic types\"" also have a class, so methods can be readily specialized to lists, integers, strings, symbols, et cetera. This is done without having to modify any class definitions.\\nThese classes do not have to inherit from some interface or base class which provides a prototype for the serialize-to-asn-1 method. Such a requirement has more to do with static typing than object oriented programming. Usually in languages which require such inheritance, there are also statically typed references. A class must conform to some \""ASNEncodable\"" class so that its instances can be passed to functions which expect references to an ASN1Encodable type, which is verified at compile time.\\nOutside of interactions with the host platform's objects, E does not generally deal in complex type hierarchies; the focus is more on \""what guarantees does this object provide\"", and composition rather than inheritance. However, it is possible to set up a type hierarchy scheme with just a bit of code.\\nIn E, a guard accepts, or coerces, certain objects and rejects others; its range constitutes a type. An auditor examines the implementation of an object and marks it approved; a stamp is an auditor which does no actual checking. Here, we create a guard/stamp pair; the guard accepts every stamped object. The stamp also asks for each supertype's stamp on the objects it audits.\\nSetting up the task's specified tree:\\nSome example objects:\\nTesting against the types:\\nThere are numerous, mutually incompatible object oriented frameworks for Forth. This one works with the FOOS preprocessor extension of 4tH.\\n\\nWorks with any ANS Forth\\nNeeds the FMS-SI (single inheritance) library code located here:\\nhttp://soton.mpeforth.com/flag/fms/index.html\\nOO has been part of the Fortran standard since 2003 but the compilers are still playing catchup. This example builds with the Intel 11.1.069 compiler (free for personal use on linux).\\nThe () behind the class names indicates a public default constructor; you need some type of public constructor to derive from a class.\\nGo eschews most trappings of inheritance, yet it's anonymous field feature allows building one struct type upon another and accessing fields of \""embedded\"" types without extra synax.\\nA type can't inherit properties from other types, but it can belong to any number of type classes, which may themselves be subclasses of other type classes.\\nThis example only works in Unicon.\\n\""Animal\"" is actually a predefined kind in Inform 7, so its definition here is redundant (but legal).\\nHere is how this would normally be done:\\ncoclass specifies that following definitions will be within the named class, and coinsert specifies that the current class will inherit from the named classes (or object -- in J the only difference between a class and an object is its name and how you can create them -- this motivates the \""co\"" prefix on operations which manipulate classes and objects).\\nSee http://www.jsoftware.com/help/jforc/modular_code.htm\\nThat said, some operations in J -- including coinsert -- will create classes if they did not already exist. So the above may be simplified to:\\nThat said, note that classes and objects are not \""types\"" in J. Instead, they are components of names. In general, when we deal with objects and classes we deal with references to the underlying representation, and in J the references are names, so a collection of classes and objects, in J, would be a collection of names which refer to classes and objects. In other words, the \""type\"" (to the degree that there is a type) would be best thought of as \""name\"" (or, more mechanically: boxed list of characters).\\nJavaScript is a class-free, object-oriented language, and as such, it uses prototypal inheritance instead of classical inheritance.\\nJulia is not really an object-oriented programming language. It support polymorphism and inheriting functionality but not structure. Thus inheritance hierarchies must be made with abstract types. Abstract types can not be instantiated and do not contain any fields. So below Dog is abstract while Collie is concrete type which may contain fields.\\n","class Animal\\n{\\n  // ... \\n};\\n\\nclass Dog: public Animal\\n{\\n  // ... \\n};\\n\\nclass Lab: public Dog\\n{\\n  // ...\\n};\\n\\nclass Collie: public Dog\\n{\\n  // ...\\n};\\n\\nclass Cat: public Animal\\n{\\n  // ...\\n};"
"C++","Input_loop","Read from a text stream either word-by-word or line-by-line until the stream runs out of data.\\nThe stream will have an unknown amount of data on it.\\n\\nThis example reads in a text stream from standard input line by line\\nand writes the output to standard output.\\nFor file consisting of just one page - a typical linux/unix file:\\nFor multi page files, each page is seekable with PROC set = (REF FILE file, INT page, line, char)VOID: ~. This allows rudimentary random access where each new page is effectively a new record.\\nThe boolean functions physical file ended(f), logical file ended(f), page ended(f) and line ended(f) are also available to indicate the end of a file, page and line.\\nThis example reads the text of a source file line by line\\nand writes the output to a destination file.\\nThis just reads lines from stdin and prints them until EOF is read.\\nor, more idiomatic:\\nThis specifically relates to console input (stdin).\\nAlternate solution:\\nThis example first creates a test file with three lines. It then opens the file in read mode, sets the string of break characters and then reads the file token by token, where tokens are delimeted by break characters. Finally, the file position is set to an invalid value, which closes the file.\\n","\\n#include <istream>\\n#include <string>\\n#include <vector>\\n#include <algorithm>\\n#include <iostream>\\n#include <iterator>\\n\\n// word by word\\ntemplate\\nvoid read_words(std::istream& is, OutIt dest)\\n{\\n  std::string word;\\n  while (is >> word)\\n  {\\n    // send the word to the output iterator\\n    *dest = word;\\n  }\\n}\\n\\n// line by line:\\ntemplate\\nvoid read_lines(std::istream& is, OutIt dest)\\n{\\n  std::string line;\\n  while (std::getline(is, line))\\n  {\\n    // store the line to the output iterator\\n    *dest = line;\\n  }\\n}\\n\\nint main()\\n{\\n  // 1) sending words from std. in std. out (end with Return)\\n  read_words(std::cin, \\n             std::ostream_iterator(std::cout, \"" \""));\\n\\n  // 2) appending lines from std. to vector (end with Ctrl+Z)\\n  std::vector v;\\n  read_lines(std::cin, std::back_inserter(v));\\n  \\n  return 0;\\n}\\n\\n"
"C++","Input_loop","Read from a text stream either word-by-word or line-by-line until the stream runs out of data.\\nThe stream will have an unknown amount of data on it.\\n\\nThis example reads in a text stream from standard input line by line\\nand writes the output to standard output.\\nFor file consisting of just one page - a typical linux/unix file:\\nFor multi page files, each page is seekable with PROC set = (REF FILE file, INT page, line, char)VOID: ~. This allows rudimentary random access where each new page is effectively a new record.\\nThe boolean functions physical file ended(f), logical file ended(f), page ended(f) and line ended(f) are also available to indicate the end of a file, page and line.\\nThis example reads the text of a source file line by line\\nand writes the output to a destination file.\\nThis just reads lines from stdin and prints them until EOF is read.\\nor, more idiomatic:\\nThis specifically relates to console input (stdin).\\nAlternate solution:\\nThis example first creates a test file with three lines. It then opens the file in read mode, sets the string of break characters and then reads the file token by token, where tokens are delimeted by break characters. Finally, the file position is set to an invalid value, which closes the file.\\n","\\ntemplate\\nvoid read_words(std::istream& is, OutIt dest)\\n{\\n    typedef std::istream_iterator InIt;\\n    std::copy(InIt(is), InIt(),\\n              dest);\\n}\\n\\nnamespace detail \\n{\\n    struct ReadableLine : public std::string \\n    { \\n        friend std::istream & operator>>(std::istream & is, ReadableLine & line)\\n        {   \\n            return std::getline(is, line);\\n        }\\n    };\\n}\\n\\ntemplate\\nvoid read_lines(std::istream& is, OutIt dest)\\n{\\n    typedef std::istream_iterator InIt;\\n    std::copy(InIt(is), InIt(),\\n              dest);\\n}\\n"
"C++","Input/Output_for_Pairs_of_Numbers","From lines of input starting with a line containing the numbers of pairs to follows, followed by that number of pairs of integers separated by a space on separate lines from STDIN, output the sum of each pair to STDOUT.\\n\\nInput\\nOutput\\nSimple version - there can be newlines before or between the numbers\\nStrict version - the pairs of numbers must appear on the same line.\\n","\\n#include <iostream>\\nusing namespace std;\\n \\nint doStuff(int a, int b) {\\n    return a + b;\\n}\\n \\nint main() {\\n	\\n	int t, **list;\\n	\\n	cin >> t;\\n	\\n	list = new int*[t];\\n	\\n	for(int j=0; j> list[j][0]>> list[j][1];\\n		\\n	}\\n	\\n	cout << endl;\\n	\\n	for(int j=0;j\\n\\nRun as per given input\\n\\n<pre>\\n5\\n1 2\\n10 20\\n-3 5\\n100 2\\n5 5\\n\\n3\\n30\\n2\\n102\\n10\\n"
"C++","Integer_overflow","Some languages support one or more integer types of the underlying processor.\\nThis integer types have fixed size;   usually   8-bit,   16-bit,   32-bit,   or   64-bit.\\nThe integers supported by such a type can be   signed   or   unsigned.\\nArithmetic for machine level integers can often be done by single CPU instructions.\\nThis allows high performance and is the main reason to support machine level integers.\\n\\nAn integer overflow happens when the result of a computation does not fit into the fixed size integer.\\nThe result can be too small or too big to be representable in the fixed size integer.\\n\\nWhen a language has fixed size integer types, create a program that\\ndoes arithmetic computations for the fixed size integers of the language.\\nThese computations must be done such that the result would overflow.\\nThe program should demonstrate what the following expressions do.\\n\\nFor 32-bit signed integers:\\nFor 64-bit signed integers:\\nFor 32-bit unsigned integers:\\nFor 64-bit unsigned integers:\\nWhen the integer overflow does trigger an exception show how the exception is caught.\\nWhen the integer overflow produces some value print it.\\nIt should be explicitly noted when an integer overflow is not recognized and the program continues with wrong results.\\nThis should be done for signed and unsigned integers of various sizes supported by the language.\\nWhen a language has no fixed size integer type or when no integer overflow can occur\\nfor other reasons this should be noted.\\nIt is okay to mention, when a language supports unlimited precision integers, but\\nthis task is NOT the place to demonstrate the capabilities of unlimited precision integers.\\n\\nYou can choose to manage or not the binary integer overflow with the program mask bits of the PSW (Program Status Word). Bit 20 enables fixed-point overflow. Two non-privileged instructions (IPM,SPM) are available for retrieving and setting the program mask of the current PSW.\\n\\nIf you mask, you can test it in your program:\\nOn the other hand,\\nyou will have the S0C8 system abend code : fixed point overflow exception\\nwith the same program, if you unmask bit 20 by:\\nIn Ada, both predefined and user-defined integer types are in a given range, between Type'First and Type'Last, inclusive. The range of predefined types is implementation specific. When the result of a computation is out of the type's range, the program does not continue with a wrong result, but instead raises an exception.\\n","#include <iostream>\\n#include <cstdint>\\n#include <limits>\\n\\nint main (int argc, char *argv[])\\n{\\n  std::cout << std::boolalpha\\n  << std::numeric_limits::is_modulo << '\\n'\\n  << std::numeric_limits::is_modulo << '\\n' // always true\\n  << std::numeric_limits::is_modulo << '\\n'\\n  << std::numeric_limits::is_modulo << '\\n' // always true\\n  << \""Signed 32-bit:\\n\""\\n    << -(-2147483647-1) << '\\n'\\n    << 2000000000 + 2000000000 << '\\n'\\n    << -2147483647 - 2147483647 << '\\n'\\n    << 46341 * 46341 << '\\n'\\n    << (-2147483647-1) / -1 << '\\n'\\n  << \""Signed 64-bit:\\n\""\\n    << -(-9223372036854775807-1) << '\\n'\\n    << 5000000000000000000+5000000000000000000 << '\\n'\\n    << -9223372036854775807 - 9223372036854775807 << '\\n'\\n    << 3037000500 * 3037000500 << '\\n'\\n    << (-9223372036854775807-1) / -1 << '\\n'\\n  << \""Unsigned 32-bit:\\n\""\\n    << -4294967295U << '\\n'\\n    << 3000000000U + 3000000000U << '\\n'\\n    << 2147483647U - 4294967295U << '\\n'\\n    << 65537U * 65537U << '\\n'\\n  << \""Unsigned 64-bit:\\n\""\\n    << -18446744073709551615LU << '\\n'\\n    << 10000000000000000000LU + 10000000000000000000LU << '\\n'\\n    << 9223372036854775807LU - 18446744073709551615LU << '\\n'\\n    << 4294967296LU * 4294967296LU << '\\n';\\n  return 0;\\n}"
"C++","Integer_roots","Create a program that computes an approximation of the principal   Nth   root of   X   as the largest integer less than or equal to   R   for which   RN=X.\\n──where:\\nNo arbitrary limits should be placed on the magnitudes of the numbers involved.\\n\\nExample:   With   N=3   and   X=8   you would calculate the number   2   because   \\n\\n\\n\\n\\n2\\n\\n3\\n\\n\\n=\\n8\\n\\n\\n{\\displaystyle 2^{3}=8}\\n\\n\\nExample:   With   N=3   and   X=9  you would again calculate the number   2   because 2 is the largest integer less than or equal to the root   R.\\nExample:   With   N=2   and   X=2×1002,000   you would calculate a large integer consisting of the first   2,001   digits (in order) of the square root of two.\\n\\n","#include <iostream>\\n#include <math.h>\\n\\nunsigned long long root(unsigned long long base, unsigned int n) {\\n	if (base < 2) return base;\\n	if (n == 0) return 1;\\n\\n	unsigned int n1 = n - 1;\\n	unsigned long long n2 = n;\\n	unsigned long long n3 = n1;\\n	unsigned long long c = 1;\\n	auto d = (n3 + base) / n2;\\n	auto e = (n3 * d + base / pow(d, n1)) / n2;\\n\\n	while (c != d && c != e) {\\n		c = d;\\n		d = e;\\n		e = (n3*e + base / pow(e, n1)) / n2;\\n	}\\n\\n	if (d < e) return d;\\n	return e;\\n}\\n\\nint main() {\\n	using namespace std;\\n\\n	cout << \""3rd root of 8 = \"" << root(8, 3) << endl;\\n	cout << \""3rd root of 9 = \"" << root(9, 3) << endl;\\n\\n	unsigned long long b = 2e18;\\n	cout << \""2nd root of \"" << b << \"" = \"" << root(b, 2) << endl;\\n\\n	return 0;\\n}"
"C++","Integer_sequence","Create a program that, when run, would display all integers from   1   to      ∞      (or any relevant implementation limit),   in sequence   (i.e.   1, 2, 3, 4, etc)   if given enough time.\\n\\nAn example may not be able to reach arbitrarily-large numbers based on implementations limits.   For example, if integers are represented as a 32-bit unsigned value with 0 as the smallest representable value, the largest representable value would be 4,294,967,295.   Some languages support arbitrarily-large numbers as a built-in feature, while others make use of a module or library.\\nIf appropriate, provide an example which reflect the language implementation's common built-in limits as well as an example which supports arbitrarily large numbers, and describe the nature of such limitations—or lack thereof.\\n\\nFor maximum compatibility, this program uses only the basic instruction set (S/360).\\n","#include <cstdint>\\n#include <iostream>\\n#include <limits>\\n\\nint main()\\n{\\n  auto i = std::uintmax_t{};\\n  \\n  while (i < std::numeric_limits::max())\\n    std::cout << ++i << '\\n';\\n}"
"C++","Inverted_index","An Inverted Index is a data structure used to create full text search.\\n\\nGiven a set of text files, implement a program to create an inverted index.\\nAlso create a user interface to do a search using that inverted index which returns a list of files that contain the query term / terms.\\nThe search index can be in memory.\\n\\nHere is the main program (file inverted_index.adb):\\nA sample output:\\nThe real work is actually done in the package Generic_Inverted_Index. Here is the specification (file generic_inverted_index.ads):\\nHere is the implementation (generic_inverted_index.adb):\\nThe main program also uses an auxiliary package Parse_Lines. Note the usage of Gnat.Regpat, which itself is pattern matching package, specific for gnat/gcc. This package is derived from the Ada implementation of the regular expressions task. Here is the spec (parse_lines.ads):\\nAnd here is the implementation (parse_lines.adb):\\nThe new standard Ada 2012 simplifies the usage of containers significantly. The following runs under gnat (GNAT GPL 2011 (20110419)), when using the experimental -gnat2012 switch. The main program is the same. Here is the spec for Generic_Inverted_Index:\\nThe implementation:\\nThis uses a hashed index and linked lists to hold the file numbers.\\nOutput:\\nThe code is stupidly long, having to implement a Trie to store strings and all -- the program doesn't do anything shiny, but Tries may be interesting to look at.\\nSame idea as the C implementation - trie to store the words\\n","\\n#include <algorithm>\\n#include <fstream>\\n#include <iostream>\\n#include <vector>\\n#include <string>\\n\\nconst std::string _CHARS = \""abcdefghijklmnopqrstuvwxyz0123456789.:-_/\"";\\nconst size_t MAX_NODES = 41;\\n\\nclass node\\n{\\npublic:\\n    node() { clear(); } \\n    node( char z ) { clear(); }\\n    ~node() { for( int x = 0; x < MAX_NODES; x++ ) if( next[x] ) delete next[x]; }\\n    void clear() { for( int x = 0; x < MAX_NODES; x++ ) next[x] = 0; isWord = false; }\\n    bool isWord;\\n    std::vector files;\\n    node* next[MAX_NODES];\\n};\\n\\nclass index {\\npublic:\\n    void add( std::string s, std::string fileName ) {\\n        std::transform( s.begin(), s.end(), s.begin(), tolower );\\n        std::string h;\\n        for( std::string::iterator i = s.begin(); i != s.end(); i++ ) {\\n            if( *i == 32 ) {\\n                pushFileName( addWord( h ), fileName );\\n                h.clear();\\n                continue;\\n            }\\n            h.append( 1, *i );\\n        }\\n        if( h.length() )\\n            pushFileName( addWord( h ), fileName );\\n    }\\n    void findWord( std::string s ) {\\n        std::vector v = find( s );\\n        if( !v.size() ) {\\n            std::cout << s + \"" was not found!\\n\"";\\n            return;\\n        }\\n        std::cout << s << \"" found in:\\n\"";\\n        for( std::vector::iterator i = v.begin(); i != v.end(); i++ ) {\\n            std::cout << *i << \""\\n\"";\\n        }\\n        std::cout << \""\\n\"";\\n    }\\nprivate:\\n    void pushFileName( node* n, std::string fn ) {\\n        std::vector::iterator i = std::find( n->files.begin(), n->files.end(), fn );\\n        if( i == n->files.end() ) n->files.push_back( fn );\\n    }\\n    const std::vector& find( std::string s ) {\\n        size_t idx;\\n        std::transform( s.begin(), s.end(), s.begin(), tolower ); \\n        node* rt = &root\\n        for( std::string::iterator i = s.begin(); i != s.end(); i++ ) {\\n            idx = _CHARS.find( *i );\\n            if( idx < MAX_NODES ) {\\n                if( !rt->next[idx] ) return std::vector(); \\n                rt = rt->next[idx]; \\n            }\\n        } \\n        if( rt->isWord ) return rt->files;\\n        return std::vector();\\n    }\\n    node* addWord( std::string s ) {\\n        size_t idx;\\n        node* rt = &root, *n;\\n        for( std::string::iterator i = s.begin(); i != s.end(); i++ ) {\\n            idx = _CHARS.find( *i );\\n            if( idx < MAX_NODES ) {\\n                n = rt->next[idx]; \\n                if( n ){ \\n                    rt = n; \\n                    continue; \\n                } \\n                n = new node( *i ); \\n                rt->next[idx] = n; \\n                rt = n; \\n            }\\n        }\\n        rt->isWord = true;\\n        return rt;\\n    }\\n    node root;\\n};\\nint main( int argc, char* argv[] ) {\\n    index t;\\n    std::string s;\\n    std::string files[] = { \""file1.txt\"", \""f_text.txt\"", \""text_1b.txt\"" };\\n\\n    for( int x = 0; x < 3; x++ ) {\\n        std::ifstream f;\\n        f.open( files[x].c_str(), std::ios::in );\\n        if( f.good() ) {\\n            while( !f.eof() ) {\\n                f >> s;\\n                t.add( s, files[x] );\\n                s.clear();\\n            }\\n            f.close();\\n        }\\n    }\\n    \\n    while( true ) {\\n        std::cout << \""Enter one word to search for, return to exit: \"";\\n        std::getline( std::cin, s );\\n        if( !s.length() ) break;\\n        t.findWord( s );\\n\\n    }\\n    return 0;\\n}\\n"
"C++","Inverted_syntax","Inverted syntax with conditional expressions\\nIn traditional syntax conditional expressions are usually shown before the action within a statement or code block:\\nIn inverted syntax, the action is listed before the conditional expression in the statement or code block:\\nInverted syntax with assignment\\nIn traditional syntax, assignments are usually expressed with the variable appearing before the expression:\\nIn inverted syntax, the expression appears before the variable:\\nTask\\nThe task is to demonstrate support for inverted syntax forms within the language by showing both the traditional and inverted forms.\\nThe only place where syntax is kind of inverted is exit when to exit loops:\\n","class invertedAssign {\\n  int data;\\npublic:\\n  invertedAssign(int data):data(data){}\\n  int getData(){return data;}\\n  void operator=(invertedAssign& other) const {\\n    other.data = this->data;\\n  }\\n};\\n\\n\\n#include <iostream>\\n\\nint main(){\\n  invertedAssign a = 0;\\n  invertedAssign b = 42;\\n  std::cout << a.getData() << ' ' << b.getData() << '\\n';\\n\\n  b = a;\\n\\n  std::cout << a.getData() << ' ' << b.getData() << '\\n';\\n}"
"C++","Iterated_digits_squaring","If you add the square of the digits of a Natural number (an integer bigger than zero), you always end with either 1 or 89:\\nAn example in Python:\\n\\nOr, for much less credit - (showing that your algorithm and/or language is slow):\\nThis problem derives from the Project Euler problem 92.\\nFor a quick algorithm for this task see the talk page\\n\\n\\nBrute-force with some caching.\\n","\\n#include <iostream>\\n\\n// returns sum of squares of digits of n\\nunsigned int sum_square_digits(unsigned int n) {\\n        int i,num=n,sum=0;\\n        // process digits one at a time until there are none left\\n        while (num > 0) {\\n                // peal off the last digit from the number\\n                int digit=num % 10;\\n                num=(num - digit)/10;\\n                // add it's square to the sum\\n                sum+=digit*digit;\\n        }\\n        return sum;\\n}\\nint main(void) {\\n        unsigned int i=0,result=0, count=0;\\n        for (i=1; i<=100000000; i++) {\\n                // if not 1 or 89, start the iteration\\n                if ((i != 1) || (i != 89)) {\\n                        result = sum_square_digits(i);\\n                }\\n                // otherwise we're done already\\n                else {\\n                        result = i;\\n                }\\n                // while we haven't reached 1 or 89, keep iterating\\n                while ((result != 1) && (result != 89)) {\\n                        result = sum_square_digits(result);\\n                }\\n                if (result == 89) {\\n                        count++;\\n                }\\n        }\\n        std::cout << count << std::endl;\\n        return 0;\\n}\\n"
"C++","Jaro_distance","The Jaro distance is a measure of similarity between two strings.\\nThe higher the Jaro distance for two strings is, the more similar the strings are.\\nThe score is normalized such that   0   equates to no similarity and   1   is an exact match.\\n\\n","#include <algorithm>\\n#include <iostream>\\n#include <string>\\n\\ndouble jaro(const std::string s1, const std::string s2) {\\n    const uint l1 = s1.length(), l2 = s2.length();\\n    if (l1 == 0)\\n        return l2 == 0 ? 1.0 : 0.0;\\n    const uint match_distance = std::max(l1, l2) / 2 - 1;\\n    bool s1_matches[l1];\\n    bool s2_matches[l2];\\n    std::fill(s1_matches, s1_matches + l1, false);\\n    std::fill(s2_matches, s2_matches + l2, false);\\n    uint matches = 0;\\n    for (uint i = 0; i < l1; i++)\\n    {\\n        const int end = std::min(i + match_distance + 1, l2);\\n        for (int k = std::max(0u, i - match_distance); k < end; k++)\\n            if (!s2_matches[k] && s1[i] == s2[k])\\n            {\\n                s1_matches[i] = true;\\n                s2_matches[k] = true;\\n                matches++;\\n                break;\\n            }\\n    }\\n    if (matches == 0)\\n        return 0.0;\\n    double t = 0.0;\\n    uint k = 0;\\n    for (uint i = 0; i < l1; i++)\\n        if (s1_matches[i])\\n        {\\n            while (!s2_matches[k]) k++;\\n            if (s1[i] != s2[k]) t += 0.5;\\n            k++;\\n        }\\n\\n    const double m = matches;\\n    return (m / l1 + m / l2 + (m - t) / m) / 3.0;\\n}\\n\\nint main() {\\n    using namespace std;\\n    cout << jaro(\""MARTHA\"", \""MARHTA\"") << endl;\\n    cout << jaro(\""DIXON\"", \""DICKSONX\"") << endl;\\n    cout << jaro(\""JELLYFISH\"", \""SMELLYFISH\"") << endl;\\n    return 0;\\n}"
"C++","Jensen's_Device","This task is an exercise in call by name.\\nJensen's Device is a computer programming technique devised by Danish computer scientist Jørn Jensen after studying the ALGOL 60 Report.\\nThe following program was proposed to illustrate the technique. It computes the 100th harmonic number:\\nThe above exploits call by name to produce the correct answer (5.187...). It depends on the assumption that an expression passed as an actual parameter to a procedure would be re-evaluated in the caller's context every time the corresponding formal parameter's value was required. If the last parameter to sum had been passed by value, and assuming the initial value of i were 1, the result would have been 100 × 1/1 = 100.\\nMoreover, the first parameter to sum, representing the \""bound\"" variable of the summation, must also be passed by name (or at least by reference), otherwise changes to it (made within sum) would not be visible in the caller's context when computing each of the values to be added.\\n(On the other hand, the global variable does not have to use the same identifier, in this case i, as the formal parameter.)\\nDonald Knuth later proposed the Man or Boy Test as a more rigorous exercise.\\n\\nHonor given where honor is due. In Algol 60, 'call by name' is the default argument evaluation.\\nOutput: +5.18737751763962e +0\\nOutput: 5.18737751764\\nOutput:\\nOutput:\\nOutput: 5.18738\\nAlternatively, C's macros provide a closer imitation of ALGOL's call-by-name semantics:\\nOutput: 5.187378\\nOutput: 5.18738\\nCan be simulated via lambda expressions:\\nWith hindsight Algol60 provided this feature in a way that is terrible for program maintenance, because the calling code looks innocuous.\\nCommon Lisp does not have call-by-name for functions; however, it can be directly simulated by a macro wrapping selected parameters in lambdas.\\nThere are better ways to do this in D, but this is closer to the original Algol version:\\n","#include <iostream>\\n\\nint i;\\ndouble sum(int &i, int lo, int hi, double (*term)()) {\\n    double temp = 0;\\n    for (i = lo; i <= hi; i++)\\n        temp += term();\\n    return temp;\\n}\\n\\ndouble term_func() { return 1.0 / i; }\\n\\nint main () {\\n    std::cout << sum(i, 1, 100, term_func) << std::endl;\\n    return 0;\\n}"
"C++","Jewels_and_Stones","\\nCreate a function which takes two string parameters: 'stones' and 'jewels' and returns an integer.\\nBoth strings can contain any number of upper or lower case letters. However, in the case of 'jewels', all letters must be distinct.\\nThe function should count (and return) how many 'stones' are 'jewels' or, in other words, how many letters in 'stones' are also letters in 'jewels'.\\n\\nNote that:\\nSo, for example, if passed \""aAAbbbb\"" for 'stones' and \""aA\"" for 'jewels', the function should return 3.\\nThis task was inspired by this problem.\\n\\n","#include <algorithm>\\n#include <iostream>\\n\\nint countJewels(const std::string& s, const std::string& j) {\\n    int count = 0;\\n    for (char c : s) {\\n        if (j.find(c) != std::string::npos) {\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\n\\nint main() {\\n    using namespace std;\\n\\n    cout << countJewels(\""aAAbbbb\"", \""aA\"") << endl;\\n    cout << countJewels(\""ZZ\"", \""z\"") << endl;\\n\\n    return 0;\\n}"
"C++","JortSort","jortSort is a sorting toolset that makes the user do the work and guarantees efficiency because you don't have to sort ever again. It was originally presented by Jenn \""Moneydollars\"" Schiffer at the prestigious JSConf.\\njortSort is a function that takes a single array of comparable objects as its argument. It then sorts the array in ascending order and compares the sorted array to the originally provided array. If the arrays match (i.e. the original array was already sorted), the function returns true. If the arrays do not match (i.e. the original array was not sorted), the function returns false.\\n","\\n#include <algorithm>\\n#include <string>\\n#include <iostream>\\n#include <iterator> \\n\\nclass jortSort {\\npublic:\\n    template\\n    bool jort_sort( T* o, size_t s ) {\\n        T* n = copy_array( o, s );\\n        sort_array( n, s );\\n        bool r = false;\\n\\n        if( n ) {\\n            r = check( o, n, s );\\n            delete [] n;\\n        }\\n        return r;\\n    }\\n\\nprivate:\\n    template\\n    T* copy_array( T* o, size_t s ) {\\n        T* z = new T[s];\\n        memcpy( z, o, s * sizeof( T ) );\\n        //std::copy( o, o + s, z );\\n        return z;\\n    }\\n    template\\n    void sort_array( T* n, size_t s ) {\\n        std::sort( n, n + s );\\n    }\\n    template\\n    bool check( T* n, T* o, size_t s ) {\\n        for( size_t x = 0; x < s; x++ )\\n            if( n[x] != o[x] ) return false;\\n        return true;\\n    }\\n};\\n\\njortSort js;\\n\\ntemplate\\nvoid displayTest( T* o, size_t s ) {\\n    std::copy( o, o + s, std::ostream_iterator<T>( std::cout, \"" \"" ) );\\n    std::cout << \"": -> The array is \"" << ( js.jort_sort( o, s ) ? \""sorted!\"" : \""not sorted!\"" ) << \""\\n\\n\"";\\n}\\n\\nint main( int argc, char* argv[] ) {\\n    const size_t s = 5;\\n    std::string oStr[] = { \""5\"", \""A\"", \""D\"", \""R\"", \""S\"" };\\n    displayTest( oStr, s );\\n    std::swap( oStr[0], oStr[1] );\\n    displayTest( oStr, s );\\n\\n    int oInt[] = { 1, 2, 3, 4, 5 };\\n    displayTest( oInt, s );\\n    std::swap( oInt[0], oInt[1] );\\n    displayTest( oInt, s );\\n\\n    return 0;\\n}\\n"
"C++","Josephus_problem","Josephus problem is a math puzzle with a grim description: \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n prisoners are standing on a circle, sequentially numbered from \\n\\n\\n\\n0\\n\\n\\n{\\displaystyle 0}\\n\\n to \\n\\n\\n\\nn\\n−\\n1\\n\\n\\n{\\displaystyle n-1}\\n\\n.\\nAn executioner walks along the circle, starting from prisoner \\n\\n\\n\\n0\\n\\n\\n{\\displaystyle 0}\\n\\n,\\nremoving every \\n\\n\\n\\nk\\n\\n\\n{\\displaystyle k}\\n\\n-th prisoner and killing him.\\nAs the process goes on, the circle becomes smaller and smaller, until only one prisoner remains, who is then freed. >\\nFor example, if there are \\n\\n\\n\\nn\\n=\\n5\\n\\n\\n{\\displaystyle n=5}\\n\\n prisoners and \\n\\n\\n\\nk\\n=\\n2\\n\\n\\n{\\displaystyle k=2}\\n\\n, the order the prisoners are killed in (let's call it the \""killing sequence\"") will be 1, 3, 0, and 4, and the survivor will be #2.\\n\\nGiven any   \\n\\n\\n\\nn\\n,\\nk\\n>\\n0\\n\\n\\n{\\displaystyle n,k>0}\\n\\n,   find out which prisoner will be the final survivor.\\nIn one such incident, there were 41 prisoners and every 3rd prisoner was being killed   (\\n\\n\\n\\nk\\n=\\n3\\n\\n\\n{\\displaystyle k=3}\\n\\n).\\nAmong them was a clever chap name Josephus who worked out the problem, stood at the surviving position, and lived on to tell the tale.\\nWhich number was he?\\n\\nThe captors may be especially kind and let \\n\\n\\n\\nm\\n\\n\\n{\\displaystyle m}\\n\\n survivors free,\\nand Josephus might just have   \\n\\n\\n\\nm\\n−\\n1\\n\\n\\n{\\displaystyle m-1}\\n\\n   friends to save.\\nProvide a way to calculate which prisoner is at any given position on the killing sequence.\\n\\n\\nThe program uses two ASSIST macros (XDECO,XPRNT) to keep the code as short as possible.\\n","\\n#include <iostream>\\n#include <vector>\\n\\n//--------------------------------------------------------------------------------------------------\\nusing namespace std;\\ntypedef unsigned long long bigint;\\n\\n//--------------------------------------------------------------------------------------------------\\nclass josephus\\n{\\npublic:\\n    bigint findSurvivors( bigint n, bigint k, bigint s = 0 )\\n    {\\n	bigint i = s + 1;\\n	for( bigint x = i; x <= n; x++, i++ )\\n	    s = ( s + k ) % i;\\n\\n	return s;\\n    }\\n\\n    void getExecutionList( bigint n, bigint k, bigint s = 1 )\\n    {\\n	cout << endl << endl << \""Execution list: \"" << endl;\\n\\n	prisoners.clear();\\n	for( bigint x = 0; x < n; x++ )\\n	    prisoners.push_back( x );\\n\\n	bigint index = 0;\\n	while( prisoners.size() > s )\\n	{\\n	    index += k - 1;\\n	    if( index >= prisoners.size() ) index %= prisoners.size();\\n	    cout << prisoners[static_cast( index )] << \"", \"";\\n\\n	    vector<bigint>::iterator it = prisoners.begin() + static_cast( index );\\n	    prisoners.erase( it );\\n	}\\n    }\\n\\nprivate:\\n    vector<bigint> prisoners;\\n};\\n//--------------------------------------------------------------------------------------------------\\nint main( int argc, char* argv[] )\\n{\\n    josephus jo;\\n    bigint n, k, s;\\n    while( true )\\n    {\\n	system( \""cls\"" );\\n	cout << \""Number of prisoners( 0 to QUIT ): \""; cin >> n;\\n	if( !n ) return 0;\\n	cout << \""Execution step: \""; cin >> k;\\n	cout << \""How many survivors: \""; cin >> s;\\n		\\n	cout << endl << \""Survivor\"";\\n	if( s == 1 )\\n	{\\n	    cout << \"": \"" << jo.findSurvivors( n, k );\\n	    jo.getExecutionList( n, k );\\n	}\\n	else\\n	{\\n	    cout << \""s: \"";\\n	    for( bigint x = 0; x < s; x++ )\\n		cout << jo.findSurvivors( n, k, x ) << \"", \"";\\n\\n	    jo.getExecutionList( n, k, s );\\n	}\\n\\n	cout << endl << endl;\\n	system( \""pause\"" );\\n    }\\n    return 0;\\n}\\n//--------------------------------------------------------------------------------------------------\\n"
"C++","JSON","Load a JSON string into a data structure.\\nAlso, create a new data structure and serialize it into JSON.\\nUse objects and arrays (as appropriate for your language)\\nand make sure your JSON is valid (https://jsonformatter.org, https://codebeautify.org/jsonvalidator, https://jsonlint.com/ or https://extendsclass.com/json-validator.html).\\n\\n8th uses JSON as its data description language, so:\\nPrints an array of [1,2,3].\\nConverting a string to an object:\\nTakes the string and converts to the JSON object (which is an 8th object). Convert back to a string:\\nThat takes the object and converts to the JSON string given above.\\n","#include \""Core/Core.h\""\\n\\nusing namespace Upp;\\n\\nCONSOLE_APP_MAIN\\n{\\n	JsonArray a;\\n	a << Json(\""name\"", \""John\"")(\""phone\"", \""1234567\"") << Json(\""name\"", \""Susan\"")(\""phone\"", \""654321\"");\\n	String txt = ~a;\\n	Cout() << txt << '\\n';\\n	Value v = ParseJSON(txt);\\n	for(int i = 0; i < v.GetCount(); i++)\\n		Cout() << v[i][\""name\""] << ' ' << v[i][\""phone\""] << '\\n';\\n}\\n"
"C++","JSON","Load a JSON string into a data structure.\\nAlso, create a new data structure and serialize it into JSON.\\nUse objects and arrays (as appropriate for your language)\\nand make sure your JSON is valid (https://jsonformatter.org, https://codebeautify.org/jsonvalidator, https://jsonlint.com/ or https://extendsclass.com/json-validator.html).\\n\\n8th uses JSON as its data description language, so:\\nPrints an array of [1,2,3].\\nConverting a string to an object:\\nTakes the string and converts to the JSON object (which is an 8th object). Convert back to a string:\\nThat takes the object and converts to the JSON string given above.\\n","#include <iostream>\\n#include <iomanip> // std::setw\\n#include <sstream>\\n#include <cassert>\\n\\n#include \""json.hpp\""\\n\\nusing json = nlohmann::json;\\n\\nint main( int argc, char* argv[] )\\n{\\n        std::string const expected =\\nR\""delim123({\\n    \""answer\"": {\\n        \""everything\"": 42\\n    },\\n    \""happy\"": true,\\n    \""list\"": [\\n        1,\\n        0,\\n        2\\n    ],\\n    \""name\"": \""Niels\"",\\n    \""nothing\"": null,\\n    \""object\"": {\\n        \""currency\"": \""USD\"",\\n        \""value\"": 42.99\\n    },\\n    \""pi\"": 3.141\\n})delim123\"";\\n\\n    json const jexpected = json::parse( expected );\\n\\n    assert( jexpected[\""list\""][1].get<int>() == 0 );\\n    assert( jexpected[\""object\""][\""currency\""] == \""USD\"" );\\n\\n    json jhandmade = {\\n        {\""pi\"", 3.141},\\n        {\""happy\"", true},\\n        {\""name\"", \""Niels\""},\\n        {\""nothing\"", nullptr},\\n        {\""answer\"", {\\n             {\""everything\"", 42}\\n         }\\n        },\\n        {\""list\"", {1, 0, 2}},\\n        {\""object\"", {\\n             {\""currency\"", \""USD\""},\\n             {\""value\"", 42.99}\\n         }\\n        }\\n    };\\n\\n    assert( jexpected == jhandmade );\\n\\n    std::stringstream jhandmade_stream;\\n    jhandmade_stream << std::setw(4) << jhandmade;\\n\\n    std::string jhandmade_string = jhandmade.dump(4);\\n\\n    assert( jhandmade_string == expected );\\n    assert( jhandmade_stream.str() == expected );\\n    \\n    return 0;    \\n}\\n"
"C++","Julia_set","Generate and draw a Julia set.\\n\\n\\n\\nUses the Algol 68G specific argc and argv procedures. Note argv( 1 ) is the path of the Algol 68G interpreter and argv( 2 ) is the source being executed.\\n","\\n#include <windows.h>\\n#include <string>\\n#include <complex>\\n\\nconst int BMP_SIZE = 600, ITERATIONS = 512;\\nconst long double FCT = 2.85, hFCT = FCT / 2.0;\\n\\nclass myBitmap {\\npublic:\\n    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}\\n    ~myBitmap() {\\n        DeleteObject( pen ); DeleteObject( brush );\\n        DeleteDC( hdc ); DeleteObject( bmp );\\n    }\\n    bool create( int w, int h ) {\\n        BITMAPINFO bi;\\n        ZeroMemory( &bi, sizeof( bi ) );\\n        bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );\\n        bi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;\\n        bi.bmiHeader.biCompression = BI_RGB;\\n        bi.bmiHeader.biPlanes      = 1;\\n        bi.bmiHeader.biWidth       =  w;\\n        bi.bmiHeader.biHeight      = -h;\\n        HDC dc = GetDC( GetConsoleWindow() );\\n        bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );\\n        if( !bmp ) return false;\\n        hdc = CreateCompatibleDC( dc );\\n        SelectObject( hdc, bmp );\\n        ReleaseDC( GetConsoleWindow(), dc );\\n        width = w; height = h;\\n        return true;\\n    }\\n    void clear( BYTE clr = 0 ) {\\n        memset( pBits, clr, width * height * sizeof( DWORD ) );\\n    }\\n    void setBrushColor( DWORD bClr ) {\\n        if( brush ) DeleteObject( brush );\\n        brush = CreateSolidBrush( bClr );\\n        SelectObject( hdc, brush );\\n    }\\n    void setPenColor( DWORD c ) {\\n        clr = c; createPen();\\n    }\\n    void setPenWidth( int w ) {\\n        wid = w; createPen();\\n    }\\n    void saveBitmap( std::string path ) {\\n        BITMAPFILEHEADER fileheader;\\n        BITMAPINFO       infoheader;\\n        BITMAP           bitmap;\\n        DWORD            wb;\\n        GetObject( bmp, sizeof( bitmap ), &bitmap );\\n        DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];\\n        ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );\\n        ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );\\n        ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );\\n        infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;\\n        infoheader.bmiHeader.biCompression = BI_RGB;\\n        infoheader.bmiHeader.biPlanes = 1;\\n        infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );\\n        infoheader.bmiHeader.biHeight = bitmap.bmHeight;\\n        infoheader.bmiHeader.biWidth = bitmap.bmWidth;\\n        infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );\\n        fileheader.bfType    = 0x4D42;\\n        fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );\\n        fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;\\n        GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );\\n        HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, \\n            FILE_ATTRIBUTE_NORMAL, NULL );\\n        WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );\\n        WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );\\n        WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );\\n        CloseHandle( file );\\n        delete [] dwpBits;\\n    }\\n    HDC getDC() const     { return hdc; }\\n    int getWidth() const  { return width; }\\n    int getHeight() const { return height; }\\n    DWORD* bits() const { return ( DWORD* )pBits; }\\nprivate:\\n    void createPen() {\\n        if( pen ) DeleteObject( pen );\\n        pen = CreatePen( PS_SOLID, wid, clr );\\n        SelectObject( hdc, pen );\\n    }\\n    HBITMAP bmp; HDC    hdc;\\n    HPEN    pen; HBRUSH brush;\\n    void    *pBits; int    width, height, wid;\\n    DWORD    clr;\\n};\\nclass julia {\\npublic:\\n    void draw( std::complex k ) {\\n        bmp.create( BMP_SIZE, BMP_SIZE );\\n        DWORD* bits = bmp.bits();\\n        int res, pos;\\n        std::complex c, factor( FCT / BMP_SIZE, FCT / BMP_SIZE ) ;\\n\\n        for( int y = 0; y < BMP_SIZE; y++ ) {\\n            pos = y * BMP_SIZE;\\n\\n            c.imag( ( factor.imag() * y ) + -hFCT );\\n\\n            for( int x = 0; x < BMP_SIZE; x++ ) {\\n                c.real( factor.real() * x + -hFCT );\\n                res = inSet( c, k );\\n                if( res ) {\\n                    int n_res = res % 255;\\n                    if( res < ( ITERATIONS >> 1 ) ) res = RGB( n_res << 2, n_res << 3, n_res << 4 );\\n                    else res = RGB( n_res << 4, n_res << 2, n_res << 5 );\\n                }\\n                bits[pos++] = res;\\n            }\\n        }\\n        bmp.saveBitmap( \""./js.bmp\"" );\\n    }\\nprivate:\\n    int inSet( std::complex z, std::complex c ) {\\n        long double dist;//, three = 3.0;\\n        for( int ec = 0; ec < ITERATIONS; ec++ ) {\\n            z = z * z; z = z + c;\\n            dist = ( z.imag() * z.imag() ) + ( z.real() * z.real() );\\n            if( dist > 3 ) return( ec );\\n        }\\n        return 0;\\n    }\\n    myBitmap bmp;\\n};\\nint main( int argc, char* argv[] ) {\\n    std::complex c;\\n    long double factor = FCT / BMP_SIZE;\\n    c.imag( ( factor * 184 ) + -1.4 );\\n    c.real( ( factor * 307 ) + -2.0 );\\n    julia j; j.draw( c ); return 0;    \\n}\\n"
"C++","Just_in_time_processing_on_a_character_stream","Given a stream of characters, presumably (simulated) from a keyboard, that contain the separators \""formfeed\"", \""linefeed\"", \""tab\"" and \""space\"" characters. Print out the ith character of the ith tab-field of the ith line of the ith page to reveal a secret password.\\nStop processing immediately upon encountering a \""!\"" found uniquely in this i,i,i,i position (least the system self destruct). The \""!\"" may be found/permitted else where however, in which case it should be ignored.\\nIdeally this can be generalise as follows:\\nProvide a reasonably interesting message to be decoded, e.g. Silence-Dogood. Your choice.\\nThis task was inspired by the movie \""National Treasure\"" with refers to a \""book cipher\"".\\nText used to encode:The Raven - by E.A.Poe\\n","\\n#include <vector>\\n#include <iostream>\\n#include <fstream>\\n#include <sstream>\\n\\ntypedef struct {\\n    int s[4];\\n}userI;\\n\\nclass jit{\\npublic:\\n    void decode( std::string& file, std::vector<userI>& ui ) {\\n        std::ifstream f( file.c_str(), std::ios_base::in );\\n        fileBuffer = std::string( ( std::istreambuf_iterator<char>( f ) ), std::istreambuf_iterator<char>() );\\n        f.close();\\n        for( std::vector<userI>::iterator t = ui.begin(); t != ui.end(); t++ ) {\\n            if( !decode( ( *t ).s ) ) break;\\n        }\\n        std::cout << \""\\n\\n\"";\\n    }\\nprivate:\\n    bool decode( int* ui ) {\\n        int l = 0, t = 0, p = 0, c = 0, a = 0;\\n        for( std::string::iterator i = fileBuffer.begin(); i != fileBuffer.end(); i++ ) {\\n            if( p == ui[0] && l == ui[1] && t == ui[2] && c == ui[3] ) {\\n                if( *i == '!' )  return false;\\n                std::cout << *i; return true;\\n            }\\n            if( *i == '\\n' )      { l++; t = c = 0; }  \\n            else if( *i == '\\t' ) { t++; c = 0; }\\n            else if( *i == '\\f' ) { p++; l = t = c = 0; }\\n            else                  { c++;}\\n        }\\n        return false;\\n    }\\n    std::string fileBuffer;\\n};\\nvoid getUserInput( std::vector<userI>& u ) {\\n    std::string h = \""0 18 0 0 0 68 0 1 0 100 0 32 0 114 0 45 0 38 0 26 0 16 0 21 0 17 0 59 0 11 \""\\n                    \""0 29 0 102 0 0 0 10 0 50 0 39 0 42 0 33 0 50 0 46 0 54 0 76 0 47 0 84 2 28\"";\\n    //std::getline( std::cin, h );\\n    std::stringstream ss( h );\\n    userI a;\\n    int x = 0;\\n    while( std::getline( ss, h, ' ' ) ) {\\n        a.s[x] = atoi( h.c_str() );\\n        if( ++x == 4 ) {\\n            u.push_back( a );\\n            x = 0;\\n        }\\n    }\\n}\\nint main( int argc, char* argv[] ) {\\n    std::vector<userI> ui;\\n    getUserInput( ui );\\n\\n    jit j;\\n    j.decode( std::string( \""theRaven.txt\"" ), ui );\\n    return 0;\\n}\\n"
"C++","Kahan_summation","\\n","#include <iostream>\\n\\nfloat epsilon() {\\n    float eps = 1.0f;\\n    while (1.0f + eps != 1.0f) eps /= 2.0f;\\n    return eps;\\n}\\n\\nfloat kahanSum(std::initializer_list<float> nums) {\\n    float sum = 0.0f;\\n    float c = 0.0f;\\n    for (auto num : nums) {\\n        float y = num - c;\\n        float t = sum + y;\\n        c = (t - sum) - y;\\n        sum = t;\\n    }\\n    return sum;\\n}\\n\\nint main() {\\n    using namespace std;\\n\\n    float a = 1.f;\\n    float b = epsilon();\\n    float c = -b;\\n\\n    cout << \""Epsilon      = \"" << b << endl;\\n    cout << \""(a + b) + c  = \"" << (a + b) + c << endl;\\n    cout << \""Kahan sum    = \"" << kahanSum({ a, b, c }) << endl;\\n\\n    return 0;\\n}"
"C++","Kaprekar_numbers","A positive integer is a Kaprekar number if:\\nNote that a split resulting in a part consisting purely of 0s is not valid,\\nas 0 is not considered positive.\\n10000 (1002) splitting from left to right:\\nGenerate and show all Kaprekar numbers less than 10,000.\\nOptionally, count (and report the count of) how many Kaprekar numbers are less than 1,000,000.\\nThe concept of Kaprekar numbers is not limited to base 10 (i.e. decimal numbers);\\nif you can, show that Kaprekar numbers exist in other bases too.\\nFor this purpose, do the following:\\n\\n","#include <vector>\\n#include <string>\\n#include <iostream>\\n#include <sstream>\\n#include <algorithm>\\n#include <iterator>\\n#include <utility>\\n\\nlong string2long( const std::string & s ) {\\n   long result ;\\n   std::istringstream( s ) >> result ;\\n   return result ;\\n}\\n\\nbool isKaprekar( long number ) {\\n   long long squarenumber = ((long long)number) * number ;\\n   std::ostringstream numberbuf ;\\n   numberbuf << squarenumber ;\\n   std::string numberstring = numberbuf.str( ) ;\\n   for ( int i = 0 ; i < numberstring.length( ) ; i++ ) {\\n      std::string firstpart = numberstring.substr( 0 , i ) ,\\n                  secondpart = numberstring.substr( i ) ;\\n      //we do not accept figures ending in a sequence of zeroes\\n      if ( secondpart.find_first_not_of( \""0\"" ) == std::string::npos ) {\\n	 return false ;\\n      }\\n      if ( string2long( firstpart ) + string2long( secondpart ) == number ) {\\n	 return true ;\\n      }\\n   }\\n   return false ;\\n}\\n\\nint main( ) {\\n   std::vector<long> kaprekarnumbers ;\\n   kaprekarnumbers.push_back( 1 ) ;\\n   for ( int i = 2 ; i < 1000001 ; i++ ) {\\n      if ( isKaprekar( i ) ) \\n	 kaprekarnumbers.push_back( i ) ;\\n   }\\n   std::vector<long>::const_iterator svi = kaprekarnumbers.begin( ) ;\\n   std::cout << \""Kaprekar numbers up to 10000: \\n\"" ;\\n   while ( *svi < 10000 ) {\\n      std::cout << *svi << \"" \"" ;\\n      svi++ ;\\n   }\\n   std::cout << '\\n' ;\\n   std::cout << \""All the Kaprekar numbers up to 1000000 :\\n\"" ;\\n   std::copy( kaprekarnumbers.begin( ) , kaprekarnumbers.end( ) ,\\n	 std::ostream_iterator<long>( std::cout , \""\\n\"" ) ) ;\\n   std::cout << \""There are \"" << kaprekarnumbers.size( )\\n      << \"" Kaprekar numbers less than one million!\\n\"" ;\\n   return 0 ;\\n}"
"C++","Kaprekar_numbers","A positive integer is a Kaprekar number if:\\nNote that a split resulting in a part consisting purely of 0s is not valid,\\nas 0 is not considered positive.\\n10000 (1002) splitting from left to right:\\nGenerate and show all Kaprekar numbers less than 10,000.\\nOptionally, count (and report the count of) how many Kaprekar numbers are less than 1,000,000.\\nThe concept of Kaprekar numbers is not limited to base 10 (i.e. decimal numbers);\\nif you can, show that Kaprekar numbers exist in other bases too.\\nFor this purpose, do the following:\\n\\n","\\n// Generate Kaperkar Numbers\\n//\\n// Nigel Galloway. June 24th., 2012\\n//\\n#include <iostream>\\nint main() {\\n	const int Base = 10;\\n	const int N = 6;\\n	int Paddy_cnt = 0;\\n	for (int nz=1; nz<=N; nz++)\\n		for (unsigned long long int k=pow((double)Base,nz-1); k\\nProduces:\\n<pre>1: 1 is 0 + 1 and squared is 1. It is a member of Residual Set 1\\n2: 9 is 8 + 1 and squared is 81. It is a member of Residual Set 0\\n3: 45 is 20 + 25 and squared is 2025. It is a member of Residual Set 0\\n4: 55 is 30 + 25 and squared is 3025. It is a member of Residual Set 1\\n5: 99 is 98 + 1 and squared is 9801. It is a member of Residual Set 0\\n6: 297 is 88 + 209 and squared is 88209. It is a member of Residual Set 0\\n7: 703 is 494 + 209 and squared is 494209. It is a member of Residual Set 1\\n8: 999 is 998 + 1 and squared is 998001. It is a member of Residual Set 0\\n9: 2223 is 494 + 1729 and squared is 4941729. It is a member of Residual Set 0\\n10: 2728 is 744 + 1984 and squared is 7441984. It is a member of Residual Set 1\\n11: 4879 is 238 + 4641 and squared is 23804641. It is a member of Residual Set 1\\n12: 4950 is 2450 + 2500 and squared is 24502500. It is a member of Residual Set 0\\n13: 5050 is 2550 + 2500 and squared is 25502500. It is a member of Residual Set 1\\n14: 5292 is 28 + 5264 and squared is 28005264. It is a member of Residual Set 0\\n15: 7272 is 5288 + 1984 and squared is 52881984. It is a member of Residual Set 0\\n16: 7777 is 6048 + 1729 and squared is 60481729. It is a member of Residual Set 1\\n17: 9999 is 9998 + 1 and squared is 99980001. It is a member of Residual Set 0\\n18: 17344 is 3008 + 14336 and squared is 300814336. It is a member of Residual Set 1\\n19: 22222 is 4938 + 17284 and squared is 493817284. It is a member of Residual Set 1\\n20: 38962 is 1518 + 37444 and squared is 1518037444. It is a member of Residual Set 1\\n21: 77778 is 60494 + 17284 and squared is 6049417284. It is a member of Residual Set 0\\n22: 82656 is 68320 + 14336 and squared is 6832014336. It is a member of Residual Set 0\\n23: 95121 is 90480 + 4641 and squared is 9048004641. It is a member of Residual Set 0\\n24: 99999 is 99998 + 1 and squared is 9999800001. It is a member of Residual Set 0\\n25: 142857 is 20408 + 122449 and squared is 20408122449. It is a member of Residual Set 0\\n26: 148149 is 21948 + 126201 and squared is 21948126201. It is a member of Residual Set 0\\n27: 181819 is 33058 + 148761 and squared is 33058148761. It is a member of Residual Set 1\\n28: 187110 is 35010 + 152100 and squared is 35010152100. It is a member of Residual Set 0\\n29: 208495 is 43470 + 165025 and squared is 43470165025. It is a member of Residual Set 1\\n30: 318682 is 101558 + 217124 and squared is 101558217124. It is a member of Residual Set 1\\n31: 329967 is 108878 + 221089 and squared is 108878221089. It is a member of Residual Set 0\\n32: 351352 is 123448 + 227904 and squared is 123448227904. It is a member of Residual Set 1\\n33: 356643 is 127194 + 229449 and squared is 127194229449. It is a member of Residual Set 0\\n34: 390313 is 152344 + 237969 and squared is 152344237969. It is a member of Residual Set 1\\n35: 461539 is 213018 + 248521 and squared is 213018248521. It is a member of Residual Set 1\\n36: 466830 is 217930 + 248900 and squared is 217930248900. It is a member of Residual Set 0\\n37: 499500 is 249500 + 250000 and squared is 249500250000. It is a member of Residual Set 0\\n38: 500500 is 250500 + 250000 and squared is 250500250000. It is a member of Residual Set 1\\n39: 533170 is 284270 + 248900 and squared is 284270248900. It is a member of Residual Set 1\\n40: 538461 is 289940 + 248521 and squared is 289940248521. It is a member of Residual Set 0\\n41: 609687 is 371718 + 237969 and squared is 371718237969. It is a member of Residual Set 0\\n42: 627615 is 39390 + 588225 and squared is 393900588225. It is a member of Residual Set 0\\n43: 643357 is 413908 + 229449 and squared is 413908229449. It is a member of Residual Set 1\\n44: 648648 is 420744 + 227904 and squared is 420744227904. It is a member of Residual Set 0\\n45: 670033 is 448944 + 221089 and squared is 448944221089. It is a member of Residual Set 1\\n46: 681318 is 464194 + 217124 and squared is 464194217124. It is a member of Residual Set 0\\n47: 791505 is 626480 + 165025 and squared is 626480165025. It is a member of Residual Set 0\\n48: 812890 is 660790 + 152100 and squared is 660790152100. It is a member of Residual Set 1\\n49: 818181 is 669420 + 148761 and squared is 669420148761. It is a member of Residual Set 0\\n50: 851851 is 725650 + 126201 and squared is 725650126201. It is a member of Residual Set 1\\n51: 857143 is 734694 + 122449 and squared is 734694122449. It is a member of Residual Set 1\\n52: 961038 is 923594 + 37444 and squared is 923594037444. It is a member of Residual Set 0\\n53: 994708 is 989444 + 5264 and squared is 989444005264. It is a member of Residual Set 1\\n54: 999999 is 999998 + 1 and squared is 999998000001. It is a member of Residual Set 0"
"C++","Kaprekar_numbers","A positive integer is a Kaprekar number if:\\nNote that a split resulting in a part consisting purely of 0s is not valid,\\nas 0 is not considered positive.\\n10000 (1002) splitting from left to right:\\nGenerate and show all Kaprekar numbers less than 10,000.\\nOptionally, count (and report the count of) how many Kaprekar numbers are less than 1,000,000.\\nThe concept of Kaprekar numbers is not limited to base 10 (i.e. decimal numbers);\\nif you can, show that Kaprekar numbers exist in other bases too.\\nFor this purpose, do the following:\\n\\n","\\nconst int Base = 16;\\nconst int N = 4;\\nstd::cout << std::dec << ++Paddy_cnt << \"": \"" << std::hex << k << \"" is \""  << q << \"" + \"" << (int)nr << \"" and squared is \"" << k*k << \"". It is a member of Residual Set \"" << k%(Base-1) << \""\\n\"";\\n"
"C++","Kaprekar_numbers","A positive integer is a Kaprekar number if:\\nNote that a split resulting in a part consisting purely of 0s is not valid,\\nas 0 is not considered positive.\\n10000 (1002) splitting from left to right:\\nGenerate and show all Kaprekar numbers less than 10,000.\\nOptionally, count (and report the count of) how many Kaprekar numbers are less than 1,000,000.\\nThe concept of Kaprekar numbers is not limited to base 10 (i.e. decimal numbers);\\nif you can, show that Kaprekar numbers exist in other bases too.\\nFor this purpose, do the following:\\n\\n","// Generate Kaprekar Numbers using Casting Out Nines Generator\\n//\\n// Nigel Galloway. July 13th., 2012\\n//\\n#include <cmath>\\nint main() {\\n	const ran r(10);\\n	int Paddy_cnt = 0;\\n	for (int nz=1; nz<=6; nz++)\\n		for (unsigned long long int k : co9(std::pow(r.base,nz-1),std::pow(r.base,nz)-1,&r))\\n			for (int n=nz; n\\nProduces:\\n<pre>1: 1 is 0 + 1 and squared is 1. It is a member of Residual Set 1\\n2: 9 is 8 + 1 and squared is 81. It is a member of Residual Set 0\\n3: 45 is 20 + 25 and squared is 2025. It is a member of Residual Set 0\\n4: 55 is 30 + 25 and squared is 3025. It is a member of Residual Set 1\\n5: 99 is 98 + 1 and squared is 9801. It is a member of Residual Set 0\\n6: 297 is 88 + 209 and squared is 88209. It is a member of Residual Set 0\\n7: 703 is 494 + 209 and squared is 494209. It is a member of Residual Set 1\\n8: 999 is 998 + 1 and squared is 998001. It is a member of Residual Set 0\\n9: 2223 is 494 + 1729 and squared is 4941729. It is a member of Residual Set 0\\n10: 2728 is 744 + 1984 and squared is 7441984. It is a member of Residual Set 1\\n11: 4879 is 238 + 4641 and squared is 23804641. It is a member of Residual Set 1\\n12: 4950 is 2450 + 2500 and squared is 24502500. It is a member of Residual Set 0\\n13: 5050 is 2550 + 2500 and squared is 25502500. It is a member of Residual Set 1\\n14: 5292 is 28 + 5264 and squared is 28005264. It is a member of Residual Set 0\\n15: 7272 is 5288 + 1984 and squared is 52881984. It is a member of Residual Set 0\\n16: 7777 is 6048 + 1729 and squared is 60481729. It is a member of Residual Set 1\\n17: 9999 is 9998 + 1 and squared is 99980001. It is a member of Residual Set 0\\n18: 17344 is 3008 + 14336 and squared is 300814336. It is a member of Residual Set 1\\n19: 22222 is 4938 + 17284 and squared is 493817284. It is a member of Residual Set 1\\n20: 38962 is 1518 + 37444 and squared is 1518037444. It is a member of Residual Set 1\\n21: 77778 is 60494 + 17284 and squared is 6049417284. It is a member of Residual Set 0\\n22: 82656 is 68320 + 14336 and squared is 6832014336. It is a member of Residual Set 0\\n23: 95121 is 90480 + 4641 and squared is 9048004641. It is a member of Residual Set 0\\n24: 99999 is 99998 + 1 and squared is 9999800001. It is a member of Residual Set 0\\n25: 142857 is 20408 + 122449 and squared is 20408122449. It is a member of Residual Set 0\\n26: 148149 is 21948 + 126201 and squared is 21948126201. It is a member of Residual Set 0\\n27: 181819 is 33058 + 148761 and squared is 33058148761. It is a member of Residual Set 1\\n28: 187110 is 35010 + 152100 and squared is 35010152100. It is a member of Residual Set 0\\n29: 208495 is 43470 + 165025 and squared is 43470165025. It is a member of Residual Set 1\\n30: 318682 is 101558 + 217124 and squared is 101558217124. It is a member of Residual Set 1\\n31: 329967 is 108878 + 221089 and squared is 108878221089. It is a member of Residual Set 0\\n32: 351352 is 123448 + 227904 and squared is 123448227904. It is a member of Residual Set 1\\n33: 356643 is 127194 + 229449 and squared is 127194229449. It is a member of Residual Set 0\\n34: 390313 is 152344 + 237969 and squared is 152344237969. It is a member of Residual Set 1\\n35: 461539 is 213018 + 248521 and squared is 213018248521. It is a member of Residual Set 1\\n36: 466830 is 217930 + 248900 and squared is 217930248900. It is a member of Residual Set 0\\n37: 499500 is 249500 + 250000 and squared is 249500250000. It is a member of Residual Set 0\\n38: 500500 is 250500 + 250000 and squared is 250500250000. It is a member of Residual Set 1\\n39: 533170 is 284270 + 248900 and squared is 284270248900. It is a member of Residual Set 1\\n40: 538461 is 289940 + 248521 and squared is 289940248521. It is a member of Residual Set 0\\n41: 609687 is 371718 + 237969 and squared is 371718237969. It is a member of Residual Set 0\\n42: 627615 is 39390 + 588225 and squared is 393900588225. It is a member of Residual Set 0\\n43: 643357 is 413908 + 229449 and squared is 413908229449. It is a member of Residual Set 1\\n44: 648648 is 420744 + 227904 and squared is 420744227904. It is a member of Residual Set 0\\n45: 670033 is 448944 + 221089 and squared is 448944221089. It is a member of Residual Set 1\\n46: 681318 is 464194 + 217124 and squared is 464194217124. It is a member of Residual Set 0\\n47: 791505 is 626480 + 165025 and squared is 626480165025. It is a member of Residual Set 0\\n48: 812890 is 660790 + 152100 and squared is 660790152100. It is a member of Residual Set 1\\n49: 818181 is 669420 + 148761 and squared is 669420148761. It is a member of Residual Set 0\\n50: 851851 is 725650 + 126201 and squared is 725650126201. It is a member of Residual Set 1\\n51: 857143 is 734694 + 122449 and squared is 734694122449. It is a member of Residual Set 1\\n52: 961038 is 923594 + 37444 and squared is 923594037444. It is a member of Residual Set 0\\n53: 994708 is 989444 + 5264 and squared is 989444005264. It is a member of Residual Set 1\\n54: 999999 is 999998 + 1 and squared is 999998000001. It is a member of Residual Set 0"
"C++","Kaprekar_numbers","A positive integer is a Kaprekar number if:\\nNote that a split resulting in a part consisting purely of 0s is not valid,\\nas 0 is not considered positive.\\n10000 (1002) splitting from left to right:\\nGenerate and show all Kaprekar numbers less than 10,000.\\nOptionally, count (and report the count of) how many Kaprekar numbers are less than 1,000,000.\\nThe concept of Kaprekar numbers is not limited to base 10 (i.e. decimal numbers);\\nif you can, show that Kaprekar numbers exist in other bases too.\\nFor this purpose, do the following:\\n\\n","\\n	const ran r = ran(16);\\n					std::cout << std::dec << ++Paddy_cnt << \"": \"" << std::hex << k << \"" is \""  << q << \"" + \"" << (int)nr << \"" and squared is \"" << k*k << \"". It is a member of Residual Set \"" << k%(r.base-1) << \""\\n\"";\\n"
"C++","Kernighans_large_earthquake_problem","Brian Kernighan, in a lecture at the University of Nottingham, described a problem on which this task is based.\\nYou are given a a data file of thousands of lines; each of three `whitespace` separated fields: a date, a one word name and the magnitude of the event.\\nExample lines from the file would be lines like:\\n\\nNew version:\\n","// Randizo was here!\\n#include <iostream>\\n#include <fstream>\\n#include <string>\\nusing namespace std;\\n\\nint main()\\n{\\n    ifstream file(\""../include/earthquake.txt\"");\\n\\n    int count_quake = 0;\\n    int column = 1;\\n    string value;\\n    double size_quake;\\n    string row = \""\"";\\n\\n\\n    while(file >> value)\\n    {\\n        if(column == 3)\\n        {\\n            size_quake = stod(value);\\n\\n            if(size_quake>6.0)\\n            {\\n                count_quake++;\\n                row += value + \""\\t\"";\\n                cout << row << endl;\\n            }\\n\\n            column = 1;\\n            row = \""\"";\\n        }\\n        else\\n        {\\n            column++;\\n            row+=value + \""\\t\"";\\n        }\\n    }\\n\\n    cout << \""\\nNumber of quakes greater than 6 is \"" << count_quake << endl;\\n\\n    return 0;\\n}"
"C++","Kernighans_large_earthquake_problem","Brian Kernighan, in a lecture at the University of Nottingham, described a problem on which this task is based.\\nYou are given a a data file of thousands of lines; each of three `whitespace` separated fields: a date, a one word name and the magnitude of the event.\\nExample lines from the file would be lines like:\\n\\nNew version:\\n","// Jolkdarr was also here!\\n#include <iostream>\\n#include <iomanip>\\n#include <fstream>\\n#include <string>\\n\\nint main() {\\n    using namespace std;\\n    ifstream file(\""data.txt\"");\\n    int count_quake = 0;\\n    string s1, s2;\\n    double rate;\\n    while (!file.eof()) {\\n        file >> s1 >> s2 >> rate;\\n        if (rate > 6.0) {\\n        	cout << s1 << setw(20) << s2 << \"" \"" << rate << endl;\\n        	count_quake++;\\n        }\\n    }\\n\\n    cout << endl << \""Number of quakes greater than 6 is \"" << count_quake << endl;\\n    return 0;\\n}"
"C++","Keyboard_input/Obtain_a_Y_or_N_response","\\nObtain a valid   Y   or   N   response from the keyboard.\\nThe keyboard should be flushed, so that any outstanding key-presses are removed, preventing any existing   Y   or   N   key-press from being evaluated.\\nThe response should be obtained as soon as   Y   or   N   are pressed, and there should be no need to press an   enter   key.\\n\\n","#include <conio.h>\\n#include <iostream>\\n\\nusing namespace std;\\n\\nint main()\\n{\\n	char ch;\\n	_cputs( \""Yes or no?\"" );\\n	do\\n	{\\n		ch = _getch();\\n		ch = toupper( ch );\\n	} while(ch!='Y'&&ch!='N');\\n\\n	if(ch=='N')\\n	{\\n		cout << \""You said no\"" << endl;\\n	}\\n	else\\n	{\\n		cout << \""You said yes\"" << endl;\\n	}\\n	return 0;\\n}\\n"
"C++","Knapsack_problem/0-1","A tourist wants to make a good trip at the weekend with his friends.\\nThey will go to the mountains to see the wonders of nature, so he needs to pack well for the trip.\\nHe has a good knapsack for carrying things, but knows that he can carry a maximum of only 4kg in it,   and it will have to last the whole day.\\nHe creates a list of what he wants to bring for the trip but the total weight of all items is too much.\\nHe then decides to add columns to his initial list detailing their weights and a numerical value representing how important the item is for the trip.\\n\\nHere is the list:\\n\\nThe tourist can choose to take any combination of items from the list,\\nbut only one of each item is available.\\nHe may not cut or diminish the items, so he can only take whole units of any item.\\n\\nShow which items the tourist can carry in his knapsack so that their total weight does not\\nexceed 400 dag [4 kg],   and their total value is maximized.\\n[dag = decagram = 10 grams]\\n\\n\\nNon recurvive brute force version.\\n","#include <vector>\\n#include <string>\\n#include <iostream>\\n#include \\n#include <set>\\n\\nint findBestPack( const std::vector > & , \\n      std::set<int> & , const int  ) ;\\n\\nint main( ) {\\n   std::vector > items ;\\n   //===========fill the vector with data====================\\n   items.push_back( boost::make_tuple( \""\"" , 0  ,  0 ) ) ;\\n   items.push_back( boost::make_tuple( \""map\"" , 9 , 150 ) ) ;\\n   items.push_back( boost::make_tuple( \""compass\"" , 13 , 35 ) ) ;\\n   items.push_back( boost::make_tuple( \""water\"" , 153 , 200 ) ) ;\\n   items.push_back( boost::make_tuple( \""sandwich\"", 50 , 160 ) ) ;\\n   items.push_back( boost::make_tuple( \""glucose\"" , 15 , 60 ) ) ;\\n   items.push_back( boost::make_tuple( \""tin\"", 68 , 45 ) ) ;\\n   items.push_back( boost::make_tuple( \""banana\"", 27 , 60 ) ) ;\\n   items.push_back( boost::make_tuple( \""apple\"" , 39 , 40 ) ) ;\\n   items.push_back( boost::make_tuple( \""cheese\"" , 23 , 30 ) ) ;\\n   items.push_back( boost::make_tuple( \""beer\"" , 52 , 10 ) ) ;\\n   items.push_back( boost::make_tuple( \""suntan creme\"" , 11 , 70 ) ) ;\\n   items.push_back( boost::make_tuple( \""camera\"" , 32 , 30 ) ) ;\\n   items.push_back( boost::make_tuple( \""T-shirt\"" , 24 , 15 ) ) ;\\n   items.push_back( boost::make_tuple( \""trousers\"" , 48 , 10 ) ) ;\\n   items.push_back( boost::make_tuple( \""umbrella\"" , 73 , 40 ) ) ;\\n   items.push_back( boost::make_tuple( \""waterproof trousers\"" , 42 , 70 ) ) ;\\n   items.push_back( boost::make_tuple( \""waterproof overclothes\"" , 43 , 75 ) ) ;\\n   items.push_back( boost::make_tuple( \""note-case\"" , 22 , 80 ) ) ;\\n   items.push_back( boost::make_tuple( \""sunglasses\"" , 7 , 20 ) ) ;\\n   items.push_back( boost::make_tuple( \""towel\"" , 18 , 12 ) ) ;\\n   items.push_back( boost::make_tuple( \""socks\"" , 4 , 50 ) ) ;\\n   items.push_back( boost::make_tuple( \""book\"" , 30 , 10 ) ) ;\\n   const int maximumWeight = 400 ;\\n   std::set<int> bestItems ; //these items will make up the optimal value\\n   int bestValue = findBestPack( items , bestItems , maximumWeight ) ;\\n   std::cout << \""The best value that can be packed in the given knapsack is \"" <<\\n      bestValue << \"" !\\n\"" ;\\n   int totalweight = 0 ;\\n   std::cout << \""The following items should be packed in the knapsack:\\n\"" ;\\n   for ( std::set<int>::const_iterator si = bestItems.begin( ) ; \\n	 si != bestItems.end( ) ; si++ ) { \\n      std::cout << (items.begin( ) + *si)->get<0>( ) << \""\\n\"" ;\\n      totalweight += (items.begin( ) + *si)->get<1>( ) ;\\n   }\\n   std::cout << \""The total weight of all items is \"" << totalweight << \"" !\\n\"" ;\\n   return 0 ;\\n}\\n   \\nint findBestPack( const std::vector > & items ,std::set<int> & bestItems , const int weightlimit ) {\\n   //dynamic programming approach sacrificing storage space for execution\\n   //time , creating a table of optimal values for every weight and a \\n   //second table of sets with the items collected so far in the knapsack\\n   //the best value is in the bottom right corner of the values table,\\n   //the set of items in the bottom right corner of the sets' table.\\n   const int n = items.size( ) ;\\n   int bestValues [ n ][ weightlimit ] ;\\n   std::set<int> solutionSets[ n ][ weightlimit ] ;\\n   std::set<int> emptyset ;\\n   for ( int i = 0 ; i < n ; i++ ) {\\n      for ( int j = 0 ; j < weightlimit  ; j++ ) {\\n	 bestValues[ i ][ j ] = 0 ;\\n	 solutionSets[ i ][ j ] = emptyset ;\\n       }\\n    }\\n    for ( int i = 0 ; i < n ; i++ ) {\\n       for ( int weight = 0 ; weight < weightlimit ; weight++ ) {\\n	  if ( i == 0 )\\n	     bestValues[ i ][ weight ] = 0 ;\\n	  else  {\\n	     int itemweight = (items.begin( ) + i)->get<1>( ) ; \\n	     if ( weight < itemweight ) {\\n		bestValues[ i ][ weight ] = bestValues[ i - 1 ][ weight ] ;\\n		solutionSets[ i ][ weight ] = solutionSets[ i - 1 ][ weight ] ;\\n	     } else { // weight >= itemweight\\n		if ( bestValues[ i - 1 ][ weight - itemweight ] + \\n		   (items.begin( ) + i)->get<2>( ) >\\n		        bestValues[ i - 1 ][ weight ] ) {\\n		   bestValues[ i ][ weight ] = \\n		       bestValues[ i - 1 ][ weight - itemweight ] + \\n	        	(items.begin( ) + i)->get<2>( ) ;\\n		  solutionSets[ i ][ weight ] = \\n		      solutionSets[ i - 1 ][ weight - itemweight ] ;\\n		  solutionSets[ i ][ weight ].insert( i ) ;\\n	     }\\n	     else {\\n		bestValues[ i ][ weight ] = bestValues[ i - 1 ][ weight ] ;\\n		solutionSets[ i ][ weight ] = solutionSets[ i - 1 ][ weight ] ;\\n	     }\\n	  }\\n       }\\n      }\\n    }\\n    bestItems.swap( solutionSets[ n - 1][ weightlimit - 1 ] ) ;\\n    return bestValues[ n - 1 ][ weightlimit - 1 ] ;\\n}"
"C++","Knapsack_problem/Bounded","A tourist wants to make a good trip at the weekend with his friends.\\nThey will go to the mountains to see the wonders of nature.   So he needs some items during the trip.   Food, clothing, etc.   He has a good knapsack for carrying the things, but he knows that he can carry only 4 kg weight in his knapsack, because they will make the trip from morning to evening.\\nHe creates a list of what he wants to bring for the trip, but the total weight of all items is too much.   He adds a value to each item.   The value represents how important the thing for the tourist.\\nThe list contains which items are the wanted things for the trip, what is the weight and value of an item, and how many units does he have from each items.\\n\\nThis is the list:\\n\\nThe tourist can choose to take any combination of items from the list, and some number of each item is available   (see the column   piece(s)   in the list above).\\nHe may not cut the items, so he can only take whole units of any item.\\n\\nShow which items does the tourist carry in his knapsack so that their total weight does not exceed 4 kg, and their total value is maximized.\\n\\n\\niterative dynamic programming solution\\n","#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <stdexcept>\\n#include <memory>\\n#include \\n\\nusing std::cout;\\nusing std::endl;\\n\\nclass StopTimer\\n{\\npublic:\\n    StopTimer(): begin_(getUsec()) {}\\n    unsigned long long getTime() const { return getUsec() - begin_; }\\nprivate:\\n    static unsigned long long getUsec()\\n    {//...you might want to use something else under Windows\\n        timeval tv;\\n        const int res = ::gettimeofday(&tv, 0);\\n        if(res)\\n            return 0;\\n        return tv.tv_usec + 1000000 * tv.tv_sec;\\n    }\\n    unsigned long long begin_;\\n};\\n\\nstruct KnapsackTask\\n{\\n    struct Item\\n    {\\n        std::string name;\\n        unsigned w, v, qty;\\n        Item(): w(), v(), qty() {}\\n        Item(const std::string& iname, unsigned iw, unsigned iv, unsigned iqty):\\n            name(iname), w(iw), v(iv), qty(iqty)\\n        {}\\n    };\\n    typedef std::vector<Item> Items;\\n    struct Solution\\n    {\\n        unsigned v, w;\\n        unsigned long long iterations, usec;\\n        std::vector<unsigned> n;\\n        Solution(): v(), w(), iterations(), usec() {}\\n    };\\n    //...\\n    KnapsackTask(): maxWeight_(), totalWeight_() {}\\n    void add(const Item& item)\\n    {\\n        const unsigned totalItemWeight = item.w * item.qty;\\n        if(const bool invalidItem = !totalItemWeight)\\n            throw std::logic_error(\""Invalid item: \"" + item.name);\\n        totalWeight_ += totalItemWeight;\\n        items_.push_back(item);\\n    }\\n    const Items& getItems() const { return items_; }\\n    void setMaxWeight(unsigned maxWeight) { maxWeight_ = maxWeight; }\\n    unsigned getMaxWeight() const { return std::min(totalWeight_, maxWeight_); }\\n\\nprivate:\\n    unsigned maxWeight_, totalWeight_;\\n    Items items_;\\n};\\n\\nclass BoundedKnapsackRecursiveSolver\\n{\\npublic:\\n    typedef KnapsackTask Task;\\n    typedef Task::Item Item;\\n    typedef Task::Items Items;\\n    typedef Task::Solution Solution;\\n\\n    void solve(const Task& task)\\n    {\\n        Impl(task, solution_).solve();\\n    }\\n    const Solution& getSolution() const { return solution_; }\\nprivate:\\n    class Impl\\n    {\\n        struct Candidate\\n        {\\n            unsigned v, n;\\n            bool visited;\\n            Candidate(): v(), n(), visited(false) {}\\n        };\\n        typedef std::vector<Candidate> Cache;\\n    public:\\n        Impl(const Task& task, Solution& solution):\\n            items_(task.getItems()),\\n            maxWeight_(task.getMaxWeight()),\\n            maxColumnIndex_(task.getItems().size() - 1),\\n            solution_(solution),\\n            cache_(task.getMaxWeight() * task.getItems().size()),\\n            iterations_(0)\\n        {}\\n        void solve()\\n        {\\n            if(const bool nothingToSolve = !maxWeight_ || items_.empty())\\n                return;\\n            StopTimer timer;\\n            Candidate candidate;\\n            solve(candidate, maxWeight_, items_.size() - 1);\\n            convertToSolution(candidate);\\n            solution_.usec = timer.getTime();\\n        }\\n    private:\\n        void solve(Candidate& current, unsigned reminderWeight, const unsigned itemIndex)\\n        {\\n            ++iterations_;\\n\\n            const Item& item(items_[itemIndex]);\\n\\n            if(const bool firstColumn = !itemIndex)\\n            {\\n                const unsigned maxQty = std::min(item.qty, reminderWeight/item.w);\\n                current.v = item.v * maxQty;\\n                current.n = maxQty;\\n                current.visited = true;\\n            }\\n            else\\n            {\\n                const unsigned nextItemIndex = itemIndex - 1;\\n                {\\n                    Candidate& nextItem = cachedItem(reminderWeight, nextItemIndex);\\n                    if(!nextItem.visited)\\n                        solve(nextItem, reminderWeight, nextItemIndex);\\n                    current.visited = true;\\n                    current.v = nextItem.v;\\n                    current.n = 0;\\n                }\\n                if(reminderWeight >= item.w)\\n                {\\n                    for (unsigned numberOfItems = 1; numberOfItems <= item.qty; ++numberOfItems)\\n                    {\\n                        reminderWeight -= item.w;\\n                        Candidate& nextItem = cachedItem(reminderWeight, nextItemIndex);\\n                        if(!nextItem.visited)\\n                            solve(nextItem, reminderWeight, nextItemIndex);\\n\\n                        const unsigned checkValue = nextItem.v + numberOfItems * item.v;\\n                        if ( checkValue > current.v)\\n                        {\\n                            current.v = checkValue;\\n                            current.n = numberOfItems;\\n                        }\\n                        if(!(reminderWeight >= item.w))\\n                            break;\\n                    }\\n                }\\n            }\\n        }\\n        void convertToSolution(const Candidate& candidate)\\n        {\\n            solution_.iterations = iterations_;\\n            solution_.v = candidate.v;\\n            solution_.n.resize(items_.size());\\n\\n            const Candidate* iter = &candidate\\n            unsigned weight = maxWeight_, itemIndex = items_.size() - 1;\\n            while(true)\\n            {\\n                const unsigned currentWeight = iter->n * items_[itemIndex].w;\\n                solution_.n[itemIndex] = iter->n;\\n                weight -= currentWeight;\\n                if(!itemIndex--)\\n                    break;\\n                iter = &cachedItem(weight, itemIndex);\\n            }\\n            solution_.w = maxWeight_ - weight;\\n        }\\n        Candidate& cachedItem(unsigned weight, unsigned itemIndex)\\n        {\\n            return cache_[weight * maxColumnIndex_ + itemIndex];\\n        }\\n        const Items& items_;\\n        const unsigned maxWeight_;\\n        const unsigned maxColumnIndex_;\\n        Solution& solution_;\\n        Cache cache_;\\n        unsigned long long iterations_;\\n    };\\n    Solution solution_;\\n};\\n\\nvoid populateDataset(KnapsackTask& task)\\n{\\n    typedef KnapsackTask::Item Item;\\n    task.setMaxWeight( 400 );\\n    task.add(Item(\""map\"",9,150,1));\\n    task.add(Item(\""compass\"",13,35,1));\\n    task.add(Item(\""water\"",153,200,2));\\n    task.add(Item(\""sandwich\"",50,60,2));\\n    task.add(Item(\""glucose\"",15,60,2));\\n    task.add(Item(\""tin\"",68,45,3));\\n    task.add(Item(\""banana\"",27,60,3));\\n    task.add(Item(\""apple\"",39,40,3));\\n    task.add(Item(\""cheese\"",23,30,1));\\n    task.add(Item(\""beer\"",52,10,3));\\n    task.add(Item(\""suntancream\"",11,70,1));\\n    task.add(Item(\""camera\"",32,30,1));\\n    task.add(Item(\""T-shirt\"",24,15,2));\\n    task.add(Item(\""trousers\"",48,10,2));\\n    task.add(Item(\""umbrella\"",73,40,1));\\n    task.add(Item(\""w-trousers\"",42,70,1));\\n    task.add(Item(\""w-overclothes\"",43,75,1));\\n    task.add(Item(\""note-case\"",22,80,1));\\n    task.add(Item(\""sunglasses\"",7,20,1));\\n    task.add(Item(\""towel\"",18,12,2));\\n    task.add(Item(\""socks\"",4,50,1));\\n    task.add(Item(\""book\"",30,10,2));\\n}\\n\\nint main()\\n{\\n    KnapsackTask task;\\n    populateDataset(task);\\n\\n    BoundedKnapsackRecursiveSolver solver;\\n    solver.solve(task);\\n    const KnapsackTask::Solution& solution = solver.getSolution();\\n\\n    cout << \""Iterations to solve: \"" << solution.iterations << endl;\\n    cout << \""Time to solve: \"" << solution.usec << \"" usec\"" << endl;\\n    cout << \""Solution:\"" << endl;\\n    for (unsigned i = 0; i < solution.n.size(); ++i)\\n    {\\n        if (const bool itemIsNotInKnapsack = !solution.n[i])\\n            continue;\\n        cout << \""  \"" << solution.n[i] << ' ' << task.getItems()[i].name << \"" ( item weight = \"" << task.getItems()[i].w << \"" )\"" << endl;\\n    }\\n\\n    cout << \""Weight: \"" << solution.w << \"" Value: \"" << solution.v << endl;\\n    return 0;\\n}"
"C++","Knight's_tour","Problem: you have a standard 8x8 chessboard, empty but for a single knight on some square. Your task is to emit a series of legal knight moves that result in the knight visiting every square on the chessboard exactly once. Note that it is not a requirement that the tour be \""closed\""; that is, the knight need not end within a single move of its start position.\\nInput and output may be textual or graphical, according to the conventions of the programming environment. If textual, squares should be indicated in algebraic notation. The output should indicate the order in which the knight visits the squares, starting with the initial position. The form of the output may be a diagram of the board with the squares numbered according to visitation sequence, or a textual list of algebraic coordinates in order, or even an actual animation of the knight moving around the chessboard.\\nInput: starting square\\nOutput: move sequence\\n\\n\\n","#include <iostream>\\n#include <iomanip>\\n#include <array>\\n#include <string>\\n#include <tuple>\\n#include <algorithm>\\nusing namespace std;\\n\\ntemplate\\nclass Board \\n{\\npublic:\\n    array, 8> moves;\\n    array, N> data;\\n\\n    Board() \\n    {\\n        moves[0] = make_pair(2, 1);\\n        moves[1] = make_pair(1, 2);\\n        moves[2] = make_pair(-1, 2);\\n        moves[3] = make_pair(-2, 1);\\n        moves[4] = make_pair(-2, -1);\\n        moves[5] = make_pair(-1, -2);\\n        moves[6] = make_pair(1, -2);\\n        moves[7] = make_pair(2, -1);\\n    }\\n\\n    array sortMoves(int x, int y) const \\n    {\\n        array, 8> counts;\\n        for(int i = 0; i < 8; ++i) \\n        {\\n            int dx = get<0>(moves[i]);\\n            int dy = get<1>(moves[i]);\\n\\n            int c = 0;\\n            for(int j = 0; j < 8; ++j) \\n            {\\n                int x2 = x + dx + get<0>(moves[j]);\\n                int y2 = y + dy + get<1>(moves[j]);\\n\\n                if (x2 < 0 || x2 >= N || y2 < 0 || y2 >= N)\\n                    continue;\\n                if(data[y2][x2] != 0)\\n                    continue;\\n\\n                c++;\\n            }\\n\\n            counts[i] = make_tuple(c, i);\\n        }\\n\\n        // Shuffle to randomly break ties\\n        random_shuffle(counts.begin(), counts.end());\\n\\n        // Lexicographic sort\\n        sort(counts.begin(), counts.end());\\n\\n        array out;\\n        for(int i = 0; i < 8; ++i)\\n            out[i] = get<1>(counts[i]);\\n        return out;\\n    }\\n\\n    void solve(string start) \\n    {\\n        for(int v = 0; v < N; ++v)\\n            for(int u = 0; u < N; ++u)\\n                data[v][u] = 0;\\n\\n        int x0 = start[0] - 'a';\\n        int y0 = N - (start[1] - '0');\\n        data[y0][x0] = 1;\\n\\n        array>, N*N> order;\\n        order[0] = make_tuple(x0, y0, 0, sortMoves(x0, y0));\\n\\n        int n = 0;\\n        while(n < N*N-1) \\n        {\\n            int x = get<0>(order[n]);\\n            int y = get<1>(order[n]);\\n\\n            bool ok = false;\\n            for(int i = get<2>(order[n]); i < 8; ++i) \\n            {\\n                int dx = moves[get<3>(order[n])[i]].first;\\n                int dy = moves[get<3>(order[n])[i]].second;\\n\\n                if(x+dx < 0 || x+dx >= N || y+dy < 0 || y+dy >= N)\\n                    continue;\\n                if(data[y + dy][x + dx] != 0) \\n                    continue;\\n\\n                ++n;\\n                get<2>(order[n]) = i + 1;\\n                data[y+dy][x+dx] = n + 1;\\n                order[n] = make_tuple(x+dx, y+dy, 0, sortMoves(x+dx, y+dy));\\n                ok = true;\\n                break;\\n            }\\n\\n            if(!ok) // Failed. Backtrack.\\n            {\\n                data[y][x] = 0;\\n                --n;\\n            }\\n        }\\n    }\\n\\n    template\\n    friend ostream& operator<<(ostream &out, const Board<N> &b);\\n};\\n\\ntemplate\\nostream& operator<<(ostream &out, const Board<N> &b) \\n{\\n    for (int v = 0; v < N; ++v) \\n    {\\n        for (int u = 0; u < N; ++u) \\n        {\\n            if (u != 0) out << \"",\"";\\n            out << setw(3) << b.data[v][u];\\n        }\\n        out << endl;\\n    }\\n    return out;\\n}\\n\\nint main() \\n{\\n    Board<5> b1;\\n    b1.solve(\""c3\"");\\n    cout << b1 << endl;\\n\\n    Board<8> b2;\\n    b2.solve(\""b5\"");\\n    cout << b2 << endl;\\n\\n    Board<31> b3; // Max size for <1000 squares\\n    b3.solve(\""a1\"");\\n    cout << b3 << endl;\\n    return 0;\\n}"
"C++","Knuth's_algorithm_S","This is a method of randomly sampling n items from a set of M items, with equal probability; where M >= n and M, the number of items is unknown until the end.\\nThis means that the equal probability sampling should be maintained for all successive items > n as they become available (although the content of successive samples can change).\\n\\n\\n\\nNote: A class taking n and generating a callable instance/function might also be used.\\n\\n\\n\\nInstead of defining a function S_of_N_Creator, we define a generic packgage with that name. The generic parameters are N (=Sample_Size) and the type of the items to be sampled:\\nHere is the implementation of that package:\\nThe main program:\\nA sample output:\\nAt each of the 100000 repetitions not only is a new function created but also new copies of its PRIVATE variables index% and samples%(). Creating such a large number of variables at run-time impacts adversely on execution speed and isn't to be recommended, other than to meet the artificial requirements of the task.\\nOutput:\\nInstead of returning a closure we set the environment in a structure:\\nSample output:\\n","#include <iostream>\\n#include <functional>\\n#include <vector>\\n#include <cstdlib>\\n#include <ctime>\\n\\ntemplate \\nstd::function s_of_n_creator(int n) {\\n  std::vector<T> sample;\\n  int i = 0;\\n  return [=](T item) mutable {\\n    i++;\\n    if (i <= n) {\\n      sample.push_back(item);\\n    } else if (std::rand() % i < n) {\\n      sample[std::rand() % n] = item;\\n    }\\n    return sample;\\n  };\\n}\\n\\nint main() {\\n  std::srand(std::time(NULL));\\n  int bin[10] = {0};\\n  for (int trial = 0; trial < 100000; trial++) {\\n    auto s_of_n = s_of_n_creator<int>(3);\\n    std::vector<int> sample;\\n    for (int i = 0; i < 10; i++)\\n      sample = s_of_n(i);\\n    for (int s : sample)\\n      bin[s]++;\\n  }\\n  for (int x : bin)\\n    std::cout << x << std::endl;\\n  return 0;\\n}"
"C++","Knuth's_algorithm_S","This is a method of randomly sampling n items from a set of M items, with equal probability; where M >= n and M, the number of items is unknown until the end.\\nThis means that the equal probability sampling should be maintained for all successive items > n as they become available (although the content of successive samples can change).\\n\\n\\n\\nNote: A class taking n and generating a callable instance/function might also be used.\\n\\n\\n\\nInstead of defining a function S_of_N_Creator, we define a generic packgage with that name. The generic parameters are N (=Sample_Size) and the type of the items to be sampled:\\nHere is the implementation of that package:\\nThe main program:\\nA sample output:\\nAt each of the 100000 repetitions not only is a new function created but also new copies of its PRIVATE variables index% and samples%(). Creating such a large number of variables at run-time impacts adversely on execution speed and isn't to be recommended, other than to meet the artificial requirements of the task.\\nOutput:\\nInstead of returning a closure we set the environment in a structure:\\nSample output:\\n","#include <iostream>\\n#include <vector>\\n#include <cstdlib>\\n#include <ctime>\\n\\ntemplate \\nclass SOfN {\\n  std::vector<T> sample;\\n  int i;\\n  const int n;\\n public:\\n  SOfN(int _n) : i(0), n(_n) { }\\n  std::vector<T> operator()(T item) {\\n    i++;\\n    if (i <= n) {\\n      sample.push_back(item);\\n    } else if (std::rand() % i < n) {\\n      sample[std::rand() % n] = item;\\n    }\\n    return sample;\\n  }\\n};\\n\\nint main() {\\n  std::srand(std::time(NULL));\\n  int bin[10] = {0};\\n  for (int trial = 0; trial < 100000; trial++) {\\n    SOfN<int> s_of_n(3);\\n    std::vector<int> sample;\\n    for (int i = 0; i < 10; i++)\\n      sample = s_of_n(i);\\n    for (std::vector<int>::const_iterator i = sample.begin(); i != sample.end(); i++)\\n      bin[*i]++;\\n  }\\n  for (int i = 0; i < 10; i++)\\n    std::cout << bin[i] << std::endl;\\n  return 0;\\n}"
"C++","Kolakoski_sequence","The Kolakoski sequence is an infinite sequence of natural numbers, (excluding zero); with the property that:\\nThis is not a Kolakoski sequence:\\nIts sequence of run counts, (sometimes called a run length encoding, (RLE); but a true RLE also gives the character that each run encodes), is calculated like this:\\nThe above gives the RLE of:\\nThe original sequence is different from its RLE in this case. It would be the same for a true Kolakoski sequence.\\nLets start with the two numbers (1, 2) that we will cycle through; i.e. they will be used in this order: 1,2,1,2,1,2,....\\nWe will arrange that the k'th item of s states how many times the last item of sshould appear at the end of s.\\nWe started s with 1 and therefore s[k] states that it should appear only the 1 time.\\nIncrement kGet the next item from c and append it to the end of sequence s. s will then become: 1, 2k was moved to the second item in the list and s[k] states that it should appear two times, so append another of the last item to the sequence s: 1, 2,2Increment kAppend the next item from the cycle to the list: 1, 2,2, 1k is now at the third item in the list that states that the last item should appear twice so add another copy of the last item to the sequence s: 1, 2,2, 1,1increment k...\\nNote that the RLE of 1, 2, 2, 1, 1, ... begins 1, 2, 2 which is the beginning of the original sequence. The generation algorithm ensures that this will always be the case.\\n(There are rules on generating Kolakoski sequences from this method that are broken by the last example)\\n","#include <iostream>\\n#include <vector>\\n\\nusing Sequence = std::vector<int>;\\n\\nstd::ostream& operator<<(std::ostream& os, const Sequence& v) {\\n  os << \""[ \"";\\n  for (const auto& e : v) {\\n    std::cout << e << \"", \"";\\n  }\\n  os << \""]\"";\\n  return os;\\n}\\n\\nint next_in_cycle(const Sequence& s, size_t i) {\\n  return s[i % s.size()];\\n}\\n\\nSequence gen_kolakoski(const Sequence& s, int n) {\\n  Sequence seq;\\n  for (size_t i = 0; seq.size() < n; ++i) {\\n    const int next = next_in_cycle(s, i);\\n    Sequence nv(i >= seq.size() ? next : seq[i], next);\\n    seq.insert(std::end(seq), std::begin(nv), std::end(nv));\\n  }\\n  return { std::begin(seq), std::begin(seq) + n };\\n}\\n\\nbool is_possible_kolakoski(const Sequence& s) {\\n  Sequence r;\\n  for (size_t i = 0; i < s.size();) {\\n    int count = 1;\\n    for (size_t j = i + 1; j < s.size(); ++j) {\\n      if (s[j] != s[i]) break;\\n      ++count;\\n    }\\n    r.push_back(count);\\n    i += count;\\n  }\\n  for (size_t i = 0; i < r.size(); ++i) if (r[i] != s[i]) return false;\\n  return true;\\n}\\n\\nint main() {\\n  std::vector<Sequence> seqs = {\\n    { 1, 2 },\\n    { 2, 1 },\\n    { 1, 3, 1, 2 },\\n    { 1, 3, 2, 1 }\\n  };\\n  for (const auto& s : seqs) {\\n    auto kol = gen_kolakoski(s, s.size() > 2 ? 30 : 20);\\n    std::cout << \""Starting with: \"" << s << \"": \"" << std::endl << \""Kolakoski sequence: \"" \\n      << kol << std::endl << \""Possibly kolakoski? \"" << is_possible_kolakoski(kol) << std::endl;		\\n  }\\n  return 0;\\n}"
"C++","Kosaraju","\\nKosaraju's algorithm (also known as the Kosaraju–Sharir algorithm) is a linear time algorithm to find the strongly connected components of a directed graph. Aho, Hopcroft and Ullman credit it to an unpublished paper from 1978 by S. Rao Kosaraju. The same algorithm was independently discovered by Micha Sharir and published by him in 1981. It makes use of the fact that the transpose graph (the same graph with the direction of every edge reversed) has exactly the same strongly connected components as the original graph.\\n\\n","#include <functional>\\n#include <iostream>\\n#include <ostream>\\n#include <vector>\\n\\ntemplate\\nstd::ostream& operator<<(std::ostream& os, const std::vector<T>& v) {\\n    auto it = v.cbegin();\\n    auto end = v.cend();\\n\\n    os << \""[\"";\\n    if (it != end) {\\n        os << *it;\\n        it = std::next(it);\\n    }\\n    while (it != end) {\\n        os << \"", \"" << *it;\\n        it = std::next(it);\\n    }\\n    return os << \""]\"";\\n}\\n\\nstd::vector<int> kosaraju(std::vector& g) {\\n    // 1. For each vertex u of the graph, mark u as unvisited. Let l be empty.\\n    auto size = g.size();\\n    std::vector<bool> vis(size);           // all false by default\\n    std::vector<int> l(size);              // all zero by default\\n    auto x = size;                         // index for filling l in reverse order\\n    std::vector t(size); // transpose graph\\n\\n    // Recursive subroutine 'visit':\\n    std::function visit;\\n    visit = [&](int u) {\\n        if (!vis[u]) {\\n            vis[u] = true;\\n            for (auto v : g[u]) {\\n                visit(v);\\n                t[v].push_back(u); // construct transpose\\n            }\\n            l[--x] = u;\\n        }\\n    };\\n\\n    // 2. For each vertex u of the graph do visit(u)\\n    for (int i = 0; i < g.size(); ++i) {\\n        visit(i);\\n    }\\n    std::vector<int> c(size); // used for component assignment\\n\\n    // Recursive subroutine 'assign':\\n    std::function assign;\\n    assign = [&](int u, int root) {\\n        if (vis[u]) { // repurpose vis to mean 'unassigned'\\n            vis[u] = false;\\n            c[u] = root;\\n            for (auto v : t[u]) {\\n                assign(v, root);\\n            }\\n        }\\n    };\\n\\n    // 3: For each element u of l in order, do assign(u, u)\\n    for (auto u : l) {\\n        assign(u, u);\\n    }\\n\\n    return c;\\n}\\n\\nstd::vector g = {\\n    {1},\\n    {2},\\n    {0},\\n    {1, 2, 4},\\n    {3, 5},\\n    {2, 6},\\n    {5},\\n    {4, 6, 7},\\n};\\n\\nint main() {\\n    using namespace std;\\n\\n    cout << kosaraju(g) << endl;\\n\\n    return 0;\\n}"
"C++","Largest_int_from_concatenated_ints","Given a set of positive integers, write a function to order the integers in such a way that the concatenation of the numbers forms the largest possible integer and return this integer.\\nUse the following two sets of integers as tests   and   show your program output here.\\n\\n\\n\\nThe algorithmic idea is to apply a twisted comparison function:\\nThis function converts the parameters Left and Right to strings and returns True if (Left before Right)\\nexceeds (Right before Left). It needs Ada 2012 -- the code for older versions of Ada would be more verbose.\\nThe rest is straightforward: Run your favourite sorting subprogram that allows to use the function \""Order\"" instead of standard comparison operators (\""<\"" or \"">\"" or so) and print the results:\\nworks for input up to 999999999.\\n","#include <iostream>\\n#include <sstream>\\n#include <algorithm>\\n#include <vector>\\n#include <string>\\n\\nstd::string findLargestConcat ( std::vector< int > & mynumbers ) {\\n   std::vector concatnumbers ;\\n   std::sort ( mynumbers.begin( ) , mynumbers.end( ) ) ;\\n   do {\\n      std::ostringstream numberstream ;\\n      for ( int i : mynumbers ) \\n	 numberstream << i ;\\n      concatnumbers.push_back( numberstream.str( ) ) ;\\n   } while ( std::next_permutation( mynumbers.begin( ) ,\\n	    mynumbers.end( ) )) ;\\n   return *( std::max_element( concatnumbers.begin( ) ,\\n	 concatnumbers.end( ) ) ) ;\\n}\\n\\nint main( ) {\\n   std::vector<int> mynumbers = { 98, 76 , 45 , 34, 9 , 4 , 3 , 1 } ;\\n   std::vector<int> othernumbers = { 54 , 546 , 548 , 60 } ;\\n   std::cout << \""The largest concatenated int is \"" <<\\n      findLargestConcat( mynumbers ) << \"" !\\n\"" ;\\n   std::cout << \""And here it is \"" << findLargestConcat( othernumbers ) \\n      << \"" !\\n\"" ;\\n   return 0 ;\\n}"
"C++","Last_Friday_of_each_month","Write a program or a script that returns the date of the last Fridays of each month of a given year.\\nThe year may be given through any simple input method in your language (command line, std in, etc).\\n\\nExample of an expected output:\\n\\n\\nThe program uses one ASSIST macro (XPRNT) to keep the code as short as possible.\\n","#include \\n#include <iostream>\\n#include <cstdlib>\\n\\nint main( int argc , char* argv[ ] ) {\\n   using namespace boost::gregorian ;\\n\\n   greg_month months[ ] = { Jan , Feb , Mar , Apr , May , Jun , Jul ,\\n      Aug , Sep , Oct , Nov , Dec } ;\\n   greg_year gy = atoi( argv[ 1 ] ) ;\\n   for ( int i = 0 ; i < 12 ; i++ ) {\\n      last_day_of_the_week_in_month lwdm ( Friday , months[ i ] ) ;\\n      date d = lwdm.get_date( gy ) ;\\n      std::cout << d << std::endl ;\\n   }\\n   return 0 ;\\n}"
"C++","Leap_year","Determine whether a given year is a leap year in the Gregorian calendar.\\n\\n\\nThis is a callable subroutine to determine whether or not a given zoned-decimal 4-digit year is a Leap Year.\\nLeap years are \""evenly divisible\"" by 4, except those which end in '00' and are not evenly divisible by 400.\\nThe subroutine receives two parameters:\\nThe value returned in Register 15 (by convention the \""return code\"") indicates whether the year is a Leap Year:\\nSample invocation from a COBOL program:\\nWORKING-STORAGE SECTION.\\n01 FILLER.\\nPROCEDURE DIVISION.\\nRESULT-DISPLAY.\\n","#include <iostream>\\n\\nbool is_leap_year(int year) {\\n  return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);\\n}\\n\\nint main() {\\n  for (auto year : {1900, 1994, 1996, 1997, 2000}) {\\n    std::cout << year << (is_leap_year(year) ? \"" is\"" : \"" is not\"") << \"" a leap year.\\n\"";\\n  }\\n}"
"C++","Least_common_multiple","Compute the least common multiple of two integers.\\nGiven   m   and   n,   the least common multiple is the smallest positive integer that has both   m   and   n   as factors.\\n\\nThe least common multiple of 12 and 18 is 36, because 12 is a factor (12 × 3 = 36), and 18 is a factor (18 × 2 = 36), and there is no positive integer less than 36 that has both factors.   As a special case, if either   m   or   n   is zero, then the least common multiple is zero.\\nOne way to calculate the least common multiple is to iterate all the multiples of   m,   until you find one that is also a multiple of   n.\\nIf you already have   gcd   for greatest common divisor,   then this formula calculates   lcm.\\n\\n","#include \\n#include <iostream>\\n\\nint main( ) {\\n   std::cout << \""The least common multiple of 12 and 18 is \"" << \\n      boost::math::lcm( 12 , 18 ) << \"" ,\\n\""\\n      << \""and the greatest common divisor \"" << boost::math::gcd( 12 , 18 ) << \"" !\"" << std::endl ;\\n   return 0 ;\\n}"
"C++","Least_common_multiple","Compute the least common multiple of two integers.\\nGiven   m   and   n,   the least common multiple is the smallest positive integer that has both   m   and   n   as factors.\\n\\nThe least common multiple of 12 and 18 is 36, because 12 is a factor (12 × 3 = 36), and 18 is a factor (18 × 2 = 36), and there is no positive integer less than 36 that has both factors.   As a special case, if either   m   or   n   is zero, then the least common multiple is zero.\\nOne way to calculate the least common multiple is to iterate all the multiples of   m,   until you find one that is also a multiple of   n.\\nIf you already have   gcd   for greatest common divisor,   then this formula calculates   lcm.\\n\\n","\\n#include <cstdlib>\\n#include <iostream>\\n#include <tuple>\\n \\nint gcd(int a, int b) {\\n    a = abs(a);\\n    b = abs(b);\\n    while (b != 0) {\\n        std::tie(a, b) = std::make_tuple(b, a % b);\\n    }\\n    return a;\\n}\\n \\nint lcm(int a, int b) {\\n    int c = gcd(a, b);\\n    return c == 0 ? 0 : a / c * b;\\n}\\n \\nint main() {\\n    std::cout << \""The least common multiple of 12 and 18 is \"" << lcm(12, 18) << \"",\\n\""\\n        << \""and their greatest common divisor is \"" << gcd(12, 18) << \""!\"" \\n        << std::endl;\\n    return 0;\\n}\\n"
"C++","Left_factorials","Left factorials,   !n,   may refer to either   subfactorials   or to   factorial sums;\\nthe same notation can be confusingly seen used for the two different definitions.\\nSometimes,   subfactorials   (also known as derangements)   may use any of the notations:\\n(It may not be visually obvious, but the last example uses an upside-down exclamation mark.)\\n\\nThis Rosetta Code task will be using this formula for left factorial:\\n\\n","\\n#include <vector>\\n#include <string>\\n#include <algorithm>\\n#include <iostream>\\n#include <sstream>\\nusing namespace std;\\n\\n#if 1 // optimized for 64-bit architecture\\ntypedef unsigned long usingle;\\ntypedef unsigned long long udouble;\\nconst int word_len = 32;\\n#else // optimized for 32-bit architecture\\ntypedef unsigned short usingle;\\ntypedef unsigned long udouble;\\nconst int word_len = 16;\\n#endif\\n\\nclass bignum {\\nprivate:\\n    // rep_.size() == 0 if and only if the value is zero.\\n    // Otherwise, the word rep_[0] keeps the least significant bits.\\n    vector<usingle> rep_;\\npublic:\\n    explicit bignum(usingle n = 0) { if (n > 0) rep_.push_back(n); }\\n    bool equals(usingle n) const {\\n        if (n == 0) return rep_.empty();\\n        if (rep_.size() > 1) return false;\\n        return rep_[0] == n;\\n    }\\n    bignum add(usingle addend) const {\\n        bignum result(0);\\n        udouble sum = addend;\\n        for (size_t i = 0; i < rep_.size(); ++i) {\\n            sum += rep_[i];\\n            result.rep_.push_back(sum & (((udouble)1 << word_len) - 1));\\n            sum >>= word_len;\\n        }\\n        if (sum > 0) result.rep_.push_back((usingle)sum);\\n        return result;\\n    }\\n    bignum add(const bignum& addend) const {\\n        bignum result(0);\\n        udouble sum = 0;\\n        size_t sz1 = rep_.size();\\n        size_t sz2 = addend.rep_.size();\\n        for (size_t i = 0; i < max(sz1, sz2); ++i) {\\n            if (i < sz1) sum += rep_[i];\\n            if (i < sz2) sum += addend.rep_[i];\\n            result.rep_.push_back(sum & (((udouble)1 << word_len) - 1));\\n            sum >>= word_len;\\n        }\\n        if (sum > 0) result.rep_.push_back((usingle)sum);\\n        return result;\\n    }\\n    bignum multiply(usingle factor) const {\\n        bignum result(0);\\n        udouble product = 0;\\n        for (size_t i = 0; i < rep_.size(); ++i) {\\n            product += (udouble)rep_[i] * factor;\\n            result.rep_.push_back(product & (((udouble)1 << word_len) - 1));\\n            product >>= word_len;\\n        }\\n        if (product > 0)\\n            result.rep_.push_back((usingle)product);\\n        return result;\\n    }\\n    void divide(usingle divisor, bignum& quotient, usingle& remainder) const {\\n        quotient.rep_.resize(0);\\n        udouble dividend = 0;\\n        remainder = 0;\\n        for (size_t i = rep_.size(); i > 0; --i) {\\n            dividend = ((udouble)remainder << word_len) + rep_[i - 1];\\n            usingle quo = (usingle)(dividend / divisor);\\n            remainder = (usingle)(dividend % divisor);\\n            if (quo > 0 || i < rep_.size())\\n                quotient.rep_.push_back(quo);\\n        }\\n        reverse(quotient.rep_.begin(), quotient.rep_.end());\\n    }\\n};\\n\\nostream& operator<<(ostream& os, const bignum& x);\\n\\nostream& operator<<(ostream& os, const bignum& x) {\\n    string rep;\\n    bignum dividend = x;\\n    bignum quotient;\\n    usingle remainder;\\n    while (true) {\\n        dividend.divide(10, quotient, remainder);\\n        rep += (char)('0' + remainder);\\n        if (quotient.equals(0)) break;\\n        dividend = quotient;\\n    }\\n    reverse(rep.begin(), rep.end());\\n    os << rep;\\n    return os;\\n}\\n\\nbignum lfact(usingle n);\\n\\nbignum lfact(usingle n) {\\n    bignum result(0);\\n    bignum f(1);\\n    for (usingle k = 1; k <= n; ++k) {\\n        result = result.add(f);\\n        f = f.multiply(k);\\n    }\\n    return result;\\n}\\n\\nint main() {\\n    for (usingle i = 0; i <= 10; ++i) {\\n        cout << \""!\"" << i << \"" = \"" << lfact(i) << endl;\\n    }\\n\\n    for (usingle i = 20; i <= 110; i += 10) {\\n        cout << \""!\"" << i << \"" = \"" << lfact(i) << endl;\\n    }\\n\\n    for (usingle i = 1000; i <= 10000; i += 1000) {\\n        stringstream ss;\\n        ss << lfact(i);\\n        cout << \""!\"" << i << \"" has \"" << ss.str().size()\\n            << \"" digits.\"" << endl;\\n    }\\n}\\n"
"C++","Leonardo_numbers","\\nThe   Leonardo numbers   are a sequence of numbers defined by:\\n\\nThe task will be using the 3rd equation (above) to calculate the Leonardo numbers.\\n\\nEdsger W. Dijkstra   used them as an integral part of\\nhis   smoothsort   algorithm.\\n\\nThe first few Leonardo numbers are:\\n\\n(The last task requirement will produce the Fibonacci numbers.)\\n\\nShow all output here.\\n\\n\\n\\n","\\n#include <iostream>\\n\\nvoid leoN( int cnt, int l0 = 1, int l1 = 1, int add = 1 ) {\\n    int t;\\n    for( int i = 0; i < cnt; i++ ) {\\n        std::cout << l0 << \"" \"";\\n        t = l0 + l1 + add; l0 = l1; l1 = t;\\n    }\\n}\\nint main( int argc, char* argv[] ) {\\n    std::cout << \""Leonardo Numbers: \""; leoN( 25 );\\n    std::cout << \""\\n\\nFibonacci Numbers: \""; leoN( 25, 0, 1, 0 );\\n    return 0;\\n}\\n"
"C++","Letter_frequency","Open a text file and count the occurrences of each letter.\\nSome of these programs count all characters (including punctuation),\\nbut some only count letters A to Z.\\n\\n","#include <fstream>\\n#include <iostream>\\n\\nint main()\\n{\\n	std::ifstream input(\""filename.txt\"", std::ios_base::binary);\\n	if (!input)\\n	{\\n		std::cerr << \""error: can't open file\\n\"";\\n		return -1;\\n	}\\n\\n	size_t count[256];\\n	std::fill_n(count, 256, 0);\\n\\n	for (char c; input.get(c); ++count[uint8_t(c)]) // process input file\\n		; // empty loop body\\n\\n	for (size_t i = 0; i < 256; ++i)\\n	{\\n		if (count[i] && isgraph(i)) // non-zero counts of printable characters\\n		{\\n			std::cout << char(i) << \"" = \"" << count[i] << '\\n';\\n		}\\n	}\\n}"
"Python","15_Puzzle_Game","\\nImplement the Fifteen Puzzle Game.\\n\\nThe   15-puzzle   is also known as:\\n\\n\\nWe fist define a generic package Generic_Puzzle. Upon instantiation, it can take any number of rows, any number of columns for a rows*columns-1 game. Instead of plain numbers, the tiles on the board can have arbitrary names (but they should all be of the same length). The package user can request the name for the tile at a certain (row,column)-point, and the set of possible moves. The user can move the empty space up, down, left and right (if possible). If the user makes the attempt to perform an impossible move, a Constraint_Error is raised.\\nThe package implementation is as follows.\\nThe main program reads the level from the command line. A larger level implies a more difficult instance. The default level is 10, which is fairly simple. After randomizing the board, the user can move the tiles.\\n","\\n''' Structural Game for 15 - Puzzle with different difficulty levels'''\\nfrom random import randint\\n\\n\\nclass Puzzle:\\n    def __init__(self):\\n        self.items = {}\\n        self.position = None\\n\\n    def main_frame(self):\\n        d = self.items\\n        print('+-----+-----+-----+-----+')\\n        print('|%s|%s|%s|%s|' % (d[1], d[2], d[3], d[4]))\\n        print('+-----+-----+-----+-----+')\\n        print('|%s|%s|%s|%s|' % (d[5], d[6], d[7], d[8]))\\n        print('+-----+-----+-----+-----+')\\n        print('|%s|%s|%s|%s|' % (d[9], d[10], d[11], d[12]))\\n        print('+-----+-----+-----+-----+')\\n        print('|%s|%s|%s|%s|' % (d[13], d[14], d[15], d[16]))\\n        print('+-----+-----+-----+-----+')\\n\\n    def format(self, ch):\\n        ch = ch.strip()\\n        if len(ch) == 1:\\n            return '  ' + ch + '  '\\n        elif len(ch) == 2:\\n            return '  ' + ch + ' '\\n        elif len(ch) == 0:\\n            return '     '\\n\\n    def change(self, to):\\n        fro = self.position\\n        for a, b in self.items.items():\\n            if b == self.format(str(to)):\\n                to = a\\n                break\\n        self.items[fro], self.items[to] = self.items[to], self.items[fro]\\n        self.position = to\\n\\n    def build_board(self, difficulty):\\n        for i in range(1, 17):\\n            self.items[i] = self.format(str(i))\\n        tmp = 0\\n        for a, b in self.items.items():\\n            if b == '  16 ':\\n                self.items[a] = '     '\\n                tmp = a\\n                break\\n        self.position = tmp\\n        if difficulty == 0:\\n            diff = 10\\n        elif difficulty == 1:\\n            diff = 50\\n        else:\\n            diff = 100\\n        for _ in range(diff):\\n            lst = self.valid_moves()\\n            lst1 = []\\n            for j in lst:\\n                lst1.append(int(j.strip()))\\n            self.change(lst1[randint(0, len(lst1)-1)])\\n\\n    def valid_moves(self):\\n        pos = self.position\\n        if pos in [6, 7, 10, 11]:\\n            return self.items[pos - 4], self.items[pos - 1],\\\\n                   self.items[pos + 1], self.items[pos + 4]\\n        elif pos in [5, 9]:\\n            return self.items[pos - 4], self.items[pos + 4],\\\\n                   self.items[pos + 1]\\n        elif pos in [8, 12]:\\n            return self.items[pos - 4], self.items[pos + 4],\\\\n                   self.items[pos - 1]\\n        elif pos in [2, 3]:\\n            return self.items[pos - 1], self.items[pos + 1], self.items[pos + 4]\\n        elif pos in [14, 15]:\\n            return self.items[pos - 1], self.items[pos + 1],\\\\n                  self.items[pos - 4]\\n        elif pos == 1:\\n            return self.items[pos + 1], self.items[pos + 4]\\n        elif pos == 4:\\n            return self.items[pos - 1], self.items[pos + 4]\\n        elif pos == 13:\\n            return self.items[pos + 1], self.items[pos - 4]\\n        elif pos == 16:\\n            return self.items[pos - 1], self.items[pos - 4]\\n\\n    def game_over(self):\\n        flag = False\\n        for a, b in self.items.items():\\n            if b == '     ':\\n                pass\\n            else:\\n                if a == int(b.strip()):\\n                    flag = True\\n                else:\\n                    flag = False\\n        return flag\\n\\n\\ng = Puzzle()\\ng.build_board(int(input('Enter the difficulty : 0 1 2\\n2 '\\n                        '=> highest 0=> lowest\\n')))\\ng.main_frame()\\nprint('Enter 0 to exit')\\nwhile True:\\n    print('Hello user:\\nTo change the position just enter the no. near it')\\n    lst = g.valid_moves()\\n    lst1 = []\\n    for i in lst:\\n        lst1.append(int(i.strip()))\\n        print(i.strip(), '\\t', end='')\\n    print()\\n    x = int(input())\\n    if x == 0:\\n        break\\n    elif x not in lst1:\\n        print('Wrong move')\\n    else:\\n        g.change(x)\\n    g.main_frame()\\n    if g.game_over():\\n        print('You WON')\\n        break\\n"
"Python","15_puzzle_solver","Your task is to write a program that finds a solution in the fewest moves possible single moves to a random Fifteen Puzzle Game.\\nFor this task you will be using the following puzzle:\\n\\nThe output must show the moves' directions, like so: left, left, left, down, right... and so on.\\nThere are two solutions, of fifty-two moves:\\nrrrulddluuuldrurdddrullulurrrddldluurddlulurruldrdrd\\nrrruldluuldrurdddluulurrrdlddruldluurddlulurruldrrdd\\nsee: Pretty Print of Optimal Solution\\nFinding either one, or both is an acceptable result.\\nSolve the following problem:\\n\\n\\nsee for an analysis of 20 randomly generated 15 puzzles solved with this solver.\\n","\\nimport random\\n\\n\\nclass IDAStar:\\n    def __init__(self, h, neighbours):\\n        \""\""\"" Iterative-deepening A* search.\\n\\n        h(n) is the heuristic that gives the cost between node n and the goal node. It must be admissable, meaning that h(n) MUST NEVER OVERSTIMATE the true cost. Underestimating is fine.\\n\\n        neighbours(n) is an iterable giving a pair (cost, node, descr) for each node neighbouring n\\n        IN ASCENDING ORDER OF COST. descr is not used in the computation but can be used to\\n        efficiently store information about the path edges (e.g. up/left/right/down for grids).\\n        \""\""\""\\n\\n        self.h = h\\n        self.neighbours = neighbours\\n        self.FOUND = object()\\n\\n\\n    def solve(self, root, is_goal, max_cost=None):\\n        \""\""\"" Returns the shortest path between the root and a given goal, as well as the total cost.\\n        If the cost exceeds a given max_cost, the function returns None. If you do not give a\\n        maximum cost the solver will never return for unsolvable instances.\""\""\""\\n\\n        self.is_goal = is_goal\\n        self.path = [root]\\n        self.is_in_path = {root}\\n        self.path_descrs = []\\n        self.nodes_evaluated = 0\\n\\n        bound = self.h(root)\\n\\n        while True:\\n            t = self._search(0, bound)\\n            if t is self.FOUND: return self.path, self.path_descrs, bound, self.nodes_evaluated\\n            if t is None: return None\\n            bound = t\\n\\n    def _search(self, g, bound):\\n        self.nodes_evaluated += 1\\n\\n        node = self.path[-1]\\n        f = g + self.h(node)\\n        if f > bound: return f\\n        if self.is_goal(node): return self.FOUND\\n\\n        m = None # Lower bound on cost.\\n        for cost, n, descr in self.neighbours(node):\\n            if n in self.is_in_path: continue\\n\\n            self.path.append(n)\\n            self.is_in_path.add(n)\\n            self.path_descrs.append(descr)\\n            t = self._search(g + cost, bound)\\n\\n            if t == self.FOUND: return self.FOUND\\n            if m is None or (t is not None and t < m): m = t\\n\\n            self.path.pop()\\n            self.path_descrs.pop()\\n            self.is_in_path.remove(n)\\n\\n        return m\\n\\n\\ndef slide_solved_state(n):\\n    return tuple(i % (n*n) for i in range(1, n*n+1))\\n\\ndef slide_randomize(p, neighbours):\\n    for _ in range(len(p) ** 2):\\n        _, p, _ = random.choice(list(neighbours(p)))\\n    return p\\n\\ndef slide_neighbours(n):\\n    movelist = []\\n    for gap in range(n*n):\\n        x, y = gap % n, gap // n\\n        moves = []\\n        if x > 0: moves.append(-1)    # Move the gap left.\\n        if x < n-1: moves.append(+1)  # Move the gap right.\\n        if y > 0: moves.append(-n)    # Move the gap up.\\n        if y < n-1: moves.append(+n)  # Move the gap down.\\n        movelist.append(moves)\\n\\n    def neighbours(p):\\n        gap = p.index(0)\\n        l = list(p)\\n\\n        for m in movelist[gap]:\\n            l[gap] = l[gap + m]\\n            l[gap + m] = 0\\n            yield (1, tuple(l), (l[gap], m))\\n            l[gap + m] = l[gap]\\n            l[gap] = 0\\n\\n    return neighbours\\n\\ndef slide_print(p):\\n    n = int(round(len(p) ** 0.5))\\n    l = len(str(n*n))\\n    for i in range(0, len(p), n):\\n        print(\"" \"".join(\""{:>{}}\"".format(x, l) for x in p[i:i+n]))\\n\\ndef encode_cfg(cfg, n):\\n    r = 0\\n    b = n.bit_length()\\n    for i in range(len(cfg)):\\n        r |= cfg[i] << (b*i)\\n    return r\\n\\n\\ndef gen_wd_table(n):\\n    goal = [[0] * i + [n] + [0] * (n - 1 - i) for i in range(n)]\\n    goal[-1][-1] = n - 1\\n    goal = tuple(sum(goal, []))\\n\\n    table = {}\\n    to_visit = [(goal, 0, n-1)]\\n    while to_visit:\\n        cfg, cost, e = to_visit.pop(0)\\n        enccfg = encode_cfg(cfg, n)\\n        if enccfg in table: continue\\n        table[enccfg] = cost\\n\\n        for d in [-1, 1]:\\n            if 0 <= e + d < n:\\n                for c in range(n):\\n                    if cfg[n*(e+d) + c] > 0:\\n                        ncfg = list(cfg)\\n                        ncfg[n*(e+d) + c] -= 1\\n                        ncfg[n*e + c] += 1\\n                        to_visit.append((tuple(ncfg), cost + 1, e+d))\\n\\n    return table\\n\\ndef slide_wd(n, goal):\\n    wd = gen_wd_table(n)\\n    goals = {i : goal.index(i) for i in goal}\\n    b = n.bit_length()\\n\\n    def h(p):\\n        ht = 0 # Walking distance between rows.\\n        vt = 0 # Walking distance between columns.\\n        d = 0\\n        for i, c in enumerate(p):\\n            if c == 0: continue\\n            g = goals[c]\\n            xi, yi = i % n, i // n\\n            xg, yg = g % n, g // n\\n            ht += 1 << (b*(n*yi+yg))\\n            vt += 1 << (b*(n*xi+xg))\\n\\n            if yg == yi:\\n                for k in range(i + 1, i - i%n + n): # Until end of row.\\n                    if p[k] and goals[p[k]] // n == yi and goals[p[k]] < g:\\n                        d += 2\\n\\n            if xg == xi:\\n                for k in range(i + n, n * n, n): # Until end of column.\\n                    if p[k] and goals[p[k]] % n == xi and goals[p[k]] < g:\\n                        d += 2\\n\\n        d += wd[ht] + wd[vt]\\n\\n        return d\\n    return h\\n\\n\\n\\n\\nif __name__ == \""__main__\"":\\n    solved_state = slide_solved_state(4)\\n    neighbours = slide_neighbours(4)\\n    is_goal = lambda p: p == solved_state\\n\\n    tests = [\\n        (15, 14, 1, 6, 9, 11, 4, 12, 0, 10, 7, 3, 13, 8, 5,  2),\\n    ]\\n\\n    slide_solver = IDAStar(slide_wd(4, solved_state), neighbours)\\n\\n    for p in tests:\\n        path, moves, cost, num_eval = slide_solver.solve(p, is_goal, 80)\\n        slide_print(p)\\n        print(\"", \"".join({-1: \""Left\"", 1: \""Right\"", -4: \""Up\"", 4: \""Down\""}[move[1]] for move in moves))\\n        print(cost, num_eval)\\n"
"Python","15_puzzle_solver","Your task is to write a program that finds a solution in the fewest moves possible single moves to a random Fifteen Puzzle Game.\\nFor this task you will be using the following puzzle:\\n\\nThe output must show the moves' directions, like so: left, left, left, down, right... and so on.\\nThere are two solutions, of fifty-two moves:\\nrrrulddluuuldrurdddrullulurrrddldluurddlulurruldrdrd\\nrrruldluuldrurdddluulurrrdlddruldluurddlulurruldrrdd\\nsee: Pretty Print of Optimal Solution\\nFinding either one, or both is an acceptable result.\\nSolve the following problem:\\n\\n\\nsee for an analysis of 20 randomly generated 15 puzzles solved with this solver.\\n","\\n\""\""\""\\n\\nPython example for this Rosetta Code task:\\n\\nhttp://rosettacode.org/wiki/15_puzzle_solver\\n\\nUsing A* Algorithm from Wikkipedia:\\n\\nhttps://en.wikipedia.org/wiki/A*_search_algorithm\\n\\nNeed to use heuristic that guarantees a shortest path\\nsolution.\\n\\n\""\""\""\\n\\nimport heapq\\nimport copy\\n\\n# Hopefully this is larger than any fscore or gscore\\n\\ninteger_infinity = 1000000000\\n\\nclass Position(object):\\n    \""\""\""Position class represents one position of a 15 puzzle\""\""\""\\n\\n    def __init__(self, tiles):\\n        \""\""\""\\n        Takes a tuple of tuples representing the tiles on a 4x4 puzzle board\\n        numbering 1-15 with 0 representing an empty square. For example:\\n        \\n        (( 1,  2,  3,  4),\\n         ( 5,  6,  7,  8),\\n         ( 9, 10, 11, 12),\\n         (13, 14, 15,  0))\\n         \\n        Converts list of lists representation into tuple of tuples.\\n        \""\""\""\\n        if type(tiles) == type(list()):\\n            t = tiles\\n            self.tiles = ((t[0][0], t[0][1], t[0][2], t[0][3]),\\n                          (t[1][0], t[1][1], t[1][2], t[1][3]),        \\n                          (t[2][0], t[2][1], t[2][2], t[2][3]),        \\n                          (t[3][0], t[3][1], t[3][2], t[3][3]))\\n        else:\\n            self.tiles = tiles\\n            \\n        # fields for A* algorithm\\n        \\n        self.fscore = integer_infinity\\n        self.gscore = integer_infinity\\n        \\n        self.cameFrom = None\\n                                    \\n    def copy_tiles(self):\\n        \""\""\"" returns list of lists version \""\""\""\\n        t = self.tiles\\n        \\n        return [[t[0][0], t[0][1], t[0][2], t[0][3]],\\n                [t[1][0], t[1][1], t[1][2], t[1][3]],        \\n                [t[2][0], t[2][1], t[2][2], t[2][3]],        \\n                [t[3][0], t[3][1], t[3][2], t[3][3]]]        \\n\\n        \\n    def neighbors(self):\\n        \""\""\""\\n        returns a list of neighbors\\n        returns a list position objects with their\\n        directiontomoveto set to the direction that the\\n        empty square moved.\\n        \\n        tiles is 4x4 tuple of tuples with\\n        0,0 as top left.\\n    \\n        tiles[y][x]\\n\\n        \""\""\""\\n        \\n        # find 0 - blank square\\n        \\n        x0 = None\\n        y0 = None\\n        \\n        for i in range(4):\\n            for j in range(4):\\n                if self.tiles[i][j] == 0:\\n                    y0 = i\\n                    x0 = j\\n\\n        if x0 == None or y0 == None:\\n            return []\\n            \\n        neighbor_list = []\\n            \\n        # move 0 to the right\\n        if x0 < 3:\\n            new_tiles = self.copy_tiles()\\n            temp = new_tiles[y0][x0+1]\\n            new_tiles[y0][x0+1] = 0\\n            new_tiles[y0][x0] = temp\\n            new_pos = new_position(new_tiles)\\n            neighbor_list.append(new_pos)\\n        # move 0 to the left\\n        if x0 > 0:\\n            new_tiles = self.copy_tiles()\\n            temp = new_tiles[y0][x0-1]\\n            new_tiles[y0][x0-1] = 0\\n            new_tiles[y0][x0] = temp\\n            new_pos = new_position(new_tiles)\\n            neighbor_list.append(new_pos)\\n        # move 0 up\\n        if y0 > 0:\\n            new_tiles = self.copy_tiles()\\n            temp = new_tiles[y0-1][x0]\\n            new_tiles[y0-1][x0] = 0\\n            new_tiles[y0][x0] = temp\\n            new_pos = new_position(new_tiles)\\n            neighbor_list.append(new_pos)\\n        # move 0 down\\n        if y0 < 3:\\n            new_tiles = self.copy_tiles()\\n            temp = new_tiles[y0+1][x0]\\n            new_tiles[y0+1][x0] = 0\\n            new_tiles[y0][x0] = temp\\n            new_pos = new_position(new_tiles)\\n            neighbor_list.append(new_pos)\\n            \\n        return neighbor_list\\n        \\n    def __repr__(self):\\n        # printable version of self\\n        \\n        return str(self.tiles[0])+'\\n'+str(self.tiles[1])+'\\n'+str(self.tiles[2])+'\\n'+str(self.tiles[3])+'\\n'\\n\\n# takes tuple of tuples tiles as key, Position object for that tiles as value\\n\\nall_positions = dict()\\n\\ndef new_position(tiles):\\n    \""\""\"" returns a new position or looks up existing one \""\""\""\\n    global all_positions\\n    if type(tiles) == type(list()):\\n        t = tiles\\n        tuptiles =   ((t[0][0], t[0][1], t[0][2], t[0][3]),\\n                      (t[1][0], t[1][1], t[1][2], t[1][3]),        \\n                      (t[2][0], t[2][1], t[2][2], t[2][3]),        \\n                      (t[3][0], t[3][1], t[3][2], t[3][3]))\\n    else:\\n        tuptiles = tiles\\n        \\n    if tuptiles in all_positions:\\n        return 	all_positions[tuptiles]\\n    else:\\n        new_pos = Position(tiles)\\n        all_positions[tuptiles] = new_pos\\n        return new_pos\\n                \\ndef reconstruct_path(current):\\n    \""\""\"" \\n    Uses the cameFrom members to follow the chain of moves backwards\\n    and then reverses the list to get the path in the correct order.\\n    \""\""\""\\n    total_path = [current]\\n\\n    while current.cameFrom != None:\\n        current = current.cameFrom\\n        total_path.append(current)\\n        \\n    total_path.reverse()\\n    \\n    return total_path\\n        \\nclass PriorityQueue(object):\\n    \""\""\""\\n    Priority queue using heapq.\\n    elements of queue are (fscore,tiles) for each position.\\n    If element is removed from queue and fscore doesn't match\\n    then that element is discarded.\\n    \""\""\""\\n\\n    def __init__(self, object_list):\\n        \""\""\"" \\n        Save a list in a heapq.\\n        Assume that each object only appears once\\n        in the list.\\n        \""\""\""\\n        self.queue_length = 0\\n        self.qheap = []\\n        for e in object_list:\\n            self.qheap.append((e.fscore,e.tiles))\\n            self.queue_length += 1\\n        heapq.heapify(self.qheap)\\n        \\n    def push(self, new_object):\\n        \""\""\"" save object in heapq \""\""\""\\n        heapq.heappush(self.qheap,(new_object.fscore,new_object.tiles))\\n        self.queue_length += 1\\n        \\n    def pop(self):\\n        \""\""\"" remove object from heap and return \""\""\""\\n        if self.queue_length < 1:\\n            return None\\n        fscore, tiles = heapq.heappop(self.qheap)\\n        self.queue_length -= 1\\n        global all_positions\\n        pos = all_positions[tiles]\\n        if pos.fscore == fscore:\\n            return pos\\n        else:\\n            return self.pop()\\n                \\n    def __repr__(self):\\n        # printable version of self\\n        strrep = \""\""\\n        for e in self.qheap:\\n          fscore, tiles = e\\n          strrep += str(fscore)+\"":\""+str(tiles)+\""\\n\""\\n        \\n        return strrep\\n        \\nconflict_table = None\\n\\ndef build_conflict_table():\\n    global conflict_table\\n    conflict_table = dict()\\n    \\n    # assumes goal tuple has up to \\n    # for the given pattern it the start position\\n    # how much to add for linear conflicts\\n    # 2 per conflict - max of 6\\n    \\n    # goal tuple is ('g0', 'g1', 'g2', 'g3')\\n    \\n    conflict_table[('g0', 'g1', 'g2', 'g3')] = 0\\n    conflict_table[('g0', 'g1', 'g2', 'x')] = 0\\n    conflict_table[('g0', 'g1', 'g3', 'g2')] = 2\\n    conflict_table[('g0', 'g1', 'g3', 'x')] = 0\\n    conflict_table[('g0', 'g1', 'x', 'g2')] = 0\\n    conflict_table[('g0', 'g1', 'x', 'g3')] = 0\\n    conflict_table[('g0', 'g1', 'x', 'x')] = 0\\n    conflict_table[('g0', 'g2', 'g1', 'g3')] = 2\\n    conflict_table[('g0', 'g2', 'g1', 'x')] = 2\\n    conflict_table[('g0', 'g2', 'g3', 'g1')] = 4\\n    conflict_table[('g0', 'g2', 'g3', 'x')] = 0\\n    conflict_table[('g0', 'g2', 'x', 'g1')] = 2\\n    conflict_table[('g0', 'g2', 'x', 'g3')] = 0\\n    conflict_table[('g0', 'g2', 'x', 'x')] = 0\\n    conflict_table[('g0', 'g3', 'g1', 'g2')] = 4 \\n    conflict_table[('g0', 'g3', 'g1', 'x')] = 2\\n    conflict_table[('g0', 'g3', 'g2', 'g1')] = 4\\n    conflict_table[('g0', 'g3', 'g2', 'x')] = 2\\n    conflict_table[('g0', 'g3', 'x', 'g1')] = 2\\n    conflict_table[('g0', 'g3', 'x', 'g2')] = 2\\n    conflict_table[('g0', 'g3', 'x', 'x')] = 0\\n    conflict_table[('g0', 'x', 'g1', 'g2')] = 0\\n    conflict_table[('g0', 'x', 'g1', 'g3')] = 0\\n    conflict_table[('g0', 'x', 'g1', 'x')] = 0\\n    conflict_table[('g0', 'x', 'g2', 'g1')] = 2\\n    conflict_table[('g0', 'x', 'g2', 'g3')] = 0\\n    conflict_table[('g0', 'x', 'g2', 'x')] = 0\\n    conflict_table[('g0', 'x', 'g3', 'g1')] = 2\\n    conflict_table[('g0', 'x', 'g3', 'g2')] = 2\\n    conflict_table[('g0', 'x', 'g3', 'x')] = 0\\n    conflict_table[('g0', 'x', 'x', 'g1')] = 0\\n    conflict_table[('g0', 'x', 'x', 'g2')] = 0\\n    conflict_table[('g0', 'x', 'x', 'g3')] = 0\\n    conflict_table[('g1', 'g0', 'g2', 'g3')] = 2\\n    conflict_table[('g1', 'g0', 'g2', 'x')] = 2\\n    conflict_table[('g1', 'g0', 'g3', 'g2')] = 4 \\n    conflict_table[('g1', 'g0', 'g3', 'x')] = 2\\n    conflict_table[('g1', 'g0', 'x', 'g2')] = 2\\n    conflict_table[('g1', 'g0', 'x', 'g3')] = 2\\n    conflict_table[('g1', 'g0', 'x', 'x')] = 2\\n    conflict_table[('g1', 'g2', 'g0', 'g3')] = 4 \\n    conflict_table[('g1', 'g2', 'g0', 'x')] = 4\\n    conflict_table[('g1', 'g2', 'g3', 'g0')] = 6 \\n    conflict_table[('g1', 'g2', 'g3', 'x')] = 0\\n    conflict_table[('g1', 'g2', 'x', 'g0')] = 4\\n    conflict_table[('g1', 'g2', 'x', 'g3')] = 0\\n    conflict_table[('g1', 'g2', 'x', 'x')] = 0\\n    conflict_table[('g1', 'g3', 'g0', 'g2')] = 4 \\n    conflict_table[('g1', 'g3', 'g0', 'x')] = 4\\n    conflict_table[('g1', 'g3', 'g2', 'g0')] = 6 \\n    conflict_table[('g1', 'g3', 'g2', 'x')] = 0\\n    conflict_table[('g1', 'g3', 'x', 'g0')] = 4\\n    conflict_table[('g1', 'g3', 'x', 'g2')] = 2\\n    conflict_table[('g1', 'g3', 'x', 'x')] = 0\\n    conflict_table[('g1', 'x', 'g0', 'g2')] = 2\\n    conflict_table[('g1', 'x', 'g0', 'g3')] = 2\\n    conflict_table[('g1', 'x', 'g0', 'x')] = 2\\n    conflict_table[('g1', 'x', 'g2', 'g0')] = 4\\n    conflict_table[('g1', 'x', 'g2', 'g3')] = 0\\n    conflict_table[('g1', 'x', 'g2', 'x')] = 0\\n    conflict_table[('g1', 'x', 'g3', 'g0')] = 4\\n    conflict_table[('g1', 'x', 'g3', 'g2')] = 2\\n    conflict_table[('g1', 'x', 'g3', 'x')] = 0\\n    conflict_table[('g1', 'x', 'x', 'g0')] = 2\\n    conflict_table[('g1', 'x', 'x', 'g2')] = 0\\n    conflict_table[('g1', 'x', 'x', 'g3')] = 0\\n    conflict_table[('g2', 'g0', 'g1', 'g3')] = 4\\n    conflict_table[('g2', 'g0', 'g1', 'x')] = 4\\n    conflict_table[('g2', 'g0', 'g3', 'g1')] = 4\\n    conflict_table[('g2', 'g0', 'g3', 'x')] = 2\\n    conflict_table[('g2', 'g0', 'x', 'g1')] = 4\\n    conflict_table[('g2', 'g0', 'x', 'g3')] = 2\\n    conflict_table[('g2', 'g0', 'x', 'x')] = 2\\n    conflict_table[('g2', 'g1', 'g0', 'g3')] = 4\\n    conflict_table[('g2', 'g1', 'g0', 'x')] = 4\\n    conflict_table[('g2', 'g1', 'g3', 'g0')] = 6\\n    conflict_table[('g2', 'g1', 'g3', 'x')] = 2\\n    conflict_table[('g2', 'g1', 'x', 'g0')] = 4\\n    conflict_table[('g2', 'g1', 'x', 'g3')] = 2\\n    conflict_table[('g2', 'g1', 'x', 'x')] = 2\\n    conflict_table[('g2', 'g3', 'g0', 'g1')] = 4\\n    conflict_table[('g2', 'g3', 'g0', 'x')] = 4\\n    conflict_table[('g2', 'g3', 'g1', 'g0')] = 6\\n    conflict_table[('g2', 'g3', 'g1', 'x')] = 4\\n    conflict_table[('g2', 'g3', 'x', 'g0')] = 4\\n    conflict_table[('g2', 'g3', 'x', 'g1')] = 4\\n    conflict_table[('g2', 'g3', 'x', 'x')] = 0\\n    conflict_table[('g2', 'x', 'g0', 'g1')] = 4\\n    conflict_table[('g2', 'x', 'g0', 'g3')] = 2\\n    conflict_table[('g2', 'x', 'g0', 'x')] = 2\\n    conflict_table[('g2', 'x', 'g1', 'g0')] = 4\\n    conflict_table[('g2', 'x', 'g1', 'g3')] = 2\\n    conflict_table[('g2', 'x', 'g1', 'x')] = 2\\n    conflict_table[('g2', 'x', 'g3', 'g0')] = 4\\n    conflict_table[('g2', 'x', 'g3', 'g1')] = 4\\n    conflict_table[('g2', 'x', 'g3', 'x')] = 0\\n    conflict_table[('g2', 'x', 'x', 'g0')] = 2\\n    conflict_table[('g2', 'x', 'x', 'g1')] = 2\\n    conflict_table[('g2', 'x', 'x', 'g3')] = 0\\n    conflict_table[('g3', 'g0', 'g1', 'g2')] = 6\\n    conflict_table[('g3', 'g0', 'g1', 'x')] = 4\\n    conflict_table[('g3', 'g0', 'g2', 'g1')] = 6\\n    conflict_table[('g3', 'g0', 'g2', 'x')] = 4\\n    conflict_table[('g3', 'g0', 'x', 'g1')] = 4\\n    conflict_table[('g3', 'g0', 'x', 'g2')] = 4\\n    conflict_table[('g3', 'g0', 'x', 'x')] = 2\\n    conflict_table[('g3', 'g1', 'g0', 'g2')] = 6\\n    conflict_table[('g3', 'g1', 'g0', 'x')] = 4\\n    conflict_table[('g3', 'g1', 'g2', 'g0')] = 6\\n    conflict_table[('g3', 'g1', 'g2', 'x')] = 4\\n    conflict_table[('g3', 'g1', 'x', 'g0')] = 4\\n    conflict_table[('g3', 'g1', 'x', 'g2')] = 4\\n    conflict_table[('g3', 'g1', 'x', 'x')] = 2\\n    conflict_table[('g3', 'g2', 'g0', 'g1')] = 6\\n    conflict_table[('g3', 'g2', 'g0', 'x')] = 4\\n    conflict_table[('g3', 'g2', 'g1', 'g0')] = 6\\n    conflict_table[('g3', 'g2', 'g1', 'x')] = 4\\n    conflict_table[('g3', 'g2', 'x', 'g0')] = 4\\n    conflict_table[('g3', 'g2', 'x', 'g1')] = 4\\n    conflict_table[('g3', 'g2', 'x', 'x')] = 2\\n    conflict_table[('g3', 'x', 'g0', 'g1')] = 4\\n    conflict_table[('g3', 'x', 'g0', 'g2')] = 4\\n    conflict_table[('g3', 'x', 'g0', 'x')] = 2\\n    conflict_table[('g3', 'x', 'g1', 'g0')] = 4\\n    conflict_table[('g3', 'x', 'g1', 'g2')] = 4\\n    conflict_table[('g3', 'x', 'g1', 'x')] = 2\\n    conflict_table[('g3', 'x', 'g2', 'g0')] = 4\\n    conflict_table[('g3', 'x', 'g2', 'g1')] = 4\\n    conflict_table[('g3', 'x', 'g2', 'x')] = 2\\n    conflict_table[('g3', 'x', 'x', 'g0')] = 2\\n    conflict_table[('g3', 'x', 'x', 'g1')] = 2\\n    conflict_table[('g3', 'x', 'x', 'g2')] = 2\\n    conflict_table[('x', 'g0', 'g1', 'g2')] = 0\\n    conflict_table[('x', 'g0', 'g1', 'g3')] = 0\\n    conflict_table[('x', 'g0', 'g1', 'x')] = 0\\n    conflict_table[('x', 'g0', 'g2', 'g1')] = 2\\n    conflict_table[('x', 'g0', 'g2', 'g3')] = 0\\n    conflict_table[('x', 'g0', 'g2', 'x')] = 0\\n    conflict_table[('x', 'g0', 'g3', 'g1')] = 2\\n    conflict_table[('x', 'g0', 'g3', 'g2')] = 2\\n    conflict_table[('x', 'g0', 'g3', 'x')] = 0\\n    conflict_table[('x', 'g0', 'x', 'g1')] = 0\\n    conflict_table[('x', 'g0', 'x', 'g2')] = 0\\n    conflict_table[('x', 'g0', 'x', 'g3')] = 0\\n    conflict_table[('x', 'g1', 'g0', 'g2')] = 2\\n    conflict_table[('x', 'g1', 'g0', 'g3')] = 2\\n    conflict_table[('x', 'g1', 'g0', 'x')] = 2\\n    conflict_table[('x', 'g1', 'g2', 'g0')] = 4\\n    conflict_table[('x', 'g1', 'g2', 'g3')] = 0\\n    conflict_table[('x', 'g1', 'g2', 'x')] = 0\\n    conflict_table[('x', 'g1', 'g3', 'g0')] = 4\\n    conflict_table[('x', 'g1', 'g3', 'g2')] = 2\\n    conflict_table[('x', 'g1', 'g3', 'x')] = 0\\n    conflict_table[('x', 'g1', 'x', 'g0')] = 2\\n    conflict_table[('x', 'g1', 'x', 'g2')] = 0\\n    conflict_table[('x', 'g1', 'x', 'g3')] = 0\\n    conflict_table[('x', 'g2', 'g0', 'g1')] = 4\\n    conflict_table[('x', 'g2', 'g0', 'g3')] = 2\\n    conflict_table[('x', 'g2', 'g0', 'x')] = 2\\n    conflict_table[('x', 'g2', 'g1', 'g0')] = 4\\n    conflict_table[('x', 'g2', 'g1', 'g3')] = 2\\n    conflict_table[('x', 'g2', 'g1', 'x')] = 2\\n    conflict_table[('x', 'g2', 'g3', 'g0')] = 4\\n    conflict_table[('x', 'g2', 'g3', 'g1')] = 4\\n    conflict_table[('x', 'g2', 'g3', 'x')] = 0\\n    conflict_table[('x', 'g2', 'x', 'g0')] = 2\\n    conflict_table[('x', 'g2', 'x', 'g1')] = 2\\n    conflict_table[('x', 'g2', 'x', 'g3')] = 0\\n    conflict_table[('x', 'g3', 'g0', 'g1')] = 4\\n    conflict_table[('x', 'g3', 'g0', 'g2')] = 4\\n    conflict_table[('x', 'g3', 'g0', 'x')] = 2\\n    conflict_table[('x', 'g3', 'g1', 'g0')] = 4\\n    conflict_table[('x', 'g3', 'g1', 'g2')] = 4\\n    conflict_table[('x', 'g3', 'g1', 'x')] = 2\\n    conflict_table[('x', 'g3', 'g2', 'g0')] = 4\\n    conflict_table[('x', 'g3', 'g2', 'g1')] = 4\\n    conflict_table[('x', 'g3', 'g2', 'x')] = 2\\n    conflict_table[('x', 'g3', 'x', 'g0')] = 2\\n    conflict_table[('x', 'g3', 'x', 'g1')] = 2\\n    conflict_table[('x', 'g3', 'x', 'g2')] = 2\\n    conflict_table[('x', 'x', 'g0', 'g1')] = 0\\n    conflict_table[('x', 'x', 'g0', 'g2')] = 0\\n    conflict_table[('x', 'x', 'g0', 'g3')] = 0\\n    conflict_table[('x', 'x', 'g1', 'g0')] = 2\\n    conflict_table[('x', 'x', 'g1', 'g2')] = 0\\n    conflict_table[('x', 'x', 'g1', 'g3')] = 0\\n    conflict_table[('x', 'x', 'g2', 'g0')] = 2\\n    conflict_table[('x', 'x', 'g2', 'g1')] = 2\\n    conflict_table[('x', 'x', 'g2', 'g3')] = 0\\n    conflict_table[('x', 'x', 'g3', 'g0')] = 2\\n    conflict_table[('x', 'x', 'g3', 'g1')] = 2\\n    conflict_table[('x', 'x', 'g3', 'g2')] = 2\\n        \\ndef linear_conflicts(start_list,goal_list):\\n    \""\""\""\\n    calculates number of moves to add to the estimate of\\n    the moves to get from start to goal based on the number\\n    of conflicts on a given row or column. start_list\\n    represents the current location and goal_list represnts\\n    the final goal.\\n    \""\""\""\\n    \\n    # Find which of the tiles in start_list have their goals on this line\\n    # build a pattern to use in a lookup table of this form:\\n    # g0, g1, g3, g3 fill in x where there is no goal for this line\\n    \\n    # all 'x' until we file a tile whose goal is in this line\\n    \\n    goal_pattern = ['x', 'x', 'x', 'x']\\n    \\n    for g in range(4):\\n        for s in range(4):\\n            start_tile_num = start_list[s]\\n            if start_tile_num == goal_list[g] and start_tile_num != 0:\\n                goal_pattern[s] = 'g' + str(g) # i.e. g0\\n                                \\n    global conflict_table\\n    \\n    tup_goal_pattern = tuple(goal_pattern)\\n    \\n    if tup_goal_pattern in conflict_table:\\n        return conflict_table[tuple(goal_pattern)]\\n    else:\\n        return 0\\n    \\nclass lcmap(dict):\\n    \""\""\"" \\n    Lets you return 0 if you look for an object that\\n    is not in the dictionary. \\n    \""\""\""\\n    def __missing__(self, key):\\n        return 0\\n\\ndef listconflicts(goal_list):\\n    \""\""\"" \\n    list all possible start lists that will have at least\\n    one linear conflict.\\n    \\n    Possible goal tile configurations\\n    \\n    g g g g\\n    g g g x\\n    g g x g\\n    g x g g\\n    x g g g\\n    g g x x\\n    g x g x\\n    g x x g\\n    x g g x\\n    x g x g\\n    x x g g\\n        \\n    \""\""\""\\n    \\n    all_tiles = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\\n    \\n    non_goal_tiles = []\\n    \\n    for t in all_tiles:\\n        if t not in goal_list:\\n            non_goal_tiles.append(t) \\n            \\n    combinations = lcmap()\\n\\n    # g g g g\\n    \\n    for i in goal_list:\\n        tile_list2 = goal_list[:]\\n        tile_list2.remove(i)\\n        for j in tile_list2:\\n            tile_list3 = tile_list2[:]\\n            tile_list3.remove(j)\\n            for k in tile_list3:\\n                tile_list4 = tile_list3[:]\\n                tile_list4.remove(k)\\n                for l in tile_list4:\\n                    start_list = (i, j, k, l)\\n                    conflictadd = linear_conflicts(start_list,goal_list)\\n                    if conflictadd > 0:\\n                        combinations[start_list]=conflictadd    \\n    \\n    # g g g x\\n    \\n    for i in goal_list:\\n        tile_list2 = goal_list[:]\\n        tile_list2.remove(i)\\n        for j in tile_list2:\\n            tile_list3 = tile_list2[:]\\n            tile_list3.remove(j)\\n            for k in tile_list3:\\n                for l in non_goal_tiles:\\n                    start_list = (i, j, k, l)\\n                    conflictadd = linear_conflicts(start_list,goal_list)\\n                    if conflictadd > 0:\\n                        combinations[start_list]=conflictadd  \\n\\n    # g g x g\\n    \\n    for i in goal_list:\\n        tile_list2 = goal_list[:]\\n        tile_list2.remove(i)\\n        for j in tile_list2:\\n            tile_list3 = tile_list2[:]\\n            tile_list3.remove(j)\\n            for k in non_goal_tiles:\\n                for l in tile_list3:\\n                    start_list = (i, j, k, l)\\n                    conflictadd = linear_conflicts(start_list,goal_list)\\n                    if conflictadd > 0:\\n                        combinations[start_list]=conflictadd\\n    # g x g g\\n    \\n    for i in goal_list:\\n        tile_list2 = goal_list[:]\\n        tile_list2.remove(i)\\n        for j in non_goal_tiles:\\n            for k in tile_list2:\\n                tile_list3 = tile_list2[:]\\n                tile_list3.remove(k)\\n                for l in tile_list3:\\n                    start_list = (i, j, k, l)\\n                    conflictadd = linear_conflicts(start_list,goal_list)\\n                    if conflictadd > 0:\\n                        combinations[start_list]=conflictadd\\n\\n    # x g g g\\n    \\n    for i in non_goal_tiles:\\n        for j in goal_list:\\n            tile_list2 = goal_list[:]\\n            tile_list2.remove(j)\\n            for k in tile_list2:\\n                tile_list3 = tile_list2[:]\\n                tile_list3.remove(k)\\n                for l in tile_list3:\\n                    start_list = (i, j, k, l)\\n                    conflictadd = linear_conflicts(start_list,goal_list)\\n                    if conflictadd > 0:\\n                        combinations[start_list]=conflictadd\\n\\n    # g g x x\\n\\n    for i in goal_list:\\n        tile_list2 = goal_list[:]\\n        tile_list2.remove(i)\\n        for j in tile_list2:\\n            tile_list3 = tile_list2[:]\\n            tile_list3.remove(j)\\n            for k in non_goal_tiles:\\n                tile_list4 = non_goal_tiles[:]\\n                tile_list4.remove(k)\\n                for l in tile_list4:\\n                    start_list = (i, j, k, l)\\n                    conflictadd = linear_conflicts(start_list,goal_list)\\n                    if conflictadd > 0:\\n                        combinations[start_list]=conflictadd \\n                        \\n    # g x g x\\n\\n    for i in goal_list:\\n        tile_list2 = goal_list[:]\\n        tile_list2.remove(i)\\n        for j in non_goal_tiles:\\n            tile_list3 = non_goal_tiles[:]\\n            tile_list3.remove(j)\\n            for k in tile_list2:\\n                for l in tile_list3:\\n                    start_list = (i, j, k, l)\\n                    conflictadd = linear_conflicts(start_list,goal_list)\\n                    if conflictadd > 0:\\n                        combinations[start_list]=conflictadd    \\n                        \\n    # g x x g\\n\\n    for i in goal_list:\\n        tile_list2 = goal_list[:]\\n        tile_list2.remove(i)\\n        for j in non_goal_tiles:\\n            tile_list3 = non_goal_tiles[:]\\n            tile_list3.remove(j)\\n            for k in tile_list2:\\n                for l in tile_list3:\\n                    start_list = (i, j, k, l)\\n                    conflictadd = linear_conflicts(start_list,goal_list)\\n                    if conflictadd > 0:\\n                        combinations[start_list]=conflictadd     \\n    \\n    # x g g x\\n\\n    for i in non_goal_tiles:\\n        tile_list2 = non_goal_tiles[:]\\n        tile_list2.remove(i)\\n        for j in goal_list:\\n            tile_list3 = goal_list[:]\\n            tile_list3.remove(j)\\n            for k in tile_list3:\\n                for l in tile_list2:\\n                    start_list = (i, j, k, l)\\n                    conflictadd = linear_conflicts(start_list,goal_list)\\n                    if conflictadd > 0:\\n                        combinations[start_list]=conflictadd      \\n    \\n    # x g x g\\n    \\n    for i in non_goal_tiles:\\n        tile_list2 = non_goal_tiles[:]\\n        tile_list2.remove(i)\\n        for j in goal_list:\\n            tile_list3 = goal_list[:]\\n            tile_list3.remove(j)\\n            for k in tile_list3:\\n                for l in tile_list2:\\n                    start_list = (i, j, k, l)\\n                    conflictadd = linear_conflicts(start_list,goal_list)\\n                    if conflictadd > 0:\\n                        combinations[start_list]=conflictadd      \\n      \\n    # x x g g\\n    \\n    for i in non_goal_tiles:\\n        tile_list2 = non_goal_tiles[:]\\n        tile_list2.remove(i)\\n        for j in tile_list2:\\n            for k in goal_list:\\n                tile_list3 = goal_list[:]\\n                tile_list3.remove(k)\\n                for l in tile_list3:\\n                    start_list = (i, j, k, l)\\n                    conflictadd = linear_conflicts(start_list,goal_list)\\n                    if conflictadd > 0:\\n                        combinations[start_list]=conflictadd      \\n      \\n    return combinations\\n\\n\\nclass HeuristicObj(object):\\n    \""\""\"" Object used to preprocess goal position for heuristic function \""\""\""\\n\\n    def __init__(self, goal):\\n        \""\""\""\\n        Preprocess goal position to setup internal data structures\\n        that can be used to speed up heuristic.\\n        \""\""\""\\n        \\n        build_conflict_table()\\n        \\n        self.goal_map = []\\n        for i in range(16):\\n            self.goal_map.append(i)    \\n        \\n        self.goal_lists = goal.tiles\\n        \\n        # preprocess for manhattan distance\\n        \\n        for row in range(4):\\n            for col in range(4):\\n                self.goal_map[goal.tiles[row][col]] = (row, col)\\n                \\n        # make access faster by changing to a tuple\\n        \\n        self.goal_map = tuple(self.goal_map)\\n                \\n        # preprocess for linear conflicts\\n        \\n        self.row_conflicts = []\\n        for row in range(4):\\n            t = goal.tiles[row]\\n            conf_dict = listconflicts([t[0],t[1],t[2],t[3]])\\n            self.row_conflicts.append(conf_dict)\\n            \\n        self.col_conflicts = []\\n        for col in range(4):\\n            col_list =[]\\n            for row in range(4):\\n                col_list.append(goal.tiles[row][col])\\n            conf_dict = listconflicts(col_list)\\n            self.col_conflicts.append(conf_dict)\\n\\n    def heuristic(self, start):\\n        \""\""\"" \\n        \\n        Estimates the number of moves from start to goal.\\n        The goal was preprocessed in __init__.\\n        \\n        \""\""\""\\n        \\n        distance = 0\\n        \\n        # local variables for instance variables\\n        \\n        t = start.tiles\\n        g = self.goal_map\\n        rc = self.row_conflicts\\n        cc = self.col_conflicts\\n        \\n        # calculate manhattan distance\\n        \\n        for row in range(4):\\n            for col in range(4):\\n                start_tilenum = t[row][col]\\n                if start_tilenum != 0:\\n                    (grow, gcol) = g[start_tilenum]\\n                    distance += abs(row - grow) + abs(col - gcol)\\n                                        \\n        # add linear conflicts \\n        \\n        for row in range(4):\\n            curr_row = t[row]\\n            distance += rc[row][curr_row]\\n       \\n        for col in range(4):\\n            col_tuple = (t[0][col], t[1][col], t[2][col], t[3][col])\\n            distance += cc[col][col_tuple]\\n          \\n        return distance\\n        \\n# global variable for heuristic object\\n\\nhob = None\\n        \\ndef a_star(start_tiles, goal_tiles):\\n    \""\""\"" Based on https://en.wikipedia.org/wiki/A*_search_algorithm \""\""\""\\n    \\n    start = new_position(start_tiles)\\n    goal = new_position(goal_tiles)\\n    \\n    # Process goal position for use in heuristic\\n    \\n    global hob\\n    hob = HeuristicObj(goal)\\n    \\n    # The set of currently discovered nodes that are not evaluated yet.\\n    # Initially, only the start node is known.\\n    # For the first node, the fscore is completely heuristic.\\n    \\n    start.fscore = hob.heuristic(start)\\n    openSet = PriorityQueue([start])\\n \\n    # The cost of going from start to start is zero.\\n    \\n    start.gscore = 0\\n    \\n    num_popped = 0\\n    \\n    while openSet.queue_length > 0:\\n        current = openSet.pop()\\n        if current == None: # tried to pop but only found old fscore values\\n            break\\n        num_popped += 1\\n        if num_popped % 100000 == 0:\\n            print(str(num_popped)+\"" positions examined\"")\\n        \\n        if current == goal:\\n            return reconstruct_path(current)\\n            \\n        for neighbor in current.neighbors():\\n\\n            # The distance from start to a neighbor\\n            # All nodes are 1 move from their neighbors\\n            \\n            tentative_gScore = current.gscore + 1\\n            \\n            # update gscore and fscore if this is shorter path\\n            # to the neighbor node\\n\\n            if tentative_gScore < neighbor.gscore: \\n                neighbor.cameFrom = current\\n                neighbor.gscore = tentative_gScore\\n                neighbor.fscore = neighbor.gscore + hob.heuristic(neighbor)\\n                openSet.push(neighbor) # add to open set every time\\n                \\n\\ndef find_zero(tiles):\\n    \""\""\"" file the 0 tile \""\""\""\\n    for row in range(4):\\n        for col in range(4):\\n            if tiles[row][col] == 0:\\n                return (row, col)\\n\\ndef path_as_0_moves(path):\\n    \""\""\""\\n    Takes the path which is a list of Position\\n    objects and outputs it as a string of rlud \\n    directions to match output desired by \\n    Rosetta Code task.\\n    \""\""\""\\n    strpath = \""\""\\n    if len(path) < 1:\\n        return \""\""\\n    prev_pos = path[0]\\n    p_row, p_col = find_zero(prev_pos.tiles)\\n    for i in range(1,len(path)):\\n        curr_pos = path[i]\\n        c_row, c_col = find_zero(curr_pos.tiles)\\n        if c_row > p_row:\\n            strpath += 'd'\\n        elif c_row < p_row:\\n            strpath += 'u'\\n        elif c_col > p_col:\\n            strpath += 'r'\\n        elif c_col < p_col:\\n            strpath += 'l'\\n        # reset for next loop\\n        prev_pos = curr_pos\\n        p_row = c_row\\n        p_col = c_col\\n    return strpath\\n        \\n"
"Python","15_puzzle_solver","Your task is to write a program that finds a solution in the fewest moves possible single moves to a random Fifteen Puzzle Game.\\nFor this task you will be using the following puzzle:\\n\\nThe output must show the moves' directions, like so: left, left, left, down, right... and so on.\\nThere are two solutions, of fifty-two moves:\\nrrrulddluuuldrurdddrullulurrrddldluurddlulurruldrdrd\\nrrruldluuldrurdddluulurrrdlddruldluurddlulurruldrrdd\\nsee: Pretty Print of Optimal Solution\\nFinding either one, or both is an acceptable result.\\nSolve the following problem:\\n\\n\\nsee for an analysis of 20 randomly generated 15 puzzles solved with this solver.\\n","\\n\""\""\""\\n\\nRuns one test of the solver passing a \\nstart and goal position.\\n\\n\""\""\""\\n\\nfrom astar import *\\nimport time\\n\\n# Rosetta Code start position\\n\\n\\nstart_tiles =    [[ 15, 14,  1,  6],\\n                  [ 9, 11,  4, 12],\\n                  [ 0, 10,  7,  3],\\n                  [13,  8,  5,  2]]\\n\\ngoal_tiles =        [[ 1,  2,  3,  4],\\n                     [ 5,  6,  7,  8],\\n                     [ 9, 10, 11, 12],\\n                     [13, 14, 15,  0]]\\n                 \\n\\nbefore = time.perf_counter()\\n\\nresult = a_star(start_tiles,goal_tiles)\\n\\nafter = time.perf_counter()\\n\\nprint(\"" \"")\\nprint(\""Path length = \""+str(len(result) - 1))\\nprint(\"" \"")\\nprint(\""Path using rlud:\"")\\nprint(\"" \"")\\nprint(path_as_0_moves(result))\\nprint(\"" \"")\\nprint(\""Run time in seconds: \""+str(after - before))\\n"
"Python","2048","Implement a 2D sliding block puzzle game where blocks with numbers are combined to add their values.\\nThe rules are that on each turn the player must choose a direction (up, down, left or right) and all tiles move as far as possible in that direction, some more than others. Two adjacent tiles (in that direction only) with matching numbers combine into one bearing the sum of those numbers. A move is valid when at least one tile can be moved, if only by combination. A new tile with the value of 2 is spawned at the end of each turn at a randomly chosen empty square, if there is one. To win the player must create a tile with the number 2048. The player loses if no valid moves are possible.\\nThe name comes from the popular open-source implementation of this game mechanic, 2048.\\nRequirements:\\nto the right should result in\\nand not\\nto the right should result in\\nand not\\n\\n","\\n#!/usr/bin/env python3\\n\\nimport curses\\nfrom random import randrange, choice # generate and place new tile\\nfrom collections import defaultdict\\n\\nletter_codes = [ord(ch) for ch in 'WASDRQwasdrq']\\nactions = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit']\\nactions_dict = dict(zip(letter_codes, actions * 2))\\n\\ndef get_user_action(keyboard):    \\n	char = \""N\""\\n	while char not in actions_dict:    \\n		char = keyboard.getch()\\n	return actions_dict[char]\\n\\ndef transpose(field):\\n	return [list(row) for row in zip(*field)]\\n\\ndef invert(field):\\n	return [row[::-1] for row in field]\\n\\nclass GameField(object):\\n	def __init__(self, height=4, width=4, win=2048):\\n		self.height = height\\n		self.width = width\\n		self.win_value = win\\n		self.score = 0\\n		self.highscore = 0\\n		self.reset()\\n\\n	def reset(self):\\n		if self.score > self.highscore:\\n			self.highscore = self.score\\n		self.score = 0\\n		self.field = [[0 for i in range(self.width)] for j in range(self.height)]\\n		self.spawn()\\n		self.spawn()\\n\\n	def move(self, direction):\\n		def move_row_left(row):\\n			def tighten(row): # squeese non-zero elements together\\n				new_row = [i for i in row if i != 0]\\n				new_row += [0 for i in range(len(row) - len(new_row))]\\n				return new_row\\n\\n			def merge(row):\\n				pair = False\\n				new_row = []\\n				for i in range(len(row)):\\n					if pair:\\n						new_row.append(2 * row[i])\\n						self.score += 2 * row[i]\\n						pair = False\\n					else:\\n						if i + 1 < len(row) and row[i] == row[i + 1]:\\n							pair = True\\n							new_row.append(0)\\n						else:\\n							new_row.append(row[i])\\n				assert len(new_row) == len(row)\\n				return new_row\\n			return tighten(merge(tighten(row)))\\n\\n		moves = {}\\n		moves['Left']  = lambda field:								\\\\n				[move_row_left(row) for row in field]\\n		moves['Right'] = lambda field:								\\\\n				invert(moves['Left'](invert(field)))\\n		moves['Up']    = lambda field:								\\\\n				transpose(moves['Left'](transpose(field)))\\n		moves['Down']  = lambda field:								\\\\n				transpose(moves['Right'](transpose(field)))\\n\\n		if direction in moves:\\n			if self.move_is_possible(direction):\\n				self.field = moves[direction](self.field)\\n				self.spawn()\\n				return True\\n			else:\\n				return False\\n\\n	def is_win(self):\\n		return any(any(i >= self.win_value for i in row) for row in self.field)\\n\\n	def is_gameover(self):\\n		return not any(self.move_is_possible(move) for move in actions)\\n\\n	def draw(self, screen):\\n		help_string1 = '(W)Up (S)Down (A)Left (D)Right'\\n		help_string2 = '     (R)Restart (Q)Exit'\\n		gameover_string = '           GAME OVER'\\n		win_string = '          YOU WIN!'\\n		def cast(string):\\n			screen.addstr(string + '\\n')\\n\\n		def draw_hor_separator():\\n			top = '┌' + ('┬──────' * self.width + '┐')[1:]\\n			mid = '├' + ('┼──────' * self.width + '┤')[1:]\\n			bot = '└' + ('┴──────' * self.width + '┘')[1:]\\n			separator = defaultdict(lambda: mid)\\n			separator[0], separator[self.height] = top, bot\\n			if not hasattr(draw_hor_separator, \""counter\""):\\n				draw_hor_separator.counter = 0\\n			cast(separator[draw_hor_separator.counter])\\n			draw_hor_separator.counter += 1\\n\\n		def draw_row(row):\\n			cast(''.join('│{: ^5} '.format(num) if num > 0 else '|      ' for num in row) + '│')\\n\\n		screen.clear()\\n		cast('SCORE: ' + str(self.score))\\n		if 0 != self.highscore:\\n			cast('HGHSCORE: ' + str(self.highscore))\\n		for row in self.field:\\n			draw_hor_separator()\\n			draw_row(row)\\n		draw_hor_separator()\\n		if self.is_win():\\n			cast(win_string)\\n		else:\\n			if self.is_gameover():\\n				cast(gameover_string)\\n			else:\\n				cast(help_string1)\\n		cast(help_string2)\\n\\n	def spawn(self):\\n		new_element = 4 if randrange(100) > 89 else 2\\n		(i,j) = choice([(i,j) for i in range(self.width) for j in range(self.height) if self.field[i][j] == 0])\\n		self.field[i][j] = new_element\\n\\n	def move_is_possible(self, direction):\\n		def row_is_left_movable(row): \\n			def change(i): # true if there'll be change in i-th tile\\n				if row[i] == 0 and row[i + 1] != 0: # Move\\n					return True\\n				if row[i] != 0 and row[i + 1] == row[i]: # Merge\\n					return True\\n				return False\\n			return any(change(i) for i in range(len(row) - 1))\\n\\n		check = {}\\n		check['Left']  = lambda field:								\\\\n				any(row_is_left_movable(row) for row in field)\\n\\n		check['Right'] = lambda field:								\\\\n				 check['Left'](invert(field))\\n\\n		check['Up']    = lambda field:								\\\\n				check['Left'](transpose(field))\\n\\n		check['Down']  = lambda field:								\\\\n				check['Right'](transpose(field))\\n\\n		if direction in check:\\n			return check[direction](self.field)\\n		else:\\n			return False\\n\\ndef main(stdscr):\\n	curses.use_default_colors()\\n	game_field = GameField(win=32)\\n	state_actions = {} # Init, Game, Win, Gameover, Exit\\n	def init():\\n		game_field.reset()\\n		return 'Game'\\n\\n	state_actions['Init'] = init\\n\\n	def not_game(state):\\n		game_field.draw(stdscr)\\n		action = get_user_action(stdscr)\\n		responses = defaultdict(lambda: state)\\n		responses['Restart'], responses['Exit'] = 'Init', 'Exit'\\n		return responses[action]\\n\\n	state_actions['Win'] = lambda: not_game('Win')\\n	state_actions['Gameover'] = lambda: not_game('Gameover')\\n\\n	def game():\\n		game_field.draw(stdscr)\\n		action = get_user_action(stdscr)\\n		if action == 'Restart':\\n			return 'Init'\\n		if action == 'Exit':\\n			return 'Exit'\\n		if game_field.move(action): # move successful\\n			if game_field.is_win():\\n				return 'Win'\\n			if game_field.is_gameover():\\n				return 'Gameover'\\n		return 'Game'\\n		\\n	state_actions['Game'] = game\\n\\n	state = 'Init'\\n	while state != 'Exit':\\n		state = state_actions[state]()\\n\\ncurses.wrapper(main)\\n"
"Python","24_game","\\nThe 24 Game tests one's mental arithmetic.\\n\\nWrite a program that randomly chooses and displays four digits, each from 1 ──► 9 (inclusive) with repetitions allowed.\\nThe program should prompt for the player to enter an arithmetic expression using just those, and all of those four digits, used exactly once each. The program should check then evaluate the expression.\\nThe goal is for the player to enter an expression that (numerically) evaluates to 24.\\n\\n\\n\\n\\nThis is a fully-worked sample of the game in 8th, showing error-detection and user-restriction techniques:\\nSee 24 game/ABAP\\ngame24.adb:\\n","'''\\n The 24 Game\\n\\n Given any four digits in the range 1 to 9, which may have repetitions,\\n Using just the +, -, *, and / operators; and the possible use of\\n brackets, (), show how to make an answer of 24.\\n\\n An answer of \""q\"" will quit the game.\\n An answer of \""!\"" will generate a new set of four digits.\\n Otherwise you are repeatedly asked for an expression until it evaluates to 24\\n\\n Note: you cannot form multiple digit numbers from the supplied digits,\\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\\n\\n'''\\n\\nfrom __future__ import division, print_function\\nimport random, ast, re\\nimport sys\\n\\nif sys.version_info[0] < 3: input = raw_input\\n\\ndef choose4():\\n    'four random digits >0 as characters'\\n    return [str(random.randint(1,9)) for i in range(4)]\\n\\ndef welcome(digits):\\n    print (__doc__)\\n    print (\""Your four digits: \"" + ' '.join(digits))\\n\\ndef check(answer, digits):\\n    allowed = set('() +-*/\\t'+''.join(digits))\\n    ok = all(ch in allowed for ch in answer) and \\\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\\n         and not re.search('\\d\\d', answer)\\n    if ok:\\n        try:\\n            ast.parse(answer)\\n        except:\\n            ok = False\\n    return ok\\n\\ndef main():    \\n    digits = choose4()\\n    welcome(digits)\\n    trial = 0\\n    answer = ''\\n    chk = ans = False\\n    while not (chk and ans == 24):\\n        trial +=1\\n        answer = input(\""Expression %i: \"" % trial)\\n        chk = check(answer, digits)\\n        if answer.lower() == 'q':\\n            break\\n        if answer == '!':\\n            digits = choose4()\\n            print (\""New digits:\"", ' '.join(digits))\\n            continue\\n        if not chk:\\n            print (\""The input '%s' was wonky!\"" % answer)\\n        else:\\n            ans = eval(answer)\\n            print (\"" = \"", ans)\\n            if ans == 24:\\n                print (\""Thats right!\"")\\n    print (\""Thank you and goodbye\"")   \\n\\nif __name__ == '__main__': main() "
"Python","24_game","\\nThe 24 Game tests one's mental arithmetic.\\n\\nWrite a program that randomly chooses and displays four digits, each from 1 ──► 9 (inclusive) with repetitions allowed.\\nThe program should prompt for the player to enter an arithmetic expression using just those, and all of those four digits, used exactly once each. The program should check then evaluate the expression.\\nThe goal is for the player to enter an expression that (numerically) evaluates to 24.\\n\\n\\n\\n\\nThis is a fully-worked sample of the game in 8th, showing error-detection and user-restriction techniques:\\nSee 24 game/ABAP\\ngame24.adb:\\n","import random, re\\nchars = [\""(\"",\"")\"",\""/\"",\""+\"",\""-\"",\""*\""]  \\nwhile True:\\n    charsandints, ints = [], []\\n    for x in range(4):\\n        ints.append(str(random.randrange(1,10)))\\n    charsandints = chars + ints\\n    print \""Numbers are:\"", ints\\n    guess = raw_input(\""Enter your guess:\"")\\n    if guess.lower() == \""q\"":\\n        break\\n    elif guess.lower() == \""|\"":\\n        pass\\n    else:\\n        flag = True\\n        for a in guess:\\n            if a not in charsandints or guess.count(a) > charsandints.count(a):\\n                flag = False\\n        if re.search(\""\\d\\d\"", guess):\\n            print \""You cannot combine digits.\""\\n            break\\n        if flag:\\n            print \""Your result is: \"", eval(guess)\\n            if eval(guess) == 24:\\n                print \""You won\""\\n                break\\n            else:\\n                print \""You lost\""\\n                break\\n        else:\\n            print \""You cannot use anthing other than\"", charsandints\\n            break\\nprint \""Thanks for playing\"""
"Python","24_game/Solve","Write a program that takes four digits, either from user input or by random generation, and computes arithmetic expressions following the rules of the 24 game.\\nShow examples of solutions generated by the program.\\n\\n\\nWill generate all possible solutions of any given four numbers according to the rules of the 24 game.\\nNote: the permute function was locally from here\\nSample Runs:\\nExamples:\\nOutput is in RPN.\\n","'''\\n The 24 Game Player\\n \\n Given any four digits in the range 1 to 9, which may have repetitions,\\n Using just the +, -, *, and / operators; and the possible use of\\n brackets, (), show how to make an answer of 24.\\n \\n An answer of \""q\""  will quit the game.\\n An answer of \""!\""  will generate a new set of four digits.\\n An answer of \""!!\"" will ask you for a new set of four digits.\\n An answer of \""?\""  will compute an expression for the current digits.\\n \\n Otherwise you are repeatedly asked for an expression until it evaluates to 24\\n \\n Note: you cannot form multiple digit numbers from the supplied digits,\\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\\n \\n'''\\n \\nfrom   __future__ import division, print_function\\nfrom   itertools  import permutations, combinations, product, \\\\n                         chain\\nfrom   pprint     import pprint as pp\\nfrom   fractions  import Fraction as F\\nimport random, ast, re\\nimport sys\\n \\nif sys.version_info[0] < 3:\\n    input = raw_input\\n    from itertools import izip_longest as zip_longest\\nelse:\\n    from itertools import zip_longest\\n \\n \\ndef choose4():\\n    'four random digits >0 as characters'\\n    return [str(random.randint(1,9)) for i in range(4)]\\n \\ndef ask4():\\n    'get four random digits >0 from the player'\\n    digits = ''\\n    while len(digits) != 4 or not all(d in '123456789' for d in digits):\\n        digits = input('Enter the digits to solve for: ')\\n        digits = ''.join(digits.strip().split())\\n    return list(digits)\\n \\ndef welcome(digits):\\n    print (__doc__)\\n    print (\""Your four digits: \"" + ' '.join(digits))\\n \\ndef check(answer, digits):\\n    allowed = set('() +-*/\\t'+''.join(digits))\\n    ok = all(ch in allowed for ch in answer) and \\\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\\n         and not re.search('\\d\\d', answer)\\n    if ok:\\n        try:\\n            ast.parse(answer)\\n        except:\\n            ok = False\\n    return ok\\n \\ndef solve(digits):\\n    \""\""\""\\\\n    >>> for digits in '3246 4788 1111 123456 1127 3838'.split():\\n            solve(list(digits))\\n \\n \\n    Solution found: 2 + 3 * 6 + 4\\n    '2 + 3 * 6 + 4'\\n    Solution found: ( 4 + 7 - 8 ) * 8\\n    '( 4 + 7 - 8 ) * 8'\\n    No solution found for: 1 1 1 1\\n    '!'\\n    Solution found: 1 + 2 + 3 * ( 4 + 5 ) - 6\\n    '1 + 2 + 3 * ( 4 + 5 ) - 6'\\n    Solution found: ( 1 + 2 ) * ( 1 + 7 )\\n    '( 1 + 2 ) * ( 1 + 7 )'\\n    Solution found: 8 / ( 3 - 8 / 3 )\\n    '8 / ( 3 - 8 / 3 )'\\n    >>> \""\""\""\\n    digilen = len(digits)\\n    # length of an exp without brackets \\n    exprlen = 2 * digilen - 1\\n    # permute all the digits\\n    digiperm = sorted(set(permutations(digits)))\\n    # All the possible operator combinations\\n    opcomb   = list(product('+-*/', repeat=digilen-1))\\n    # All the bracket insertion points:\\n    brackets = ( [()] + [(x,y)\\n                         for x in range(0, exprlen, 2)\\n                         for y in range(x+4, exprlen+2, 2)\\n                         if (x,y) != (0,exprlen+1)]\\n                 + [(0, 3+1, 4+2, 7+3)] ) # double brackets case\\n    for d in digiperm:\\n        for ops in opcomb:\\n            if '/' in ops:\\n                d2 = [('F(%s)' % i) for i in d] # Use Fractions for accuracy\\n            else:\\n                d2 = d\\n            ex = list(chain.from_iterable(zip_longest(d2, ops, fillvalue='')))\\n            for b in brackets:\\n                exp = ex[::]\\n                for insertpoint, bracket in zip(b, '()'*(len(b)//2)):\\n                    exp.insert(insertpoint, bracket)\\n                txt = ''.join(exp)\\n                try:\\n                    num = eval(txt)\\n                except ZeroDivisionError:\\n                    continue\\n                if num == 24:\\n                    if '/' in ops:\\n                        exp = [ (term if not term.startswith('F(') else term[2])\\n                               for term in exp ]\\n                    ans = ' '.join(exp).rstrip()\\n                    print (\""Solution found:\"",ans)\\n                    return ans\\n    print (\""No solution found for:\"", ' '.join(digits))            \\n    return '!'\\n \\ndef main():    \\n    digits = choose4()\\n    welcome(digits)\\n    trial = 0\\n    answer = ''\\n    chk = ans = False\\n    while not (chk and ans == 24):\\n        trial +=1\\n        answer = input(\""Expression %i: \"" % trial)\\n        chk = check(answer, digits)\\n        if answer == '?':\\n            solve(digits)\\n            answer = '!'\\n        if answer.lower() == 'q':\\n            break\\n        if answer == '!':\\n            digits = choose4()\\n            trial = 0\\n            print (\""\\nNew digits:\"", ' '.join(digits))\\n            continue\\n        if answer == '!!':\\n            digits = ask4()\\n            trial = 0\\n            print (\""\\nNew digits:\"", ' '.join(digits))\\n            continue\\n        if not chk:\\n            print (\""The input '%s' was wonky!\"" % answer)\\n        else:\\n            if '/' in answer:\\n                # Use Fractions for accuracy in divisions\\n                answer = ''.join( (('F(%s)' % char) if char in '123456789' else char)\\n                                  for char in answer )\\n            ans = eval(answer)\\n            print (\"" = \"", ans)\\n            if ans == 24:\\n                print (\""Thats right!\"")\\n    print (\""Thank you and goodbye\"")   \\n \\nmain()"
"Python","24_game/Solve","Write a program that takes four digits, either from user input or by random generation, and computes arithmetic expressions following the rules of the 24 game.\\nShow examples of solutions generated by the program.\\n\\n\\nWill generate all possible solutions of any given four numbers according to the rules of the 24 game.\\nNote: the permute function was locally from here\\nSample Runs:\\nExamples:\\nOutput is in RPN.\\n","# -*- coding: utf-8 -*-\\nimport operator\\nfrom itertools import product, permutations\\n\\ndef mydiv(n, d):\\n    return n / d if d != 0 else 9999999\\n\\nsyms = [operator.add, operator.sub, operator.mul, mydiv]\\nop = {sym: ch for sym, ch in zip(syms, '+-*/')}\\n\\ndef solve24(nums):\\n    for x, y, z in product(syms, repeat=3):\\n        for a, b, c, d in permutations(nums):\\n            if round(x(y(a,b),z(c,d)),5) == 24:\\n                return f\""({a} {op[y]} {b}) {op[x]} ({c} {op[z]} {d})\""\\n            elif round(x(a,y(b,z(c,d))),5) == 24:\\n                return f\""{a} {op[x]} ({b} {op[y]} ({c} {op[z]} {d}))\""\\n            elif round(x(y(z(c,d),b),a),5) == 24:\\n                return f\""(({c} {op[z]} {d}) {op[y]} {b}) {op[x]} {a}\""\\n            elif round(x(y(b,z(c,d)),a),5) == 24:\\n                return f\""({b} {op[y]} ({c} {op[z]} {d})) {op[x]} {a}\""\\n    return '--Not Found--'\\n\\nif __name__ == '__main__':\\n    #nums = eval(input('Four integers in the range 1:9 inclusive, separated by commas: '))\\n    for nums in [\\n        [9,4,4,5],\\n        [1,7,2,7],\\n        [5,7,5,4],\\n        [1,4,6,6],\\n        [2,3,7,3],\\n        [8,7,9,7],\\n        [1,6,2,6],\\n        [7,9,4,1],\\n        [6,4,2,2],\\n        [5,7,9,7],\\n        [3,3,8,8],  # Difficult case requiring precise division\\n            ]:\\n        print(f\""solve24({nums}) -> {solve24(nums)}\"")"
"Python","24_game/Solve","Write a program that takes four digits, either from user input or by random generation, and computes arithmetic expressions following the rules of the 24 game.\\nShow examples of solutions generated by the program.\\n\\n\\nWill generate all possible solutions of any given four numbers according to the rules of the 24 game.\\nNote: the permute function was locally from here\\nSample Runs:\\nExamples:\\nOutput is in RPN.\\n","# -*- coding: utf-8 -*-\\n# Python 3\\nfrom operator import mul, sub, add\\n\\n\\ndef div(a, b):\\n    if b == 0:\\n        return 999999.0\\n    return a / b\\n\\nops = {mul: '*', div: '/', sub: '-', add: '+'}\\n\\ndef solve24(num, how, target):\\n    if len(num) == 1:\\n        if round(num[0], 5) == round(target, 5):\\n            yield str(how[0]).replace(',', '').replace(\""'\"", '')\\n    else:\\n        for i, n1 in enumerate(num):\\n            for j, n2 in enumerate(num):\\n                if i != j:\\n                    for op in ops:\\n                        new_num = [n for k, n in enumerate(num) if k != i and k != j] + [op(n1, n2)]\\n                        new_how = [h for k, h in enumerate(how) if k != i and k != j] + [(how[i], ops[op], how[j])]\\n                        yield from solve24(new_num, new_how, target)\\n\\ntests = [\\n         [1, 7, 2, 7],\\n         [5, 7, 5, 4],\\n         [1, 4, 6, 6],\\n         [2, 3, 7, 3],\\n         [1, 6, 2, 6],\\n         [7, 9, 4, 1],\\n         [6, 4, 2, 2],\\n         [5, 7, 9, 7],\\n         [3, 3, 8, 8],  # Difficult case requiring precise division\\n         [8, 7, 9, 7],  # No solution\\n         [9, 4, 4, 5],  # No solution\\n            ]\\nfor nums in tests:\\n    print(nums, end=' : ')\\n    try:\\n        print(next(solve24(nums, nums, 24)))\\n    except StopIteration:\\n        print(\""No solution found\"")\\n"
"Python","4-rings_or_4-squares_puzzle","Replace       a, b, c, d, e, f,   and\\n  g        with the decimal\\ndigits   LOW   ───►   HIGH\\nsuch that the sum of the letters inside of each of the four large squares add up to\\nthe same sum.\\nShow all output here.\\n\\n\\n\\nAs with the REXX solution, we use explicit loops to generate the permutations.\\n","\\nimport itertools\\n\\ndef all_equal(a,b,c,d,e,f,g):\\n    return a+b == b+c+d == d+e+f == f+g\\n\\ndef foursquares(lo,hi,unique,show):\\n    solutions = 0\\n    if unique:\\n        uorn = \""unique\""\\n        citer = itertools.combinations(range(lo,hi+1),7)\\n    else:\\n        uorn = \""non-unique\""\\n        citer =  itertools.combinations_with_replacement(range(lo,hi+1),7)\\n                    \\n    for c in citer:\\n            for p in set(itertools.permutations(c)):\\n                if all_equal(*p):\\n                    solutions += 1\\n                    if show:\\n                        print str(p)[1:-1]\\n\\n    print str(solutions)+\"" \""+uorn+\"" solutions in \""+str(lo)+\"" to \""+str(hi)\\n    print\\n"
"Python","4-rings_or_4-squares_puzzle","Replace       a, b, c, d, e, f,   and\\n  g        with the decimal\\ndigits   LOW   ───►   HIGH\\nsuch that the sum of the letters inside of each of the four large squares add up to\\nthe same sum.\\nShow all output here.\\n\\n\\n\\nAs with the REXX solution, we use explicit loops to generate the permutations.\\n","\\ndef foursquares(lo,hi,unique,show):\\n\\n    def acd_iter():\\n        \""\""\""\\n        Iterates through all the possible valid values of \\n        a, c, and d.\\n        \\n        a = c + d\\n        \""\""\""\\n        for c in range(lo,hi+1):\\n            for d in range(lo,hi+1):\\n                if (not unique) or (c <> d):\\n                    a = c + d\\n                    if a >= lo and a <= hi:\\n                        if (not unique) or (c <> 0 and d <> 0):\\n                            yield (a,c,d)\\n                            \\n    def ge_iter():\\n        \""\""\""\\n        Iterates through all the possible valid values of \\n        g and e.\\n        \\n        g = d + e\\n        \""\""\""\\n        for e in range(lo,hi+1):\\n            if (not unique) or (e not in (a,c,d)):\\n                g = d + e\\n                if g >= lo and g <= hi:\\n                    if (not unique) or (g not in (a,c,d,e)):\\n                        yield (g,e)\\n                        \\n    def bf_iter():\\n        \""\""\""\\n        Iterates through all the possible valid values of \\n        b and f.\\n        \\n        b = e + f - c\\n        \""\""\""\\n        for f in range(lo,hi+1):\\n            if (not unique) or (f not in (a,c,d,g,e)):\\n                b = e + f - c\\n                if b >= lo and b <= hi:\\n                    if (not unique) or (b not in (a,c,d,g,e,f)):\\n                        yield (b,f)\\n\\n    solutions = 0                    \\n    acd_itr = acd_iter()              \\n    for acd in acd_itr:\\n        a,c,d = acd\\n        ge_itr = ge_iter()\\n        for ge in ge_itr:\\n            g,e = ge\\n            bf_itr = bf_iter()\\n            for bf in bf_itr:\\n                b,f = bf\\n                solutions += 1\\n                if show:\\n                    print str((a,b,c,d,e,f,g))[1:-1]\\n    if unique:\\n        uorn = \""unique\""\\n    else:\\n        uorn = \""non-unique\""\\n               \\n    print str(solutions)+\"" \""+uorn+\"" solutions in \""+str(lo)+\"" to \""+str(hi)\\n    print\\n\\n"
"Python","9_billion_names_of_God_the_integer","This task is a variation of the short story by Arthur C. Clarke.\\n(Solvers should be aware of the consequences of completing this task.)\\nIn detail, to specify what is meant by a   “name”:\\n\\nDisplay the first 25 rows of a number triangle which begins:\\nWhere row   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n   corresponds to integer   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n,   and each column   \\n\\n\\n\\nC\\n\\n\\n{\\displaystyle C}\\n\\n   in row   \\n\\n\\n\\nm\\n\\n\\n{\\displaystyle m}\\n\\n   from left to right corresponds to the number of names beginning with   \\n\\n\\n\\nC\\n\\n\\n{\\displaystyle C}\\n\\n.\\nA function   \\n\\n\\n\\nG\\n(\\nn\\n)\\n\\n\\n{\\displaystyle G(n)}\\n\\n   should return the sum of the   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n-th   row.\\nDemonstrate this function by displaying:   \\n\\n\\n\\nG\\n(\\n23\\n)\\n\\n\\n{\\displaystyle G(23)}\\n\\n,   \\n\\n\\n\\nG\\n(\\n123\\n)\\n\\n\\n{\\displaystyle G(123)}\\n\\n,   \\n\\n\\n\\nG\\n(\\n1234\\n)\\n\\n\\n{\\displaystyle G(1234)}\\n\\n,   and   \\n\\n\\n\\nG\\n(\\n12345\\n)\\n\\n\\n{\\displaystyle G(12345)}\\n\\n.\\nOptionally note that the sum of the   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n-th   row   \\n\\n\\n\\nP\\n(\\nn\\n)\\n\\n\\n{\\displaystyle P(n)}\\n\\n   is the     integer partition function.\\nDemonstrate this is equivalent to   \\n\\n\\n\\nG\\n(\\nn\\n)\\n\\n\\n{\\displaystyle G(n)}\\n\\n   by displaying:   \\n\\n\\n\\nP\\n(\\n23\\n)\\n\\n\\n{\\displaystyle P(23)}\\n\\n,   \\n\\n\\n\\nP\\n(\\n123\\n)\\n\\n\\n{\\displaystyle P(123)}\\n\\n,   \\n\\n\\n\\nP\\n(\\n1234\\n)\\n\\n\\n{\\displaystyle P(1234)}\\n\\n,   and   \\n\\n\\n\\nP\\n(\\n12345\\n)\\n\\n\\n{\\displaystyle P(12345)}\\n\\n.\\n\\nIf your environment is able, plot   \\n\\n\\n\\nP\\n(\\nn\\n)\\n\\n\\n{\\displaystyle P(n)}\\n\\n   against   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n   for   \\n\\n\\n\\nn\\n=\\n1\\n…\\n999\\n\\n\\n{\\displaystyle n=1\\ldots 999}\\n\\n.\\n\\n","cache = [[1]]\\ndef cumu(n):\\n    for l in range(len(cache), n+1):\\n        r = [0]\\n        for x in range(1, l+1):\\n            r.append(r[-1] + cache[l-x][min(x, l-x)])\\n        cache.append(r)\\n    return cache[n]\\n\\ndef row(n):\\n    r = cumu(n)\\n    return [r[i+1] - r[i] for i in range(n)]\\n\\nprint \""rows:\""\\nfor x in range(1, 11): print \""%2d:\""%x, row(x)\\n\\n\\nprint \""\\nsums:\""\\nfor x in [23, 123, 1234, 12345]: print x, cumu(x)[-1]"
"Python","9_billion_names_of_God_the_integer","This task is a variation of the short story by Arthur C. Clarke.\\n(Solvers should be aware of the consequences of completing this task.)\\nIn detail, to specify what is meant by a   “name”:\\n\\nDisplay the first 25 rows of a number triangle which begins:\\nWhere row   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n   corresponds to integer   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n,   and each column   \\n\\n\\n\\nC\\n\\n\\n{\\displaystyle C}\\n\\n   in row   \\n\\n\\n\\nm\\n\\n\\n{\\displaystyle m}\\n\\n   from left to right corresponds to the number of names beginning with   \\n\\n\\n\\nC\\n\\n\\n{\\displaystyle C}\\n\\n.\\nA function   \\n\\n\\n\\nG\\n(\\nn\\n)\\n\\n\\n{\\displaystyle G(n)}\\n\\n   should return the sum of the   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n-th   row.\\nDemonstrate this function by displaying:   \\n\\n\\n\\nG\\n(\\n23\\n)\\n\\n\\n{\\displaystyle G(23)}\\n\\n,   \\n\\n\\n\\nG\\n(\\n123\\n)\\n\\n\\n{\\displaystyle G(123)}\\n\\n,   \\n\\n\\n\\nG\\n(\\n1234\\n)\\n\\n\\n{\\displaystyle G(1234)}\\n\\n,   and   \\n\\n\\n\\nG\\n(\\n12345\\n)\\n\\n\\n{\\displaystyle G(12345)}\\n\\n.\\nOptionally note that the sum of the   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n-th   row   \\n\\n\\n\\nP\\n(\\nn\\n)\\n\\n\\n{\\displaystyle P(n)}\\n\\n   is the     integer partition function.\\nDemonstrate this is equivalent to   \\n\\n\\n\\nG\\n(\\nn\\n)\\n\\n\\n{\\displaystyle G(n)}\\n\\n   by displaying:   \\n\\n\\n\\nP\\n(\\n23\\n)\\n\\n\\n{\\displaystyle P(23)}\\n\\n,   \\n\\n\\n\\nP\\n(\\n123\\n)\\n\\n\\n{\\displaystyle P(123)}\\n\\n,   \\n\\n\\n\\nP\\n(\\n1234\\n)\\n\\n\\n{\\displaystyle P(1234)}\\n\\n,   and   \\n\\n\\n\\nP\\n(\\n12345\\n)\\n\\n\\n{\\displaystyle P(12345)}\\n\\n.\\n\\nIf your environment is able, plot   \\n\\n\\n\\nP\\n(\\nn\\n)\\n\\n\\n{\\displaystyle P(n)}\\n\\n   against   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n   for   \\n\\n\\n\\nn\\n=\\n1\\n…\\n999\\n\\n\\n{\\displaystyle n=1\\ldots 999}\\n\\n.\\n\\n","def partitions(N):\\n    diffs,k,s = [],1,1\\n    while k * (3*k-1) < 2*N:\\n        diffs.extend([(2*k - 1, s), (k, s)])\\n	k,s = k+1,-s\\n\\n    out = [1] + [0]*N\\n    for p in range(0, N+1):\\n        x = out[p]\\n	for (o,s) in diffs:\\n           p += o\\n           if p > N: break\\n           out[p] += x*s\\n\\n    return out\\n\\np = partitions(12345)\\nfor x in [23,123,1234,12345]: print x, p[x]"
"Python","9_billion_names_of_God_the_integer","This task is a variation of the short story by Arthur C. Clarke.\\n(Solvers should be aware of the consequences of completing this task.)\\nIn detail, to specify what is meant by a   “name”:\\n\\nDisplay the first 25 rows of a number triangle which begins:\\nWhere row   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n   corresponds to integer   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n,   and each column   \\n\\n\\n\\nC\\n\\n\\n{\\displaystyle C}\\n\\n   in row   \\n\\n\\n\\nm\\n\\n\\n{\\displaystyle m}\\n\\n   from left to right corresponds to the number of names beginning with   \\n\\n\\n\\nC\\n\\n\\n{\\displaystyle C}\\n\\n.\\nA function   \\n\\n\\n\\nG\\n(\\nn\\n)\\n\\n\\n{\\displaystyle G(n)}\\n\\n   should return the sum of the   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n-th   row.\\nDemonstrate this function by displaying:   \\n\\n\\n\\nG\\n(\\n23\\n)\\n\\n\\n{\\displaystyle G(23)}\\n\\n,   \\n\\n\\n\\nG\\n(\\n123\\n)\\n\\n\\n{\\displaystyle G(123)}\\n\\n,   \\n\\n\\n\\nG\\n(\\n1234\\n)\\n\\n\\n{\\displaystyle G(1234)}\\n\\n,   and   \\n\\n\\n\\nG\\n(\\n12345\\n)\\n\\n\\n{\\displaystyle G(12345)}\\n\\n.\\nOptionally note that the sum of the   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n-th   row   \\n\\n\\n\\nP\\n(\\nn\\n)\\n\\n\\n{\\displaystyle P(n)}\\n\\n   is the     integer partition function.\\nDemonstrate this is equivalent to   \\n\\n\\n\\nG\\n(\\nn\\n)\\n\\n\\n{\\displaystyle G(n)}\\n\\n   by displaying:   \\n\\n\\n\\nP\\n(\\n23\\n)\\n\\n\\n{\\displaystyle P(23)}\\n\\n,   \\n\\n\\n\\nP\\n(\\n123\\n)\\n\\n\\n{\\displaystyle P(123)}\\n\\n,   \\n\\n\\n\\nP\\n(\\n1234\\n)\\n\\n\\n{\\displaystyle P(1234)}\\n\\n,   and   \\n\\n\\n\\nP\\n(\\n12345\\n)\\n\\n\\n{\\displaystyle P(12345)}\\n\\n.\\n\\nIf your environment is able, plot   \\n\\n\\n\\nP\\n(\\nn\\n)\\n\\n\\n{\\displaystyle P(n)}\\n\\n   against   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n   for   \\n\\n\\n\\nn\\n=\\n1\\n…\\n999\\n\\n\\n{\\displaystyle n=1\\ldots 999}\\n\\n.\\n\\n","def partitions(n):\\n    partitions.p.append(0)\\n\\n    for k in xrange(1, n + 1):\\n        d = n - k * (3 * k - 1) // 2\\n        if d < 0:\\n            break\\n\\n        if k & 1:\\n            partitions.p[n] += partitions.p[d]\\n        else:\\n            partitions.p[n] -= partitions.p[d]\\n\\n        d -= k\\n        if d < 0:\\n            break\\n\\n        if k & 1:\\n            partitions.p[n] += partitions.p[d]\\n        else:\\n            partitions.p[n] -= partitions.p[d]\\n\\n    return partitions.p[-1]\\n\\npartitions.p = [1]\\n\\ndef main():\\n    ns = set([23, 123, 1234, 12345])\\n    max_ns = max(ns)\\n\\n    for i in xrange(1, max_ns + 1):\\n        if i > max_ns:\\n            break\\n        p = partitions(i)\\n        if i in ns:\\n            print \""%6d: %s\"" % (i, p)\\n\\nmain()"
"Python","99_Bottles_of_Beer","Display the complete lyrics for the song:     99 Bottles of Beer on the Wall.\\n\\nThe lyrics follow this form:\\n 99 bottles of beer on the wall\\n99 bottles of beer\\nTake one down, pass it around\\n98 bottles of beer on the wall\\n 98 bottles of beer on the wall\\n98 bottles of beer\\nTake one down, pass it around\\n97 bottles of beer on the wall\\n... and so on, until reaching 0.\\nGrammatical support for \""1 bottle of beer\"" is optional.\\nAs with any puzzle, try to do it in as creative/concise/comical a way\\nas possible (simple, obvious solutions allowed, too).\\n\\n\\n\\nSee 99 Bottles of Beer/EsoLang\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nor (With ABAP 7.40)\\nSee 99 Bottles of Beer/Lisp\\nwith 1 task to print out the information and 99 tasks to specify the number of bottles\\nImplementation in Apache Ant, due to the limitations of Ant, this requires ant-contrib for arithmetic operations and a dummy target to keep Ant from detecting the loop.\\n\\nNote that the output label text is not displayed until the entire lyrics text has been built and there is some delay between button press and display.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\nOutput can be sent directly to a label with this preferred method as there is no noticeable delay between button press and output.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\n\\n\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Shell\\nSee 99 Bottles of Beer/Shell\\nIf you don't want so many beers, here you can specify the starting amount. \\nFor example, just a sixpack:\\n","\\n\""\""\""Pythonic 99 beer song (readability counts).\""\""\""\\n\\nregular_verse = '''\\\\n{n} bottles of beer on the wall, {n} bottles of beer\\nTake one down and pass it around, {n_minus_1} bottles of beer on the wall.\\n\\n'''\\n\\nending_verses = '''\\\\n2 bottles of beer on the wall, 2 bottles of beer.\\nTake one down and pass it around, 1 bottle of beer on the wall.\\n\\n1 bottle of beer on the wall, 1 bottle of beer.\\nTake one down and pass it around, no more bottles of beer on the wall.\\n\\nNo more bottles of beer on the wall, no more bottles of beer.\\nGo to the store and buy some more, 99 bottles of beer on the wall.\\n\\n'''\\n\\n# @todo: It is possible to refactor the code to avoid n-1 in the code,\\n#        notice that the last line of any verse and the first line of the next\\n#        verse share the same number of bottles. Nevertheless the code\\n#        would be less readliable.\\n\\nfor n in range(99, 2, -1):\\n    print(regular_verse.format(n=n, n_minus_1=n - 1))\\nprint(ending_verses)"
"Python","99_Bottles_of_Beer","Display the complete lyrics for the song:     99 Bottles of Beer on the Wall.\\n\\nThe lyrics follow this form:\\n 99 bottles of beer on the wall\\n99 bottles of beer\\nTake one down, pass it around\\n98 bottles of beer on the wall\\n 98 bottles of beer on the wall\\n98 bottles of beer\\nTake one down, pass it around\\n97 bottles of beer on the wall\\n... and so on, until reaching 0.\\nGrammatical support for \""1 bottle of beer\"" is optional.\\nAs with any puzzle, try to do it in as creative/concise/comical a way\\nas possible (simple, obvious solutions allowed, too).\\n\\n\\n\\nSee 99 Bottles of Beer/EsoLang\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Assembly\\nor (With ABAP 7.40)\\nSee 99 Bottles of Beer/Lisp\\nwith 1 task to print out the information and 99 tasks to specify the number of bottles\\nImplementation in Apache Ant, due to the limitations of Ant, this requires ant-contrib for arithmetic operations and a dummy target to keep Ant from detecting the loop.\\n\\nNote that the output label text is not displayed until the entire lyrics text has been built and there is some delay between button press and display.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\nOutput can be sent directly to a label with this preferred method as there is no noticeable delay between button press and output.\\n<CLICK HERE TO VIEW THE BLOCKS AND OUTPUT>\\n\\n\\nSee 99 Bottles of Beer/Assembly\\nSee 99 Bottles of Beer/Shell\\nSee 99 Bottles of Beer/Shell\\nIf you don't want so many beers, here you can specify the starting amount. \\nFor example, just a sixpack:\\n","\\n\""\""\""Pythonic 99 beer song (readability counts).\""\""\""\\n\\nfirst = '''\\\\n99 bottles of beer on the wall, 99 bottles of beer\\n'''\\n\\nmiddle = '''\\\\nTake one down and pass it around, {n} bottles of beer on the wall.\\n\\n{n} bottles of beer on the wall, {n} bottles of beer\\n'''\\n\\nlast = '''\\\\nTake one down and pass it around, 1 bottle of beer on the wall.\\n\\n1 bottle of beer on the wall, 1 bottle of beer.\\nTake one down and pass it around, no more bottles of beer on the wall.\\n\\nNo more bottles of beer on the wall, no more bottles of beer.\\nGo to the store and buy some more, 99 bottles of beer on the wall.\\n'''\\n\\nprint(first)\\nfor n in range(98, 1, -1):\\n    print(middle.format(n=n))\\nprint(last)"
"Python","99_Bottles_of_Beer/Python","99 Bottles of Beer done in Python.\\n","def sing(b, end):\\n    print(b or 'No more','bottle'+('s' if b-1 else ''), end)\\n\\nfor i in range(99, 0, -1):\\n    sing(i, 'of beer on the wall,')\\n    sing(i, 'of beer,')\\n    print('Take one down, pass it around,')\\n    sing(i-1, 'of beer on the wall.\\n')"
"Python","99_Bottles_of_Beer/Python","99 Bottles of Beer done in Python.\\n","verse = '''\\\\n%i bottles of beer on the wall\\n%i bottles of beer\\nTake one down, pass it around\\n%i bottles of beer on the wall\\n'''\\n\\nfor bottles in range(99,0,-1):\\n    print verse % (bottles, bottles, bottles-1) "
"Python","99_Bottles_of_Beer/Python","99 Bottles of Beer done in Python.\\n","verse = '''\\\\n{some} bottles of beer on the wall\\n{some} bottles of beer\\nTake one down, pass it around\\n{less} bottles of beer on the wall\\n'''\\n\\nfor bottles in range(99,0,-1):\\n    print verse.format(some=bottles, less=bottles-1) "
"Python","99_Bottles_of_Beer/Python","99 Bottles of Beer done in Python.\\n","a, b, c, s = \"" bottles of beer\"", \"" on the wall\\n\"", \""Take one down, pass it around\\n\"", str\\nprint \""\\n\"".join(s(x)+a+b+s(x)+a+\""\\n\""+c+s(x-1)+a+b for x in xrange(99, 0, -1))"
"Python","99_Bottles_of_Beer/Python","99 Bottles of Beer done in Python.\\n","a = lambda n: \""%u bottle%s of beer on the wall\\n\"" % (n, \""s\""[n==1:])\\nprint \""\\n\"".join(a(x)+a(x)[:-13]+\""\\nTake one down, pass it around\\n\""+a(x-1) for x in xrange(99, 0, -1))"
"Python","99_Bottles_of_Beer/Python","99 Bottles of Beer done in Python.\\n","#!/usr/bin/env python3\\n\""\""\""\\\\n{0} {2} of beer on the wall\\n{0} {2} of beer\\nTake one down, pass it around\\n{1} {3} of beer on the wall\\n\""\""\""\\nprint(\""\\n\"".join(\\n    __doc__.format(\\n        i, i - 1,\\n        \""bottle\"" if i == 1 else \""bottles\"",\\n        \""bottle\"" if i - 1 == 1 else \""bottles\""\\n    ) for i in range(99, 0, -1)\\n), end=\""\"")"
"Python","99_Bottles_of_Beer/Python","99 Bottles of Beer done in Python.\\n","ones = (\\n'', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'\\n)\\nprefixes = ('thir', 'four', 'fif', 'six', 'seven', 'eigh', 'nine')\\ntens = ['', '', 'twenty' ]\\nteens = ['ten', 'eleven', 'twelve']\\nfor prefix in prefixes:\\n    tens.append(prefix + 'ty')\\n    teens.append(prefix +'teen')\\ntens[4] = 'forty'\\n\\ndef number(num): \\n    \""get the wordy version of a number\""\\n    ten, one = divmod(num, 10)\\n    if ten == 0 and one == 0:\\n        return 'no'\\n    elif ten == 0:\\n        return ones[one]\\n    elif ten == 1:\\n        return teens[one]\\n    elif one == 0:\\n        return tens[ten]\\n    else:\\n        return \""%s-%s\"" % (tens[ten], ones[one])\\n\\ndef bottles(beer):\\n    \""our rephrase\""\\n    return \""%s bottle%s of beer\"" % ( \\n            number(beer).capitalize(), 's' if beer > 1 else ''\\n    )\\n\\nonthewall = 'on the wall'\\ntakeonedown = 'Take one down, pass it around'\\nfor beer in range(99, 0, -1): \\n    print bottles(beer), onthewall\\n    print bottles(beer)\\n    print takeonedown\\n    print bottles(beer-1), onthewall\\n    print"
"Python","99_Bottles_of_Beer/Python","99 Bottles of Beer done in Python.\\n","for n in xrange(99, 0, -1):\\n    ##  The formatting performs a conditional check on the variable.\\n    ##  If it formats the first open for False, and the second for True\\n    print n, 'bottle%s of beer on the the wall.' % ('s', '')[n == 1]\\n    print n, 'bottle%s of beer.' % ('s', '')[n == 1]\\n    print 'Take one down, pass it around.'\\n    print n - 1, 'bottle%s of beer on the wall.\\n' % ('s', '')[n - 1 == 1]"
"Python","A*_search_algorithm","The A* search algorithm is an extension of Dijkstra's algorithm useful for finding the lowest cost path between two nodes (aka vertices) of a graph. The path may traverse any number of nodes connected by edges (aka arcs) with each edge having an associated cost. The algorithm uses a heuristic which associates an estimate of the lowest cost path from this node to the goal node, such that this estimate is never greater than the actual cost.\\nThe algorithm should not assume that all edge costs are the same. It should be possible to start and finish on any node, including ones identified as a barrier in the task.\\nConsider the problem of finding a route across the diagonal of a chess board-like 8x8 grid. The rows are numbered from 0 to 7. The columns are also numbered 0 to 7. The start position is (0, 0) and the end position is (7, 7). Movement is allow by one square in any direction including diagonals, similar to a king in chess. The standard movement cost is 1. To make things slightly harder, there is a barrier that occupy certain positions of the grid. Moving into any of the barrier positions has a cost of 100.\\nThe barrier occupies the positions (2,4), (2,5), (2,6), (3,6), (4,6), (5,6), (5,5), (5,4), (5,3), (5,2), (4,2) and (3,2).\\nA route with the lowest cost should be found using the A* search algorithm (there are multiple optimal solutions with the same total cost).\\nPrint the optimal route in text format, as well as the total cost of the route.\\nOptionally, draw the optimal route and the barrier positions.\\nNote: using a heuristic score of zero is equivalent to Dijkstra's algorithm and that's kind of cheating/not really A*!\\nUse this algorithm to solve an 8 puzzle. Each node of the input graph will represent an arrangement of the tiles. The nodes will be connected by 4 edges representing swapping the blank tile up, down, left, or right. The cost of each edge is 1. The heuristic will be the sum of the manhatten distance of each numbered tile from its goal position. An 8 puzzle graph will have 9!/2 (181,440) nodes. The 15 puzzle has over 10 trillion nodes. This algorithm may solve simple 15 puzzles (but there are not many of those).\\n\\n\\n\\n","from __future__ import print_function\\nimport matplotlib.pyplot as plt\\n \\nclass AStarGraph(object):\\n	#Define a class board like grid with two barriers\\n \\n	def __init__(self):\\n		self.barriers = []\\n		self.barriers.append([(2,4),(2,5),(2,6),(3,6),(4,6),(5,6),(5,5),(5,4),(5,3),(5,2),(4,2),(3,2)])\\n\\n	def heuristic(self, start, goal):\\n		#Use Chebyshev distance heuristic if we can move one square either\\n		#adjacent or diagonal\\n		D = 1\\n		D2 = 1\\n		dx = abs(start[0] - goal[0])\\n		dy = abs(start[1] - goal[1])\\n		return D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)\\n \\n	def get_vertex_neighbours(self, pos):\\n		n = []\\n		#Moves allow link a chess king\\n		for dx, dy in [(1,0),(-1,0),(0,1),(0,-1),(1,1),(-1,1),(1,-1),(-1,-1)]:\\n			x2 = pos[0] + dx\\n			y2 = pos[1] + dy\\n			if x2 < 0 or x2 > 7 or y2 < 0 or y2 > 7:\\n				continue\\n			n.append((x2, y2))\\n		return n\\n \\n	def move_cost(self, a, b):\\n		for barrier in self.barriers:\\n			if b in barrier:\\n				return 100 #Extremely high cost to enter barrier squares\\n		return 1 #Normal movement cost\\n \\ndef AStarSearch(start, end, graph):\\n \\n	G = {} #Actual movement cost to each position from the start position\\n	F = {} #Estimated movement cost of start to end going via this position\\n \\n	#Initialize starting values\\n	G[start] = 0 \\n	F[start] = graph.heuristic(start, end)\\n \\n	closedVertices = set()\\n	openVertices = set([start])\\n	cameFrom = {}\\n \\n	while len(openVertices) > 0:\\n		#Get the vertex in the open list with the lowest F score\\n		current = None\\n		currentFscore = None\\n		for pos in openVertices:\\n			if current is None or F[pos] < currentFscore:\\n				currentFscore = F[pos]\\n				current = pos\\n\\n		#Check if we have reached the goal\\n		if current == end:\\n			#Retrace our route backward\\n			path = [current]\\n			while current in cameFrom:\\n				current = cameFrom[current]\\n				path.append(current)\\n			path.reverse()\\n			return path, F[end] #Done!\\n \\n		#Mark the current vertex as closed\\n		openVertices.remove(current)\\n		closedVertices.add(current)\\n \\n		#Update scores for vertices near the current position\\n		for neighbour in graph.get_vertex_neighbours(current):\\n			if neighbour in closedVertices: \\n				continue #We have already processed this node exhaustively\\n			candidateG = G[current] + graph.move_cost(current, neighbour)\\n \\n			if neighbour not in openVertices:\\n				openVertices.add(neighbour) #Discovered a new vertex\\n			elif candidateG >= G[neighbour]:\\n				continue #This G score is worse than previously found\\n \\n			#Adopt this G score\\n			cameFrom[neighbour] = current\\n			G[neighbour] = candidateG\\n			H = graph.heuristic(neighbour, end)\\n			F[neighbour] = G[neighbour] + H\\n \\n	raise RuntimeError(\""A* failed to find a solution\"")\\n \\nif __name__==\""__main__\"":\\n	graph = AStarGraph()\\n	result, cost = AStarSearch((0,0), (7,7), graph)\\n	print (\""route\"", result)\\n	print (\""cost\"", cost)\\n	plt.plot([v[0] for v in result], [v[1] for v in result])\\n	for barrier in graph.barriers:\\n		plt.plot([v[0] for v in barrier], [v[1] for v in barrier])\\n	plt.xlim(-1,8)\\n	plt.ylim(-1,8)\\n	plt.show()"
"Python","A+B","A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.\\n\\nGiven two integers,   A and B.\\nTheir sum needs to be calculated.\\n\\nTwo integers are written in the input stream, separated by space(s):\\n\\nThe required output is one integer:   the sum of A and B.\\n\\n\\n","try: raw_input\\nexcept: raw_input = input\\n\\nprint(sum(map(int, raw_input().split())))"
"Python","A+B","A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.\\n\\nGiven two integers,   A and B.\\nTheir sum needs to be calculated.\\n\\nTwo integers are written in the input stream, separated by space(s):\\n\\nThe required output is one integer:   the sum of A and B.\\n\\n\\n","import sys\\n\\nfor line in sys.stdin:\\n    print(sum(map(int, line.split())))"
"Python","Abbreviations,_automatic","The use of   abbreviations   (also sometimes called synonyms, nicknames, AKAs, or aliases)   can be an\\neasy way to add flexibility when specifying or using commands, sub─commands, options, etc.\\n\\nIt would make a list of words easier to maintain   (as words are added, changed, and/or deleted)   if\\nthe minimum abbreviation length of that list could be automatically (programmatically) determined.\\n\\nFor this task, use the list (below) of the days-of-the-week names that are expressed in about a hundred languages   (note that there is a blank line in the list).\\nCaveat:   The list (above) most surely contains errors (or, at the least, differences) of what the actual (or true) names for the days-of-the-week.\\n\\nTo make this Rosetta Code task page as small as possible, if processing the complete list, read the days-of-the-week from a file (that is created from the above list).\\n\\nNotes concerning the above list of words\\n\\n\\n\\n","def shortest_abbreviation_length(line, list_size):\\n    words = line.split()\\n    word_count = len(words)\\n    # Can't give true answer with unexpected number of entries\\n    if word_count != list_size:\\n        raise ValueError(f'Not enough entries, expected {list_size} found {word_count}')\\n\\n    # Find the small slice length that gives list_size unique values\\n    abbreviation_length = 1\\n    abbreviations = set()\\n    while(True):\\n        abbreviations = {word[:abbreviation_length] for word in words}\\n        if len(abbreviations) == list_size:\\n            return abbreviation_length\\n        abbreviation_length += 1\\n        abbreviations.clear()\\n\\ndef automatic_abbreviations(filename, words_per_line):\\n    with open(filename) as file:\\n        for line in file:\\n            line = line.rstrip()\\n            if len(line) > 0:\\n                length = shortest_abbreviation_length(line, words_per_line)\\n                print(f'{length:2} {line}')\\n            else:\\n                print()\\n\\nautomatic_abbreviations('daysOfWeek.txt', 7)"
"Python","Abbreviations,_automatic","The use of   abbreviations   (also sometimes called synonyms, nicknames, AKAs, or aliases)   can be an\\neasy way to add flexibility when specifying or using commands, sub─commands, options, etc.\\n\\nIt would make a list of words easier to maintain   (as words are added, changed, and/or deleted)   if\\nthe minimum abbreviation length of that list could be automatically (programmatically) determined.\\n\\nFor this task, use the list (below) of the days-of-the-week names that are expressed in about a hundred languages   (note that there is a blank line in the list).\\nCaveat:   The list (above) most surely contains errors (or, at the least, differences) of what the actual (or true) names for the days-of-the-week.\\n\\nTo make this Rosetta Code task page as small as possible, if processing the complete list, read the days-of-the-week from a file (that is created from the above list).\\n\\nNotes concerning the above list of words\\n\\n\\n\\n","import operator\\nfrom itertools import (accumulate,\\n                       repeat)\\nfrom pathlib import Path\\nfrom typing import (Iterator,\\n                    List,\\n                    Tuple)\\n\\n\\nFILEPATH = Path('days_of_week.txt')\\n\\n\\ndef read_lines(path: Path) -> Iterator[str]:\\n    with path.open() as file:\\n        yield from file\\n\\n\\ndef cumulative_letters(word: str) -> Iterator[str]:\\n    \""\""\""For a word 'foo' yields 'f', 'fo', 'foo', 'foo', 'foo', ...\""\""\""\\n    yield from accumulate(word, operator.add)\\n    yield from repeat(word)\\n\\n\\ndef words_cumulative_letters(words: List[str]) -> Iterator[Tuple[str, ...]]:\\n    \""\""\""Yields cumulative letters for several words at the same time\""\""\""\\n    yield from zip(*map(cumulative_letters, words))\\n\\n\\ndef longest_string_length(strings: Tuple[str, ...]) -> int:\\n    return max(map(len, strings))\\n\\n\\ndef min_abbreviation_length(words: List[str]) -> int:\\n    def are_unique(abbreviations: Tuple[str, ...]) -> bool:\\n        return len(set(abbreviations)) == len(words)\\n\\n    unique_abbreviations = filter(are_unique, words_cumulative_letters(words))\\n\\n    return longest_string_length(next(unique_abbreviations))\\n\\n\\ndef main():\\n    for line in read_lines(FILEPATH):\\n        words = line.split()\\n        if not words:\\n            print()\\n            continue\\n\\n        count = min_abbreviation_length(words)\\n        print(f'{count} {line}', end='')\\n\\n\\nif __name__ == '__main__':\\n    main()"
"Python","Abbreviations,_automatic","The use of   abbreviations   (also sometimes called synonyms, nicknames, AKAs, or aliases)   can be an\\neasy way to add flexibility when specifying or using commands, sub─commands, options, etc.\\n\\nIt would make a list of words easier to maintain   (as words are added, changed, and/or deleted)   if\\nthe minimum abbreviation length of that list could be automatically (programmatically) determined.\\n\\nFor this task, use the list (below) of the days-of-the-week names that are expressed in about a hundred languages   (note that there is a blank line in the list).\\nCaveat:   The list (above) most surely contains errors (or, at the least, differences) of what the actual (or true) names for the days-of-the-week.\\n\\nTo make this Rosetta Code task page as small as possible, if processing the complete list, read the days-of-the-week from a file (that is created from the above list).\\n\\nNotes concerning the above list of words\\n\\n\\n\\n","import itertools\\n \\n \\n# abbrevLen :: [String] -> Int\\ndef abbrevLen(xs):\\n    n = len(xs)\\n    return next(\\n        len(a[0]) for a in map(\\n            compose(nub)(\\n                _map(concat)\\n            ),\\n            transpose(\\n                map(inits, xs)\\n            )\\n        ) if n == len(a)\\n    )\\n \\n \\n# TEST ----------------------------------------------------\\ndef main():\\n    xs = list(map(strip, lines(\\n        readFile('weekDayNames.txt')\\n    )))\\n    for i, n in enumerate(\\n        map(\\n            compose(abbrevLen)(words),\\n            xs\\n        )\\n    ):\\n        print (n, '  ', xs[i])\\n \\n \\n# GENERIC -------------------------------------------------\\n \\n \\n# compose (<<<) :: (b -> c) -> (a -> b) -> a -> c\\ndef compose(g):\\n    return lambda f: lambda x: g(f(x))\\n \\n \\n# concat :: [String] -> String\\ndef concat(xs):\\n    return ''.join(xs)\\n \\n \\n# inits :: [a] -> [[a]]\\ndef inits(xs):\\n    return scanl(lambda a, x: a + [x])(\\n        []\\n    )(list(xs))\\n \\n \\n# lines :: String -> [String]\\ndef lines(s):\\n    return s.splitlines()\\n \\n \\n# map :: (a -> b) -> [a] -> [b]\\ndef _map(f):\\n    return lambda xs: list(map(f, xs))\\n \\n \\n# nub :: [a] -> [a]\\ndef nub(xs):\\n    return list(dict.fromkeys(xs))\\n \\n \\n# readFile :: FilePath -> IO String\\ndef readFile(fp):\\n    return open(fp).read()\\n \\n \\n# scanl is like reduce, but returns a succession of\\n# intermediate values, building from the left.\\n# scanl :: (b -> a -> b) -> b -> [a] -> [b]\\ndef scanl(f):\\n    return lambda a: lambda xs: (\\n        list(itertools.accumulate([a] + list(xs), f))\\n    )\\n \\n \\n# strip :: String -> String\\ndef strip(s):\\n    return s.strip()\\n \\n \\n# transpose :: [[a]] -> [[a]]\\ndef transpose(xs):\\n    return map(list, zip(*xs))\\n \\n \\n# words :: String -> [String]\\ndef words(s):\\n    return s.split()\\n \\n \\n# MAIN ---\\nif __name__ == '__main__':\\n    main()"
"Python","Abbreviations,_easy","This task is an easier (to code) variant of the Rosetta Code task:    Abbreviations, simple.\\n\\nFor this task, the following   command table   will be used:\\n\\nNotes concerning the above   command table:\\n\\n\\nFor a user string of:\\nthe computer program should return the string:\\n\\n\\nUses Algol 68G specific is lower and to upper procedures. Does not use a hash table.\\n","\\n\\ncommand_table_text = \""\""\""Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy\\n   COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find\\n   NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput\\n   Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO\\n   MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT\\n   READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT\\n   RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up\""\""\""\\n\\nuser_words = \""riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\""\\n\\n\\ndef find_abbreviations_length(command_table_text):\\n    \""\""\"" find the minimal abbreviation length for each word by counting capital letters.\\n        a word that does not have capital letters\\n        gets it's full lengths as the minimum.\\n    \""\""\""\\n    command_table = dict()\\n    for word in command_table_text.split():\\n        abbr_len = sum(1 for c in word if c.isupper())\\n        if abbr_len == 0:\\n            abbr_len = len(word)\\n        command_table[word] = abbr_len\\n    return command_table\\n\\n\\ndef find_abbreviations(command_table):\\n    \""\""\"" for each command insert all possible abbreviations\""\""\""\\n    abbreviations = dict()\\n    for command, min_abbr_len in command_table.items():\\n        for l in range(min_abbr_len, len(command)+1):\\n            abbr = command[:l].lower()\\n            abbreviations[abbr] = command.upper()\\n    return abbreviations\\n\\n\\ndef parse_user_string(user_string, abbreviations):\\n    user_words = [word.lower() for word in user_string.split()]\\n    commands = [abbreviations.get(user_word, \""*error*\"") for user_word in user_words]\\n    return \"" \"".join(commands)\\n\\n\\ncommand_table = find_abbreviations_length(command_table_text)\\nabbreviations_table = find_abbreviations(command_table)\\n\\nfull_words = parse_user_string(user_words, abbreviations_table)\\n\\nprint(\""user words:\"", user_words)\\nprint(\""full words:\"", full_words)\\n"
"Python","Abbreviations,_simple","The use of   abbreviations   (also sometimes called synonyms, nicknames, AKAs, or aliases)   can be an\\neasy way to add flexibility when specifying or using commands, sub─commands, options, etc.\\n\\nFor this task, the following   command table   will be used:\\n\\nNotes concerning the above   command table:\\n\\n\\nFor a user string of:\\nthe computer program should return the string:\\n\\n\\n","\\n\\ncommand_table_text = \""\""\""add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3\\n   compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate\\n   3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2\\n   forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load\\n   locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2\\n   msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3\\n   refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left\\n   2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1\""\""\""\\n\\nuser_words = \""riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\""\\n\\n\\ndef find_abbreviations_length(command_table_text):\\n    \""\""\"" find the minimal abbreviation length for each word.\\n        a word that does not have minimum abbreviation length specified\\n        gets it's full lengths as the minimum.\\n    \""\""\""\\n    command_table = dict()\\n    input_iter = iter(command_table_text.split())\\n\\n    word = None\\n    try:\\n        while True:\\n            if word is None:\\n                word = next(input_iter)\\n            abbr_len = next(input_iter, len(word))\\n            try:\\n                command_table[word] = int(abbr_len)\\n                word = None\\n            except ValueError:\\n                command_table[word] = len(word)\\n                word = abbr_len\\n    except StopIteration:\\n        pass\\n    return command_table\\n\\n\\ndef find_abbreviations(command_table):\\n    \""\""\"" for each command insert all possible abbreviations\""\""\""\\n    abbreviations = dict()\\n    for command, min_abbr_len in command_table.items():\\n        for l in range(min_abbr_len, len(command)+1):\\n            abbr = command[:l].lower()\\n            abbreviations[abbr] = command.upper()\\n    return abbreviations\\n\\n\\ndef parse_user_string(user_string, abbreviations):\\n    user_words = [word.lower() for word in user_string.split()]\\n    commands = [abbreviations.get(user_word, \""*error*\"") for user_word in user_words]\\n    return \"" \"".join(commands)\\n\\n\\ncommand_table = find_abbreviations_length(command_table_text)\\nabbreviations_table = find_abbreviations(command_table)\\n\\nfull_words = parse_user_string(user_words, abbreviations_table)\\n\\nprint(\""user words:\"", user_words)\\nprint(\""full words:\"", full_words)\\n"
"Python","ABC_Problem","\\nYou are given a collection of ABC blocks   (maybe like the ones you had when you were a kid).\\nThere are twenty blocks with two letters on each block.\\nA complete alphabet is guaranteed amongst all sides of the blocks.\\nThe sample collection of blocks:\\n\\nWrite a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks.\\n\\nThe rules are simple:\\n\\n\\nThe program uses one ASSIST macro (XPRNT) to keep the code as short as possible.\\n","\\n'''\\nNote that this code is broken, e.g., it won't work when \\nblocks = [(\""A\"", \""B\""), (\""A\"",\""C\"")] and the word is \""AB\"", where the answer\\nshould be True, but the code returns False.\\n'''\\nblocks = [(\""B\"", \""O\""),\\n          (\""X\"", \""K\""),\\n          (\""D\"", \""Q\""),\\n          (\""C\"", \""P\""),\\n          (\""N\"", \""A\""),\\n          (\""G\"", \""T\""),\\n          (\""R\"", \""E\""),\\n          (\""T\"", \""G\""),\\n          (\""Q\"", \""D\""),\\n          (\""F\"", \""S\""),\\n          (\""J\"", \""W\""),\\n          (\""H\"", \""U\""),\\n          (\""V\"", \""I\""),\\n          (\""A\"", \""N\""),\\n          (\""O\"", \""B\""),\\n          (\""E\"", \""R\""),\\n          (\""F\"", \""S\""),\\n          (\""L\"", \""Y\""),\\n          (\""P\"", \""C\""),\\n          (\""Z\"", \""M\"")]\\n\\n\\ndef can_make_word(word, block_collection=blocks):\\n    \""\""\""\\n    Return True if `word` can be made from the blocks in `block_collection`.\\n\\n    >>> can_make_word(\""\"")\\n    False\\n    >>> can_make_word(\""a\"")\\n    True\\n    >>> can_make_word(\""bark\"")\\n    True\\n    >>> can_make_word(\""book\"")\\n    False\\n    >>> can_make_word(\""treat\"")\\n    True\\n    >>> can_make_word(\""common\"")\\n    False\\n    >>> can_make_word(\""squad\"")\\n    True\\n    >>> can_make_word(\""coNFused\"")\\n    True\\n    \""\""\""\\n    if not word:\\n        return False\\n\\n    blocks_remaining = block_collection[:]\\n    for char in word.upper():\\n        for block in blocks_remaining:\\n            if char in block:\\n                blocks_remaining.remove(block)\\n                break\\n        else:\\n            return False\\n    return True\\n\\n\\nif __name__ == \""__main__\"":\\n    import doctest\\n    doctest.testmod()\\n    print(\"", \"".join(\""'%s': %s\"" % (w, can_make_word(w)) for w in\\n                    [\""\"", \""a\"", \""baRk\"", \""booK\"", \""treat\"", \\n                     \""COMMON\"", \""squad\"", \""Confused\""]))\\n"
"Python","ABC_Problem","\\nYou are given a collection of ABC blocks   (maybe like the ones you had when you were a kid).\\nThere are twenty blocks with two letters on each block.\\nA complete alphabet is guaranteed amongst all sides of the blocks.\\nThe sample collection of blocks:\\n\\nWrite a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks.\\n\\nThe rules are simple:\\n\\n\\nThe program uses one ASSIST macro (XPRNT) to keep the code as short as possible.\\n","BLOCKS = 'BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM'.split()\\n\\ndef _abc(word, blocks):\\n    for i, ch in enumerate(word):\\n        for blk in (b for b in blocks if ch in b):\\n            whatsleft = word[i + 1:]\\n            blksleft = blocks[:]\\n            blksleft.remove(blk)\\n            if not whatsleft: \\n                return True, blksleft\\n            if not blksleft: \\n                return False, blksleft\\n            ans, blksleft = _abc(whatsleft, blksleft)\\n            if ans:\\n                return ans, blksleft\\n        else:\\n            break\\n    return False, blocks\\n\\ndef abc(word, blocks=BLOCKS):\\n    return _abc(word.upper(), blocks)[0]\\n\\nif __name__ == '__main__':\\n    for word in [''] + 'A BARK BoOK TrEAT COmMoN SQUAD conFUsE'.split():\\n        print('Can we spell %9r? %r' % (word, abc(word)))"
"Python","ABC_Problem","\\nYou are given a collection of ABC blocks   (maybe like the ones you had when you were a kid).\\nThere are twenty blocks with two letters on each block.\\nA complete alphabet is guaranteed amongst all sides of the blocks.\\nThe sample collection of blocks:\\n\\nWrite a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks.\\n\\nThe rules are simple:\\n\\n\\nThe program uses one ASSIST macro (XPRNT) to keep the code as short as possible.\\n","def mkword(w, b):\\n    if not w: return []\\n\\n    c,w = w[0],w[1:]\\n    for i in range(len(b)):\\n        if c in b[i]:\\n            m = mkword(w, b[0:i] + b[i+1:])\\n            if m != None: return [b[i]] + m\\n\\ndef abc(w, blk):\\n    return mkword(w.upper(), [a.upper() for a in blk])\\n\\nblocks = 'BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM'.split()\\n\\nfor w in \"", A, bark, book, treat, common, SQUAD, conFUsEd\"".split(', '):\\n    print '\\'' + w + '\\'' + ' ->', abc(w, blocks)"
"Python","Abstract_type","Abstract type is a type without instances or without definition.\\nFor example in object-oriented programming using some languages, abstract types can be partial implementations of other types, which are to be derived there-from. An abstract type may provide implementation of some operations and/or components. Abstract types without any implementation are called interfaces. In the languages that do not support multiple inheritance (Ada, Java), classes can, nonetheless, inherit from multiple interfaces. The languages with multiple inheritance (like C++) usually make no distinction between partially implementable abstract types and interfaces. Because the abstract type's implementation is incomplete,  OO languages normally prevent instantiation from them (instantiation must derived from one of their descendant classes).\\nThe term abstract datatype also may denote a type, with an implementation provided by the programmer rather than directly by the language (a built-in or an inferred type). Here the word abstract means that the implementation is abstracted away, irrelevant for the user of the type. Such implementation can and should be hidden if the language supports separation of implementation and specification. This hides complexity while allowing the implementation to change without repercussions on the usage. The corresponding software design practice is said to follow the information hiding principle.\\nIt is important not to confuse this abstractness (of implementation) with one of the abstract type. The latter is abstract in the sense that the set of its values is empty. In the sense of implementation abstracted away, all user-defined types are abstract.\\nIn some languages, like for example in Objective Caml which is strongly statically typed, it is also possible to have abstract types that are not OO related and are not an abstractness too. These are pure abstract types without any definition even in the implementation and can be used for example for the type algebra, or for some consistence of the type inference. For example in this area, an abstract type can be used as a phantom type to augment another type as its parameter.\\nTask: show how an abstract type can be declared in the language. If the language makes a distinction between interfaces and partially implemented types illustrate both.\\n\\nInterfaces in ABAP are classes with the following restrictions:\\n1. All methods must be abstract instance methods (Static methods aren't allowed).\\n2. Variables must be static final. The values may be computed at run time.\\n3. No static initialiser blockers. No static initialiser helper methods.\\nWhile ActionScript does not support explicit abstract classes, it does have interfaces. Interfaces in ActionScript may not implement any methods and all methods are public and implicitly abstract. Interfaces can extend other interfaces, and interfaces may be multiply inherited.\\nAbstract types can also be simulated using the built-in flash.utils.getQualifiedClassName() function in the constructor to check that the runtime type is an inhertied class, and throwing exceptions from \""abstract\"" methods which can be overridden by inheritors to disable them. If any inheriting class does not implement an abstract method, the error will not be thrown until the non-implemented method is called.\\nInheriting this class:\\nInterfaces in Ada may have no components or implemented operation except for ones implemented as null operations. Interfaces can be multiply inherited.\\nInterfaces can be declared synchronized or task when intended implementations are to be provided by protected objects or tasks. For example:\\nAbstract types may provide components and implementation of their operations. Abstract types are singly inherited.\\nHere Node is an abstract type that is inherited from Limited_Controlled and implements a node of a  doubly linked list. It also implements the interface of a queue described above, because any node can be considered a head of the queue of linked elements. For the operation Finalize an implementation is provided to ensure that the element of a list is removed from there upon its finalization. The operation itself is inherited from the parent type Limited_Controlled and then overridden. The operations Dequeue and Enqueue of the Queue interface are also implemented.\\nUsing records for storing the interface methods and instance arguments (which are similar to Haskell type classes) for overloading:\\nThere is dog and cat is objects of different types for which the interface method is implemented.\\nAn abstract class contains functions that have no body defined. You cannot instantiate a class that contains abstract functions.\\nInterfaces in Aikido define a set of functions, operators, classes, interfaces, monitors or threads (but no variables) that must be implemented by a class implementing the interface.\\nIn AmigaE, abstract methods are supported but interfaces are not.\\nprints to the console:\\nred orange\\n\\nBBC BASIC is a procedural language with no built-in OO features. The CLASSLIB library implements simple Object Classes with multiple inheritance; an abstract class may be created without any instantiation, the sole purpose of which is for other classes to inherit from it. At least one member or method must be declared, but no error will be generated if there is no implementation:\\nDoing abstract types in C is not particularly trivial as C doesn't really support classes. The following series will show an abstract type, followed by a realizable class that provides the abstract interface, and finally followed by an example of usage.\\nThe header file for the abstract class, interfaceAbs.h\\nThat will define the abstract class. The next section declares a public interface for a class providing the interface of the abstract class. This class is Silly and\\nthe code is in file silly.h. Note the actual structure of the class is not provided\\nhere. We don't want it visible.\\nOk. Now it is necessary to provide the implementation of the realizable class.\\nThis code should be in silly.c.\\nThat last macro, ABSTRACT_METHODS may need a little explanation. First note that macros do a string substitution of the parameter values into the arguments of the defined macro, with a little hitch. In the macro definition the ' ## ' expression is special. Here cName ## _Iface gets converted to Silly_Iface, as 'Silly' replaces cName. So the macro call declares an instance of the class record, and defines a constructor named Silly_Instance, which takes a Silly structure as an arguments\\nand uses the class record it previously set up as well.\\nThe methods MyMethod1, MyMethod2, and MyMethod3 are called through the abstract class interface and do not need to be visible outside this file. Hence, they are declared static.\\nNow all's left is some example code that uses all this stuff.\\nYou can declare a virtual function to not have an implementation (called \""pure virtual function\"") by the following \""= 0\"" syntax after the method declaration. A class containing at least one pure virtual function (or inheriting one and not overriding it) cannot be instantiated.\\nBecause C++ allows multiple inheritance of classes, no distinction is made between interfaces and abstract classes.\\nIn Caché, abstract and data type classes cannot be instantiated directly - there must be a 'concrete subclass' that extends them as well as the '%RegisteredObject' class in order to instantiate an object, see example below.\\nData type classes differ because they cannot contain properties, see example below.\\nBoth class types can contain implementation code. Caché allows multiple inheritance of classes, so no distinction is made between abstract classes and interfaces.\\n","class BaseQueue(object):\\n    \""\""\""Abstract/Virtual Class \\n    \""\""\""\\n    def __init__(self):\\n        self.contents = list()\\n        raise NotImplementedError\\n    def Enqueue(self, item):\\n        raise NotImplementedError\\n    def Dequeue(self):\\n        raise NotImplementedError\\n    def Print_Contents(self):\\n        for i in self.contents:\\n            print i,"
"Python","Abstract_type","Abstract type is a type without instances or without definition.\\nFor example in object-oriented programming using some languages, abstract types can be partial implementations of other types, which are to be derived there-from. An abstract type may provide implementation of some operations and/or components. Abstract types without any implementation are called interfaces. In the languages that do not support multiple inheritance (Ada, Java), classes can, nonetheless, inherit from multiple interfaces. The languages with multiple inheritance (like C++) usually make no distinction between partially implementable abstract types and interfaces. Because the abstract type's implementation is incomplete,  OO languages normally prevent instantiation from them (instantiation must derived from one of their descendant classes).\\nThe term abstract datatype also may denote a type, with an implementation provided by the programmer rather than directly by the language (a built-in or an inferred type). Here the word abstract means that the implementation is abstracted away, irrelevant for the user of the type. Such implementation can and should be hidden if the language supports separation of implementation and specification. This hides complexity while allowing the implementation to change without repercussions on the usage. The corresponding software design practice is said to follow the information hiding principle.\\nIt is important not to confuse this abstractness (of implementation) with one of the abstract type. The latter is abstract in the sense that the set of its values is empty. In the sense of implementation abstracted away, all user-defined types are abstract.\\nIn some languages, like for example in Objective Caml which is strongly statically typed, it is also possible to have abstract types that are not OO related and are not an abstractness too. These are pure abstract types without any definition even in the implementation and can be used for example for the type algebra, or for some consistence of the type inference. For example in this area, an abstract type can be used as a phantom type to augment another type as its parameter.\\nTask: show how an abstract type can be declared in the language. If the language makes a distinction between interfaces and partially implemented types illustrate both.\\n\\nInterfaces in ABAP are classes with the following restrictions:\\n1. All methods must be abstract instance methods (Static methods aren't allowed).\\n2. Variables must be static final. The values may be computed at run time.\\n3. No static initialiser blockers. No static initialiser helper methods.\\nWhile ActionScript does not support explicit abstract classes, it does have interfaces. Interfaces in ActionScript may not implement any methods and all methods are public and implicitly abstract. Interfaces can extend other interfaces, and interfaces may be multiply inherited.\\nAbstract types can also be simulated using the built-in flash.utils.getQualifiedClassName() function in the constructor to check that the runtime type is an inhertied class, and throwing exceptions from \""abstract\"" methods which can be overridden by inheritors to disable them. If any inheriting class does not implement an abstract method, the error will not be thrown until the non-implemented method is called.\\nInheriting this class:\\nInterfaces in Ada may have no components or implemented operation except for ones implemented as null operations. Interfaces can be multiply inherited.\\nInterfaces can be declared synchronized or task when intended implementations are to be provided by protected objects or tasks. For example:\\nAbstract types may provide components and implementation of their operations. Abstract types are singly inherited.\\nHere Node is an abstract type that is inherited from Limited_Controlled and implements a node of a  doubly linked list. It also implements the interface of a queue described above, because any node can be considered a head of the queue of linked elements. For the operation Finalize an implementation is provided to ensure that the element of a list is removed from there upon its finalization. The operation itself is inherited from the parent type Limited_Controlled and then overridden. The operations Dequeue and Enqueue of the Queue interface are also implemented.\\nUsing records for storing the interface methods and instance arguments (which are similar to Haskell type classes) for overloading:\\nThere is dog and cat is objects of different types for which the interface method is implemented.\\nAn abstract class contains functions that have no body defined. You cannot instantiate a class that contains abstract functions.\\nInterfaces in Aikido define a set of functions, operators, classes, interfaces, monitors or threads (but no variables) that must be implemented by a class implementing the interface.\\nIn AmigaE, abstract methods are supported but interfaces are not.\\nprints to the console:\\nred orange\\n\\nBBC BASIC is a procedural language with no built-in OO features. The CLASSLIB library implements simple Object Classes with multiple inheritance; an abstract class may be created without any instantiation, the sole purpose of which is for other classes to inherit from it. At least one member or method must be declared, but no error will be generated if there is no implementation:\\nDoing abstract types in C is not particularly trivial as C doesn't really support classes. The following series will show an abstract type, followed by a realizable class that provides the abstract interface, and finally followed by an example of usage.\\nThe header file for the abstract class, interfaceAbs.h\\nThat will define the abstract class. The next section declares a public interface for a class providing the interface of the abstract class. This class is Silly and\\nthe code is in file silly.h. Note the actual structure of the class is not provided\\nhere. We don't want it visible.\\nOk. Now it is necessary to provide the implementation of the realizable class.\\nThis code should be in silly.c.\\nThat last macro, ABSTRACT_METHODS may need a little explanation. First note that macros do a string substitution of the parameter values into the arguments of the defined macro, with a little hitch. In the macro definition the ' ## ' expression is special. Here cName ## _Iface gets converted to Silly_Iface, as 'Silly' replaces cName. So the macro call declares an instance of the class record, and defines a constructor named Silly_Instance, which takes a Silly structure as an arguments\\nand uses the class record it previously set up as well.\\nThe methods MyMethod1, MyMethod2, and MyMethod3 are called through the abstract class interface and do not need to be visible outside this file. Hence, they are declared static.\\nNow all's left is some example code that uses all this stuff.\\nYou can declare a virtual function to not have an implementation (called \""pure virtual function\"") by the following \""= 0\"" syntax after the method declaration. A class containing at least one pure virtual function (or inheriting one and not overriding it) cannot be instantiated.\\nBecause C++ allows multiple inheritance of classes, no distinction is made between interfaces and abstract classes.\\nIn Caché, abstract and data type classes cannot be instantiated directly - there must be a 'concrete subclass' that extends them as well as the '%RegisteredObject' class in order to instantiate an object, see example below.\\nData type classes differ because they cannot contain properties, see example below.\\nBoth class types can contain implementation code. Caché allows multiple inheritance of classes, so no distinction is made between abstract classes and interfaces.\\n","from abc import ABCMeta, abstractmethod\\n\\nclass BaseQueue():\\n    \""\""\""Abstract Class \\n    \""\""\""\\n    __metaclass__ = ABCMeta\\n\\n    def __init__(self):\\n        self.contents = list()\\n\\n    @abstractmethod\\n    def Enqueue(self, item):\\n        pass\\n\\n    @abstractmethod\\n    def Dequeue(self):\\n        pass\\n\\n    def Print_Contents(self):\\n        for i in self.contents:\\n            print i,"
"Python","Abundant,_deficient_and_perfect_number_classifications","These define three classifications of positive integers based on their   proper divisors.\\nLet   P(n)   be the sum of the proper divisors of   n   where the proper divisors are all positive divisors of   n   other than   n   itself.\\n\\n6   has proper divisors of   1,   2,   and   3.\\n1 + 2 + 3 = 6,   so   6   is classed as a perfect number.\\n\\nCalculate how many of the integers   1   to   20,000   (inclusive) are in each of the three classes.\\nShow the results here.\\n\\n\\n",">>> from proper_divisors import proper_divs\\n>>> from collections import Counter\\n>>> \\n>>> rangemax = 20000\\n>>> \\n>>> def pdsum(n):\\n...     return sum(proper_divs(n))\\n... \\n>>> def classify(n, p):\\n...     return 'perfect' if n == p else 'abundant' if p > n else 'deficient'\\n... \\n>>> classes = Counter(classify(n, pdsum(n)) for n in range(1, 1 + rangemax))\\n>>> classes.most_common()\\n[('deficient', 15043), ('abundant', 4953), ('perfect', 4)]\\n>>> "
"Python","Accumulator_factory","A problem posed by Paul Graham is that of creating a function that takes a single (numeric) argument and which returns another function that is an accumulator. The returned accumulator function in turn also takes a single numeric argument, and returns the sum of all the numeric values passed in so far to that accumulator (including the initial value passed when the accumulator was created).\\n\\nThe detailed rules are at http://paulgraham.com/accgensub.html and are reproduced here for simplicity (with additions in small italic text).\\n\\nCreate a function that implements the described rules.\\n\\nIt need not handle any special error cases not described above. The simplest way to implement the task as described is typically to use a closure, providing the language supports them.\\nWhere it is not possible to hold exactly to the constraints above, describe the deviations.\\n\\n",">>> def accumulator(sum):\\n  def f(n):\\n    f.sum += n\\n    return f.sum\\n  f.sum = sum\\n  return f\\n\\n>>> x = accumulator(1)\\n>>> x(5)\\n6\\n>>> x(2.3)\\n8.3000000000000007\\n>>> x = accumulator(1)\\n>>> x(5)\\n6\\n>>> x(2.3)\\n8.3000000000000007\\n>>> x2 = accumulator(3)\\n>>> x2(5)\\n8\\n>>> x2(3.3)\\n11.300000000000001\\n>>> x(0)\\n8.3000000000000007\\n>>> x2(0)\\n11.300000000000001"
"Python","Accumulator_factory","A problem posed by Paul Graham is that of creating a function that takes a single (numeric) argument and which returns another function that is an accumulator. The returned accumulator function in turn also takes a single numeric argument, and returns the sum of all the numeric values passed in so far to that accumulator (including the initial value passed when the accumulator was created).\\n\\nThe detailed rules are at http://paulgraham.com/accgensub.html and are reproduced here for simplicity (with additions in small italic text).\\n\\nCreate a function that implements the described rules.\\n\\nIt need not handle any special error cases not described above. The simplest way to implement the task as described is typically to use a closure, providing the language supports them.\\nWhere it is not possible to hold exactly to the constraints above, describe the deviations.\\n\\n","def accumulator(sum):\\n  def f(n):\\n    nonlocal sum\\n    sum += n\\n    return sum\\n  return f\\n\\nx = accumulator(1)\\nx(5)\\nprint(accumulator(3))\\nprint(x(2.3))"
"Python","Accumulator_factory","A problem posed by Paul Graham is that of creating a function that takes a single (numeric) argument and which returns another function that is an accumulator. The returned accumulator function in turn also takes a single numeric argument, and returns the sum of all the numeric values passed in so far to that accumulator (including the initial value passed when the accumulator was created).\\n\\nThe detailed rules are at http://paulgraham.com/accgensub.html and are reproduced here for simplicity (with additions in small italic text).\\n\\nCreate a function that implements the described rules.\\n\\nIt need not handle any special error cases not described above. The simplest way to implement the task as described is typically to use a closure, providing the language supports them.\\nWhere it is not possible to hold exactly to the constraints above, describe the deviations.\\n\\n","def accumulator(sum):\\n  while True:\\n    sum += yield sum\\n\\nx = accumulator(1)\\nx.send(None)\\nx.send(5)\\nprint(accumulator(3))\\nprint(x.send(2.3))"
"Python","Ackermann_function","The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.\\n\\nThe Ackermann function is usually defined as follows:\\n\\n","def ack1(M, N):\\n   return (N + 1) if M == 0 else (\\n      ack1(M-1, 1) if N == 0 else ack1(M-1, ack1(M, N-1)))"
"Python","Ackermann_function","The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.\\n\\nThe Ackermann function is usually defined as follows:\\n\\n","from functools import lru_cache\\n\\n@lru_cache(None)\\ndef ack2(M, N):\\n    if M == 0:\\n        return N + 1\\n    elif N == 0:\\n        return ack2(M - 1, 1)\\n    else:\\n        return ack2(M - 1, ack2(M, N - 1))"
"Python","Ackermann_function","The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.\\n\\nThe Ackermann function is usually defined as follows:\\n\\n",">>> import sys\\n>>> sys.setrecursionlimit(3000)\\n>>> ack1(0,0)\\n1\\n>>> ack1(3,4)\\n125\\n>>> ack2(0,0)\\n1\\n>>> ack2(3,4)\\n125"
"Python","Ackermann_function","The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.\\n\\nThe Ackermann function is usually defined as follows:\\n\\n","def ack2(M, N):\\n   return (N + 1)   if M == 0 else (\\n          (N + 2)   if M == 1 else (\\n          (2*N + 3) if M == 2 else (\\n          (8*(2**N - 1) + 5) if M == 3 else (\\n          ack2(M-1, 1) if N == 0 else ack2(M-1, ack2(M, N-1))))))"
"Python","Active_Directory/Connect","The task is to establish a connection to an Active Directory or Lightweight Directory Access Protocol server.\\nWith OpenLDAP:\\n\\n\\nBased on dopenldap.\\nThis needs a test case. Is there a LDAP server available?\\nFor Active Directory we use the library System.DirectoryServicesFor your average LDAP server we use System.DirectoryServices.ProtocolFor a minimal example we make an anonymous connect to the local machine on the well-known LDAP port 389\\nlet ldapServer = new System.DirectoryServices.Protocols.LdapDirectoryIdentifier(\""127.0.0.1\"")let connect = new System.DirectoryServices.Protocols.LdapConnection(ldapServer)connect.Bind()\\nGo[edit]\\nLibrary: go-ldap-client\\n\\nThere are a large number of third-party LDAP libraries for Go. This uses one of the simpler ones and the code below is largely taken from the example on its main page.\\n\\npackage main import (    \""log\""    \""github.com/jtblin/go-ldap-client\"") func main() {    client := &ldap.LDAPClient{        Base:         \""dc=example,dc=com\"",        Host:         \""ldap.example.com\"",        Port:         389,        UseSSL:       false,        BindDN:       \""uid=readonlyuser,ou=People,dc=example,dc=com\"",        BindPassword: \""readonlypassword\"",        UserFilter:   \""(uid=%s)\"",        GroupFilter:  \""(memberUid=%s)\"",        Attributes:   []string{\""givenName\"", \""sn\"", \""mail\"", \""uid\""},    }    defer client.Close()    err := client.Connect()    if err != nil {         log.Fatalf(\""Failed to connect : %+v\"", err)    }    // Do something}\\nHaskell[edit]\\nExample uses the ldap-client package:\\n\\n{-# LANGUAGE OverloadedStrings #-} module Main (main) where import           Data.Foldable (for_)import qualified Data.Text.Encoding as Text (encodeUtf8)import           Ldap.Client (Attr(..), Filter(..))import qualified Ldap.Client as Ldap (Dn(..), Host(..), search, with, typesOnly) main :: IO ()main = do    entries <- Ldap.with (Ldap.Plain \""localhost\"") 389 $ \\ldap ->        Ldap.search ldap (Ldap.Dn \""o=example.com\"") (Ldap.typesOnly True) (Attr \""uid\"" := Text.encodeUtf8 \""user\"") []    for_ entries $ \\entry ->        print entry\\nJava[edit]\\nThis code uses the Apache Directory third-party library.\\n\\nimport java.io.IOException;import org.apache.directory.api.ldap.model.exception.LdapException;import org.apache.directory.ldap.client.api.LdapConnection;import org.apache.directory.ldap.client.api.LdapNetworkConnection; public class LdapConnectionDemo {     public static void main(String[] args) throws LdapException, IOException {        try (LdapConnection connection = new LdapNetworkConnection(\""localhost\"", 10389)) {            connection.bind();            connection.unBind();        }    }}\\nKotlin[edit]\\n import org.apache.directory.api.ldap.model.exception.LdapExceptionimport org.apache.directory.ldap.client.api.LdapNetworkConnectionimport java.io.IOExceptionimport java.util.logging.Levelimport java.util.logging.Logger class LDAP(map: Map<String, String>) {    fun run() {        var connection: LdapNetworkConnection? = null        try {            if (info) log.info(\""LDAP Connection to $hostname on port $port\"")            connection = LdapNetworkConnection(hostname, port.toInt())             try {                if (info) log.info(\""LDAP bind\"")                connection.bind()            } catch (e: LdapException) {                log.severe(e.toString())            }             try {                if (info) log.info(\""LDAP unbind\"")                connection.unBind()            } catch (e: LdapException) {                log.severe(e.toString())            }        } finally {            try {                if (info) log.info(\""LDAP close connection\"")                connection!!.close()            } catch (e: IOException) {                log.severe(e.toString())            }        }    }     private val log = Logger.getLogger(LDAP::class.java.name)    private val info = log.isLoggable(Level.INFO)    private val hostname: String by map    private val port: String by map} fun main(args: Array<String>) = LDAP(mapOf(\""hostname\"" to \""localhost\"", \""port\""  to \""10389\"")).run() \\nNetRexx[edit]\\nUses the Apache LDAP API, connecting to a local ApacheDS LDAP directory server.\\n\\n/* NetRexx */options replace format comments java crossref symbols binary import org.apache.directory.ldap.client.api.LdapConnectionimport org.apache.directory.ldap.client.api.LdapNetworkConnectionimport org.apache.directory.shared.ldap.model.exception.LdapExceptionimport org.slf4j.Loggerimport org.slf4j.LoggerFactory class RDirectoryLDAP public   properties constant    log_ = LoggerFactory.getLogger(RDirectoryLDAP.class)   properties private static    connection = LdapConnection null   method main(args = String[]) public static    ldapHostName = String \""localhost\""    ldapPort = int 10389     if log_.isInfoEnabled() then log_.info(\""LDAP Connection to\"" ldapHostName \""on port\"" ldapPort)    connection = LdapNetworkConnection(ldapHostName, ldapPort)     do      if log_.isTraceEnabled() then log_.trace(\""LDAP bind\"")      connection.bind()       if log_.isTraceEnabled() then log_.trace(\""LDAP unbind\"")      connection.unBind()    catch lex = LdapException      log_.error(\""LDAP Error\"", Throwable lex)    catch iox = IOException      log_.error(\""I/O Error\"", Throwable iox)    finally      do      if connection \\= null then connection.close()      catch iox = IOException        log_.error(\""I/O Error on connection.close()\"", Throwable iox)      end    end     return \\nSample log4j.xml configuration file:\\n\\n<?xml version=\""1.0\"" encoding=\""UTF-8\"" ?><!DOCTYPE log4j:configuration SYSTEM \""log4j.dtd\""><log4j:configuration xmlns:log4j='http://jakarta.apache.org/log4j/'>  <appender name=\""stdout\"" class=\""org.apache.log4j.ConsoleAppender\"">    <param name=\""Target\"" value=\""System.out\"" />    <layout class=\""org.apache.log4j.PatternLayout\"">      <param name=\""ConversionPattern\"" value=\""[%d{HH:mm:ss}] %-5p [%c] - %m%n\"" />    </layout>  </appender>   <!-- with these we'll not get innundated when switching to DEBUG -->  <logger name=\""org.apache.directory.shared.ldap.name\"">    <level value=\""warn\"" />  </logger>  <logger name=\""org.apache.directory.shared.codec\"">    <level value=\""warn\"" />  </logger>  <logger name=\""org.apache.directory.shared.asn1\"">    <level value=\""warn\"" />  </logger>   <root>    <level value=\""info\"" />    <appender-ref ref=\""stdout\"" />  </root></log4j:configuration> \\nOutput:\\n\\n[08:40:05] INFO  [RDirectoryLDAP] - LDAP Connection to localhost on port 10389\\n\\nPerl[edit]\\nLDAP Modules\\n\\n use Net::LDAP; my $ldap = Net::LDAP->new('ldap://ldap.example.com') or die [email protected];my $mesg = $ldap->bind( $bind_dn, password => $bind_pass ); \\nPHP[edit]\\nPHP LDAP Reference\\n\\n<?php$ldap = ldap_connect($hostname, $port);$success = ldap_bind($ldap, $username, $password);\\nPicoLisp[edit]\\n(unless (=0 (setq Ldap (native \""libldap.so\"" \""ldap_open\"" 'N \""example.com\"" 389)))   (quit \""Can't open LDAP\"") ) (native \""libldap.so\"" \""ldap_simple_bind_s\"" 'I Ldap \""user\"" \""password\"")\\nPython[edit]\\nWorks with: Python version 2.6\\nLibrary: python-ldap\\npython-ldap Documentation\\n\\nimport ldap l = ldap.initialize(\""ldap://ldap.example.com\"")try:    l.protocol_version = ldap.VERSION3    l.set_option(ldap.OPT_REFERRALS, 0)     bind = l.simple_bind_s(\""[email protected]\"", \""password\"")finally:    l.unbind() \\nRacket[edit]\\nThis version uses the ldap package, and was tested against OpenLDAP (with real values):\\n\\n#lang racket(require net/ldap)(ldap-authenticate \""ldap.somewhere.com\"" 389 \""uid=username,ou=people,dc=somewhere,dc=com\"" password)\\nTranslation of: C\\nThis is a direct translation of the C code -- I have no idea how to try it out since I don't have a working ldap server... So take it as a stub that waits for someone who can try it to do so. (And it's a low level thing anyway, there's an ldap package for Racket which I can't try for a similar reason.)\\n\\n#lang racket (require ffi/unsafe ffi/unsafe/define) (define-ffi-definer defldap (ffi-lib \""libldap\""))(defldap ldap_init (_fun _string _int -> _pointer))(defldap ldap_unbind (_fun _pointer -> _void))(defldap ldap_simple_bind_s (_fun _pointer _string _string -> _int))(defldap ldap_err2string (_fun _int -> _string)) (define name ...)(define password ...)(define ld (ldap_init \""ldap.somewhere.com\"" 389))(ldap_simple_bind_s ld name password) (ldap_unbind ld)\\nRing[edit]\\n see system(\""dir\"") + nl \\nRuby[edit]\\nSimilar to Tcl, assume the AD server talks LDAP.\\nThere are many Ruby LDAP packages ([1]) -- this solution uses Net::LDAP (\""Pure Ruby LDAP Tools\"" on RubyForge, gem name \""ruby-net-ldap\"")\\n\\nLibrary: RubyGems\\nrequire 'rubygems'require 'net/ldap'ldap = Net::LDAP.new(:host => 'ldap.example.com', :base => 'o=companyname')ldap.authenticate('bind_dn', 'bind_pass')\\nRun BASIC[edit]\\nprint shell$(\""dir\"") ' shell out to the os and print it\\nScala[edit]\\nimport java.io.IOException import org.apache.directory.api.ldap.model.exception.LdapExceptionimport org.apache.directory.ldap.client.api.{LdapConnection, LdapNetworkConnection} object LdapConnectionDemo {  @throws[LdapException]  @throws[IOException]  def main(args: Array[String]): Unit = {    try {      val connection: LdapConnection = new LdapNetworkConnection(\""localhost\"", 10389)      try {        connection.bind()        connection.unBind()      } finally if (connection != null) connection.close()    }  }}\\nsmart BASIC[edit]\\nsmart BASIC uses three separate commands to list the current directory, folder and files respectively.\\n\\nPRINT \""Current directory: \"";CURRENT_DIR$()PRINTPRINT \""Folders:\""PRINTDIR \""/\"" LIST DIRS a$,cFOR n = 0 TO c-1PRINT ,a$(n)NEXT nPRINTPRINT \""Files:\""PRINTDIR \""/\"" LIST FILES a$,cFOR n = 0 TO c-1PRINT ,a$(n)NEXT n\\nTcl[edit]\\nThis does not use SSPI/Kerberos yet, so your AD would need to allow simple ldap access.\\n\\npackage require ldapset conn [ldap::connect $host $port]ldap::bind $conn $user $password\\nVBScript[edit]\\nCreating the normal connection to AD\\n\\nSet objConn = CreateObject(\""ADODB.Connection\"")Set objCmd = CreateObject(\""ADODB.Command\"")objConn.Provider = \""ADsDSOObject\""objConn.Open\\nThere are a large number of third-party LDAP libraries for Go. This uses one of the simpler ones and the code below is largely taken from the example on its main page.\\nExample uses the ldap-client package:\\nThis code uses the Apache Directory third-party library.\\nUses the Apache LDAP API, connecting to a local ApacheDS LDAP directory server.\\nSample log4j.xml configuration file:\\nOutput:\\nLDAP Modules\\nPHP LDAP Reference\\npython-ldap Documentation\\nThis version uses the ldap package, and was tested against OpenLDAP (with real values):\\nThis is a direct translation of the C code -- I have no idea how to try it out since I don't have a working ldap server... So take it as a stub that waits for someone who can try it to do so. (And it's a low level thing anyway, there's an ldap package for Racket which I can't try for a similar reason.)\\nSimilar to Tcl, assume the AD server talks LDAP.\\nThere are many Ruby LDAP packages ([1]) -- this solution uses Net::LDAP (\""Pure Ruby LDAP Tools\"" on RubyForge, gem name \""ruby-net-ldap\"")\\nsmart BASIC uses three separate commands to list the current directory, folder and files respectively.\\nThis does not use SSPI/Kerberos yet, so your AD would need to allow simple ldap access.\\nCreating the normal connection to AD\\n","import ldap\\n\\nl = ldap.initialize(\""ldap://ldap.example.com\"")\\ntry:\\n    l.protocol_version = ldap.VERSION3\\n    l.set_option(ldap.OPT_REFERRALS, 0)\\n\\n    bind = l.simple_bind_s(\""me@example.com\"", \""password\"")\\nfinally:\\n    l.unbind()\\n"
"Python","Active_object","In object-oriented programming an object is active when its state depends on clock. Usually an active object encapsulates a task that updates the object's state. To the outer world the object looks like a normal object with methods that can be called from outside. Implementation of such methods must have a certain synchronization mechanism with the encapsulated task in order to prevent object's state corruption.\\nA typical instance of an active object is an animation widget. The widget state changes with the time, while as an object it has all properties of a normal widget.\\nThe task\\nImplement an active integrator object. The object has an input and output. The input can be set using the method Input. The input is a function of time. The output can be queried using the method Output. The object integrates its input over the time and the result becomes the object's output. So if the input is K(t) and the output is S, the object state S is changed to S + (K(t1) + K(t0)) * (t1 - t0) / 2, i.e. it integrates K using the trapeze method. Initially K is constant 0 and S is 0.\\nIn order to test the object:\\nVerify that now the object's output is approximately 0 (the sine has the period of 2s). The accuracy of the result will depend on the OS scheduler time slicing and the accuracy of the clock.\\nSample output:\\nOutput:\\nUses POSIX threads.\\noutput\\nOutput:\\noutput\\n","from time import time, sleep\\nfrom threading import Thread\\n\\nclass Integrator(Thread):\\n    'continuously integrate a function `K`, at each `interval` seconds'\\n    def __init__(self, K=lambda t:0, interval=1e-4):\\n        Thread.__init__(self)\\n        self.interval  = interval\\n        self.K   = K\\n        self.S   = 0.0\\n        self.__run = True\\n        self.start()\\n\\n    def run(self):\\n        \""entry point for the thread\""\\n        interval = self.interval\\n        start = time()\\n        t0, k0 = 0, self.K(0)\\n        while self.__run:\\n            sleep(interval)\\n            t1 = time() - start\\n            k1 = self.K(t1)\\n            self.S += (k1 + k0)*(t1 - t0)/2.0\\n            t0, k0 = t1, k1\\n\\n    def join(self):\\n        self.__run = False\\n        Thread.join(self)\\n\\nif __name__ == \""__main__\"":\\n    from math import sin, pi\\n \\n    ai = Integrator(lambda t: sin(pi*t))\\n    sleep(2)\\n    print ai.S\\n    ai.K = lambda t: 0\\n    sleep(0.5)\\n    print ai.S"
"Python","Add_a_variable_to_a_class_instance_at_runtime","Demonstrate how to dynamically add variables to an object (a class instance) at runtime.\\nThis is useful when the methods/variables of an instance are based on a data file that isn't available until runtime. Hal Fulton gives an example of creating an OO CSV parser at An Exercise in Metaprogramming with Ruby. This is referred to as \""monkeypatching\"" by Pythonistas and some others.\\nIn ActionScript this can be done using an Object object\\nOr by creating a dynamic class\\nAda is not a dynamically typed language. Yet it supports mix-in inheritance, run-time inheritance and interfaces. These three allow us to achieve the desired effect, however questionably useful it could be. The example declares an interface of the class (Class). Then a concrete type is created (Base). The object E is an instance of Base. Later, at the run time, a new type Monkey_Patch is created such that it refers to E and implements the class interface per delegation to E. Monkey_Patch has a new integer member Foo and EE is an instance of Monkey_Path. For the user EE appears as E with Foo.\\nSample output:\\nIt's not really intended that you should do this, but if you must you can:\\nThis solution saves the original members and methods in a variable, using pattern matching. Then, using macro expansion, a new object is created with an additional member variable and also an additional method. Because the new object is assigned to the same variable as the original object, the original object ceases to exist.\\nOutput:\\n","class empty(object):\\n    pass\\ne = empty()"
"Python","Add_a_variable_to_a_class_instance_at_runtime","Demonstrate how to dynamically add variables to an object (a class instance) at runtime.\\nThis is useful when the methods/variables of an instance are based on a data file that isn't available until runtime. Hal Fulton gives an example of creating an OO CSV parser at An Exercise in Metaprogramming with Ruby. This is referred to as \""monkeypatching\"" by Pythonistas and some others.\\nIn ActionScript this can be done using an Object object\\nOr by creating a dynamic class\\nAda is not a dynamically typed language. Yet it supports mix-in inheritance, run-time inheritance and interfaces. These three allow us to achieve the desired effect, however questionably useful it could be. The example declares an interface of the class (Class). Then a concrete type is created (Base). The object E is an instance of Base. Later, at the run time, a new type Monkey_Patch is created such that it refers to E and implements the class interface per delegation to E. Monkey_Patch has a new integer member Foo and EE is an instance of Monkey_Path. For the user EE appears as E with Foo.\\nSample output:\\nIt's not really intended that you should do this, but if you must you can:\\nThis solution saves the original members and methods in a variable, using pattern matching. Then, using macro expansion, a new object is created with an additional member variable and also an additional method. Because the new object is assigned to the same variable as the original object, the original object ceases to exist.\\nOutput:\\n","   e.foo = 1"
"Python","Add_a_variable_to_a_class_instance_at_runtime","Demonstrate how to dynamically add variables to an object (a class instance) at runtime.\\nThis is useful when the methods/variables of an instance are based on a data file that isn't available until runtime. Hal Fulton gives an example of creating an OO CSV parser at An Exercise in Metaprogramming with Ruby. This is referred to as \""monkeypatching\"" by Pythonistas and some others.\\nIn ActionScript this can be done using an Object object\\nOr by creating a dynamic class\\nAda is not a dynamically typed language. Yet it supports mix-in inheritance, run-time inheritance and interfaces. These three allow us to achieve the desired effect, however questionably useful it could be. The example declares an interface of the class (Class). Then a concrete type is created (Base). The object E is an instance of Base. Later, at the run time, a new type Monkey_Patch is created such that it refers to E and implements the class interface per delegation to E. Monkey_Patch has a new integer member Foo and EE is an instance of Monkey_Path. For the user EE appears as E with Foo.\\nSample output:\\nIt's not really intended that you should do this, but if you must you can:\\nThis solution saves the original members and methods in a variable, using pattern matching. Then, using macro expansion, a new object is created with an additional member variable and also an additional method. Because the new object is assigned to the same variable as the original object, the original object ceases to exist.\\nOutput:\\n","   setattr(e, name, value)"
"Python","Add_a_variable_to_a_class_instance_at_runtime","Demonstrate how to dynamically add variables to an object (a class instance) at runtime.\\nThis is useful when the methods/variables of an instance are based on a data file that isn't available until runtime. Hal Fulton gives an example of creating an OO CSV parser at An Exercise in Metaprogramming with Ruby. This is referred to as \""monkeypatching\"" by Pythonistas and some others.\\nIn ActionScript this can be done using an Object object\\nOr by creating a dynamic class\\nAda is not a dynamically typed language. Yet it supports mix-in inheritance, run-time inheritance and interfaces. These three allow us to achieve the desired effect, however questionably useful it could be. The example declares an interface of the class (Class). Then a concrete type is created (Base). The object E is an instance of Base. Later, at the run time, a new type Monkey_Patch is created such that it refers to E and implements the class interface per delegation to E. Monkey_Patch has a new integer member Foo and EE is an instance of Monkey_Path. For the user EE appears as E with Foo.\\nSample output:\\nIt's not really intended that you should do this, but if you must you can:\\nThis solution saves the original members and methods in a variable, using pattern matching. Then, using macro expansion, a new object is created with an additional member variable and also an additional method. Because the new object is assigned to the same variable as the original object, the original object ceases to exist.\\nOutput:\\n","class empty(object):\\n    def __init__(this):\\n        this.foo = \""whatever\""\\n\\ndef patch_empty(obj):\\n    def fn(self=obj):\\n        print self.foo\\n    obj.print_output = fn\\n\\ne = empty()\\npatch_empty(e)\\ne.print_output()\\n# >>> whatever"
"Python","Address_of_a_variable","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\n\\nDemonstrate how to get the address of a variable and how to set the address of a variable.\\n\\nTo get the address of a variable, use LA (load address) instead of L (load):\\nTo set a variable dynamically at the same address of an other variable, use a DSECT (dummy section):\\nSet the address of a variable to address A100 in hexadecimal\\nSet the address of one variable to the address of another variable, creating an overlay.\\nBasically ALGOL 68 refuses to let the programmer access the memory directly.\\nThe language does allow \""references\"" any variables.\\nThese references are effectively the address a particular variable.\\nBut the value of the actual address is not available\\nfor printing or any arithmetic.\\n","foo = object()  # Create (instantiate) an empty object\\naddress = id(foo)"
"Python","AKS_test_for_primes","The AKS algorithm for testing whether a number is prime is a polynomial-time algorithm based on an elementary theorem about Pascal triangles.\\nThe theorem on which the test is based can be stated as follows:\\nare divisible by   \\n\\n\\n\\np\\n\\n\\n{\\displaystyle p}\\n\\n.\\n\\nUsing   \\n\\n\\n\\np\\n=\\n3\\n\\n\\n{\\displaystyle p=3}\\n\\n:\\n\\nAnd all the coefficients are divisible by 3,   so 3 is prime.\\n\\n\\n\\n\\n\\n","def expand_x_1(n): \\n# This version uses a generator and thus less computations\\n    c =1\\n    for i in range(n//2+1):\\n        c = c*(n-i)//(i+1)\\n        yield c\\n        \\ndef aks(p):\\n    if p==2:\\n        return True\\n\\n    for i in expand_x_1(p):\\n        if i % p:\\n# we stop without computing all possible solutions\\n            return False\\n    return True"
"Python","AKS_test_for_primes","The AKS algorithm for testing whether a number is prime is a polynomial-time algorithm based on an elementary theorem about Pascal triangles.\\nThe theorem on which the test is based can be stated as follows:\\nare divisible by   \\n\\n\\n\\np\\n\\n\\n{\\displaystyle p}\\n\\n.\\n\\nUsing   \\n\\n\\n\\np\\n=\\n3\\n\\n\\n{\\displaystyle p=3}\\n\\n:\\n\\nAnd all the coefficients are divisible by 3,   so 3 is prime.\\n\\n\\n\\n\\n\\n","def aks(p):\\n    if p==2:return True\\n    c=1\\n    for i in range(p//2+1):\\n        c=c*(p-i)//(i+1)\\n        if c%p:return False\\n    return True"
"Python","AKS_test_for_primes","The AKS algorithm for testing whether a number is prime is a polynomial-time algorithm based on an elementary theorem about Pascal triangles.\\nThe theorem on which the test is based can be stated as follows:\\nare divisible by   \\n\\n\\n\\np\\n\\n\\n{\\displaystyle p}\\n\\n.\\n\\nUsing   \\n\\n\\n\\np\\n=\\n3\\n\\n\\n{\\displaystyle p=3}\\n\\n:\\n\\nAnd all the coefficients are divisible by 3,   so 3 is prime.\\n\\n\\n\\n\\n\\n","def expand_x_1(p):\\n    ex = [1]\\n    for i in range(p):\\n        ex.append(ex[-1] * -(p-i) / (i+1))\\n    return ex[::-1]\\n\\ndef aks_test(p):\\n    if p < 2: return False\\n    ex = expand_x_1(p)\\n    ex[0] += 1\\n    return not any(mult % p for mult in ex[0:-1])\\n    \\n    \\nprint('# p: (x-1)^p for small p')\\nfor p in range(12):\\n    print('%3i: %s' % (p, ' '.join('%+i%s' % (e, ('x^%i' % n) if n else '')\\n                                   for n,e in enumerate(expand_x_1(p)))))\\n\\nprint('\\n# small primes using the aks test')\\nprint([p for p in range(101) if aks_test(p)])"
"Python","AKS_test_for_primes","The AKS algorithm for testing whether a number is prime is a polynomial-time algorithm based on an elementary theorem about Pascal triangles.\\nThe theorem on which the test is based can be stated as follows:\\nare divisible by   \\n\\n\\n\\np\\n\\n\\n{\\displaystyle p}\\n\\n.\\n\\nUsing   \\n\\n\\n\\np\\n=\\n3\\n\\n\\n{\\displaystyle p=3}\\n\\n:\\n\\nAnd all the coefficients are divisible by 3,   so 3 is prime.\\n\\n\\n\\n\\n\\n","print('''\\n{| class=\""wikitable\"" style=\""text-align:left;\""\\n|+ Polynomial Expansions and AKS prime test\\n|-\\n! <math>p"
"Python","Align_columns","Given a text file of many lines, where fields within a line\\nare delineated by a single 'dollar' character, write a program\\nthat aligns each column of fields by ensuring that words in each\\ncolumn are separated by at least one space.\\nFurther, allow for each word in a column to be either left\\njustified, right justified, or center justified within its column.\\nUse the following text to test your programs:\\nNote that:\\n\\n","from StringIO import StringIO\\n \\ntextinfile = '''Given$a$text$file$of$many$lines,$where$fields$within$a$line$\\nare$delineated$by$a$single$'dollar'$character,$write$a$program\\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\\ncolumn$are$separated$by$at$least$one$space.\\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\\njustified,$right$justified,$or$center$justified$within$its$column.'''\\n \\nj2justifier = dict(L=str.ljust, R=str.rjust, C=str.center)\\n \\ndef aligner(infile, justification = 'L'):\\n  ''' \\\\n  Justify columns of textual tabular input where the row separator is the newline\\n  and the field separator is a 'dollar' character.\\n  justification can be L, R, or C; (Left, Right, or Centered).\\n \\n  Return the justified output as a string\\n  '''\\n  assert justification in j2justifier, \""justification can be L, R, or C; (Left, Right, or Centered).\""\\n  justifier = j2justifier[justification]\\n \\n  fieldsbyrow= [line.strip().split('$') for line in infile]\\n  # pad to same number of fields per row\\n  maxfields = max(len(row) for row in fieldsbyrow)\\n  fieldsbyrow = [fields + ['']*(maxfields - len(fields))\\n                    for fields in fieldsbyrow]\\n  # rotate\\n  fieldsbycolumn = zip(*fieldsbyrow)\\n  # calculate max fieldwidth per column\\n  colwidths = [max(len(field) for field in column)\\n               for column in fieldsbycolumn]\\n  # pad fields in columns to colwidth with spaces\\n  fieldsbycolumn = [ [justifier(field, width) for field in column]\\n                     for width, column in zip(colwidths, fieldsbycolumn) ]\\n  # rotate again\\n  fieldsbyrow = zip(*fieldsbycolumn)\\n \\n  return \""\\n\"".join( \"" \"".join(row) for row in fieldsbyrow)\\n \\n \\nfor align in 'Left Right Center'.split():\\n  infile = StringIO(textinfile)\\n  print \""\\n# %s Column-aligned output:\"" % align\\n  print aligner(infile, align[0])"
"Python","Align_columns","Given a text file of many lines, where fields within a line\\nare delineated by a single 'dollar' character, write a program\\nthat aligns each column of fields by ensuring that words in each\\ncolumn are separated by at least one space.\\nFurther, allow for each word in a column to be either left\\njustified, right justified, or center justified within its column.\\nUse the following text to test your programs:\\nNote that:\\n\\n","txt = \""\""\""Given$a$txt$file$of$many$lines,$where$fields$within$a$line$\\nare$delineated$by$a$single$'dollar'$character,$write$a$program\\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\\ncolumn$are$separated$by$at$least$one$space.\\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\\njustified,$right$justified,$or$center$justified$within$its$column.\""\""\""\\n\\nparts = [line.rstrip(\""$\"").split(\""$\"") for line in txt.splitlines()]\\n\\nmax_widths = {}\\nfor line in parts:\\n    for i, word in enumerate(line):\\n        max_widths[i] = max(max_widths.get(i, 0), len(word))\\n\\nfor i, justify in enumerate([str.ljust, str.center, str.rjust]):\\n    print [\""Left\"", \""Center\"", \""Right\""][i], \"" column-aligned output:\\n\""\\n    for line in parts:\\n        for j, word in enumerate(line):\\n            print justify(word, max_widths[j]),\\n        print\\n    print \""- \"" * 52"
"Python","Align_columns","Given a text file of many lines, where fields within a line\\nare delineated by a single 'dollar' character, write a program\\nthat aligns each column of fields by ensuring that words in each\\ncolumn are separated by at least one space.\\nFurther, allow for each word in a column to be either left\\njustified, right justified, or center justified within its column.\\nUse the following text to test your programs:\\nNote that:\\n\\n","'''\\ncat <<'EOF' > align_columns.dat\\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\\nare$delineated$by$a$single$'dollar'$character,$write$a$program\\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\\ncolumn$are$separated$by$at$least$one$space.\\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\\njustified,$right$justified,$or$center$justified$within$its$column.\\nEOF\\n'''\\n\\nfor align in '<^>':\\n  rows = [ line.strip().split('$') for line in open('align_columns.dat') ]\\n  fmts = [ '{:%s%d}' % (align, max( len(row[i]) if i < len(row) else 0 for row in rows ))\\n           for i in range(max(map(len, rows))) ]\\n  for row in rows:\\n    print(' '.join(fmts).format(*(row + [''] * len(fmts))))\\n  print('')"
"Python","Aliquot_sequence_classifications","An aliquot sequence of a positive integer K is defined recursively as the first member\\nbeing K and subsequent members being the sum of the Proper divisors of the previous term.\\n\\nShow all output on this page.\\n\\n\\nAssumes LONG INT is at least 64 bits, as in Algol 68G.\\n","from proper_divisors import proper_divs\\nfrom functools import lru_cache\\n\\n\\n@lru_cache()\\ndef pdsum(n): \\n    return sum(proper_divs(n))\\n    \\n    \\ndef aliquot(n, maxlen=16, maxterm=2**47):\\n    if n == 0:\\n        return 'terminating', [0]\\n    s, slen, new = [n], 1, n\\n    while slen <= maxlen and new < maxterm:\\n        new = pdsum(s[-1])\\n        if new in s:\\n            if s[0] == new:\\n                if slen == 1:\\n                    return 'perfect', s\\n                elif slen == 2:\\n                    return 'amicable', s\\n                else:\\n                    return 'sociable of length %i' % slen, s\\n            elif s[-1] == new:\\n                return 'aspiring', s\\n            else:\\n                return 'cyclic back to %i' % new, s\\n        elif new == 0:\\n            return 'terminating', s + [0]\\n        else:\\n            s.append(new)\\n            slen += 1\\n    else:\\n        return 'non-terminating', s\\n                \\nif __name__ == '__main__':\\n    for n in range(1, 11): \\n        print('%s: %r' % aliquot(n))\\n    print()\\n    for n in [11, 12, 28, 496, 220, 1184,  12496, 1264460, 790, 909, 562, 1064, 1488, 15355717786080]: \\n        print('%s: %r' % aliquot(n))"
"Python","Almost_prime","A   k-Almost-prime   is a natural number   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n   that is the product of   \\n\\n\\n\\nk\\n\\n\\n{\\displaystyle k}\\n\\n   (possibly identical) primes.\\n\\n1-almost-primes,   where   \\n\\n\\n\\nk\\n=\\n1\\n\\n\\n{\\displaystyle k=1}\\n\\n,   are the prime numbers themselves.\\n2-almost-primes,   where   \\n\\n\\n\\nk\\n=\\n2\\n\\n\\n{\\displaystyle k=2}\\n\\n,   are the   semiprimes.\\n\\nWrite a function/method/subroutine/... that generates k-almost primes and use it to create a table here of the first ten members of k-Almost primes for   \\n\\n\\n\\n1\\n<=\\nK\\n<=\\n5\\n\\n\\n{\\displaystyle 1<=K<=5}\\n\\n.\\n\\n\\n","from prime_decomposition import decompose\\nfrom itertools import islice, count\\ntry: \\n    from functools import reduce\\nexcept: \\n    pass\\n\\n\\ndef almostprime(n, k=2):\\n    d = decompose(n)\\n    try:\\n        terms = [next(d) for i in range(k)]\\n        return reduce(int.__mul__, terms, 1) == n\\n    except:\\n        return False\\n\\nif __name__ == '__main__':\\n    for k in range(1,6):\\n        print('%i: %r' % (k, list(islice((n for n in count() if almostprime(n, k)), 10))))"
"Python","Almost_prime","A   k-Almost-prime   is a natural number   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n   that is the product of   \\n\\n\\n\\nk\\n\\n\\n{\\displaystyle k}\\n\\n   (possibly identical) primes.\\n\\n1-almost-primes,   where   \\n\\n\\n\\nk\\n=\\n1\\n\\n\\n{\\displaystyle k=1}\\n\\n,   are the prime numbers themselves.\\n2-almost-primes,   where   \\n\\n\\n\\nk\\n=\\n2\\n\\n\\n{\\displaystyle k=2}\\n\\n,   are the   semiprimes.\\n\\nWrite a function/method/subroutine/... that generates k-almost primes and use it to create a table here of the first ten members of k-Almost primes for   \\n\\n\\n\\n1\\n<=\\nK\\n<=\\n5\\n\\n\\n{\\displaystyle 1<=K<=5}\\n\\n.\\n\\n\\n","\\n# k-Almost-primes\\n# Python 3.6.3\\n# no imports\\n\\ndef prime_factors(m=2):\\n    \\n    for i in range(2, m):\\n        r, q = divmod(m, i)\\n        if not q:\\n            return [i] + prime_factors(r)\\n    return [m]\\n\\ndef k_almost_primes(n, k=2):\\n    multiples = set()\\n    lists = list()\\n    for x in range(k+1):\\n        lists.append([])\\n\\n    for i in range(2, n+1):\\n        if i not in multiples:\\n            if len(lists[1]) < 10:\\n                lists[1].append(i)\\n            multiples.update(range(i*i, n+1, i))\\n    print(\""k=1: {}\"".format(lists[1]))\\n\\n    for j in range(2, k+1):\\n        for m in multiples:\\n            l = prime_factors(m)\\n            ll = len(l)\\n            if ll == j and len(lists[j]) < 10:\\n                lists[j].append(m)\\n\\n        print(\""k={}: {}\"".format(j, lists[j]))\\n\\nk_almost_primes(200, 5)\\n# try:\\n#k_almost_primes(6000, 10)\\n"
"Python","Amb","Define and give an example of the Amb operator.\\nThe Amb operator expresses nondeterminism. This doesn't refer to randomness (as in \""nondeterministic universe\"") but is closely related to the term as it is used in automata theory (\""non-deterministic finite automaton\"").\\nThe Amb operator takes a variable number of expressions (or values if that's simpler in the language) and yields a correct one which will satisfy a constraint in some future computation, thereby avoiding failure.\\nProblems whose solution the Amb operator naturally expresses can be approached with other tools, such as explicit nested iterations over data sets, or with pattern matching. By contrast, the Amb operator appears integrated into the language. Invocations of Amb are not wrapped in any visible loops or other search patterns; they appear to be independent.\\nEssentially Amb(x, y, z) splits the computation into three possible futures: a future in which the value x is yielded, a future in which the value y is yielded and a future in which the value z is yielded. The future which leads to a successful subsequent computation is chosen. The other \""parallel universes\"" somehow go away. Amb called with no arguments fails.\\nFor simplicity, one of the domain values usable with Amb may denote failure, if that is convenient. For instance, it is convenient if a Boolean false denotes failure, so that Amb(false) fails, and thus constraints can be expressed using Boolean expressions like Amb(x * y == 8) which unless x and y add to four.\\nA pseudo-code program which satisfies this constraint might look like:\\nThe output is 2 4 because Amb(1, 2, 3) correctly chooses the future in which x has value 2, Amb(7, 6, 4, 5) chooses 4 and consequently Amb(x * y = 8) produces a success.\\nAlternatively, failure could be represented using strictly Amb():\\nOr else Amb could take the form of two operators or functions: one for producing values and one for enforcing constraints:\\nwhere Ambassert behaves like Amb() if the Boolean expression is false, otherwise it allows the future computation to take place, without yielding any value.\\nThe task is to somehow implement Amb, and demonstrate it with a program which chooses one word from each of the following four sets of character strings to generate a four-word sentence:\\nThe constraint to be satisfied is that the last character of each word (other than the last) is the same as the first character of its successor.\\nThe only successful sentence is \""that thing grows slowly\""; other combinations do not satisfy the constraint and thus fail.\\nThe goal of this task isn't to simply process the four lists of words with explicit, deterministic program flow such as nested iteration, to trivially demonstrate the correct output. The goal is to implement the Amb operator, or a facsimile thereof that is possible within the language limitations.\\n","import itertools as _itertools\\n \\nclass Amb(object):\\n    def __init__(self):\\n        self._names2values   = {}       # set of values for each global name\\n        self._func           = None     # Boolean constraint function\\n        self._valueiterator  = None     # itertools.product of names values\\n        self._funcargnames   = None     # Constraint parameter names\\n \\n    def __call__(self, arg=None):\\n        if hasattr(arg, '__code__'):                \\n            ##\\n            ## Called with a constraint function. \\n            ##\\n            globls = arg.__globals__ if hasattr(arg, '__globals__') else arg.func_globals\\n            # Names used in constraint\\n            argv = arg.__code__.co_varnames[:arg.__code__.co_argcount]\\n            for name in argv:\\n                if name not in self._names2values:\\n                    assert name in globls, \\\\n                           \""Global name %s not found in function globals\"" % name\\n                    self._names2values[name] = globls[name]\\n            # Gather the range of values of all names used in the constraint\\n            valuesets = [self._names2values[name] for name in argv]\\n            self._valueiterator = _itertools.product(*valuesets)\\n            self._func = arg\\n            self._funcargnames = argv\\n            return self\\n        elif arg is not None:\\n            ##\\n            ## Assume called with an iterable set of values\\n            ##\\n            arg = frozenset(arg)\\n            return arg\\n        else:\\n            ##\\n            ## blank call tries to return next solution\\n            ##\\n            return self._nextinsearch()\\n \\n    def _nextinsearch(self):\\n        arg = self._func\\n        globls = arg.__globals__\\n        argv = self._funcargnames\\n        found = False\\n        for values in self._valueiterator:\\n            if arg(*values):\\n                # Set globals.\\n                found = True\\n                for n, v in zip(argv, values):\\n                    globls[n] = v\\n                break\\n        if not found: raise StopIteration\\n        return values\\n \\n    def __iter__(self):\\n        return self\\n \\n    def __next__(self):\\n        return self()\\n    next = __next__ # Python 2\\n \\nif __name__ == '__main__':\\n    if True:\\n        amb = Amb()\\n \\n        print(\""\\nSmall Pythagorean triples problem:\"")\\n        x = amb(range(1,11))\\n        y = amb(range(1,11))\\n        z = amb(range(1,11))\\n \\n        for _dummy in amb( lambda x, y, z: x*x + y*y == z*z ):\\n            print ('%s %s %s' % (x, y, z))\\n \\n \\n    if True:\\n        amb = Amb()\\n \\n        print(\""\\nRosetta Code Amb problem:\"")\\n        w1 = amb([\""the\"", \""that\"", \""a\""])\\n        w2 = amb([\""frog\"", \""elephant\"", \""thing\""])\\n        w3 = amb([\""walked\"", \""treaded\"", \""grows\""])\\n        w4 = amb([\""slowly\"", \""quickly\""])\\n \\n        for _dummy in amb( lambda w1, w2, w3, w4: \\\\n                             w1[-1] == w2[0] and \\\\n                             w2[-1] == w3[0] and \\\\n                             w3[-1] == w4[0] ):\\n            print ('%s %s %s %s' % (w1, w2, w3, w4))\\n \\n    if True:\\n        amb = Amb()\\n \\n        print(\""\\nAmb problem from \""\\n            \""http://www.randomhacks.net/articles/2005/10/11/amb-operator:\"")\\n        x = amb([1, 2, 3])\\n        y = amb([4, 5, 6])\\n \\n        for _dummy in amb( lambda x, y: x * y != 8 ):\\n            print ('%s %s' % (x, y))"
"Python","Amicable_pairs","Two integers \\n\\n\\n\\nN\\n\\n\\n{\\displaystyle N}\\n\\n and \\n\\n\\n\\nM\\n\\n\\n{\\displaystyle M}\\n\\n are said to be amicable pairs if \\n\\n\\n\\nN\\n≠\\nM\\n\\n\\n{\\displaystyle N\\neq M}\\n\\n and the sum of the proper divisors of \\n\\n\\n\\nN\\n\\n\\n{\\displaystyle N}\\n\\n (\\n\\n\\n\\n\\ns\\nu\\nm\\n\\n(\\n\\np\\nr\\no\\np\\nD\\ni\\nv\\ns\\n\\n(\\nN\\n)\\n)\\n\\n\\n{\\displaystyle \\mathrm {sum} (\\mathrm {propDivs} (N))}\\n\\n) \\n\\n\\n\\n=\\nM\\n\\n\\n{\\displaystyle =M}\\n\\n as well as \\n\\n\\n\\n\\ns\\nu\\nm\\n\\n(\\n\\np\\nr\\no\\np\\nD\\ni\\nv\\ns\\n\\n(\\nM\\n)\\n)\\n=\\nN\\n\\n\\n{\\displaystyle \\mathrm {sum} (\\mathrm {propDivs} (M))=N}\\n\\n.\\n\\n1184 and 1210 are an amicable pair, with proper divisors:\\n\\nCalculate and show here the Amicable pairs below 20,000; (there are eight).\\n\\n\\n","from proper_divisors import proper_divs\\n\\ndef amicable(rangemax=20000):\\n    n2divsum = {n: sum(proper_divs(n)) for n in range(1, rangemax + 1)}\\n    for num, divsum in n2divsum.items():\\n        if num < divsum and divsum <= rangemax and n2divsum[divsum] == num:\\n            yield num, divsum\\n\\nif __name__ == '__main__':\\n    for num, divsum in amicable():\\n        print('Amicable pair: %i and %i With proper divisors:\\n    %r\\n    %r'\\n              % (num, divsum, sorted(proper_divs(num)), sorted(proper_divs(divsum))))"
"Python","Anagrams","When two or more words are composed of the same characters, but in a different order, they are called anagrams.\\nUsing the word list at   http://www.puzzlers.org/pub/wordlists/unixdict.txt,\\nfind the sets of words that share the same characters that contain the most words in them.\\nOrdered words\\nPalindrome detection\\nSemordnilap\\nAnagrams\\nAnagrams/Deranged anagrams\\n",">>> import urllib.request\\n>>> from collections import defaultdict\\n>>> words = urllib.request.urlopen('http://www.puzzlers.org/pub/wordlists/unixdict.txt').read().split()\\n>>> anagram = defaultdict(list) # map sorted chars to anagrams\\n>>> for word in words:\\n	anagram[tuple(sorted(word))].append( word )\\n\\n	\\n>>> count = max(len(ana) for ana in anagram.values())\\n>>> for ana in anagram.values():\\n	if len(ana) >= count:\\n		print ([x.decode() for x in ana])"
"Python","Anagrams","When two or more words are composed of the same characters, but in a different order, they are called anagrams.\\nUsing the word list at   http://www.puzzlers.org/pub/wordlists/unixdict.txt,\\nfind the sets of words that share the same characters that contain the most words in them.\\nOrdered words\\nPalindrome detection\\nSemordnilap\\nAnagrams\\nAnagrams/Deranged anagrams\\n",">>> import urllib\\n>>> from collections import defaultdict\\n>>> words = urllib.urlopen('http://www.puzzlers.org/pub/wordlists/unixdict.txt').read().split()\\n>>> len(words)\\n25104\\n>>> anagram = defaultdict(list) # map sorted chars to anagrams\\n>>> for word in words:\\n	anagram[tuple(sorted(word))].append( word )\\n\\n	\\n>>> count = max(len(ana) for ana in anagram.itervalues())\\n>>> for ana in anagram.itervalues():\\n	if len(ana) >= count:\\n		print ana\\n\\n		\\n['angel', 'angle', 'galen', 'glean', 'lange']\\n['alger', 'glare', 'lager', 'large', 'regal']\\n['caret', 'carte', 'cater', 'crate', 'trace']\\n['evil', 'levi', 'live', 'veil', 'vile']\\n['elan', 'lane', 'lean', 'lena', 'neal']\\n['abel', 'able', 'bale', 'bela', 'elba']\\n>>> count\\n5\\n>>>"
"Python","Anagrams","When two or more words are composed of the same characters, but in a different order, they are called anagrams.\\nUsing the word list at   http://www.puzzlers.org/pub/wordlists/unixdict.txt,\\nfind the sets of words that share the same characters that contain the most words in them.\\nOrdered words\\nPalindrome detection\\nSemordnilap\\nAnagrams\\nAnagrams/Deranged anagrams\\n",">>> import urllib, itertools\\n>>> words = urllib.urlopen('http://www.puzzlers.org/pub/wordlists/unixdict.txt').read().split()\\n>>> len(words)\\n25104\\n>>> anagrams = [list(g) for k,g in itertools.groupby(sorted(words, key=sorted), key=sorted)]\\n\\n\\n>>> count = max(len(ana) for ana in anagrams)\\n>>> for ana in anagrams:\\n	if len(ana) >= count:\\n		print ana\\n\\n		\\n['abel', 'able', 'bale', 'bela', 'elba']\\n['caret', 'carte', 'cater', 'crate', 'trace']\\n['angel', 'angle', 'galen', 'glean', 'lange']\\n['alger', 'glare', 'lager', 'large', 'regal']\\n['elan', 'lane', 'lean', 'lena', 'neal']\\n['evil', 'levi', 'live', 'veil', 'vile']\\n>>> count\\n5\\n>>>"
"Python","Anagrams/Deranged_anagrams","Two or more words are said to be anagrams if they have the same characters, but in a different order.\\nBy analogy with derangements we define a deranged anagram as two words with the same characters, but in which the same character does not appear in the same position in both words.\\nUse the word list at unixdict to find and display the longest deranged anagram.\\nOrdered words\\nPalindrome detection\\nSemordnilap\\nAnagrams\\nAnagrams/Deranged anagrams\\n","import urllib.request\\nfrom collections import defaultdict\\nfrom itertools import combinations\\n\\ndef getwords(url='http://www.puzzlers.org/pub/wordlists/unixdict.txt'):\\n    return list(set(urllib.request.urlopen(url).read().decode().split()))\\n\\ndef find_anagrams(words):\\n    anagram = defaultdict(list) # map sorted chars to anagrams\\n    for word in words:\\n        anagram[tuple(sorted(word))].append( word )\\n    return dict((key, words) for key, words in anagram.items()\\n                if len(words) > 1)\\n\\ndef is_deranged(words):\\n    'returns pairs of words that have no character in the same position'\\n    return [ (word1, word2)\\n             for word1,word2 in combinations(words, 2)\\n             if all(ch1 != ch2 for ch1, ch2 in zip(word1, word2)) ]\\n\\ndef largest_deranged_ana(anagrams):\\n    ordered_anagrams = sorted(anagrams.items(),\\n                              key=lambda x:(-len(x[0]), x[0]))\\n    for _, words in ordered_anagrams:\\n        deranged_pairs = is_deranged(words)\\n        if deranged_pairs:\\n            return deranged_pairs\\n    return []\\n\\nif __name__ == '__main__':\\n    words = getwords('http://www.puzzlers.org/pub/wordlists/unixdict.txt')\\n    print(\""Word count:\"", len(words))\\n\\n    anagrams = find_anagrams(words)\\n    print(\""Anagram count:\"", len(anagrams),\""\\n\"")\\n\\n    print(\""Longest anagrams with no characters in the same position:\"")\\n    print('  ' + '\\n  '.join(', '.join(pairs)\\n                             for pairs in largest_deranged_ana(anagrams)))"
"Python","Anagrams/Deranged_anagrams","Two or more words are said to be anagrams if they have the same characters, but in a different order.\\nBy analogy with derangements we define a deranged anagram as two words with the same characters, but in which the same character does not appear in the same position in both words.\\nUse the word list at unixdict to find and display the longest deranged anagram.\\nOrdered words\\nPalindrome detection\\nSemordnilap\\nAnagrams\\nAnagrams/Deranged anagrams\\n","from itertools import izip, ifilter\\nfrom collections import defaultdict\\n\\ndef find_deranged(words):\\n    return [(w1, w2) for i, w1 in enumerate(words)\\n                     for w2 in words[i + 1:]\\n                     if all(a != b for a,b in izip(w1, w2))]\\n\\ndef main():\\n    wclasses = [[] for _ in xrange(30)]\\n    for word in open(\""unixdict.txt\"").read().split():\\n        wclasses[-len(word)].append(word)\\n\\n    print \""Longest deranged anagrams:\""\\n    for words in ifilter(None, wclasses):\\n        anags = defaultdict(list)\\n        for w in words:\\n            anags[\""\"".join(sorted(w))].append(w)\\n        anas = (find_deranged(a) for a in anags.itervalues() if len(a)>1)\\n        pairs = filter(None, anas)\\n        if pairs:\\n            print \""  %s, %s\"" % (pairs[0][0])\\n            break\\n\\nmain()"
"Python","Angle_difference_between_two_bearings","Finding the angle between two bearings is often confusing.[1]\\n\\nFind the angle which is the result of the subtraction b2 - b1, where b1 and b2 are the bearings.\\nInput bearings are expressed in the range   -180   to   +180   degrees.\\nThe result is also expressed in the range   -180   to   +180   degrees.\\n\\nCompute the angle for the following pairs:\\n\\nAllow the input bearings to be any (finite) value.\\n\\n\\n","from __future__ import print_function\\n \\ndef getDifference(b1, b2):\\n	r = (b2 - b1) % 360.0\\n	# Python modulus has same sign as divisor, which is positive here,\\n	# so no need to consider negative case\\n	if r >= 180.0:\\n		r -= 360.0\\n	return r\\n \\nif __name__ == \""__main__\"":\\n	print (\""Input in -180 to +180 range\"")\\n	print (getDifference(20.0, 45.0))\\n	print (getDifference(-45.0, 45.0))\\n	print (getDifference(-85.0, 90.0))\\n	print (getDifference(-95.0, 90.0))\\n	print (getDifference(-45.0, 125.0))\\n	print (getDifference(-45.0, 145.0))\\n	print (getDifference(-45.0, 125.0))\\n	print (getDifference(-45.0, 145.0))\\n	print (getDifference(29.4803, -88.6381))\\n	print (getDifference(-78.3251, -159.036))\\n \\n	print (\""Input in wider range\"")\\n	print (getDifference(-70099.74233810938, 29840.67437876723))\\n	print (getDifference(-165313.6666297357, 33693.9894517456))\\n	print (getDifference(1174.8380510598456, -154146.66490124757))\\n	print (getDifference(60175.77306795546, 42213.07192354373))"
"Python","Angle_difference_between_two_bearings","Finding the angle between two bearings is often confusing.[1]\\n\\nFind the angle which is the result of the subtraction b2 - b1, where b1 and b2 are the bearings.\\nInput bearings are expressed in the range   -180   to   +180   degrees.\\nThe result is also expressed in the range   -180   to   +180   degrees.\\n\\nCompute the angle for the following pairs:\\n\\nAllow the input bearings to be any (finite) value.\\n\\n\\n","from math import (acos, cos, pi, sin)\\n\\n\\n# bearingDelta :: Radians -> Radians -> Radians\\ndef bearingDelta(ar):\\n    def go(br):\\n        [(ax, ay), (bx, by)] = map(\\n            lambda x: (sin(x), cos(x)),\\n            [ar, br]\\n        )\\n        # cross-product > 0 ?\\n        sign = +1 if 0 < ((ay * bx) - (by * ax)) else -1\\n        # sign * dot-product\\n        return sign * acos((ax * bx) + (ay * by))\\n    return lambda br: go(br)\\n\\n\\n# showMap :: Degrees -> Degrees -> String\\ndef showMap(da, db):\\n    return unwords(\\n        map(lambda x: justifyRight(x[0])(' ')(str(x[1])), [\\n            (22, str(da) + ' +'),\\n            (23, str(db) + '  -> '),\\n            (6, round(\\n                degrees(\\n                    bearingDelta\\n                    (radians(da))\\n                    (radians(db))\\n                ), 2)\\n             )\\n        ])\\n    )\\n\\n\\n# main :: IO ()\\ndef main():\\n    print (\\n        unlines(map(lambda ab: showMap(*ab), [\\n            (20, 45),\\n            (-45, 45),\\n            (-85, 90),\\n            (-95, 90),\\n            (-45, 125),\\n            (-45, 145),\\n            (-70099.74233810938, 29840.67437876723),\\n            (-165313.6666297357, 33693.9894517456),\\n            (1174.8380510598456, -154146.66490124757),\\n            (60175.77306795546, 42213.07192354373)\\n        ])))\\n\\n\\n# GENERIC ----------------------------------------------\\n\\n# radians :: Float x => Degrees x -> Radians x\\ndef radians(x):\\n    return (pi * x / 180)\\n\\n\\n# degrees :: Float x => Radians x -> Degrees x\\ndef degrees(x):\\n    return (180 * x / pi)\\n\\n\\n# justifyRight :: Int -> Char -> String -> String\\ndef justifyRight(n):\\n    return lambda cFiller: lambda s: (\\n        ((n * cFiller) + s)[-n:]\\n    )\\n\\n\\n# unlines :: [String] -> String\\ndef unlines(xs):\\n    return '\\n'.join(xs)\\n\\n\\n# unwords :: [String] -> String\\ndef unwords(xs):\\n    return ' '.join(xs)\\n\\n\\nmain()"
"Python","Animate_a_pendulum","One good way of making an animation is by simulating a physical system and illustrating the variables in that system using a dynamically changing graphical display.\\nThe classic such physical system is a simple gravity pendulum.\\nFor this task, create a simple physical model of a pendulum and animate it.\\nThis does not use a GUI, it simply animates the pendulum and prints out the positions. If you want, you can replace the output method with graphical update methods.\\nX and Y are relative positions of the pendulum to the anchor.\\npendulums.ads:\\npendulums.adb:\\nexample main.adb:\\n","import pygame, sys\\nfrom pygame.locals import *\\nfrom math import sin, cos, radians\\n\\npygame.init()\\n\\nWINDOWSIZE = 250\\nTIMETICK = 100\\nBOBSIZE = 15\\n\\nwindow = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))\\npygame.display.set_caption(\""Pendulum\"")\\n\\nscreen = pygame.display.get_surface()\\nscreen.fill((255,255,255))\\n\\nPIVOT = (WINDOWSIZE/2, WINDOWSIZE/10)\\nSWINGLENGTH = PIVOT[1]*4\\n\\nclass BobMass(pygame.sprite.Sprite):\\n    def __init__(self):\\n        pygame.sprite.Sprite.__init__(self)\\n        self.theta = 45\\n        self.dtheta = 0\\n        self.rect = pygame.Rect(PIVOT[0]-SWINGLENGTH*cos(radians(self.theta)),\\n                                PIVOT[1]+SWINGLENGTH*sin(radians(self.theta)),\\n                                1,1)\\n        self.draw()\\n\\n    def recomputeAngle(self):\\n        scaling = 3000.0/(SWINGLENGTH**2)\\n\\n        firstDDtheta = -sin(radians(self.theta))*scaling\\n        midDtheta = self.dtheta + firstDDtheta\\n        midtheta = self.theta + (self.dtheta + midDtheta)/2.0\\n\\n        midDDtheta = -sin(radians(midtheta))*scaling\\n        midDtheta = self.dtheta + (firstDDtheta + midDDtheta)/2\\n        midtheta = self.theta + (self.dtheta + midDtheta)/2\\n\\n        midDDtheta = -sin(radians(midtheta)) * scaling\\n        lastDtheta = midDtheta + midDDtheta\\n        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0\\n        \\n        lastDDtheta = -sin(radians(lasttheta)) * scaling\\n        lastDtheta = midDtheta + (midDDtheta + lastDDtheta)/2.0\\n        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0\\n\\n        self.dtheta = lastDtheta\\n        self.theta = lasttheta\\n        self.rect = pygame.Rect(PIVOT[0]-\\n                                SWINGLENGTH*sin(radians(self.theta)), \\n                                PIVOT[1]+\\n                                SWINGLENGTH*cos(radians(self.theta)),1,1)\\n\\n\\n    def draw(self):\\n        pygame.draw.circle(screen, (0,0,0), PIVOT, 5, 0)\\n        pygame.draw.circle(screen, (0,0,0), self.rect.center, BOBSIZE, 0)\\n        pygame.draw.aaline(screen, (0,0,0), PIVOT, self.rect.center)\\n        pygame.draw.line(screen, (0,0,0), (0, PIVOT[1]), (WINDOWSIZE, PIVOT[1]))\\n\\n    def update(self):\\n        self.recomputeAngle()\\n        screen.fill((255,255,255))\\n        self.draw()\\n\\nbob = BobMass()\\n\\nTICK = USEREVENT + 2\\npygame.time.set_timer(TICK, TIMETICK)\\n\\ndef input(events):\\n    for event in events:\\n        if event.type == QUIT:\\n            sys.exit(0)\\n        elif event.type == TICK:\\n            bob.update()\\n\\nwhile True:\\n    input(pygame.event.get())\\n    pygame.display.flip()"
"Python","Animation","\\nAnimation is integral to many parts of GUIs, including both the fancy effects when things change used in window managers, and of course games.   The core of any animation system is a scheme for periodically changing the display while still remaining responsive to the user.   This task demonstrates this.\\n\\nCreate a window containing the string \""Hello World! \"" (the trailing space is significant).\\nMake the text appear to be rotating right by periodically removing one letter from the end of the string and attaching it to the front.\\nWhen the user clicks on the (windowed) text, it should reverse its direction.\\n\\nanimation.adb:\\n(NB: implicitly, through GTK, it uses also Pango library)\\nmodule.ceylon\\nrun.ceylon\\nClojure is a JVM language so this example uses Swing, and illustrates Clojure's platform integration.\\nThe ltk package provides a lisp interface to Tk for creating graphical interfaces. Assuming ltk has been installed somewhere the following will work as per the Tcl example.\\nText-only version (no Java dependency; no clicking, use reverse() and stop() to control):\\n\\nAny mouse button on the text will change the direction.\\nTo exit, push the window's closing cross. (255 + 107 is the combination that is passed to INKEY$ by that button.)\\nClick here for image of running code\\nRun within interpreter GHCi:\\nThe following code uses features exclusive to Unicon.\\nThe following code uses features exclusive to Icon.\\nThis image is a VI Snippet, an executable image of LabVIEW code. The LabVIEW version is shown on the top-right hand corner. You can download it, then drag-and-drop it onto the LabVIEW block diagram from a file browser, and it will appear as runnable, editable code.\\n\\nAny Button can use a blink, a timer which return a changed value, true or false, but here we didn't use it (so we didn't Read from event's stack of values. We can place Stack statement to view this stack in console).\\nWe can use console as window too. Although we don't have events for this window, we can read mouse button. Also we use split screen so first line (line 0) has the title, and all other lines are cleared before we print on it, every 200ms\\nWe use form layer as console (we can't use input statements for those layers). We setup a thread to change form layer, at an interval of 200ms.\\nWhen a thread created saves the current layer, to use it in each iteration.\\nFirst, create a textbox, and by right-clicking it, and selecting component properties, change its name to \""Text\"". Then, create 2 buttons, changing the caption on one to \""Reverse\"", and the other to \""Forward\"". In the edit click action of each respective button, you will put:\\nand:\\nThen in the startup actions, accessed by clicking the 2 gears, add this:\\nCreates a window with a rotating label and 2 buttons to change the direction.\\nExample can be compiled by FreePascal/Lazarus.\\nDid all in one file, normally you have the project-file, the form-unit- and the form-resource-file.\\nA plain text version. The following script works in an XTerm window.\\nThe standard PicoLisp GUI is HTTP based. Connect your browser to\\nhttp://localhost:8080 after starting the following script.\\nThe scrolling text is displayed in a button. Clicking on the button\\nreverses the scroll direction.\\nThis solution works on ErsatzLisp, the Java version of PicoLisp.\\nSWI-Prolog has a grapghic interface XPCE.\\nBefore, load the QB.EXE with /L QB.QLB key, or QBX.EXE with /L QBX.QLB key, or just /L key any of them. That's the easiest way to get the mouse in DOS.\\nPressing to change direction should be on the text. To exit push the right button anywhere.\\nThe basic principle is:create a window with a label in it, then add a handler to the label for rotating the string, and another for changing direction on a click. Use of the tag function allows you to store the text flow direction as an attribute of the label.\\nThis REXX version only works with REXX/Personal or REXX/PC.\\nOutput:\\nScratch is event and animation oriented, so this is a natural task for this language. This solution is hosted at the scratch website, where one can see it in action and read its code.\\nSolution Summary and Comments\\nThe solution consists of two blocks of code. The main block initializes variables upon invocation and sets up a loop to display the crawling \""Hello World! \"" message. The crawl is accomplished by manipulation of the list containing the message as individual characters. The other block of code is attached to the scratch sprite, and all it does is change the direction of the text crawl when the sprite is clicked.\\nI tried a couple of techniques for introducing a delay into the text crawl loop. The command \""Say message for 2 seconds\"" resulted in poor performance; the application's response to clicks was spotty. Using the timer and waiting for it to exceed 2 seconds before resetting it and advancing the crawl worked much better. (I also tried waiting for the timer to equal 2 seconds, and unsurprisingly this resulted in an application freeze-up.)\\n\\nThis program can be concatenated onto a single line using ! as the concatenator:\\nMr. Kibernetik, the creator of smart Basic, offered this ultra-compact one-line version:\\nand smart Basic Forum member sarossell found a way to shorten even that! See if you can spot what is changed.\\nThis animation is defined as a smooth movement rather than by moving whole characters, because that is more natural in SVG (without scripting); by characters would require 13 different text elements displayed in sequence.\\n(Does not work in Safari 4.0.2 because it apparently does not implement toggled animations correctly (see spec). Dreadful workaround: set the two animations to id=\""a\"" begin=\""0s;all.click\"" end=\""all.mousedown\"" and begin=\""a.end\"" end=\""all.click\"", respectively.)\\nThe requirements contain \""When the user clicks on the text…\"". The TI-89 does not have a graphical cursor, so just for the sake of overdoing it, and to have a little more complex animation (overlapping objects), this program implements one. Use the arrow keys and ENTER to control the cursor.\\nIt is not possible to detect mouse clicks while a macro is running. Therefore, the direction is controlled with Caps Lock key.\\nThis example shows code that is hidden by the IDE. (Form creation is done graphically within the IDE, not at runtime.)\\nReplaces the detection of mouse click by pressing a key (Spectrum does not detect this device by default).\\n","#!/usr/bin/env python3\\nimport sys\\n\\nfrom PyQt5.QtCore import QBasicTimer, Qt\\nfrom PyQt5.QtGui import QFont\\nfrom PyQt5.QtWidgets import QApplication, QLabel\\n\\n\\nclass Marquee(QLabel):\\n    def __init__(self, **kwargs):\\n        super().__init__(**kwargs)\\n        self.right_to_left_direction = True\\n        self.initUI()\\n        self.timer = QBasicTimer()\\n        self.timer.start(80, self)\\n\\n    def initUI(self):\\n        self.setWindowFlags(Qt.FramelessWindowHint)\\n        self.setAttribute(Qt.WA_TranslucentBackground)\\n        self.setText(\""Hello World! \"")\\n        self.setFont(QFont(None, 50, QFont.Bold))\\n        # make more irritating for the authenticity with <marquee> element\\n        self.setStyleSheet(\""QLabel {color: cyan; }\"")\\n\\n    def timerEvent(self, event):\\n        i = 1 if self.right_to_left_direction else -1\\n        self.setText(self.text()[i:] + self.text()[:i])  # rotate\\n\\n    def mouseReleaseEvent(self, event):  # change direction on mouse release\\n        self.right_to_left_direction = not self.right_to_left_direction\\n\\n    def keyPressEvent(self, event):  # exit on Esc\\n        if event.key() == Qt.Key_Escape:\\n            self.close()\\n\\n\\napp = QApplication(sys.argv)\\nw = Marquee()\\n# center widget on the screen\\nw.adjustSize()  # update w.rect() now\\nw.move(QApplication.instance().desktop().screen().rect().center()\\n       - w.rect().center())\\nw.show()\\nsys.exit(app.exec())"
"Python","Animation","\\nAnimation is integral to many parts of GUIs, including both the fancy effects when things change used in window managers, and of course games.   The core of any animation system is a scheme for periodically changing the display while still remaining responsive to the user.   This task demonstrates this.\\n\\nCreate a window containing the string \""Hello World! \"" (the trailing space is significant).\\nMake the text appear to be rotating right by periodically removing one letter from the end of the string and attaching it to the front.\\nWhen the user clicks on the (windowed) text, it should reverse its direction.\\n\\nanimation.adb:\\n(NB: implicitly, through GTK, it uses also Pango library)\\nmodule.ceylon\\nrun.ceylon\\nClojure is a JVM language so this example uses Swing, and illustrates Clojure's platform integration.\\nThe ltk package provides a lisp interface to Tk for creating graphical interfaces. Assuming ltk has been installed somewhere the following will work as per the Tcl example.\\nText-only version (no Java dependency; no clicking, use reverse() and stop() to control):\\n\\nAny mouse button on the text will change the direction.\\nTo exit, push the window's closing cross. (255 + 107 is the combination that is passed to INKEY$ by that button.)\\nClick here for image of running code\\nRun within interpreter GHCi:\\nThe following code uses features exclusive to Unicon.\\nThe following code uses features exclusive to Icon.\\nThis image is a VI Snippet, an executable image of LabVIEW code. The LabVIEW version is shown on the top-right hand corner. You can download it, then drag-and-drop it onto the LabVIEW block diagram from a file browser, and it will appear as runnable, editable code.\\n\\nAny Button can use a blink, a timer which return a changed value, true or false, but here we didn't use it (so we didn't Read from event's stack of values. We can place Stack statement to view this stack in console).\\nWe can use console as window too. Although we don't have events for this window, we can read mouse button. Also we use split screen so first line (line 0) has the title, and all other lines are cleared before we print on it, every 200ms\\nWe use form layer as console (we can't use input statements for those layers). We setup a thread to change form layer, at an interval of 200ms.\\nWhen a thread created saves the current layer, to use it in each iteration.\\nFirst, create a textbox, and by right-clicking it, and selecting component properties, change its name to \""Text\"". Then, create 2 buttons, changing the caption on one to \""Reverse\"", and the other to \""Forward\"". In the edit click action of each respective button, you will put:\\nand:\\nThen in the startup actions, accessed by clicking the 2 gears, add this:\\nCreates a window with a rotating label and 2 buttons to change the direction.\\nExample can be compiled by FreePascal/Lazarus.\\nDid all in one file, normally you have the project-file, the form-unit- and the form-resource-file.\\nA plain text version. The following script works in an XTerm window.\\nThe standard PicoLisp GUI is HTTP based. Connect your browser to\\nhttp://localhost:8080 after starting the following script.\\nThe scrolling text is displayed in a button. Clicking on the button\\nreverses the scroll direction.\\nThis solution works on ErsatzLisp, the Java version of PicoLisp.\\nSWI-Prolog has a grapghic interface XPCE.\\nBefore, load the QB.EXE with /L QB.QLB key, or QBX.EXE with /L QBX.QLB key, or just /L key any of them. That's the easiest way to get the mouse in DOS.\\nPressing to change direction should be on the text. To exit push the right button anywhere.\\nThe basic principle is:create a window with a label in it, then add a handler to the label for rotating the string, and another for changing direction on a click. Use of the tag function allows you to store the text flow direction as an attribute of the label.\\nThis REXX version only works with REXX/Personal or REXX/PC.\\nOutput:\\nScratch is event and animation oriented, so this is a natural task for this language. This solution is hosted at the scratch website, where one can see it in action and read its code.\\nSolution Summary and Comments\\nThe solution consists of two blocks of code. The main block initializes variables upon invocation and sets up a loop to display the crawling \""Hello World! \"" message. The crawl is accomplished by manipulation of the list containing the message as individual characters. The other block of code is attached to the scratch sprite, and all it does is change the direction of the text crawl when the sprite is clicked.\\nI tried a couple of techniques for introducing a delay into the text crawl loop. The command \""Say message for 2 seconds\"" resulted in poor performance; the application's response to clicks was spotty. Using the timer and waiting for it to exceed 2 seconds before resetting it and advancing the crawl worked much better. (I also tried waiting for the timer to equal 2 seconds, and unsurprisingly this resulted in an application freeze-up.)\\n\\nThis program can be concatenated onto a single line using ! as the concatenator:\\nMr. Kibernetik, the creator of smart Basic, offered this ultra-compact one-line version:\\nand smart Basic Forum member sarossell found a way to shorten even that! See if you can spot what is changed.\\nThis animation is defined as a smooth movement rather than by moving whole characters, because that is more natural in SVG (without scripting); by characters would require 13 different text elements displayed in sequence.\\n(Does not work in Safari 4.0.2 because it apparently does not implement toggled animations correctly (see spec). Dreadful workaround: set the two animations to id=\""a\"" begin=\""0s;all.click\"" end=\""all.mousedown\"" and begin=\""a.end\"" end=\""all.click\"", respectively.)\\nThe requirements contain \""When the user clicks on the text…\"". The TI-89 does not have a graphical cursor, so just for the sake of overdoing it, and to have a little more complex animation (overlapping objects), this program implements one. Use the arrow keys and ENTER to control the cursor.\\nIt is not possible to detect mouse clicks while a macro is running. Therefore, the direction is controlled with Caps Lock key.\\nThis example shows code that is hidden by the IDE. (Form creation is done graphically within the IDE, not at runtime.)\\nReplaces the detection of mouse click by pressing a key (Spectrum does not detect this device by default).\\n","import pygame, sys\\nfrom pygame.locals import *\\npygame.init()\\n\\nYSIZE = 40\\nXSIZE = 150\\n\\nTEXT = \""Hello World! \""\\nFONTSIZE = 32\\n\\nLEFT = False\\nRIGHT = True\\n\\nDIR = RIGHT\\n\\nTIMETICK = 180\\nTICK = USEREVENT + 2\\n\\nTEXTBOX = pygame.Rect(10,10,XSIZE,YSIZE)\\n\\npygame.time.set_timer(TICK, TIMETICK)\\n\\nwindow = pygame.display.set_mode((XSIZE, YSIZE))\\npygame.display.set_caption(\""Animation\"")\\n\\nfont = pygame.font.SysFont(None, FONTSIZE)\\nscreen = pygame.display.get_surface()\\n\\ndef rotate():\\n    index = DIR and -1 or 1\\n    global TEXT\\n    TEXT = TEXT[index:]+TEXT[:index]\\n\\ndef click(position):\\n    if TEXTBOX.collidepoint(position):\\n        global DIR\\n        DIR = not DIR\\n\\ndef draw():\\n    surface = font.render(TEXT, True, (255,255,255), (0,0,0))\\n    global TEXTBOX\\n    TEXTBOX = screen.blit(surface, TEXTBOX)\\n    \\ndef input(event):\\n    if event.type == QUIT:\\n        sys.exit(0)\\n    elif event.type == MOUSEBUTTONDOWN:\\n        click(event.pos)\\n    elif event.type == TICK:\\n        draw()\\n        rotate()\\n\\nwhile True:\\n    input(pygame.event.wait())\\n    pygame.display.flip()"
"Python","Animation","\\nAnimation is integral to many parts of GUIs, including both the fancy effects when things change used in window managers, and of course games.   The core of any animation system is a scheme for periodically changing the display while still remaining responsive to the user.   This task demonstrates this.\\n\\nCreate a window containing the string \""Hello World! \"" (the trailing space is significant).\\nMake the text appear to be rotating right by periodically removing one letter from the end of the string and attaching it to the front.\\nWhen the user clicks on the (windowed) text, it should reverse its direction.\\n\\nanimation.adb:\\n(NB: implicitly, through GTK, it uses also Pango library)\\nmodule.ceylon\\nrun.ceylon\\nClojure is a JVM language so this example uses Swing, and illustrates Clojure's platform integration.\\nThe ltk package provides a lisp interface to Tk for creating graphical interfaces. Assuming ltk has been installed somewhere the following will work as per the Tcl example.\\nText-only version (no Java dependency; no clicking, use reverse() and stop() to control):\\n\\nAny mouse button on the text will change the direction.\\nTo exit, push the window's closing cross. (255 + 107 is the combination that is passed to INKEY$ by that button.)\\nClick here for image of running code\\nRun within interpreter GHCi:\\nThe following code uses features exclusive to Unicon.\\nThe following code uses features exclusive to Icon.\\nThis image is a VI Snippet, an executable image of LabVIEW code. The LabVIEW version is shown on the top-right hand corner. You can download it, then drag-and-drop it onto the LabVIEW block diagram from a file browser, and it will appear as runnable, editable code.\\n\\nAny Button can use a blink, a timer which return a changed value, true or false, but here we didn't use it (so we didn't Read from event's stack of values. We can place Stack statement to view this stack in console).\\nWe can use console as window too. Although we don't have events for this window, we can read mouse button. Also we use split screen so first line (line 0) has the title, and all other lines are cleared before we print on it, every 200ms\\nWe use form layer as console (we can't use input statements for those layers). We setup a thread to change form layer, at an interval of 200ms.\\nWhen a thread created saves the current layer, to use it in each iteration.\\nFirst, create a textbox, and by right-clicking it, and selecting component properties, change its name to \""Text\"". Then, create 2 buttons, changing the caption on one to \""Reverse\"", and the other to \""Forward\"". In the edit click action of each respective button, you will put:\\nand:\\nThen in the startup actions, accessed by clicking the 2 gears, add this:\\nCreates a window with a rotating label and 2 buttons to change the direction.\\nExample can be compiled by FreePascal/Lazarus.\\nDid all in one file, normally you have the project-file, the form-unit- and the form-resource-file.\\nA plain text version. The following script works in an XTerm window.\\nThe standard PicoLisp GUI is HTTP based. Connect your browser to\\nhttp://localhost:8080 after starting the following script.\\nThe scrolling text is displayed in a button. Clicking on the button\\nreverses the scroll direction.\\nThis solution works on ErsatzLisp, the Java version of PicoLisp.\\nSWI-Prolog has a grapghic interface XPCE.\\nBefore, load the QB.EXE with /L QB.QLB key, or QBX.EXE with /L QBX.QLB key, or just /L key any of them. That's the easiest way to get the mouse in DOS.\\nPressing to change direction should be on the text. To exit push the right button anywhere.\\nThe basic principle is:create a window with a label in it, then add a handler to the label for rotating the string, and another for changing direction on a click. Use of the tag function allows you to store the text flow direction as an attribute of the label.\\nThis REXX version only works with REXX/Personal or REXX/PC.\\nOutput:\\nScratch is event and animation oriented, so this is a natural task for this language. This solution is hosted at the scratch website, where one can see it in action and read its code.\\nSolution Summary and Comments\\nThe solution consists of two blocks of code. The main block initializes variables upon invocation and sets up a loop to display the crawling \""Hello World! \"" message. The crawl is accomplished by manipulation of the list containing the message as individual characters. The other block of code is attached to the scratch sprite, and all it does is change the direction of the text crawl when the sprite is clicked.\\nI tried a couple of techniques for introducing a delay into the text crawl loop. The command \""Say message for 2 seconds\"" resulted in poor performance; the application's response to clicks was spotty. Using the timer and waiting for it to exceed 2 seconds before resetting it and advancing the crawl worked much better. (I also tried waiting for the timer to equal 2 seconds, and unsurprisingly this resulted in an application freeze-up.)\\n\\nThis program can be concatenated onto a single line using ! as the concatenator:\\nMr. Kibernetik, the creator of smart Basic, offered this ultra-compact one-line version:\\nand smart Basic Forum member sarossell found a way to shorten even that! See if you can spot what is changed.\\nThis animation is defined as a smooth movement rather than by moving whole characters, because that is more natural in SVG (without scripting); by characters would require 13 different text elements displayed in sequence.\\n(Does not work in Safari 4.0.2 because it apparently does not implement toggled animations correctly (see spec). Dreadful workaround: set the two animations to id=\""a\"" begin=\""0s;all.click\"" end=\""all.mousedown\"" and begin=\""a.end\"" end=\""all.click\"", respectively.)\\nThe requirements contain \""When the user clicks on the text…\"". The TI-89 does not have a graphical cursor, so just for the sake of overdoing it, and to have a little more complex animation (overlapping objects), this program implements one. Use the arrow keys and ENTER to control the cursor.\\nIt is not possible to detect mouse clicks while a macro is running. Therefore, the direction is controlled with Caps Lock key.\\nThis example shows code that is hidden by the IDE. (Form creation is done graphically within the IDE, not at runtime.)\\nReplaces the detection of mouse click by pressing a key (Spectrum does not detect this device by default).\\n","import Tkinter as tki\\n\\ndef scroll_text(s, how_many):\\n    return s[how_many:] + s[:how_many]\\n\\ndirection = 1\\ntk = tki.Tk()\\nvar = tki.Variable(tk)\\n\\ndef mouse_handler(point):\\n    global direction\\n    direction *= -1\\n\\ndef timer_handler():\\n    var.set(scroll_text(var.get(),direction))\\n    tk.after(125, timer_handler)\\n\\nvar.set('Hello, World! ')\\ntki.Label(tk, textvariable=var).pack()\\ntk.bind(\""<Button-1>\"", mouse_handler)\\ntk.after(125, timer_handler)\\ntk.title('Python Animation')\\ntki.mainloop()\\n"
"Python","Anonymous_recursion","While implementing a recursive function, it often happens that we must resort to a separate   helper function   to handle the actual recursion.\\nThis is usually the case when directly calling the current function would waste too many resources (stack space, execution time), causing unwanted side-effects,   and/or the function doesn't have the right arguments and/or return values.\\nSo we end up inventing some silly name like   foo2   or   foo_helper.   I have always found it painful to come up with a proper name, and see some disadvantages:\\nSome languages allow you to embed recursion directly in-place.   This might work via a label, a local gosub instruction, or some special keyword.\\nAnonymous recursion can also be accomplished using the   Y combinator.\\n\\nIf possible, demonstrate this by writing the recursive version of the fibonacci function   (see Fibonacci sequence)   which checks for a negative argument before doing the actual recursion.\\n\\n",">>> Y = lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args)))\\n>>> fib = lambda f: lambda n: None if n < 0 else (0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2)))\\n>>> [ Y(fib)(i) for i in range(-2, 10) ]\\n[None, None, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34]"
"Python","Anonymous_recursion","While implementing a recursive function, it often happens that we must resort to a separate   helper function   to handle the actual recursion.\\nThis is usually the case when directly calling the current function would waste too many resources (stack space, execution time), causing unwanted side-effects,   and/or the function doesn't have the right arguments and/or return values.\\nSo we end up inventing some silly name like   foo2   or   foo_helper.   I have always found it painful to come up with a proper name, and see some disadvantages:\\nSome languages allow you to embed recursion directly in-place.   This might work via a label, a local gosub instruction, or some special keyword.\\nAnonymous recursion can also be accomplished using the   Y combinator.\\n\\nIf possible, demonstrate this by writing the recursive version of the fibonacci function   (see Fibonacci sequence)   which checks for a negative argument before doing the actual recursion.\\n\\n",">>>from functools import partial\\n>>> Y = lambda f: (lambda x: x(x))(lambda y: partial(f, lambda *args: y(y)(*args)))\\n>>> fib = lambda f, n: None if n < 0 else (0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2)))\\n>>> [ Y(fib)(i) for i in range(-2, 10) ]\\n[None, None, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34]"
"Python","Anonymous_recursion","While implementing a recursive function, it often happens that we must resort to a separate   helper function   to handle the actual recursion.\\nThis is usually the case when directly calling the current function would waste too many resources (stack space, execution time), causing unwanted side-effects,   and/or the function doesn't have the right arguments and/or return values.\\nSo we end up inventing some silly name like   foo2   or   foo_helper.   I have always found it painful to come up with a proper name, and see some disadvantages:\\nSome languages allow you to embed recursion directly in-place.   This might work via a label, a local gosub instruction, or some special keyword.\\nAnonymous recursion can also be accomplished using the   Y combinator.\\n\\nIf possible, demonstrate this by writing the recursive version of the fibonacci function   (see Fibonacci sequence)   which checks for a negative argument before doing the actual recursion.\\n\\n",">>> from functools import partial\\n>>> Y = lambda f: partial(f, f)\\n>>> fib = lambda f, n: None if n < 0 else (0 if n == 0 else (1 if n == 1 else f(f, n-1) + f(f, n-2)))\\n>>> [ Y(fib)(i) for i in range(-2, 10) ]\\n[None, None, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34]"
"Python","Anonymous_recursion","While implementing a recursive function, it often happens that we must resort to a separate   helper function   to handle the actual recursion.\\nThis is usually the case when directly calling the current function would waste too many resources (stack space, execution time), causing unwanted side-effects,   and/or the function doesn't have the right arguments and/or return values.\\nSo we end up inventing some silly name like   foo2   or   foo_helper.   I have always found it painful to come up with a proper name, and see some disadvantages:\\nSome languages allow you to embed recursion directly in-place.   This might work via a label, a local gosub instruction, or some special keyword.\\nAnonymous recursion can also be accomplished using the   Y combinator.\\n\\nIf possible, demonstrate this by writing the recursive version of the fibonacci function   (see Fibonacci sequence)   which checks for a negative argument before doing the actual recursion.\\n\\n","\\n>>> from inspect import currentframe\\n>>> from types import FunctionType\\n>>> def myself (*args, **kw):\\n...    caller_frame = currentframe(1)\\n...    code = caller_frame.f_code\\n...    return FunctionType(code, caller_frame.f_globals)(*args, **kw)\\n...\\n>>> print \""factorial(5) =\"",\\n>>> print (lambda n:1 if n<=1 else n*myself(n-1)) ( 5 )\\n"
"Python","Anti-primes","The anti-primes\\n(or highly composite numbers)\\nare the natural numbers with more factors than any smaller than itself.\\nGenerate and show here, the first twenty anti-primes.\\n \\n","from itertools import chain, count, cycle, islice, accumulate\\n \\ndef factors(n):\\n    def prime_powers(n):\\n        for c in accumulate(chain([2, 1, 2], cycle([2,4]))):\\n            if c*c > n: break\\n            if n%c: continue\\n            d,p = (), c\\n            while not n%c:\\n                n,p,d = n//c, p*c, d + (p,)\\n            yield(d)\\n        if n > 1: yield((n,))\\n \\n    r = [1]\\n    for e in prime_powers(n):\\n        r += [a*b for a in r for b in e]\\n    return r\\n    \\ndef antiprimes():\\n    mx = 0\\n    for c in count(1):\\n        ln = len(factors(c))\\n        if ln > mx:\\n            yield c\\n            mx = ln        \\n\\nif __name__ == '__main__':\\n    print(list(islice(antiprimes(), 20)))"
"Python","Append_a_record_to_the_end_of_a_text_file","Many systems offer the ability to open a file for writing, such that any data written will be appended to the end of the file. Further, the file operations will always adjust the position pointer to guarantee the end of the file, even in a multitasking environment.\\nThis feature is most useful in the case of log files, where many jobs may be appending to the log file at the same time, or where care must be taken to avoid concurrently overwriting the same record from another job.\\n\\nGiven a two record sample for a mythical \""passwd\"" file:\\nResulting file format: should mimic Linux's /etc/passwd file format with particular attention to the \"",\"" separator used in the GECOS field. But if the specific language has a particular or unique format of storing records in text file, then this format should be named and demonstrated with an additional example.\\nExpected output:\\nFinally: Provide a summary of the language's \""append record\"" capabilities in a table. eg.\\nAlternatively: If the language's appends can not guarantee its writes will always append, then note this restriction in the table. If possible, provide an actual code example (possibly using file/record locking) to guarantee correct concurrent appends.\\n\\nOutput:","#############################\\n# Create a passwd text file\\n#############################\\n# note that UID & gid are of type \""text\""\\npasswd_list=[\\n  dict(account='jsmith', password='x', UID=1001, GID=1000, # UID and GID are type int\\n       GECOS=dict(fullname='Joe Smith', office='Room 1007', extension='(234)555-8917',\\n                  homephone='(234)555-0077', email='jsmith@rosettacode.org'),\\n                  directory='/home/jsmith', shell='/bin/bash'),\\n  dict(account='jdoe', password='x', UID=1002, GID=1000,\\n       GECOS=dict(fullname='Jane Doe', office='Room 1004', extension='(234)555-8914',\\n                  homephone='(234)555-0044', email='jdoe@rosettacode.org'),\\n       directory='/home/jdoe', shell='/bin/bash')\\n]\\n\\npasswd_fields=\""account password UID GID GECOS directory shell\"".split()\\nGECOS_fields=\""fullname office extension homephone email\"".split()\\n\\ndef passwd_text_repr(passwd_rec):\\n# convert individual fields to string type\\n  passwd_rec[\""GECOS\""]=\"",\"".join([ passwd_rec[\""GECOS\""][field] for field in GECOS_fields])\\n  for field in passwd_rec: # convert \""int\"" fields\\n    if not isinstance(passwd_rec[field], str):\\n      passwd_rec[field]=`passwd_rec[field]`\\n  return \"":\"".join([ passwd_rec[field] for field in passwd_fields ])\\n\\npasswd_text=open(\""passwd.txt\"",\""w\"")\\nfor passwd_rec in passwd_list:\\n  print >> passwd_text,passwd_text_repr(passwd_rec)\\npasswd_text.close()\\n\\n#################################\\n# Load text ready for appending\\n#################################\\npasswd_text=open(\""passwd.txt\"",\""a+\"")\\nnew_rec=dict(account='xyz', password='x', UID=1003, GID=1000,\\n             GECOS=dict(fullname='X Yz', office='Room 1003', extension='(234)555-8913',\\n                        homephone='(234)555-0033', email='xyz@rosettacode.org'),\\n             directory='/home/xyz', shell='/bin/bash')\\nprint >> passwd_text,  passwd_text_repr(new_rec)\\npasswd_text.close()\\n\\n##############################################\\n# Finally reopen and check record was appended\\n##############################################\\npasswd_list=list(open(\""passwd.txt\"",\""r\""))\\nif \""xyz\"" in passwd_list[-1]:\\n  print \""Appended record:\"",passwd_list[-1][:-1]"
"Python","Apply_a_callback_to_an_array","Take a combined set of elements and apply a function to each element.\\n\\n","def square(n):\\n    return n * n\\n  \\nnumbers = [1, 3, 5, 7]\\n\\nsquares1 = [square(n) for n in numbers]     # list comprehension\\n\\nsquares2a = map(square, numbers)            # functional form\\n\\nsquares2b = map(lambda x: x*x, numbers)     # functional form with `lambda`\\n\\nsquares3 = [n * n for n in numbers]         # no need for a function,\\n                                            # anonymous or otherwise\\n\\nisquares1 = (n * n for n in numbers)        # iterator, lazy\\n\\nimport itertools\\nisquares2 = itertools.imap(square, numbers) # iterator, lazy"
"Python","Apply_a_callback_to_an_array","Take a combined set of elements and apply a function to each element.\\n\\n","print \"" \"".join(str(n * n) for n in range(10))"
"Python","Apply_a_callback_to_an_array","Take a combined set of elements and apply a function to each element.\\n\\n","print \"" \"".join(map(str, map(square, range(10))))"
"Python","Apply_a_callback_to_an_array","Take a combined set of elements and apply a function to each element.\\n\\n","0 1 4 9 16 25 36 49 64 81"
"Python","Apply_a_digital_filter_(direct_form_II_transposed)","Digital filters are used to apply a mathematical operation to a sampled signal. One of the common formulations is the \""direct form II transposed\"" which can represent both infinite impulse response (IIR) and finite impulse response (FIR) filters, as well as being more numerically stable than other forms. [1]\\nFilter a signal using an order 3 low-pass Butterworth filter. The coefficients for the filter are a=[1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17] and b = [0.16666667, 0.5, 0.5, 0.16666667]\\nThe signal that needs filtering is the following vector: [-0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412, -0.662370894973, -1.00700480494, -0.404707073677 ,0.800482325044, 0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195, 0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293, 0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589]\\nGiven the number of values a coefficient or signal vector can have and the number of digits, this implementation reads data from a file and prints it to the console if no output file is specified or writes to the specified output file. Usage printed on incorrect invocation.\\nInput file, 3 lines containing first ( a ) and second ( b ) coefficient followed by the signal, all values should be separated by a single space:\\nInvocation and output for writing to file :\\nOutput file :\\nThis uses the C++11 method of initializing vectors. In g++, use the -std=c++0x compiler switch.\\n","#!/bin/python\\nfrom __future__ import print_function\\nfrom scipy import signal\\nimport matplotlib.pyplot as plt\\n\\nif __name__==\""__main__\"":\\n	sig = [-0.917843918645,0.141984778794,1.20536903482,0.190286794412,-0.662370894973,-1.00700480494,\\n		-0.404707073677,0.800482325044,0.743500089861,1.01090520172,0.741527555207,\\n		0.277841675195,0.400833448236,-0.2085993586,-0.172842103641,-0.134316096293,\\n		0.0259303398477,0.490105989562,0.549391221511,0.9047198589]\\n\\n	#Create an order 3 lowpass butterworth filter\\n	#Generated using b, a = signal.butter(3, 0.5)\\n	a = [1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17]\\n	b = [0.16666667, 0.5, 0.5, 0.16666667]\\n\\n	#Apply the filter to signal\\n	filt = signal.lfilter(b, a, sig)\\n	print (filt)\\n\\n	plt.plot(sig, 'b')\\n	plt.plot(filt, 'r--')\\n	plt.show()"
"Python","Arbitrary-precision_integers_(included)","Using the in-built capabilities of your language, calculate the integer value of:\\n\\n\\n\\n",">>> y = str( 5**4**3**2 )\\n>>> print (\""5**4**3**2 = %s...%s and has %i digits\"" % (y[:20], y[-20:], len(y)))\\n5**4**3**2 = 62060698786608744707...92256259918212890625 and has 183231 digits"
"Python","Archimedean_spiral","The Archimedean spiral is a spiral named after the Greek mathematician Archimedes.\\n\\nAn Archimedean spiral can be described by the equation:\\nwith real numbers a and b.\\n\\nDraw an Archimedean spiral.\\n\\n\\n","from turtle import *\\nfrom math import *\\ncolor(\""blue\"")\\ndown()\\nfor i in range(200):\\n    t = i / 20 * pi\\n    x = (1 + 5 * t) * cos(t)\\n    y = (1 + 5 * t) * sin(t)\\n    goto(x, y)\\nup()\\ndone()"
"Python","Arithmetic_coding/As_a_generalized_change_of_radix","Create a program which implements the arithmetic coding as a generalized change of radix.\\nShow the results, in base 10, for all the following strings:\\n\\nVerify the implementation by decoding the results back into strings and checking for equality with the given strings.\\n","from collections import Counter\\n\\ndef cumulative_freq(freq):\\n    cf = {}\\n    total = 0\\n    for b in range(256):\\n        if b in freq:\\n            cf[b] = total\\n            total += freq[b]\\n    return cf\\n\\ndef arithmethic_coding(bytes, radix):\\n\\n    # The frequency characters\\n    freq = Counter(bytes)\\n\\n    # The cumulative frequency table\\n    cf = cumulative_freq(freq)\\n\\n    # Base\\n    base = len(bytes)\\n\\n    # Lower bound\\n    lower = 0\\n\\n    # Product of all frequencies\\n    pf = 1\\n\\n    # Each term is multiplied by the product of the\\n    # frequencies of all previously occurring symbols\\n    for b in bytes:\\n        lower = lower*base + cf[b]*pf\\n        pf *= freq[b]\\n\\n    # Upper bound\\n    upper = lower+pf\\n\\n    pow = 0\\n    while True:\\n        pf //= radix\\n        if pf==0: break\\n        pow += 1\\n\\n    enc = (upper-1) // radix**pow\\n    return enc, pow, freq\\n\\ndef arithmethic_decoding(enc, radix, pow, freq):\\n\\n    # Multiply enc by radix^pow\\n    enc *= radix**pow;\\n\\n    # Base\\n    base = sum(freq.values())\\n\\n    # Create the cumulative frequency table\\n    cf = cumulative_freq(freq)\\n\\n    # Create the dictionary\\n    dict = {}\\n    for k,v in cf.items():\\n        dict[v] = k\\n\\n    # Fill the gaps in the dictionary\\n    lchar = None\\n    for i in range(base):\\n        if i in dict:\\n            lchar = dict[i]\\n        elif lchar is not None:\\n            dict[i] = lchar\\n\\n    # Decode the input number\\n    decoded = bytearray()\\n    for i in range(base-1, -1, -1):\\n        pow = base**i\\n        div = enc//pow\\n\\n        c  = dict[div]\\n        fv = freq[c]\\n        cv = cf[c]\\n\\n        rem = (enc - pow*cv) // fv\\n\\n        enc = rem\\n        decoded.append(c)\\n\\n    # Return the decoded output\\n    return bytes(decoded)\\n\\nradix = 10      # can be any integer greater or equal with 2\\n\\nfor str in b'DABDDB DABDDBBDDBA ABRACADABRA TOBEORNOTTOBEORTOBEORNOT'.split():\\n    enc, pow, freq = arithmethic_coding(str, radix)\\n    dec = arithmethic_decoding(enc, radix, pow, freq)\\n\\n    print(\""%-25s=> %19s * %d^%s\"" % (str, enc, radix, pow))\\n\\n    if str != dec:\\n    	raise Exception(\""\\tHowever that is incorrect!\"")"
"Python","Arithmetic_evaluation","Create a program which parses and evaluates arithmetic expressions.\\n\\nFor those who don't remember, mathematical precedence is as follows:\\n\\n\\nPratt parser\\n","import operator\\n\\nclass AstNode(object):\\n   def __init__( self, opr, left, right ):\\n      self.opr = opr\\n      self.l = left\\n      self.r = right\\n\\n   def eval(self):\\n      return self.opr(self.l.eval(), self.r.eval())\\n\\nclass LeafNode(object):\\n   def __init__( self, valStrg ):\\n      self.v = int(valStrg)\\n\\n   def eval(self):\\n      return self.v\\n\\nclass Yaccer(object):\\n   def __init__(self):\\n      self.operstak = []\\n      self.nodestak =[]\\n      self.__dict__.update(self.state1)\\n\\n   def v1( self, valStrg ):\\n      # Value String\\n      self.nodestak.append( LeafNode(valStrg))\\n      self.__dict__.update(self.state2)\\n      #print 'push', valStrg\\n\\n   def o2( self, operchar ):\\n      # Operator character or open paren in state1\\n      def openParen(a,b):\\n         return 0		# function should not be called\\n\\n      opDict= { '+': ( operator.add, 2, 2 ),\\n         '-': (operator.sub, 2, 2 ),\\n         '*': (operator.mul, 3, 3 ),\\n         '/': (operator.div, 3, 3 ),\\n         '^': ( pow,         4, 5 ),  # right associative exponentiation for grins\\n         '(': ( openParen,   0, 8 )\\n         }\\n      operPrecidence = opDict[operchar][2]\\n      self.redeuce(operPrecidence)\\n\\n      self.operstak.append(opDict[operchar])\\n      self.__dict__.update(self.state1)\\n      # print 'pushop', operchar\\n\\n   def syntaxErr(self, char ):\\n      # Open Parenthesis \\n      print 'parse error - near operator \""%s\""' %char\\n\\n   def pc2( self,operchar ):\\n      # Close Parenthesis\\n      # reduce node until matching open paren found \\n      self.redeuce( 1 )\\n      if len(self.operstak)>0:\\n         self.operstak.pop()		# pop off open parenthesis\\n      else:\\n         print 'Error - no open parenthesis matches close parens.'\\n      self.__dict__.update(self.state2)\\n\\n   def end(self):\\n      self.redeuce(0)\\n      return self.nodestak.pop()\\n\\n   def redeuce(self, precidence):\\n      while len(self.operstak)>0:\\n         tailOper = self.operstak[-1]\\n         if tailOper[1] < precidence: break\\n\\n         tailOper = self.operstak.pop()\\n         vrgt = self.nodestak.pop()\\n         vlft= self.nodestak.pop()\\n         self.nodestak.append( AstNode(tailOper[0], vlft, vrgt))\\n         # print 'reduce'\\n\\n   state1 = { 'v': v1, 'o':syntaxErr, 'po':o2, 'pc':syntaxErr }\\n   state2 = { 'v': syntaxErr, 'o':o2, 'po':syntaxErr, 'pc':pc2 }\\n\\n\\ndef Lex( exprssn, p ):\\n   bgn = None\\n   cp = -1\\n   for c in exprssn:\\n      cp += 1\\n      if c in '+-/*^()':         # throw in exponentiation (^)for grins\\n         if bgn is not None:\\n            p.v(p, exprssn[bgn:cp])\\n            bgn = None\\n         if c=='(': p.po(p, c)\\n         elif c==')':p.pc(p, c)\\n         else: p.o(p, c)\\n      elif c in ' \\t':\\n         if bgn is not None:\\n            p.v(p, exprssn[bgn:cp])\\n            bgn = None\\n      elif c in '0123456789':\\n         if bgn is None:\\n            bgn = cp\\n      else:\\n         print 'Invalid character in expression'\\n         if bgn is not None:\\n            p.v(p, exprssn[bgn:cp])\\n            bgn = None\\n         \\n   if bgn is not None:\\n      p.v(p, exprssn[bgn:cp+1])\\n      bgn = None\\n   return p.end()\\n\\n\\nexpr = raw_input(\""Expression:\"")\\nastTree = Lex( expr, Yaccer())\\nprint expr, '=',astTree.eval()"
"Python","Arithmetic_evaluation","Create a program which parses and evaluates arithmetic expressions.\\n\\nFor those who don't remember, mathematical precedence is as follows:\\n\\n\\nPratt parser\\n",">>> import ast\\n>>> \\n>>> expr=\""2 * (3 -1) + 2 * 5\""\\n>>> node = ast.parse(expr, mode='eval')\\n>>> print(ast.dump(node).replace(',', ',\\n'))\\nExpression(body=BinOp(left=BinOp(left=Num(n=2),\\n op=Mult(),\\n right=BinOp(left=Num(n=3),\\n op=Sub(),\\n right=Num(n=1))),\\n op=Add(),\\n right=BinOp(left=Num(n=2),\\n op=Mult(),\\n right=Num(n=5))))\\n>>> code_object = compile(node, filename='<string>', mode='eval')\\n>>> eval(code_object)\\n14\\n>>> # lets modify the AST by changing the 5 to a 6\\n>>> node.body.right.right.n\\n5\\n>>> node.body.right.right.n = 6\\n>>> code_object = compile(node, filename='<string>', mode='eval')\\n>>> eval(code_object)\\n16"
"Python","Arithmetic-geometric_mean/Calculate_Pi","Almkvist Berndt 1988 begins with an investigation of why the agm is such an efficient algorithm, and proves that it converges quadratically. This is an efficient method to calculate \\n\\n\\n\\nπ\\n\\n\\n{\\displaystyle \\pi }\\n\\n.\\nWith the same notations used in Arithmetic-geometric mean, we can summarize the paper by writing:\\n\\n\\n\\n\\nπ\\n=\\n\\n\\n\\n4\\n\\n\\na\\ng\\nm\\n\\n(\\n1\\n,\\n1\\n\\n/\\n\\n\\n\\n2\\n\\n\\n\\n)\\n\\n2\\n\\n\\n\\n\\n1\\n−\\n\\n∑\\n\\nn\\n=\\n1\\n\\n\\n∞\\n\\n\\n\\n2\\n\\nn\\n+\\n1\\n\\n\\n(\\n\\na\\n\\nn\\n\\n\\n2\\n\\n\\n−\\n\\ng\\n\\nn\\n\\n\\n2\\n\\n\\n)\\n\\n\\n\\n\\n\\n{\\displaystyle \\pi ={\\frac {4\\;\\mathrm {agm} (1,1/{\\sqrt {2}})^{2}}{1-\\sum \\limits _{n=1}^{\\infty }2^{n+1}(a_{n}^{2}-g_{n}^{2})}}}\\n\\n\\nThis allows you to make the approximation, for any large   N:\\n\\n\\n\\n\\nπ\\n≈\\n\\n\\n\\n4\\n\\n\\na\\n\\nN\\n\\n\\n2\\n\\n\\n\\n\\n1\\n−\\n\\n∑\\n\\nk\\n=\\n1\\n\\n\\nN\\n\\n\\n\\n2\\n\\nk\\n+\\n1\\n\\n\\n(\\n\\na\\n\\nk\\n\\n\\n2\\n\\n\\n−\\n\\ng\\n\\nk\\n\\n\\n2\\n\\n\\n)\\n\\n\\n\\n\\n\\n{\\displaystyle \\pi \\approx {\\frac {4\\;a_{N}^{2}}{1-\\sum \\limits _{k=1}^{N}2^{k+1}(a_{k}^{2}-g_{k}^{2})}}}\\n\\n\\nThe purpose of this task is to demonstrate how to use this approximation in order to compute a large number of decimals of \\n\\n\\n\\nπ\\n\\n\\n{\\displaystyle \\pi }\\n\\n.\\nSee Talk:Arithmetic-geometric mean\\ni<7 produces:\\ni<8 produces:\\n","from decimal import *\\n\\nD = Decimal\\ngetcontext().prec = 100\\na = n = D(1)\\ng, z, half = 1 / D(2).sqrt(), D(0.25), D(0.5)\\nfor i in range(18):\\n    x = [(a + g) * half, (a * g).sqrt()]\\n    var = x[0] - a\\n    z -= var * var * n\\n    n += n\\n    a, g = x    \\nprint(a * a / z)"
"Python","Arithmetic/Complex","A   complex number   is a number which can be written as:\\n\\n\\n\\n\\na\\n+\\nb\\n×\\ni\\n\\n\\n{\\displaystyle a+b\\times i}\\n\\n\\n(sometimes shown as:\\n\\n\\n\\n\\nb\\n+\\na\\n×\\ni\\n\\n\\n{\\displaystyle b+a\\times i}\\n\\n\\nwhere   \\n\\n\\n\\na\\n\\n\\n{\\displaystyle a}\\n\\n   and   \\n\\n\\n\\nb\\n\\n\\n{\\displaystyle b}\\n\\n  are real numbers,   and   \\n\\n\\n\\ni\\n\\n\\n{\\displaystyle i}\\n\\n   is   √ -1 \\n\\nTypically, complex numbers are represented as a pair of real numbers called the \""imaginary part\"" and \""real part\"",   where the imaginary part is the number to be multiplied by \\n\\n\\n\\ni\\n\\n\\n{\\displaystyle i}\\n\\n.\\n\\n\\nBy definition, the   complex conjugate   of\\n\\n\\n\\n\\na\\n+\\nb\\ni\\n\\n\\n{\\displaystyle a+bi}\\n\\n\\nis\\n\\n\\n\\n\\na\\n−\\nb\\ni\\n\\n\\n{\\displaystyle a-bi}\\n\\n\\n\\nSome languages have complex number libraries available.   If your language does, show the operations.   If your language does not, also show the definition of this type.\\n\\n",">>> z1 = 1.5 + 3j\\n>>> z2 = 1.5 + 1.5j\\n>>> z1 + z2\\n(3+4.5j)\\n>>> z1 - z2\\n1.5j\\n>>> z1 * z2\\n(-2.25+6.75j)\\n>>> z1 / z2\\n(1.5+0.5j)\\n>>> - z1\\n(-1.5-3j)\\n>>> z1.conjugate()\\n(1.5-3j)\\n>>> abs(z1)\\n3.3541019662496847\\n>>> z1 ** z2\\n(-1.1024829553277784-0.38306415117199333j)\\n>>> z1.real\\n1.5\\n>>> z1.imag\\n3.0\\n>>> "
"Python","Arithmetic/Integer","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\nGet two integers from the user,   and then (for those two integers), display their:\\n\\nDon't include error handling.\\nFor quotient, indicate how it rounds   (e.g. towards zero, towards negative infinity, etc.).\\nFor remainder, indicate whether its sign matches the sign of the first operand or of the second operand, if they are different.\\n\\n","x = int(raw_input(\""Number 1: \""))\\ny = int(raw_input(\""Number 2: \""))\\n\\nprint \""Sum: %d\"" % (x + y)\\nprint \""Difference: %d\"" % (x - y)\\nprint \""Product: %d\"" % (x * y)\\nprint \""Quotient: %d\"" % (x / y)     #  or x // y  for newer python versions.\\n                                   # truncates towards negative infinity\\nprint \""Remainder: %d\"" % (x % y)    # same sign as second operand\\nprint \""Quotient: %d with Remainder: %d\"" % divmod(x, y)\\nprint \""Power: %d\"" % x**y\\n\\n## Only used to keep the display up when the program ends\\nraw_input( )"
"Python","Arithmetic/Integer","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\nGet two integers from the user,   and then (for those two integers), display their:\\n\\nDon't include error handling.\\nFor quotient, indicate how it rounds   (e.g. towards zero, towards negative infinity, etc.).\\nFor remainder, indicate whether its sign matches the sign of the first operand or of the second operand, if they are different.\\n\\n","def getnum(prompt):\\n    while True: # retrying ...\\n        try:\\n            n = int(raw_input(prompt))\\n        except ValueError:\\n            print \""Input could not be parsed as an integer. Please try again.\""\\\\n            continue\\n        break\\n    return n\\n\\nx = getnum(\""Number1: \"")\\ny = getnum(\""Number2: \"")\\n..."
"Python","Arithmetic/Integer","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\nGet two integers from the user,   and then (for those two integers), display their:\\n\\nDon't include error handling.\\nFor quotient, indicate how it rounds   (e.g. towards zero, towards negative infinity, etc.).\\nFor remainder, indicate whether its sign matches the sign of the first operand or of the second operand, if they are different.\\n\\n","def arithmetic(x, y):\\n    for op in \""+ - * // % **\"".split():\\n        expr = \""%(x)s %(op)s %(y)s\"" % vars()\\n        print(\""%s\\t=> %s\"" % (expr, eval(expr)))\\n\\n\\narithmetic(12, 8)\\narithmetic(input(\""Number 1: \""), input(\""Number 2: \""))"
"Python","Arithmetic/Rational","Create a reasonably complete implementation of rational arithmetic in the particular language using the idioms of the language.\\n\\nDefine a new type called frac with binary operator \""//\"" of two integers that returns a structure made up of the numerator and the denominator (as per a rational number).\\nFurther define the appropriate rational unary operators abs and '-', with the binary operators for addition '+', subtraction '-', multiplication '×', division '/', integer division '÷', modulo division, the comparison operators (e.g. '<', '≤', '>', & '≥') and equality operators (e.g. '=' & '≠').\\nDefine standard coercion operators for casting int to frac etc.\\nIf space allows, define standard increment and decrement operators (e.g. '+:=' & '-:=' etc.).\\nFinally test the operators:\\nUse the new type frac to find all perfect numbers less than 219 by summing the reciprocal of the factors.\\n\\n\\nThe generic package specification:\\nThe package can be instantiated with any integer type. It provides rational numbers represented by a numerator and denominator cleaned from the common divisors. Mixed arithmetic of the base integer type and the rational type is supported. Division to zero raises Constraint_Error. The implementation of the specification above is as follows:\\nThe implementation uses solution of the greatest common divisor task. Here is the implementation of the test:\\nThe perfect numbers are searched by summing of the reciprocal of each of the divisors of a candidate except 1. This sum must be 1 for a perfect number.\\n","from fractions import Fraction\\n\\nfor candidate in range(2, 2**19):\\n  sum = Fraction(1, candidate)\\n  for factor in range(2, int(candidate**0.5)+1):\\n    if candidate % factor == 0:\\n      sum += Fraction(1, factor) + Fraction(1, candidate // factor)\\n  if sum.denominator == 1:\\n    print(\""Sum of recipr. factors of %d = %d exactly %s\"" %\\n           (candidate, int(sum), \""perfect!\"" if sum == 1 else \""\""))"
"Python","Arithmetic/Rational","Create a reasonably complete implementation of rational arithmetic in the particular language using the idioms of the language.\\n\\nDefine a new type called frac with binary operator \""//\"" of two integers that returns a structure made up of the numerator and the denominator (as per a rational number).\\nFurther define the appropriate rational unary operators abs and '-', with the binary operators for addition '+', subtraction '-', multiplication '×', division '/', integer division '÷', modulo division, the comparison operators (e.g. '<', '≤', '>', & '≥') and equality operators (e.g. '=' & '≠').\\nDefine standard coercion operators for casting int to frac etc.\\nIf space allows, define standard increment and decrement operators (e.g. '+:=' & '-:=' etc.).\\nFinally test the operators:\\nUse the new type frac to find all perfect numbers less than 219 by summing the reciprocal of the factors.\\n\\n\\nThe generic package specification:\\nThe package can be instantiated with any integer type. It provides rational numbers represented by a numerator and denominator cleaned from the common divisors. Mixed arithmetic of the base integer type and the rational type is supported. Division to zero raises Constraint_Error. The implementation of the specification above is as follows:\\nThe implementation uses solution of the greatest common divisor task. Here is the implementation of the test:\\nThe perfect numbers are searched by summing of the reciprocal of each of the divisors of a candidate except 1. This sum must be 1 for a perfect number.\\n","def lcm(a, b):\\n    return a // gcd(a,b) * b\\n\\ndef gcd(u, v):\\n    return gcd(v, u%v) if v else abs(u)\\n\\nclass Fraction:\\n    def __init__(self, numerator, denominator):\\n        common = gcd(numerator, denominator)\\n        self.numerator = numerator//common\\n        self.denominator = denominator//common\\n    def __add__(self, frac):\\n        common = lcm(self.denominator, frac.denominator)\\n        n = common // self.denominator * self.numerator + common // frac.denominator * frac.numerator\\n        return Fraction(n, common)\\n    def __sub__(self, frac):\\n        return self.__add__(-frac)\\n    def __neg__(self):\\n        return Fraction(-self.numerator, self.denominator)\\n    def __abs__(self):\\n        return Fraction(abs(self.numerator), abs(self.denominator))\\n    def __mul__(self, frac):\\n        return Fraction(self.numerator * frac.numerator, self.denominator * frac.denominator)\\n    def __div__(self, frac):\\n        return self.__mul__(frac.reciprocal())\\n    def reciprocal(self):\\n        return Fraction(self.denominator, self.numerator)\\n    def __cmp__(self, n):\\n        return int(float(self) - float(n))\\n    def __float__(self):\\n        return float(self.numerator / self.denominator)\\n    def __int__(self):\\n        return (self.numerator // self.denominator)"
"Python","Array_concatenation","Show how to concatenate two arrays in your language.\\n\\nIf this is as simple as array1 + array2, so be it.\\n\\n","arr1 = [1, 2, 3]\\narr2 = [4, 5, 6]\\narr3 = [7, 8, 9]\\narr4 = arr1 + arr2\\nassert arr4 == [1, 2, 3, 4, 5, 6]\\narr4.extend(arr3)\\nassert arr4 == [1, 2, 3, 4, 5, 6, 7, 8, 9]"
"Python","Array_concatenation","Show how to concatenate two arrays in your language.\\n\\nIf this is as simple as array1 + array2, so be it.\\n\\n","arr5 = [4, 5, 6]\\narr6 = [7, 8, 9]\\narr6 += arr5\\nassert arr6 == [7, 8, 9, 4, 5, 6]"
"Python","Array_length","Determine the amount of elements in an array.\\n\\nAs an example use an array holding the strings 'apple' and 'orange'.\\n\\n\\n",">>> print(len(['apple', 'orange']))\\n2\\n>>> "
"Python","Arrays","This task is about arrays.\\nFor hashes or associative arrays, please see Creating an Associative Array.\\nFor a definition and in-depth discussion of what an array is, see Array.\\n\\nShow basic array syntax in your language.\\nBasically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and\\ndynamic arrays, pushing a value into it).\\nPlease discuss at Village Pump:   Arrays.\\nPlease merge code in from these obsolete tasks:\\n\\n\\nDynamic (resizable) arrays are possible to implement, but are error-prone since bounds checking must be done by the programmer.\\nArrays are declared using JSON syntax, and are dynamic (but not sparse)\\nThere are no real arrays in ABAP but a construct called internal tables.\\n","array = []\\n\\narray.append(1)\\narray.append(3)\\n\\narray[0] = 2\\n\\nprint array[0]"
"Python","Arrays","This task is about arrays.\\nFor hashes or associative arrays, please see Creating an Associative Array.\\nFor a definition and in-depth discussion of what an array is, see Array.\\n\\nShow basic array syntax in your language.\\nBasically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and\\ndynamic arrays, pushing a value into it).\\nPlease discuss at Village Pump:   Arrays.\\nPlease merge code in from these obsolete tasks:\\n\\n\\nDynamic (resizable) arrays are possible to implement, but are error-prone since bounds checking must be done by the programmer.\\nArrays are declared using JSON syntax, and are dynamic (but not sparse)\\nThere are no real arrays in ABAP but a construct called internal tables.\\n","myArray = [0] * size"
"Python","Arrays","This task is about arrays.\\nFor hashes or associative arrays, please see Creating an Associative Array.\\nFor a definition and in-depth discussion of what an array is, see Array.\\n\\nShow basic array syntax in your language.\\nBasically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and\\ndynamic arrays, pushing a value into it).\\nPlease discuss at Village Pump:   Arrays.\\nPlease merge code in from these obsolete tasks:\\n\\n\\nDynamic (resizable) arrays are possible to implement, but are error-prone since bounds checking must be done by the programmer.\\nArrays are declared using JSON syntax, and are dynamic (but not sparse)\\nThere are no real arrays in ABAP but a construct called internal tables.\\n","myArray = [[0]* width] * height] # DOES NOT WORK AS INTENDED!!!"
"Python","Arrays","This task is about arrays.\\nFor hashes or associative arrays, please see Creating an Associative Array.\\nFor a definition and in-depth discussion of what an array is, see Array.\\n\\nShow basic array syntax in your language.\\nBasically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and\\ndynamic arrays, pushing a value into it).\\nPlease discuss at Village Pump:   Arrays.\\nPlease merge code in from these obsolete tasks:\\n\\n\\nDynamic (resizable) arrays are possible to implement, but are error-prone since bounds checking must be done by the programmer.\\nArrays are declared using JSON syntax, and are dynamic (but not sparse)\\nThere are no real arrays in ABAP but a construct called internal tables.\\n","myArray = [[0 for x in range(width)] for y in range(height)]"
"Python","Arrays","This task is about arrays.\\nFor hashes or associative arrays, please see Creating an Associative Array.\\nFor a definition and in-depth discussion of what an array is, see Array.\\n\\nShow basic array syntax in your language.\\nBasically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and\\ndynamic arrays, pushing a value into it).\\nPlease discuss at Village Pump:   Arrays.\\nPlease merge code in from these obsolete tasks:\\n\\n\\nDynamic (resizable) arrays are possible to implement, but are error-prone since bounds checking must be done by the programmer.\\nArrays are declared using JSON syntax, and are dynamic (but not sparse)\\nThere are no real arrays in ABAP but a construct called internal tables.\\n","myArray = list()\\nfor x in range(height):\\n   myArray.append([0] * width)"
"Python","Arrays","This task is about arrays.\\nFor hashes or associative arrays, please see Creating an Associative Array.\\nFor a definition and in-depth discussion of what an array is, see Array.\\n\\nShow basic array syntax in your language.\\nBasically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and\\ndynamic arrays, pushing a value into it).\\nPlease discuss at Village Pump:   Arrays.\\nPlease merge code in from these obsolete tasks:\\n\\n\\nDynamic (resizable) arrays are possible to implement, but are error-prone since bounds checking must be done by the programmer.\\nArrays are declared using JSON syntax, and are dynamic (but not sparse)\\nThere are no real arrays in ABAP but a construct called internal tables.\\n","\\n# Retrieve an element directly from the array.\\nitem = array[index]\\n\\n# Use the array like a stack.  Note that using the pop() method removes the element.\\narray.pop()  # Pop last item in a list\\narray.pop(0) # Pop first item in a list\\n\\n# Using a negative element counts from the end of the list.\\nitem = array[-1] # Retrieve last element in a list.\\n"
"Python","Arrays","This task is about arrays.\\nFor hashes or associative arrays, please see Creating an Associative Array.\\nFor a definition and in-depth discussion of what an array is, see Array.\\n\\nShow basic array syntax in your language.\\nBasically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and\\ndynamic arrays, pushing a value into it).\\nPlease discuss at Village Pump:   Arrays.\\nPlease merge code in from these obsolete tasks:\\n\\n\\nDynamic (resizable) arrays are possible to implement, but are error-prone since bounds checking must be done by the programmer.\\nArrays are declared using JSON syntax, and are dynamic (but not sparse)\\nThere are no real arrays in ABAP but a construct called internal tables.\\n","\\ntry:\\n    # This will cause an exception, which will then be caught.\\n    print array[len(array)]\\nexcept IndexError as e:\\n    # Print the exception. \\n    print e\\n"
"Python","Assertions","Assertions are a way of breaking out of code when there is an error or an unexpected input.\\nSome languages throw exceptions and some treat it as a break point.\\n\\nShow an assertion in your language by asserting that an integer variable is equal to 42.\\n\\nUsing pragma Assert:\\nThe behavior of pragma is controlled by pragma Assertion_Policy. Another way is to use the predefined package Ada.Assertions:\\nThe procedure Assert propagates Assertion_Error when condition is false.\\nExecuting the program will produce on standard error:\\nThe \""Revised Report on the Algorithmic Language - ALGOL 68\"" suggest that\\nASSERT may be made available by a particular implementation, quote: \""Pragmats may\\n... convey to the implementation some piece of information affecting some aspect\\nof the meaning of the program which is not defined by this Report,...\""\\nExample given[1]:\\nThis works with neither ELLA ALGOL 68 nor ALGOL 68G.\\nThe standard alternative would be to implement the assertions\\nas an exception as per the Exceptions sample code.\\nIn ELLA ALGOL 68 the ASSERT is implemented as an operator in the environment prelude:\\nAnd can be \""USEd\"" as follows:\\nAssertions were added to the 1972 version of Algol W. If the tested condition is false, the program terminates. In the following, the write does not get executed.\\nAsserts that the specified condition is true. If it is not, a fatal error is returned that causes code execution to halt.\\nAsserts that the first two arguments are the same. If they are not, a fatal error is returned that causes code execution to halt.\\nAsserts that the first two arguments are different. If they are the same, a fatal error is returned that causes code execution to halt.\\nYou can’t catch an assertion failure using a try/catch block even though it is logged as an exception.\\nAWK doesn't have a built-in assert statement. It could be simulated using a user-defined assert() function defined as below. The BEGIN section shows some examples of successful and failed \""assertions\"".\\nThe above example produces the output below, and sets the program's exit code to 1 (the default is 0)\\n","a = 5\\n#...input or change a here\\nassert a == 42 # throws an AssertionError when a is not 42\\nassert a == 42, \""Error message\"" # throws an AssertionError\\n       # when a is not 42 with \""Error message\"" for the message\\n       # the error message can be any expression"
"Python","Associative_array/Creation","The goal is to create an associative array (also known as a dictionary, map, or hash).\\n\\nRelated tasks:\\n\\n\\n8th has 'maps' as built-in data types, and can use JSON to describe them:\\nAlternatively, they can be created in code:\\nBecause ActionScript does not have associative arrays in the normal sense, Object objects are used instead and keys are simply properties on those objects.\\nNote: The Object only supports String keys. To use an object as a key, try the flash.utils.Dictionary class.\\nAikido provides a native map for associative arrays. You can create them using a map literal and you can insert and remove items on the fly.\\nAime records are heterogenous associative arrays. No creation procedure is required, declaration is fine.\\n","hash = dict()  # 'dict' is the dictionary type.\\nhash = dict(red=\""FF0000\"", green=\""00FF00\"", blue=\""0000FF\"")\\nhash = { 'key1':1, 'key2':2, }\\nvalue = hash[key]"
"Python","Associative_array/Creation","The goal is to create an associative array (also known as a dictionary, map, or hash).\\n\\nRelated tasks:\\n\\n\\n8th has 'maps' as built-in data types, and can use JSON to describe them:\\nAlternatively, they can be created in code:\\nBecause ActionScript does not have associative arrays in the normal sense, Object objects are used instead and keys are simply properties on those objects.\\nNote: The Object only supports String keys. To use an object as a key, try the flash.utils.Dictionary class.\\nAikido provides a native map for associative arrays. You can create them using a map literal and you can insert and remove items on the fly.\\nAime records are heterogenous associative arrays. No creation procedure is required, declaration is fine.\\n","# empty dictionary\\nd = {}\\nd['spam'] = 1\\nd['eggs'] = 2  \\n\\n# dictionaries with two keys\\nd1 = {'spam': 1, 'eggs': 2}\\nd2 = dict(spam=1, eggs=2)\\n\\n# dictionaries from tuple list\\nd1 = dict([('spam', 1), ('eggs', 2)])\\nd2 = dict(zip(['spam', 'eggs'], [1, 2]))\\n\\n# iterating over keys\\nfor key in d:\\n  print key, d[key]\\n\\n# iterating over (key, value) pairs\\nfor key, value in d.iteritems():\\n  print key, value"
"Python","Associative_array/Creation","The goal is to create an associative array (also known as a dictionary, map, or hash).\\n\\nRelated tasks:\\n\\n\\n8th has 'maps' as built-in data types, and can use JSON to describe them:\\nAlternatively, they can be created in code:\\nBecause ActionScript does not have associative arrays in the normal sense, Object objects are used instead and keys are simply properties on those objects.\\nNote: The Object only supports String keys. To use an object as a key, try the flash.utils.Dictionary class.\\nAikido provides a native map for associative arrays. You can create them using a map literal and you can insert and remove items on the fly.\\nAime records are heterogenous associative arrays. No creation procedure is required, declaration is fine.\\n","myDict = { '1': 'a string', 1: 'an integer', 1.0: 'a floating point number', (1,): 'a tuple' }"
"Python","Atomic_updates","\\nDefine a data type consisting of a fixed number of 'buckets', each containing a nonnegative integer value, which supports operations to:\\nIn order to exercise this data type, create one set of buckets, and start three concurrent tasks:\\n\\nThe display task need not be explicit; use of e.g. a debugger or trace tool is acceptable provided it is simple to set up to provide the display.\\nThis task is intended as an exercise in atomic operations.   The sum of the bucket values must be preserved even if the two tasks attempt to perform transfers simultaneously, and a straightforward solution is to ensure that at any time, only one transfer is actually occurring — that the transfer operation is atomic.\\n\\n","from __future__ import with_statement # required for Python 2.5\\nimport threading\\nimport random\\nimport time\\n\\nterminate = threading.Event()\\n\\nclass Buckets:\\n    def __init__(self, nbuckets):\\n        self.nbuckets = nbuckets\\n        self.values = [random.randrange(10) for i in range(nbuckets)]\\n        self.lock = threading.Lock()\\n\\n    def __getitem__(self, i):\\n        return self.values[i]\\n\\n    def transfer(self, src, dst, amount):\\n        with self.lock:\\n            amount = min(amount, self.values[src])\\n            self.values[src] -= amount\\n            self.values[dst] += amount\\n\\n    def snapshot(self):\\n        # copy of the current state (synchronized)\\n        with self.lock:\\n            return self.values[:]\\n\\ndef randomize(buckets):\\n    nbuckets = buckets.nbuckets\\n    while not terminate.isSet():\\n        src = random.randrange(nbuckets)\\n        dst = random.randrange(nbuckets)\\n        if dst!=src:\\n            amount = random.randrange(20)\\n            buckets.transfer(src, dst, amount)\\n\\ndef equalize(buckets):\\n    nbuckets = buckets.nbuckets\\n    while not terminate.isSet():\\n        src = random.randrange(nbuckets)\\n        dst = random.randrange(nbuckets)\\n        if dst!=src:\\n            amount = (buckets[src] - buckets[dst]) // 2\\n            if amount>=0: buckets.transfer(src, dst, amount)\\n            else: buckets.transfer(dst, src, -amount)\\n\\ndef print_state(buckets):\\n    snapshot = buckets.snapshot()\\n    for value in snapshot:\\n        print '%2d' % value,\\n    print '=', sum(snapshot)\\n\\n# create 15 buckets\\nbuckets = Buckets(15)\\n\\n# the randomize thread\\nt1 = threading.Thread(target=randomize, args=[buckets])\\nt1.start()\\n\\n# the equalize thread\\nt2 = threading.Thread(target=equalize, args=[buckets])\\nt2.start()\\n\\n# main thread, display\\ntry:\\n    while True:\\n        print_state(buckets)\\n        time.sleep(1)\\nexcept KeyboardInterrupt: # ^C to finish\\n    terminate.set()\\n\\n# wait until all worker threads finish\\nt1.join()\\nt2.join()"
"Python","AudioAlarm","AudioAlarm is a program that asks the user to enter a certain number, representing a number of seconds. After the user enters the number, the program will ask the user to enter the name of an MP3 audio file (without the .mp3 file extension). The program will then display a (usually blank) page. After the time (indicated by the number) is up, a sound (indicated by the MP3 file) will go off. Useful for timers and alarm clocks. The app must be installed in its own folder, preferrably with a name like AudioAlarm. To install a sound on the app, just copy the MP3 to the app folder you set up. Then, when the app asks you for the filename, you just type in the name without an extension.\\nUses Run for maximum compatibility\\n","import time\\nimport os\\n\\nseconds = input(\""Enter a number of seconds: \"")\\nsound = input(\""Enter an mp3 filename: \"")\\n\\ntime.sleep(float(seconds))\\nos.startfile(sound + \"".mp3\"")"
"Python","Average_loop_length","Let f be a uniformly-randomly chosen mapping from the numbers 1..N to the numbers 1..N (note: not necessarily a permutation of 1..N; the mapping could produce a number in more than one way or not at all). At some point, the sequence 1, f(1), f(f(1))... will contain a repetition, a number that occurring for the second time in the sequence.\\n\\nWrite a program or a script that estimates, for each N, the average length until the first such repetition.\\nAlso calculate this expected length using an analytical formula, and optionally compare the simulated result with the theoretical one.\\n\\nThis problem comes from the end of Donald Knuth's Christmas tree lecture 2011.\\nExample of expected output:\\n\\n","from __future__ import division # Only necessary for Python 2.X\\nfrom math import factorial\\nfrom random import randrange\\n\\nMAX_N = 20\\nTIMES = 1000000\\n\\ndef analytical(n):\\n	return sum(factorial(n) / pow(n, i) / factorial(n -i) for i in range(1, n+1))\\n\\ndef test(n, times):\\n    count = 0\\n    for i in range(times):\\n        x, bits = 1, 0\\n        while not (bits & x):\\n            count += 1\\n            bits |= x\\n            x = 1 << randrange(n)\\n    return count / times\\n\\nif __name__ == '__main__':\\n    print(\"" n\\tavg\\texp.\\tdiff\\n-------------------------------\"")\\n    for n in range(1, MAX_N+1):\\n        avg = test(n, TIMES)\\n        theory = analytical(n)\\n        diff = (avg / theory - 1) * 100\\n        print(\""%2d %8.4f %8.4f %6.3f%%\"" % (n, avg, theory, diff))"
"Python","Averages/Arithmetic_mean","Write a program to find the mean (arithmetic average) of a numeric vector.\\nIn case of a zero-length input, since the mean of an empty set of numbers is ill-defined, the program may choose to behave in any way it deems appropriate, though if the programming language has an established convention for conveying math errors or undefined values, it's preferable to follow it.\\n","from math import fsum\\ndef average(x):\\n    return fsum(x)/float(len(x)) if x else 0\\nprint (average([0,0,3,1,4,1,5,9,0,0]))\\nprint (average([1e20,-1e-20,3,1,4,1,5,9,-1e20,1e-20]))"
"Python","Averages/Arithmetic_mean","Write a program to find the mean (arithmetic average) of a numeric vector.\\nIn case of a zero-length input, since the mean of an empty set of numbers is ill-defined, the program may choose to behave in any way it deems appropriate, though if the programming language has an established convention for conveying math errors or undefined values, it's preferable to follow it.\\n","2.3\\n2.3"
"Python","Averages/Arithmetic_mean","Write a program to find the mean (arithmetic average) of a numeric vector.\\nIn case of a zero-length input, since the mean of an empty set of numbers is ill-defined, the program may choose to behave in any way it deems appropriate, though if the programming language has an established convention for conveying math errors or undefined values, it's preferable to follow it.\\n","def average(x):\\n    return sum(x)/float(len(x)) if x else 0\\nprint (average([0,0,3,1,4,1,5,9,0,0]))\\nprint (average([1e20,-1e-20,3,1,4,1,5,9,-1e20,1e-20]))"
"Python","Averages/Arithmetic_mean","Write a program to find the mean (arithmetic average) of a numeric vector.\\nIn case of a zero-length input, since the mean of an empty set of numbers is ill-defined, the program may choose to behave in any way it deems appropriate, though if the programming language has an established convention for conveying math errors or undefined values, it's preferable to follow it.\\n","2.3\\n1e-21"
"Python","Averages/Arithmetic_mean","Write a program to find the mean (arithmetic average) of a numeric vector.\\nIn case of a zero-length input, since the mean of an empty set of numbers is ill-defined, the program may choose to behave in any way it deems appropriate, though if the programming language has an established convention for conveying math errors or undefined values, it's preferable to follow it.\\n","def avg(data):\\n    if len(data)==0:\\n        return 0\\n    else:\\n        return sum(data)/float(len(data))\\nprint avg([0,0,3,1,4,1,5,9,0,0])"
"Python","Averages/Arithmetic_mean","Write a program to find the mean (arithmetic average) of a numeric vector.\\nIn case of a zero-length input, since the mean of an empty set of numbers is ill-defined, the program may choose to behave in any way it deems appropriate, though if the programming language has an established convention for conveying math errors or undefined values, it's preferable to follow it.\\n","2.3"
"Python","Averages/Arithmetic_mean","Write a program to find the mean (arithmetic average) of a numeric vector.\\nIn case of a zero-length input, since the mean of an empty set of numbers is ill-defined, the program may choose to behave in any way it deems appropriate, though if the programming language has an established convention for conveying math errors or undefined values, it's preferable to follow it.\\n",">>> from statistics import mean\\n>>> mean([1e20,-1e-20,3,1,4,1,5,9,-1e20,1e-20])\\n2.3\\n>>> mean([10**10000, -10**10000, 3, 1, 4, 1, 5, 9, 0, 0])\\n2.3\\n>>> mean([10**10000, -10**10000, 3, 1, 4, 1, 5, 9, Fraction(1, 10**10000), Fraction(-1, 10**10000)])\\nFraction(23, 10)\\n>>> big = 10**10000\\n>>> mean([Decimal(big), Decimal(-big), 3, 1, 4, 1, 5, 9, 1/Decimal(big), -1/Decimal(big)])\\nDecimal('2.3')"
"Python","Averages/Mean_angle","When calculating the average or mean of an angle one has to take into account how angles wrap around so that any angle in degrees plus any integer multiple of 360 degrees is a measure of the same angle.\\nIf one wanted an average direction of the wind over two readings where the first reading was of 350 degrees and the second was of 10 degrees then the average of the numbers is 180 degrees, whereas if you can note that 350 degrees is equivalent to -10 degrees and so you have two readings at 10 degrees either side of zero degrees leading to a more fitting mean angle of zero degrees.\\nTo calculate the mean angle of several angles:\\n\\n(Note that, since the mean is the sum divided by the number of numbers, and division by a positive real number does not affect the angle, you can also simply compute the sum for step 2.)\\nYou can alternatively use this formula:\\n",">>> from cmath import rect, phase\\n>>> from math import radians, degrees\\n>>> def mean_angle(deg):\\n...     return degrees(phase(sum(rect(1, radians(d)) for d in deg)/len(deg)))\\n... \\n>>> for angles in [[350, 10], [90, 180, 270, 360], [10, 20, 30]]:\\n...     print('The mean angle of', angles, 'is:', round(mean_angle(angles), 12), 'degrees')\\n...     \\nThe mean angle of [350, 10] is: -0.0 degrees\\nThe mean angle of [90, 180, 270, 360] is: -90.0 degrees\\nThe mean angle of [10, 20, 30] is: 20.0 degrees\\n>>> "
"Python","Averages/Mean_time_of_day","A particular activity of bats occurs at these times of the day:\\nUsing the idea that there are twenty-four hours in a day,\\nwhich is analogous to there being 360 degrees in a circle,\\nmap times of day to and from angles;\\nand using the ideas of Averages/Mean angle\\ncompute and show the average time of the nocturnal activity\\nto an accuracy of one second of time.\\n","from cmath import rect, phase\\nfrom math import radians, degrees\\n\\n\\ndef mean_angle(deg):\\n    return degrees(phase(sum(rect(1, radians(d)) for d in deg)/len(deg)))\\n\\ndef mean_time(times):\\n    t = (time.split(':') for time in times)\\n    seconds = ((float(s) + int(m) * 60 + int(h) * 3600) \\n               for h, m, s in t)\\n    day = 24 * 60 * 60\\n    to_angles = [s * 360. / day for s in seconds]\\n    mean_as_angle = mean_angle(to_angles)\\n    mean_seconds = mean_as_angle * day / 360.\\n    if mean_seconds < 0:\\n        mean_seconds += day\\n    h, m = divmod(mean_seconds, 3600)\\n    m, s = divmod(m, 60)\\n    return '%02i:%02i:%02i' % (h, m, s)\\n\\n\\nif __name__ == '__main__':\\n    print( mean_time([\""23:00:17\"", \""23:40:20\"", \""00:12:45\"", \""00:17:19\""]) )"
"Python","Averages/Median","Write a program to find the   median   value of a vector of floating-point numbers.\\nThe program need not handle the case where the vector is empty, but must handle the case where there are an even number of elements.   In that case, return the average of the two middle values.\\nThere are several approaches to this.   One is to sort the elements, and then pick the element(s) in the middle.\\nSorting would take at least   O(n logn).   Another approach would be to build a priority queue from the elements, and then extract half of the elements to get to the middle element(s).   This would also take   O(n logn).   The best solution is to use the   selection algorithm   to find the median in   O(n)   time.\\nQuickselect_algorithm\\n","def median(aray):\\n    srtd = sorted(aray)\\n    alen = len(srtd)\\n    return 0.5*( srtd[(alen-1)//2] + srtd[alen//2])\\n\\na = (4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2)\\nprint a, median(a)\\na = (4.1, 7.2, 1.7, 9.3, 4.4, 3.2)\\nprint a, median(a)"
"Python","Averages/Mode","Write a program to find the mode value of a collection.\\nThe case where the collection is empty may be ignored. Care must be taken to handle the case where the mode is non-unique.\\nIf it is not appropriate or possible to support a general collection, use a vector (array), if possible. If it is not appropriate or possible to support an unspecified value type, use integers.\\n",">>> from collections import defaultdict\\n>>> def modes(values):\\n	count = defaultdict(int)\\n	for v in values:\\n		count[v] +=1\\n	best = max(count.values())\\n	return [k for k,v in count.items() if v == best]\\n\\n>>> modes([1,3,6,6,6,6,7,7,12,12,17])\\n[6]\\n>>> modes((1,1,2,4,4))\\n[1, 4]"
"Python","Averages/Mode","Write a program to find the mode value of a collection.\\nThe case where the collection is empty may be ignored. Care must be taken to handle the case where the mode is non-unique.\\nIf it is not appropriate or possible to support a general collection, use a vector (array), if possible. If it is not appropriate or possible to support an unspecified value type, use integers.\\n",">>> from collections import Counter\\n>>> def modes(values):\\n	count = Counter(values)\\n	best = max(count.values())\\n	return [k for k,v in count.items() if v == best]\\n\\n>>> modes([1,3,6,6,6,6,7,7,12,12,17])\\n[6]\\n>>> modes((1,1,2,4,4))\\n[1, 4]"
"Python","Averages/Mode","Write a program to find the mode value of a collection.\\nThe case where the collection is empty may be ignored. Care must be taken to handle the case where the mode is non-unique.\\nIf it is not appropriate or possible to support a general collection, use a vector (array), if possible. If it is not appropriate or possible to support an unspecified value type, use integers.\\n","def onemode(values):\\n    return max(set(values), key=values.count)"
"Python","Averages/Pythagorean_means","Compute all three of the Pythagorean means of the set of integers 1 through 10 (inclusive).\\nShow that \\n\\n\\n\\nA\\n(\\n\\nx\\n\\n1\\n\\n\\n,\\n…\\n,\\n\\nx\\n\\nn\\n\\n\\n)\\n≥\\nG\\n(\\n\\nx\\n\\n1\\n\\n\\n,\\n…\\n,\\n\\nx\\n\\nn\\n\\n\\n)\\n≥\\nH\\n(\\n\\nx\\n\\n1\\n\\n\\n,\\n…\\n,\\n\\nx\\n\\nn\\n\\n\\n)\\n\\n\\n{\\displaystyle A(x_{1},\\ldots ,x_{n})\\geq G(x_{1},\\ldots ,x_{n})\\geq H(x_{1},\\ldots ,x_{n})}\\n\\n for this set of positive integers.\\n\\n","from operator import mul\\nfrom functools import reduce\\n\\ndef amean(num):\\n	return sum(num)/len(num)\\n\\ndef gmean(num):\\n	return reduce(mul, num, 1)**(1/len(num))\\n\\ndef hmean(num):\\n	return len(num)/sum(1/n for n in num)\\n\\nnumbers = range(1,11) # 1..10\\na, g, h = amean(numbers), gmean(numbers), hmean(numbers)\\nprint(a, g, h)\\nassert( a >= g >= h )\\n"
"Python","Averages/Root_mean_square","Compute the   Root mean square   of the numbers 1..10.\\n\\nThe   root mean square   is also known by its initials RMS (or rms), and as the quadratic mean.\\nThe RMS is calculated as the mean of the squares of the numbers, square-rooted:\\n\\n\\n",">>> from math import sqrt\\n>>> def qmean(num):\\n	return sqrt(sum(n*n for n in num)/len(num))\\n\\n>>> qmean(range(1,11))\\n6.2048368229954285"
"Python","Averages/Root_mean_square","Compute the   Root mean square   of the numbers 1..10.\\n\\nThe   root mean square   is also known by its initials RMS (or rms), and as the quadratic mean.\\nThe RMS is calculated as the mean of the squares of the numbers, square-rooted:\\n\\n\\n","from functools import (reduce)\\nfrom math import (sqrt)\\n\\n\\n# rootMeanSquare :: [Num] -> Float\\ndef rootMeanSquare(xs):\\n    return sqrt(reduce(lambda a, x: a + x * x, xs, 0) / len(xs))\\n\\n\\nprint(\\n    rootMeanSquare([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\\n)"
"Python","Averages/Simple_moving_average","Computing the simple moving average of a series of numbers.\\nCreate a stateful function/class/instance that takes a period and returns a routine that takes a number as argument and returns a simple moving average of its arguments so far.\\nA simple moving average is a method for computing an average of a stream of numbers by only averaging the last   P   numbers from the stream,   where   P   is known as the period.\\nIt can be implemented by calling an initialing routine with   P   as its argument,   I(P),   which should then return a routine that when called with individual, successive members of a stream of numbers, computes the mean of (up to), the last   P   of them, lets call this   SMA().\\nThe word   stateful   in the task description refers to the need for   SMA()   to remember certain information between calls to it:\\n\\nStateful   also means that successive calls to   I(),   the initializer,   should return separate routines that do   not   share saved state so they could be used on two independent streams of data.\\nPseudo-code for an implementation of   SMA   is:\\n","from collections import deque\\n\\ndef simplemovingaverage(period):\\n    assert period == int(period) and period > 0, \""Period must be an integer >0\""\\n    \\n    summ = n = 0.0\\n    values = deque([0.0] * period)     # old value queue\\n\\n    def sma(x):\\n        nonlocal summ, n\\n        \\n        values.append(x)\\n        summ += x - values.popleft()\\n        n = min(n+1, period)\\n        return summ / n\\n\\n    return sma"
"Python","Averages/Simple_moving_average","Computing the simple moving average of a series of numbers.\\nCreate a stateful function/class/instance that takes a period and returns a routine that takes a number as argument and returns a simple moving average of its arguments so far.\\nA simple moving average is a method for computing an average of a stream of numbers by only averaging the last   P   numbers from the stream,   where   P   is known as the period.\\nIt can be implemented by calling an initialing routine with   P   as its argument,   I(P),   which should then return a routine that when called with individual, successive members of a stream of numbers, computes the mean of (up to), the last   P   of them, lets call this   SMA().\\nThe word   stateful   in the task description refers to the need for   SMA()   to remember certain information between calls to it:\\n\\nStateful   also means that successive calls to   I(),   the initializer,   should return separate routines that do   not   share saved state so they could be used on two independent streams of data.\\nPseudo-code for an implementation of   SMA   is:\\n","from collections import deque\\n\\nclass Simplemovingaverage():\\n    def __init__(self, period):\\n        assert period == int(period) and period > 0, \""Period must be an integer >0\""\\n        self.period = period\\n        self.stream = deque()\\n        \\n    def __call__(self, n):\\n        stream = self.stream\\n        stream.append(n)    # appends on the right\\n        streamlength = len(stream)\\n        if streamlength > self.period:\\n            stream.popleft()\\n            streamlength -= 1\\n        if streamlength == 0:\\n            average = 0\\n        else:\\n            average = sum( stream ) / streamlength\\n\\n        return average"
"Python","Averages/Simple_moving_average","Computing the simple moving average of a series of numbers.\\nCreate a stateful function/class/instance that takes a period and returns a routine that takes a number as argument and returns a simple moving average of its arguments so far.\\nA simple moving average is a method for computing an average of a stream of numbers by only averaging the last   P   numbers from the stream,   where   P   is known as the period.\\nIt can be implemented by calling an initialing routine with   P   as its argument,   I(P),   which should then return a routine that when called with individual, successive members of a stream of numbers, computes the mean of (up to), the last   P   of them, lets call this   SMA().\\nThe word   stateful   in the task description refers to the need for   SMA()   to remember certain information between calls to it:\\n\\nStateful   also means that successive calls to   I(),   the initializer,   should return separate routines that do   not   share saved state so they could be used on two independent streams of data.\\nPseudo-code for an implementation of   SMA   is:\\n","if __name__ == '__main__':\\n    for period in [3, 5]:\\n        print (\""\\nSIMPLE MOVING AVERAGE (procedural): PERIOD =\"", period)\\n        sma = simplemovingaverage(period)\\n        for i in range(1,6):\\n            print (\""  Next number = %-2g, SMA = %g \"" % (i, sma(i)))\\n        for i in range(5, 0, -1):\\n            print (\""  Next number = %-2g, SMA = %g \"" % (i, sma(i)))\\n    for period in [3, 5]:\\n        print (\""\\nSIMPLE MOVING AVERAGE (class based): PERIOD =\"", period)\\n        sma = Simplemovingaverage(period)\\n        for i in range(1,6):\\n            print (\""  Next number = %-2g, SMA = %g \"" % (i, sma(i)))\\n        for i in range(5, 0, -1):\\n            print (\""  Next number = %-2g, SMA = %g \"" % (i, sma(i)))"
"Python","AVL_tree","\\nIn computer science, an AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; at no time do they differ by more than one because rebalancing is done ensure this is the case. Lookup, insertion, and deletion all take O(log n) time in both the average and worst cases, where n is the number of nodes in the tree prior to the operation. Insertions and deletions may require the tree to be rebalanced by one or more tree rotations.\\nAVL trees are often compared with red-black trees because they support the same set of operations and because red-black trees also take O(log n) time for the basic operations. Because AVL trees are more rigidly balanced, they are faster than red-black trees for lookup-intensive applications. Similar to red-black trees, AVL trees are height-balanced, but in general not weight-balanced nor μ-balanced; that is, sibling nodes can have hugely differing numbers of descendants.\\n\\nImplement an AVL tree in the language of choice, and provide at least basic operations.\\n\\nThis implementation uses the type system to enforce the height invariants, though not the BST invariants\\nSee AVL tree/C\\nSee AVL_tree/C_sharp.\\n","\\n\""\""\""\\n\\nPython AVL tree example based on \\n\\nhttps://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/lec06_code.zip\\n\\nSimplified for Rosetta Code example.\\n\\nSee also:\\n\\nhttps://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/MIT6_006F11_lec06_orig.pdf\\n\\nhttps://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/lecture-6-avl-trees-avl-sort/\\n\\n\""\""\""\\n\\nclass AVLNode(object):\\n    \""\""\""A node in the AVL tree.\""\""\""\\n    \\n    def __init__(self, parent, k):\\n        \""\""\""Creates a node.\\n        \\n        Args:\\n            parent: The node's parent.\\n            k: key of the node.\\n        \""\""\""\\n        self.key = k\\n        self.parent = parent\\n        self.left = None\\n        self.right = None\\n  \\n    def _str(self):\\n        \""\""\""Internal method for ASCII art.\""\""\""\\n        label = str(self.key)\\n        if self.left is None:\\n            left_lines, left_pos, left_width = [], 0, 0\\n        else:\\n            left_lines, left_pos, left_width = self.left._str()\\n        if self.right is None:\\n            right_lines, right_pos, right_width = [], 0, 0\\n        else:\\n            right_lines, right_pos, right_width = self.right._str()\\n        middle = max(right_pos + left_width - left_pos + 1, len(label), 2)\\n        pos = left_pos + middle // 2\\n        width = left_pos + middle + right_width - right_pos\\n        while len(left_lines) < len(right_lines):\\n            left_lines.append(' ' * left_width)\\n        while len(right_lines) < len(left_lines):\\n            right_lines.append(' ' * right_width)\\n        if (middle - len(label)) % 2 == 1 and self.parent is not None and \\\\n           self is self.parent.left and len(label) < middle:\\n            label += '.'\\n        label = label.center(middle, '.')\\n        if label[0] == '.': label = ' ' + label[1:]\\n        if label[-1] == '.': label = label[:-1] + ' '\\n        lines = [' ' * left_pos + label + ' ' * (right_width - right_pos),\\n                 ' ' * left_pos + '/' + ' ' * (middle-2) +\\n                 '\\\\' + ' ' * (right_width - right_pos)] + \\\\n          [left_line + ' ' * (width - left_width - right_width) + right_line\\n           for left_line, right_line in zip(left_lines, right_lines)]\\n        return lines, pos, width\\n        \\n    def __str__(self):\\n        return '\\n'.join(self._str()[0])\\n\\n    def find(self, k):\\n        \""\""\""Finds and returns the node with key k from the subtree rooted at this \\n        node.\\n        \\n        Args:\\n            k: The key of the node we want to find.\\n        \\n        Returns:\\n            The node with key k.\\n        \""\""\""\\n        if k == self.key:\\n            return self\\n        elif k < self.key:\\n            if self.left is None:\\n                return None\\n            else:\\n                return self.left.find(k)\\n        else:\\n            if self.right is None:  \\n                return None\\n            else:\\n                return self.right.find(k)\\n    \\n    def find_min(self):\\n        \""\""\""Finds the node with the minimum key in the subtree rooted at this \\n        node.\\n        \\n        Returns:\\n            The node with the minimum key.\\n        \""\""\""\\n        current = self\\n        while current.left is not None:\\n            current = current.left\\n        return current\\n       \\n    def next_larger(self):\\n        \""\""\""Returns the node with the next larger key (the successor) in the BST.\\n        \""\""\""\\n        if self.right is not None:\\n            return self.right.find_min()\\n        current = self\\n        while current.parent is not None and current is current.parent.right:\\n            current = current.parent\\n        return current.parent\\n\\n    def insert(self, node):\\n        \""\""\""Inserts a node into the subtree rooted at this node.\\n        \\n        Args:\\n            node: The node to be inserted.\\n        \""\""\""\\n        if node is None:\\n            return\\n        if node.key < self.key:\\n            if self.left is None:\\n                node.parent = self\\n                self.left = node\\n            else:\\n                self.left.insert(node)\\n        else:\\n            if self.right is None:\\n                node.parent = self\\n                self.right = node\\n            else:\\n                self.right.insert(node)\\n  \\n    def delete(self):\\n        \""\""\""Deletes and returns this node from the tree.\""\""\""\\n        if self.left is None or self.right is None:\\n            if self is self.parent.left:\\n                self.parent.left = self.left or self.right\\n                if self.parent.left is not None:\\n                    self.parent.left.parent = self.parent\\n            else:\\n                self.parent.right = self.left or self.right\\n                if self.parent.right is not None:\\n                    self.parent.right.parent = self.parent\\n            return self\\n        else:\\n            s = self.next_larger()\\n            self.key, s.key = s.key, self.key\\n            return s.delete()\\n\\ndef height(node):\\n    if node is None:\\n        return -1\\n    else:\\n        return node.height\\n\\ndef update_height(node):\\n    node.height = max(height(node.left), height(node.right)) + 1\\n\\nclass AVL(object):\\n    \""\""\""\\n    AVL binary search tree implementation.\\n    \""\""\""\\n    \\n    def __init__(self):\\n        \""\""\"" empty tree \""\""\""\\n        self.root = None\\n    \\n    def __str__(self):\\n        if self.root is None: return ''\\n        return str(self.root)\\n\\n    def find(self, k):\\n        \""\""\""Finds and returns the node with key k from the subtree rooted at this \\n        node.\\n        \\n        Args:\\n            k: The key of the node we want to find.\\n        \\n        Returns:\\n            The node with key k or None if the tree is empty.\\n        \""\""\""\\n        return self.root and self.root.find(k)\\n                \\n    def find_min(self):\\n        \""\""\""Returns the minimum node of this BST.\""\""\""\\n        \\n        return self.root and self.root.find_min()\\n    \\n    def next_larger(self, k):\\n        \""\""\""Returns the node that contains the next larger (the successor) key in\\n        the BST in relation to the node with key k.\\n        \\n        Args:\\n            k: The key of the node of which the successor is to be found.\\n            \\n        Returns:\\n            The successor node.\\n        \""\""\""\\n        node = self.find(k)\\n        return node and node.next_larger()   \\n\\n    def left_rotate(self, x):\\n        y = x.right\\n        y.parent = x.parent\\n        if y.parent is None:\\n            self.root = y\\n        else:\\n            if y.parent.left is x:\\n                y.parent.left = y\\n            elif y.parent.right is x:\\n                y.parent.right = y\\n        x.right = y.left\\n        if x.right is not None:\\n            x.right.parent = x\\n        y.left = x\\n        x.parent = y\\n        update_height(x)\\n        update_height(y)\\n\\n    def right_rotate(self, x):\\n        y = x.left\\n        y.parent = x.parent\\n        if y.parent is None:\\n            self.root = y\\n        else:\\n            if y.parent.left is x:\\n                y.parent.left = y\\n            elif y.parent.right is x:\\n                y.parent.right = y\\n        x.left = y.right\\n        if x.left is not None:\\n            x.left.parent = x\\n        y.right = x\\n        x.parent = y\\n        update_height(x)\\n        update_height(y)\\n\\n    def rebalance(self, node):\\n        while node is not None:\\n            update_height(node)\\n            if height(node.left) >= 2 + height(node.right):\\n                if height(node.left.left) >= height(node.left.right):\\n                    self.right_rotate(node)\\n                else:\\n                    self.left_rotate(node.left)\\n                    self.right_rotate(node)\\n            elif height(node.right) >= 2 + height(node.left):\\n                if height(node.right.right) >= height(node.right.left):\\n                    self.left_rotate(node)\\n                else:\\n                    self.right_rotate(node.right)\\n                    self.left_rotate(node)\\n            node = node.parent\\n\\n    def insert(self, k):\\n        \""\""\""Inserts a node with key k into the subtree rooted at this node.\\n        This AVL version guarantees the balance property: h = O(lg n).\\n        \\n        Args:\\n            k: The key of the node to be inserted.\\n        \""\""\""\\n        node = AVLNode(None, k)\\n        if self.root is None:\\n            # The root's parent is None.\\n            self.root = node\\n        else:\\n            self.root.insert(node)\\n        self.rebalance(node)\\n\\n    def delete(self, k):\\n        \""\""\""Deletes and returns a node with key k if it exists from the BST.\\n        This AVL version guarantees the balance property: h = O(lg n).\\n        \\n        Args:\\n            k: The key of the node that we want to delete.\\n            \\n        Returns:\\n            The deleted node with key k.\\n        \""\""\""\\n        node = self.find(k)\\n        if node is None:\\n            return None\\n        if node is self.root:\\n            pseudoroot = AVLNode(None, 0)\\n            pseudoroot.left = self.root\\n            self.root.parent = pseudoroot\\n            deleted = self.root.delete()\\n            self.root = pseudoroot.left\\n            if self.root is not None:\\n                self.root.parent = None\\n        else:\\n            deleted = node.delete()   \\n        ## node.parent is actually the old parent of the node,\\n        ## which is the first potentially out-of-balance node.\\n        self.rebalance(deleted.parent)\\n\\ndef test(args=None):\\n    import random, sys\\n    if not args:\\n        args = sys.argv[1:]\\n    if not args:\\n        print('usage: %s ' % \\\\n              sys.argv[0])\\n        sys.exit()\\n    elif len(args) == 1:\\n        items = (random.randrange(100) for i in range(int(args[0])))\\n    else:\\n        items = [int(i) for i in args]\\n\\n    tree = AVL()\\n    print(tree)\\n    for item in items:\\n        tree.insert(item)\\n        print()\\n        print(tree)\\n\\nif __name__ == '__main__': test()\\n"
"Python","Babbage_problem","Charles Babbage, looking ahead to the sorts of problems his Analytical Engine would be able to solve, gave this example:\\nHe thought the answer might be 99,736, whose square is 9,947,269,696; but he couldn't be certain.\\n\\nThe task is to find out if Babbage had the right answer — and to do so, as far as your language allows it, in code that Babbage himself would have been able to read and understand.\\nAs Babbage evidently solved the task with pencil and paper, a similar efficient solution is preferred.\\nFor these purposes, Charles Babbage may be taken to be an intelligent person, familiar with mathematics and with the idea of a computer; he has written the first drafts of simple computer programmes in tabular form. [Babbage Archive Series L].\\n\\nThe aim of the task is to write a program that is sufficiently clear and well-documented for such a person to be able to read it and be confident that it does indeed solve the specified problem.\\n\\nAn assembler program always seems a bit tricky for non system engineer because it deals directly with the operating system and with the hardware instructions. Here we have a 32-bit computer with 16 32-bit registers. The caller (the operating system to keep it simple) is calling you giving your location address stored in register-15 and has stored in register-14 his return address. To save each program context, register-13 points to a 18 word save area. Do not spend time in understanding the context saving and restoring in the prologue and epilogue part of the program. What you have to know, “360” architecture uses 32-bit signed binary arithmetic, so here the maximum integer value is 2^31-1 (2147483647). Therefore the solution must be less than 2147483647. The multiplication and the division use a pair of registers; coding “MR 4,2” means multiply register-5 by register-2 and place result in the (register-4,register-5) pair; the same way “DR 4,2” means divide the (register-4,register-5) pair by register-2 and place the quotient in register-5 and the reminder in register-4. We use in the below program this intermediate 64-bit integers to find a solution with a value up to 2^31-1 even when we have to compute the square of this value.\\n","\\n# Lines that start by # are a comments:\\n# they will be ignored by the machine\\n\\nn=0 # n is a variable and its value is 0\\n\\n# we will increase its value by one until\\n# its square ends in 269,696\\n\\nwhile n**2 % 1000000 != 269696:\\n\\n    # n**2 -> n squared\\n    # %    -> 'modulo' or remainer after division\\n    # !=   -> not equal to\\n    \\n    n += 1 # += -> increase by a certain number\\n\\nprint(n) # prints n\\n\\n# short version\\n>>> [x for x in range(30000) if (x*x) % 1000000 == 269696] [0]\\n25264\\n"
"Python","Babbage_problem","Charles Babbage, looking ahead to the sorts of problems his Analytical Engine would be able to solve, gave this example:\\nHe thought the answer might be 99,736, whose square is 9,947,269,696; but he couldn't be certain.\\n\\nThe task is to find out if Babbage had the right answer — and to do so, as far as your language allows it, in code that Babbage himself would have been able to read and understand.\\nAs Babbage evidently solved the task with pencil and paper, a similar efficient solution is preferred.\\nFor these purposes, Charles Babbage may be taken to be an intelligent person, familiar with mathematics and with the idea of a computer; he has written the first drafts of simple computer programmes in tabular form. [Babbage Archive Series L].\\n\\nThe aim of the task is to write a program that is sufficiently clear and well-documented for such a person to be able to read it and be confident that it does indeed solve the specified problem.\\n\\nAn assembler program always seems a bit tricky for non system engineer because it deals directly with the operating system and with the hardware instructions. Here we have a 32-bit computer with 16 32-bit registers. The caller (the operating system to keep it simple) is calling you giving your location address stored in register-15 and has stored in register-14 his return address. To save each program context, register-13 points to a 18 word save area. Do not spend time in understanding the context saving and restoring in the prologue and epilogue part of the program. What you have to know, “360” architecture uses 32-bit signed binary arithmetic, so here the maximum integer value is 2^31-1 (2147483647). Therefore the solution must be less than 2147483647. The multiplication and the division use a pair of registers; coding “MR 4,2” means multiply register-5 by register-2 and place result in the (register-4,register-5) pair; the same way “DR 4,2” means divide the (register-4,register-5) pair by register-2 and place the quotient in register-5 and the reminder in register-4. We use in the below program this intermediate 64-bit integers to find a solution with a value up to 2^31-1 even when we have to compute the square of this value.\\n","from math import (floor, sqrt)\\nfrom itertools import (islice)\\n\\n\\n# main :: IO ()\\ndef main():\\n    for b in take(10)(squaresWithSuffix(269696)):\\n        print (\\n            f'{int(sqrt(b))}^2 -> {b}'\\n        )\\n\\n\\n# squaresWithSuffix :: Int -> Gen [Int]\\ndef squaresWithSuffix(n):\\n    stem = 10 ** len(str(n))\\n    i = 0\\n    while True:\\n        i = until(lambda x: isPerfectSquare(n + (stem * x)))(\\n            succ\\n        )(i)\\n        yield n + (stem * i)\\n        i = succ(i)\\n\\n\\n# isPerfectSquare :: Int -> Bool\\ndef isPerfectSquare(n):\\n    r = sqrt(n)\\n    return r == floor(r)\\n\\n\\n# GENERIC ABSTRACTIONS ------------------------------------\\n\\n\\n# succ :: Enum a => a -> a\\n# succ :: Int -> Int\\ndef succ(x):\\n    return 1 + x\\n\\n\\n# take :: Int -> [a] -> [a]\\n# take :: Int -> String -> String\\ndef take(n):\\n    return lambda xs: (\\n        xs[0:n]\\n        if isinstance(xs, list)\\n        else list(islice(xs, n))\\n    )\\n\\n\\n# until :: (a -> Bool) -> (a -> a) -> a -> a\\ndef until(p):\\n    def go(f, x):\\n        v = x\\n        while not p(v):\\n            v = f(v)\\n        return v\\n    return lambda f: lambda x: go(f, x)\\n\\n\\n# MAIN ---\\nmain()"
"Python","Bacon_cipher","This task is to implement a program for encryption and decryption of plaintext using the simple alphabet of the Baconian cipher or some other kind of representation of this alphabet (make anything signify anything).\\nThe Baconian alphabet:\\n\\nTested with Agena 2.9.5 Win32\\n","import string\\n\\nsometext = \""\""\""All children, except one, grow up. They soon know that they will grow\\nup, and the way Wendy knew was this. One day when she was two years old\\nshe was playing in a garden, and she plucked another flower and ran with\\nit to her mother. I suppose she must have looked rather delightful, for\\nMrs. Darling put her hand to her heart and cried, \""Oh, why can't you\\nremain like this for ever!\"" This was all that passed between them on\\nthe subject, but henceforth Wendy knew that she must grow up. You always\\nknow after you are two. Two is the beginning of the end.\\n\\nOf course they lived at 14 [their house number on their street], and\\nuntil Wendy came her mother was the chief one. She was a lovely lady,\\nwith a romantic mind and such a sweet mocking mouth. Her romantic\\nmind was like the tiny boxes, one within the other, that come from the\\npuzzling East, however many you discover there is always one more; and\\nher sweet mocking mouth had one kiss on it that Wendy could never get,\\nthough there it was, perfectly conspicuous in the right-hand corner.\""\""\"".lower()\\n\\nlc2bin = {ch: '{:05b}'.format(i) \\n          for i, ch in enumerate(string.ascii_lowercase + ' .')}\\nbin2lc = {val: key for key, val in lc2bin.items()}\\n\\nphrase = 'Rosetta code Bacon cipher example secret phrase to encode in the capitalisation of peter pan'.lower()\\n\\ndef to_5binary(msg):\\n    return ( ch == '1' for ch in ''.join(lc2bin.get(ch, '') for ch in msg.lower()))\\n\\ndef encrypt(message, text):\\n    bin5 = to_5binary(message)\\n    textlist = list(text.lower())\\n    out = []\\n    for capitalise in bin5:\\n        while textlist:\\n            ch = textlist.pop(0)\\n            if ch.isalpha():\\n                if capitalise:\\n                    ch = ch.upper()\\n                out.append(ch)\\n                break\\n            else:\\n                out.append(ch)\\n        else:\\n            raise Exception('ERROR: Ran out of characters in sometext')\\n    return ''.join(out) + '...'\\n\\n\\ndef  decrypt(bacontext):\\n    binary = []\\n    bin5 = []\\n    out = []\\n    for ch in bacontext:\\n        if ch.isalpha():\\n            binary.append('1' if ch.isupper() else '0')\\n            if len(binary) == 5:\\n                bin5 = ''.join(binary)\\n                out.append(bin2lc[bin5])\\n                binary = []\\n    return ''.join(out)\\n                \\n\\nprint('PLAINTEXT = \\n%s\\n' % phrase)\\nencrypted = encrypt(phrase, sometext)\\nprint('ENCRYPTED = \\n%s\\n' % encrypted)\\ndecrypted = decrypt(encrypted)\\nprint('DECRYPTED = \\n%s\\n' % decrypted)\\nassert phrase == decrypted, 'Round-tripping error'"
"Python","Balanced_brackets","Task:\\n\\n\\n",">>> def gen(N):\\n...     txt = ['[', ']'] * N\\n...     random.shuffle( txt )\\n...     return ''.join(txt)\\n... \\n>>> def balanced(txt):\\n...     braced = 0\\n...     for ch in txt:\\n...         if ch == '[': braced += 1\\n...         if ch == ']':\\n...             braced -= 1\\n...             if braced < 0: return False\\n...     return braced == 0\\n... \\n>>> for txt in (gen(N) for N in range(10)):\\n...     print (\""%-22r is%s balanced\"" % (txt, '' if balanced(txt) else ' not'))\\n... \\n''                     is balanced\\n'[]'                   is balanced\\n'[][]'                 is balanced\\n'][[[]]'               is not balanced\\n'[]][[][]'             is not balanced\\n'[][[][]]]['           is not balanced\\n'][]][][[]][['         is not balanced\\n'[[]]]]][]][[[['       is not balanced\\n'[[[[]][]]][[][]]'     is balanced\\n'][[][[]]][]]][[[[]'   is not balanced"
"Python","Balanced_brackets","Task:\\n\\n\\n",">>> from itertools import accumulate\\n>>> from random import shuffle\\n>>> def gen(n):\\n...     txt = list('[]' * n)\\n...     shuffle(txt)\\n...     return ''.join(txt)\\n...\\n>>> def balanced(txt):\\n...     brackets = ({'[': 1, ']': -1}.get(ch, 0) for ch in txt)\\n...     return all(x>=0 for x in accumulate(brackets))\\n...\\n>>> for txt in (gen(N) for N in range(10)):\\n...     print (\""%-22r is%s balanced\"" % (txt, '' if balanced(txt) else ' not'))\\n...\\n''                     is balanced\\n']['                   is not balanced\\n'[]]['                 is not balanced\\n']][[[]'               is not balanced\\n'][[][][]'             is not balanced\\n'[[[][][]]]'           is balanced\\n'][[[][][]][]'         is not balanced\\n'][]][][[]][[]['       is not balanced\\n'][[]]][][[]][[[]'     is not balanced\\n'][[][[]]]][[[]][]['   is not balanced"
"Python","Balanced_brackets","Task:\\n\\n\\n",">>> import numpy as np\\n>>> from random import shuffle\\n>>> def gen(n):\\n...     txt = list('[]' * n)\\n...     shuffle(txt)\\n...     return ''.join(txt)\\n...\\n>>> m = np.array([{'[': 1, ']': -1}.get(chr(c), 0) for c in range(128)])\\n>>> def balanced(txt):\\n...     a = np.array(txt, 'c').view(np.uint8)\\n...     return np.all(m[a].cumsum() >= 0)\\n...\\n>>> for txt in (gen(N) for N in range(10)):\\n...     print (\""%-22r is%s balanced\"" % (txt, '' if balanced(txt) else ' not'))\\n...\\n''                     is balanced\\n']['                   is not balanced\\n'[[]]'                 is balanced\\n'[]][]['               is not balanced\\n']][]][[['             is not balanced\\n'[[]][[][]]'           is balanced\\n'[][[]][[]]]['         is not balanced\\n'[][[[]][[]]][]'       is balanced\\n'[[][][[]]][[[]]]'     is balanced\\n'][]][][[]][]][][[['   is not balanced"
"Python","Balanced_ternary","Balanced ternary is a way of representing numbers. Unlike the prevailing binary representation, a balanced ternary integer is in base 3, and each digit can have the values 1, 0, or −1.\\n\\nDecimal 11 = 32 + 31 − 30, thus it can be written as \""++−\""\\nDecimal 6 = 32 − 31 + 0 × 30, thus it can be written as \""+−0\""\\n\\nImplement balanced ternary representation of integers with the following:\\n\\nTest case With balanced ternaries a from string \""+-0++0+\"", b from native integer -436, c \""+-++-\"":\\n\\nNote: The pages generalised floating point addition and generalised floating point multiplication have code implementing arbitrary precision floating point balanced ternary.\\n\\nSee also:\\nSpecifications (bt.ads):\\nImplementation (bt.adb):\\nTest task requirements (testbt.adb):\\nOutput:\\nOutput:\\nOutput\\noutput:\\n","class BalancedTernary:\\n    # Represented as a list of 0, 1 or -1s, with least significant digit first.\\n\\n    str2dig = {'+': 1, '-': -1, '0': 0} # immutable\\n    dig2str = {1: '+', -1: '-', 0: '0'} # immutable\\n    table = ((0, -1), (1, -1), (-1, 0), (0, 0), (1, 0), (-1, 1), (0, 1)) # immutable\\n\\n    def __init__(self, inp):\\n        if isinstance(inp, str):\\n            self.digits = [BalancedTernary.str2dig[c] for c in reversed(inp)]\\n        elif isinstance(inp, int):\\n            self.digits = self._int2ternary(inp)\\n        elif isinstance(inp, BalancedTernary):\\n            self.digits = list(inp.digits)\\n        elif isinstance(inp, list):\\n            if all(d in (0, 1, -1) for d in inp):\\n                self.digits = list(inp)\\n            else:\\n                raise ValueError(\""BalancedTernary: Wrong input digits.\"")\\n        else:\\n            raise TypeError(\""BalancedTernary: Wrong constructor input.\"")\\n\\n    @staticmethod\\n    def _int2ternary(n):\\n        if n == 0: return []\\n        if (n % 3) == 0: return [0] + BalancedTernary._int2ternary(n // 3)\\n        if (n % 3) == 1: return [1] + BalancedTernary._int2ternary(n // 3)\\n        if (n % 3) == 2: return [-1] + BalancedTernary._int2ternary((n + 1) // 3)\\n\\n    def to_int(self):\\n        return reduce(lambda y,x: x + 3 * y, reversed(self.digits), 0)\\n\\n    def __repr__(self):\\n        if not self.digits: return \""0\""\\n        return \""\"".join(BalancedTernary.dig2str[d] for d in reversed(self.digits))\\n\\n    @staticmethod\\n    def _neg(digs):\\n        return [-d for d in digs]\\n\\n    def __neg__(self):\\n        return BalancedTernary(BalancedTernary._neg(self.digits))\\n\\n    @staticmethod\\n    def _add(a, b, c=0):\\n        if not (a and b):\\n            if c == 0:\\n                return a or b\\n            else:\\n                return BalancedTernary._add([c], a or b)\\n        else:\\n            (d, c) = BalancedTernary.table[3 + (a[0] if a else 0) + (b[0] if b else 0) + c]\\n            res = BalancedTernary._add(a[1:], b[1:], c)\\n            # trim leading zeros\\n            if res or d != 0:\\n                return [d] + res\\n            else:\\n                return res\\n\\n    def __add__(self, b):\\n        return BalancedTernary(BalancedTernary._add(self.digits, b.digits))\\n\\n    def __sub__(self, b):\\n        return self + (-b)\\n\\n    @staticmethod\\n    def _mul(a, b):\\n        if not (a and b):\\n            return []\\n        else:\\n            if   a[0] == -1: x = BalancedTernary._neg(b)\\n            elif a[0] ==  0: x = []\\n            elif a[0] ==  1: x = b\\n            else: assert False\\n            y = [0] + BalancedTernary._mul(a[1:], b)\\n            return BalancedTernary._add(x, y)\\n\\n    def __mul__(self, b):\\n        return BalancedTernary(BalancedTernary._mul(self.digits, b.digits))\\n\\n\\ndef main():\\n    a = BalancedTernary(\""+-0++0+\"")\\n    print \""a:\"", a.to_int(), a\\n\\n    b = BalancedTernary(-436)\\n    print \""b:\"", b.to_int(), b\\n\\n    c = BalancedTernary(\""+-++-\"")\\n    print \""c:\"", c.to_int(), c\\n\\n    r = a * (b - c)\\n    print \""a * (b - c):\"", r.to_int(), r\\n\\nmain()"
"Python","Barnsley_fern","A Barnsley fern is a fractal named after British mathematician Michael Barnsley and can be created using an iterated function system (IFS).\\n\\nCreate this fractal fern, using the following transformations:\\nStarting position: x = 0, y = 0\\n\\nThis implementation requires the WinBGIm library. Iteration starts from (0,0) as required by the task however before plotting the point is translated and scaled as negative co-ordinates are not supported by the graphics window, scaling is necessary as otherwise the fern is tiny even for large iterations ( > 1000000).\\nThis code uses the opticl package for generating an image and saving it as a PNG file.\\nHint: After putting a TPaintBox on the main form align it to alClient. Client width / heigth of the main form should be no less than 640 x 480.\\n","\\n\\nimport random\\nfrom PIL import Image\\n\\n\\nclass BarnsleyFern(object):\\n    def __init__(self, img_width, img_height, paint_color=(0, 150, 0),\\n                 bg_color=(255, 255, 255)):\\n        self.img_width, self.img_height = img_width, img_height\\n        self.paint_color = paint_color\\n        self.x, self.y = 0, 0\\n        self.age = 0\\n\\n        self.fern = Image.new('RGB', (img_width, img_height), bg_color)\\n        self.pix = self.fern.load()\\n        self.pix[self.scale(0, 0)] = paint_color\\n\\n    def scale(self, x, y):\\n        h = (x + 2.182)*(self.img_width - 1)/4.8378\\n        k = (9.9983 - y)*(self.img_height - 1)/9.9983\\n        return h, k\\n\\n    def transform(self, x, y):\\n        rand = random.uniform(0, 100)\\n        if rand < 1:\\n            return 0, 0.16*y\\n        elif 1 <= rand < 86:\\n            return 0.85*x + 0.04*y, -0.04*x + 0.85*y + 1.6\\n        elif 86 <= rand < 93:\\n            return 0.2*x - 0.26*y, 0.23*x + 0.22*y + 1.6\\n        else:\\n            return -0.15*x + 0.28*y, 0.26*x + 0.24*y + 0.44\\n\\n    def iterate(self, iterations):\\n        for _ in range(iterations):\\n            self.x, self.y = self.transform(self.x, self.y)\\n            self.pix[self.scale(self.x, self.y)] = self.paint_color\\n        self.age += iterations\\n\\nfern = BarnsleyFern(500, 500)\\nfern.iterate(1000000)\\nfern.fern.show()\\n\\n"
"Python","Base58Check_encoding","The popular encoding of small and medium-sized checksums is base16, that is more compact than usual base10 and is human readable... For checksums resulting in hash digests bigger than ~100 bits, the base16 is too long: base58 is shorter and (when using good alphabet) preserves secure human readability. The most popular alphabet of base58 is the variant used in bitcoin address (see Bitcoin/address validation), so it is the \""default base58 alphabet\"".\\nWrite a program that takes a checksum (resultant hash digest) integer binary representation as argument, and converts (encode it) into base58 with the standard Bitcoin alphabet — which uses an alphabet of the characters 0 .. 9, A ..Z, a .. z, but without the four characters:\\n\\nThe reference algorithm is at the Bitcoin's Base58Check page.\\n\\n","ALPHABET = \""123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\""\\n\\ndef convertToBase58(num):\\n    sb = ''\\n    while (num > 0):\\n        r = num % 58\\n        sb = sb + ALPHABET[r]\\n        num = num / 58;\\n    return sb[::-1]\\n\\ns = 25420294593250030202636073700053352635053786165627414518\\nb = convertToBase58(s)\\nprint \""%-56d -> %s\"" % (s, b)\\n\\nhash_arr = [0x61, 0x626262, 0x636363, 0x73696d706c792061206c6f6e6720737472696e67, 0x516b6fcd0f, 0xbf4f89001e670274dd, 0x572e4794, 0xecac89cad93923c02321, 0x10c8511e]\\nfor num in hash_arr:\\n    b = convertToBase58(num)\\n    print \""0x%-54x -> %s\"" % (num, b)"
"Python","Base64_encode_data","Convert an array of bytes or binary string to the base64-encoding of that string and output that value. Use the icon for Rosetta Code as the data to convert.\\n","import urllib\\nimport base64\\n\\ndata = urllib.urlopen('http://rosettacode.org/favicon.ico').read()\\nprint base64.b64encode(data)"
"Python","Bernoulli_numbers","Bernoulli numbers are used in some series expansions of several functions   (trigonometric, hyperbolic, gamma, etc.),   and are extremely important in number theory and analysis.\\nNote that there are two definitions of Bernoulli numbers;   this task will be using the modern usage   (as per   The National Institute of Standards and Technology convention).\\nThe   nth   Bernoulli number is expressed as   Bn.\\n\\n\\nThe Akiyama–Tanigawa algorithm for the \""second Bernoulli numbers\"" as taken from wikipedia is as follows:\\n\\nUses Algol 68G's LONG LONG INT which has allows for large numbers of digits.\\n","from fractions import Fraction as Fr\\n\\ndef bernoulli(n):\\n    A = [0] * (n+1)\\n    for m in range(n+1):\\n        A[m] = Fr(1, m+1)\\n        for j in range(m, 0, -1):\\n          A[j-1] = j*(A[j-1] - A[j])\\n    return A[0] # (which is Bn)\\n\\nbn = [(i, bernoulli(i)) for i in range(61)]\\nbn = [(i, b) for i,b in bn if b]\\nwidth = max(len(str(b.numerator)) for i,b in bn)\\nfor i,b in bn:\\n    print('B(%2i) = %*i/%i' % (i, width, b.numerator, b.denominator))"
"Python","Bernoulli_numbers","Bernoulli numbers are used in some series expansions of several functions   (trigonometric, hyperbolic, gamma, etc.),   and are extremely important in number theory and analysis.\\nNote that there are two definitions of Bernoulli numbers;   this task will be using the modern usage   (as per   The National Institute of Standards and Technology convention).\\nThe   nth   Bernoulli number is expressed as   Bn.\\n\\n\\nThe Akiyama–Tanigawa algorithm for the \""second Bernoulli numbers\"" as taken from wikipedia is as follows:\\n\\nUses Algol 68G's LONG LONG INT which has allows for large numbers of digits.\\n","def bernoulli2():\\n    A, m = [], 0\\n    while True:\\n        A.append(Fr(1, m+1))\\n        for j in range(m, 0, -1):\\n          A[j-1] = j*(A[j-1] - A[j])\\n        yield A[0] # (which is Bm)\\n        m += 1\\n\\nbn2 = [ix for ix in zip(range(61), bernoulli2())]\\nbn2 = [(i, b) for i,b in bn2 if b]\\nwidth = max(len(str(b.numerator)) for i,b in bn2)\\nfor i,b in bn2:\\n    print('B(%2i) = %*i/%i' % (i, width, b.numerator, b.denominator))"
"Python","Best_shuffle","Shuffle the characters of a string in such a way that as many of the character values are in a different position as possible.\\nA shuffle that produces a randomized result among the best choices is to be preferred. A deterministic approach that produces the same sequence every time is acceptable as an alternative.\\nDisplay the result as follows:\\nThe score gives the number of positions whose character value did not change.\\n\\n\\n\\n\\nOutput:\\nOutput:\\nThe Icon and Unicon program uses a simple algorithm of swapping. This is relatively easy to translate to Awk.\\nThis program has the same output as the Icon and Unicon program.\\nThe Perl 6 program (and the equivalent Ruby program) use several built-in array functions. Awk provides no array functions, except for split(). This Awk program, a translation from Perl 6, uses its own code\\nIf those built-in array functions seem strange to you, and if you can understand these for loops, then you might prefer this Awk program. This algorithm counts the letters in the string, sorts the positions, and fills the positions in order.\\nOutput:\\nThe output might change if the for (c in set) loop iterates the array in a different order.\\nOutput (varies between runs):\\nNot optimized:\\nOptimized (~100 x faster):\\nOutput:\\nThis approach is totally deterministic, and is based on the final J implementation from the talk page.\\nIn essence: we form cyclic groups of character indices where each cyclic group is guaranteed to represent each character only once (two instances of the letter 'a' must have their indices in separate groups), and then we rotate each of the cyclic groups. We then use the before/after version of these cycles to shuffle the original text. The only way a character can be repeated, here, is when a cyclic group contains only one character index, and this can only happen when more than half of the text uses that character. This is C99 code.\\nOutput:\\n","import random\\n\\ndef count(w1,wnew):\\n    return sum(c1==c2 for c1,c2 in zip(w1, wnew))\\n\\ndef best_shuffle(w):\\n    wnew = list(w)\\n    n = len(w)\\n    rangelists = (list(range(n)), list(range(n)))\\n    for r in rangelists:\\n        random.shuffle(r)\\n    rangei, rangej = rangelists\\n    for i in rangei:\\n        for j in rangej:\\n            if i != j and wnew[j] != wnew[i] and w[i] != wnew[j] and w[j] != wnew[i]:\\n                wnew[j], wnew[i] = wnew[i], wnew[j]\\n                break\\n    wnew = ''.join(wnew)\\n    return wnew, count(w, wnew)\\n\\n\\nif __name__ == '__main__':\\n    test_words = ('tree abracadabra seesaw elk grrrrrr up a ' \\n                  + 'antidisestablishmentarianism hounddogs').split()\\n    test_words += ['aardvarks are ant eaters', 'immediately', 'abba']\\n    for w in test_words:\\n        wnew, c = best_shuffle(w)\\n        print(\""%29s, %-29s ,(%i)\"" % (w, wnew, c))"
"Python","Best_shuffle","Shuffle the characters of a string in such a way that as many of the character values are in a different position as possible.\\nA shuffle that produces a randomized result among the best choices is to be preferred. A deterministic approach that produces the same sequence every time is acceptable as an alternative.\\nDisplay the result as follows:\\nThe score gives the number of positions whose character value did not change.\\n\\n\\n\\n\\nOutput:\\nOutput:\\nThe Icon and Unicon program uses a simple algorithm of swapping. This is relatively easy to translate to Awk.\\nThis program has the same output as the Icon and Unicon program.\\nThe Perl 6 program (and the equivalent Ruby program) use several built-in array functions. Awk provides no array functions, except for split(). This Awk program, a translation from Perl 6, uses its own code\\nIf those built-in array functions seem strange to you, and if you can understand these for loops, then you might prefer this Awk program. This algorithm counts the letters in the string, sorts the positions, and fills the positions in order.\\nOutput:\\nThe output might change if the for (c in set) loop iterates the array in a different order.\\nOutput (varies between runs):\\nNot optimized:\\nOptimized (~100 x faster):\\nOutput:\\nThis approach is totally deterministic, and is based on the final J implementation from the talk page.\\nIn essence: we form cyclic groups of character indices where each cyclic group is guaranteed to represent each character only once (two instances of the letter 'a' must have their indices in separate groups), and then we rotate each of the cyclic groups. We then use the before/after version of these cycles to shuffle the original text. The only way a character can be repeated, here, is when a cyclic group contains only one character index, and this can only happen when more than half of the text uses that character. This is C99 code.\\nOutput:\\n","#!/usr/bin/env python\\n\\ndef best_shuffle(s):\\n    # Count the supply of characters.\\n    from collections import defaultdict\\n    count = defaultdict(int)\\n    for c in s:\\n        count[c] += 1\\n\\n    # Shuffle the characters.\\n    r = []\\n    for x in s:\\n        # Find the best character to replace x.\\n        best = None\\n        rankb = -2\\n        for c, rankc in count.items():\\n            # Prefer characters with more supply.\\n            # (Save characters with less supply.)\\n            # Avoid identical characters.\\n            if c == x: rankc = -1\\n            if rankc > rankb:\\n                best = c\\n                rankb = rankc\\n\\n        # Add character to list. Remove it from supply.\\n        r.append(best)\\n        count[best] -= 1\\n        if count[best] >= 0: del count[best]\\n\\n    # If the final letter became stuck (as \""ababcd\"" became \""bacabd\"",\\n    # and the final \""d\"" became stuck), then fix it.\\n    i = len(s) - 1\\n    if r[i] == s[i]:\\n        for j in range(i):\\n            if r[i] != s[j] and r[j] != s[i]:\\n                r[i], r[j] = r[j], r[i]\\n                break\\n\\n    # Convert list to string. PEP 8, \""Style Guide for Python Code\"",\\n    # suggests that ''.join() is faster than + when concatenating\\n    # many strings. See http://www.python.org/dev/peps/pep-0008/\\n    r = ''.join(r)\\n\\n    score = sum(x == y for x, y in zip(r, s))\\n\\n    return (r, score)\\n\\nfor s in \""abracadabra\"", \""seesaw\"", \""elk\"", \""grrrrrr\"", \""up\"", \""a\"":\\n    shuffled, score = best_shuffle(s)\\n    print(\""%s, %s, (%d)\"" % (s, shuffled, score))"
"Python","Bilinear_interpolation","Bilinear interpolation is linear interpolation in 2 dimensions, and is typically used for image scaling and for 2D finite element analysis.\\nOpen an image file, enlarge it by 60% using bilinear interpolation, then either display the result or save the result to a file.\\nSeems to have some artifacting in the output, but the image is at least recognizable.\\nThis uses the module from the Grayscale Image task.\\n(and also just using\\ndraw.BiLinear\\nfrom the golang.org/x/image/draw pacakge).\\nFile:J bilinear interpolant.jpg\\nLet n mean shape function, C mean constants, i mean interpolant, and the three digits meaning dimensionality, number of corners, and (in base 36) the number of nodes we construct various linear and quadratic interpolants in 1, 2, and 3 dimensions as\\n","#!/bin/python\\nimport numpy as np\\nfrom scipy.misc import imread, imshow\\nfrom scipy import ndimage\\n\\ndef GetBilinearPixel(imArr, posX, posY):\\n	out = []\\n\\n	#Get integer and fractional parts of numbers\\n	modXi = int(posX)\\n	modYi = int(posY)\\n	modXf = posX - modXi\\n	modYf = posY - modYi\\n	modXiPlusOneLim = min(modXi+1,imArr.shape[1]-1)\\n	modYiPlusOneLim = min(modYi+1,imArr.shape[0]-1)\\n\\n	#Get pixels in four corners\\n	for chan in range(imArr.shape[2]):\\n		bl = imArr[modYi, modXi, chan]\\n		br = imArr[modYi, modXiPlusOneLim, chan]\\n		tl = imArr[modYiPlusOneLim, modXi, chan]\\n		tr = imArr[modYiPlusOneLim, modXiPlusOneLim, chan]\\n	\\n		#Calculate interpolation\\n		b = modXf * br + (1. - modXf) * bl\\n		t = modXf * tr + (1. - modXf) * tl\\n		pxf = modYf * t + (1. - modYf) * b\\n		out.append(int(pxf+0.5))\\n\\n	return out\\n\\nif __name__==\""__main__\"":\\n	\\n	im = imread(\""test.jpg\"", mode=\""RGB\"")\\n	enlargedShape = list(map(int, [im.shape[0]*1.6, im.shape[1]*1.6, im.shape[2]]))\\n	enlargedImg = np.empty(enlargedShape, dtype=np.uint8)\\n	rowScale = float(im.shape[0]) / float(enlargedImg.shape[0])\\n	colScale = float(im.shape[1]) / float(enlargedImg.shape[1])\\n\\n	for r in range(enlargedImg.shape[0]):\\n		for c in range(enlargedImg.shape[1]):\\n			orir = r * rowScale #Find position in original image\\n			oric = c * colScale\\n			enlargedImg[r, c] = GetBilinearPixel(im, oric, orir)\\n\\n	imshow(enlargedImg)\\n"
"Python","Binary_search","A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a \""divide and conquer\"" algorithm.\\nAs an analogy, consider the children's game \""guess a number.\"" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.\\nAs the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.\\n\\nGiven the starting point of a range, the ending point of a range, and the \""secret value\"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.\\nThere are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.\\nAll of the following code examples use an \""inclusive\"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using \""exclusive\"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):\\nThe algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the \""insertion point\"" for it (the index that the value would have if it were inserted into the array).\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nMake sure it does not have overflow bugs.\\nThe line in the pseudo-code above to calculate the mean of two integers:\\ncould produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.\\nOne way to fix it is to manually add half the range to the low number:\\nEven though this is mathematically equivalent to the above, it is not susceptible to overflow.\\nAnother way for signed integers, possibly faster, is the following:\\nwhere  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.\\n\\n\\n\\n","def binary_search(l, value):\\n    low = 0\\n    high = len(l)-1\\n    while low <= high: \\n        mid = (low+high)//2\\n        if l[mid] > value: high = mid-1\\n        elif l[mid] < value: low = mid+1\\n        else: return mid\\n    return -1"
"Python","Binary_search","A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a \""divide and conquer\"" algorithm.\\nAs an analogy, consider the children's game \""guess a number.\"" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.\\nAs the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.\\n\\nGiven the starting point of a range, the ending point of a range, and the \""secret value\"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.\\nThere are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.\\nAll of the following code examples use an \""inclusive\"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using \""exclusive\"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):\\nThe algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the \""insertion point\"" for it (the index that the value would have if it were inserted into the array).\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nMake sure it does not have overflow bugs.\\nThe line in the pseudo-code above to calculate the mean of two integers:\\ncould produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.\\nOne way to fix it is to manually add half the range to the low number:\\nEven though this is mathematically equivalent to the above, it is not susceptible to overflow.\\nAnother way for signed integers, possibly faster, is the following:\\nwhere  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.\\n\\n\\n\\n","def binary_search(l, value, low = 0, high = -1):\\n    if not l: return -1\\n    if(high == -1): high = len(l)-1\\n    if low >= high:\\n        if l[low] == value: return low\\n        else: return -1\\n    mid = (low+high)//2\\n    if l[mid] > value: return binary_search(l, value, low, mid-1)\\n    elif l[mid] < value: return binary_search(l, value, mid+1, high)\\n    else: return mid"
"Python","Binary_search","A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a \""divide and conquer\"" algorithm.\\nAs an analogy, consider the children's game \""guess a number.\"" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.\\nAs the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.\\n\\nGiven the starting point of a range, the ending point of a range, and the \""secret value\"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.\\nThere are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.\\nAll of the following code examples use an \""inclusive\"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using \""exclusive\"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):\\nThe algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the \""insertion point\"" for it (the index that the value would have if it were inserted into the array).\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nMake sure it does not have overflow bugs.\\nThe line in the pseudo-code above to calculate the mean of two integers:\\ncould produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.\\nOne way to fix it is to manually add half the range to the low number:\\nEven though this is mathematically equivalent to the above, it is not susceptible to overflow.\\nAnother way for signed integers, possibly faster, is the following:\\nwhere  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.\\n\\n\\n\\n","index = bisect.bisect_left(list, item) # leftmost insertion point\\nindex = bisect.bisect_right(list, item) # rightmost insertion point\\nindex = bisect.bisect(list, item) # same as bisect_right\\n\\n# same as above but actually insert the item into the list at the given place:\\nbisect.insort_left(list, item)\\nbisect.insort_right(list, item)\\nbisect.insort(list, item)"
"Python","Binary_search","A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a \""divide and conquer\"" algorithm.\\nAs an analogy, consider the children's game \""guess a number.\"" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.\\nAs the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.\\n\\nGiven the starting point of a range, the ending point of a range, and the \""secret value\"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.\\nThere are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.\\nAll of the following code examples use an \""inclusive\"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using \""exclusive\"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):\\nThe algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the \""insertion point\"" for it (the index that the value would have if it were inserted into the array).\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nMake sure it does not have overflow bugs.\\nThe line in the pseudo-code above to calculate the mean of two integers:\\ncould produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.\\nOne way to fix it is to manually add half the range to the low number:\\nEven though this is mathematically equivalent to the above, it is not susceptible to overflow.\\nAnother way for signed integers, possibly faster, is the following:\\nwhere  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.\\n\\n\\n\\n","from bisect import bisect_left\\n\\ndef binary_search(a, x, lo=0, hi=None):   # can't use a to specify default for hi\\n    hi = hi if hi is not None else len(a) # hi defaults to len(a)   \\n    pos = bisect_left(a,x,lo,hi)          # find insertion position\\n    return (pos if pos != hi and a[pos] == x else -1) # don't walk off the end"
"Python","Binary_search","A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a \""divide and conquer\"" algorithm.\\nAs an analogy, consider the children's game \""guess a number.\"" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.\\nAs the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.\\n\\nGiven the starting point of a range, the ending point of a range, and the \""secret value\"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.\\nThere are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.\\nAll of the following code examples use an \""inclusive\"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using \""exclusive\"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):\\nThe algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the \""insertion point\"" for it (the index that the value would have if it were inserted into the array).\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nThe following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.\\nRecursive Pseudocode:\\nIterative Pseudocode:\\nMake sure it does not have overflow bugs.\\nThe line in the pseudo-code above to calculate the mean of two integers:\\ncould produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.\\nOne way to fix it is to manually add half the range to the low number:\\nEven though this is mathematically equivalent to the above, it is not susceptible to overflow.\\nAnother way for signed integers, possibly faster, is the following:\\nwhere  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.\\n\\n\\n\\n","def binary_search(l, value):\\n    low = 0\\n    high = len(l)-1\\n    while low + 1 < high:\\n        mid = (low+high)//2\\n        if l[mid] > value:\\n            high = mid\\n        elif l[mid] < value:\\n            low = mid\\n        else:\\n            return mid\\n    return high if abs(l[high] - value) < abs(l[low] - value) else low"
"Python","Binary_strings","Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks.\\nThis task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them. If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language.\\nIn particular the functions you need to create are:\\n\\nPossible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.\\n\\nAda has native support for single dimensioned arrays, which provide all specified operations. String is a case of array. The array of bytes is predefined in Ada in the package System.Storage_Elements (LRM 13.7.1). Storage_Element is substitute for byte.\\nStorage_Array is \""binary string\"" used for memory representation. For stream-oriented I/O communication Ada provides alternative \""binary string\"" called Stream_Element_Array (LRM 13.13.1). When dealing with octets of bits, programmers are encouraged to provide a data type of their own to ensure that the byte is exactly 8 bits length. For example:\\nAlternatively:\\nNote that all of these types will have all operations described above.\\nOutput:\\nOutput:\\nString creation (garbage collection will handle its destruction)\\nusing the string as an atom and casting a character list to a string\\nString assignment\\ncomparing two string\\ncopy a string\\nstring replacement isn't covered by the ansi standard probably best to use (replace-all) or cl-ppcre\\n\\njoining strings works in the same way as appending bytes\\nBlackBox Component Builder\\nExecute: ^Q NpctBinaryString.Do\\nOutput:\\nDéjà Vu has a blob type, which is much like Python 3's bytearray. They are used for dealing with binary data in the standard library, and works basically like a list, except it can only have integer numbers from 0 to 255 as elements, pushing and popping is not supported, and can be resized to any size in a single step.\\n(Since the task is not a specific program, the code here consists of example REPL sessions, not a whole program.)\\nIn E, binary data is represented as ELists (implemented as arrays or ropes) of integers; a String is strictly a character string. ELists come in Flex (mutable) and Const (immutable) varieties.\\nTo work with binary strings we must first have a byte type; this is a place where E shows its Java roots (to be fixed).\\nAs E is a memory-safe garbage-collected language there is no explicit destruction. It is good practice to work with immutable ConstLists when reasonable, however; especially when passing strings around.\\nNote: Elixir data types are immutable.\\n","s1 = \""A 'string' literal \\n\""\\ns2 = 'You may use any of \\' or \"" as delimiter'\\ns3 = \""\""\""This text \\n   goes over several lines\\n       up to the closing triple quote\""\""\"""
"Python","Binary_strings","Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks.\\nThis task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them. If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language.\\nIn particular the functions you need to create are:\\n\\nPossible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.\\n\\nAda has native support for single dimensioned arrays, which provide all specified operations. String is a case of array. The array of bytes is predefined in Ada in the package System.Storage_Elements (LRM 13.7.1). Storage_Element is substitute for byte.\\nStorage_Array is \""binary string\"" used for memory representation. For stream-oriented I/O communication Ada provides alternative \""binary string\"" called Stream_Element_Array (LRM 13.13.1). When dealing with octets of bits, programmers are encouraged to provide a data type of their own to ensure that the byte is exactly 8 bits length. For example:\\nAlternatively:\\nNote that all of these types will have all operations described above.\\nOutput:\\nOutput:\\nString creation (garbage collection will handle its destruction)\\nusing the string as an atom and casting a character list to a string\\nString assignment\\ncomparing two string\\ncopy a string\\nstring replacement isn't covered by the ansi standard probably best to use (replace-all) or cl-ppcre\\n\\njoining strings works in the same way as appending bytes\\nBlackBox Component Builder\\nExecute: ^Q NpctBinaryString.Do\\nOutput:\\nDéjà Vu has a blob type, which is much like Python 3's bytearray. They are used for dealing with binary data in the standard library, and works basically like a list, except it can only have integer numbers from 0 to 255 as elements, pushing and popping is not supported, and can be resized to any size in a single step.\\n(Since the task is not a specific program, the code here consists of example REPL sessions, not a whole program.)\\nIn E, binary data is represented as ELists (implemented as arrays or ropes) of integers; a String is strictly a character string. ELists come in Flex (mutable) and Const (immutable) varieties.\\nTo work with binary strings we must first have a byte type; this is a place where E shows its Java roots (to be fixed).\\nAs E is a memory-safe garbage-collected language there is no explicit destruction. It is good practice to work with immutable ConstLists when reasonable, however; especially when passing strings around.\\nNote: Elixir data types are immutable.\\n","s = \""Hello \""\\nt = \""world!\""\\nu = s + t   # + concatenates"
"Python","Binary_strings","Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks.\\nThis task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them. If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language.\\nIn particular the functions you need to create are:\\n\\nPossible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.\\n\\nAda has native support for single dimensioned arrays, which provide all specified operations. String is a case of array. The array of bytes is predefined in Ada in the package System.Storage_Elements (LRM 13.7.1). Storage_Element is substitute for byte.\\nStorage_Array is \""binary string\"" used for memory representation. For stream-oriented I/O communication Ada provides alternative \""binary string\"" called Stream_Element_Array (LRM 13.13.1). When dealing with octets of bits, programmers are encouraged to provide a data type of their own to ensure that the byte is exactly 8 bits length. For example:\\nAlternatively:\\nNote that all of these types will have all operations described above.\\nOutput:\\nOutput:\\nString creation (garbage collection will handle its destruction)\\nusing the string as an atom and casting a character list to a string\\nString assignment\\ncomparing two string\\ncopy a string\\nstring replacement isn't covered by the ansi standard probably best to use (replace-all) or cl-ppcre\\n\\njoining strings works in the same way as appending bytes\\nBlackBox Component Builder\\nExecute: ^Q NpctBinaryString.Do\\nOutput:\\nDéjà Vu has a blob type, which is much like Python 3's bytearray. They are used for dealing with binary data in the standard library, and works basically like a list, except it can only have integer numbers from 0 to 255 as elements, pushing and popping is not supported, and can be resized to any size in a single step.\\n(Since the task is not a specific program, the code here consists of example REPL sessions, not a whole program.)\\nIn E, binary data is represented as ELists (implemented as arrays or ropes) of integers; a String is strictly a character string. ELists come in Flex (mutable) and Const (immutable) varieties.\\nTo work with binary strings we must first have a byte type; this is a place where E shows its Java roots (to be fixed).\\nAs E is a memory-safe garbage-collected language there is no explicit destruction. It is good practice to work with immutable ConstLists when reasonable, however; especially when passing strings around.\\nNote: Elixir data types are immutable.\\n","assert \""Hello\"" == 'Hello'\\nassert '\\t' == '\\x09'\\nassert \""one\"" < \""two\""\\nassert \""two\"" >= \""three\"""
"Python","Binary_strings","Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks.\\nThis task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them. If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language.\\nIn particular the functions you need to create are:\\n\\nPossible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.\\n\\nAda has native support for single dimensioned arrays, which provide all specified operations. String is a case of array. The array of bytes is predefined in Ada in the package System.Storage_Elements (LRM 13.7.1). Storage_Element is substitute for byte.\\nStorage_Array is \""binary string\"" used for memory representation. For stream-oriented I/O communication Ada provides alternative \""binary string\"" called Stream_Element_Array (LRM 13.13.1). When dealing with octets of bits, programmers are encouraged to provide a data type of their own to ensure that the byte is exactly 8 bits length. For example:\\nAlternatively:\\nNote that all of these types will have all operations described above.\\nOutput:\\nOutput:\\nString creation (garbage collection will handle its destruction)\\nusing the string as an atom and casting a character list to a string\\nString assignment\\ncomparing two string\\ncopy a string\\nstring replacement isn't covered by the ansi standard probably best to use (replace-all) or cl-ppcre\\n\\njoining strings works in the same way as appending bytes\\nBlackBox Component Builder\\nExecute: ^Q NpctBinaryString.Do\\nOutput:\\nDéjà Vu has a blob type, which is much like Python 3's bytearray. They are used for dealing with binary data in the standard library, and works basically like a list, except it can only have integer numbers from 0 to 255 as elements, pushing and popping is not supported, and can be resized to any size in a single step.\\n(Since the task is not a specific program, the code here consists of example REPL sessions, not a whole program.)\\nIn E, binary data is represented as ELists (implemented as arrays or ropes) of integers; a String is strictly a character string. ELists come in Flex (mutable) and Const (immutable) varieties.\\nTo work with binary strings we must first have a byte type; this is a place where E shows its Java roots (to be fixed).\\nAs E is a memory-safe garbage-collected language there is no explicit destruction. It is good practice to work with immutable ConstLists when reasonable, however; especially when passing strings around.\\nNote: Elixir data types are immutable.\\n","if x=='': print \""Empty string\""\\nif not x: print \""Empty string, provided you know x is a string\"""
"Python","Binary_strings","Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks.\\nThis task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them. If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language.\\nIn particular the functions you need to create are:\\n\\nPossible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.\\n\\nAda has native support for single dimensioned arrays, which provide all specified operations. String is a case of array. The array of bytes is predefined in Ada in the package System.Storage_Elements (LRM 13.7.1). Storage_Element is substitute for byte.\\nStorage_Array is \""binary string\"" used for memory representation. For stream-oriented I/O communication Ada provides alternative \""binary string\"" called Stream_Element_Array (LRM 13.13.1). When dealing with octets of bits, programmers are encouraged to provide a data type of their own to ensure that the byte is exactly 8 bits length. For example:\\nAlternatively:\\nNote that all of these types will have all operations described above.\\nOutput:\\nOutput:\\nString creation (garbage collection will handle its destruction)\\nusing the string as an atom and casting a character list to a string\\nString assignment\\ncomparing two string\\ncopy a string\\nstring replacement isn't covered by the ansi standard probably best to use (replace-all) or cl-ppcre\\n\\njoining strings works in the same way as appending bytes\\nBlackBox Component Builder\\nExecute: ^Q NpctBinaryString.Do\\nOutput:\\nDéjà Vu has a blob type, which is much like Python 3's bytearray. They are used for dealing with binary data in the standard library, and works basically like a list, except it can only have integer numbers from 0 to 255 as elements, pushing and popping is not supported, and can be resized to any size in a single step.\\n(Since the task is not a specific program, the code here consists of example REPL sessions, not a whole program.)\\nIn E, binary data is represented as ELists (implemented as arrays or ropes) of integers; a String is strictly a character string. ELists come in Flex (mutable) and Const (immutable) varieties.\\nTo work with binary strings we must first have a byte type; this is a place where E shows its Java roots (to be fixed).\\nAs E is a memory-safe garbage-collected language there is no explicit destruction. It is good practice to work with immutable ConstLists when reasonable, however; especially when passing strings around.\\nNote: Elixir data types are immutable.\\n","txt = \""Some text\""\\ntxt += '\\x07'\\n# txt refers now to a new string having \""Some text\\x07\"""
"Python","Binary_strings","Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks.\\nThis task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them. If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language.\\nIn particular the functions you need to create are:\\n\\nPossible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.\\n\\nAda has native support for single dimensioned arrays, which provide all specified operations. String is a case of array. The array of bytes is predefined in Ada in the package System.Storage_Elements (LRM 13.7.1). Storage_Element is substitute for byte.\\nStorage_Array is \""binary string\"" used for memory representation. For stream-oriented I/O communication Ada provides alternative \""binary string\"" called Stream_Element_Array (LRM 13.13.1). When dealing with octets of bits, programmers are encouraged to provide a data type of their own to ensure that the byte is exactly 8 bits length. For example:\\nAlternatively:\\nNote that all of these types will have all operations described above.\\nOutput:\\nOutput:\\nString creation (garbage collection will handle its destruction)\\nusing the string as an atom and casting a character list to a string\\nString assignment\\ncomparing two string\\ncopy a string\\nstring replacement isn't covered by the ansi standard probably best to use (replace-all) or cl-ppcre\\n\\njoining strings works in the same way as appending bytes\\nBlackBox Component Builder\\nExecute: ^Q NpctBinaryString.Do\\nOutput:\\nDéjà Vu has a blob type, which is much like Python 3's bytearray. They are used for dealing with binary data in the standard library, and works basically like a list, except it can only have integer numbers from 0 to 255 as elements, pushing and popping is not supported, and can be resized to any size in a single step.\\n(Since the task is not a specific program, the code here consists of example REPL sessions, not a whole program.)\\nIn E, binary data is represented as ELists (implemented as arrays or ropes) of integers; a String is strictly a character string. ELists come in Flex (mutable) and Const (immutable) varieties.\\nTo work with binary strings we must first have a byte type; this is a place where E shows its Java roots (to be fixed).\\nAs E is a memory-safe garbage-collected language there is no explicit destruction. It is good practice to work with immutable ConstLists when reasonable, however; especially when passing strings around.\\nNote: Elixir data types are immutable.\\n","txt = \""Some more text\""\\nassert txt[4] == \"" \""\\nassert txt[0:4] == \""Some\""\\nassert txt[:4] == \""Some\"" # you can omit the starting index if 0\\nassert txt[5:9] == \""more\""\\nassert txt[5:] == \""more text\"" # omitting the second index means \""to the end\"""
"Python","Binary_strings","Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks.\\nThis task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them. If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language.\\nIn particular the functions you need to create are:\\n\\nPossible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.\\n\\nAda has native support for single dimensioned arrays, which provide all specified operations. String is a case of array. The array of bytes is predefined in Ada in the package System.Storage_Elements (LRM 13.7.1). Storage_Element is substitute for byte.\\nStorage_Array is \""binary string\"" used for memory representation. For stream-oriented I/O communication Ada provides alternative \""binary string\"" called Stream_Element_Array (LRM 13.13.1). When dealing with octets of bits, programmers are encouraged to provide a data type of their own to ensure that the byte is exactly 8 bits length. For example:\\nAlternatively:\\nNote that all of these types will have all operations described above.\\nOutput:\\nOutput:\\nString creation (garbage collection will handle its destruction)\\nusing the string as an atom and casting a character list to a string\\nString assignment\\ncomparing two string\\ncopy a string\\nstring replacement isn't covered by the ansi standard probably best to use (replace-all) or cl-ppcre\\n\\njoining strings works in the same way as appending bytes\\nBlackBox Component Builder\\nExecute: ^Q NpctBinaryString.Do\\nOutput:\\nDéjà Vu has a blob type, which is much like Python 3's bytearray. They are used for dealing with binary data in the standard library, and works basically like a list, except it can only have integer numbers from 0 to 255 as elements, pushing and popping is not supported, and can be resized to any size in a single step.\\n(Since the task is not a specific program, the code here consists of example REPL sessions, not a whole program.)\\nIn E, binary data is represented as ELists (implemented as arrays or ropes) of integers; a String is strictly a character string. ELists come in Flex (mutable) and Const (immutable) varieties.\\nTo work with binary strings we must first have a byte type; this is a place where E shows its Java roots (to be fixed).\\nAs E is a memory-safe garbage-collected language there is no explicit destruction. It is good practice to work with immutable ConstLists when reasonable, however; especially when passing strings around.\\nNote: Elixir data types are immutable.\\n","txt = \""Some more text\""\\nassert txt[-1] == \""t\""\\nassert txt[-4:] == \""text\"""
"Python","Binary_strings","Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks.\\nThis task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them. If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language.\\nIn particular the functions you need to create are:\\n\\nPossible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.\\n\\nAda has native support for single dimensioned arrays, which provide all specified operations. String is a case of array. The array of bytes is predefined in Ada in the package System.Storage_Elements (LRM 13.7.1). Storage_Element is substitute for byte.\\nStorage_Array is \""binary string\"" used for memory representation. For stream-oriented I/O communication Ada provides alternative \""binary string\"" called Stream_Element_Array (LRM 13.13.1). When dealing with octets of bits, programmers are encouraged to provide a data type of their own to ensure that the byte is exactly 8 bits length. For example:\\nAlternatively:\\nNote that all of these types will have all operations described above.\\nOutput:\\nOutput:\\nString creation (garbage collection will handle its destruction)\\nusing the string as an atom and casting a character list to a string\\nString assignment\\ncomparing two string\\ncopy a string\\nstring replacement isn't covered by the ansi standard probably best to use (replace-all) or cl-ppcre\\n\\njoining strings works in the same way as appending bytes\\nBlackBox Component Builder\\nExecute: ^Q NpctBinaryString.Do\\nOutput:\\nDéjà Vu has a blob type, which is much like Python 3's bytearray. They are used for dealing with binary data in the standard library, and works basically like a list, except it can only have integer numbers from 0 to 255 as elements, pushing and popping is not supported, and can be resized to any size in a single step.\\n(Since the task is not a specific program, the code here consists of example REPL sessions, not a whole program.)\\nIn E, binary data is represented as ELists (implemented as arrays or ropes) of integers; a String is strictly a character string. ELists come in Flex (mutable) and Const (immutable) varieties.\\nTo work with binary strings we must first have a byte type; this is a place where E shows its Java roots (to be fixed).\\nAs E is a memory-safe garbage-collected language there is no explicit destruction. It is good practice to work with immutable ConstLists when reasonable, however; especially when passing strings around.\\nNote: Elixir data types are immutable.\\n","v1 = \""hello world\""\\nv2 = v1.replace(\""l\"", \""L\"")\\nprint v2 # prints heLLo worLd"
"Python","Binary_strings","Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks.\\nThis task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them. If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language.\\nIn particular the functions you need to create are:\\n\\nPossible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.\\n\\nAda has native support for single dimensioned arrays, which provide all specified operations. String is a case of array. The array of bytes is predefined in Ada in the package System.Storage_Elements (LRM 13.7.1). Storage_Element is substitute for byte.\\nStorage_Array is \""binary string\"" used for memory representation. For stream-oriented I/O communication Ada provides alternative \""binary string\"" called Stream_Element_Array (LRM 13.13.1). When dealing with octets of bits, programmers are encouraged to provide a data type of their own to ensure that the byte is exactly 8 bits length. For example:\\nAlternatively:\\nNote that all of these types will have all operations described above.\\nOutput:\\nOutput:\\nString creation (garbage collection will handle its destruction)\\nusing the string as an atom and casting a character list to a string\\nString assignment\\ncomparing two string\\ncopy a string\\nstring replacement isn't covered by the ansi standard probably best to use (replace-all) or cl-ppcre\\n\\njoining strings works in the same way as appending bytes\\nBlackBox Component Builder\\nExecute: ^Q NpctBinaryString.Do\\nOutput:\\nDéjà Vu has a blob type, which is much like Python 3's bytearray. They are used for dealing with binary data in the standard library, and works basically like a list, except it can only have integer numbers from 0 to 255 as elements, pushing and popping is not supported, and can be resized to any size in a single step.\\n(Since the task is not a specific program, the code here consists of example REPL sessions, not a whole program.)\\nIn E, binary data is represented as ELists (implemented as arrays or ropes) of integers; a String is strictly a character string. ELists come in Flex (mutable) and Const (immutable) varieties.\\nTo work with binary strings we must first have a byte type; this is a place where E shows its Java roots (to be fixed).\\nAs E is a memory-safe garbage-collected language there is no explicit destruction. It is good practice to work with immutable ConstLists when reasonable, however; especially when passing strings around.\\nNote: Elixir data types are immutable.\\n","v1 = \""hello\"" \\nv2 = \""world\""\\nmsg = v1 + \"" \"" + v2"
"Python","Binary_strings","Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks.\\nThis task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them. If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language.\\nIn particular the functions you need to create are:\\n\\nPossible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.\\n\\nAda has native support for single dimensioned arrays, which provide all specified operations. String is a case of array. The array of bytes is predefined in Ada in the package System.Storage_Elements (LRM 13.7.1). Storage_Element is substitute for byte.\\nStorage_Array is \""binary string\"" used for memory representation. For stream-oriented I/O communication Ada provides alternative \""binary string\"" called Stream_Element_Array (LRM 13.13.1). When dealing with octets of bits, programmers are encouraged to provide a data type of their own to ensure that the byte is exactly 8 bits length. For example:\\nAlternatively:\\nNote that all of these types will have all operations described above.\\nOutput:\\nOutput:\\nString creation (garbage collection will handle its destruction)\\nusing the string as an atom and casting a character list to a string\\nString assignment\\ncomparing two string\\ncopy a string\\nstring replacement isn't covered by the ansi standard probably best to use (replace-all) or cl-ppcre\\n\\njoining strings works in the same way as appending bytes\\nBlackBox Component Builder\\nExecute: ^Q NpctBinaryString.Do\\nOutput:\\nDéjà Vu has a blob type, which is much like Python 3's bytearray. They are used for dealing with binary data in the standard library, and works basically like a list, except it can only have integer numbers from 0 to 255 as elements, pushing and popping is not supported, and can be resized to any size in a single step.\\n(Since the task is not a specific program, the code here consists of example REPL sessions, not a whole program.)\\nIn E, binary data is represented as ELists (implemented as arrays or ropes) of integers; a String is strictly a character string. ELists come in Flex (mutable) and Const (immutable) varieties.\\nTo work with binary strings we must first have a byte type; this is a place where E shows its Java roots (to be fixed).\\nAs E is a memory-safe garbage-collected language there is no explicit destruction. It is good practice to work with immutable ConstLists when reasonable, however; especially when passing strings around.\\nNote: Elixir data types are immutable.\\n","items = [\""Smith\"", \""John\"", \""417 Evergreen Av\"", \""Chimichurri\"", \""481-3172\""]\\njoined = \"",\"".join(items)\\nprint joined\\n# output:\\n# Smith,John,417 Evergreen Av,Chimichurri,481-3172"
"Python","Binary_strings","Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks.\\nThis task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them. If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language.\\nIn particular the functions you need to create are:\\n\\nPossible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.\\n\\nAda has native support for single dimensioned arrays, which provide all specified operations. String is a case of array. The array of bytes is predefined in Ada in the package System.Storage_Elements (LRM 13.7.1). Storage_Element is substitute for byte.\\nStorage_Array is \""binary string\"" used for memory representation. For stream-oriented I/O communication Ada provides alternative \""binary string\"" called Stream_Element_Array (LRM 13.13.1). When dealing with octets of bits, programmers are encouraged to provide a data type of their own to ensure that the byte is exactly 8 bits length. For example:\\nAlternatively:\\nNote that all of these types will have all operations described above.\\nOutput:\\nOutput:\\nString creation (garbage collection will handle its destruction)\\nusing the string as an atom and casting a character list to a string\\nString assignment\\ncomparing two string\\ncopy a string\\nstring replacement isn't covered by the ansi standard probably best to use (replace-all) or cl-ppcre\\n\\njoining strings works in the same way as appending bytes\\nBlackBox Component Builder\\nExecute: ^Q NpctBinaryString.Do\\nOutput:\\nDéjà Vu has a blob type, which is much like Python 3's bytearray. They are used for dealing with binary data in the standard library, and works basically like a list, except it can only have integer numbers from 0 to 255 as elements, pushing and popping is not supported, and can be resized to any size in a single step.\\n(Since the task is not a specific program, the code here consists of example REPL sessions, not a whole program.)\\nIn E, binary data is represented as ELists (implemented as arrays or ropes) of integers; a String is strictly a character string. ELists come in Flex (mutable) and Const (immutable) varieties.\\nTo work with binary strings we must first have a byte type; this is a place where E shows its Java roots (to be fixed).\\nAs E is a memory-safe garbage-collected language there is no explicit destruction. It is good practice to work with immutable ConstLists when reasonable, however; especially when passing strings around.\\nNote: Elixir data types are immutable.\\n","line = \""Smith,John,417 Evergreen Av,Chimichurri,481-3172\""\\nfields = line.split(',')\\nprint fields\\n# output:\\n# ['Smith', 'John', '417 Evergreen Av', 'Chimichurri', '481-3172']"
"Python","Binary_strings","Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks.\\nThis task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them. If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language.\\nIn particular the functions you need to create are:\\n\\nPossible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.\\n\\nAda has native support for single dimensioned arrays, which provide all specified operations. String is a case of array. The array of bytes is predefined in Ada in the package System.Storage_Elements (LRM 13.7.1). Storage_Element is substitute for byte.\\nStorage_Array is \""binary string\"" used for memory representation. For stream-oriented I/O communication Ada provides alternative \""binary string\"" called Stream_Element_Array (LRM 13.13.1). When dealing with octets of bits, programmers are encouraged to provide a data type of their own to ensure that the byte is exactly 8 bits length. For example:\\nAlternatively:\\nNote that all of these types will have all operations described above.\\nOutput:\\nOutput:\\nString creation (garbage collection will handle its destruction)\\nusing the string as an atom and casting a character list to a string\\nString assignment\\ncomparing two string\\ncopy a string\\nstring replacement isn't covered by the ansi standard probably best to use (replace-all) or cl-ppcre\\n\\njoining strings works in the same way as appending bytes\\nBlackBox Component Builder\\nExecute: ^Q NpctBinaryString.Do\\nOutput:\\nDéjà Vu has a blob type, which is much like Python 3's bytearray. They are used for dealing with binary data in the standard library, and works basically like a list, except it can only have integer numbers from 0 to 255 as elements, pushing and popping is not supported, and can be resized to any size in a single step.\\n(Since the task is not a specific program, the code here consists of example REPL sessions, not a whole program.)\\nIn E, binary data is represented as ELists (implemented as arrays or ropes) of integers; a String is strictly a character string. ELists come in Flex (mutable) and Const (immutable) varieties.\\nTo work with binary strings we must first have a byte type; this is a place where E shows its Java roots (to be fixed).\\nAs E is a memory-safe garbage-collected language there is no explicit destruction. It is good practice to work with immutable ConstLists when reasonable, however; especially when passing strings around.\\nNote: Elixir data types are immutable.\\n","s1 = b\""A 'byte string' literal \\n\""\\ns2 = b'You may use any of \\' or \"" as delimiter'\\ns3 = b\""\""\""This text \\n   goes over several lines\\n       up to the closing triple quote\""\""\"""
"Python","Binary_strings","Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks.\\nThis task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them. If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language.\\nIn particular the functions you need to create are:\\n\\nPossible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.\\n\\nAda has native support for single dimensioned arrays, which provide all specified operations. String is a case of array. The array of bytes is predefined in Ada in the package System.Storage_Elements (LRM 13.7.1). Storage_Element is substitute for byte.\\nStorage_Array is \""binary string\"" used for memory representation. For stream-oriented I/O communication Ada provides alternative \""binary string\"" called Stream_Element_Array (LRM 13.13.1). When dealing with octets of bits, programmers are encouraged to provide a data type of their own to ensure that the byte is exactly 8 bits length. For example:\\nAlternatively:\\nNote that all of these types will have all operations described above.\\nOutput:\\nOutput:\\nString creation (garbage collection will handle its destruction)\\nusing the string as an atom and casting a character list to a string\\nString assignment\\ncomparing two string\\ncopy a string\\nstring replacement isn't covered by the ansi standard probably best to use (replace-all) or cl-ppcre\\n\\njoining strings works in the same way as appending bytes\\nBlackBox Component Builder\\nExecute: ^Q NpctBinaryString.Do\\nOutput:\\nDéjà Vu has a blob type, which is much like Python 3's bytearray. They are used for dealing with binary data in the standard library, and works basically like a list, except it can only have integer numbers from 0 to 255 as elements, pushing and popping is not supported, and can be resized to any size in a single step.\\n(Since the task is not a specific program, the code here consists of example REPL sessions, not a whole program.)\\nIn E, binary data is represented as ELists (implemented as arrays or ropes) of integers; a String is strictly a character string. ELists come in Flex (mutable) and Const (immutable) varieties.\\nTo work with binary strings we must first have a byte type; this is a place where E shows its Java roots (to be fixed).\\nAs E is a memory-safe garbage-collected language there is no explicit destruction. It is good practice to work with immutable ConstLists when reasonable, however; especially when passing strings around.\\nNote: Elixir data types are immutable.\\n","x = b'abc'\\nx[0] # evaluates to 97"
"Python","Binary_strings","Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks.\\nThis task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them. If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language.\\nIn particular the functions you need to create are:\\n\\nPossible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.\\n\\nAda has native support for single dimensioned arrays, which provide all specified operations. String is a case of array. The array of bytes is predefined in Ada in the package System.Storage_Elements (LRM 13.7.1). Storage_Element is substitute for byte.\\nStorage_Array is \""binary string\"" used for memory representation. For stream-oriented I/O communication Ada provides alternative \""binary string\"" called Stream_Element_Array (LRM 13.13.1). When dealing with octets of bits, programmers are encouraged to provide a data type of their own to ensure that the byte is exactly 8 bits length. For example:\\nAlternatively:\\nNote that all of these types will have all operations described above.\\nOutput:\\nOutput:\\nString creation (garbage collection will handle its destruction)\\nusing the string as an atom and casting a character list to a string\\nString assignment\\ncomparing two string\\ncopy a string\\nstring replacement isn't covered by the ansi standard probably best to use (replace-all) or cl-ppcre\\n\\njoining strings works in the same way as appending bytes\\nBlackBox Component Builder\\nExecute: ^Q NpctBinaryString.Do\\nOutput:\\nDéjà Vu has a blob type, which is much like Python 3's bytearray. They are used for dealing with binary data in the standard library, and works basically like a list, except it can only have integer numbers from 0 to 255 as elements, pushing and popping is not supported, and can be resized to any size in a single step.\\n(Since the task is not a specific program, the code here consists of example REPL sessions, not a whole program.)\\nIn E, binary data is represented as ELists (implemented as arrays or ropes) of integers; a String is strictly a character string. ELists come in Flex (mutable) and Const (immutable) varieties.\\nTo work with binary strings we must first have a byte type; this is a place where E shows its Java roots (to be fixed).\\nAs E is a memory-safe garbage-collected language there is no explicit destruction. It is good practice to work with immutable ConstLists when reasonable, however; especially when passing strings around.\\nNote: Elixir data types are immutable.\\n","x = b'abc'\\nlist(x) # evaluates to [97, 98, 99]\\nbytes([97, 98, 99]) # evaluates to b'abc'"
"Python","Birthday_problem","This page uses content from Wikipedia.\\nThe current wikipedia article is at Birthday Problem.\\nThe original RosettaCode article was extracted from the wikipedia article № 296054030 of 21:44, 12 June 2009 .\\nThe list of authors can be seen in the page history.\\nAs with Rosetta Code,\\nthe pre 5 June 2009 text of Wikipedia is available under the GNU FDL.\\n(See links for details on variance)\\n\\nIn probability theory, the birthday problem, or birthday paradox This is not a paradox in the sense of leading to a logical contradiction, but is called a paradox because the mathematical truth contradicts naïve intuition: most people estimate that the chance is much lower than 50%. pertains to the probability that in a set of randomly chosen people some pair of them will have the same birthday. In a group of at least 23 randomly chosen people, there is more than 50% probability that some pair of them will both have been born on the same day. For 57 or more people, the probability is more than 99%, and it reaches 100% when the number of people reaches 366 (by the pigeon hole principle, ignoring leap years). The mathematics behind this problem leads to a well-known cryptographic attack called the birthday attack.\\n\\nUsing simulation, estimate the number of independent people required in a groups before we can expect a better than even chance that at least 2 independent people in a group share a common birthday. Furthermore: Simulate and thus estimate when we can expect a better than even chance that at least 3, 4 & 5 independent people of the group share a common birthday. For simplicity assume that all of the people are alive...\\n\\n\\n\\nThis solution assumes a 4-year cycle, with three 365-day years and one leap year.\\n","\\nfrom random import randint\\n\\ndef equal_birthdays(sharers=2, groupsize=23, rep=100000):\\n    'Note: 4 sharing common birthday may have 2 dates shared between two people each' \\n    g = range(groupsize)\\n    sh = sharers - 1\\n    eq = sum((groupsize - len(set(randint(1,365) for i in g)) >= sh)\\n             for j in range(rep))\\n    return (eq * 100.) / rep\\n\\ndef equal_birthdays(sharers=2, groupsize=23, rep=100000):\\n    'Note: 4 sharing common birthday must all share same common day' \\n    g = range(groupsize)\\n    sh = sharers - 1\\n    eq = 0\\n    for j in range(rep):\\n        group = [randint(1,365) for i in g]\\n        if (groupsize - len(set(group)) >= sh and\\n            any( group.count(member) >= sharers for member in set(group))):\\n            eq += 1\\n    return (eq * 100.) / rep\\n\\ngroup_est = [2]\\nfor sharers in (2, 3, 4, 5):\\n    groupsize = group_est[-1]+1\\n    while equal_birthdays(sharers, groupsize, 100) < 50.:\\n        # Coarse\\n        groupsize += 1\\n    for groupsize in range(int(groupsize - (groupsize - group_est[-1])/4.), groupsize + 999):\\n        # Finer\\n        eq = equal_birthdays(sharers, groupsize, 250)\\n        if eq > 50.:\\n            break\\n    for groupsize in range(groupsize - 1, groupsize +999):\\n        # Finest\\n        eq = equal_birthdays(sharers, groupsize, 50000)\\n        if eq > 50.:\\n            break\\n    group_est.append(groupsize)\\n    print(\""%i independent people in a group of %s share a common birthday. (%5.1f)\"" % (sharers, groupsize, eq))"
"Python","Birthday_problem","This page uses content from Wikipedia.\\nThe current wikipedia article is at Birthday Problem.\\nThe original RosettaCode article was extracted from the wikipedia article № 296054030 of 21:44, 12 June 2009 .\\nThe list of authors can be seen in the page history.\\nAs with Rosetta Code,\\nthe pre 5 June 2009 text of Wikipedia is available under the GNU FDL.\\n(See links for details on variance)\\n\\nIn probability theory, the birthday problem, or birthday paradox This is not a paradox in the sense of leading to a logical contradiction, but is called a paradox because the mathematical truth contradicts naïve intuition: most people estimate that the chance is much lower than 50%. pertains to the probability that in a set of randomly chosen people some pair of them will have the same birthday. In a group of at least 23 randomly chosen people, there is more than 50% probability that some pair of them will both have been born on the same day. For 57 or more people, the probability is more than 99%, and it reaches 100% when the number of people reaches 366 (by the pigeon hole principle, ignoring leap years). The mathematics behind this problem leads to a well-known cryptographic attack called the birthday attack.\\n\\nUsing simulation, estimate the number of independent people required in a groups before we can expect a better than even chance that at least 2 independent people in a group share a common birthday. Furthermore: Simulate and thus estimate when we can expect a better than even chance that at least 3, 4 & 5 independent people of the group share a common birthday. For simplicity assume that all of the people are alive...\\n\\n\\n\\nThis solution assumes a 4-year cycle, with three 365-day years and one leap year.\\n","from collections import defaultdict\\ndays = 365\\n\\ndef find_half(c):\\n\\n    # inc_people takes birthday combinations of n people and generates the\\n    # new set for n+1\\n    def inc_people(din, over):\\n        # 'over' is the number of combinations that have at least c people\\n        # sharing a birthday. These are not contained in the set.\\n\\n        dout,over = defaultdict(int), over * days\\n        for k,s in din.items():\\n            for i,v in enumerate(k):\\n                if v + 1 >= c:\\n                    over += s\\n                else:\\n                    dout[tuple(sorted(k[0:i] + (v + 1,) + k[i+1:]))] += s\\n            dout[(1,) + k] += s * (days - len(k))\\n        return dout, over\\n\\n    d, combos, good, n = {():1}, 1, 0, 0\\n\\n    # increase number of people until at least half of the cases have at\\n    # at least c people sharing a birthday\\n    while True:\\n        n += 1\\n        combos *= days # or, combos = sum(d.values()) + good\\n        d,good = inc_people(d, good)\\n\\n        #!!! print d.items()\\n        if good * 2 >= combos:\\n            return n, good, combos\\n\\n# In all fairness, I don't know if the code works for x >= 4: I probably don't\\n# have enough RAM for it, and certainly not enough patience. But it should.\\n# In theory.\\nfor x in range(2, 5):\\n    n, good, combos = find_half(x)\\n    print \""%d of %d people sharing birthday: %d out of %d combos\""% (x, n, good, combos)\\n"
"Python","Birthday_problem","This page uses content from Wikipedia.\\nThe current wikipedia article is at Birthday Problem.\\nThe original RosettaCode article was extracted from the wikipedia article № 296054030 of 21:44, 12 June 2009 .\\nThe list of authors can be seen in the page history.\\nAs with Rosetta Code,\\nthe pre 5 June 2009 text of Wikipedia is available under the GNU FDL.\\n(See links for details on variance)\\n\\nIn probability theory, the birthday problem, or birthday paradox This is not a paradox in the sense of leading to a logical contradiction, but is called a paradox because the mathematical truth contradicts naïve intuition: most people estimate that the chance is much lower than 50%. pertains to the probability that in a set of randomly chosen people some pair of them will have the same birthday. In a group of at least 23 randomly chosen people, there is more than 50% probability that some pair of them will both have been born on the same day. For 57 or more people, the probability is more than 99%, and it reaches 100% when the number of people reaches 366 (by the pigeon hole principle, ignoring leap years). The mathematics behind this problem leads to a well-known cryptographic attack called the birthday attack.\\n\\nUsing simulation, estimate the number of independent people required in a groups before we can expect a better than even chance that at least 2 independent people in a group share a common birthday. Furthermore: Simulate and thus estimate when we can expect a better than even chance that at least 3, 4 & 5 independent people of the group share a common birthday. For simplicity assume that all of the people are alive...\\n\\n\\n\\nThis solution assumes a 4-year cycle, with three 365-day years and one leap year.\\n","# ought to use a memoize class for all this\\n# factorial\\ndef fact(n, cache={0:1}):\\n    if not n in cache:\\n        cache[n] = n * fact(n - 1)\\n    return cache[n]\\n\\n# permutations\\ndef perm(n, k, cache={}):\\n    if not (n,k) in cache:\\n        cache[(n,k)] = fact(n) / fact(n - k)\\n    return cache[(n,k)]\\n\\ndef choose(n, k, cache={}):\\n    if not (n,k) in cache:\\n        cache[(n,k)] = perm(n, k) / fact(k)\\n    return cache[(n, k)]\\n\\n# ways of distribute p people's birthdays into d days, with\\n# no more than m sharing any one day\\ndef combos(d, p, m, cache={}):\\n    if not p: return 1\\n    if not m: return 0\\n    if p <= m: return d**p        # any combo would satisfy\\n\\n    k = (d, p, m)\\n    if not k in cache:\\n        result = 0\\n        for x in range(0, p//m + 1):\\n            c = combos(d - x, p - x * m, m - 1)\\n            # ways to occupy x days with m people each\\n            if c: result += c * choose(d, x) * perm(p, x * m) / fact(m)**x\\n        cache[k] = result\\n\\n    return cache[k]\\n\\ndef find_half(m):\\n    n = 0\\n    while True:\\n        n += 1\\n        total = 365 ** n\\n        c = total - combos(365, n, m - 1)\\n        if c * 2 >= total:\\n            print \""%d of %d people: %d/%d combos\"" % (n, m, c, total)\\n            return\\n\\nfor x in range(2, 6): find_half(x)"
"Python","Bitcoin/address_validation","\\nWrite a program that takes a bitcoin address as argument,\\nand checks whether or not this address is valid.\\nA bitcoin address uses a base58 encoding, which uses an alphabet of the characters 0 .. 9, A ..Z, a .. z, but without the four characters:\\n\\nWith this encoding, a bitcoin address encodes 25 bytes:\\n\\nTo check the bitcoin address, you must read the first twenty-one bytes, compute the checksum, and check that it corresponds to the last four bytes.\\nThe program can either return a boolean value or throw an exception when not valid.\\nYou can use a digest library for SHA-256.\\n\\n\\n","from hashlib import sha256\\n\\ndigits58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\\n\\ndef decode_base58(bc, length):\\n    n = 0\\n    for char in bc:\\n        n = n * 58 + digits58.index(char)\\n    return n.to_bytes(length, 'big')\\ndef check_bc(bc):\\n    try:\\n        bcbytes = decode_base58(bc, 25)\\n        return bcbytes[-4:] == sha256(sha256(bcbytes[:-4]).digest()).digest()[:4]\\n    except Exception:\\n        return False\\n\\nprint(check_bc('1AGNa15ZQXAZUgFiqJ3i7Z2DPU2J6hW62i'))\\nprint(check_bc(\""17NdbrSGoUotzeGCcMMCqnFkEvLymoou9j\""))"
"Python","Bitcoin/address_validation","\\nWrite a program that takes a bitcoin address as argument,\\nand checks whether or not this address is valid.\\nA bitcoin address uses a base58 encoding, which uses an alphabet of the characters 0 .. 9, A ..Z, a .. z, but without the four characters:\\n\\nWith this encoding, a bitcoin address encodes 25 bytes:\\n\\nTo check the bitcoin address, you must read the first twenty-one bytes, compute the checksum, and check that it corresponds to the last four bytes.\\nThe program can either return a boolean value or throw an exception when not valid.\\nYou can use a digest library for SHA-256.\\n\\n\\n",">>> n = 2491969579123783355964723219455906992268673266682165637887\\n>>> length = 25\\n>>> list( reversed(range(length)) )\\n[24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\\n>>> assert n.to_bytes(length, 'big') == bytes( (n >> i*8) & 0xff for i in reversed(range(length)))\\n>>> "
"Python","Bitcoin/public_point_to_address","Bitcoin uses a specific encoding format to encode the digest of an elliptic curve public point into a short ASCII string. The purpose of this task is to perform such a conversion.\\nThe encoding steps are:\\nThe base-58 encoding is based on an alphabet of alphanumeric characters (numbers, upper case and lower case, in that order) but without the four characters 0, O, l and I.\\nHere is an example public point:\\nThe corresponding address should be:\\n16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM\\nNb. The leading '1' is not significant as 1 is zero in base-58. It is however often added to the bitcoin address for various reasons. There can actually be several of them. You can ignore this and output an address without the leading 1.\\nExtra credit: add a verification procedure about the public point, making sure it belongs to the secp256k1 elliptic curve\\nRequires the second D module from the SHA-256 task.\\n","#!/usr/bin/env python3\\n\\nimport binascii\\nimport functools\\nimport hashlib\\n\\ndigits58 = b'123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\\n\\ndef b58(n):\\n    return b58(n//58) + digits58[n%58:n%58+1] if n else b''\\n\\ndef public_point_to_address(x, y):\\n    c = b'\\x04' + binascii.unhexlify(x) + binascii.unhexlify(y)\\n    r = hashlib.new('ripemd160')\\n    r.update(hashlib.sha256(c).digest())\\n    c = b'\\x00' + r.digest()\\n    d = hashlib.sha256(hashlib.sha256(c).digest()).digest()\\n    return b58(functools.reduce(lambda n, b: n<<8|b, c + d[:4]))\\n\\nif __name__ == '__main__':\\n    print(public_point_to_address(\\n        b'50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352',\\n        b'2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6'))"
"Python","Bitmap/Bresenham's_line_algorithm","Using the data storage type defined on the Bitmap page for raster graphics images, draw a line given two points with Bresenham's line algorithm.\\n\\nThe test program's\\nsample output\\n16 bit Intel 8086\\80486 Assembly for dos, see x86 assembly language.\\nTo run this code you will need to use Dos emulator.\\n\\nInstead of swaps in the initialisation use error calculation for both directions x and y simultaneously:\\nPort of the C version.\\nThis code uses the Image defined in Bitmap Task.\\nTo run the demo code compile with -version=bitmap_bresenhams_line_algorithm_main.\\n","def line(self, x0, y0, x1, y1):\\n    \""Bresenham's line algorithm\""\\n    dx = abs(x1 - x0)\\n    dy = abs(y1 - y0)\\n    x, y = x0, y0\\n    sx = -1 if x0 > x1 else 1\\n    sy = -1 if y0 > y1 else 1\\n    if dx > dy:\\n        err = dx / 2.0\\n        while x != x1:\\n            self.set(x, y)\\n            err -= dy\\n            if err < 0:\\n                y += sy\\n                err += dx\\n            x += sx\\n    else:\\n        err = dy / 2.0\\n        while y != y1:\\n            self.set(x, y)\\n            err -= dx\\n            if err < 0:\\n                x += sx\\n                err += dy\\n            y += sy        \\n    self.set(x, y)\\nBitmap.line = line\\n\\nbitmap = Bitmap(17,17)\\nfor points in ((1,8,8,16),(8,16,16,8),(16,8,8,1),(8,1,1,8)):\\n    bitmap.line(*points)\\nbitmap.chardisplay()\\n\\n'''\\nThe origin, 0,0; is the lower left, with x increasing to the right,\\nand Y increasing upwards.\\n\\nThe chardisplay above produces the following output :\\n+-----------------+\\n|        @        |\\n|       @ @       |\\n|      @   @      |\\n|     @     @     |\\n|    @       @    |\\n|    @        @   |\\n|   @          @  |\\n|  @            @ |\\n| @              @|\\n|  @            @ |\\n|   @          @  |\\n|    @       @@   |\\n|     @     @     |\\n|      @   @      |\\n|       @ @       |\\n|        @        |\\n|                 |\\n+-----------------+\\n'''"
"Python","Bitmap/Bresenham's_line_algorithm","Using the data storage type defined on the Bitmap page for raster graphics images, draw a line given two points with Bresenham's line algorithm.\\n\\nThe test program's\\nsample output\\n16 bit Intel 8086\\80486 Assembly for dos, see x86 assembly language.\\nTo run this code you will need to use Dos emulator.\\n\\nInstead of swaps in the initialisation use error calculation for both directions x and y simultaneously:\\nPort of the C version.\\nThis code uses the Image defined in Bitmap Task.\\nTo run the demo code compile with -version=bitmap_bresenhams_line_algorithm_main.\\n","\\nfrom fractions import Fraction\\n\\ndef line(self, x0, y0, x1, y1):\\n    rev = reversed\\n    if abs(y1 - y0) <= abs(x1 - x0):\\n        x0, y0, x1, y1 = y0, x0, y1, x1\\n        rev = lambda x: x\\n    if x1 < x0:\\n        x0, y0, x1, y1 = x1, y1, x0, y0\\n    leny = abs(y1 - y0)\\n    for i in range(leny + 1):\\n        self.set(*rev((round(Fraction(i, leny) * (x1 - x0)) + x0, (1 if y1 > y0 else -1) * i + y0)))\\n\\nBitmap.line = line\\n\\n# see test code above\\n"
"Python","Bitmap/Flood_fill","Implement a flood fill.\\nA flood fill is a way of filling an area using color banks to define the contained area or a target color which \""determines\"" the area (the valley that can be flooded; Wikipedia uses the term target color). It works almost like a water flooding from a point towards the banks (or: inside the valley): if there's a hole in the banks, the flood is not contained and all the image (or all the \""connected valleys\"") get filled.\\nTo accomplish the task, you need to implement just one of the possible algorithms (examples are on Wikipedia). Variations on the theme are allowed (e.g. adding a tolerance parameter or argument for color-matching of the banks or target color).\\nTesting: the basic algorithm is not suitable for truecolor images; a possible test image is the one shown on the right box; you can try to fill the white area, or the black inner circle.\\n\\nThe procedure has the following parameters. Picture is the image to change. From is the point to start at. Fill is the color to fill with. Replace is the color to replace. Distance defines the range of color around Replace to replace as well. The distance is defined as a maximum of the differences of stimuli. The following code snippet reads the test file, fills the area between two circles red, and writes the result:\\nThis is limited to %StackSize% pixels.\\nBBC BASIC has a built-in flood fill statement, but to satisfy the terms of the task it is not used in this example.\\nThe sys/queue.h is not POSIX. (See FIFO)\\nThe pixelcount could be used to know the area of the filled region. The internal parameter tolerance can be tuned to cope with antialiasing, bringing \""sharper\"" resuts.\\n(Comments show changes to fill the white area instead of the black circle)\\nInput is the image, the starting node (x, y), the target color we want to fill, and the replacement color that will replace the target color. It implements a 4-way flood fill algorithm.\\nInterface\\nImplementation\\nThis implementation matches exact colours only. Since the example image has grey pixels around the edges of the circles, these will remain grey after the interiors are filled.\\nThis version uses the bitmap module from the Bitmap Task, matches exact colours only, and is derived from the Go version (to avoid stack overflow because unlike Go the D stack is not segmented).\\nUsing the image type from Basic bitmap storage#E.\\nIn \""PC.LIB\"" library there is a FILL procedure that do the job, but the example program implements the algorithm in ERRE language using an iterative method. This program is taken from the distribution disk and works in 320x200 graphics.\\nNote: I haven't an \""Upload files\"" item, so I can't show the resulting image!\\nUsing an emulated stack. EMT's recursive stack space is limited. For the notebook with images see this page.\\nUsing pure FBSL's built-in graphics functions:\\nOutput: \\nThis simple recursive algorithm uses routines from Basic bitmap storage.\\nHere the target color paradigm is used. Again the matchdistance parameter can be tuned to ignore small differences that could come because of antialiasing.\\nUsage example excerpt (which on the test image will fill with green the inner black circle):\\nAn addition to code from the bitmap task:\\nAnd a test program. Works with code from read ppm and write ppm to pipe tasks. For input, it uses a version of the test file converted by the Go solution to \""Read an image through a pipe\"". For output it uses the trick from \""PPM conversion through a pipe\"" to write the .png suitable for uploading to RC.\\nThis code uses the Bitmap and Bitmap.RGB modules defined here.\\nHicEst color fill is via the decoration option of WRITE()\\nSolution:\\nUses getPixels and setPixels from Basic bitmap storage.\\nExample Usage:\\nThe following draws the same image as for the Tcl example image below.\\nUses definitions from Basic bitmap storage, Bresenham's line algorithm and Midpoint circle algorithm.\\nAlternative findcontig:\\nThe following alternative version of findcontig is less concise but is leaner, faster, works for n-dimensions and is not restricted to numerical arrays.\\nInput is the image, the starting node (x, y), the target color we want to fill, and the replacement color that will replace the target color. It implements a 4-way flood fill algorithm. For large images, the performance can be improved by drawing the scanlines instead of setting each pixel to the replacement color, or by working directly on the databuffer.\\nAnd here is an example of how to replace the white color with red from the sample image (with starting node (50, 50)):\\nInspired to  Python version.\\nLingo has built-in flood fill for image objects, so a custom implementation would be pointless:\\n","\\nimport Image\\ndef FloodFill( fileName, initNode, targetColor, replaceColor ):\\n   img = Image.open( fileName )\\n   pix = img.load()\\n   xsize, ysize = img.size\\n   Q = []\\n   if pix[ initNode[0], initNode[1] ] != targetColor:\\n      return img\\n   Q.append( initNode )\\n   while Q != []:\\n      node = Q.pop(0)\\n      if pix[ node[0], node[1] ] == targetColor:\\n         W = list( node )\\n         if node[0] + 1 < xsize:\\n            E = list( [ node[0] + 1, node[1] ] )\\n         else:\\n            E = list( node )\\n      # Move west until color of node does not match targetColor\\n      while pix[ W[0], W[1] ] == targetColor:\\n         pix[ W[0], W[1] ] = replaceColor\\n         if W[1] + 1 < ysize:\\n            if pix[ W[0], W[1] + 1 ] == targetColor:\\n               Q.append( [ W[0], W[1] + 1 ] )\\n         if W[1] - 1 >= 0:\\n            if pix[ W[0], W[1] - 1 ] == targetColor:\\n               Q.append( [ W[0], W[1] - 1 ] )\\n         if W[0] - 1 >= 0:\\n            W[0] = W[0] - 1\\n         else:\\n            break\\n      # Move east until color of node does not match targetColor\\n      while pix[ E[0], E[1] ] == targetColor:\\n         pix[ E[0], E[1] ] = replaceColor\\n         if E[1] + 1 < ysize:\\n            if pix[ E[0], E[1] + 1 ] == targetColor:\\n               Q.append( [ E[0], E[1] + 1 ] )\\n         if E[1] - 1 >= 0:\\n            if pix[ E[0], E[1] - 1 ] == targetColor:\\n               Q.append( [ E[0], E[1] -1 ] )\\n         if E[0] + 1 < xsize:\\n            E[0] = E[0] + 1\\n         else:\\n            break\\n      return img\\n"
"Python","Bitmap/Flood_fill","Implement a flood fill.\\nA flood fill is a way of filling an area using color banks to define the contained area or a target color which \""determines\"" the area (the valley that can be flooded; Wikipedia uses the term target color). It works almost like a water flooding from a point towards the banks (or: inside the valley): if there's a hole in the banks, the flood is not contained and all the image (or all the \""connected valleys\"") get filled.\\nTo accomplish the task, you need to implement just one of the possible algorithms (examples are on Wikipedia). Variations on the theme are allowed (e.g. adding a tolerance parameter or argument for color-matching of the banks or target color).\\nTesting: the basic algorithm is not suitable for truecolor images; a possible test image is the one shown on the right box; you can try to fill the white area, or the black inner circle.\\n\\nThe procedure has the following parameters. Picture is the image to change. From is the point to start at. Fill is the color to fill with. Replace is the color to replace. Distance defines the range of color around Replace to replace as well. The distance is defined as a maximum of the differences of stimuli. The following code snippet reads the test file, fills the area between two circles red, and writes the result:\\nThis is limited to %StackSize% pixels.\\nBBC BASIC has a built-in flood fill statement, but to satisfy the terms of the task it is not used in this example.\\nThe sys/queue.h is not POSIX. (See FIFO)\\nThe pixelcount could be used to know the area of the filled region. The internal parameter tolerance can be tuned to cope with antialiasing, bringing \""sharper\"" resuts.\\n(Comments show changes to fill the white area instead of the black circle)\\nInput is the image, the starting node (x, y), the target color we want to fill, and the replacement color that will replace the target color. It implements a 4-way flood fill algorithm.\\nInterface\\nImplementation\\nThis implementation matches exact colours only. Since the example image has grey pixels around the edges of the circles, these will remain grey after the interiors are filled.\\nThis version uses the bitmap module from the Bitmap Task, matches exact colours only, and is derived from the Go version (to avoid stack overflow because unlike Go the D stack is not segmented).\\nUsing the image type from Basic bitmap storage#E.\\nIn \""PC.LIB\"" library there is a FILL procedure that do the job, but the example program implements the algorithm in ERRE language using an iterative method. This program is taken from the distribution disk and works in 320x200 graphics.\\nNote: I haven't an \""Upload files\"" item, so I can't show the resulting image!\\nUsing an emulated stack. EMT's recursive stack space is limited. For the notebook with images see this page.\\nUsing pure FBSL's built-in graphics functions:\\nOutput: \\nThis simple recursive algorithm uses routines from Basic bitmap storage.\\nHere the target color paradigm is used. Again the matchdistance parameter can be tuned to ignore small differences that could come because of antialiasing.\\nUsage example excerpt (which on the test image will fill with green the inner black circle):\\nAn addition to code from the bitmap task:\\nAnd a test program. Works with code from read ppm and write ppm to pipe tasks. For input, it uses a version of the test file converted by the Go solution to \""Read an image through a pipe\"". For output it uses the trick from \""PPM conversion through a pipe\"" to write the .png suitable for uploading to RC.\\nThis code uses the Bitmap and Bitmap.RGB modules defined here.\\nHicEst color fill is via the decoration option of WRITE()\\nSolution:\\nUses getPixels and setPixels from Basic bitmap storage.\\nExample Usage:\\nThe following draws the same image as for the Tcl example image below.\\nUses definitions from Basic bitmap storage, Bresenham's line algorithm and Midpoint circle algorithm.\\nAlternative findcontig:\\nThe following alternative version of findcontig is less concise but is leaner, faster, works for n-dimensions and is not restricted to numerical arrays.\\nInput is the image, the starting node (x, y), the target color we want to fill, and the replacement color that will replace the target color. It implements a 4-way flood fill algorithm. For large images, the performance can be improved by drawing the scanlines instead of setting each pixel to the replacement color, or by working directly on the databuffer.\\nAnd here is an example of how to replace the white color with red from the sample image (with starting node (50, 50)):\\nInspired to  Python version.\\nLingo has built-in flood fill for image objects, so a custom implementation would be pointless:\\n","\\n# \""FloodFillClean.png\"" is name of input file\\n# [55,55] the x,y coordinate where fill starts\\n# (0,0,0,255) the target colour being filled( black in this example )\\n# (255,255,255,255) the final colour ( white in this case )\\nimg = FloodFill( \""FloodFillClean.png\"", [55,55], (0,0,0,255), (255,255,255,255) )\\n#The resulting image is saved as Filled.png\\nimg.save( \""Filled.png\"" )\\n"
"Python","Bitmap/Histogram","Extend the basic bitmap storage defined on this page to support dealing with image histograms. The image histogram contains for each luminance the count of image pixels having this luminance. Choosing a histogram representation take care about the data type used for the counts. It must have range of at least 0..NxM, where N is the image width and M is the image height.\\nTest task\\nHistogram is useful for many image processing operations. As an example, use it to convert an image into black and white art. The method works as follows:\\nUse  read/write ppm file, and grayscale image solutions.\\nHistogram of an image:\\nMedian of a histogram:\\nConversion of an image to black and white art:\\nThe given histogram must be freed with a simple free(histogram).\\nAn example of usage is the following code.\\nWhich reads from the file specified from the command line and outputs to the standard out the PPM B/W version of the input image. The input image can be of any format handled by ImageMagick (see Read image file through a pipe)\\nIt uses the grayscale_image from the Grayscale image Task. The loaded frog image is from the Color quantization Task.\\nFBSL volatiles and function call concatenation used heavily for brevity.\\n24-bpp P.O.T.-size BMP solution:\\nNote: luminance range is hard-encoded and is from 0 to 255. This could be enhanced.\\nExample:\\nHistogram and Threshold functions are be added to the Grmap type for this task:\\nDemonstration program computes the median:\\nFirst, an implementation of a black-and-white instance of Color. For simplicty, we use ASCII PBM for output instead of the raw format.\\nEvery instance of Color has a luminance method, so we don't need to convert an image to Gray to calculate its histogram.\\nSolution:\\nUsing toGray from Grayscale image.\\nExample Usage:\\nUse Lenna100.jpg for testing (read using the media/platimg addon and convert to ppm file).\\nRead ppm file, convert to black and white and write to a new ppm file using writeppm, readppm and toColor from the  read/write ppm file, and grayscale image solutions.\\nUses the image from the Percentage difference between images task as an example.\\nThis solution uses functions defined at:\\nRead ppm file#Lua,\\nWrite ppm file#Lua,\\nBasic bitmap storage#Lua,\\nGrayscale image#Lua.\\nmain:\\nUsing package Image\\nUses pieces from  Bitmap,  Write a PPM file and  Grayscale image tasks. Included here to make a complete, runnable program.\\nSee Lenna, and Lenna-bw images. (converted to .png as .ppm format is not widely supported).\\nRequires read_ppm() from Read_a_PPM_file, write_ppm() from Write_a_PPM_file.\\nUses lena.ppm, which you will have to find/download to demo/rosetta yourself.\\nIncluded as demo\\rosetta\\Bitmap_Histogram.exw, results may be verified with demo\\rosetta\\viewppm.exw\\nExample: \\n\\n\\nThe Image on the left is read in and the average luminosity calculated.\\nEvery pixel darker than average is painted black; brighter painted white.\\nThe black and white image on the right is then saved to the file system.\\n\\nAlso requires PureBasic solutions for Read a PPM file, Grayscale image, and Write a PPM file.\\nMakes use of the Pillow library (PIL) you can install it using pip. The code is probably not the fastest or the image I used (1960x1960) is just too big.\\n","from PIL import Image\\n\\n# Open the image\\nimage = Image.open(\""lena.jpg\"")\\n# Get the width and height of the image\\nwidth, height = image.size\\n# Calculate the amount of pixels\\namount = width * height\\n\\n# Total amount of greyscale\\ntotal = 0\\n# B/W image\\nbw_image = Image.new('L', (width, height), 0)\\n# Bitmap image\\nbm_image = Image.new('1', (width, height), 0)\\n\\nfor h in range(0, height):\\n    for w in range(0, width):\\n        r, g, b = image.getpixel((w, h))\\n\\n        greyscale = int((r + g + b) / 3)\\n        total += greyscale\\n\\n        bw_image.putpixel((w, h), gray_scale)\\n\\n# The average greyscale\\navg = total / amount\\n\\nblack = 0\\nwhite = 1\\n\\nfor h in range(0, height):\\n    for w in range(0, width):\\n        v = bw_image.getpixel((w, h))\\n\\n        if v >= avg:\\n            bm_image.putpixel((w, h), white)\\n        else:\\n            bm_image.putpixel((w, h), black)\\n\\nbw_image.show()\\nbm_image.show()"
"Python","Bitmap/PPM_conversion_through_a_pipe","Using the data storage type defined on this page for raster images, delegate writing a JPEG file through a pipe using the output_ppm function defined on this other page.\\nThere are various utilities that can be used for this task, for example: cjpeg (package \""jpeg-progs\"" on Linux), ppmtojpeg (package \""netpbm\"" on Linux), convert (from ImageMagick, multi-platform).\\nThis one uses the ImageMagick convert tool.\\nThe code that writes to the pipe is the same of output_ppm of course. A complete example is\\nIn order to make it working, you must link it with the raster image functions given by the codes here and here\\nUsing cjpeg:\\nIn order to provide a complete runnable example, we repeat bits of code from other relevant tasks and add code which pipes .ppm data to ImageMagick's 'convert' tool which then writes the corresponding .jpg file to disk.\\nThe Windows command line does not like quotes in the middle of text, so strings have been turned into character codes.\\n","\\n\""\""\""\\nAdapted from https://stackoverflow.com/questions/26937143/ppm-to-jpeg-jpg-conversion-for-python-3-4-1\\nRequires pillow-5.3.0 with Python 3.7.1 32-bit on Windows.\\nSample ppm graphics files from http://www.cs.cornell.edu/courses/cs664/2003fa/images/\\n\""\""\""\\n\\nfrom PIL import Image\\n\\nim = Image.open(\""boxes_1.ppm\"")\\nim.save(\""boxes_1.jpg\"")\\n"
"Python","Bitmap/Read_a_PPM_file","Using the data storage type defined on this page for raster images, read an image from a PPM file (binary P6 prefered).\\n(Read the definition of PPM file on Wikipedia.)\\nTask: Use write ppm file solution and grayscale image solution with this one in order to convert a color image to grayscale one.\\nThe implementation propagates Data_Error when the file format is incorrect. End_Error is propagated when the file end is prematurely met. The following example illustrates conversion of a color file to grayscale.\\nOnly ppm6 files supported.\\nIt is up to the caller to open the file and pass the handler to the function. So this code can be used in\\nRead image file through a pipe without modification. It only understands the P6 file format.\\nInterface:\\nImplementation:\\nThe following acts as a filter to convert a PPM file read from standard input into a PPM gray image, and it outputs the converted image to standard output (see Grayscale image, Write ppm file, and Raster graphics operations in general):\\nTested with this solution.\\nThe function read-ppm-image reads either a P6 or P3 file depending on the file contents. The package description assumes that you have the Basic bitmap storage#Common Lisp package.\\nTo read the feep.ppm file as shown on the description page for the ppm format use:\\nThe Image module contains a loadPPM6 function to load binary PPM images.\\n\\nUsage in accordance with Grayscale Task:\\nConverting an image to grayscale:\\nRead a colored PPM file, convert it to grayscale and write back to disk under a different name. Sanity checks are omitted for brevity.\\n24-bpp P6 PPM solution:\\n(This function is part of module RCImageIO, see Write ppm file)\\nNotes:\\nDemonstration program, also demonstrating functions from task Grayscale image:\\nThe definition of Bitmap.Netpbm.readNetpbm is given here.\\nThe above writes a PGM, not a PPM, since the image being output is in grayscale. If you actually want a gray PPM, convert the Image RealWorld Gray back to an Image RealWorld RGB first:\\nSolution:\\nUses makeRGB from Basic bitmap storage.\\nExample:\\nUsing utilities and file from Grayscale image and Write ppm file.\\nWrites a gray PPM file (a color format) which is bigger than necessary. A PGM file would be more appropriate.\\nFor convenience, we repeat the code for the class used in the Bitmap task here and integrate the code in the Grayscale image task within it.\\nNow function Bitmap has double signature. With two numbers make a bitmap,with all pixels white. With one number, expect that it is a file number and read file, and then return the bitmap.\\nand converting a given color file to grayscale:\\nsending the result to stdout allows to see the result without creating a temporary file sending it through a pipe to the display utility of ImageMagick:\\nThe read function in module \""BitmapIO.oz\"":\\nThe actual task:\\n\\nUses pieces from  Bitmap,  Write a PPM file and  Grayscale image tasks. Included here to make a complete, runnable program.\\nSee camelia, and camelia-gs images. (converted to .png as .ppm format is not widely supported).\\nBased on Euphoria, requires write_ppm() from Write_a_PPM_file, to_gray from Grayscale_image\\nRead a color image \""img.ppm\"", convert and write to \""img.pgm\"":\\nTo complete the task, the following code should be added to the above fragment and to the PureBasic solutions for Grayscale image and Write a PPM file\\nExtending the example given here\\n\\nThe input file   Lenna50.ppm   is a PPM format of\\nthe input file    Lenna50.jpg    used elsewhere on Rosetta Code.\\nThis REXX program handles alternative delimiters as well as comments within the PPM header.\\n","# With help from http://netpbm.sourceforge.net/doc/ppm.html\\n\\n# String masquerading as ppm file (version P3)\\nimport io\\n\\nppmtxt = '''P3\\n# feep.ppm\\n4 4\\n15\\n 0  0  0    0  0  0    0  0  0   15  0 15\\n 0  0  0    0 15  7    0  0  0    0  0  0\\n 0  0  0    0  0  0    0 15  7    0  0  0\\n15  0 15    0  0  0    0  0  0    0  0  0\\n'''\\n\\n\\ndef tokenize(f):\\n    for line in f:\\n        if line[0] != '#':\\n            for t in line.split():\\n                yield t\\n\\ndef ppmp3tobitmap(f):\\n    t = tokenize(f)\\n    nexttoken = lambda : next(t)\\n    assert 'P3' == nexttoken(), 'Wrong filetype'\\n    width, height, maxval = (int(nexttoken()) for i in range(3))\\n    bitmap = Bitmap(width, height, Colour(0, 0, 0))\\n    for h in range(height-1, -1, -1):\\n        for w in range(0, width):\\n            bitmap.set(w, h, Colour( *(int(nexttoken()) for i in range(3))))\\n\\n    return bitmap\\n    \\nprint('Original Colour PPM file')\\nprint(ppmtxt)\\nppmfile = io.StringIO(ppmtxt)\\nbitmap = ppmp3tobitmap(ppmfile)\\nprint('Grey PPM:')\\nbitmap.togreyscale()\\nppmfileout = io.StringIO('')\\nbitmap.writeppmp3(ppmfileout)\\nprint(ppmfileout.getvalue())\\n\\n\\n'''\\nThe print statements above produce the following output:\\n\\nOriginal Colour PPM file\\nP3\\n# feep.ppm\\n4 4\\n15\\n 0  0  0    0  0  0    0  0  0   15  0 15\\n 0  0  0    0 15  7    0  0  0    0  0  0\\n 0  0  0    0  0  0    0 15  7    0  0  0\\n15  0 15    0  0  0    0  0  0    0  0  0\\n\\nGrey PPM:\\nP3\\n# generated from Bitmap.writeppmp3\\n4 4\\n11\\n    0  0  0    0  0  0    0  0  0    4  4  4\\n    0  0  0   11 11 11    0  0  0    0  0  0\\n    0  0  0    0  0  0   11 11 11    0  0  0\\n    4  4  4    0  0  0    0  0  0    0  0  0\\n\\n'''"
"Python","Bitmap/Write_a_PPM_file","Using the data storage type defined on this page for raster images, write the image to a PPM file (binary P6 prefered). \\n(Read the definition of PPM file on Wikipedia.)\\nThe solution writes the image into an opened file. The file format might fail to work on certain OSes, because output might mangle control characters like LF, CR, FF, HT, VT etc. The OS might also limit the line length of a text file. In general it is a bad idea to mix binary and text output in one file. This solution uses stream I/O, which should be as portable as possible.\\n\\nThis is one file program which writes one color in each step :\\n\\nThis program writes whole array in one step :\\n\\nHere is a program which uses imglib library. One must create files imglib.h and imglib.c using code from category  Raster graphics operations. Start from  bitmap page\\nThis program writes whole array in one step.\\nInterface:\\nImplementation:\\nThis implementation uses a StreamWriter to write the header in text, then writes the pixel data in binary using a BinaryWriter.\\nThe Image module contains a savePPM6 function to save binary PPM images.\\nThe code for this task is incorporated into Basic bitmap storage#E.\\nWrites a bitmap to PPM file. Uses 24 bit color depth (color max value 255).\\nProcedure writing bitmap data storage:\\nThis code converts a Windows BMP to a PPM. Uses FBSL volatiles for brevity.\\n24-bpp P.O.T.-size BMP solution:\\nIt loads RCImageBasic module, which is defined here.\\nCode below writes 8-bit P6 format only. See Bitmap task for additional file needed to build working raster package.\\nDemonstration program. Note that it imports package raster. To build package raster, put code above in one file, put code from Bitmap task in another, and compile and link them into a Go package.\\nSolution:\\nExample:\\nUsing routines from Basic Bitmap Storage:\\nFor convenience, we repeat the code for the class used in the Bitmap task here.\\nAdded ToFile in group which return the function Bitmap. In this example we export using ToFile and get bytes (unsigned values) from buffer, and we export from outside, using getpixel and convert the RGB value to bytes (color returned as a negative number, so we have to invert before further process it)\\n","\\n# String masquerading as ppm file (version P3)\\nimport io\\nppmfileout = io.StringIO('')\\n\\ndef writeppmp3(self, f):\\n    self.writeppm(f, ppmformat='P3')\\n        \\ndef writeppm(self, f, ppmformat='P6'):\\n    assert ppmformat in ['P3', 'P6'], 'Format wrong'\\n    magic = ppmformat + '\\n'\\n    comment = '# generated from Bitmap.writeppm\\n'\\n    maxval = max(max(max(bit) for bit in row) for row in self.map)\\n    assert ppmformat == 'P3' or 0 <= maxval < 256, 'R,G,B must fit in a byte'\\n    if ppmformat == 'P6':\\n        fwrite = lambda s: f.write(bytes(s, 'UTF-8'))\\n        maxval = 255\\n    else:\\n        fwrite = f.write\\n        numsize=len(str(maxval))\\n    fwrite(magic)\\n    fwrite(comment)\\n    fwrite('%i %i\\n%i\\n' % (self.width, self.height, maxval))\\n    for h in range(self.height-1, -1, -1):\\n        for w in range(self.width):\\n            r, g, b = self.get(w, h)\\n            if ppmformat == 'P3':\\n                fwrite('   %*i %*i %*i' % (numsize, r, numsize, g, numsize, b))\\n            else:\\n                fwrite('%c%c%c' % (r, g, b))\\n        if ppmformat == 'P3':\\n            fwrite('\\n')\\n\\nBitmap.writeppmp3 = writeppmp3\\nBitmap.writeppm = writeppm\\n\\n# Draw something simple\\nbitmap = Bitmap(4, 4, black)\\nbitmap.fillrect(1, 0, 1, 2, white)\\nbitmap.set(3, 3, Colour(127, 0, 63))\\n# Write to the open 'file' handle\\nbitmap.writeppmp3(ppmfileout)\\n# Whats in the generated PPM file\\nprint(ppmfileout.getvalue())\\n\\n'''\\nThe print statement above produces the following output :\\n\\nP3\\n# generated from Bitmap.writeppmp3\\n4 4\\n255\\n     0   0   0     0   0   0     0   0   0   127   0  63\\n     0   0   0     0   0   0     0   0   0     0   0   0\\n     0   0   0   255 255 255     0   0   0     0   0   0\\n     0   0   0   255 255 255     0   0   0     0   0   0\\n\\n'''\\n\\n# Write a P6 file\\nppmfileout = open('tmp.ppm', 'wb')\\nbitmap.writeppm(ppmfileout)\\nppmfileout.close()\\n"
"Python","Bitwise_operations","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\n\\nWrite a routine to perform a bitwise AND, OR, and XOR on two integers, a bitwise NOT on the first integer, a left shift, right shift, right arithmetic shift, left rotate, and right rotate.\\nAll shifts and rotates should be done on the first integer with a shift/rotate amount of the second integer.\\nIf any operation is not available in your language, note it.\\n\\n","def bitwise(a, b):\\n        print 'a and b:', a & b\\n        print 'a or b:', a | b\\n        print 'a xor b:', a ^ b\\n        print 'not a:', ~a\\n        print 'a << b:', a << b # left shift\\n        print 'a >> b:', a >> b # arithmetic right shift"
"Python","Bitwise_operations","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\n\\nWrite a routine to perform a bitwise AND, OR, and XOR on two integers, a bitwise NOT on the first integer, a left shift, right shift, right arithmetic shift, left rotate, and right rotate.\\nAll shifts and rotates should be done on the first integer with a shift/rotate amount of the second integer.\\nIf any operation is not available in your language, note it.\\n\\n","# 8-bit bounded shift:\\nx = x << n & 0xff\\n# ditto for 16 bit:\\nx = x << n & 0xffff\\n# ... and 32-bit:\\nx = x << n & 0xffffffff\\n# ... and 64-bit:\\nx = x << n & 0xffffffffffffffff"
"Python","Bitwise_operations","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\n\\nWrite a routine to perform a bitwise AND, OR, and XOR on two integers, a bitwise NOT on the first integer, a left shift, right shift, right arithmetic shift, left rotate, and right rotate.\\nAll shifts and rotates should be done on the first integer with a shift/rotate amount of the second integer.\\nIf any operation is not available in your language, note it.\\n\\n","def bitstr(n, width=None):\\n   \""\""\""return the binary representation of n as a string and\\n      optionally zero-fill (pad) it to a given length\\n   \""\""\""\\n   result = list()\\n   while n:\\n      result.append(str(n%2))\\n      n = int(n/2)\\n   if (width is not None) and len(result) < width:\\n      result.extend(['0'] * (width - len(result)))\\n   result.reverse()\\n   return ''.join(result)\\n\\ndef mask(n):\\n   \""\""\""Return a bitmask of length n (suitable for masking against an\\n      int to coerce the size to a given length)\\n   \""\""\""\\n   if n >= 0:\\n       return 2**n - 1\\n   else:\\n       return 0\\n\\ndef rol(n, rotations=1, width=8):\\n    \""\""\""Return a given number of bitwise left rotations of an integer n,\\n       for a given bit field width.\\n    \""\""\""\\n    rotations %= width\\n    if rotations < 1:\\n        return n\\n    n &= mask(width) ## Should it be an error to truncate here?\\n    return ((n << rotations) & mask(width)) | (n >> (width - rotations))\\n\\ndef ror(n, rotations=1, width=8):\\n    \""\""\""Return a given number of bitwise right rotations of an integer n,\\n       for a given bit field width.\\n    \""\""\""\\n    rotations %= width\\n    if rotations < 1:\\n        return n\\n    n &= mask(width)\\n    return (n >> rotations) | ((n << (width - rotations)) & mask(width))"
"Python","Boolean_values","Show how to represent the boolean states \""true\"" and \""false\"" in a language.\\nIf other objects represent \""true\"" or \""false\"" in conditionals, note it.\\n\\n\\n11l defines a built-in data type Bool, which has two values represented by the constants 0B and 1B.\\nThe are no TRUE or FALSE constants in 360 Assembly; but an often used convention is :\\nA single bit represents true or false. By convention, 0 (cleared) is false, 1 (set) is true.\\nIn the following, \""bit\"" represents the direct address of any of the 256 directly accessible bits.\\nIn 8th, any non-zero number is true, as is the specific boolean value 'true'. Everything else evaluates as 'false' (including the boolean value, 'false')\\nSame as Boolean Values#Common Lisp.\\nAda has a predefined discrete type with the specification:\\nwith Boolean lattice and relational operations defined on it. See RM A.1.\\nALGOL 68 Enforces strong typing and so has few default coercions. The appropriate operators must be used to convert to and from bool[ean] and the following code demonstrates principle conversions:\\n",">>> True\\nTrue\\n>>> not True\\nFalse\\n>>> # As numbers\\n>>> False + 0\\n0\\n>>> True + 0\\n1\\n>>> False + 0j\\n0j\\n>>> True * 3.141\\n3.141\\n>>> # Numbers as booleans\\n>>> not 0\\nTrue\\n>>> not not 0\\nFalse\\n>>> not 1234\\nFalse\\n>>> bool(0.0)\\nFalse\\n>>> bool(0j)\\nFalse\\n>>> bool(1+2j)\\nTrue\\n>>> # Collections as booleans\\n>>> bool([])\\nFalse\\n>>> bool([None])\\nTrue\\n>>> 'I contain something' if (None,) else 'I am empty'\\n'I contain something'\\n>>> bool({})\\nFalse\\n>>> bool(\""\"")\\nFalse\\n>>> bool(\""False\"")\\nTrue"
"Python","Box_the_compass","There be many a land lubber that knows naught of the pirate ways and gives direction by degree!\\nThey know not how to box the compass!\\n\\n\\n\\n","majors   = 'north east south west'.split()\\nmajors   *= 2 # no need for modulo later\\nquarter1 = 'N,N by E,N-NE,NE by N,NE,NE by E,E-NE,E by N'.split(',')\\nquarter2 = [p.replace('NE','EN') for p in quarter1]\\n\\ndef degrees2compasspoint(d):\\n    d = (d % 360) + 360/64\\n    majorindex, minor = divmod(d, 90.)\\n    majorindex = int(majorindex)\\n    minorindex  = int( (minor*4) // 45 )\\n    p1, p2 = majors[majorindex: majorindex+2]\\n    if p1 in {'north', 'south'}:\\n        q = quarter1\\n    else:\\n        q = quarter2\\n    return q[minorindex].replace('N', p1).replace('E', p2).capitalize()\\n\\nif __name__ == '__main__':\\n    for i in range(33):\\n        d = i * 11.25\\n        m = i % 3\\n        if   m == 1: d += 5.62\\n        elif m == 2: d -= 5.62\\n        n = i % 32 + 1\\n        print( '%2i %-18s %7.2f°' % (n, degrees2compasspoint(d), d) )"
"Python","Brace_expansion","Brace expansion is a type of parameter expansion made popular by Unix shells, where it allows users to specify multiple similar string parameters without having to type them all out. E.g. the parameter enable_{audio,video} would be interpreted as if both enable_audio and enable_video had been specified.\\nWrite a function that can perform brace expansion on any input string, according to the following specification.\\nDemonstrate how it would be used, and that it passes the four test cases given below.\\nIn the input string, balanced pairs of braces containing comma-separated substrings (details below) represent alternations that specify multiple alternatives which are to appear at that position in the output. In general, one can imagine the information conveyed by the input string as a tree of nested alternations interspersed with literal substrings, as shown in the middle part of the following diagram:\\nThis tree can in turn be transformed into the intended list of output strings by, colloquially speaking, determining all the possible ways to walk through it from left to right while only descending into one branch of each alternation one comes across (see the right part of the diagram). When implementing it, one can of course combine the parsing and expansion into a single algorithm, but this specification discusses them separately for the sake of clarity.\\nExpansion of alternations can be more rigorously described by these rules:\\nParsing the input string involves some additional complexity to deal with escaped characters and \""incomplete\"" brace pairs:\\nFor every possible input string, your implementation should produce exactly the output which this specification mandates. Please comply with this even when it's inconvenient, to ensure that all implementations are comparable. However, none of the above should be interpreted as instructions (or even recommendations) for how to implement it. Try to come up with a solution that is idiomatic in your programming language. (See #Perl for a reference implementation.)\\n~/{Downloads,Pictures}/*.{jpg,gif,png}\\n~/Downloads/*.jpg\\n~/Downloads/*.gif\\n~/Downloads/*.png\\n~/Pictures/*.jpg\\n~/Pictures/*.gif\\n~/Pictures/*.png\\nIt{{em,alic}iz,erat}e{d,}, please.\\nItemized, please.\\nItemize, please.\\nItalicized, please.\\nItalicize, please.\\nIterated, please.\\nIterate, please.\\n{,{,gotta have{ ,\\, again\\, }}more }cowbell!\\ncowbell!\\nmore cowbell!\\ngotta have more cowbell!\\ngotta have\\, again\\, more cowbell!\\n{}} some }{,{\\\\{ edge, edge} \\,}{ cases, {here} \\\\\\\\\\}\\n{}} some }{,{\\\\ edge \\,}{ cases, {here} \\\\\\\\\\}\\n{}} some }{,{\\\\ edge \\,}{ cases, {here} \\\\\\\\\\}\\n","def getitem(s, depth=0):\\n    out = [\""\""]\\n    while s:\\n        c = s[0]\\n        if depth and (c == ',' or c == '}'):\\n            return out,s\\n        if c == '{':\\n            x = getgroup(s[1:], depth+1)\\n            if x:\\n                out,s = [a+b for a in out for b in x[0]], x[1]\\n                continue\\n        if c == '\\\\' and len(s) > 1:\\n            s, c = s[1:], c + s[1]\\n\\n        out, s = [a+c for a in out], s[1:]\\n\\n    return out,s\\n\\ndef getgroup(s, depth):\\n    out, comma = [], False\\n    while s:\\n        g,s = getitem(s, depth)\\n        if not s: break\\n        out += g\\n\\n        if s[0] == '}':\\n            if comma: return out, s[1:]\\n            return ['{' + a + '}' for a in out], s[1:]\\n\\n        if s[0] == ',':\\n            comma,s = True, s[1:]\\n\\n    return None\\n\\n# stolen cowbells from perl6 example\\nfor s in '''~/{Downloads,Pictures}/*.{jpg,gif,png}\\nIt{{em,alic}iz,erat}e{d,}, please.\\n{,{,gotta have{ ,\\, again\\, }}more }cowbell!\\n{}} some }{,{\\\\\\\\{ edge, edge} \\,}{ cases, {here} \\\\\\\\\\\\\\\\\\}'''.split('\\n'):\\n    print \""\\n\\t\"".join([s] + getitem(s)[0]) + \""\\n\"""
"Python","Break_OO_privacy","Show how to access private or protected members of a class in an object-oriented language from outside an instance of the class, without calling non-private or non-protected members of the class as a proxy.\\nThe intent is to show how a debugger, serializer, or other meta-programming tool might access information that is barred by normal access methods to the object but can nevertheless be accessed from within the language by some provided escape hatch or reflection mechanism.\\nThe intent is specifically not to demonstrate heroic measures such as peeking and poking raw memory.\\nNote that cheating on your type system is almost universally regarded\\nas unidiomatic at best, and poor programming practice at worst.\\nNonetheless, if your language intentionally maintains a double-standard for OO privacy, here's where you can show it off.\\nSimilar to C++, ABAP allows the declaration of friends which can be both classes and interfaces. All subclasses of friend classes are automatically friends of the source class. For example if classA (source) has classB as a friend and classC is a subclass of classB then classC is a friend of classA. Similarly all implementing classes of friend interfaces are friends of the source class. Also all interfaces which contain the befriended interface as a component are friends of the source class.\\nOne of the great criticisms of Pascal was \""there is no escape\"". The reason was that sometimes you have to convert the incompatible. For this purpose, Ada has the generic function Unchecked_Conversion, that can be used for such purposes\\nas breaking OO privacy. We start with the package that holds the \""secret\"":\\nSecond, the package that provides the \""hack\"" into Confidential_Stuff:\\nThe output shows that C holds, surprise, surprise, the default password:\\n",">>> class MyClassName:\\n	__private = 123\\n	non_private = __private * 2\\n\\n	\\n>>> mine = MyClassName()\\n>>> mine.non_private\\n246\\n>>> mine.__private\\nTraceback (most recent call last):\\n  File \""<pyshell#23>\"", line 1, in <module>\\n    mine.__private\\nAttributeError: 'MyClassName' object has no attribute '__private'\\n>>> mine._MyClassName__private\\n123\\n>>> "
"Python","Brownian_tree","\\nGenerate and draw a   Brownian Tree.\\n\\nA Brownian Tree is generated as a result of an initial seed, followed by the interaction of two processes.\\nBecause of the lax rules governing the random nature of the particle's placement and motion, no two resulting trees are really expected to be the same, or even necessarily have the same general shape. \\nTakes a little while to run, be patient.\\nRequires the GDI+ Standard Library by Tic\\n\\nBold text\\nThis version writes the image as Portable Bit Map to stdout and doesn't move already set particles.\\nRun-time about 12.4 seconds with SIDE=600, NUM_PARTICLES=10000.\\n\\nFor an animated version based on this same code see: Brownian tree/C++ animated\\nWhen the random walk lands on a set pixel it sets the pixel at the previous position.\\nAn alternate method sets a pixel if the current position is vacant and at least one neighbour is set.\\nThe former produces denser trees than the latter. If compiled with SBCL, providing a command line argument will invoke the latter method.\\nRequires Quicklisp library manager and the CL-GD package for producing PNG images.\\nWorld side = 600, num_particles = 10_000, cropped (about 20 seconds run-time with dmd, about 4.3 seconds with ldc2):\\nThis example sets four spawn points, one in each corner of the image, giving the result a vague x-shaped appearance. For visual reasons, movement is restricted to diagonals. So be careful if you change the seed or spawns — they should all fall on the same diagonal.\\n","import pygame, sys, os\\nfrom pygame.locals import *\\nfrom random import randint\\npygame.init()\\n\\nMAXSPEED = 15\\nSIZE = 3\\nCOLOR = (45, 90, 45)\\nWINDOWSIZE = 400\\nTIMETICK = 1\\nMAXPART = 50\\n\\nfreeParticles = pygame.sprite.Group()\\ntree = pygame.sprite.Group()\\n\\nwindow = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))\\npygame.display.set_caption(\""Brownian Tree\"")\\n\\nscreen = pygame.display.get_surface()\\n\\n\\nclass Particle(pygame.sprite.Sprite):\\n    def __init__(self, vector, location, surface):\\n        pygame.sprite.Sprite.__init__(self)\\n        self.vector = vector\\n        self.surface = surface\\n        self.accelerate(vector)\\n        self.add(freeParticles)\\n        self.rect = pygame.Rect(location[0], location[1], SIZE, SIZE)\\n        self.surface.fill(COLOR, self.rect)\\n\\n    def onEdge(self):\\n        if self.rect.left <= 0:\\n            self.vector = (abs(self.vector[0]), self.vector[1])\\n        elif self.rect.top <= 0:\\n            self.vector = (self.vector[0], abs(self.vector[1]))\\n        elif self.rect.right >= WINDOWSIZE:\\n            self.vector = (-abs(self.vector[0]), self.vector[1])\\n        elif self.rect.bottom >= WINDOWSIZE:\\n            self.vector = (self.vector[0], -abs(self.vector[1]))\\n\\n    def update(self):\\n        if freeParticles in self.groups():\\n            self.surface.fill((0,0,0), self.rect)\\n            self.remove(freeParticles)\\n            if pygame.sprite.spritecollideany(self, freeParticles):\\n                self.accelerate((randint(-MAXSPEED, MAXSPEED), \\n                                 randint(-MAXSPEED, MAXSPEED)))\\n                self.add(freeParticles)\\n            elif pygame.sprite.spritecollideany(self, tree):\\n                self.stop()\\n            else:\\n                self.add(freeParticles)\\n                \\n            self.onEdge()\\n\\n            if (self.vector == (0,0)) and tree not in self.groups():\\n                self.accelerate((randint(-MAXSPEED, MAXSPEED), \\n                                 randint(-MAXSPEED, MAXSPEED)))\\n            self.rect.move_ip(self.vector[0], self.vector[1])\\n        self.surface.fill(COLOR, self.rect)\\n\\n    def stop(self):\\n        self.vector = (0,0)\\n        self.remove(freeParticles)\\n        self.add(tree)\\n\\n    def accelerate(self, vector):\\n        self.vector = vector\\n\\nNEW = USEREVENT + 1\\nTICK = USEREVENT + 2\\n\\npygame.time.set_timer(NEW, 50)\\npygame.time.set_timer(TICK, TIMETICK)\\n\\n\\ndef input(events):\\n    for event in events:\\n        if event.type == QUIT:\\n            sys.exit(0)\\n        elif event.type == NEW and (len(freeParticles) < MAXPART):\\n            Particle((randint(-MAXSPEED,MAXSPEED),\\n                      randint(-MAXSPEED,MAXSPEED)),\\n                     (randint(0, WINDOWSIZE), randint(0, WINDOWSIZE)), \\n                     screen)\\n        elif event.type == TICK:\\n            freeParticles.update()\\n\\n\\nhalf = WINDOWSIZE/2\\ntenth = WINDOWSIZE/10\\n\\nroot = Particle((0,0),\\n                (randint(half-tenth, half+tenth), \\n                 randint(half-tenth, half+tenth)), screen)\\nroot.stop()\\n\\nwhile True:\\n    input(pygame.event.get())\\n    pygame.display.flip()"
"Python","Bulls_and_cows","\\nCreate a four digit random number from the digits   1   to   9,   without duplication.\\nThe program should:\\n\\nThe score is computed as:\\n\\n\\nOutput:\\nGUI implementation; the prompt for a guess includes a list of all past guesses and their scores.\\nThe following function contains the code to check how many bulls and cows there are.\\nTo handle I/O, we use functions named say (which simply outputs a string) and prompt (which takes a prompt string to display to the user and returns a line of input, without a trailing newline). These require platform-specific implementations. Here's how they can be implemented for the SpiderMonkey shell:\\nWe can now solve the task using say and prompt:\\n","'''\\n Bulls and cows. A game pre-dating, and similar to, Mastermind.\\n'''\\n\\nimport random\\n\\ndigits = '123456789'\\nsize = 4\\nchosen = ''.join(random.sample(digits,size))\\n#print chosen # Debug\\nprint '''I have chosen a number from %s unique digits from 1 to 9 arranged in a random order.\\nYou need to input a %i digit, unique digit number as a guess at what I have chosen''' % (size, size)\\nguesses = 0\\nwhile True:\\n    guesses += 1\\n    while True:\\n        # get a good guess\\n        guess = raw_input('\\nNext guess [%i]: ' % guesses).strip()\\n        if len(guess) == size and \\\\n           all(char in digits for char in guess) \\\\n           and len(set(guess)) == size:\\n            break\\n        print \""Problem, try again. You need to enter %i unique digits from 1 to 9\"" % size\\n    if guess == chosen:\\n        print '\\nCongratulations you guessed correctly in',guesses,'attempts'\\n        break\\n    bulls = cows = 0\\n    for i in range(size):\\n        if guess[i] == chosen[i]:\\n            bulls += 1\\n        elif guess[i] in chosen:\\n            cows += 1\\n    print '  %i Bulls\\n  %i Cows' % (bulls, cows)"
"Python","Bulls_and_cows/Player","Write a player of the Bulls and Cows game, rather than a scorer. The player should give intermediate answers that respect the scores to previous attempts.\\nOne method is to generate a list of all possible numbers that could be the answer, then to prune the list by keeping only those numbers that would give an equivalent score to how your last guess was scored. Your next guess can be any number from the pruned list.\\nEither you guess correctly or run out of numbers to guess, which indicates a problem with the scoring.\\n\\n\\nbulls_player.adb:\\noutput:\\nOutput:\\nExample output:-\\nOutput:\\n","from itertools import permutations\\nfrom random import shuffle\\n\\ntry:\\n    raw_input\\nexcept:\\n    raw_input = input\\ntry:\\n    from itertools import izip\\nexcept:\\n    izip = zip\\n    \\ndigits = '123456789'\\nsize = 4\\n\\ndef parse_score(score):\\n    score = score.strip().split(',')\\n    return tuple(int(s.strip()) for s in score)\\n\\ndef scorecalc(guess, chosen):\\n    bulls = cows = 0\\n    for g,c in izip(guess, chosen):\\n        if g == c:\\n            bulls += 1\\n        elif g in chosen:\\n            cows += 1\\n    return bulls, cows\\n\\nchoices = list(permutations(digits, size))\\nshuffle(choices)\\nanswers = []\\nscores  = []\\n\\nprint (\""Playing Bulls & Cows with %i unique digits\\n\"" % size)\\n       \\nwhile True:\\n    ans = choices[0]\\n    answers.append(ans)\\n    #print (\""(Narrowed to %i possibilities)\"" % len(choices))\\n    score = raw_input(\""Guess %2i is %*s. Answer (Bulls, cows)? \""\\n                      % (len(answers), size, ''.join(ans)))\\n    score = parse_score(score)\\n    scores.append(score)\\n    #print(\""Bulls: %i, Cows: %i\"" % score)\\n    found =  score == (size, 0)\\n    if found:\\n        print (\""Ye-haw!\"")\\n        break\\n    choices = [c for c in choices if scorecalc(c, ans) == score]\\n    if not choices:\\n        print (\""Bad scoring? nothing fits those scores you gave:\"")\\n        print ('  ' +\\n               '\\n  '.join(\""%s -> %s\"" % (''.join(an),sc)\\n                           for an,sc in izip(answers, scores)))\\n        break"
"Python","Caesar_cipher","\\nImplement a Caesar cipher, both encoding and decoding. \\nThe key is an integer from 1 to 25.\\nThis cipher rotates (either towards left or right) the letters of the alphabet (A to Z).\\nThe encoding replaces each letter with the 1st to 25th next letter in the alphabet (wrapping Z to A).\\nSo key 2 encrypts \""HI\"" to \""JK\"", but key 20 encrypts \""HI\"" to \""BC\"".\\nThis simple \""mono-alphabetic substitution cipher\"" provides almost no security, because an attacker who has the encoded message can either use frequency analysis to guess the key, or just try all 25 keys.\\nCaesar cipher is identical to Vigenère cipher with a key of length 1. \\nAlso, Rot-13 is identical to Caesar cipher with key 13.\\n\\n\\n","def caesar(s, k, decode = False):\\n	if decode: k = 26 - k\\n	return \""\"".join([chr((ord(i) - 65 + k) % 26 + 65)\\n				for i in s.upper()\\n				if ord(i) >= 65 and ord(i) <= 90 ])\\n\\nmsg = \""The quick brown fox jumped over the lazy dogs\""\\nprint msg\\nenc = caesar(msg, 11)\\nprint enc\\nprint caesar(enc, 11, decode = True)"
"Python","Caesar_cipher","\\nImplement a Caesar cipher, both encoding and decoding. \\nThe key is an integer from 1 to 25.\\nThis cipher rotates (either towards left or right) the letters of the alphabet (A to Z).\\nThe encoding replaces each letter with the 1st to 25th next letter in the alphabet (wrapping Z to A).\\nSo key 2 encrypts \""HI\"" to \""JK\"", but key 20 encrypts \""HI\"" to \""BC\"".\\nThis simple \""mono-alphabetic substitution cipher\"" provides almost no security, because an attacker who has the encoded message can either use frequency analysis to guess the key, or just try all 25 keys.\\nCaesar cipher is identical to Vigenère cipher with a key of length 1. \\nAlso, Rot-13 is identical to Caesar cipher with key 13.\\n\\n\\n","import string\\ndef caesar(s, k, decode = False):\\n   if decode: k = 26 - k\\n   return s.translate(\\n       string.maketrans(\\n           string.ascii_uppercase + string.ascii_lowercase,\\n           string.ascii_uppercase[k:] + string.ascii_uppercase[:k] +\\n           string.ascii_lowercase[k:] + string.ascii_lowercase[:k]\\n           )\\n       )\\nmsg = \""The quick brown fox jumped over the lazy dogs\""\\nprint msg\\nenc = caesar(msg, 11)\\nprint enc\\nprint caesar(enc, 11, decode = True)"
"Python","Caesar_cipher","\\nImplement a Caesar cipher, both encoding and decoding. \\nThe key is an integer from 1 to 25.\\nThis cipher rotates (either towards left or right) the letters of the alphabet (A to Z).\\nThe encoding replaces each letter with the 1st to 25th next letter in the alphabet (wrapping Z to A).\\nSo key 2 encrypts \""HI\"" to \""JK\"", but key 20 encrypts \""HI\"" to \""BC\"".\\nThis simple \""mono-alphabetic substitution cipher\"" provides almost no security, because an attacker who has the encoded message can either use frequency analysis to guess the key, or just try all 25 keys.\\nCaesar cipher is identical to Vigenère cipher with a key of length 1. \\nAlso, Rot-13 is identical to Caesar cipher with key 13.\\n\\n\\n","import string\\ndef caesar(s, k = 13, decode = False, *, memo={}):\\n  if decode: k = 26 - k\\n  k = k % 26\\n  table = memo.get(k)\\n  if table is None:\\n    table = memo[k] = str.maketrans(\\n                        string.ascii_uppercase + string.ascii_lowercase,\\n                        string.ascii_uppercase[k:] + string.ascii_uppercase[:k] +\\n                        string.ascii_lowercase[k:] + string.ascii_lowercase[:k])\\n  return s.translate(table)"
"Python","Caesar_cipher","\\nImplement a Caesar cipher, both encoding and decoding. \\nThe key is an integer from 1 to 25.\\nThis cipher rotates (either towards left or right) the letters of the alphabet (A to Z).\\nThe encoding replaces each letter with the 1st to 25th next letter in the alphabet (wrapping Z to A).\\nSo key 2 encrypts \""HI\"" to \""JK\"", but key 20 encrypts \""HI\"" to \""BC\"".\\nThis simple \""mono-alphabetic substitution cipher\"" provides almost no security, because an attacker who has the encoded message can either use frequency analysis to guess the key, or just try all 25 keys.\\nCaesar cipher is identical to Vigenère cipher with a key of length 1. \\nAlso, Rot-13 is identical to Caesar cipher with key 13.\\n\\n\\n","\\nfrom string import ascii_uppercase as abc\\n\\ndef caesar(s, k, decode = False):\\n    trans = dict(zip(abc, abc[(k,26-k)[decode]:] + abc[:(k,26-k)[decode]]))\\n    return ''.join(trans[L] for L in s.upper() if L in abc)\\n\\nmsg = \""The quick brown fox jumped over the lazy dogs\""\\nprint(caesar(msg, 11))\\nprint(caesar(caesar(msg, 11), 11, True))\\n"
"Python","Calculating_the_value_of_e","Calculate the value of   e.\\n\\n(e   is also known as   Euler's number   and   Napier's constant.)\\n\\nSee details: Calculating the value of e\\n\\n","import math\\n#Implementation of Brother's formula\\ne0 = 0\\ne = 2\\nn = 0\\nfact = 1\\nwhile(e-e0 > 1e-15):\\n	e0 = e\\n	n += 1\\n	fact *= 2*n*(2*n+1)\\n	e += (2.*n+2)/fact\\n\\nprint \""Computed e = \""+str(e)\\nprint \""Real e = \""+str(math.e)\\nprint \""Error = \""+str(math.e-e)\\nprint \""Number of iterations = \""+str(n)"
"Python","Calculating_the_value_of_e","Calculate the value of   e.\\n\\n(e   is also known as   Euler's number   and   Napier's constant.)\\n\\nSee details: Calculating the value of e\\n\\n","from itertools import (accumulate)\\nfrom functools import (reduce)\\nfrom operator import (mul)\\n\\n\\n# eApprox :: () -> Float\\ndef eApprox():\\n    return reduce(\\n        lambda a, x: a + 1 / x,\\n        scanl(mul)(1)(\\n            range(1, 18)\\n        ),\\n        0\\n    )\\n\\n\\n# main :: IO ()\\ndef main():\\n    print(\\n        eApprox()\\n    )\\n\\n\\n# GENERIC ABSTRACTIONS ------------------------------------\\n\\n# scanl is like reduce, but returns a succession of\\n# intermediate values, building from the left.\\n# See, for example, under `scan` in the Lists chapter of\\n# the language-independent Bird & Wadler 1988.\\n\\n# scanl :: (b -> a -> b) -> b -> [a] -> [b]\\ndef scanl(f):\\n    return lambda a: lambda xs: (\\n        accumulate([a] + list(xs), f)\\n    )\\n\\n\\nmain()"
"Python","Call_a_foreign-language_function","Show how a foreign language function can be called from the language.\\n\\nAs an example, consider calling functions defined in the C language. Create a string containing \""Hello World!\"" of the string type typical to the language. Pass the string content to C's strdup. The content can be copied if necessary. Get the result from strdup and print it using language means. Do not forget to free the result of strdup (allocated in the heap).\\n\\n\\n\\nThe designers of Algol 68 made it extremely hard to incorporate code written in other languages. To be fair, this was a long time ago when such considerations weren't thought important and one should be careful to apply Hanlon's razor.\\nThe entry below is wildly non-portable, inefficient, violates the spirit of the specification and is just plain sick. However, it gives the correct results with Algol 68 Genie on Linux and, I claim, meets the letter of the spec. It also omits most of the error checking which should be present in production code.\\nNote that I chose a non-trivial library function because the suggested strdup() doesn't really demonstrate the technique all that well.\\n","import ctypes\\nlibc = ctypes.CDLL(\""/lib/libc.so.6\"")\\nlibc.strcmp(\""abc\"", \""def\"")     # -1\\nlibc.strcmp(\""hello\"", \""hello\"") #  0"
"Python","Call_a_function","Demonstrate the different syntax and semantics provided for calling a function.\\n\\nThis may include:\\n\\nThis task is not about defining functions.\\n\\nDue to assembler, argument are passed by reference.\\nWith:\\nIf you do not want to use the CALL macro instruction and for a link-edited object-module:\\nIf you call a link-edited object-module:\\nIf you call an load-module at execution time:\\nSee First-Class Functions for an example of first-class functions in ALGOL 68.\\nSee Partial Function Application for an example of partial function application in ALGOL 68.\\nSee Optional Parameters for an example of optional parameters in Algol 68.\\nSee Named Parameters for an example of named parameters in Algol 68.\\nAntLang provides two ways to apply a function.\\nOne way is infix application.\\nInfix application is right associative, so x f y g z means x f (y g z) and not (x f y) g z.\\nYou can break this rule using parenthesis.\\nThe other way is prefix application.\\nThe awk interpreter reads the entire script prior to processing, so functions can be called from sections of code appearing before the definition.\\nIn awk, scalar values are passed by value, but arrays are passed by reference. Note that if a function has no arguments, then empty parentheses are required.\\nThe awk extraction and reporting language does not support the use of named parameters.\\nIn Axe, up to six arguments are passed as the variables r₁ through r₆. As with all variables in Axe, these exist in the global scope, which makes nested function calls and recursion quite difficult.\\nSince arguments are simply global variables, they are always optional and can be omitted from right to left.\\nSomewhat similar to TI-83 BASIC, the last evaluated expression becomes the return value of the function. However, this is distinct from the Ans variable. Return values can be captured just like any other expression.\\nUser-defined functions can be distinguished from language-defined functions by the fact that language-defined function names are composed of atomic tokens (usually with built-in parentheses) whereas user-defined function names are composed of individual characters. Also, because only uppercase letters are available by default in the OS, most user-defined names are all uppercase while language-defined names are mixed case.\\nBatch files do not have a traditional \""function\"" system like OOP languages, however this is the closest thing to it. The only difference between a block of code and a function is the way method you choose to invoke it. It's also worth noting that all batch files can be called from any other batch file, performing a function. A function should be put somewhere in the code where it will not be parsed unless the script is redirected there.\\nBBC BASIC distinguishes between functions (which return one value), procedures (which may return an arbitrary number of values including zero), and subroutines. Functions can be built-in or user-defined.\\nA call to a built-in function (for example, the square root function) is an expression:\\nThe parentheses can often be omitted:\\nThe name of a user-defined function must begin with FN. A call to it is also an expression:\\n(The sigils $ and % identify the variables' types.)\\nA function that takes no arguments can be called omitting the parentheses:\\nThe name of a procedure must begin with PROC. A call to it is a statement, not an expression:\\nIf it has arguments, they come in parentheses just as with a function:\\nNote that you cannot tell from this syntax which of the variables bar$, baz%, and quux are arguments provided to the procedure and which of them are return values from it. You have to look at where it is defined:\\nSubroutines are provided for compatibility with older, unstructured dialects of BASIC; otherwise they are never really used. They require statements to be numbered, and they can neither receive arguments nor return values: they can only manipulate global variables. The GOSUB and RETURN statements in fact mirror assembly language 'jump to subroutine' and 'return from subroutine' instructions quite closely.\\nStrictly speaking, all Bracmat functions receive at least one argument. But empty strings are valid expressions, so you can do\\nor\\nBoth function calls pass the right and side of the $ or ' operator. This is in fact still something: an empty string.\\nThe $ operator always evaluates its right hand side before passing it to the function, while the ' does not. Therefore it is slightly faster to use the functionName' variant.\\nBracmat passes exactly one argument to a function, called arg. The argument can be any Bracmat expression. In patterns, if a function call expression is a pattern component, a second argument sjt is added, the part of the subject that the pattern component is going trying to match.\\nThere is no special syntax for that. It is up to the programmer to define a datastructure with a variable part, e.g., a list.\\nSame answer.\\nThere is no special syntax for that. You could pass a list of (name.value) pairs.\\nA f...\\nYou can do\\nThe ; marks the end of a Bracmat statement.\\n(Copied from JavaScript:) Bracmat functions are first-class citizens; they can be stored in variables and passed as arguments. Assigning to a variable yourfunc can be done in a few ways. The most common one is\\nIf there is already a function myfunc that you want to assign to yourfunc as well, do\\nNotice that the returned value can be any evaluated expression.\\nYou cannot list built-in functions that are implemented directly in C. Nor can such functions be passed as arguments or assigned to variables. There are also a number of built-in functions that are written in Bracmat. They are nothing special and can be deleted or redefined. You can see a list of all currently defined functions that are written in Bracmat with the function call cat'.\\nYou can ignore the return value of a function myfunc as follows:\\nBut notice that if myfunc fails, the above expression returns the value produced by myfunc! To also ignore the success/failure of a function, do\\nValues are passed by reference, or by value if the reference counter, which is a very small integer, overflows. Most values are immutable, so for those there is no practical difference between passing by reference or value. The single exception of a mutable value is always passed by reference, and has an enormous reference counter. (The binary operator = introduces a mutable value and can be used for an object oriented style of programming.)\\nThere is no special syntax for that, but you can write a function that e.g., can take a list with one or with two elements and that returns a function in the first case.\\nOutput:\\n","def no_args():\\n    pass\\n# call\\nno_args()\\n\\ndef fixed_args(x, y):\\n    print('x=%r, y=%r' % (x, y))\\n# call\\nfixed_args(1, 2)        # x=1, y=2\\n\\n## Can also called them using the parameter names, in either order:\\nfixed_args(y=2, x=1)\\n\\n## Can also \""apply\"" fixed_args() to a sequence:\\nmyargs=(1,2) # tuple\\nfixed_args(*myargs)\\n\\ndef opt_args(x=1):\\n    print(x)\\n# calls\\nopt_args()              # 1\\nopt_args(3.141)         # 3.141\\n\\ndef var_args(*v):\\n    print(v)\\n# calls	\\nvar_args(1, 2, 3)       # (1, 2, 3)\\nvar_args(1, (2,3))      # (1, (2, 3))\\nvar_args()              # ()\\n\\n## Named arguments\\nfixed_args(y=2, x=1)    # x=1, y=2\\n\\n## As a statement\\nif 1:\\n    no_args()\\n\\n## First-class within an expression\\nassert no_args() is None\\n\\ndef return_something():\\n    return 1\\nx = return_something()\\n\\ndef is_builtin(x):\\n	print(x.__name__ in dir(__builtins__))\\n# calls\\nis_builtin(pow)         # True\\nis_builtin(is_builtin)  # False\\n\\n# Very liberal function definition\\n\\ndef takes_anything(*args, **kwargs):\\n    for each in args:\\n        print(each)\\n    for key, value in sorted(kwargs.items()):\\n        print(\""%s:%s\"" % (key, value))\\n    # Passing those to another, wrapped, function:\\n    wrapped_fn(*args, **kwargs)\\n    # (Function being wrapped can have any parameter list\\n    # ... that doesn't have to match this prototype)\\n\\n## A subroutine is merely a function that has no explicit\\n## return statement and will return None.\\n\\n## Python uses \""Call by Object Reference\"".\\n## See, for example, http://www.python-course.eu/passing_arguments.php\\n\\n## For partial function application see:\\n##   http://rosettacode.org/wiki/Partial_function_application#Python"
"Python","Call_a_function_in_a_shared_library","Show how to call a function in a shared library (without dynamically linking to it at compile-time). In particular, show how to call the shared library function if the library is available, otherwise use an internal equivalent function.\\nThis is a special case of calling a foreign language function where the focus is close to the ABI level and not at the normal API level.\\n\\n\\nThe following solution calls MessageBox from Windows' dynamic library user32.dll. It does not use Win32 bindings, which would be meaningless, because MessageBox is already there. Instead of that it links statically to kernel32.dll, which required to load anything under Windows. From there it uses LoadLibrary to load user32.dll and then GetProcAddress to get the MessageBox entry point there. Note how Windows mangles names of functions in the import libraries. So \""LoadLibrary\"" becomes \""[email protected]\"", which is its real name. \""A\"" means ASCII. Once address of MessageBox is obtained it is converted to a pointer to a function that has an interface corresponding to it. Note Windows' call convention, which is stdcall.\\nHere we are using the dl library statically (-ldl switch upon linking) and Xlib dynamically (libX11.so). The function dlopen loads a library. The function dlsym looks up for an entry point there. From libX11.so, first XOpenDisplay is called to open an X11 display, which name is in the DISPLAY environment variable. Then XDisplayWidth of the display is obtained an printed into the standard output.\\ndllhost.ahk\\ndllclient.ahk\\n","import ctypes\\n  \\nuser32_dll = ctypes.cdll.LoadLibrary('User32.dll')\\nprint user32_dll.GetDoubleClickTime()"
"Python","Call_a_function_in_a_shared_library","Show how to call a function in a shared library (without dynamically linking to it at compile-time). In particular, show how to call the shared library function if the library is available, otherwise use an internal equivalent function.\\nThis is a special case of calling a foreign language function where the focus is close to the ABI level and not at the normal API level.\\n\\n\\nThe following solution calls MessageBox from Windows' dynamic library user32.dll. It does not use Win32 bindings, which would be meaningless, because MessageBox is already there. Instead of that it links statically to kernel32.dll, which required to load anything under Windows. From there it uses LoadLibrary to load user32.dll and then GetProcAddress to get the MessageBox entry point there. Note how Windows mangles names of functions in the import libraries. So \""LoadLibrary\"" becomes \""[email protected]\"", which is its real name. \""A\"" means ASCII. Once address of MessageBox is obtained it is converted to a pointer to a function that has an interface corresponding to it. Note Windows' call convention, which is stdcall.\\nHere we are using the dl library statically (-ldl switch upon linking) and Xlib dynamically (libX11.so). The function dlopen loads a library. The function dlsym looks up for an entry point there. From libX11.so, first XOpenDisplay is called to open an X11 display, which name is in the DISPLAY environment variable. Then XDisplayWidth of the display is obtained an printed into the standard output.\\ndllhost.ahk\\ndllclient.ahk\\n",">>> import ctypes\\n>>> # libc = ctypes.cdll.msvcrt # Windows\\n>>> # libc = ctypes.CDLL('libc.dylib') # Mac\\n>>> libc = ctypes.CDLL('libc.so') # Linux and most other *nix\\n>>> libc.printf(b'hi there, %s\\n', b'world')\\nhi there, world.\\n17"
"Python","Call_a_function_in_a_shared_library","Show how to call a function in a shared library (without dynamically linking to it at compile-time). In particular, show how to call the shared library function if the library is available, otherwise use an internal equivalent function.\\nThis is a special case of calling a foreign language function where the focus is close to the ABI level and not at the normal API level.\\n\\n\\nThe following solution calls MessageBox from Windows' dynamic library user32.dll. It does not use Win32 bindings, which would be meaningless, because MessageBox is already there. Instead of that it links statically to kernel32.dll, which required to load anything under Windows. From there it uses LoadLibrary to load user32.dll and then GetProcAddress to get the MessageBox entry point there. Note how Windows mangles names of functions in the import libraries. So \""LoadLibrary\"" becomes \""[email protected]\"", which is its real name. \""A\"" means ASCII. Once address of MessageBox is obtained it is converted to a pointer to a function that has an interface corresponding to it. Note Windows' call convention, which is stdcall.\\nHere we are using the dl library statically (-ldl switch upon linking) and Xlib dynamically (libX11.so). The function dlopen loads a library. The function dlsym looks up for an entry point there. From libX11.so, first XOpenDisplay is called to open an X11 display, which name is in the DISPLAY environment variable. Then XDisplayWidth of the display is obtained an printed into the standard output.\\ndllhost.ahk\\ndllclient.ahk\\n","\\n>>> from cffi import FFI\\n>>> ffi = FFI()\\n>>> ffi.cdef(\""\""\""\\n...     int printf(const char *format, ...);   // copy-pasted from the man page\\n... \""\""\"")\\n>>> C = ffi.dlopen(None)                     # loads the entire C namespace\\n>>> arg = ffi.new(\""char[]\"", b\""world\"")         # equivalent to C code: char arg[] = \""world\"";\\n>>> C.printf(b\""hi there, %s.\\n\"", arg)         # call printf\\nhi there, world.\\n17"
"Python","Call_an_object_method","In object-oriented programming a method is a function associated with a particular class or object. In most forms of object oriented implementations methods can be static, associated with the class itself; or instance, associated with an instance of a class.\\nShow how to call a static or class method, and an instance method of a class.\\nAda is a language based on strict typing. Nevertheless, since Ada 95 (the first major revision of the language), Ada also includes the concepts of a class. Types may be tagged, and for each tagged type T there is an associated type T'Class. If you define a method as \""procedure Primitive(Self: T)\"", the actual parameter Self must be of type T, exactly, and the method Primitive will be called, well, statically. This may be surprising, if you are used to other object-oriented languages.\\nIf you define a method as \""prodedure Dynamic(Self: T'Class)\"", the actual parameter can be either T or any of its descendents. Now, if you call Self.Primitive within the procedure Dynamic, it will be dispatching, i.e., it will call the primitive function matching the type of Self (i.e., either T or any of its subtype). This is what you would expect in many other object-oriented languages.\\nFinally, a static method can be defined as a subprogram within the same package that holds the object type and the other methods.\\nSpecify the class My_Class, with one primitive subprogram, one dynamic subprogram and a static subprogram:\\nImplement the package:\\nSpecify and implement a subclass of My_Class:\\nThe main program, making the dynamic and static calls:\\n","class MyClass(object):\\n	@classmethod\\n	def myClassMethod(self, x):\\n		pass\\n	@staticmethod\\n	def myStaticMethod(x):\\n		pass\\n	def myMethod(self, x):\\n		return 42 + x\\n\\nmyInstance = MyClass()\\n\\n# Instance method\\nmyInstance.myMethod(someParameter)\\n# A method can also be retrieved as an attribute from the class, and then explicitly called on an instance:\\nMyClass.myMethod(myInstance, someParameter)\\n\\n\\n# Class or static methods\\nMyClass.myClassMethod(someParameter)\\nMyClass.myStaticMethod(someParameter)\\n# You can also call class or static methods on an instance, which will simply call it on the instance's class\\nmyInstance.myClassMethod(someParameter)\\nmyInstance.myStaticMethod(someParameter)"
"Python","Canny_edge_detector","A possible algorithm consists of the following steps:\\nThe following program reads an 8 bits per pixel grayscale BMP file and saves the result to `out.bmp'. Compile with `-lm'.\\nThis version retains some of the style of the original C version. This code is faster than the C version, even with the DMD compiler. This version loads and saves PGM images, using the module of the Grayscale image Task.\\n\\n\\nThe example image for this program is the color photograph of a steam engine taken from the Wikipedia article linked to in the task description.\\nAfter applying the Canny edge detector, the resulting image is similar to but not quite the same as the Wikipedia image, probably due to differences in the parameters used though a 5×5 Gaussian filter is used in both cases.\\nNote that on Linux the extension of the example image file name needs to be changed from .PNG to .png in order for the library used to recognize it.\\nIn this solution images are represented as 2D arrays of pixels, with first and second axes representing down and right respectively. Each processing step has a specific pixel representation. In the original and Gaussian-filtered images, array elements represent monochromatic intensity values as numbers ranging from 0 (black) to 255 (white). In the intensity gradient image, gradient values are vectors, and are represented as complex numbers, with real and imaginary components representing down and right respectively. Detected edge and non-edge points are represented as ones and zeros respectively. An edge is a set of connected edge points (points adjacent horizontally, vertically, or diagonally are considered to be connected). In the final image, each edge is represented by assigning its set of points a common unique value. The above implementation solves the 'inner problem' of Canny Edge Detection in the J language, with no external dependencies. J's Qt IDE provides additional support including interfaces to image file formats, graphic displays, and the user. The following code exercises these featuresThe file 'valve.png' referenced in this code is from one of several Wikipedia articles on edge detection. It can be viewed at [https://upload.wikimedia.org/wikipedia/commons/2/2e/Valve_gaussian_%282%29.PNG]Mathematica uses canny edge detection by default. This seems so cheaty next to all of these giant answers...\\nThere is a built-in function, edge, that has Canny Edge Detection as one of its options.\\nIn Python, Canny edge detection would normally be done using scikit-image or OpenCV-Python. Here is an approach using numpy/scipy:\\n","#!/bin/python\\nimport numpy as np\\nfrom scipy.ndimage.filters import convolve, gaussian_filter\\nfrom scipy.misc import imread, imshow\\n	\\ndef CannyEdgeDetector(im, blur = 1, highThreshold = 91, lowThreshold = 31):\\n	im = np.array(im, dtype=float) #Convert to float to prevent clipping values\\n \\n	#Gaussian blur to reduce noise\\n	im2 = gaussian_filter(im, blur)\\n\\n	#Use sobel filters to get horizontal and vertical gradients\\n	im3h = convolve(im2,[[-1,0,1],[-2,0,2],[-1,0,1]]) \\n	im3v = convolve(im2,[[1,2,1],[0,0,0],[-1,-2,-1]])\\n\\n	#Get gradient and direction\\n	grad = np.power(np.power(im3h, 2.0) + np.power(im3v, 2.0), 0.5)\\n	theta = np.arctan2(im3v, im3h)\\n	thetaQ = (np.round(theta * (5.0 / np.pi)) + 5) % 5 #Quantize direction\\n\\n	#Non-maximum suppression\\n	gradSup = grad.copy()\\n	for r in range(im.shape[0]):\\n		for c in range(im.shape[1]):\\n			#Suppress pixels at the image edge\\n			if r == 0 or r == im.shape[0]-1 or c == 0 or c == im.shape[1] - 1:\\n				gradSup[r, c] = 0\\n				continue\\n			tq = thetaQ[r, c] % 4\\n\\n			if tq == 0: #0 is E-W (horizontal)\\n				if grad[r, c] <= grad[r, c-1] or grad[r, c] <= grad[r, c+1]:\\n					gradSup[r, c] = 0\\n			if tq == 1: #1 is NE-SW\\n				if grad[r, c] <= grad[r-1, c+1] or grad[r, c] <= grad[r+1, c-1]:\\n					gradSup[r, c] = 0\\n			if tq == 2: #2 is N-S (vertical)\\n				if grad[r, c] <= grad[r-1, c] or grad[r, c] <= grad[r+1, c]:\\n					gradSup[r, c] = 0\\n			if tq == 3: #3 is NW-SE\\n				if grad[r, c] <= grad[r-1, c-1] or grad[r, c] <= grad[r+1, c+1]:\\n					gradSup[r, c] = 0\\n\\n	#Double threshold\\n	strongEdges = (gradSup > highThreshold)\\n\\n	#Strong has value 2, weak has value 1\\n	thresholdedEdges = np.array(strongEdges, dtype=np.uint8) + (gradSup > lowThreshold)\\n\\n	#Tracing edges with hysteresis	\\n	#Find weak edge pixels near strong edge pixels\\n	finalEdges = strongEdges.copy()\\n	currentPixels = []\\n	for r in range(1, im.shape[0]-1):\\n		for c in range(1, im.shape[1]-1):	\\n			if thresholdedEdges[r, c] != 1:\\n				continue #Not a weak pixel\\n			\\n			#Get 3x3 patch	\\n			localPatch = thresholdedEdges[r-1:r+2,c-1:c+2]\\n			patchMax = localPatch.max()\\n			if patchMax == 2:\\n				currentPixels.append((r, c))\\n				finalEdges[r, c] = 1\\n\\n	#Extend strong edges based on current pixels\\n	while len(currentPixels) > 0:\\n		newPix = []\\n		for r, c in currentPixels:\\n			for dr in range(-1, 2):\\n				for dc in range(-1, 2):\\n					if dr == 0 and dc == 0: continue\\n					r2 = r+dr\\n					c2 = c+dc\\n					if thresholdedEdges[r2, c2] == 1 and finalEdges[r2, c2] == 0:\\n						#Copy this weak pixel to final result\\n						newPix.append((r2, c2))\\n						finalEdges[r2, c2] = 1\\n		currentPixels = newPix\\n\\n	return finalEdges\\n\\nif __name__==\""__main__\"":\\n	im = imread(\""test.jpg\"", mode=\""L\"") #Open image, convert to greyscale\\n	finalEdges = CannyEdgeDetector(im)\\n	imshow(finalEdges)"
"Python","Cantor_set","Draw Cantor set.\\nSee details: Cantor set\\n\\n","WIDTH = 81\\nHEIGHT = 5\\n\\nlines=[]\\ndef cantor(start, len, index):\\n    seg = len / 3\\n    if seg == 0:\\n        return None\\n    for it in xrange(HEIGHT-index):\\n        i = index + it\\n        for jt in xrange(seg):\\n            j = start + seg + jt\\n            pos = i * WIDTH + j\\n            lines[pos] = ' '\\n    cantor(start,           seg, index + 1)\\n    cantor(start + seg * 2, seg, index + 1)\\n    return None\\n\\nlines = ['*'] * (WIDTH*HEIGHT)\\ncantor(0, WIDTH, 1)\\n\\nfor i in xrange(HEIGHT):\\n    beg = WIDTH * i\\n    print ''.join(lines[beg : beg+WIDTH])"
"Python","Cantor_set","Draw Cantor set.\\nSee details: Cantor set\\n\\n","from itertools import (chain, repeat)\\nfrom functools import (reduce)\\n\\n\\n# cantor :: [(Bool, Int)] -> [(Bool, Int)]\\ndef cantor(xs):\\n    def go(tpl):\\n        (bln, n) = tpl\\n        m = n // 3\\n        return [\\n            (True, m), (False, m), (True, m)\\n        ] if bln and (1 < n) else [tpl]\\n    return concatMap(go)(xs)\\n\\n\\n# cantorLines :: Int -> String\\ndef cantorLines(n):\\n    m = n - 1\\n    return '\\n'.join(\\n        [showCantor(x) for x in (\\n            reduce(\\n                lambda a, f: a + [f(a[-1])],\\n                repeat(cantor, m),\\n                [[(True, 3 ** m)]]\\n            )\\n        )]\\n    )\\n\\n\\n# showCantor :: [(Bool, Int)] -> String\\ndef showCantor(xs):\\n    return ''.join(\\n        concatMap(lambda tpl: tpl[1] * ('█' if tpl[0] else ' '))(\\n            xs\\n        )\\n    )\\n\\n\\n# main :: IO ()\\ndef main():\\n    print (\\n        cantorLines(5)\\n    )\\n\\n\\n# GENERIC -------------------------------------------------------------\\n\\n\\n# concatMap :: (a -> [b]) -> [a] -> [b]\\ndef concatMap(f):\\n    return lambda xs: list(\\n        chain.from_iterable(\\n            map(f, xs)\\n        )\\n    )\\n\\n\\nif __name__ == '__main__':\\n    main()"
"Python","Cantor_set","Draw Cantor set.\\nSee details: Cantor set\\n\\n","from itertools import (chain, islice)\\n\\n\\n# main :: IO ()\\ndef main():\\n    print (\\n        cantorLines(5)\\n    )\\n\\n\\n# cantorLines :: Int -> String\\ndef cantorLines(n):\\n    return '\\n'.join(\\n        [''.join(x) for x in islice(\\n            iterate(cantor)(\\n                [3 ** (n - 1) * '█']\\n            ), n\\n        )]\\n    )\\n\\n\\n# cantor :: [String] -> [String]\\ndef cantor(xs):\\n    def go(s):\\n        m = len(s) // 3\\n        blocks = s[0:m]\\n        return [\\n            blocks, m * ' ', blocks\\n        ] if '█' == s[0] else [s]\\n    return concatMap(go)(xs)\\n\\n\\n# GENERIC -------------------------------------------------\\n\\n\\n# concatMap :: (a -> [b]) -> [a] -> [b]\\ndef concatMap(f):\\n    return lambda xs: list(\\n        chain.from_iterable(\\n            map(f, xs)\\n        )\\n    )\\n\\n\\n# iterate :: (a -> a) -> a -> Gen [a]\\ndef iterate(f):\\n    def go(x):\\n        v = x\\n        while True:\\n            yield(v)\\n            v = f(v)\\n    return lambda x: go(x)\\n\\n\\n# MAIN ---\\nmain()"
"Python","Cantor_set","Draw Cantor set.\\nSee details: Cantor set\\n\\n","from itertools import (islice, chain)\\nfrom functools import (reduce)\\nfrom fractions import Fraction\\n\\n\\n# cantor :: Generator [[(Fraction, Fraction)]]\\ndef cantor():\\n    def go(xy):\\n        (x, y) = xy\\n        third = Fraction(y - x, 3)\\n        return [(x, x + third), (y - third, y)]\\n\\n    xs = [(0, 1)]\\n    while True:\\n        yield xs\\n        xs = concatMap(go)(xs)\\n\\n\\n# main :: IO ()\\ndef main():\\n    xs = list(islice(cantor(), 4))\\n    w = max(xy[1].denominator for xy in xs[-1])\\n    print(\\n        '\\n'.join(map(fractionLists, xs)),\\n        '\\n'\\n    )\\n    print(\\n        '\\n'.join(map(intervalBars(w), xs))\\n    )\\n\\n\\n# fractionLists :: [(Fraction, Fraction)] -> String\\ndef fractionLists(xs):\\n    def go(xy):\\n        return ', '.join(map(showRatio, xy))\\n    return ' '.join('(' + go(x) + ')' for x in xs)\\n\\n\\n# intervalBars :: [(Fraction, Fraction)] -> String\\ndef intervalBars(w):\\n    def go(xs):\\n        def show(a, tpl):\\n            [x, y] = [int(w * r) for r in tpl]\\n            return (\\n                y,  # Accumulator - end of previous interval\\n                (' ' * (x - a)) + ('█' * (y - x))  # A gap + an interval bar\\n            )\\n        return mapAccumL(show)(0)(xs)\\n    return lambda xs: ''.join(go(xs)[1])\\n\\n\\n# GENERIC -----------------------------------------------------\\n\\n# concatMap :: (a -> [b]) -> [a] -> [b]\\ndef concatMap(f):\\n    return lambda xs: list(\\n        chain.from_iterable(\\n            map(f, xs)\\n        )\\n    )\\n\\n\\n# mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\\ndef mapAccumL(f):\\n    def go(a, x):\\n        tpl = f(a[0], x)\\n        return (tpl[0], a[1] + [tpl[1]])\\n    return lambda acc: lambda xs: (\\n        reduce(go, xs, (acc, []))\\n    )\\n\\n\\n# showRatio :: Ratio -> String\\ndef showRatio(r):\\n    d = r.denominator\\n    return str(r.numerator) + (\\n        '/' + str(d) if 1 != d else ''\\n    )\\n\\n\\nmain()"
"Python","Card_shuffles","\\n\\nThere are many techniques that people use to shuffle cards for card games. Some are more effective than others.\\n\\nImplement the (seemingly) more common techniques of the riffle shuffle and overhand shuffle for   n   iterations.\\n\\nImplementing playing cards is not necessary if it would be easier to implement these shuffling methods for generic collections.\\nWhere possible, compare this to a standard/built-in shuffling procedure.\\nOne iteration of the riffle shuffle is defined as:\\n\\nOne iteration of the overhand shuffle is defined as:\\n\\nImplement other methods described in the Wikipedia\\narticle:   card shuffling.\\nAllow for \""human errors\"" of imperfect cutting and interleaving.\\n\\n","import random\\n\\ndef riffleShuffle(va, flips):\\n    nl = va\\n    for n in range(flips):\\n        #cut the deck at the middle +/- 10%, remove the second line of the formula for perfect cutting\\n        cutPoint = len(nl)/2 + random.choice([-1, 1]) * random.randint(0, len(va)/10)\\n\\n        # split the deck\\n        left = nl[0:cutPoint]\\n        right = nl[cutPoint:]\\n\\n        del nl[:]\\n        while (len(left) > 0 and len(right) > 0):\\n            #allow for imperfect riffling so that more than one card can come form the same side in a row\\n            #biased towards the side with more cards\\n            #remove the if and else and brackets for perfect riffling\\n            if (random.uniform(0, 1) >= len(left) / len(right) / 2):\\n                nl.append(right.pop(0))\\n            else:\\n                nl.append(left.pop(0))\\n        if (len(left) > 0):\\n            nl = nl + left\\n        if (len(right) > 0):\\n            nl = nl + right\\n    return nl\\n\\ndef overhandShuffle(va, passes):\\n    mainHand = va\\n    for n in range(passes):\\n        otherHand = []\\n        while (len(mainHand) > 0):\\n            #cut at up to 20% of the way through the deck\\n            cutSize = random.randint(0, len(va) / 5) + 1\\n            temp = []\\n\\n            #grab the next cut up to the end of the cards left in the main hand\\n            i=0\\n            while (i 0):\\n                temp.append(mainHand.pop(0))\\n                i = i + 1\\n\\n            #add them to the cards in the other hand, sometimes to the front sometimes to the back\\n            if (random.uniform(0, 1) >= 0.1):\\n                #front most of the time\\n                otherHand = temp + otherHand\\n            else:\\n                otherHand = otherHand + temp\\n        #move the cards back to the main hand\\n        mainHand = otherHand\\n    return mainHand\\n\\nprint \""Riffle shuffle\""\\nnums = [x+1 for x in range(21)]\\nprint nums\\nprint riffleShuffle(nums, 10)\\nprint\\n\\nprint \""Riffle shuffle\""\\nnums = [x+1 for x in range(21)]\\nprint nums\\nprint riffleShuffle(nums, 1)\\nprint\\n\\nprint \""Overhand shuffle\""\\nnums = [x+1 for x in range(21)]\\nprint nums\\nprint overhandShuffle(nums, 10)\\nprint\\n\\nprint \""Overhand shuffle\""\\nnums = [x+1 for x in range(21)]\\nprint nums\\nprint overhandShuffle(nums, 1)\\nprint\\n\\nprint \""Library shuffle\""\\nnums = [x+1 for x in range(21)]\\nprint nums\\nrandom.shuffle(nums)\\nprint nums\\nprint"
"Python","Carmichael_3_strong_pseudoprimes","A lot of composite numbers can be separated from primes by Fermat's Little Theorem, but there are some that completely confound it.\\nThe   Miller Rabin Test   uses a combination of Fermat's Little Theorem and Chinese Division Theorem to overcome this.\\nThe purpose of this task is to investigate such numbers using a method based on   Carmichael numbers,   as suggested in   Notes by G.J.O Jameson March 2010.\\n\\nFind Carmichael numbers of the form:\\nwhere    (Prime1 < Prime2 < Prime3)    for all    Prime1    up to   61.\\n(See page 7 of   Notes by G.J.O Jameson March 2010   for solutions.)\\n\\nFor a given   \\n\\n\\n\\nP\\nr\\ni\\nm\\n\\ne\\n\\n1\\n\\n\\n\\n\\n{\\displaystyle Prime_{1}}\\n\\n\\n\\n","class Isprime():\\n    '''\\n    Extensible sieve of Eratosthenes\\n    \\n    >>> isprime.check(11)\\n    True\\n    >>> isprime.multiples\\n    {2, 4, 6, 8, 9, 10}\\n    >>> isprime.primes\\n    [2, 3, 5, 7, 11]\\n    >>> isprime(13)\\n    True\\n    >>> isprime.multiples\\n    {2, 4, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 18, 20, 21, 22}\\n    >>> isprime.primes\\n    [2, 3, 5, 7, 11, 13, 17, 19]\\n    >>> isprime.nmax\\n    22\\n    >>> \\n    '''\\n    multiples = {2}\\n    primes = [2]\\n    nmax = 2\\n    \\n    def __init__(self, nmax):\\n        if nmax > self.nmax:\\n            self.check(nmax)\\n\\n    def check(self, n):\\n        if type(n) == float:\\n            if not n.is_integer(): return False\\n            n = int(n)\\n        multiples = self.multiples\\n        if n <= self.nmax:\\n            return n not in multiples\\n        else:\\n            # Extend the sieve\\n            primes, nmax = self.primes, self.nmax\\n            newmax = max(nmax*2, n)\\n            for p in primes:\\n                multiples.update(range(p*((nmax + p + 1) // p), newmax+1, p))\\n            for i in range(nmax+1, newmax+1):\\n                if i not in multiples:\\n                    primes.append(i)\\n                    multiples.update(range(i*2, newmax+1, i))\\n            self.nmax = newmax\\n            return n not in multiples\\n\\n    __call__ = check\\n            \\n        \\ndef carmichael(p1):\\n    ans = []\\n    if isprime(p1):\\n        for h3 in range(2, p1):\\n            g = h3 + p1\\n            for d in range(1, g):\\n                if (g * (p1 - 1)) % d == 0 and (-p1 * p1) % h3 == d % h3:\\n                    p2 = 1 + ((p1 - 1)* g // d)\\n                    if isprime(p2):\\n                        p3 = 1 + (p1 * p2 // h3)\\n                        if isprime(p3):\\n                            if (p2 * p3) % (p1 - 1) == 1:\\n                                #print('%i X %i X %i' % (p1, p2, p3))\\n                                ans += [tuple(sorted((p1, p2, p3)))]\\n    return ans\\n                \\nisprime = Isprime(2)\\n \\nans = sorted(sum((carmichael(n) for n in range(62) if isprime(n)), []))\\nprint(',\\n'.join(repr(ans[i:i+5])[1:-1] for i in range(0, len(ans)+1, 5)))"
"Python","Cartesian_product_of_two_or_more_lists","Show one or more idiomatic ways of generating the Cartesian product of two arbitrary lists in your language.\\nDemonstrate that your function/method correctly returns:\\nand, in contrast:\\nAlso demonstrate, using your function/method, that the product of an empty list with any other list is empty.\\nFor extra credit, show or write a function returning the n-ary product of an arbitrary number of lists, each of arbitrary length. Your function might, for example, accept a single argument which is itself a list of lists, and return the n-ary product of those lists.\\nUse your n-ary Cartesian product function to show the following products:\\n\\n","import itertools\\n\\ndef cp(lsts):\\n    return list(itertools.product(*lsts))\\n\\nif __name__ == '__main__':\\n    from pprint import pprint as pp\\n    \\n    for lists in [[[1,2],[3,4]], [[3,4],[1,2]], [[], [1, 2]], [[1, 2], []],\\n                  ((1776, 1789),  (7, 12), (4, 14, 23), (0, 1)),\\n                  ((1, 2, 3), (30,), (500, 100)),\\n                  ((1, 2, 3), (), (500, 100))]:\\n        print(lists, '=<*>')\\n        pp(cp(lists), indent=2)\\n"
"Python","Cartesian_product_of_two_or_more_lists","Show one or more idiomatic ways of generating the Cartesian product of two arbitrary lists in your language.\\nDemonstrate that your function/method correctly returns:\\nand, in contrast:\\nAlso demonstrate, using your function/method, that the product of an empty list with any other list is empty.\\nFor extra credit, show or write a function returning the n-ary product of an arbitrary number of lists, each of arbitrary length. Your function might, for example, accept a single argument which is itself a list of lists, and return the n-ary product of those lists.\\nUse your n-ary Cartesian product function to show the following products:\\n\\n","ap(map(Tuple, xs))"
"Python","Cartesian_product_of_two_or_more_lists","Show one or more idiomatic ways of generating the Cartesian product of two arbitrary lists in your language.\\nDemonstrate that your function/method correctly returns:\\nand, in contrast:\\nAlso demonstrate, using your function/method, that the product of an empty list with any other list is empty.\\nFor extra credit, show or write a function returning the n-ary product of an arbitrary number of lists, each of arbitrary length. Your function might, for example, accept a single argument which is itself a list of lists, and return the n-ary product of those lists.\\nUse your n-ary Cartesian product function to show the following products:\\n\\n","# nAryCartProd :: [[a], [b], [c] ...] -<*> [(a, b, c ...)]\\ndef nAryCartProd(xxs):\\n    return foldl1(cartesianProduct)(\\n        xxs\\n    )"
"Python","Cartesian_product_of_two_or_more_lists","Show one or more idiomatic ways of generating the Cartesian product of two arbitrary lists in your language.\\nDemonstrate that your function/method correctly returns:\\nand, in contrast:\\nAlso demonstrate, using your function/method, that the product of an empty list with any other list is empty.\\nFor extra credit, show or write a function returning the n-ary product of an arbitrary number of lists, each of arbitrary length. Your function might, for example, accept a single argument which is itself a list of lists, and return the n-ary product of those lists.\\nUse your n-ary Cartesian product function to show the following products:\\n\\n","# Two lists -<*> list of tuples\\n\\n\\n# cartesianProduct :: [a] -<*> [b] -<*> [(a, b)]\\ndef cartesianProduct(xs):\\n    return ap(map(Tuple, xs))\\n\\n\\n# List of lists -<*> list of tuples\\n\\n# nAryCartProd :: [[a], [b], [c] ...] -<*> [(a, b, c ...)]\\ndef nAryCartProd(xxs):\\n    return foldl1(cartesianProduct)(\\n        xxs\\n    )\\n\\n\\n# main :: IO ()\\ndef main():\\n    # Product of lists of different types\\n    print (\\n        'Product of two lists of different types:'\\n    )\\n    print(\\n        cartesianProduct(['a', 'b', 'c'])(\\n            [1, 2]\\n        )\\n    )\\n\\n    # TESTS OF PRODUCTS OF TWO LISTS\\n\\n    print(\\n        '\\nSpecified tests of products of two lists:'\\n    )\\n    print(\\n        cartesianProduct([1, 2])([3, 4]),\\n        ' <--<*> ',\\n        cartesianProduct([3, 4])([1, 2])\\n    )\\n    print (\\n        cartesianProduct([1, 2])([]),\\n        ' <--<*> ',\\n        cartesianProduct([])([1, 2])\\n    )\\n\\n    # TESTS OF N-ARY CARTESIAN PRODUCTS\\n\\n    print('\\nSpecified tests of nAry products:')\\n    for xs in nAryCartProd([[1776, 1789], [7, 12], [4, 14, 23], [0, 1]]):\\n        print(xs)\\n\\n    for xs in (\\n        map_(nAryCartProd)(\\n            [\\n                [[1, 2, 3], [30], [500, 100]],\\n                [[1, 2, 3], [], [500, 100]]\\n            ]\\n        )\\n    ):\\n        print(\\n            xs\\n        )\\n\\n# GENERIC -------------------------------------------------\\n\\n\\n# Applicative function for lists\\n\\n# ap (<*<*>) :: [(a -<*> b)] -<*> [a] -<*> [b]\\ndef ap(fs):\\n    return lambda xs: foldl(\\n        lambda a: lambda f: a + foldl(\\n            lambda a: lambda x: a + [f(x)])([])(xs)\\n    )([])(fs)\\n\\n\\n# foldl :: (a -<*> b -<*> a) -<*> a -<*> [b] -<*> a\\ndef foldl(f):\\n    def go(v, xs):\\n        a = v\\n        for x in xs:\\n            a = f(a)(x)\\n        return a\\n    return lambda acc: lambda xs: go(acc, xs)\\n\\n\\n# foldl1 :: (a -<*> a -<*> a) -<*> [a] -<*> a\\ndef foldl1(f):\\n    return lambda xs: foldl(f)(xs[0])(\\n        xs[1:]\\n    ) if xs else None\\n\\n\\n# map :: (a -<*> b) -<*> [a] -<*> [b]\\ndef map_(f):\\n    return lambda xs: list(map(f, xs))\\n\\n\\n# Tuple :: a -<*> b -<*> (a, b)\\ndef Tuple(x):\\n    return lambda y: (\\n        x + (y,)\\n    ) if tuple is type(x) else (x, y)\\n\\n\\n# TEST ----------------------------------------------------\\nif __name__ == '__main__':\\n    main()"
"Python","Case-sensitivity_of_identifiers","Three dogs (Are there three dogs or one dog?) is a code snippet used to illustrate the lettercase sensitivity of the programming language. For a case-sensitive language, the identifiers dog, Dog and DOG are all different and we should get the output:\\nFor a language that is lettercase insensitive, we get the following output:\\n\\n\\n11l identifiers are case sensitive.\\ncase insensitive\\nOutput:\\nTranslation of Algol W. Agena is case sensitive, as this example demonstrates. Tested with Agena 2.9.5 Win32\\n",">>> dog = 'Benjamin'; Dog = 'Samba'; DOG = 'Bernie'\\n>>> print ('The three dogs are named ',dog,', ',Dog,', and ',DOG)\\nThe three dogs are named  Benjamin ,  Samba , and  Bernie\\n>>> "
"Python","Casting_out_nines","\\nWrite a procedure (say \\n\\n\\n\\n\\n\\nc\\no\\n9\\n\\n\\n(\\nx\\n)\\n\\n\\n{\\displaystyle {\\mathit {co9}}(x)}\\n\\n) which implements Casting Out Nines as described by returning the checksum for \\n\\n\\n\\nx\\n\\n\\n{\\displaystyle x}\\n\\n. Demonstrate the procedure using the examples given there, or others you may consider lucky.\\nNotwithstanding past Intel microcode errors, checking computer calculations like this would not be sensible. To find a computer use for your procedure:\\nDemonstrate that your procedure can be used to generate or filter a range of numbers with the property \\n\\n\\n\\n\\n\\nc\\no\\n9\\n\\n\\n(\\nk\\n)\\n=\\n\\n\\nc\\no\\n9\\n\\n\\n(\\n\\nk\\n\\n2\\n\\n\\n)\\n\\n\\n{\\displaystyle {\\mathit {co9}}(k)={\\mathit {co9}}(k^{2})}\\n\\n and show that this subset is a small proportion of the range and contains all the Kaprekar in the range.\\nConsidering this MathWorld page, produce a efficient algorithm based on the more mathematical treatment of Casting Out Nines, and realizing:\\nDemonstrate your algorithm by generating or filtering a range of numbers with the property \\n\\n\\n\\nk\\n%\\n(\\n\\n\\nB\\na\\ns\\ne\\n\\n\\n−\\n1\\n)\\n==\\n(\\n\\nk\\n\\n2\\n\\n\\n)\\n%\\n(\\n\\n\\nB\\na\\ns\\ne\\n\\n\\n−\\n1\\n)\\n\\n\\n{\\displaystyle k\\%({\\mathit {Base}}-1)==(k^{2})\\%({\\mathit {Base}}-1)}\\n\\n and show that this subset is a small proportion of the range and contains all the Kaprekar in the range.\\n\\nThe program uses two ASSIST macros (XDECO,XPRNT) to keep the code as short as possible.\\n","# Casting out Nines\\n#\\n# Nigel Galloway: June 27th., 2012,\\n#\\ndef CastOut(Base=10, Start=1, End=999999):\\n  ran = [y for y in range(Base-1) if y%(Base-1) == (y*y)%(Base-1)]\\n  x,y = divmod(Start, Base-1)\\n  while True:\\n    for n in ran:\\n      k = (Base-1)*x + n\\n      if k < Start:\\n        continue\\n      if k > End:\\n        return\\n      yield k\\n    x += 1\\n\\nfor V in CastOut(Base=16,Start=1,End=255):\\n  print(V, end=' ')"
"Python","Catalan_numbers","\\nCatalan numbers are a sequence of numbers which can be defined directly:\\nOr recursively:\\nOr alternatively (also recursive):\\n\\nImplement at least one of these algorithms and print out the first 15 Catalan numbers with each.\\nMemoization   is not required, but may be worth the effort when using the second method above.\\n\\n\\n","from math import factorial\\nimport functools\\n\\ndef memoize(func):\\n    cache = {}\\n    def memoized(key):\\n        # Returned, new, memoized version of decorated function\\n        if key not in cache:\\n            cache[key] = func(key)\\n        return cache[key]\\n    return functools.update_wrapper(memoized, func)\\n\\n\\n@memoize\\ndef fact(n):\\n    return factorial(n)\\n\\ndef cat_direct(n):\\n    return fact(2*n) // fact(n + 1) // fact(n)\\n\\n@memoize    \\ndef catR1(n):\\n    return ( 1 if n == 0\\n             else sum( catR1(i) * catR1(n - 1 - i)\\n                       for i in range(n) ) )\\n\\n@memoize    \\ndef catR2(n):\\n    return ( 1 if n == 0\\n             else ( ( 4 * n - 2 ) * catR2( n - 1) ) // ( n + 1 ) )\\n\\n\\nif __name__ == '__main__':\\n    def pr(results):\\n        fmt = '%-10s %-10s %-10s'\\n        print ((fmt % tuple(c.__name__ for c in defs)).upper())\\n        print (fmt % (('='*10,)*3))\\n        for r in zip(*results):\\n            print (fmt % r)\\n\\n\\n    defs = (cat_direct, catR1, catR2)\\n    results = [ tuple(c(i) for i in range(15)) for c in defs ]\\n    pr(results)"
"Python","Catamorphism","Reduce is a function or method that is used to take the values in an array or a list and apply a function to successive members of the list to produce (or reduce them to), a single value.\\n\\nShow how reduce (or foldl or foldr etc), work (or would be implemented) in your language.\\n\\n\\n",">>> # Python 2.X\\n>>> from operator import add\\n>>> listoflists = [['the', 'cat'], ['sat', 'on'], ['the', 'mat']]\\n>>> help(reduce)\\nHelp on built-in function reduce in module __builtin__:\\n\\nreduce(...)\\n    reduce(function, sequence[, initial]) -> value\\n    \\n    Apply a function of two arguments cumulatively to the items of a sequence,\\n    from left to right, so as to reduce the sequence to a single value.\\n    For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates\\n    ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items\\n    of the sequence in the calculation, and serves as a default when the\\n    sequence is empty.\\n\\n>>> reduce(add, listoflists, [])\\n['the', 'cat', 'sat', 'on', 'the', 'mat']\\n>>> "
"Python","Catamorphism","Reduce is a function or method that is used to take the values in an array or a list and apply a function to successive members of the list to produce (or reduce them to), a single value.\\n\\nShow how reduce (or foldl or foldr etc), work (or would be implemented) in your language.\\n\\n\\n","# Python 3.X\\n\\nfrom functools import reduce\\nfrom operator import add, mul\\n\\nnums = range(1,11)\\n\\nsummation = reduce(add, nums)\\n\\nproduct = reduce(mul, nums)\\n\\nconcatenation = reduce(lambda a, b: str(a) + str(b), nums)\\n\\nprint(summation, product, concatenation)"
"Python","Chaocipher","Description\\nThe Chaocipher was invented by J.F.Byrne in 1918 and, although simple by modern cryptographic standards, does not appear to have been broken until the algorithm was finally disclosed by his family in 2010.\\nThe algorithm is described in this paper by M.Rubin in 2010 and there is a C# implementation here.\\n\\nTask\\nThe task is to code the algorithm in your language and to test that it works with the plaintext 'WELLDONEISBETTERTHANWELLSAID' used in the paper itself.\\n\\n","\\n# Python3 implementation of Chaocipher \\n# left wheel = ciphertext wheel\\n# right wheel = plaintext wheel\\n\\ndef main():\\n    # letters only! makealpha(key) helps generate lalpha/ralpha. \\n    lalpha = \""HXUCZVAMDSLKPEFJRIGTWOBNYQ\""\\n    ralpha = \""PTLNBQDEOYSFAVZKGJRIHWXUMC\""\\n    msg = \""WELLDONEISBETTERTHANWELLSAID\""\\n\\n    print(\""L:\"", lalpha)\\n    print(\""R:\"", ralpha)\\n    print(\""I:\"", msg)\\n    print(\""O:\"", do_chao(msg, lalpha, ralpha, 1, 0), \""\\n\"")\\n    \\n    do_chao(msg, lalpha, ralpha, 1, 1)\\n\\ndef do_chao(msg, lalpha, ralpha, en=1, show=0):\\n    msg = correct_case(msg)\\n    out = \""\""    \\n    if show:\\n        print(\""=\""*54)        \\n        print(10*\"" \"" + \""left:\"" + 21*\"" \"" + \""right: \"")\\n        print(\""=\""*54)        \\n        print(lalpha, ralpha, \""\\n\"")\\n    for L in msg:\\n        if en:\\n            lalpha, ralpha = rotate_wheels(lalpha, ralpha, L)\\n            out += lalpha[0]\\n        else:\\n            ralpha, lalpha = rotate_wheels(ralpha, lalpha, L)\\n            out += ralpha[0]\\n        lalpha, ralpha = scramble_wheels(lalpha, ralpha)\\n        if show:\\n            print(lalpha, ralpha)            \\n    return out\\n    \\ndef makealpha(key=\""\""):\\n    alpha = \""ABCDEFGHIJKLMNOPQRSTUVWXYZ\""\\n    z = set()\\n    key = [x.upper() for x in (key + alpha[::-1])\\n           if not (x.upper() in z or z.add(x.upper()))]\\n    return \""\"".join(key)\\n\\ndef correct_case(string):\\n    return \""\"".join([s.upper() for s in string if s.isalpha()])\\n\\ndef permu(alp, num):\\n    alp = alp[:num], alp[num:]\\n    return \""\"".join(alp[::-1])\\n\\ndef rotate_wheels(lalph, ralph, key):\\n    newin = ralph.index(key)\\n    return permu(lalph, newin), permu(ralph, newin)    \\n\\ndef scramble_wheels(lalph, ralph):\\n    # LEFT = cipher wheel \\n    # Cycle second[1] through nadir[14] forward\\n    lalph = list(lalph)\\n    lalph = \""\"".join([*lalph[0],\\n                    *lalph[2:14],\\n                    lalph[1],\\n                    *lalph[14:]])\\n    \\n    # RIGHT = plain wheel                    \\n    # Send the zenith[0] character to the end[25],\\n    # cycle third[2] through nadir[14] characters forward\\n    ralph = list(ralph)\\n    ralph = \""\"".join([*ralph[1:3],\\n                     *ralph[4:15],\\n                     ralph[3],\\n                     *ralph[15:],\\n                     ralph[0]])\\n    return lalph, ralph\\n\\nmain()"
"Python","Chaos_game","The Chaos Game is a method of generating the attractor of an iterated function system (IFS). One of the best-known and simplest examples creates a fractal, using a polygon and an initial point selected at random.\\n\\nPlay the Chaos Game using the corners of an equilateral triangle as the reference points. Add a starting point at random (preferably inside the triangle). Then add the next point halfway between the starting point and one of the reference points. This reference point is chosen at random.\\nAfter a sufficient number of iterations, the image of a Sierpinski Triangle should emerge.\\n\\n\\nThis should require minimal adaptation to work with any of the older Microsoft-style BASICs. Users of other dialects will need to replace lines 10 and 150 with the appropriate statements to select a graphics output mode (if necessary) and to plot a pixel at x,y in colour v; they should also add LET throughout and 170 END if their dialects require those things.\\nAdapted from the code given above.\\nAdapted from the other BASIC versions. Monochrome and low-resolution, of course. Works with only 1k of RAM. If you like, you can try changing line 30 to go round the loop a different number of times.\\nNote that ZX81 BASIC does not have an explicit computed GOTO; we can, however, actually compute the value of an expression and then GOTO it as a line number.\\n","\\nimport argparse\\nimport random\\nimport shapely.geometry as geometry\\nimport numpy as np\\nimport matplotlib.pyplot as plt\\nimport matplotlib.animation as animation\\n\\n\\ndef main(args):\\n    # Styles\\n    plt.style.use(\""ggplot\"")\\n\\n    # Creating figure\\n    fig = plt.figure()\\n    line, = plt.plot([], [], \"".\"")\\n\\n    # Limit axes\\n    plt.xlim(0, 1)\\n    plt.ylim(0, 1)\\n\\n    # Titles\\n    title = \""Chaos Game\""\\n    plt.title(title)\\n    fig.canvas.set_window_title(title)\\n\\n    # Getting data\\n    data = get_data(args.frames)\\n\\n    # Creating animation\\n    line_ani = animation.FuncAnimation(\\n        fig=fig,\\n        func=update_line,\\n        frames=args.frames,\\n        fargs=(data, line),\\n        interval=args.interval,\\n        repeat=False\\n    )\\n\\n    # To save the animation install ffmpeg and uncomment\\n    # line_ani.save(\""chaos_game.gif\"")\\n\\n    plt.show()\\n\\n\\ndef get_data(n):\\n    \""\""\""\\n    Get data to plot\\n    \""\""\""\\n    leg = 1\\n    triangle = get_triangle(leg)\\n    cur_point = gen_point_within_poly(triangle)\\n    data = []\\n    for _ in range(n):\\n        data.append((cur_point.x, cur_point.y))\\n        cur_point = next_point(triangle, cur_point)\\n    return data\\n\\n\\ndef get_triangle(n):\\n    \""\""\""\\n    Create right triangle\\n    \""\""\""\\n    ax = ay = 0.0\\n    a = ax, ay\\n\\n    bx = 0.5  *  n\\n    by = 0.75 * (n ** 2)\\n    b = bx, by\\n\\n    cx = n\\n    cy = 0.0\\n    c = cx, cy\\n\\n    triangle = geometry.Polygon([a, b, c])\\n    return triangle\\n\\n\\ndef gen_point_within_poly(poly):\\n    \""\""\""\\n    Generate random point inside given polygon\\n    \""\""\""\\n    minx, miny, maxx, maxy = poly.bounds\\n    while True:\\n        x = random.uniform(minx, maxx)\\n        y = random.uniform(miny, maxy)\\n        point = geometry.Point(x, y)\\n        if point.within(poly):\\n            return point\\n\\n\\ndef next_point(poly, point):\\n    \""\""\""\\n    Generate next point according to chaos game rules\\n    \""\""\""\\n    vertices = poly.boundary.coords[:-1]  # Last point is the same as the first one\\n    random_vertex = geometry.Point(random.choice(vertices))\\n    line = geometry.linestring.LineString([point, random_vertex])\\n    return line.centroid\\n\\n\\ndef update_line(num, data, line):\\n    \""\""\""\\n    Update line with new points\\n    \""\""\""\\n    new_data = zip(*data[:num]) or [(), ()]\\n    line.set_data(new_data)\\n    return line,\\n\\n\\nif __name__ == \""__main__\"":\\n    arg_parser = argparse.ArgumentParser(description=\""Chaos Game by Suenweek (c) 2017\"")\\n    arg_parser.add_argument(\""-f\"", dest=\""frames\"", type=int, default=1000)\\n    arg_parser.add_argument(\""-i\"", dest=\""interval\"", type=int, default=10)\\n\\n    main(arg_parser.parse_args())\\n\\n"
"Python","Character_codes","\\nGiven a character value in your language, print its code   (could be ASCII code, Unicode code, or whatever your language uses).\\n\\nThe character   'a'   (lowercase letter A)   has a code of 97 in ASCII   (as well as Unicode, as ASCII forms the beginning of Unicode).\\nConversely, given a code, print out the corresponding character.\\n\\nS/360 architecture and EBCDIC was born together.\\nIn EBCDIC, the character 'a' (lowercase letter A) has a code of 129 in decimal and '81'x in hexadecimal.\\nTo perform conversion, we use IC (insert character) and STC (store character) opcodes.\\n","print ord('a') # prints \""97\""\\nprint chr(97)  # prints \""a\"""
"Python","Character_codes","\\nGiven a character value in your language, print its code   (could be ASCII code, Unicode code, or whatever your language uses).\\n\\nThe character   'a'   (lowercase letter A)   has a code of 97 in ASCII   (as well as Unicode, as ASCII forms the beginning of Unicode).\\nConversely, given a code, print out the corresponding character.\\n\\nS/360 architecture and EBCDIC was born together.\\nIn EBCDIC, the character 'a' (lowercase letter A) has a code of 129 in decimal and '81'x in hexadecimal.\\nTo perform conversion, we use IC (insert character) and STC (store character) opcodes.\\n","print ord(u'π')   # prints \""960\""\\nprint unichr(960) # prints \""π\"""
"Python","Character_codes","\\nGiven a character value in your language, print its code   (could be ASCII code, Unicode code, or whatever your language uses).\\n\\nThe character   'a'   (lowercase letter A)   has a code of 97 in ASCII   (as well as Unicode, as ASCII forms the beginning of Unicode).\\nConversely, given a code, print out the corresponding character.\\n\\nS/360 architecture and EBCDIC was born together.\\nIn EBCDIC, the character 'a' (lowercase letter A) has a code of 129 in decimal and '81'x in hexadecimal.\\nTo perform conversion, we use IC (insert character) and STC (store character) opcodes.\\n","print(ord('a')) # prints \""97\"" (will also work in 2.x)\\nprint(ord('π')) # prints \""960\""\\nprint(chr(97))  # prints \""a\"" (will also work in 2.x)\\nprint(chr(960)) # prints \""π\"""
"Python","Chat_server","Write a server for a minimal text based chat.\\nPeople should be able to connect via ‘telnet’, sign on with a nickname, and type messages which will then be seen by all other connected users. Arrivals and departures of chat members should generate appropriate notification messages.\\n\\nC has no built-in networking functions, but the POSIX library does provide some low-level networking functions. The functions of interest relating to sockets include bind, listen, select, accept, read, write and close.\\nThe example below was compiled on Cygwin, and accepts PuTTY connections under the RAW protocol.\\nA glitch occurs if a connection is made using the Telnet protocol - user names are preceded by garbled text.\\nThis is ported from the JavaScript version. The tool js2coffee got me a mostly working version, and then I manually converted JS-style classes to CS \""classic-style class\"" syntax.\\nThis example uses the Go idiom of Do not communicate by sharing memory; instead, share memory by communicating; there are no explicit locks used, instead Go channels are used to safely synchronize where required.\\nA similar exercise of a chat roulette (different in that messages only have to be written to a single partner rather than broadcast, this simplifies the code greatly) was the topic of a 2012 Go Talk.\\nThis example handles the case of one specific client \""falling behind\"" by relying on the underlying TCP stack to do a reasonable job of buffering. Once that buffer fills, a write to the that client's connection will time out and the connection will dropped. Other minor improvements would include enabling TCP keep alives, handling temporary errors from accept, and better logging. Not ideal, but it should be good enough for this example.\\nThis is Unicon-specific:\\nBroadcasting of messages is done by the thread that received the message, so a bad client could potentially disrupt the server. The output buffer is set to 16K in an attempt to alleviate possible symptoms, but I'm not sure if it's effective. Server does not allow duplicate client names, and lists all users online after a successful connection. Client can type \""/quit\"" to quit.\\nI think ideally, NIO would be used to select() sockets available/ready for I/O, to eliminate the possibility of a bad connection disrupting the server, but this increases the complexity.\\nModified to fit the Rosetta Code task from example code for the WebSockets module written by Leah Hanson.\\nTo test, start the code and use a browser to connect to localhost:8000.\\nNotes:\\nAfter starting the above script, connect to the chat server from two terminals:\\nWorks with Swi-Prolog as of Jan 2019.\\nThis version will load the server automatically on port 5000, adapt to your needs.\\nThis is a very basic chat server, but it does everything that is needed for this task.\\nOn my Linux box, telnet seems to only want to connect to port 23.\\n","#!/usr/bin/env python\\n\\nimport socket\\nimport thread\\nimport time\\n\\nHOST = \""\""\\nPORT = 4004\\n\\ndef accept(conn):\\n    \""\""\""\\n    Call the inner func in a thread so as not to block. Wait for a \\n    name to be entered from the given connection. Once a name is \\n    entered, set the connection to non-blocking and add the user to \\n    the users dict.\\n    \""\""\""\\n    def threaded():\\n        while True:\\n            conn.send(\""Please enter your name: \"")\\n            try:\\n                name = conn.recv(1024).strip()\\n            except socket.error:\\n                continue\\n            if name in users:\\n                conn.send(\""Name entered is already in use.\\n\"")\\n            elif name:\\n                conn.setblocking(False)\\n                users[name] = conn\\n                broadcast(name, \""+++ %s arrived +++\"" % name)\\n                break\\n    thread.start_new_thread(threaded, ())\\n\\ndef broadcast(name, message):\\n    \""\""\""\\n    Send a message to all users from the given name.\\n    \""\""\""\\n    print message\\n    for to_name, conn in users.items():\\n        if to_name != name:\\n            try:\\n                conn.send(message + \""\\n\"")\\n            except socket.error:\\n                pass\\n\\n# Set up the server socket.\\nserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\\nserver.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\\nserver.setblocking(False)\\nserver.bind((HOST, PORT))\\nserver.listen(1)\\nprint \""Listening on %s\"" % (\""%s:%s\"" % server.getsockname())\\n\\n# Main event loop.\\nusers = {}\\nwhile True:\\n    try:\\n        # Accept new connections.\\n        while True:\\n            try:\\n                conn, addr = server.accept()\\n            except socket.error:\\n                break\\n            accept(conn)\\n        # Read from connections.\\n        for name, conn in users.items():\\n            try:\\n                message = conn.recv(1024)\\n            except socket.error:\\n                continue\\n            if not message:\\n                # Empty string is given on disconnect.\\n                del users[name]\\n                broadcast(name, \""--- %s leaves ---\"" % name)\\n            else:\\n                broadcast(name, \""%s> %s\"" % (name, message.strip()))\\n        time.sleep(.1)\\n    except (SystemExit, KeyboardInterrupt):\\n        break"
"Python","Check_input_device_is_a_terminal","Demonstrate how to check whether the input device is a terminal or not.\\n\\n\\nWe use the interface to C library functions isatty() and fileno().\\n","from sys import stdin\\nif stdin.isatty():\\n    print(\""Input comes from tty.\"")\\nelse:\\n    print(\""Input doesn't come from tty.\"")"
"Python","Check_Machin-like_formulas","Machin-like formulas   are useful for efficiently computing numerical approximations for \\n\\n\\n\\nπ\\n\\n\\n{\\displaystyle \\pi }\\n\\n\\n\\nVerify the following Machin-like formulas are correct by calculating the value of tan   (right hand side) for each equation using exact arithmetic and showing they equal 1:\\nand confirm that the following formula is incorrect by showing   tan   (right hand side)   is not   1:\\nThese identities are useful in calculating the values:\\n\\nYou can store the equations in any convenient data structure, but for extra credit parse them from human-readable text input.\\nNote: to formally prove the formula correct, it would have to be shown that \\n\\n\\n\\n\\n\\n\\n−\\n3\\np\\ni\\n\\n4\\n\\n\\n\\n\\n{\\displaystyle {-3pi \\over 4}}\\n\\n < right hand side < \\n\\n\\n\\n\\n\\n\\n5\\np\\ni\\n\\n4\\n\\n\\n\\n\\n{\\displaystyle {5pi \\over 4}}\\n\\n due to \\n\\n\\n\\ntan\\n⁡\\n(\\n)\\n\\n\\n{\\displaystyle \\tan()}\\n\\n periodicity.\\n\\nClojure automatically handles ratio of numbers as fractions\\n","import re\\nfrom fractions import Fraction\\nfrom pprint import pprint as pp\\n\\n\\nequationtext = '''\\\\n  pi/4 = arctan(1/2) + arctan(1/3) \\n  pi/4 = 2*arctan(1/3) + arctan(1/7)\\n  pi/4 = 4*arctan(1/5) - arctan(1/239)\\n  pi/4 = 5*arctan(1/7) + 2*arctan(3/79)\\n  pi/4 = 5*arctan(29/278) + 7*arctan(3/79)\\n  pi/4 = arctan(1/2) + arctan(1/5) + arctan(1/8) \\n  pi/4 = 4*arctan(1/5) - arctan(1/70) + arctan(1/99) \\n  pi/4 = 5*arctan(1/7) + 4*arctan(1/53) + 2*arctan(1/4443)\\n  pi/4 = 6*arctan(1/8) + 2*arctan(1/57) + arctan(1/239)\\n  pi/4 = 8*arctan(1/10) - arctan(1/239) - 4*arctan(1/515)\\n  pi/4 = 12*arctan(1/18) + 8*arctan(1/57) - 5*arctan(1/239)\\n  pi/4 = 16*arctan(1/21) + 3*arctan(1/239) + 4*arctan(3/1042)\\n  pi/4 = 22*arctan(1/28) + 2*arctan(1/443) - 5*arctan(1/1393) - 10*arctan(1/11018)\\n  pi/4 = 22*arctan(1/38) + 17*arctan(7/601) + 10*arctan(7/8149)\\n  pi/4 = 44*arctan(1/57) + 7*arctan(1/239) - 12*arctan(1/682) + 24*arctan(1/12943)\\n  pi/4 = 88*arctan(1/172) + 51*arctan(1/239) + 32*arctan(1/682) + 44*arctan(1/5357) + 68*arctan(1/12943)\\n  pi/4 = 88*arctan(1/172) + 51*arctan(1/239) + 32*arctan(1/682) + 44*arctan(1/5357) + 68*arctan(1/12944)\\n'''\\n\\ndef parse_eqn(equationtext=equationtext):\\n    eqn_re = re.compile(r\""\""\""(?mx)\\n    (?P<lhs> ^ \\s* pi/4 \\s* = \\s*)?             # LHS of equation\\n    (?:                                         # RHS\\n        \\s* (?P<sign> [+-])? \\s* \\n        (?: (?P<mult> \\d+) \\s* \\*)? \\n        \\s* arctan\\( (?P<numer> \\d+) / (?P<denom> \\d+)\\n    )\""\""\"")\\n\\n    found = eqn_re.findall(equationtext)\\n    machins, part = [], []\\n    for lhs, sign, mult, numer, denom in eqn_re.findall(equationtext):\\n        if lhs and part:\\n            machins.append(part)\\n            part = []\\n        part.append( ( (-1 if sign == '-' else 1) * ( int(mult) if mult else 1),\\n                       Fraction(int(numer), (int(denom) if denom else 1)) ) )\\n    machins.append(part)\\n    return machins\\n\\n\\ndef tans(xs):\\n    xslen = len(xs)\\n    if xslen == 1:\\n        return tanEval(*xs[0])\\n    aa, bb = xs[:xslen//2], xs[xslen//2:]\\n    a, b = tans(aa), tans(bb)\\n    return (a + b) / (1 - a * b)\\n\\ndef tanEval(coef, f):\\n    if coef == 1:\\n        return f\\n    if coef < 0:\\n        return -tanEval(-coef, f)\\n    ca = coef // 2\\n    cb = coef - ca\\n    a, b = tanEval(ca, f), tanEval(cb, f)\\n    return (a + b) / (1 - a * b)\\n\\n\\nif __name__ == '__main__':\\n    machins = parse_eqn()\\n    #pp(machins, width=160)\\n    for machin, eqn in zip(machins, equationtext.split('\\n')):\\n        ans = tans(machin)\\n        print('%5s: %s' % ( ('OK' if ans == 1 else 'ERROR'), eqn))"
"Python","Check_output_device_is_a_terminal","Demonstrate how to check whether the output device is a terminal or not.\\n\\n\\nWe use the interface to C library functions isatty() and fileno().\\n","from sys import stdout\\nif stdout.isatty():\\n    print 'The output device is a teletype. Or something like a teletype.'\\nelse:\\n    print 'The output device isn\\'t like a teletype.'"
"Python","Check_that_file_exists","Verify that a file called     input.txt     and   a directory called     docs     exist.\\n\\nThis should be done twice:  \\n\\nOptional criteria (May 2015):   verify it works with:\\n\\nThis example should work with any Ada 95 compiler.\\nThis example should work with any Ada 2005 compiler.\\nThe stat function returns a System.Stat object for an existing file or directory, or null if it can't be found.\\nUses the Algol 68G specific \""file is directory\"" procedure to test for the existence of directories.\\n(macOS JavaScript for Automation)\\n","import os\\n\\nos.path.isfile(\""input.txt\"")\\nos.path.isfile(\""/input.txt\"")\\nos.path.isdir(\""docs\"")\\nos.path.isdir(\""/docs\"")"
"Python","Cheryl's_Birthday","Albert and Bernard just became friends with Cheryl, and they want to know when her birthday is.\\nCheryl gave them a list of 10 possible dates:\\nMay 15, May 16, May 19\\nJune 17, June 18\\nJuly 14, July 16\\nAugust 14, August 15, August 17\\nCheryl then tells Albert and Bernard separately the month and the day of the birthday respectively.\\n1) Albert: I don't know when Cheryl's birthday is, but I know that Bernard does not know too.\\n2) Bernard: At first I don't know when Cheryl's birthday is, but I know now.\\n3) Albert: Then I also know when Cheryl's birthday is.\\n\\nWrite a program in your language to deduce, by successive elimination, Cheryl's birthday.\\n\\n","from typing import Callable, Dict, List, Tuple, Union\\nfrom itertools import (groupby)\\nfrom operator import not_\\nfrom re import (split)\\n\\n\\n# main :: IO ()\\ndef main() -> None:\\n    (month, day) = (0, 1)\\n    print(\\n        # (A's month contains only one remaining day)\\n        # (3 :: A \""Then I also know\"")\\n        uniquePairing(month)(\\n            # (B's day is paired with only one remaining month)\\n            # (2 :: B \""I know now\"")\\n            uniquePairing(day)(\\n                # (A's month is not among those with unique days)\\n                # (1 :: A \""I know that Bernard does not know\"")\\n                monthsWithUniqueDays(False)(\\n                    # 0 :: Cheryl's list:\\n                    list(map(\\n                        lambda x: tuple(x.split()),\\n                        split(\\n                            ', ',\\n                            'May 15, May 16, May 19, ' +\\n                            'June 17, June 18, ' +\\n                            'July 14, July 16, ' +\\n                            'Aug 14, Aug 15, Aug 17'\\n                        )\\n                    ))\\n                )\\n            )\\n        )\\n    )\\n\\n\\n#  QUERY FUNCTIONS ----------------------------------------\\n\\n# monthsWithUniqueDays :: Bool -> [(Month, Day)] -> [(Month, Day)]\\ndef monthsWithUniqueDays(blnInclude: bool) -> Callable:\\n    def go(xs):\\n        (month, day) = (0, 1)\\n        months = list(map(fst, uniquePairing(day)(xs)))\\n        return list(filter(\\n            lambda md: (\\n                md if blnInclude else not_\\n            )(md[month] in months),\\n            xs\\n        ))\\n    return lambda xs: go(xs)\\n\\n\\n# uniquePairing :: DatePart -> [(Month, Day)] -> [(Month, Day)]\\ndef uniquePairing(i: int) -> Callable:\\n    def go(xs):\\n        def inner(md):\\n            dct = md[i]\\n            uniques = list(filter(\\n                lambda k: 1 == len(dct[k]),\\n                dct.keys()\\n            ))\\n            return filter(lambda tpl: tpl[i] in uniques, xs)\\n        return inner\\n    return lambda xs: bindPairs(xs)(go(xs))\\n\\n\\n# bindPairs :: [(Month, Day)] -> ((Dict String [String], Dict String [String])\\n#                             -> [(Month, Day)]) -> [(Month, Day)]\\ndef bindPairs(xs: List[Tuple[str, str]]) -> Callable:\\n    return lambda f: list(f(\\n        (dictFromPairs(xs), dictFromPairs(map(swap, xs)))\\n    ))\\n\\n\\n# dictFromPairs :: [(Month, Day)] -> Dict Text [Text]\\ndef dictFromPairs(\\n    xs: Union[map, List[Tuple[str, str]]]\\n) -> Dict[str, List[str]]:\\n    return dict(\\n        (k, list(map(snd, m))) for k, m in groupby(\\n            sorted(xs, key=fst), key=fst\\n        )\\n    )\\n\\n\\n# GENERIC -------------------------------------------------\\n\\n# fst :: (a, b) -> a\\ndef fst(tpl: Tuple[str, str]) -> str:\\n    \""Return first element of tpl\""\\n    return tpl[0]\\n\\n\\n# snd :: (a, b) -> b\\ndef snd(tpl: Tuple[str, str]) -> str:\\n    \""Return second element of tpl\""\\n    return tpl[1]\\n\\n\\n# swap :: (a, b) -> (b, a)\\ndef swap(tpl: Tuple[str, str]) -> Tuple[str, str]:\\n    \""Swap and return first and second elements of tpl\""\\n    return (tpl[1], tpl[0])\\n\\n\\nif __name__ == '__main__':\\n    main()"
"Python","Chinese_remainder_theorem","Suppose   \\n\\n\\n\\n\\nn\\n\\n1\\n\\n\\n\\n\\n{\\displaystyle n_{1}}\\n\\n,   \\n\\n\\n\\n\\nn\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle n_{2}}\\n\\n,   \\n\\n\\n\\n…\\n\\n\\n{\\displaystyle \\ldots }\\n\\n,   \\n\\n\\n\\n\\nn\\n\\nk\\n\\n\\n\\n\\n{\\displaystyle n_{k}}\\n\\n   are positive integers that are pairwise co-prime.  \\nThen, for any given sequence of integers   \\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n{\\displaystyle a_{1}}\\n\\n,   \\n\\n\\n\\n\\na\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle a_{2}}\\n\\n,   \\n\\n\\n\\n…\\n\\n\\n{\\displaystyle \\dots }\\n\\n,   \\n\\n\\n\\n\\na\\n\\nk\\n\\n\\n\\n\\n{\\displaystyle a_{k}}\\n\\n,   there exists an integer   \\n\\n\\n\\nx\\n\\n\\n{\\displaystyle x}\\n\\n   solving the following system of simultaneous congruences:\\nFurthermore, all solutions   \\n\\n\\n\\nx\\n\\n\\n{\\displaystyle x}\\n\\n   of this system are congruent modulo the product,   \\n\\n\\n\\nN\\n=\\n\\nn\\n\\n1\\n\\n\\n\\nn\\n\\n2\\n\\n\\n…\\n\\nn\\n\\nk\\n\\n\\n\\n\\n{\\displaystyle N=n_{1}n_{2}\\ldots n_{k}}\\n\\n.\\n\\nWrite a program to solve a system of linear congruences by applying the   Chinese Remainder Theorem.\\nIf the system of equations cannot be solved, your program must somehow indicate this.\\n(It may throw an exception or return a special false value.)\\nSince there are infinitely many solutions, the program should return the unique solution   \\n\\n\\n\\ns\\n\\n\\n{\\displaystyle s}\\n\\n   where   \\n\\n\\n\\n0\\n≤\\ns\\n≤\\n\\nn\\n\\n1\\n\\n\\n\\nn\\n\\n2\\n\\n\\n…\\n\\nn\\n\\nk\\n\\n\\n\\n\\n{\\displaystyle 0\\leq s\\leq n_{1}n_{2}\\ldots n_{k}}\\n\\n.\\n\\nShow the functionality of this program by printing the result such that the   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n's   are   \\n\\n\\n\\n[\\n3\\n,\\n5\\n,\\n7\\n]\\n\\n\\n{\\displaystyle [3,5,7]}\\n\\n   and the   \\n\\n\\n\\na\\n\\n\\n{\\displaystyle a}\\n\\n's   are   \\n\\n\\n\\n[\\n2\\n,\\n3\\n,\\n2\\n]\\n\\n\\n{\\displaystyle [2,3,2]}\\n\\n.\\n\\nAlgorithm:   The following algorithm only applies if the   \\n\\n\\n\\n\\nn\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle n_{i}}\\n\\n's   are pairwise co-prime.\\nSuppose, as above, that a solution is required for the system of congruences:\\nAgain, to begin, the product   \\n\\n\\n\\nN\\n=\\n\\nn\\n\\n1\\n\\n\\n\\nn\\n\\n2\\n\\n\\n…\\n\\nn\\n\\nk\\n\\n\\n\\n\\n{\\displaystyle N=n_{1}n_{2}\\ldots n_{k}}\\n\\n   is defined.\\nThen a solution   \\n\\n\\n\\nx\\n\\n\\n{\\displaystyle x}\\n\\n   can be found as follows:\\nFor each   \\n\\n\\n\\ni\\n\\n\\n{\\displaystyle i}\\n\\n,   the integers   \\n\\n\\n\\n\\nn\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle n_{i}}\\n\\n   and   \\n\\n\\n\\nN\\n\\n/\\n\\n\\nn\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle N/n_{i}}\\n\\n   are co-prime.\\nUsing the   Extended Euclidean algorithm,   we can find integers   \\n\\n\\n\\n\\nr\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle r_{i}}\\n\\n   and   \\n\\n\\n\\n\\ns\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle s_{i}}\\n\\n   such that   \\n\\n\\n\\n\\nr\\n\\ni\\n\\n\\n\\nn\\n\\ni\\n\\n\\n+\\n\\ns\\n\\ni\\n\\n\\nN\\n\\n/\\n\\n\\nn\\n\\ni\\n\\n\\n=\\n1\\n\\n\\n{\\displaystyle r_{i}n_{i}+s_{i}N/n_{i}=1}\\n\\n.\\nThen, one solution to the system of simultaneous congruences is:\\nand the minimal solution,\\n\\n","# Python 2.7\\ndef chinese_remainder(n, a):\\n    sum = 0\\n    prod = reduce(lambda a, b: a*b, n)\\n\\n    for n_i, a_i in zip(n, a):\\n        p = prod / n_i\\n        sum += a_i * mul_inv(p, n_i) * p\\n    return sum % prod\\n\\n\\ndef mul_inv(a, b):\\n    b0 = b\\n    x0, x1 = 0, 1\\n    if b == 1: return 1\\n    while a > 1:\\n        q = a / b\\n        a, b = b, a%b\\n        x0, x1 = x1 - q * x0, x0\\n    if x1 < 0: x1 += b0\\n    return x1\\n\\nif __name__ == '__main__':\\n    n = [3, 5, 7]\\n    a = [2, 3, 2]\\n    print chinese_remainder(n, a)"
"Python","Chinese_remainder_theorem","Suppose   \\n\\n\\n\\n\\nn\\n\\n1\\n\\n\\n\\n\\n{\\displaystyle n_{1}}\\n\\n,   \\n\\n\\n\\n\\nn\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle n_{2}}\\n\\n,   \\n\\n\\n\\n…\\n\\n\\n{\\displaystyle \\ldots }\\n\\n,   \\n\\n\\n\\n\\nn\\n\\nk\\n\\n\\n\\n\\n{\\displaystyle n_{k}}\\n\\n   are positive integers that are pairwise co-prime.  \\nThen, for any given sequence of integers   \\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n{\\displaystyle a_{1}}\\n\\n,   \\n\\n\\n\\n\\na\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle a_{2}}\\n\\n,   \\n\\n\\n\\n…\\n\\n\\n{\\displaystyle \\dots }\\n\\n,   \\n\\n\\n\\n\\na\\n\\nk\\n\\n\\n\\n\\n{\\displaystyle a_{k}}\\n\\n,   there exists an integer   \\n\\n\\n\\nx\\n\\n\\n{\\displaystyle x}\\n\\n   solving the following system of simultaneous congruences:\\nFurthermore, all solutions   \\n\\n\\n\\nx\\n\\n\\n{\\displaystyle x}\\n\\n   of this system are congruent modulo the product,   \\n\\n\\n\\nN\\n=\\n\\nn\\n\\n1\\n\\n\\n\\nn\\n\\n2\\n\\n\\n…\\n\\nn\\n\\nk\\n\\n\\n\\n\\n{\\displaystyle N=n_{1}n_{2}\\ldots n_{k}}\\n\\n.\\n\\nWrite a program to solve a system of linear congruences by applying the   Chinese Remainder Theorem.\\nIf the system of equations cannot be solved, your program must somehow indicate this.\\n(It may throw an exception or return a special false value.)\\nSince there are infinitely many solutions, the program should return the unique solution   \\n\\n\\n\\ns\\n\\n\\n{\\displaystyle s}\\n\\n   where   \\n\\n\\n\\n0\\n≤\\ns\\n≤\\n\\nn\\n\\n1\\n\\n\\n\\nn\\n\\n2\\n\\n\\n…\\n\\nn\\n\\nk\\n\\n\\n\\n\\n{\\displaystyle 0\\leq s\\leq n_{1}n_{2}\\ldots n_{k}}\\n\\n.\\n\\nShow the functionality of this program by printing the result such that the   \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n's   are   \\n\\n\\n\\n[\\n3\\n,\\n5\\n,\\n7\\n]\\n\\n\\n{\\displaystyle [3,5,7]}\\n\\n   and the   \\n\\n\\n\\na\\n\\n\\n{\\displaystyle a}\\n\\n's   are   \\n\\n\\n\\n[\\n2\\n,\\n3\\n,\\n2\\n]\\n\\n\\n{\\displaystyle [2,3,2]}\\n\\n.\\n\\nAlgorithm:   The following algorithm only applies if the   \\n\\n\\n\\n\\nn\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle n_{i}}\\n\\n's   are pairwise co-prime.\\nSuppose, as above, that a solution is required for the system of congruences:\\nAgain, to begin, the product   \\n\\n\\n\\nN\\n=\\n\\nn\\n\\n1\\n\\n\\n\\nn\\n\\n2\\n\\n\\n…\\n\\nn\\n\\nk\\n\\n\\n\\n\\n{\\displaystyle N=n_{1}n_{2}\\ldots n_{k}}\\n\\n   is defined.\\nThen a solution   \\n\\n\\n\\nx\\n\\n\\n{\\displaystyle x}\\n\\n   can be found as follows:\\nFor each   \\n\\n\\n\\ni\\n\\n\\n{\\displaystyle i}\\n\\n,   the integers   \\n\\n\\n\\n\\nn\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle n_{i}}\\n\\n   and   \\n\\n\\n\\nN\\n\\n/\\n\\n\\nn\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle N/n_{i}}\\n\\n   are co-prime.\\nUsing the   Extended Euclidean algorithm,   we can find integers   \\n\\n\\n\\n\\nr\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle r_{i}}\\n\\n   and   \\n\\n\\n\\n\\ns\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle s_{i}}\\n\\n   such that   \\n\\n\\n\\n\\nr\\n\\ni\\n\\n\\n\\nn\\n\\ni\\n\\n\\n+\\n\\ns\\n\\ni\\n\\n\\nN\\n\\n/\\n\\n\\nn\\n\\ni\\n\\n\\n=\\n1\\n\\n\\n{\\displaystyle r_{i}n_{i}+s_{i}N/n_{i}=1}\\n\\n.\\nThen, one solution to the system of simultaneous congruences is:\\nand the minimal solution,\\n\\n","# Python 3.6\\nfrom functools import reduce\\ndef chinese_remainder(n, a):\\n    sum = 0\\n    prod = reduce(lambda a, b: a*b, n)\\n    for n_i, a_i in zip(n, a):\\n        p = prod // n_i\\n        sum += a_i * mul_inv(p, n_i) * p\\n    return sum % prod\\n \\n \\n\\ndef mul_inv(a, b):\\n    b0 = b\\n    x0, x1 = 0, 1\\n    if b == 1: return 1\\n    while a > 1:\\n        q = a // b\\n        a, b = b, a%b\\n        x0, x1 = x1 - q * x0, x0\\n    if x1 < 0: x1 += b0\\n    return x1\\n \\n\\n\\nif __name__ == '__main__':\\n    n = [3, 5, 7]\\n    a = [2, 3, 2]\\n    print(chinese_remainder(n, a))"
"Python","Chinese_zodiac","Traditionally, the Chinese have counted years using two simultaneous cycles, one of length 10 (the \""celestial stems\"") and one of length 12 (the \""terrestrial branches\""); the combination results in a repeating 60-year pattern. Mapping the branches to twelve traditional animal deities results in the well-known \""Chinese zodiac\"", assigning each year to a given animal. For example, Saturday, January 28, 2017 CE (in the common Gregorian calendar) begins the lunisolar year of the Rooster.\\nThe celestial stems have no one-to-one mapping like that of the branches to animals; however, the five pairs of consecutive stems each belong to one of the five traditional Chinese elements (Wood, Fire, Earth, Metal, and Water). Further, one of the two years within each element's governance is associated with yin, the other with yang.\\nThus, 2017 is also the yin year of Fire. Note that since 12 is an even number, the association between animals and yin/yang doesn't change. Consecutive Years of the Rooster will cycle through the five elements, but will always be yin, despite the apparent conceptual mismatch between the male animals and the female aspect.\\nYou may optionally provide more information in the form of the year's numerical position within the 60-year cycle and/or its actual Chinese stem-branch name (in Han characters or Pinyin transliteration).\\nThus, 1984 was the year of the Wood Rat (yang), 1985 was the year of the Wood Ox (yin), and 1986 the year of the Fire Tiger (yang); 2017 - which, as already noted, is the year of the Fire Rooster (yin) - is the 34th year of the current cycle.\\nTherefore 1984 was 甲子 (jiă-zĭ, or jia3-zi3). 2017 is the 34th year of the current cycle, 丁酉 (dīng-yŏu or ding1-you3).\\n\\n","\\n# coding: utf-8\\n\\nfrom __future__ import print_function\\nfrom datetime import datetime\\n\\npinyin = {\\n  '甲': 'jiă',\\n  '乙': 'yĭ',\\n  '丙': 'bĭng',\\n  '丁': 'dīng',\\n  '戊': 'wù',\\n  '己': 'jĭ',\\n  '庚': 'gēng',\\n  '辛': 'xīn',\\n  '壬': 'rén',\\n  '癸': 'gŭi',\\n\\n  '子': 'zĭ',\\n  '丑': 'chŏu',\\n  '寅': 'yín',\\n  '卯': 'măo',\\n  '辰': 'chén',\\n  '巳': 'sì',\\n  '午': 'wŭ',\\n  '未': 'wèi',\\n  '申': 'shēn',\\n  '酉': 'yŏu',\\n  '戌': 'xū',\\n  '亥': 'hài'\\n}\\n\\nanimals = ['Rat', 'Ox', 'Tiger', 'Rabbit', 'Dragon', 'Snake',\\n           'Horse', 'Goat', 'Monkey', 'Rooster', 'Dog', 'Pig']\\nelements = ['Wood', 'Fire', 'Earth', 'Metal', 'Water']\\n\\ncelestial = ['甲', '乙', '丙', '丁', '戊', '己', '庚', '辛', '壬', '癸']\\nterrestrial = ['子', '丑', '寅', '卯', '辰', '巳', '午', '未', '申', '酉', '戌', '亥']\\naspects = ['yang', 'yin']\\n\\n\\ndef calculate(year):\\n    BASE = 4\\n    year = int(year)\\n    cycle_year = year - BASE\\n    stem_number = cycle_year % 10\\n    stem_han = celestial[stem_number]\\n    stem_pinyin = pinyin[stem_han]\\n    element_number = stem_number // 2\\n    element = elements[element_number]\\n    branch_number = cycle_year % 12\\n    branch_han = terrestrial[branch_number]\\n    branch_pinyin = pinyin[branch_han]\\n    animal = animals[branch_number]\\n    aspect_number = cycle_year % 2\\n    aspect = aspects[aspect_number]\\n    index = cycle_year % 60 + 1\\n    print(\""{}: {}{} ({}-{}, {} {}; {} - year {} of the cycle)\""\\n          .format(year, stem_han, branch_han,\\n                  stem_pinyin, branch_pinyin, element, animal, aspect, index))\\n\\n\\ncurrent_year = datetime.now().year\\nyears = [1935, 1938, 1968, 1972, 1976, current_year]\\nfor year in years:\\n    calculate(year)"
"Python","Chinese_zodiac","Traditionally, the Chinese have counted years using two simultaneous cycles, one of length 10 (the \""celestial stems\"") and one of length 12 (the \""terrestrial branches\""); the combination results in a repeating 60-year pattern. Mapping the branches to twelve traditional animal deities results in the well-known \""Chinese zodiac\"", assigning each year to a given animal. For example, Saturday, January 28, 2017 CE (in the common Gregorian calendar) begins the lunisolar year of the Rooster.\\nThe celestial stems have no one-to-one mapping like that of the branches to animals; however, the five pairs of consecutive stems each belong to one of the five traditional Chinese elements (Wood, Fire, Earth, Metal, and Water). Further, one of the two years within each element's governance is associated with yin, the other with yang.\\nThus, 2017 is also the yin year of Fire. Note that since 12 is an even number, the association between animals and yin/yang doesn't change. Consecutive Years of the Rooster will cycle through the five elements, but will always be yin, despite the apparent conceptual mismatch between the male animals and the female aspect.\\nYou may optionally provide more information in the form of the year's numerical position within the 60-year cycle and/or its actual Chinese stem-branch name (in Han characters or Pinyin transliteration).\\nThus, 1984 was the year of the Wood Rat (yang), 1985 was the year of the Wood Ox (yin), and 1986 the year of the Fire Tiger (yang); 2017 - which, as already noted, is the year of the Fire Rooster (yin) - is the 34th year of the current cycle.\\nTherefore 1984 was 甲子 (jiă-zĭ, or jia3-zi3). 2017 is the 34th year of the current cycle, 丁酉 (dīng-yŏu or ding1-you3).\\n\\n","from functools import (reduce)\\nimport datetime\\n\\n# TRADITIONAL STRINGS ---------------------------------------------------\\n\\ndctTokens = dict(\\n    zip(\\n    ['tian', 'di', 'wu', 'sx', 'yy'],\\n    map(\\n        lambda tpl: list(\\n            zip(* [tpl[0]] + list(\\n                map(\\n                    lambda x: x.split(),\\n                    tpl[1:])\\n                )\\n            )\\n        ),\\n        [\\n            # 天干 tiangan – 10 heavenly stems\\n            ('甲乙丙丁戊己庚辛壬癸',\\n             'jiă yĭ bĭng dīng wù jĭ gēng xīn rén gŭi'),\\n\\n            # 地支 dizhi – 12 terrestrial branches\\n            ('子丑寅卯辰巳午未申酉戌亥',\\n             'zĭ chŏu yín măo chén sì wŭ wèi shēn yŏu xū hài'),\\n\\n            # 五行 wuxing – 5 elements\\n            ('木火土金水',\\n             'mù huǒ tǔ jīn shuǐ',\\n             'wood fire earth metal water'),\\n\\n            # 十二生肖 shengxiao – 12 symbolic animals\\n            ('鼠牛虎兔龍蛇馬羊猴鸡狗豬',\\n             'shǔ niú hǔ tù lóng shé mǎ yáng hóu jī gǒu zhū',\\n             'rat ox tiger rabbit dragon snake horse goat monkey rooster dog pig'),\\n\\n            # 阴阳 yinyang\\n            ('阳阴', 'yáng yīn')\\n       ]\\n    )))\\n\\n\\n# zodiac :: Int -> [[String]]\\ndef zodiac(dct):\\n    def tokens(y):\\n        iYear = y - 4\\n        iStem = iYear % 10\\n        iBranch = iYear % 12\\n        (hStem, pStem) = dct['tian'][iStem]\\n        (hBranch, pBranch) = dct['di'][iBranch]\\n        return [\\n            [str(y), '', ''], \\n            [\\n                hStem + hBranch, \\n                pStem + pBranch, \\n                str((iYear % 60) + 1) + '/60'\\n            ], \\n            list(dct['wu'][iStem // 2]), \\n            list(dct['sx'][iBranch]),\\n            list(dct['yy'][iYear % 2]) + ['']\\n        ]\\n    return lambda year: tokens(year)\\n\\n\\n# FORMATTING --------------------------------------------------\\n\\n\\n# zodiacTable :: Int -> String\\ndef zodiacTable(y):\\n    return wikiTable({\\n        'class': 'wikitable',\\n        'colwidth': '70px'\\n    })(transpose(zodiac(dctTokens)(y)))\\n\\n\\n# transpose :: [[a]] -> [[a]]\\ndef transpose(xs):\\n    return list(map(list, zip(*xs)))\\n\\n\\n# wikiTable :: Dict -> [[a]] -> String\\ndef wikiTable(opts):\\n    def colWidth():\\n        return 'width:' + opts['colwidth'] + '; ' if (\\n            'colwidth' in opts) else ''\\n\\n    def cellStyle():\\n        return opts['cell'] if 'cell' in opts else ''\\n\\n    return lambda rows: '{| ' + reduce(\\n        lambda a, k: (\\n            a + k + '=\""' + opts[k] + '\"" ' if k in opts else a\\n        ),\\n        ['class', 'style'],\\n        ''\\n    ) + '\\n' + '\\n|-\\n'.join(\\n        '\\n'.join(\\n            ('|' if (0 != i and ('cell' not in opts)) else (\\n                '|style=\""' + colWidth() + cellStyle() + '\""|'\\n            )) + (\\n                str(x) or ' '\\n            ) for x in row\\n        ) for i, row in enumerate(rows)\\n    ) + '\\n|}\\n'\\n\\nif __name__ == '__main__':\\n    print('\\n'.join(\\n        list(map(\\n            zodiacTable, \\n            [\\n                1935, 1938, 1949, \\n                1968, 1972, 1976, \\n                datetime.datetime.now().year\\n            ]\\n        ))\\n    ))"
"Python","Cholesky_decomposition","Every symmetric, positive definite matrix A can be decomposed into a product of a unique lower triangular matrix L and its transpose:\\n\\n\\n\\n\\nL\\n\\n\\n{\\displaystyle L}\\n\\n is called the Cholesky factor of \\n\\n\\n\\nA\\n\\n\\n{\\displaystyle A}\\n\\n, and can be interpreted as a generalized square root of \\n\\n\\n\\nA\\n\\n\\n{\\displaystyle A}\\n\\n, as described in Cholesky decomposition.\\nIn a 3x3 example, we have to solve the following system of equations:\\nWe can see that for the diagonal elements (\\n\\n\\n\\n\\nl\\n\\nk\\nk\\n\\n\\n\\n\\n{\\displaystyle l_{kk}}\\n\\n) of \\n\\n\\n\\nL\\n\\n\\n{\\displaystyle L}\\n\\n there is a calculation pattern:\\nor in general:\\nFor the elements below the diagonal (\\n\\n\\n\\n\\nl\\n\\ni\\nk\\n\\n\\n\\n\\n{\\displaystyle l_{ik}}\\n\\n, where \\n\\n\\n\\ni\\n>\\nk\\n\\n\\n{\\displaystyle i>k}\\n\\n) there is also a calculation pattern:\\nwhich can also be expressed in a general formula:\\nTask description\\nThe task is to implement a routine which will return a lower Cholesky factor \\n\\n\\n\\nL\\n\\n\\n{\\displaystyle L}\\n\\n for every given symmetric, positive definite nxn matrix \\n\\n\\n\\nA\\n\\n\\n{\\displaystyle A}\\n\\n. You should then test it on the following two examples and include your output.\\nExample 1:\\nExample 2:\\n\\n\\ndecomposition.ads:\\ndecomposition.adb:\\nExample usage:\\n","from __future__ import print_function\\n\\nfrom pprint import pprint\\nfrom math import sqrt\\n\\n\\ndef cholesky(A):\\n    L = [[0.0] * len(A) for _ in xrange(len(A))]\\n    for i in xrange(len(A)):\\n        for j in xrange(i+1):\\n            s = sum(L[i][k] * L[j][k] for k in xrange(j))\\n            L[i][j] = sqrt(A[i][i] - s) if (i == j) else \\\\n                      (1.0 / L[j][j] * (A[i][j] - s))\\n    return L\\n\\nif __name__ == \""__main__\"":\\n    m1 = [[25, 15, -5],\\n          [15, 18,  0],\\n          [-5,  0, 11]]\\n    pprint(cholesky(m1))\\n    print()\\n    \\n    m2 = [[18, 22,  54,  42],\\n          [22, 70,  86,  62],\\n          [54, 86, 174, 134],\\n          [42, 62, 134, 106]]\\n    pprint(cholesky(m2), width=120)"
"Python","Cholesky_decomposition","Every symmetric, positive definite matrix A can be decomposed into a product of a unique lower triangular matrix L and its transpose:\\n\\n\\n\\n\\nL\\n\\n\\n{\\displaystyle L}\\n\\n is called the Cholesky factor of \\n\\n\\n\\nA\\n\\n\\n{\\displaystyle A}\\n\\n, and can be interpreted as a generalized square root of \\n\\n\\n\\nA\\n\\n\\n{\\displaystyle A}\\n\\n, as described in Cholesky decomposition.\\nIn a 3x3 example, we have to solve the following system of equations:\\nWe can see that for the diagonal elements (\\n\\n\\n\\n\\nl\\n\\nk\\nk\\n\\n\\n\\n\\n{\\displaystyle l_{kk}}\\n\\n) of \\n\\n\\n\\nL\\n\\n\\n{\\displaystyle L}\\n\\n there is a calculation pattern:\\nor in general:\\nFor the elements below the diagonal (\\n\\n\\n\\n\\nl\\n\\ni\\nk\\n\\n\\n\\n\\n{\\displaystyle l_{ik}}\\n\\n, where \\n\\n\\n\\ni\\n>\\nk\\n\\n\\n{\\displaystyle i>k}\\n\\n) there is also a calculation pattern:\\nwhich can also be expressed in a general formula:\\nTask description\\nThe task is to implement a routine which will return a lower Cholesky factor \\n\\n\\n\\nL\\n\\n\\n{\\displaystyle L}\\n\\n for every given symmetric, positive definite nxn matrix \\n\\n\\n\\nA\\n\\n\\n{\\displaystyle A}\\n\\n. You should then test it on the following two examples and include your output.\\nExample 1:\\nExample 2:\\n\\n\\ndecomposition.ads:\\ndecomposition.adb:\\nExample usage:\\n","def cholesky(A):\\n    L = [[0.0] * len(A) for _ in range(len(A))]\\n    for i, (Ai, Li) in enumerate(zip(A, L)):\\n        for j, Lj in enumerate(L[:i+1]):\\n            s = sum(Li[k] * Lj[k] for k in range(j))\\n            Li[j] = sqrt(Ai[i] - s) if (i == j) else \\\\n                      (1.0 / Lj[j] * (Ai[j] - s))\\n    return L"
"Python","Church_Numerals","In the Church encoding of natural numbers, the number N is encoded by a function that applies its first argument N times to its second argument.\\n\\nArithmetic operations on natural numbers can be similarly represented as functions on Church numerals.\\nIn your language define:\\n\\nYou should:\\n\\nImplementing churchFromInt as a fold seems to protect Applescript from overflowing its (famously shallow) stack with even quite low Church numerals.\\n","import functools\\nimport itertools\\n\\n# CHURCH ENCODINGS ---------------------------------\\n\\n\\ndef churchZero():\\n    return lambda f: id\\n\\n\\ndef churchSucc(cn):\\n    return lambda f: lambda x: f(cn(f)(x))\\n\\n\\ndef churchAdd(m):\\n    return lambda n: lambda f: lambda x: n(f)(m(f)(x))\\n\\n\\ndef churchMult(m):\\n    return lambda n: lambda f: lambda x: n(m(f))(x)\\n\\n\\ndef churchExp(m):\\n    return lambda n: n(m)\\n\\n\\ndef churchFromInt(n):\\n    return lambda f: (\\n        foldl\\n        (composeR)\\n        (id)\\n        (replicate(n)(f))\\n    )\\n\\n# OR, recursively:\\n# def churchFromInt(n):\\n#    if 0 == n:\\n#        return churchZero()\\n#    else:\\n#        return churchSucc(churchFromInt(n - 1))\\n\\n\\ndef intFromChurch(cn):\\n    return cn(succ)(0)\\n\\n\\n# GENERIC FUNCTIONS -------------------------------\\n\\n# composeR (>>>) :: (a -> b) -> (b -> c) -> a -> c\\ndef composeR(f):\\n    return lambda g: lambda x: f(g(x))\\n\\n\\n# foldl :: (a -> b -> a) -> a -> [b] -> a\\ndef foldl(f):\\n    return lambda a: lambda xs: (\\n        functools.reduce(uncurry(f), xs, a)\\n    )\\n\\n\\n# id :: a -> a\\ndef id(x):\\n    return x\\n\\n\\n# replicate :: Int -> a -> [a]\\ndef replicate(n):\\n    return lambda x: itertools.repeat(x, n)\\n\\n\\n# succ :: Int -> Int\\ndef succ(x):\\n    return 1 + x\\n\\n\\n# uncurry :: (a -> b -> c) -> ((a, b) -> c)\\ndef uncurry(f):\\n    def g(x, y):\\n        return f(x)(y)\\n    return g\\n\\n\\n# MAIN -------------------------------------------\\ndef main():\\n    cThree = churchFromInt(3)\\n    cFour = churchFromInt(4)\\n\\n    print (list(map(intFromChurch, [\\n        churchAdd(cThree)(cFour),\\n        churchMult(cThree)(cFour),\\n        churchExp(cFour)(cThree),\\n        churchExp(cThree)(cFour),\\n    ])))\\n\\n\\nmain()"
"Python","Cipolla's_algorithm","Cipolla's algorithm\\nSolve x² ≡ n (mod p)\\nIn computational number theory, Cipolla's algorithm is a technique for solving an equation of the form x² ≡ n (mod p), where p is an odd prime and x ,n ∊ Fp = {0, 1, ... p-1}.\\nTo apply the algorithm we need the Legendre symbol, and arithmetic in Fp².\\nLegendre symbol\\n\\nArithmetic in Fp²\\nLet ω a symbol such as ω² is a member of Fp and not a square, x and y members of Fp. The set Fp² is defined as {x + ω y }. The subset { x + 0 ω} of Fp² is Fp. Fp² is somewhat equivalent to the field of complex number, with ω analoguous to i, and i² = -1 . Remembering that all operations are modulo p, addition, multiplication and exponentiation in Fp² are defined as :\\n\\nAlgorithm pseudo-code\\nTo compute this step, use a pair of numbers, initially [a,1], and use repeated \""multiplication\"" which is defined such that [c,d] times [e,f] is (mod p) [ c*c + ω²*f*f, d*e + c*f ].\\n\\nExample from Wikipedia\\nTask\\nImplement the above.\\nFind solutions (if any) for\\n\\nExtra credit\\n\\nSee also:\\n\\n","\\n#Converts n to base b as a list of integers between 0 and b-1\\n#Most-significant digit on the left\\ndef convertToBase(n, b):\\n	if(n < 2):\\n		return [n];\\n	temp = n;\\n	ans = [];\\n	while(temp != 0):\\n		ans = [temp % b]+ ans;\\n		temp /= b;\\n	return ans;\\n\\n#Takes integer n and odd prime p\\n#Returns both square roots of n modulo p as a pair (a,b)\\n#Returns () if no root\\ndef cipolla(n,p):\\n	n %= p\\n	if(n == 0 or n == 1):\\n		return (n,-n%p)\\n	phi = p - 1\\n	if(pow(n, phi/2, p) != 1):\\n		return ()\\n	if(p%4 == 3):\\n		ans = pow(n,(p+1)/4,p)\\n		return (ans,-ans%p)\\n	aa = 0\\n	for i in xrange(1,p):\\n		temp = pow((i*i-n)%p,phi/2,p)\\n		if(temp == phi):\\n			aa = i\\n			break;\\n	exponent = convertToBase((p+1)/2,2)\\n	def cipollaMult((a,b),(c,d),w,p):\\n		return ((a*c+b*d*w)%p,(a*d+b*c)%p)\\n	x1 = (aa,1)\\n	x2 = cipollaMult(x1,x1,aa*aa-n,p)\\n	for i in xrange(1,len(exponent)):\\n		if(exponent[i] == 0):\\n			x2 = cipollaMult(x2,x1,aa*aa-n,p)\\n			x1 = cipollaMult(x1,x1,aa*aa-n,p)\\n		else:\\n			x1 = cipollaMult(x1,x2,aa*aa-n,p)\\n			x2 = cipollaMult(x2,x2,aa*aa-n,p)\\n	return (x1[0],-x1[0]%p)\\n\\nprint \""Roots of 2 mod 7: \"" +str(cipolla(2,7))\\nprint \""Roots of 8218 mod 10007: \"" +str(cipolla(8218,10007))\\nprint \""Roots of 56 mod 101: \"" +str(cipolla(56,101))\\nprint \""Roots of 1 mod 11: \"" +str(cipolla(1,11))\\nprint \""Roots of 8219 mod 10007: \"" +str(cipolla(8219,10007))\\n"
"Python","Circles_of_given_radius_through_two_points","Given two points on a plane and a radius, usually two circles of given radius can be drawn through the points.\\n\\n\\n\\n\\nCalculations based on the C solution.\\n","from collections import namedtuple\\nfrom math import sqrt\\n\\nPt = namedtuple('Pt', 'x, y')\\nCircle = Cir = namedtuple('Circle', 'x, y, r')\\n\\ndef circles_from_p1p2r(p1, p2, r):\\n    'Following explanation at http://mathforum.org/library/drmath/view/53027.html'\\n    if r == 0.0:\\n        raise ValueError('radius of zero')\\n    (x1, y1), (x2, y2) = p1, p2\\n    if p1 == p2:\\n        raise ValueError('coincident points gives infinite number of Circles')\\n    # delta x, delta y between points\\n    dx, dy = x2 - x1, y2 - y1\\n    # dist between points\\n    q = sqrt(dx**2 + dy**2)\\n    if q > 2.0*r:\\n        raise ValueError('separation of points > diameter')\\n    # halfway point\\n    x3, y3 = (x1+x2)/2, (y1+y2)/2\\n    # distance along the mirror line\\n    d = sqrt(r**2-(q/2)**2)\\n    # One answer\\n    c1 = Cir(x = x3 - d*dy/q,\\n             y = y3 + d*dx/q,\\n             r = abs(r))\\n    # The other answer\\n    c2 = Cir(x = x3 + d*dy/q,\\n             y = y3 - d*dx/q,\\n             r = abs(r))\\n    return c1, c2\\n\\nif __name__ == '__main__':\\n    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0),\\n                      (Pt(0.0000, 2.0000), Pt(0.0000, 0.0000), 1.0),\\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0),\\n                      (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5),\\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\\n        print('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:'\\n              % (p1, p2, r))\\n        try:\\n            print('  %r\\n  %r\\n' % circles_from_p1p2r(p1, p2, r))\\n        except ValueError as v:\\n            print('  ERROR: %s\\n' % (v.args[0],))"
"Python","Classes","In object-oriented programming class is a set (a transitive closure) of types bound by the relation of inheritance. It is said that all types derived from some base type T and the type T itself form a class T.\\nThe first type T from the class T sometimes is called the root type of the class.\\nA class of types itself, as a type, has the values and operations of its own.\\nThe operations of are usually called methods of the root type.\\nBoth operations and values are called  polymorphic.\\nA polymorphic operation (method) selects an implementation depending on the actual specific type of the polymorphic argument.\\nThe action of choice the type-specific implementation of a polymorphic operation is called dispatch. Correspondingly, polymorphic operations are often called dispatching or virtual.\\nOperations with multiple arguments and/or the results of the class are called multi-methods.\\nA further generalization of is the operation with arguments and/or results from different classes.\\n\\nA polymorphic value has a type tag indicating its specific type from the class and the corresponding specific value of that type.\\nThis type is sometimes called the most specific type of a [polymorphic] value.\\nThe type tag of the value is used in order to resolve the dispatch.\\nThe set of polymorphic values of a class is a transitive closure of the sets of values of all types from that class.\\nIn many  OO languages\\nthe type of the class of T and T itself are considered equivalent.\\nIn some languages they are distinct (like in Ada).\\nWhen class T and T are equivalent, there is no way to distinguish\\npolymorphic and specific values.\\n\\nCreate a basic class with a method, a constructor, an instance variable and how to instantiate it.\\n\\nNote that member functions in 11l by default are not polymorphic; if you want a polymorphic member function, you have to mark it as virtual. Example:\\nClass is used in many languages to provide both encapsulation, or grouping of data and actions, and type definition. Ada packages provide encapsulation or grouping while type definitions are done using the type reserved word. Types participating in inheritance are named tagged record types.\\nA package specification has the following form:\\nThe type declaration at the top of the package gives public visibility to the private tagged type My_Type. Since My_Type is declared to be private, the public has no visibility of its structure. The type must be treated as a black box. The private section of the package specification includes the actual tagged record definition. Note that the data member Variable is initialized to -12. This corresponds to a default constructor for the type.\\nThe package body must contain the implementation of the procedures and functions declared in the package specification.\\nThe Set function acts as a conversion constructor for My_Type.\\nAn instance is typically created outside the package:\\nAikido provides classes with single inheritance and multiple interface implementation. A class takes a set of constructor arguments and provides a set of public functions, operators, classes, monitors and threads.\\nThe following code is experimental. Basically ALGOL 68 is not object oriented, so the task to create (and use of) objects is tedious due to the lack of certain constructs, especially the lack of OO syntactic sugar.\\nFor further details:\\nOther examples of this experimental approach are located at pages: Life in two dimensions, Playing Cards and Stack.\\n","class MyClass:\\n    name2 = 2 # Class attribute\\n\\n    def __init__(self):\\n        \""\""\""\\n        Constructor  (Technically an initializer rather than a true \""constructor\"")\\n        \""\""\""\\n        self.name1 = 0 # Instance attribute\\n  \\n    def someMethod(self):\\n        \""\""\""\\n        Method\\n        \""\""\""\\n        self.name1 = 1\\n        MyClass.name2 = 3\\n  \\n  \\nmyclass = MyClass() # class name, invoked as a function is the constructor syntax.\\n\\nclass MyOtherClass:\\n    count = 0  # Population of \""MyOtherClass\"" objects\\n    def __init__(self, name, gender=\""Male\"", age=None):\\n        \""\""\""\\n        One initializer required, others are optional (with different defaults)\\n        \""\""\""\\n        MyOtherClass.count += 1\\n        self.name = name\\n        self.gender = gender\\n        if age is not None:\\n            self.age = age\\n    def __del__(self):\\n        MyOtherClass.count -= 1\\n\\nperson1 = MyOtherClass(\""John\"")\\nprint person1.name, person1.gender  # \""John Male\""\\nprint person1.age                   # Raises AttributeError exception!\\nperson2 = MyOtherClass(\""Jane\"", \""Female\"", 23)\\nprint person2.name, person2.gender, person2.age  # \""Jane Female 23\"""
"Python","Classes","In object-oriented programming class is a set (a transitive closure) of types bound by the relation of inheritance. It is said that all types derived from some base type T and the type T itself form a class T.\\nThe first type T from the class T sometimes is called the root type of the class.\\nA class of types itself, as a type, has the values and operations of its own.\\nThe operations of are usually called methods of the root type.\\nBoth operations and values are called  polymorphic.\\nA polymorphic operation (method) selects an implementation depending on the actual specific type of the polymorphic argument.\\nThe action of choice the type-specific implementation of a polymorphic operation is called dispatch. Correspondingly, polymorphic operations are often called dispatching or virtual.\\nOperations with multiple arguments and/or the results of the class are called multi-methods.\\nA further generalization of is the operation with arguments and/or results from different classes.\\n\\nA polymorphic value has a type tag indicating its specific type from the class and the corresponding specific value of that type.\\nThis type is sometimes called the most specific type of a [polymorphic] value.\\nThe type tag of the value is used in order to resolve the dispatch.\\nThe set of polymorphic values of a class is a transitive closure of the sets of values of all types from that class.\\nIn many  OO languages\\nthe type of the class of T and T itself are considered equivalent.\\nIn some languages they are distinct (like in Ada).\\nWhen class T and T are equivalent, there is no way to distinguish\\npolymorphic and specific values.\\n\\nCreate a basic class with a method, a constructor, an instance variable and how to instantiate it.\\n\\nNote that member functions in 11l by default are not polymorphic; if you want a polymorphic member function, you have to mark it as virtual. Example:\\nClass is used in many languages to provide both encapsulation, or grouping of data and actions, and type definition. Ada packages provide encapsulation or grouping while type definitions are done using the type reserved word. Types participating in inheritance are named tagged record types.\\nA package specification has the following form:\\nThe type declaration at the top of the package gives public visibility to the private tagged type My_Type. Since My_Type is declared to be private, the public has no visibility of its structure. The type must be treated as a black box. The private section of the package specification includes the actual tagged record definition. Note that the data member Variable is initialized to -12. This corresponds to a default constructor for the type.\\nThe package body must contain the implementation of the procedures and functions declared in the package specification.\\nThe Set function acts as a conversion constructor for My_Type.\\nAn instance is typically created outside the package:\\nAikido provides classes with single inheritance and multiple interface implementation. A class takes a set of constructor arguments and provides a set of public functions, operators, classes, monitors and threads.\\nThe following code is experimental. Basically ALGOL 68 is not object oriented, so the task to create (and use of) objects is tedious due to the lack of certain constructs, especially the lack of OO syntactic sugar.\\nFor further details:\\nOther examples of this experimental approach are located at pages: Life in two dimensions, Playing Cards and Stack.\\n","class MyClass(object):\\n    ..."
"Python","Closures/Value_capture","Create a list of ten functions, in the simplest manner possible   (anonymous functions are encouraged),   such that the function at index    i     (you may choose to start     i     from either    0    or    1),    when run, should return the square of the index,   that is,     i  2.\\nDisplay the result of running any but the last function, to demonstrate that the function indeed remembers its value.\\n\\nDemonstrate how to create a series of independent closures based on the same template but maintain separate copies of the variable closed over.\\nIn imperative languages, one would generally use a loop with a mutable counter variable.\\nFor each function to maintain the correct number, it has to capture the value of the variable at the time it was created, rather than just a reference to the variable, which would have a different value by the time the function was run.\\nSee also: Multiple distinct objects\\nOne way to realize closures in Ada is the usage of protected objects.\\n","funcs = []\\nfor i in range(10):\\n    funcs.append(lambda: i * i)\\nprint funcs[3]() # prints 81"
"Python","Closures/Value_capture","Create a list of ten functions, in the simplest manner possible   (anonymous functions are encouraged),   such that the function at index    i     (you may choose to start     i     from either    0    or    1),    when run, should return the square of the index,   that is,     i  2.\\nDisplay the result of running any but the last function, to demonstrate that the function indeed remembers its value.\\n\\nDemonstrate how to create a series of independent closures based on the same template but maintain separate copies of the variable closed over.\\nIn imperative languages, one would generally use a loop with a mutable counter variable.\\nFor each function to maintain the correct number, it has to capture the value of the variable at the time it was created, rather than just a reference to the variable, which would have a different value by the time the function was run.\\nSee also: Multiple distinct objects\\nOne way to realize closures in Ada is the usage of protected objects.\\n","funcs = []\\nfor i in range(10):\\n    funcs.append(lambda i=i: i * i)\\nprint funcs[3]() # prints 9"
"Python","Closures/Value_capture","Create a list of ten functions, in the simplest manner possible   (anonymous functions are encouraged),   such that the function at index    i     (you may choose to start     i     from either    0    or    1),    when run, should return the square of the index,   that is,     i  2.\\nDisplay the result of running any but the last function, to demonstrate that the function indeed remembers its value.\\n\\nDemonstrate how to create a series of independent closures based on the same template but maintain separate copies of the variable closed over.\\nIn imperative languages, one would generally use a loop with a mutable counter variable.\\nFor each function to maintain the correct number, it has to capture the value of the variable at the time it was created, rather than just a reference to the variable, which would have a different value by the time the function was run.\\nSee also: Multiple distinct objects\\nOne way to realize closures in Ada is the usage of protected objects.\\n","funcs = [lambda i=i: i * i for i in range(10)]\\nprint funcs[3]() # prints 9"
"Python","Closures/Value_capture","Create a list of ten functions, in the simplest manner possible   (anonymous functions are encouraged),   such that the function at index    i     (you may choose to start     i     from either    0    or    1),    when run, should return the square of the index,   that is,     i  2.\\nDisplay the result of running any but the last function, to demonstrate that the function indeed remembers its value.\\n\\nDemonstrate how to create a series of independent closures based on the same template but maintain separate copies of the variable closed over.\\nIn imperative languages, one would generally use a loop with a mutable counter variable.\\nFor each function to maintain the correct number, it has to capture the value of the variable at the time it was created, rather than just a reference to the variable, which would have a different value by the time the function was run.\\nSee also: Multiple distinct objects\\nOne way to realize closures in Ada is the usage of protected objects.\\n","funcs = []\\nfor i in range(10):\\n    funcs.append((lambda i: lambda: i * i)(i))\\nprint funcs[3]() # prints 9"
"Python","Closures/Value_capture","Create a list of ten functions, in the simplest manner possible   (anonymous functions are encouraged),   such that the function at index    i     (you may choose to start     i     from either    0    or    1),    when run, should return the square of the index,   that is,     i  2.\\nDisplay the result of running any but the last function, to demonstrate that the function indeed remembers its value.\\n\\nDemonstrate how to create a series of independent closures based on the same template but maintain separate copies of the variable closed over.\\nIn imperative languages, one would generally use a loop with a mutable counter variable.\\nFor each function to maintain the correct number, it has to capture the value of the variable at the time it was created, rather than just a reference to the variable, which would have a different value by the time the function was run.\\nSee also: Multiple distinct objects\\nOne way to realize closures in Ada is the usage of protected objects.\\n","funcs = [(lambda i: lambda: i)(i * i) for i in range(10)]\\nprint funcs[3]() # prints 9"
"Python","Closures/Value_capture","Create a list of ten functions, in the simplest manner possible   (anonymous functions are encouraged),   such that the function at index    i     (you may choose to start     i     from either    0    or    1),    when run, should return the square of the index,   that is,     i  2.\\nDisplay the result of running any but the last function, to demonstrate that the function indeed remembers its value.\\n\\nDemonstrate how to create a series of independent closures based on the same template but maintain separate copies of the variable closed over.\\nIn imperative languages, one would generally use a loop with a mutable counter variable.\\nFor each function to maintain the correct number, it has to capture the value of the variable at the time it was created, rather than just a reference to the variable, which would have a different value by the time the function was run.\\nSee also: Multiple distinct objects\\nOne way to realize closures in Ada is the usage of protected objects.\\n","funcs = map(lambda i: lambda: i * i, range(10))\\nprint funcs[3]() # prints 9"
"Python","Closures/Value_capture","Create a list of ten functions, in the simplest manner possible   (anonymous functions are encouraged),   such that the function at index    i     (you may choose to start     i     from either    0    or    1),    when run, should return the square of the index,   that is,     i  2.\\nDisplay the result of running any but the last function, to demonstrate that the function indeed remembers its value.\\n\\nDemonstrate how to create a series of independent closures based on the same template but maintain separate copies of the variable closed over.\\nIn imperative languages, one would generally use a loop with a mutable counter variable.\\nFor each function to maintain the correct number, it has to capture the value of the variable at the time it was created, rather than just a reference to the variable, which would have a different value by the time the function was run.\\nSee also: Multiple distinct objects\\nOne way to realize closures in Ada is the usage of protected objects.\\n","funcs=[eval(\""lambda:%s\""%i**2)for i in range(10)]\\nprint funcs[3]() # prints 9"
"Python","Collections","\\nCollections are abstractions to represent sets of values.\\nIn statically-typed languages, the values are typically of a common data type.\\n\\nCreate a collection, and add a few values to it.\\n\\n\\nAda 95 and earlier offers arrays. Ada 2005 adds the Ada.Containers package and its children. Examples of Doubly Linked Lists and Vectors are given.\\nAda 2005 also provides hashed and ordered Maps and Sets (not shown).\\nIn Ada, arrays can be indexed on any range of discrete values. The example below creates an anonymous array indexed from -3 to -1. It initializes the three elements of the array at declaration. Then it reverses their order in the array.\\n\\nAnonymous arrays have no type associated with them that is accessible to the programmer. This means that anonymous arrays cannot be compared in the aggregate to other arrays (even those with the same index structure and contained type) or passed as a parameter to a subprogram. For these reasons, anonymous arrays are best used as singletons and global constants.\\nBecause of the limitations of anonymous arrays noted above, arrays are more typically defined in Ada as array types, as in the example below.\\nDynamic arrays can be created through the use of pointers to unconstrained arrays. While an unconstrained array's index type is defined, it does not have a pre-defined range of indices - they are specified at the time of declaration or, as would be the case in a dynamic array, at the time the memory for the array is allocated. The creation of a dynamic array is not shown here, but below is an example declaration of an unconstrained array in Ada.\\nAime collections include \""list\""s (sequences) and \""record\""s (associative arrays).\\nBoth types of collections are heterogenous and resize dynamically.\\nDeclaring a list:\\nAdding values to it:\\nRetrieving values from a list:\\nDeclaring a record:\\nAdding values to it:\\nRetrieving values from a record:\\nArrays are the closest thing to collections available as standard in Algol 68. Collections could be implemented using STRUCTs but there are none as standard. Some examples of arrays:\\nA list is an ordered collection of elements that are distinguished by their indices\\nCreating Lists\\nAccess elements in a list\\nUsing Array Notation for One-dimensional list\\nA set is an unordered collection of elements that do not contain any duplicates.\\nDefining a set:\\nAccess elements in a set:\\nNote the following limitations on sets:\\nA map is a collection of key-value pairs where each unique key maps to a single value\\nDeclaring a map:\\nAccessing a Map:\\nMap Considerations:\\nMap keys of type String are case-sensitive. Two keys that differ only by the case are considered unique and have corresponding distinct Map entries.Subsequently, the Map methods, including put, get, containsKey, and remove treat these keys as distinct.\\nBoolean, Date, DateTime, Decimal, Double, Enum, Id, Integer, Long, String, Time\\nDocumentation\\nDocumentation: http://www.autohotkey.com/docs/misc/Arrays.htm\\nStructs are not natively supported in AutoHotkey, however they are often required in DllCalls to C++ Dlls.\\nThis shows how to retrieve values from a RECT structure in AutoHotkey (from the DllCall documentation at http://www.autohotkey.com/docs/commands/DllCall.htm)\\nIn awk, the closest thing to collections would be arrays. They are created when needed at assignment\\nor by splitting a string\\nSingle elements are accessible with the bracket notation, like in C:\\nOne can iterate over the elements of an array:\\nIn BBC BASIC the only native type of 'collection' is the array; the index starts at zero and the subscript specified in the DIM is the highest value of the index. Hence in this example an array with two elements is defined:\\nWhen the objects in the collection are not simple scalar types an array of structures may be used:\\nAlthough not a native language feature, other types of collections such as linked lists may be constructed:\\nSee Arrays for basic operations on arrays, the only collection type in bc.\\nSee Also foreach\\nOne thing in C language proper that can be said to be a collection is array type.\\nAn array has a length known at compile time.\\nPlease note that c built-in pointer-arithmetic support which helps this logic. An integer may be 4 bytes, and a char 1 byte: the plus operator (+) is overloaded to multiply a incement by 4 for integer pointers and by 1 for char pointers (etc).\\nAnother construct which can be seen as a collection is a malloced array. The size of a malloced array is not known at compile time.\\nA string is another C language construct (when looked at with its standard libraries) that behaves like a collection.\\nA C language string is an array of char, and it's size may or may not be known at compile time, however a c string is terminated with a ASCII NUL (which may be stated as a constant, '\\0' or ((char)0) in the C language). The String standard library \""class\"" has many \""methods\"", however instead of being called String.method(), they are usually called strmethod().\\nArbitrarily complex data structures can be constructed, normally via language features struct and pointers. They are everywhere, but not provided by the C language itself per se.\\nC++ has a range of different collections optimized for different use cases. Note that in C++, objects of user-defined types are mostly treated just like objects of built-in types; especially there's no different treatment for collections. Thus all collections can simply be demonstrated with the built-in type int. For user-defined types, just replace int with the user-defined type. Any type which goes into a collection must be copyable and assignable (which in general is automatically the case unless you explicitly disallow it).\\nNote however that C++ collections store copies of the objects given to them, so you'll lose any polymorphic behaviour. If you need polymorphism, use a collection of pointers (or smart pointers like boost::shared_ptr).\\nThe simplest collection in C++ is the built-in array. Built-in arrays have a fixed size, and except for POD types (i.e. basically any type you culd also write in C), the members are all initialized at array creation time (if no explicit initialization is done, the default constructr is used).\\nA vector is basically a resizable array. It is optimized for adding/removing elements on the end, and fast access to elements anywhere. Inserting elements at the beginning or in the middle is possible, but in general inefficient.\\nA deque is optimized for appending and removing elements on both ends ofd the array. Accessing random elements is still efficient, but slightly less than with vector.\\nA list is optimized for insertion at an arbitrary place (provided you already have an iterator pointing to that place). Element access is efficient only in linear order.\\nA set keeps the inserted elements sorted, and also makes sure that each element occurs only once. Of course, if you want to put something into a set, it must be less-than-comparable, i.e. you must be able to compare which of two objects a and b is smaller using a<b (there's also a way to define sets with an user-defined order, in which case this restriction doesn't apply).\\nA multiset is like a set, except the same element may occur multiple times.\\nThe size of ArrayList is dynamically increased as required. ArrayLists are zero-based.\\nThe List class is the generic equivalent of the ArrayList class.\\nA List is a strongly typed list of objects that can be accessed by index ( zero-based again).\\nHashtables represent a collection of key/value pairs that are organized based on the hash code of the key.\\nKeys must be unique.\\nDictionary is a generic class.It represents a collection of key/value pairs. Keys must be unique.\\nClojure's collections are immutable: rather than modifying an existing collection, you create a new collection based on a previous one but with changes, for example an additional element.\\nCOBOL is very much a fixed length programming environment. Hierarchical fixed length records are the main data grouping in many COBOL applications.\\nArrays are historically called tables in COBOL literature and are usually defined within a hierarchy. Tables are defined with the reserved word phrases OCCURS n TIMES, and OCCURS FROM n TO m TIMES DEPENDING ON x, (commonly referred to as ODO for short).\\nThis example shows a small record layout inside a very small table. The last line of the output sample is a debug enabled run-time bounds check abend, caused after the table is decreased in size. The first run, without bounds check, runs to an erroneous completion; the second, with debug enabled, does not.\\n","collection = [0, '1']                 # Lists are mutable (editable) and can be sorted in place\\nx = collection[0]                     # accessing an item (which happens to be a numeric 0 (zero)\\ncollection.append(2)                  # adding something to the end of the list\\ncollection.insert(0, '-1')            # inserting a value into the beginning\\ny = collection[0]                     # now returns a string of \""-1\""\\ncollection.extend([2,'3'])            # same as [collection.append(i) for i in [2,'3']] ... but faster\\ncollection += [2,'3']                 # same as previous line\\ncollection[2:6]                       # a \""slice\"" (collection of the list elements from the third up to but not including the sixth)\\nlen(collection)                       # get the length of (number of elements in) the collection\\ncollection = (0, 1)                   # Tuples are immutable (not editable)\\ncollection[:]                         # ... slices work on these too; and this is equivalent to collection[0:len(collection)]\\ncollection[-4:-1]                     # negative slices count from the end of the string\\ncollection[::2]                       # slices can also specify a stride --- this returns all even elements of the collection\\ncollection=\""some string\""              # strings are treated as sequences of characters\\nx = collection[::-1]                  # slice with negative step returns reversed sequence (string in this case).\\ncollection[::2] == \""some string\""[::2] # True, literal objects don't need to be bound to name/variable to access slices or object methods\\ncollection.__getitem__(slice(0,len(collection),2))  # same as previous expressions.\\ncollection = {0: \""zero\"", 1: \""one\""}    # Dictionaries (Hash)\\ncollection['zero'] = 2                # Dictionary members accessed using same syntax as list/array indexes.\\ncollection = set([0, '1'])            # sets (Hash)"
"Python","Color_of_a_screen_pixel","Get color information from an arbitrary pixel on the screen, such as the current location of the mouse cursor.\\nThe mouse cursor may or may not have to be active in a GUI created by your program. These functions are OS related.\\n\\nApp Inventor has two Canvas blocks to determine the color under a pixel.\\nGetBackgroundPixelColor returns a color from the Canvas but ignores Ball sprites and ImageSprites.\\nGetPixelColor returns a color from either the Canvas or a Ball sprite or ImageSprite.\\nIn the app's display below, the purple Ball sprite was touched on the left canvas, but the pixel color (green) returned was from the area below it.\\n<VIEW THE BLOCKS AND ANDROID APP DISPLAY>\\nLow-Resolution (Lo-Res) graphics 40x48, 16 colors, page 1\\nHi-Resolution (Hi-Res) graphics 280x192, 6 colors\\nThere is no HSCRN( X,Y) function in Applesoft. What follows is an elaborate subroutine that determines the hi-res color at the location given by variables X and Y on the current hi-res page. A color value in the range from 0 to 7 is returned in the variable C. The color is determined by peeking at adjacent pixels and the Most Significant Bit MSB. The VTAB routine is used as an aid to calculate the address of pixels. Other colors beyond the 6 hi-res colors can be displayed by positioning pixels at byte boundaries using the MSB. This routine is limited to the eight hi-res colors.\\n","def get_pixel_colour(i_x, i_y):\\n	import win32gui\\n	i_desktop_window_id = win32gui.GetDesktopWindow()\\n	i_desktop_window_dc = win32gui.GetWindowDC(i_desktop_window_id)\\n	long_colour = win32gui.GetPixel(i_desktop_window_dc, i_x, i_y)\\n	i_colour = int(long_colour)\\n	return (i_colour & 0xff), ((i_colour >> 8) & 0xff), ((i_colour >> 16) & 0xff)\\n\\nprint get_pixel_colour(0, 0)"
"Python","Color_of_a_screen_pixel","Get color information from an arbitrary pixel on the screen, such as the current location of the mouse cursor.\\nThe mouse cursor may or may not have to be active in a GUI created by your program. These functions are OS related.\\n\\nApp Inventor has two Canvas blocks to determine the color under a pixel.\\nGetBackgroundPixelColor returns a color from the Canvas but ignores Ball sprites and ImageSprites.\\nGetPixelColor returns a color from either the Canvas or a Ball sprite or ImageSprite.\\nIn the app's display below, the purple Ball sprite was touched on the left canvas, but the pixel color (green) returned was from the area below it.\\n<VIEW THE BLOCKS AND ANDROID APP DISPLAY>\\nLow-Resolution (Lo-Res) graphics 40x48, 16 colors, page 1\\nHi-Resolution (Hi-Res) graphics 280x192, 6 colors\\nThere is no HSCRN( X,Y) function in Applesoft. What follows is an elaborate subroutine that determines the hi-res color at the location given by variables X and Y on the current hi-res page. A color value in the range from 0 to 7 is returned in the variable C. The color is determined by peeking at adjacent pixels and the Most Significant Bit MSB. The VTAB routine is used as an aid to calculate the address of pixels. Other colors beyond the 6 hi-res colors can be displayed by positioning pixels at byte boundaries using the MSB. This routine is limited to the eight hi-res colors.\\n","def get_pixel_colour(i_x, i_y):\\n	import PIL.ImageGrab\\n	return PIL.ImageGrab.grab().load()[i_x, i_y]\\n\\nprint get_pixel_colour(0, 0)"
"Python","Color_of_a_screen_pixel","Get color information from an arbitrary pixel on the screen, such as the current location of the mouse cursor.\\nThe mouse cursor may or may not have to be active in a GUI created by your program. These functions are OS related.\\n\\nApp Inventor has two Canvas blocks to determine the color under a pixel.\\nGetBackgroundPixelColor returns a color from the Canvas but ignores Ball sprites and ImageSprites.\\nGetPixelColor returns a color from either the Canvas or a Ball sprite or ImageSprite.\\nIn the app's display below, the purple Ball sprite was touched on the left canvas, but the pixel color (green) returned was from the area below it.\\n<VIEW THE BLOCKS AND ANDROID APP DISPLAY>\\nLow-Resolution (Lo-Res) graphics 40x48, 16 colors, page 1\\nHi-Resolution (Hi-Res) graphics 280x192, 6 colors\\nThere is no HSCRN( X,Y) function in Applesoft. What follows is an elaborate subroutine that determines the hi-res color at the location given by variables X and Y on the current hi-res page. A color value in the range from 0 to 7 is returned in the variable C. The color is determined by peeking at adjacent pixels and the Most Significant Bit MSB. The VTAB routine is used as an aid to calculate the address of pixels. Other colors beyond the 6 hi-res colors can be displayed by positioning pixels at byte boundaries using the MSB. This routine is limited to the eight hi-res colors.\\n","def get_pixel_colour(i_x, i_y):\\n	import PIL.Image # python-imaging\\n	import PIL.ImageStat # python-imaging\\n	import Xlib.display # python-xlib\\n	o_x_root = Xlib.display.Display().screen().root\\n	o_x_image = o_x_root.get_image(i_x, i_y, 1, 1, Xlib.X.ZPixmap, 0xffffffff)\\n	o_pil_image_rgb = PIL.Image.fromstring(\""RGB\"", (1, 1), o_x_image.data, \""raw\"", \""BGRX\"")\\n	lf_colour = PIL.ImageStat.Stat(o_pil_image_rgb).mean\\n	return tuple(map(int, lf_colour))\\n\\nprint get_pixel_colour(0, 0)"
"Python","Color_of_a_screen_pixel","Get color information from an arbitrary pixel on the screen, such as the current location of the mouse cursor.\\nThe mouse cursor may or may not have to be active in a GUI created by your program. These functions are OS related.\\n\\nApp Inventor has two Canvas blocks to determine the color under a pixel.\\nGetBackgroundPixelColor returns a color from the Canvas but ignores Ball sprites and ImageSprites.\\nGetPixelColor returns a color from either the Canvas or a Ball sprite or ImageSprite.\\nIn the app's display below, the purple Ball sprite was touched on the left canvas, but the pixel color (green) returned was from the area below it.\\n<VIEW THE BLOCKS AND ANDROID APP DISPLAY>\\nLow-Resolution (Lo-Res) graphics 40x48, 16 colors, page 1\\nHi-Resolution (Hi-Res) graphics 280x192, 6 colors\\nThere is no HSCRN( X,Y) function in Applesoft. What follows is an elaborate subroutine that determines the hi-res color at the location given by variables X and Y on the current hi-res page. A color value in the range from 0 to 7 is returned in the variable C. The color is determined by peeking at adjacent pixels and the Most Significant Bit MSB. The VTAB routine is used as an aid to calculate the address of pixels. Other colors beyond the 6 hi-res colors can be displayed by positioning pixels at byte boundaries using the MSB. This routine is limited to the eight hi-res colors.\\n","def get_pixel_colour(i_x, i_y):\\n	import gtk # python-gtk2\\n	o_gdk_pixbuf = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, False, 8, 1, 1)\\n	o_gdk_pixbuf.get_from_drawable(gtk.gdk.get_default_root_window(), gtk.gdk.colormap_get_system(), i_x, i_y, 0, 0, 1, 1)\\n	return tuple(o_gdk_pixbuf.get_pixels_array().tolist()[0][0])\\n\\nprint get_pixel_colour(0, 0)"
"Python","Color_of_a_screen_pixel","Get color information from an arbitrary pixel on the screen, such as the current location of the mouse cursor.\\nThe mouse cursor may or may not have to be active in a GUI created by your program. These functions are OS related.\\n\\nApp Inventor has two Canvas blocks to determine the color under a pixel.\\nGetBackgroundPixelColor returns a color from the Canvas but ignores Ball sprites and ImageSprites.\\nGetPixelColor returns a color from either the Canvas or a Ball sprite or ImageSprite.\\nIn the app's display below, the purple Ball sprite was touched on the left canvas, but the pixel color (green) returned was from the area below it.\\n<VIEW THE BLOCKS AND ANDROID APP DISPLAY>\\nLow-Resolution (Lo-Res) graphics 40x48, 16 colors, page 1\\nHi-Resolution (Hi-Res) graphics 280x192, 6 colors\\nThere is no HSCRN( X,Y) function in Applesoft. What follows is an elaborate subroutine that determines the hi-res color at the location given by variables X and Y on the current hi-res page. A color value in the range from 0 to 7 is returned in the variable C. The color is determined by peeking at adjacent pixels and the Most Significant Bit MSB. The VTAB routine is used as an aid to calculate the address of pixels. Other colors beyond the 6 hi-res colors can be displayed by positioning pixels at byte boundaries using the MSB. This routine is limited to the eight hi-res colors.\\n","def get_pixel_colour(i_x, i_y):\\n	import PyQt4.QtGui # python-qt4\\n	app = PyQt4.QtGui.QApplication([])\\n	long_qdesktop_id = PyQt4.QtGui.QApplication.desktop().winId()\\n	long_colour = PyQt4.QtGui.QPixmap.grabWindow(long_qdesktop_id, i_x, i_y, 1, 1).toImage().pixel(0, 0)\\n	i_colour = int(long_colour)\\n	return ((i_colour >> 16) & 0xff), ((i_colour >> 8) & 0xff), (i_colour & 0xff)\\n\\nprint get_pixel_colour(0, 0)"
"Python","Color_quantization","Color quantization is the process of reducing number of colors used in an image while trying to maintain the visual appearance of the original image. In general, it is a form of cluster analysis, if each RGB color value is considered as a coordinate triple in the 3D colorspace. There are some well know algorithms [1], each with its own advantages and drawbacks.\\nTask: Take an RGB color image and reduce its colors to some smaller number (< 256). For this task, use the frog as input and reduce colors to 16, and output the resulting colors. The chosen colors should be adaptive to the input image, meaning you should not use a fixed palette such as Web colors or Windows system palette. Dithering is not required.\\nNote: the funny color bar on top of the frog image is intentional.\\n\\nUsing an octree to store colors. Here are only the relevant parts. For full C code see Color_quantization/C. It's different from the standard octree method in that:\\nThe output image is better at preserving textures of the original than Gimp, though it obviously depends on the input image. This particular frog image has the color bar added at the top specifically to throw off some early truncation algorithms, which Gimp is suseptible to.\\n\\nUse median cut.\\nThis code retains the style of the original OCaML code, and uses the bitmap module from the Bitmap Task.\\nThis code retains part of the style of the original C code.\\nCompiled with ldc2, it runs on the quantum_frog image in about 0.20 seconds with dithering and about 0.10 seconds without dithering.\\nA very basic median cut algorithm, no dithering.\\nA variation of the median cut algorithm by splitting color space on the nearest to the mean instead. It provides lower error than the Gimp output sample.\\nHere, we use a simplistic averaging technique to build an initial set of colors and then use k-means clustering to refine them.\\nThe left argument is the number of colors desired.\\nThe right argument is the image, with pixels represented as bmp color integers (base 256 numbers).\\nThe result is the colors represented as pixel triples (blue, green, red). They are shown here as fractional numbers, but they should be either rounded to the nearest integer in the range 0..255 (and possibly converted back to bmp integer form) or scaled so they are floating point triples in the range 0..1.\\nThe Images package for Julia uses the ImageMagick libraries by default, but this Julia module does not currently implement ImageMagick's support for color quantization. However, once ImageMagick is installed for the Images Julia module, a direct call to ImageMagick's convert command is possible.\\n\\nRather than coding this from scratch, we invoke programatically ImageMagick's 'convert' tool which has all this stuff built in.\\n","from PIL import Image\\n\\nif __name__==\""__main__\"":\\n	im = Image.open(\""frog.png\"")\\n	im2 = im.quantize(16)\\n	im2.show()"
"Python","Color_wheel","Write a function to draw a HSV color wheel[1] completely with code.\\nThis is strictly for learning purposes only. It's highly recommended that you use an image in an actual application to actually draw the color wheel   (as procedurally drawing is super slow). This does help you understand how color wheels work and this can easily be used to determine a color value based on a position within a circle.\\n\\n","from PIL import Image\\nimport colorsys\\nimport math\\n\\nif __name__ == \""__main__\"":\\n\\n	im = Image.new(\""RGB\"", (300,300))\\n	radius = min(im.size)/2.0\\n	centre = im.size[0]/2, im.size[1]/2\\n	pix = im.load()\\n\\n	for x in range(im.width):\\n		for y in range(im.height):\\n			rx = x - centre[0]\\n			ry = y - centre[1]\\n			s = ((x - centre[0])**2.0 + (y - centre[1])**2.0)**0.5 / radius\\n			if s <= 1.0:\\n				h = ((math.atan2(ry, rx) / math.pi) + 1.0) / 2.0\\n				rgb = colorsys.hsv_to_rgb(h, s, 1.0)\\n				pix[x,y] = tuple([int(round(c*255.0)) for c in rgb])\\n\\n	im.show()"
"Python","Colour_bars/Display","Display a series of vertical color bars across the width of the display.\\nThe color bars should either use:\\n\\nThis task achieved only on Commodore computers with color capabilities. The example below tested as-is in VICE on the following machines:\\n\\nIt will also work well on the VIC-20 if you either omit line 310 or comment (REM) it out as the VIC-20 has only an eight-color palette.\\nThis cross-compatibility is achieved by using the PETSCII control codes (CHR$(x)) for changing color, which are generally the same across all platforms, although the system palettes themselves may differ. This is combined with printing a \""reverse video\"" space (solid block) character in the color selected.\\nShow the default MODE 0 palette (includes two blinking colors at the end):\\nPress Enter or Escape to exit the program.\\n\\nAssuming a terminal with support for ANSI escape sequences, this fills the screen with the colour sequence: black, red, green, blue, magenta, cyan, yellow and white. It then waits for the user to press Enter before terminating.\\nThis task requires functionality which allows the code to communicate to the video device. This will vary from vendor to vendor. The following examples show two ways of doing this, in the text and graphics mode, using Borland's Turbo C.\\nThe required functions and structures are in conio.h\\nThe required functions and structures are in graphics.h, conio.h is included for getch().\\nusing Qt 4.6\\nfile colorbars.h:\\nfile colorbars.cpp:\\nfile main.cpp:\\nThis program extends ANS Forth to control the TMS9918 Video display processor in the TI-99 computer.\\n The color bars are shown in Society of Motion Picture and Television Engineers (SMPTE) order.\\n","\\n#!/usr/bin/env python\\n#vertical coloured stripes in window in Python 2.7.1\\n\\nfrom livewires import *\\n\\nhoriz=640; vert=480\\nbegin_graphics(width=horiz,height=vert,title=\""v_stripes\"",background=Colour.black)\\nNameColors=[\""black\"",\""red\"",\""green\"",\""dark_blue\"",\""purple\"",\""blue\"",\""yellow\"",\""white\""]\\nstepik=horiz/len(NameColors)\\n\\nfor index,each in enumerate(NameColors):\\n	ExcStrng=\""set_colour(Colour.\""+each+\"")\""\\n	exec ExcStrng\\n	box(index*stepik,0,(index+1)*stepik,vert,filled=1)\\n\\nwhile keys_pressed() != ['x']: # press x key to terminate program\\n	pass\\n\\nend_graphics()\\n"
"Python","Colour_pinstripe/Display","The task is to create 1 pixel wide coloured vertical pinstripes with a sufficient number of pinstripes to span the entire width of the graphics display. The pinstripes should either follow the system palette sequence or a sequence that includes Black, Red, Green, Blue, Magenta, Cyan, Yellow, White.\\nAfter filling the top quarter of the display, we switch to a wider 2 pixel wide vertical pinstripe pattern. Halfway down the display we switch to 3 pixel wide vertical pinstripe and then finally to a 4 pixels wide vertical pinstripe for the last quarter of the display.\\nc.f. Pinstripe/Display\\nRequires the GDI+ standard library: http://www.autohotkey.com/forum/viewtopic.php?t=32238\\nIt is worth noting that this fills the whole screen; press Esc to exit.\\nWrites the image to stdout using the PPM format. You can either redirect that to a file, or pipe it to something like ImageMagick's display utility to view the result.\\nThe dimensions of the image are specified by the first two values on the stack: 1366 (\""%\"":*3-) by 768 (\""`\""8*).\\nThe following code uses the BGI graphics library of Borland's Turbo C.\\n\\nUsing Allegro's Common Graphics. As stated in the comments, I'm using line drawing here\\nwhich causes the line caps to make the edges between regions to be a bit ragged. I mention\\na couple of alternatives there which I'm too lazy to implement right now.\\nClick to see output image\\n","\\nfrom turtle import *\\n\\ncolors = [\""black\"", \""red\"", \""green\"", \""blue\"", \""magenta\"", \""cyan\"", \""yellow\"", \""white\""]\\n\\n# Middle of screen is 0,0\\n\\nscreen = getscreen()\\n\\nleft_edge = -screen.window_width()//2\\n\\nright_edge = screen.window_width()//2\\n\\nquarter_height = screen.window_height()//4\\n\\nhalf_height = quarter_height * 2\\n\\nspeed(\""fastest\"")\\n\\nfor quarter in range(4):\\n    pensize(quarter+1)\\n    colornum = 0\\n\\n    min_y = half_height - ((quarter + 1) * quarter_height)\\n    max_y = half_height - ((quarter) * quarter_height)\\n    \\n    for x in range(left_edge,right_edge,quarter+1):\\n        penup()\\n        pencolor(colors[colornum])\\n        colornum = (colornum + 1) % len(colors)\\n        setposition(x,min_y)\\n        pendown()\\n        setposition(x,max_y)\\n         \\nnotused = input(\""Hit enter to continue: \"")\\n"
"Python","Combinations","Given non-negative integers    m    and    n,   generate all size    m    combinations   of the integers from    0   (zero)   to    n-1    in sorted order   (each combination is sorted and the entire table is sorted).\\n\\n3   comb    5      is:\\nIf it is more \""natural\"" in your language to start counting from    1   (unity) instead of    0   (zero),\\nthe combinations can be of the integers from    1   to    n. \\n\\n\\n",">>> from itertools import combinations\\n>>> list(combinations(range(5),3))\\n[(0, 1, 2), (0, 1, 3), (0, 1, 4), (0, 2, 3), (0, 2, 4), (0, 3, 4), (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]"
"Python","Combinations","Given non-negative integers    m    and    n,   generate all size    m    combinations   of the integers from    0   (zero)   to    n-1    in sorted order   (each combination is sorted and the entire table is sorted).\\n\\n3   comb    5      is:\\nIf it is more \""natural\"" in your language to start counting from    1   (unity) instead of    0   (zero),\\nthe combinations can be of the integers from    1   to    n. \\n\\n\\n","def comb(m, lst):\\n    if m == 0: return [[]]\\n    return [[x] + suffix for i, x in enumerate(lst)\\n            for suffix in comb(m - 1, lst[i + 1:])]"
"Python","Combinations","Given non-negative integers    m    and    n,   generate all size    m    combinations   of the integers from    0   (zero)   to    n-1    in sorted order   (each combination is sorted and the entire table is sorted).\\n\\n3   comb    5      is:\\nIf it is more \""natural\"" in your language to start counting from    1   (unity) instead of    0   (zero),\\nthe combinations can be of the integers from    1   to    n. \\n\\n\\n",">>> comb(3, range(5))\\n[[0, 1, 2], [0, 1, 3], [0, 1, 4], [0, 2, 3], [0, 2, 4], [0, 3, 4], [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]"
"Python","Combinations","Given non-negative integers    m    and    n,   generate all size    m    combinations   of the integers from    0   (zero)   to    n-1    in sorted order   (each combination is sorted and the entire table is sorted).\\n\\n3   comb    5      is:\\nIf it is more \""natural\"" in your language to start counting from    1   (unity) instead of    0   (zero),\\nthe combinations can be of the integers from    1   to    n. \\n\\n\\n","def comb(m, s):\\n    if m == 0: return [[]]\\n    if s == []: return []\\n    return [s[:1] + a for a in comb(m-1, s[1:])] + comb(m, s[1:])\\n\\nprint comb(3, range(5))"
"Python","Combinations_and_permutations","\\nImplement the combination    (nCk)    and permutation    (nPk)    operators in the target language:\\n\\nSee the Wikipedia articles for a more detailed description.\\nTo test, generate and print examples of:\\n\\n\\nBracmat cannot handle floating point numbers. Instead, this solution shows the first 50 digits and a count of the digits that are not shown.\\nOutput:\\nUsing big integers. GMP in fact has a factorial function which is quite possibly more efficient, though using it would make code longer.\\n","from __future__ import print_function\\n\\nfrom scipy.misc import factorial as fact\\nfrom scipy.misc import comb\\n\\ndef perm(N, k, exact=0):\\n    return comb(N, k, exact) * fact(k, exact)\\n\\nexact=True\\nprint('Sample Perms 1..12')\\nfor N in range(1, 13):\\n    k = max(N-2, 1)\\n    print('%iP%i =' % (N, k), perm(N, k, exact), end=', ' if N % 5 else '\\n')\\n          \\nprint('\\n\\nSample Combs 10..60')\\nfor N in range(10, 61, 10):\\n    k = N-2\\n    print('%iC%i =' % (N, k), comb(N, k, exact), end=', ' if N % 50 else '\\n')\\n\\nexact=False\\nprint('\\n\\nSample Perms 5..1500 Using FP approximations')\\nfor N in [5, 15, 150, 1500, 15000]:\\n    k = N-2\\n    print('%iP%i =' % (N, k), perm(N, k, exact))\\n          \\nprint('\\nSample Combs 100..1000 Using FP approximations')\\nfor N in range(100, 1001, 100):\\n    k = N-2\\n    print('%iC%i =' % (N, k), comb(N, k, exact))\\n"
"Python","Combinations_with_repetitions","The set of combinations with repetitions is computed from a set, \\n\\n\\n\\nS\\n\\n\\n{\\displaystyle S}\\n\\n (of cardinality \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n), and a size of resulting selection, \\n\\n\\n\\nk\\n\\n\\n{\\displaystyle k}\\n\\n, by reporting the sets of cardinality \\n\\n\\n\\nk\\n\\n\\n{\\displaystyle k}\\n\\n where each member of those sets is chosen from \\n\\n\\n\\nS\\n\\n\\n{\\displaystyle S}\\n\\n.\\nIn the real world, it is about choosing sets where there is a “large” supply of each type of element and where the order of choice does not matter.\\nFor example:\\nNote that both the order of items within a pair, and the order of the pairs given in the answer is not significant; the pairs represent multisets.\\nAlso note that doughnut can also be spelled donut.\\n\\n\\n\\n\\nShould work for any discrete type: integer, modular, or enumeration.\\ncombinations.adb:\\n",">>> from itertools import combinations_with_replacement\\n>>> n, k = 'iced jam plain'.split(), 2\\n>>> list(combinations_with_replacement(n,k))\\n[('iced', 'iced'), ('iced', 'jam'), ('iced', 'plain'), ('jam', 'jam'), ('jam', 'plain'), ('plain', 'plain')]\\n>>> # Extra credit\\n>>> len(list(combinations_with_replacement(range(10), 3)))\\n220\\n>>> "
"Python","Comma_quibbling","Comma quibbling is a task originally set by Eric Lippert in his blog.\\n\\nWrite a function to generate a string output which is the concatenation of input words from a list/sequence where:\\n\\nTest your function with the following series of inputs showing your output here on this page:\\n\\nNote: Assume words are non-empty strings of uppercase characters for this task.\\n\\n",">>> def strcat(sequence):\\n    return '{%s}' % ', '.join(sequence)[::-1].replace(',', 'dna ', 1)[::-1]\\n\\n>>> for seq in ([], [\""ABC\""], [\""ABC\"", \""DEF\""], [\""ABC\"", \""DEF\"", \""G\"", \""H\""]):\\n    print('Input: %-24r -> Output: %r' % (seq, strcat(seq)))\\n\\n	\\nInput: []                       -> Output: '{}'\\nInput: ['ABC']                  -> Output: '{ABC}'\\nInput: ['ABC', 'DEF']           -> Output: '{ABC and DEF}'\\nInput: ['ABC', 'DEF', 'G', 'H'] -> Output: '{ABC, DEF, G and H}'\\n>>> "
"Python","Comma_quibbling","Comma quibbling is a task originally set by Eric Lippert in his blog.\\n\\nWrite a function to generate a string output which is the concatenation of input words from a list/sequence where:\\n\\nTest your function with the following series of inputs showing your output here on this page:\\n\\nNote: Assume words are non-empty strings of uppercase characters for this task.\\n\\n","def commaQuibble(s):\\n    return '{%s}' % ' and '.join(s).replace(' and ', ', ', len(s) - 2)\\n\\nfor seq in ([], [\""ABC\""], [\""ABC\"", \""DEF\""], [\""ABC\"", \""DEF\"", \""G\"", \""H\""]):\\n	print('Input: %-24r -> Output: %r' % (seq, commaQuibble(seq)))"
"Python","Comma_quibbling","Comma quibbling is a task originally set by Eric Lippert in his blog.\\n\\nWrite a function to generate a string output which is the concatenation of input words from a list/sequence where:\\n\\nTest your function with the following series of inputs showing your output here on this page:\\n\\nNote: Assume words are non-empty strings of uppercase characters for this task.\\n\\n",">>> def quibble(s):\\n    return ('{' +\\n                (', '.join(s[:-1]) + ' and ' if len(s) > 1 else '') +\\n	        (s[-1] if s else '') +\\n	    '}')\\n\\n>>> for seq in ([], [\""ABC\""], [\""ABC\"", \""DEF\""], [\""ABC\"", \""DEF\"", \""G\"", \""H\""]):\\n	print('Input: %-24r -> Output: %r' % (seq, quibble(seq)))\\n\\n	\\nInput: []                       -> Output: '{}'\\nInput: ['ABC']                  -> Output: '{ABC}'\\nInput: ['ABC', 'DEF']           -> Output: '{ABC and DEF}'\\nInput: ['ABC', 'DEF', 'G', 'H'] -> Output: '{ABC, DEF, G and H}'\\n>>> "
"Python","Command-line_arguments","See also Program name.\\nFor parsing command line arguments intelligently, see Parsing command-line arguments.\\nExample command line:\\n:argv is a list containing all command line arguments, including the program name.\\nIn Ada95 and later versions, command line arguments are available through the predefined package Ada.Command_Line. In Ada83, this would be implementation dependent.\\nUses Matreshka\\nThe arguments are passed to the program as a vector of strings called args\\nLinux command:\\nOutput:\\nFrom the AutoHotkey documentation:\\n\""The script sees incoming parameters as the variables %1%, %2%, and so on. In addition, %0% contains the number of parameters passed (0 if none). \""\\n\\nInvoke Babel in interactive mode with arguments using the -i switch:\\nPrint the argv list with newlines:\\n","import sys\\nprogram_name = sys.argv[0]\\narguments = sys.argv[1:]\\ncount = len(arguments)"
"Python","Commatizing_numbers","Commatizing   numbers (as used here, a handy expedient made-up word) is the act of adding commas to a number (or string), or the numeric part of a larger string.\\n\\nWrite a function that takes a string as an argument with optional arguments or parameters (the format of parameters/options is left to the programmer) that in general, adds commas (or some\\nother characters, including blanks or tabs) to the first numeric part of a string (if it's suitable for commatizing as per the rules below), and returns that newly commatized string.\\nSome of the commatizing rules (specified below) are arbitrary, but they'll be a part of this task requirements, if only to make the results consistent amongst national preferences and other disciplines.\\nThe number may be part of a larger (non-numeric) string such as:\\n\\nThe string may possibly not have a number suitable for commatizing, so it should be untouched and no error generated.\\nIf any argument (option) is invalid, nothing is changed and no error need be generated (quiet execution, no fail execution).   Error message generation is optional.\\nThe exponent part of a number is never commatized.   The following string isn't suitable for commatizing:   9.7e+12000\\nLeading zeroes are never commatized.   The string   0000000005714.882   after commatization is:   0000000005,714.882\\nAny   period   (.)   in a number is assumed to be a   decimal point.\\nThe original string is never changed   except   by the addition of commas   [or whatever character(s) is/are used for insertion], if at all.\\nTo wit, the following should be preserved:\\n\\nAny exponent character(s) should be supported:\\nNumbers may be terminated with any non-digit character, including subscripts and/or superscript:   41421356243   or   7320509076(base 24).\\nThe character(s) to be used for the comma can be specified, and may contain blanks, tabs, and other whitespace characters, as well as multiple characters.   The default is the comma (,) character.\\nThe   period length   can be specified   (sometimes referred to as \""thousands\"" or \""thousands separators\"").   The   period length   can be defined as the length (or number) of the decimal digits between commas.   The default period length is   3.\\nThe location of where to start the scanning for the target field (the numeric part) should be able to be specified.   The default is   1.\\nThe character strings below may be placed in a file (and read) or stored as simple strings within the program.\\n\\nThe value of   pi   (expressed in base 10)   should be separated with blanks every   5   places past the decimal point,\\nthe Zimbabwe dollar amount should use a decimal point for the \""comma\"" separator:\\nwhere the penultimate string has three leading blanks   (real blanks are to be used).\\n\\n","\\nimport re as RegEx\\n\\n\\ndef Commatize( _string, _startPos=0, _periodLen=3, _separator=\"",\"" ):\\n	outString = \""\""\\n	strPos = 0\\n	matches = RegEx.findall( \""[0-9]*\"", _string )\\n\\n	for match in matches[:-1]:\\n		if not match:\\n			outString += _string[ strPos ]\\n			strPos += 1\\n		else:\\n			if len(match) > _periodLen:\\n				leadIn = match[:_startPos]\\n				periods =  [ match [ i:i + _periodLen ] for i in range ( _startPos, len ( match ), _periodLen ) ]\\n				outString += leadIn + _separator.join( periods )\\n			else:\\n				outString += match\\n\\n			strPos += len( match )\\n\\n	return outString\\n\\n\\n\\nprint ( Commatize( \""pi=3.14159265358979323846264338327950288419716939937510582097494459231\"", 0, 5, \"" \"" ) )\\nprint ( Commatize( \""The author has two Z$100000000000000 Zimbabwe notes (100 trillion).\"", 0, 3, \"".\"" ))\\nprint ( Commatize( \""\\\""-in Aus$+1411.8millions\\\""\"" ))\\nprint ( Commatize( \""===US$0017440 millions=== (in 2000 dollars)\"" ))\\nprint ( Commatize( \""123.e8000 is pretty big.\"" ))\\nprint ( Commatize( \""The land area of the earth is 57268900(29% of the surface) square miles.\"" ))\\nprint ( Commatize( \""Ain't no numbers in this here words, nohow, no way, Jose.\"" ))\\nprint ( Commatize( \""James was never known as 0000000007\"" ))\\nprint ( Commatize( \""Arthur Eddington wrote: I believe there are 15747724136275002577605653961181555468044717914527116709366231425076185631031296 protons in the universe.\"" ))\\nprint ( Commatize( \""␢␢␢$-140000±100 millions.\"" ))\\nprint ( Commatize( \""6/9/1946 was a good year for some.\"" ))\\n"
"Python","Comments","Show all ways to include text in a language source file\\nthat's completely ignored by the compiler or interpreter.\\n\\n\\n\\nNote: syntax depends on the assembler software but use of a semicolon is fairly standard\\nNote: syntax depends on the assembler software but use of a semicolon is fairly standard\\nJust like Common Lisp:\\nAgena has single line comments and two styles of multi-line comments.\\nA comment in ALGOL 60 takes the place of a single instruction.\\nComments can be inserted in variety of ways:\\nincludes bold typeface.\\nlike to Wiki markup.\\n7-bit/ascii implementations.\\ndetecting reserved words.\\n6-bits/byte implementations.\\ncomment text comment\\n'comment' text 'comment'\\nCOMMENT text COMMENT\\ncomment text comment\\n.COMMENT TEXT .COMMENT\\nNotes:\\nComments in Algol W can appear anywhere whitespace is allowed. A comment starts with the reserved word 'comment' and ends with the next semi-colon. Alternatively a comment can start with a percent sign and end with the next percent sign or semi-colon.\\nA single word in the form of an identifier following the reserved word 'end' is also a comment.\\nArendelle uses C style comments\\nSee programming introduction in the Asymptote manual.\\nWhen reading data files a comment character in them can be specified as comment=\""#\"" etc. See Files in the Asymptote manual.\\nFor multi-line comments, the /* and */ must be on their own separate lines. Nothing else can be on the same line.\\nThe hash symbol # start a comment; it ends at the end of line.\\n\\nThe only truly standard method of marking a comment in BASIC is using the REM keyword. This dates back to (at least) the late 1970's, and should work with most BASICs available today:\\nThis may not be well known, but you may include text after the line number of GOTO and GOSUB statements. This is kind of a comment in absence of labels.\\nSpaces are removed from non-keyword text. BASIC keywords can be used.\\nList outputs spaces around keywords.\\nMost BASICs also support alternate comment characters,\\ncommonly an apostrophe (single quote):\\nCharacters other than apostrophe are used in some BASICs. For example, DarkBASIC uses a back-tick character (`, a.k.a. grave accent):\\nIn addition to single-line comments, a few BASICs support block comments. FreeBASIC was influenced by the C family's block comment characters:\\nBaCon accepts REM (or single quote apostrophe) for line comments.\\nC-style block comments can be used with /* and */ pairs; these comment blocks may cross line boundaries.\\nInside USEC sections, all comment styles accepted by the configured C compiler will also be ignored.\\nThere is another (unsupported) option, using a double-colon ::. However, this has issues with some syntactic constructs and therefore may raise syntax errors.\\nSince comment lines are skipped entirely by the parser multi-line comments aren't possible even with line continuation.\\n\\nLike Brainf***, all characters and whitespace which are not commands are ignored.\\nAlso, since the code/data-space is two-dimensional, comments can be placed anywhere that will be untouched by the instruction pointer and data access commands.\\nFinally, in Funge-98, the ; instruction immediately skips to the next ; instruction, which allows to isolate comments from code.\\nBracmat uses curly braces as comment delimiters. Curly braces inside comments must be balanced. Comments are so much ignored when source code is read, that they do not reappear in listings created by the built-in lst$ function, an otherwise very useful function to autoindent your code.\\nMost ASCII characters may be used for comments; only the eight characters \""+-<>[],.\"" are Brainf*** commands. Extra care must be used when using punctuation, particularly the comma or period. These are I/O operators and are actually commands rather than comments, and are instead compiled into the program if used and may have to be \""debugged\"" and removed if you forget this issue.\\nBurlesque does NOT have comments. However, you can comment code by pushing a string and popping it immediately.\\nSince strings are multi-line strings:\\nThe comment starts at the /*, and ends at the */. A comment may be used between any tokens. It cannot be used inside tokens, that is, given the code\\nthe function takes an argument of type char, named isma, not an unnamed argument of type charisma.\\nComments cannot be nested; that is, if you write\\nthe comment ends at the first */, and inside */ is again interpreted as source code (almost certainly causing a compile error). Some compilers have the option to allow nested comments, but this is not a standard feature.\\nConditional compilation also can be used to make the compiler ignore some text:\\nThe trick is that 0 is always false, therefore the text between #if 0 and #endif is never compiled. While this should never be used for actual comments, it's an easy way to comment out some code, especially because it doesn't interfere with normal (documentation) comments.\\nConditional compile \""comments\"" can be nested:\\nEven though the compiler doesn't see #if 0 text, the preprocessor does. Therefore some minimal rules still have to be followed. For example, the following code is not valid:\\nThat's because the preprocessor will interpret the apostrophe as beginning of a character constant, and will complain because that character constant isn't terminated with another apostrophe.\\nNote that the problem mentioned above cannot occur if there's valid code between the #if 0 and #endif.\\nSingle line C++-style comments\\nC++-style comments start with // and reach up to, but not including, the end of line (more exactly, up to the next unescaped newline). While formally, C++-style comments cannot be nested either, in practice they can:\\nThat's because starting with the first // everything in the line is ignored, including the second //.\\nThe fact that the newline is not part of the comment is important for multi-line macro definitions. It means that in the code\\nthe line (no more macro text) is not part of the macro definition. Also escaping the line break at the end of the comment with '\\' doesn't help, because that would make the third line part of the comment instead. Comments inside macros therefore have to be C-style.\\nClean comments are similar to C++.\\nIn contrast to C++ comments can be nested.\\nAnything from a semicolon to the end of a line is a comment.\\nThe (comment) macro will prevent a form from being evaluated, returning nil no matter what is contained in the comment. However the forms inside the comment form must be properly parseable (parentheses balanced, etc.) or an exception will be thrown.\\nFinally, the #_ reader macro will cause a form to be ignored by the reader. Unlike (comment), this does not return nil; the surrounding code is evaluated as though the ignored form isn't even there.\\nA D in the 7th column indicates a debugging line which is treated like a comment unless a compiler flag is set.\\nThis indicates a debugging line like above, but if it is used in fixed format files, it must be in the 8th column or beyond. Not necessarily. GnuCOBOL also supports D as an indicator in column 7, the >>D format works (more by trickery than spec) if the angle brackets start in column 5, the D ending up in column 7. The >>D debug marker can then be both fixed and free form compatible.\\nThis statement causes everything following it up to the next separator period to be treated as a comment. This statement was deleted in COBOL-74.\\nThere are quite a few IDENTIFICATION DIVISION obsolete and extension reserved words that will work in GnuCOBOL 2.\\nIn tags:\\nIn script:\\nCommon Lisp provides line comments (;) and block comments (#|...|#).\\nBlock comments can nest (#|...#|...|#...|#), unlike block comments in e.g. C.\\nIn a common convention, header comments are prefaced with four semicolons, top-level (function level) comments use three, comments for sections of code use two, and margin comments use one.\\nHowever, comments should not be used for inline documentation, as most defining constructs permit a documentation string (which is then available at runtime).\\nThere is no comment syntax in POSIX dc. The convention is to make a string on the stack and move it to an unused register; a no-op.\\nGNU dc added the comment syntax of many other scripting languages.\\nComments are only allowed in places such as \""on load\"" scripts. You cannot put them in form or view definitions.\\nIn addition to Pascal, Delphi also allows C++ style single line comments:\\nAll comments span to the end of the line; there are no paired-delimiter comment syntaxes. “#” begins a comment anywhere outside of quotes; “?” and “>” begin comments only if they are at the beginning of a line (except for whitespace), because those characters are also used for infix operators.\\nIn Updoc, “?” indicates the beginning of a program fragment, “>” the continuation of one, and “#” begins the expected output from its evaluation; “??” indicates special directives.\\nSingle-line comments must begin with //\\nBlock comments must be delimited with /* and */\\nThe original EDSAC made no provision for comments in source code. Modern simulators, however, accept square brackets as comment delimiters.\\nElixir does not have multiple line comments.\\nA comment is started by ; and reaches to the end of the line.\\nThere are some coding conventions for ;; align to indentation, ;;; sections, etc,\\nAnother way to add comments is to use strings at places where the result of an expression is ignored, since they simply evaluate to themselves without any effect. Note that strings can be multi-line:\\nNote that strings at the beginning of function definitions are interpreted as documentation strings for the function (i.e. Emacs will display them if asked for help about the function), e.g.\\nDue to this, it's debatable if the string at that place can be considered as comment.\\n\\nSingle line comment:\\n\\nMultiline C-style comment:\\nF# accepts C++ type line comments and OCaml type block comments\\nFalcon supports C-language style single line and block comments. A single line comment begins with two slashes (//) and ends at the end of the line. A block comment begins with a slash followed by an asterisk, and terminates when an asterisk followed by a slash is met (/*...*/).\\nSince ><> is a funge-like language, all characters not touched by the command pointer or modified by the p and g commands can be comments.\\nUnlike Brainf***, unknown commands are not ignored by the compiler, they just raise an error.\\nStandard Forth includes a number of ways to add comment text. As with everything in Forth, comment characters are actually words that control the compiler.\\nTraditionally, the paren comments are used for \""stack effect\"" notation:\\nThis comment means \""myword takes two cells on the stack and leaves one\"". Sometimes, stack effect comment names give clues about the word's function:\\nSome Forth systems implement other commenting words, such as these words from Win32Forth:\\nCompiler: ANSI FORTRAN 77 or compatible (like g77 -strict)\\nThe first six columns in Fortran are traditionally reserved for labels and certain special characters. In particular the letter \""C\"" in the first column indicates a comment:\\nSome Fortran compilers have the extension that comments starting with D are treated as non-comments if a special debugging flag is given at the compiler invocation. For example:\\nISO Fortran 90 or later have an inline comment (!) syntax:\\nIn ISO Fortran 90 or later, \""C in first column\"" comments are only allowed in the \""fixed\"" source form familiar to FORTRAN 77 programmers. The \""free\"" source form only has inline comments (!).\\nISO Fortran 95 or later has an optional conditional compilation syntax. If present, it can be used (abused?) to (in effect) comment out blocks of code:\\n\\nIn gambas, comments can be inserted by prefixing them with an apostrophe. The gambas interpreter will ignore the apostrophe and any other characters that follow it until the end of the line:\\nA shebang (#!) may be used as a comment in the first line of a file.\\nsingle-line comment:\\nmulti-line comment:\\nThe way backslash continues a comment means that comments can't usefully be put within a multi-line function definition,\\n# through to newline.\\n// works similarly but is reckoned the \""old way\"" (as of Gri 2.12.23)\\nBoth forms can be used in input data files too.\\nAny text after \""#\"" is a comment.\\nThe The Icon Programming Library established conventions for commenting library additions and functions. This included both header block comments and meta comments on procedures within library files.\\nThe comment character in IDL is the semicolon - everything starting with it and to the end of the line is a comment. Like this:\\nJava has two ways to enter normal comments, plus a third type of comment that doubles as a way to generate HTML documentation.\\nThis C-style comment starts with /* and ends with */.\\nThe two delimiters may be on the same or separate lines.\\nThis style comment may be used anywhere white space is permitted.\\nThis C++-style comment starts with // and extends to the end of line.\\nJavadoc is a standardized documentation code for Java. Its comments begin with a forward slash and two stars. Javadoc comments have different tags that signify different things in the methods and classes that they precede.\\nYour editor will probably colour this as great big comment, but it compiles and prints \""Hello World!\"". Once you've figured out how this works, try this discussion on why it's allowed.\\nfirst form\\nsecond form\\nMulti-line comments cannot be nested.\\n\\nExcept when a hash symbol (#) appears within a string, it begins a comment that continues to the end of the line:\\nThis image is a VI Snippet, an executable image of LabVIEW code. The LabVIEW version is shown on the top-right hand corner. You can download it, then drag-and-drop it onto the LabVIEW block diagram from a file browser, and it will appear as runnable, editable code.\\nIn LaTeX, comments look like this:\\nLaTeX comments start with % and continue up to and including the line break. The fact that the line break itself is commented out as well makes it useful for adding line breaks in the source code of complex macros without LaTeX interpreting them (which may cause extra space or even a paragraph break in the resulting typeset text). For example, the following results in the one word \""understandable\"":\\nWithout the percent sign after \\firstpart{stand}, it would have been the two words \""understand able\"".\\nThere are two kinds of comments:\\nand\\nLike with C, block comments don't nest.\\nIn Lingo any line starting with \""--\"" is a comment and ignored by the interpreter.\\nLotusScript has two ways to enter comments.\\nWherever the single quote (') is used, the rest of the line is treated as a comment and ignored. Multi-line comments would each need a single quote mark. This style of comment is usually used for making small in-line or single line comments.\\nA %REM marker begins a comment block, and a %END REM marker ends the comment block. This style of comment is used for making longer multi-line comments, often at the beginning of a class, sub or function.\\nThe author of LSE comments the stack effect of words with header comments as follows:\\nThere is no multi line comment. We have to use ' or \\\\nThere are three types of remarks. After statement with a dark color, in a line, with no statements, with the current pen color, and the Rem statement. Rem statement skip statements in current line, but m2000 editor render these using syntax highlight.\\n\\n","# This is a comment\\nfoo = 5 # You can also append comments to statements"
"Python","Comments","Show all ways to include text in a language source file\\nthat's completely ignored by the compiler or interpreter.\\n\\n\\n\\nNote: syntax depends on the assembler software but use of a semicolon is fairly standard\\nNote: syntax depends on the assembler software but use of a semicolon is fairly standard\\nJust like Common Lisp:\\nAgena has single line comments and two styles of multi-line comments.\\nA comment in ALGOL 60 takes the place of a single instruction.\\nComments can be inserted in variety of ways:\\nincludes bold typeface.\\nlike to Wiki markup.\\n7-bit/ascii implementations.\\ndetecting reserved words.\\n6-bits/byte implementations.\\ncomment text comment\\n'comment' text 'comment'\\nCOMMENT text COMMENT\\ncomment text comment\\n.COMMENT TEXT .COMMENT\\nNotes:\\nComments in Algol W can appear anywhere whitespace is allowed. A comment starts with the reserved word 'comment' and ends with the next semi-colon. Alternatively a comment can start with a percent sign and end with the next percent sign or semi-colon.\\nA single word in the form of an identifier following the reserved word 'end' is also a comment.\\nArendelle uses C style comments\\nSee programming introduction in the Asymptote manual.\\nWhen reading data files a comment character in them can be specified as comment=\""#\"" etc. See Files in the Asymptote manual.\\nFor multi-line comments, the /* and */ must be on their own separate lines. Nothing else can be on the same line.\\nThe hash symbol # start a comment; it ends at the end of line.\\n\\nThe only truly standard method of marking a comment in BASIC is using the REM keyword. This dates back to (at least) the late 1970's, and should work with most BASICs available today:\\nThis may not be well known, but you may include text after the line number of GOTO and GOSUB statements. This is kind of a comment in absence of labels.\\nSpaces are removed from non-keyword text. BASIC keywords can be used.\\nList outputs spaces around keywords.\\nMost BASICs also support alternate comment characters,\\ncommonly an apostrophe (single quote):\\nCharacters other than apostrophe are used in some BASICs. For example, DarkBASIC uses a back-tick character (`, a.k.a. grave accent):\\nIn addition to single-line comments, a few BASICs support block comments. FreeBASIC was influenced by the C family's block comment characters:\\nBaCon accepts REM (or single quote apostrophe) for line comments.\\nC-style block comments can be used with /* and */ pairs; these comment blocks may cross line boundaries.\\nInside USEC sections, all comment styles accepted by the configured C compiler will also be ignored.\\nThere is another (unsupported) option, using a double-colon ::. However, this has issues with some syntactic constructs and therefore may raise syntax errors.\\nSince comment lines are skipped entirely by the parser multi-line comments aren't possible even with line continuation.\\n\\nLike Brainf***, all characters and whitespace which are not commands are ignored.\\nAlso, since the code/data-space is two-dimensional, comments can be placed anywhere that will be untouched by the instruction pointer and data access commands.\\nFinally, in Funge-98, the ; instruction immediately skips to the next ; instruction, which allows to isolate comments from code.\\nBracmat uses curly braces as comment delimiters. Curly braces inside comments must be balanced. Comments are so much ignored when source code is read, that they do not reappear in listings created by the built-in lst$ function, an otherwise very useful function to autoindent your code.\\nMost ASCII characters may be used for comments; only the eight characters \""+-<>[],.\"" are Brainf*** commands. Extra care must be used when using punctuation, particularly the comma or period. These are I/O operators and are actually commands rather than comments, and are instead compiled into the program if used and may have to be \""debugged\"" and removed if you forget this issue.\\nBurlesque does NOT have comments. However, you can comment code by pushing a string and popping it immediately.\\nSince strings are multi-line strings:\\nThe comment starts at the /*, and ends at the */. A comment may be used between any tokens. It cannot be used inside tokens, that is, given the code\\nthe function takes an argument of type char, named isma, not an unnamed argument of type charisma.\\nComments cannot be nested; that is, if you write\\nthe comment ends at the first */, and inside */ is again interpreted as source code (almost certainly causing a compile error). Some compilers have the option to allow nested comments, but this is not a standard feature.\\nConditional compilation also can be used to make the compiler ignore some text:\\nThe trick is that 0 is always false, therefore the text between #if 0 and #endif is never compiled. While this should never be used for actual comments, it's an easy way to comment out some code, especially because it doesn't interfere with normal (documentation) comments.\\nConditional compile \""comments\"" can be nested:\\nEven though the compiler doesn't see #if 0 text, the preprocessor does. Therefore some minimal rules still have to be followed. For example, the following code is not valid:\\nThat's because the preprocessor will interpret the apostrophe as beginning of a character constant, and will complain because that character constant isn't terminated with another apostrophe.\\nNote that the problem mentioned above cannot occur if there's valid code between the #if 0 and #endif.\\nSingle line C++-style comments\\nC++-style comments start with // and reach up to, but not including, the end of line (more exactly, up to the next unescaped newline). While formally, C++-style comments cannot be nested either, in practice they can:\\nThat's because starting with the first // everything in the line is ignored, including the second //.\\nThe fact that the newline is not part of the comment is important for multi-line macro definitions. It means that in the code\\nthe line (no more macro text) is not part of the macro definition. Also escaping the line break at the end of the comment with '\\' doesn't help, because that would make the third line part of the comment instead. Comments inside macros therefore have to be C-style.\\nClean comments are similar to C++.\\nIn contrast to C++ comments can be nested.\\nAnything from a semicolon to the end of a line is a comment.\\nThe (comment) macro will prevent a form from being evaluated, returning nil no matter what is contained in the comment. However the forms inside the comment form must be properly parseable (parentheses balanced, etc.) or an exception will be thrown.\\nFinally, the #_ reader macro will cause a form to be ignored by the reader. Unlike (comment), this does not return nil; the surrounding code is evaluated as though the ignored form isn't even there.\\nA D in the 7th column indicates a debugging line which is treated like a comment unless a compiler flag is set.\\nThis indicates a debugging line like above, but if it is used in fixed format files, it must be in the 8th column or beyond. Not necessarily. GnuCOBOL also supports D as an indicator in column 7, the >>D format works (more by trickery than spec) if the angle brackets start in column 5, the D ending up in column 7. The >>D debug marker can then be both fixed and free form compatible.\\nThis statement causes everything following it up to the next separator period to be treated as a comment. This statement was deleted in COBOL-74.\\nThere are quite a few IDENTIFICATION DIVISION obsolete and extension reserved words that will work in GnuCOBOL 2.\\nIn tags:\\nIn script:\\nCommon Lisp provides line comments (;) and block comments (#|...|#).\\nBlock comments can nest (#|...#|...|#...|#), unlike block comments in e.g. C.\\nIn a common convention, header comments are prefaced with four semicolons, top-level (function level) comments use three, comments for sections of code use two, and margin comments use one.\\nHowever, comments should not be used for inline documentation, as most defining constructs permit a documentation string (which is then available at runtime).\\nThere is no comment syntax in POSIX dc. The convention is to make a string on the stack and move it to an unused register; a no-op.\\nGNU dc added the comment syntax of many other scripting languages.\\nComments are only allowed in places such as \""on load\"" scripts. You cannot put them in form or view definitions.\\nIn addition to Pascal, Delphi also allows C++ style single line comments:\\nAll comments span to the end of the line; there are no paired-delimiter comment syntaxes. “#” begins a comment anywhere outside of quotes; “?” and “>” begin comments only if they are at the beginning of a line (except for whitespace), because those characters are also used for infix operators.\\nIn Updoc, “?” indicates the beginning of a program fragment, “>” the continuation of one, and “#” begins the expected output from its evaluation; “??” indicates special directives.\\nSingle-line comments must begin with //\\nBlock comments must be delimited with /* and */\\nThe original EDSAC made no provision for comments in source code. Modern simulators, however, accept square brackets as comment delimiters.\\nElixir does not have multiple line comments.\\nA comment is started by ; and reaches to the end of the line.\\nThere are some coding conventions for ;; align to indentation, ;;; sections, etc,\\nAnother way to add comments is to use strings at places where the result of an expression is ignored, since they simply evaluate to themselves without any effect. Note that strings can be multi-line:\\nNote that strings at the beginning of function definitions are interpreted as documentation strings for the function (i.e. Emacs will display them if asked for help about the function), e.g.\\nDue to this, it's debatable if the string at that place can be considered as comment.\\n\\nSingle line comment:\\n\\nMultiline C-style comment:\\nF# accepts C++ type line comments and OCaml type block comments\\nFalcon supports C-language style single line and block comments. A single line comment begins with two slashes (//) and ends at the end of the line. A block comment begins with a slash followed by an asterisk, and terminates when an asterisk followed by a slash is met (/*...*/).\\nSince ><> is a funge-like language, all characters not touched by the command pointer or modified by the p and g commands can be comments.\\nUnlike Brainf***, unknown commands are not ignored by the compiler, they just raise an error.\\nStandard Forth includes a number of ways to add comment text. As with everything in Forth, comment characters are actually words that control the compiler.\\nTraditionally, the paren comments are used for \""stack effect\"" notation:\\nThis comment means \""myword takes two cells on the stack and leaves one\"". Sometimes, stack effect comment names give clues about the word's function:\\nSome Forth systems implement other commenting words, such as these words from Win32Forth:\\nCompiler: ANSI FORTRAN 77 or compatible (like g77 -strict)\\nThe first six columns in Fortran are traditionally reserved for labels and certain special characters. In particular the letter \""C\"" in the first column indicates a comment:\\nSome Fortran compilers have the extension that comments starting with D are treated as non-comments if a special debugging flag is given at the compiler invocation. For example:\\nISO Fortran 90 or later have an inline comment (!) syntax:\\nIn ISO Fortran 90 or later, \""C in first column\"" comments are only allowed in the \""fixed\"" source form familiar to FORTRAN 77 programmers. The \""free\"" source form only has inline comments (!).\\nISO Fortran 95 or later has an optional conditional compilation syntax. If present, it can be used (abused?) to (in effect) comment out blocks of code:\\n\\nIn gambas, comments can be inserted by prefixing them with an apostrophe. The gambas interpreter will ignore the apostrophe and any other characters that follow it until the end of the line:\\nA shebang (#!) may be used as a comment in the first line of a file.\\nsingle-line comment:\\nmulti-line comment:\\nThe way backslash continues a comment means that comments can't usefully be put within a multi-line function definition,\\n# through to newline.\\n// works similarly but is reckoned the \""old way\"" (as of Gri 2.12.23)\\nBoth forms can be used in input data files too.\\nAny text after \""#\"" is a comment.\\nThe The Icon Programming Library established conventions for commenting library additions and functions. This included both header block comments and meta comments on procedures within library files.\\nThe comment character in IDL is the semicolon - everything starting with it and to the end of the line is a comment. Like this:\\nJava has two ways to enter normal comments, plus a third type of comment that doubles as a way to generate HTML documentation.\\nThis C-style comment starts with /* and ends with */.\\nThe two delimiters may be on the same or separate lines.\\nThis style comment may be used anywhere white space is permitted.\\nThis C++-style comment starts with // and extends to the end of line.\\nJavadoc is a standardized documentation code for Java. Its comments begin with a forward slash and two stars. Javadoc comments have different tags that signify different things in the methods and classes that they precede.\\nYour editor will probably colour this as great big comment, but it compiles and prints \""Hello World!\"". Once you've figured out how this works, try this discussion on why it's allowed.\\nfirst form\\nsecond form\\nMulti-line comments cannot be nested.\\n\\nExcept when a hash symbol (#) appears within a string, it begins a comment that continues to the end of the line:\\nThis image is a VI Snippet, an executable image of LabVIEW code. The LabVIEW version is shown on the top-right hand corner. You can download it, then drag-and-drop it onto the LabVIEW block diagram from a file browser, and it will appear as runnable, editable code.\\nIn LaTeX, comments look like this:\\nLaTeX comments start with % and continue up to and including the line break. The fact that the line break itself is commented out as well makes it useful for adding line breaks in the source code of complex macros without LaTeX interpreting them (which may cause extra space or even a paragraph break in the resulting typeset text). For example, the following results in the one word \""understandable\"":\\nWithout the percent sign after \\firstpart{stand}, it would have been the two words \""understand able\"".\\nThere are two kinds of comments:\\nand\\nLike with C, block comments don't nest.\\nIn Lingo any line starting with \""--\"" is a comment and ignored by the interpreter.\\nLotusScript has two ways to enter comments.\\nWherever the single quote (') is used, the rest of the line is treated as a comment and ignored. Multi-line comments would each need a single quote mark. This style of comment is usually used for making small in-line or single line comments.\\nA %REM marker begins a comment block, and a %END REM marker ends the comment block. This style of comment is used for making longer multi-line comments, often at the beginning of a class, sub or function.\\nThe author of LSE comments the stack effect of words with header comments as follows:\\nThere is no multi line comment. We have to use ' or \\\\nThere are three types of remarks. After statement with a dark color, in a line, with no statements, with the current pen color, and the Rem statement. Rem statement skip statements in current line, but m2000 editor render these using syntax highlight.\\n\\n","\""\""\""Un-assigned strings in triple-quotes might be used \\n   as multi-line comments\\n\""\""\""\\n\\n'''\\n   \""triple quoted strings\"" can be delimited by either 'single' or \""double\"" quote marks; and they can contain mixtures\\n   of other quote marks without any need to \\escape\\ them using any special characters.  They also may span multiple\\n   lines without special escape characters.\\n'''"
"Python","Comments","Show all ways to include text in a language source file\\nthat's completely ignored by the compiler or interpreter.\\n\\n\\n\\nNote: syntax depends on the assembler software but use of a semicolon is fairly standard\\nNote: syntax depends on the assembler software but use of a semicolon is fairly standard\\nJust like Common Lisp:\\nAgena has single line comments and two styles of multi-line comments.\\nA comment in ALGOL 60 takes the place of a single instruction.\\nComments can be inserted in variety of ways:\\nincludes bold typeface.\\nlike to Wiki markup.\\n7-bit/ascii implementations.\\ndetecting reserved words.\\n6-bits/byte implementations.\\ncomment text comment\\n'comment' text 'comment'\\nCOMMENT text COMMENT\\ncomment text comment\\n.COMMENT TEXT .COMMENT\\nNotes:\\nComments in Algol W can appear anywhere whitespace is allowed. A comment starts with the reserved word 'comment' and ends with the next semi-colon. Alternatively a comment can start with a percent sign and end with the next percent sign or semi-colon.\\nA single word in the form of an identifier following the reserved word 'end' is also a comment.\\nArendelle uses C style comments\\nSee programming introduction in the Asymptote manual.\\nWhen reading data files a comment character in them can be specified as comment=\""#\"" etc. See Files in the Asymptote manual.\\nFor multi-line comments, the /* and */ must be on their own separate lines. Nothing else can be on the same line.\\nThe hash symbol # start a comment; it ends at the end of line.\\n\\nThe only truly standard method of marking a comment in BASIC is using the REM keyword. This dates back to (at least) the late 1970's, and should work with most BASICs available today:\\nThis may not be well known, but you may include text after the line number of GOTO and GOSUB statements. This is kind of a comment in absence of labels.\\nSpaces are removed from non-keyword text. BASIC keywords can be used.\\nList outputs spaces around keywords.\\nMost BASICs also support alternate comment characters,\\ncommonly an apostrophe (single quote):\\nCharacters other than apostrophe are used in some BASICs. For example, DarkBASIC uses a back-tick character (`, a.k.a. grave accent):\\nIn addition to single-line comments, a few BASICs support block comments. FreeBASIC was influenced by the C family's block comment characters:\\nBaCon accepts REM (or single quote apostrophe) for line comments.\\nC-style block comments can be used with /* and */ pairs; these comment blocks may cross line boundaries.\\nInside USEC sections, all comment styles accepted by the configured C compiler will also be ignored.\\nThere is another (unsupported) option, using a double-colon ::. However, this has issues with some syntactic constructs and therefore may raise syntax errors.\\nSince comment lines are skipped entirely by the parser multi-line comments aren't possible even with line continuation.\\n\\nLike Brainf***, all characters and whitespace which are not commands are ignored.\\nAlso, since the code/data-space is two-dimensional, comments can be placed anywhere that will be untouched by the instruction pointer and data access commands.\\nFinally, in Funge-98, the ; instruction immediately skips to the next ; instruction, which allows to isolate comments from code.\\nBracmat uses curly braces as comment delimiters. Curly braces inside comments must be balanced. Comments are so much ignored when source code is read, that they do not reappear in listings created by the built-in lst$ function, an otherwise very useful function to autoindent your code.\\nMost ASCII characters may be used for comments; only the eight characters \""+-<>[],.\"" are Brainf*** commands. Extra care must be used when using punctuation, particularly the comma or period. These are I/O operators and are actually commands rather than comments, and are instead compiled into the program if used and may have to be \""debugged\"" and removed if you forget this issue.\\nBurlesque does NOT have comments. However, you can comment code by pushing a string and popping it immediately.\\nSince strings are multi-line strings:\\nThe comment starts at the /*, and ends at the */. A comment may be used between any tokens. It cannot be used inside tokens, that is, given the code\\nthe function takes an argument of type char, named isma, not an unnamed argument of type charisma.\\nComments cannot be nested; that is, if you write\\nthe comment ends at the first */, and inside */ is again interpreted as source code (almost certainly causing a compile error). Some compilers have the option to allow nested comments, but this is not a standard feature.\\nConditional compilation also can be used to make the compiler ignore some text:\\nThe trick is that 0 is always false, therefore the text between #if 0 and #endif is never compiled. While this should never be used for actual comments, it's an easy way to comment out some code, especially because it doesn't interfere with normal (documentation) comments.\\nConditional compile \""comments\"" can be nested:\\nEven though the compiler doesn't see #if 0 text, the preprocessor does. Therefore some minimal rules still have to be followed. For example, the following code is not valid:\\nThat's because the preprocessor will interpret the apostrophe as beginning of a character constant, and will complain because that character constant isn't terminated with another apostrophe.\\nNote that the problem mentioned above cannot occur if there's valid code between the #if 0 and #endif.\\nSingle line C++-style comments\\nC++-style comments start with // and reach up to, but not including, the end of line (more exactly, up to the next unescaped newline). While formally, C++-style comments cannot be nested either, in practice they can:\\nThat's because starting with the first // everything in the line is ignored, including the second //.\\nThe fact that the newline is not part of the comment is important for multi-line macro definitions. It means that in the code\\nthe line (no more macro text) is not part of the macro definition. Also escaping the line break at the end of the comment with '\\' doesn't help, because that would make the third line part of the comment instead. Comments inside macros therefore have to be C-style.\\nClean comments are similar to C++.\\nIn contrast to C++ comments can be nested.\\nAnything from a semicolon to the end of a line is a comment.\\nThe (comment) macro will prevent a form from being evaluated, returning nil no matter what is contained in the comment. However the forms inside the comment form must be properly parseable (parentheses balanced, etc.) or an exception will be thrown.\\nFinally, the #_ reader macro will cause a form to be ignored by the reader. Unlike (comment), this does not return nil; the surrounding code is evaluated as though the ignored form isn't even there.\\nA D in the 7th column indicates a debugging line which is treated like a comment unless a compiler flag is set.\\nThis indicates a debugging line like above, but if it is used in fixed format files, it must be in the 8th column or beyond. Not necessarily. GnuCOBOL also supports D as an indicator in column 7, the >>D format works (more by trickery than spec) if the angle brackets start in column 5, the D ending up in column 7. The >>D debug marker can then be both fixed and free form compatible.\\nThis statement causes everything following it up to the next separator period to be treated as a comment. This statement was deleted in COBOL-74.\\nThere are quite a few IDENTIFICATION DIVISION obsolete and extension reserved words that will work in GnuCOBOL 2.\\nIn tags:\\nIn script:\\nCommon Lisp provides line comments (;) and block comments (#|...|#).\\nBlock comments can nest (#|...#|...|#...|#), unlike block comments in e.g. C.\\nIn a common convention, header comments are prefaced with four semicolons, top-level (function level) comments use three, comments for sections of code use two, and margin comments use one.\\nHowever, comments should not be used for inline documentation, as most defining constructs permit a documentation string (which is then available at runtime).\\nThere is no comment syntax in POSIX dc. The convention is to make a string on the stack and move it to an unused register; a no-op.\\nGNU dc added the comment syntax of many other scripting languages.\\nComments are only allowed in places such as \""on load\"" scripts. You cannot put them in form or view definitions.\\nIn addition to Pascal, Delphi also allows C++ style single line comments:\\nAll comments span to the end of the line; there are no paired-delimiter comment syntaxes. “#” begins a comment anywhere outside of quotes; “?” and “>” begin comments only if they are at the beginning of a line (except for whitespace), because those characters are also used for infix operators.\\nIn Updoc, “?” indicates the beginning of a program fragment, “>” the continuation of one, and “#” begins the expected output from its evaluation; “??” indicates special directives.\\nSingle-line comments must begin with //\\nBlock comments must be delimited with /* and */\\nThe original EDSAC made no provision for comments in source code. Modern simulators, however, accept square brackets as comment delimiters.\\nElixir does not have multiple line comments.\\nA comment is started by ; and reaches to the end of the line.\\nThere are some coding conventions for ;; align to indentation, ;;; sections, etc,\\nAnother way to add comments is to use strings at places where the result of an expression is ignored, since they simply evaluate to themselves without any effect. Note that strings can be multi-line:\\nNote that strings at the beginning of function definitions are interpreted as documentation strings for the function (i.e. Emacs will display them if asked for help about the function), e.g.\\nDue to this, it's debatable if the string at that place can be considered as comment.\\n\\nSingle line comment:\\n\\nMultiline C-style comment:\\nF# accepts C++ type line comments and OCaml type block comments\\nFalcon supports C-language style single line and block comments. A single line comment begins with two slashes (//) and ends at the end of the line. A block comment begins with a slash followed by an asterisk, and terminates when an asterisk followed by a slash is met (/*...*/).\\nSince ><> is a funge-like language, all characters not touched by the command pointer or modified by the p and g commands can be comments.\\nUnlike Brainf***, unknown commands are not ignored by the compiler, they just raise an error.\\nStandard Forth includes a number of ways to add comment text. As with everything in Forth, comment characters are actually words that control the compiler.\\nTraditionally, the paren comments are used for \""stack effect\"" notation:\\nThis comment means \""myword takes two cells on the stack and leaves one\"". Sometimes, stack effect comment names give clues about the word's function:\\nSome Forth systems implement other commenting words, such as these words from Win32Forth:\\nCompiler: ANSI FORTRAN 77 or compatible (like g77 -strict)\\nThe first six columns in Fortran are traditionally reserved for labels and certain special characters. In particular the letter \""C\"" in the first column indicates a comment:\\nSome Fortran compilers have the extension that comments starting with D are treated as non-comments if a special debugging flag is given at the compiler invocation. For example:\\nISO Fortran 90 or later have an inline comment (!) syntax:\\nIn ISO Fortran 90 or later, \""C in first column\"" comments are only allowed in the \""fixed\"" source form familiar to FORTRAN 77 programmers. The \""free\"" source form only has inline comments (!).\\nISO Fortran 95 or later has an optional conditional compilation syntax. If present, it can be used (abused?) to (in effect) comment out blocks of code:\\n\\nIn gambas, comments can be inserted by prefixing them with an apostrophe. The gambas interpreter will ignore the apostrophe and any other characters that follow it until the end of the line:\\nA shebang (#!) may be used as a comment in the first line of a file.\\nsingle-line comment:\\nmulti-line comment:\\nThe way backslash continues a comment means that comments can't usefully be put within a multi-line function definition,\\n# through to newline.\\n// works similarly but is reckoned the \""old way\"" (as of Gri 2.12.23)\\nBoth forms can be used in input data files too.\\nAny text after \""#\"" is a comment.\\nThe The Icon Programming Library established conventions for commenting library additions and functions. This included both header block comments and meta comments on procedures within library files.\\nThe comment character in IDL is the semicolon - everything starting with it and to the end of the line is a comment. Like this:\\nJava has two ways to enter normal comments, plus a third type of comment that doubles as a way to generate HTML documentation.\\nThis C-style comment starts with /* and ends with */.\\nThe two delimiters may be on the same or separate lines.\\nThis style comment may be used anywhere white space is permitted.\\nThis C++-style comment starts with // and extends to the end of line.\\nJavadoc is a standardized documentation code for Java. Its comments begin with a forward slash and two stars. Javadoc comments have different tags that signify different things in the methods and classes that they precede.\\nYour editor will probably colour this as great big comment, but it compiles and prints \""Hello World!\"". Once you've figured out how this works, try this discussion on why it's allowed.\\nfirst form\\nsecond form\\nMulti-line comments cannot be nested.\\n\\nExcept when a hash symbol (#) appears within a string, it begins a comment that continues to the end of the line:\\nThis image is a VI Snippet, an executable image of LabVIEW code. The LabVIEW version is shown on the top-right hand corner. You can download it, then drag-and-drop it onto the LabVIEW block diagram from a file browser, and it will appear as runnable, editable code.\\nIn LaTeX, comments look like this:\\nLaTeX comments start with % and continue up to and including the line break. The fact that the line break itself is commented out as well makes it useful for adding line breaks in the source code of complex macros without LaTeX interpreting them (which may cause extra space or even a paragraph break in the resulting typeset text). For example, the following results in the one word \""understandable\"":\\nWithout the percent sign after \\firstpart{stand}, it would have been the two words \""understand able\"".\\nThere are two kinds of comments:\\nand\\nLike with C, block comments don't nest.\\nIn Lingo any line starting with \""--\"" is a comment and ignored by the interpreter.\\nLotusScript has two ways to enter comments.\\nWherever the single quote (') is used, the rest of the line is treated as a comment and ignored. Multi-line comments would each need a single quote mark. This style of comment is usually used for making small in-line or single line comments.\\nA %REM marker begins a comment block, and a %END REM marker ends the comment block. This style of comment is used for making longer multi-line comments, often at the beginning of a class, sub or function.\\nThe author of LSE comments the stack effect of words with header comments as follows:\\nThere is no multi line comment. We have to use ' or \\\\nThere are three types of remarks. After statement with a dark color, in a line, with no statements, with the current pen color, and the Rem statement. Rem statement skip statements in current line, but m2000 editor render these using syntax highlight.\\n\\n","#!/usr/bin/env python\\n# Example of using doc strings\\n\""\""\""My Doc-string example\""\""\""\\n \\nclass Foo:\\n     '''Some documentation for the Foo class'''\\n     def __init__(self):\\n        \""Foo's initialization method's documentation\""\\n \\ndef bar():\\n    \""\""\""documentation for the bar function\""\""\""\\n \\nif __name__ == \""__main__\"":\\n    print (__doc__)\\n    print (Foo.__doc__)\\n    print (Foo.__init__.__doc__)\\n    print (bar.__doc__)"
"Python","Compare_a_list_of_strings","Given a   list   of arbitrarily many strings, show how to:\\n\\nEach of those two tests should result in a single true or false value, which could be used as the condition of an    if    statement or similar.\\nIf the input list has less than two elements, the tests should always return true.\\nThere is no need to provide a complete program and output.\\nAssume that the strings are already stored in an array/list/sequence/tuple variable (whatever is most idiomatic) with the name   strings,   and just show the expressions for performing those two tests on it (plus of course any includes and custom functions etc. that it needs),   with as little distractions as possible.\\nTry to write your solution in a way that does not modify the original list,   but if it does then please add a note to make that clear to readers.\\nIf you need further guidance/clarification,   see #Perl and #Python for solutions that use implicit short-circuiting loops,   and #Perl_6 for a solution that gets away with simply using a built-in language feature. \\n\\n\\nThe program uses one ASSIST macro (XPRNT) to keep the code as short as possible.\\n","all(a == nexta for a, nexta in zip(strings, strings[1:])) # All equal\\nall(a < nexta for a, nexta in zip(strings, strings[1:])) # Strictly ascending\\n\\nlen(set(strings)) == 1  # Concise all equal\\nsorted(strings, reverse=True) == strings  # Concise (but not particularly efficient) ascending\\n"
"Python","Compare_sorting_algorithms'_performance","Measure a relative performance of sorting algorithms implementations.\\nPlot execution time vs. input sequence length dependencies for various implementation of sorting algorithm and different input sequence types (example figures).\\nConsider three type of input sequences:\\nConsider at least two different sorting functions (different algorithms or/and different implementation of the same algorithm).\\nFor example, consider Bubble Sort, Insertion sort, Quicksort or/and implementations of Quicksort with different pivot selection mechanisms. Where possible, use existing implementations.\\nPreliminary subtask:\\nGeneral steps:\\nOutput:\\n(The reference example is Python)\\nWe can use the codes in the category Sorting Algorithms; since these codes deal with integer arrays, we should change them a little. To accomplish this task I've also renamed them more consistently algorithm_sort; so we have e.g. bubble_sort, quick_sort and so on.\\ncsequence.h\\ncsequence.c\\nWe shall use the code from Query Performance. Since the action is a generic function with a single argument, we need wrappers which encapsule each sorting algorithms we want to test.\\nwritetimings.h\\nwritetimings.c\\nThis code produce several files with the following naming convention:\\nWhere algorithm is one of the following: insertion, merge, shell, quick, qsort (the quicksort in the libc library) (bubble sort became too slow for longest sequences). Sequence is c1 (constant value 1), rr (reverse range), sr (shufled range). These data can be easily plotted by Gnuplot, which can also do fitting. Instead we do our fitting using Polynomial Fitting.\\nHere we search for a fit with C0+C1x \""in the log scale\"", since we supposed the data, once plotted on a logscale graph, can be fitted by a line. We can use e.g. a shell one-liner to produce the parameters for the line for each data file previously output. In particular I've used the following\\nOnce we have all the \"".dat\"" files and associated \"".fd\"", we can use Gnuplot to draw our data and think about conclusions (we could also use the idea in Plot x, y arrays, but it needs too much enhancements to be usable for this analysis). Here an example of such a draw for a single file (using Gnuplot)\\n(The _u.dat are produced by a modified version of the code in order to write timings in microseconds instead of seconds)\\nWe can easily write another shell script/one-liner to produce a single file driver for Gnuplot in order to produce all the graph we can be interested in.\\nThese graphs show that the linear (in log scale) fit do not always fit the data... I haven't repeated the tests; the problems are when the sequence length becomes huge; for some algorithm that uses extra memory (like implementation of the merge sort), this could depend on the allocation of the needed memory. Another extraneous factor could be system load (the CLOCK_MONOTONIC used by the timing function is system wide rather than per process, so counting time spent in other processes too?).\\nThe \""most stable\"" algorithms seem to be quick sort (but not qsort, which indeed is just the libc quick sort, here not plotted!) and shell sort (except for reversed range).\\nConclusion: we should repeat the tests...\\n\\n","def builtinsort(x):\\n    x.sort()\\n\\ndef partition(seq, pivot):\\n   low, middle, up = [], [], []\\n   for x in seq:\\n       if x < pivot:\\n           low.append(x)\\n       elif x == pivot:\\n           middle.append(x)\\n       else:\\n           up.append(x)\\n   return low, middle, up\\nimport random\\ndef qsortranpart(seq):\\n   size = len(seq)\\n   if size < 2: return seq\\n   low, middle, up = partition(seq, random.choice(seq))\\n   return qsortranpart(low) + middle + qsortranpart(up)"
"Python","Compare_sorting_algorithms'_performance","Measure a relative performance of sorting algorithms implementations.\\nPlot execution time vs. input sequence length dependencies for various implementation of sorting algorithm and different input sequence types (example figures).\\nConsider three type of input sequences:\\nConsider at least two different sorting functions (different algorithms or/and different implementation of the same algorithm).\\nFor example, consider Bubble Sort, Insertion sort, Quicksort or/and implementations of Quicksort with different pivot selection mechanisms. Where possible, use existing implementations.\\nPreliminary subtask:\\nGeneral steps:\\nOutput:\\n(The reference example is Python)\\nWe can use the codes in the category Sorting Algorithms; since these codes deal with integer arrays, we should change them a little. To accomplish this task I've also renamed them more consistently algorithm_sort; so we have e.g. bubble_sort, quick_sort and so on.\\ncsequence.h\\ncsequence.c\\nWe shall use the code from Query Performance. Since the action is a generic function with a single argument, we need wrappers which encapsule each sorting algorithms we want to test.\\nwritetimings.h\\nwritetimings.c\\nThis code produce several files with the following naming convention:\\nWhere algorithm is one of the following: insertion, merge, shell, quick, qsort (the quicksort in the libc library) (bubble sort became too slow for longest sequences). Sequence is c1 (constant value 1), rr (reverse range), sr (shufled range). These data can be easily plotted by Gnuplot, which can also do fitting. Instead we do our fitting using Polynomial Fitting.\\nHere we search for a fit with C0+C1x \""in the log scale\"", since we supposed the data, once plotted on a logscale graph, can be fitted by a line. We can use e.g. a shell one-liner to produce the parameters for the line for each data file previously output. In particular I've used the following\\nOnce we have all the \"".dat\"" files and associated \"".fd\"", we can use Gnuplot to draw our data and think about conclusions (we could also use the idea in Plot x, y arrays, but it needs too much enhancements to be usable for this analysis). Here an example of such a draw for a single file (using Gnuplot)\\n(The _u.dat are produced by a modified version of the code in order to write timings in microseconds instead of seconds)\\nWe can easily write another shell script/one-liner to produce a single file driver for Gnuplot in order to produce all the graph we can be interested in.\\nThese graphs show that the linear (in log scale) fit do not always fit the data... I haven't repeated the tests; the problems are when the sequence length becomes huge; for some algorithm that uses extra memory (like implementation of the merge sort), this could depend on the allocation of the needed memory. Another extraneous factor could be system load (the CLOCK_MONOTONIC used by the timing function is system wide rather than per process, so counting time spent in other processes too?).\\nThe \""most stable\"" algorithms seem to be quick sort (but not qsort, which indeed is just the libc quick sort, here not plotted!) and shell sort (except for reversed range).\\nConclusion: we should repeat the tests...\\n\\n","def ones(n):\\n    return [1]*n\\n\\ndef reversedrange(n):\\n    return reversed(range(n))\\n\\ndef shuffledrange(n):\\n    x = range(n)\\n    random.shuffle(x)\\n    return x"
"Python","Compare_sorting_algorithms'_performance","Measure a relative performance of sorting algorithms implementations.\\nPlot execution time vs. input sequence length dependencies for various implementation of sorting algorithm and different input sequence types (example figures).\\nConsider three type of input sequences:\\nConsider at least two different sorting functions (different algorithms or/and different implementation of the same algorithm).\\nFor example, consider Bubble Sort, Insertion sort, Quicksort or/and implementations of Quicksort with different pivot selection mechanisms. Where possible, use existing implementations.\\nPreliminary subtask:\\nGeneral steps:\\nOutput:\\n(The reference example is Python)\\nWe can use the codes in the category Sorting Algorithms; since these codes deal with integer arrays, we should change them a little. To accomplish this task I've also renamed them more consistently algorithm_sort; so we have e.g. bubble_sort, quick_sort and so on.\\ncsequence.h\\ncsequence.c\\nWe shall use the code from Query Performance. Since the action is a generic function with a single argument, we need wrappers which encapsule each sorting algorithms we want to test.\\nwritetimings.h\\nwritetimings.c\\nThis code produce several files with the following naming convention:\\nWhere algorithm is one of the following: insertion, merge, shell, quick, qsort (the quicksort in the libc library) (bubble sort became too slow for longest sequences). Sequence is c1 (constant value 1), rr (reverse range), sr (shufled range). These data can be easily plotted by Gnuplot, which can also do fitting. Instead we do our fitting using Polynomial Fitting.\\nHere we search for a fit with C0+C1x \""in the log scale\"", since we supposed the data, once plotted on a logscale graph, can be fitted by a line. We can use e.g. a shell one-liner to produce the parameters for the line for each data file previously output. In particular I've used the following\\nOnce we have all the \"".dat\"" files and associated \"".fd\"", we can use Gnuplot to draw our data and think about conclusions (we could also use the idea in Plot x, y arrays, but it needs too much enhancements to be usable for this analysis). Here an example of such a draw for a single file (using Gnuplot)\\n(The _u.dat are produced by a modified version of the code in order to write timings in microseconds instead of seconds)\\nWe can easily write another shell script/one-liner to produce a single file driver for Gnuplot in order to produce all the graph we can be interested in.\\nThese graphs show that the linear (in log scale) fit do not always fit the data... I haven't repeated the tests; the problems are when the sequence length becomes huge; for some algorithm that uses extra memory (like implementation of the merge sort), this could depend on the allocation of the needed memory. Another extraneous factor could be system load (the CLOCK_MONOTONIC used by the timing function is system wide rather than per process, so counting time spent in other processes too?).\\nThe \""most stable\"" algorithms seem to be quick sort (but not qsort, which indeed is just the libc quick sort, here not plotted!) and shell sort (except for reversed range).\\nConclusion: we should repeat the tests...\\n\\n","def write_timings(npoints=10, maxN=10**4, sort_functions=(builtinsort,insertion_sort, qsort), \\n                  sequence_creators = (ones, range, shuffledrange)):    \\n   Ns = range(2, maxN, maxN//npoints)\\n   for sort in sort_functions:\\n       for make_seq in sequence_creators:\\n           Ts = [usec(sort, (make_seq(n),)) for n in Ns]\\n           writedat('%s-%s-%d-%d.xy' % (sort.__name__,  make_seq.__name__, len(Ns), max(Ns)), Ns, Ts)"
"Python","Compare_sorting_algorithms'_performance","Measure a relative performance of sorting algorithms implementations.\\nPlot execution time vs. input sequence length dependencies for various implementation of sorting algorithm and different input sequence types (example figures).\\nConsider three type of input sequences:\\nConsider at least two different sorting functions (different algorithms or/and different implementation of the same algorithm).\\nFor example, consider Bubble Sort, Insertion sort, Quicksort or/and implementations of Quicksort with different pivot selection mechanisms. Where possible, use existing implementations.\\nPreliminary subtask:\\nGeneral steps:\\nOutput:\\n(The reference example is Python)\\nWe can use the codes in the category Sorting Algorithms; since these codes deal with integer arrays, we should change them a little. To accomplish this task I've also renamed them more consistently algorithm_sort; so we have e.g. bubble_sort, quick_sort and so on.\\ncsequence.h\\ncsequence.c\\nWe shall use the code from Query Performance. Since the action is a generic function with a single argument, we need wrappers which encapsule each sorting algorithms we want to test.\\nwritetimings.h\\nwritetimings.c\\nThis code produce several files with the following naming convention:\\nWhere algorithm is one of the following: insertion, merge, shell, quick, qsort (the quicksort in the libc library) (bubble sort became too slow for longest sequences). Sequence is c1 (constant value 1), rr (reverse range), sr (shufled range). These data can be easily plotted by Gnuplot, which can also do fitting. Instead we do our fitting using Polynomial Fitting.\\nHere we search for a fit with C0+C1x \""in the log scale\"", since we supposed the data, once plotted on a logscale graph, can be fitted by a line. We can use e.g. a shell one-liner to produce the parameters for the line for each data file previously output. In particular I've used the following\\nOnce we have all the \"".dat\"" files and associated \"".fd\"", we can use Gnuplot to draw our data and think about conclusions (we could also use the idea in Plot x, y arrays, but it needs too much enhancements to be usable for this analysis). Here an example of such a draw for a single file (using Gnuplot)\\n(The _u.dat are produced by a modified version of the code in order to write timings in microseconds instead of seconds)\\nWe can easily write another shell script/one-liner to produce a single file driver for Gnuplot in order to produce all the graph we can be interested in.\\nThese graphs show that the linear (in log scale) fit do not always fit the data... I haven't repeated the tests; the problems are when the sequence length becomes huge; for some algorithm that uses extra memory (like implementation of the merge sort), this could depend on the allocation of the needed memory. Another extraneous factor could be system load (the CLOCK_MONOTONIC used by the timing function is system wide rather than per process, so counting time spent in other processes too?).\\nThe \""most stable\"" algorithms seem to be quick sort (but not qsort, which indeed is just the libc quick sort, here not plotted!) and shell sort (except for reversed range).\\nConclusion: we should repeat the tests...\\n\\n","import operator\\nimport numpy, pylab\\ndef plotdd(dictplotdict):\\n   \""\""\""See ``plot_timings()`` below.\""\""\""\\n   symbols = ('o', '^', 'v', '<', '>', 's', '+', 'x', 'D', 'd',\\n              '1', '2', '3', '4', 'h', 'H', 'p', '|', '_')\\n   colors = list('bgrcmyk') # split string on distinct characters\\n   for npoints, plotdict in dictplotdict.iteritems():\\n       for ttle, lst in plotdict.iteritems():            \\n           pylab.hold(False)                                \\n           for i, (label, polynom, x, y) in enumerate(sorted(lst,key=operator.itemgetter(0))):\\n               pylab.plot(x, y, colors[i % len(colors)] + symbols[i % len(symbols)], label='%s %s' % (polynom, label))\\n               pylab.hold(True)\\n               y = numpy.polyval(polynom, x)\\n               pylab.plot(x, y, colors[i % len(colors)], label= '_nolegend_')                \\n           pylab.legend(loc='upper left')\\n           pylab.xlabel(polynom.variable)\\n           pylab.ylabel('log2( time in microseconds )')                \\n           pylab.title(ttle, verticalalignment='bottom')\\n           figname = '_%(npoints)03d%(ttle)s' % vars()\\n           pylab.savefig(figname+'.png')\\n           pylab.savefig(figname+'.pdf')\\n           print figname"
"Python","Compare_sorting_algorithms'_performance","Measure a relative performance of sorting algorithms implementations.\\nPlot execution time vs. input sequence length dependencies for various implementation of sorting algorithm and different input sequence types (example figures).\\nConsider three type of input sequences:\\nConsider at least two different sorting functions (different algorithms or/and different implementation of the same algorithm).\\nFor example, consider Bubble Sort, Insertion sort, Quicksort or/and implementations of Quicksort with different pivot selection mechanisms. Where possible, use existing implementations.\\nPreliminary subtask:\\nGeneral steps:\\nOutput:\\n(The reference example is Python)\\nWe can use the codes in the category Sorting Algorithms; since these codes deal with integer arrays, we should change them a little. To accomplish this task I've also renamed them more consistently algorithm_sort; so we have e.g. bubble_sort, quick_sort and so on.\\ncsequence.h\\ncsequence.c\\nWe shall use the code from Query Performance. Since the action is a generic function with a single argument, we need wrappers which encapsule each sorting algorithms we want to test.\\nwritetimings.h\\nwritetimings.c\\nThis code produce several files with the following naming convention:\\nWhere algorithm is one of the following: insertion, merge, shell, quick, qsort (the quicksort in the libc library) (bubble sort became too slow for longest sequences). Sequence is c1 (constant value 1), rr (reverse range), sr (shufled range). These data can be easily plotted by Gnuplot, which can also do fitting. Instead we do our fitting using Polynomial Fitting.\\nHere we search for a fit with C0+C1x \""in the log scale\"", since we supposed the data, once plotted on a logscale graph, can be fitted by a line. We can use e.g. a shell one-liner to produce the parameters for the line for each data file previously output. In particular I've used the following\\nOnce we have all the \"".dat\"" files and associated \"".fd\"", we can use Gnuplot to draw our data and think about conclusions (we could also use the idea in Plot x, y arrays, but it needs too much enhancements to be usable for this analysis). Here an example of such a draw for a single file (using Gnuplot)\\n(The _u.dat are produced by a modified version of the code in order to write timings in microseconds instead of seconds)\\nWe can easily write another shell script/one-liner to produce a single file driver for Gnuplot in order to produce all the graph we can be interested in.\\nThese graphs show that the linear (in log scale) fit do not always fit the data... I haven't repeated the tests; the problems are when the sequence length becomes huge; for some algorithm that uses extra memory (like implementation of the merge sort), this could depend on the allocation of the needed memory. Another extraneous factor could be system load (the CLOCK_MONOTONIC used by the timing function is system wide rather than per process, so counting time spent in other processes too?).\\nThe \""most stable\"" algorithms seem to be quick sort (but not qsort, which indeed is just the libc quick sort, here not plotted!) and shell sort (except for reversed range).\\nConclusion: we should repeat the tests...\\n\\n","import collections, itertools, glob, re\\nimport numpy\\ndef plot_timings():\\n   makedict = lambda: collections.defaultdict(lambda: collections.defaultdict(list))\\n   df = makedict()\\n   ds = makedict()\\n   # populate plot dictionaries\\n   for filename in glob.glob('*.xy'):\\n       m = re.match(r'([^-]+)-([^-]+)-(\\d+)-(\\d+)\\.xy', filename)\\n       print filename\\n       assert m, filename\\n       funcname, seqname, npoints, maxN = m.groups()\\n       npoints, maxN = int(npoints), int(maxN)        \\n       a = numpy.fromiter(itertools.imap(float, open(filename).read().split()), dtype='f')\\n       Ns = a[::2]  # sequences lengths\\n       Ts = a[1::2] # corresponding times \\n       assert len(Ns) == len(Ts) == npoints\\n       assert max(Ns) <= maxN\\n       #\\n       logsafe = numpy.logical_and(Ns>0, Ts>0)\\n       Ts = numpy.log2(Ts[logsafe])\\n       Ns = numpy.log2(Ns[logsafe])\\n       coeffs = numpy.polyfit(Ns, Ts, deg=1)\\n       poly = numpy.poly1d(coeffs, variable='log2(N)')\\n       #\\n       df[npoints][funcname].append((seqname, poly, Ns, Ts))\\n       ds[npoints][seqname].append((funcname, poly, Ns, Ts))\\n   # actual plotting\\n   plotdd(df)\\n   plotdd(ds) # see ``plotdd()`` above"
"Python","Compare_sorting_algorithms'_performance","Measure a relative performance of sorting algorithms implementations.\\nPlot execution time vs. input sequence length dependencies for various implementation of sorting algorithm and different input sequence types (example figures).\\nConsider three type of input sequences:\\nConsider at least two different sorting functions (different algorithms or/and different implementation of the same algorithm).\\nFor example, consider Bubble Sort, Insertion sort, Quicksort or/and implementations of Quicksort with different pivot selection mechanisms. Where possible, use existing implementations.\\nPreliminary subtask:\\nGeneral steps:\\nOutput:\\n(The reference example is Python)\\nWe can use the codes in the category Sorting Algorithms; since these codes deal with integer arrays, we should change them a little. To accomplish this task I've also renamed them more consistently algorithm_sort; so we have e.g. bubble_sort, quick_sort and so on.\\ncsequence.h\\ncsequence.c\\nWe shall use the code from Query Performance. Since the action is a generic function with a single argument, we need wrappers which encapsule each sorting algorithms we want to test.\\nwritetimings.h\\nwritetimings.c\\nThis code produce several files with the following naming convention:\\nWhere algorithm is one of the following: insertion, merge, shell, quick, qsort (the quicksort in the libc library) (bubble sort became too slow for longest sequences). Sequence is c1 (constant value 1), rr (reverse range), sr (shufled range). These data can be easily plotted by Gnuplot, which can also do fitting. Instead we do our fitting using Polynomial Fitting.\\nHere we search for a fit with C0+C1x \""in the log scale\"", since we supposed the data, once plotted on a logscale graph, can be fitted by a line. We can use e.g. a shell one-liner to produce the parameters for the line for each data file previously output. In particular I've used the following\\nOnce we have all the \"".dat\"" files and associated \"".fd\"", we can use Gnuplot to draw our data and think about conclusions (we could also use the idea in Plot x, y arrays, but it needs too much enhancements to be usable for this analysis). Here an example of such a draw for a single file (using Gnuplot)\\n(The _u.dat are produced by a modified version of the code in order to write timings in microseconds instead of seconds)\\nWe can easily write another shell script/one-liner to produce a single file driver for Gnuplot in order to produce all the graph we can be interested in.\\nThese graphs show that the linear (in log scale) fit do not always fit the data... I haven't repeated the tests; the problems are when the sequence length becomes huge; for some algorithm that uses extra memory (like implementation of the merge sort), this could depend on the allocation of the needed memory. Another extraneous factor could be system load (the CLOCK_MONOTONIC used by the timing function is system wide rather than per process, so counting time spent in other processes too?).\\nThe \""most stable\"" algorithms seem to be quick sort (but not qsort, which indeed is just the libc quick sort, here not plotted!) and shell sort (except for reversed range).\\nConclusion: we should repeat the tests...\\n\\n","sort_functions = [\\n    builtinsort,         # see implementation above\\n    insertion_sort,      # see [[Insertion sort]]\\n    insertion_sort_lowb, # ''insertion_sort'', where sequential search is replaced\\n                         #     by lower_bound() function\\n    qsort,               # see [[Quicksort]]\\n    qsortranlc,          # ''qsort'' with randomly choosen ''pivot''\\n                         #     and the filtering via list comprehension\\n    qsortranpart,        # ''qsortranlc'' with filtering via ''partition'' function\\n    qsortranpartis,      # ''qsortranpart'', where for a small input sequence lengths\\n    ]                    #     ''insertion_sort'' is called\\nif __name__==\""__main__\"":\\n   import sys\\n   sys.setrecursionlimit(10000)\\n   write_timings(npoints=100, maxN=1024, # 1 <= N <= 2**10 an input sequence length\\n                 sort_functions=sort_functions,\\n                 sequence_creators = (ones, range, shuffledrange))\\n   plot_timings()"
"Python","Compiler/AST_interpreter","An AST interpreter interprets an Abstract Syntax Tree (AST)\\nproduced by a Syntax Analyzer.\\nTake the AST output from the Syntax analyzer task, and interpret it as appropriate.\\nRefer to the Syntax analyzer task for details of the AST.\\nNotes:\\nBecause of the simple nature of our tiny language, Semantic analysis is not needed.\\nYour interpreter should use C like division semantics, for both division and modulus. For division of positive operands, only the non-fractional portion of the result should be returned. In other words, the result should be truncated towards 0.\\nThis means, for instance, that 3 / 2 should result in 1.\\nFor division when one of the operands is negative, the result should be truncated towards 0.\\nThis means, for instance, that 3 / -2 should result in -1.\\nYour solution should pass all the test cases above and the additional tests found Here.\\nThe C and Python versions can be considered reference implementations.\\n","from __future__ import print_function\\nimport sys, shlex, operator\\n\\nnd_Ident, nd_String, nd_Integer, nd_Sequence, nd_If, nd_Prtc, nd_Prts, nd_Prti, nd_While, \\\\nnd_Assign, nd_Negate, nd_Not, nd_Mul, nd_Div, nd_Mod, nd_Add, nd_Sub, nd_Lss, nd_Leq,     \\\\nnd_Gtr, nd_Geq, nd_Eql, nd_Neq, nd_And, nd_Or = range(25)\\n\\nall_syms = {\\n    \""Identifier\""  : nd_Ident,    \""String\""      : nd_String,\\n    \""Integer\""     : nd_Integer,  \""Sequence\""    : nd_Sequence,\\n    \""If\""          : nd_If,       \""Prtc\""        : nd_Prtc,\\n    \""Prts\""        : nd_Prts,     \""Prti\""        : nd_Prti,\\n    \""While\""       : nd_While,    \""Assign\""      : nd_Assign,\\n    \""Negate\""      : nd_Negate,   \""Not\""         : nd_Not,\\n    \""Multiply\""    : nd_Mul,      \""Divide\""      : nd_Div,\\n    \""Mod\""         : nd_Mod,      \""Add\""         : nd_Add,\\n    \""Subtract\""    : nd_Sub,      \""Less\""        : nd_Lss,\\n    \""LessEqual\""   : nd_Leq,      \""Greater\""     : nd_Gtr,\\n    \""GreaterEqual\"": nd_Geq,      \""Equal\""       : nd_Eql,\\n    \""NotEqual\""    : nd_Neq,      \""And\""         : nd_And,\\n    \""Or\""          : nd_Or}\\n\\ninput_file  = None\\nglobals     = {}\\n\\n#*** show error and exit\\ndef error(msg):\\n    print(\""%s\"" % (msg))\\n    exit(1)\\n\\nclass Node:\\n    def __init__(self, node_type, left = None, right = None, value = None):\\n        self.node_type  = node_type\\n        self.left  = left\\n        self.right = right\\n        self.value = value\\n\\n#***\\ndef make_node(oper, left, right = None):\\n    return Node(oper, left, right)\\n\\n#***\\ndef make_leaf(oper, n):\\n    return Node(oper, value = n)\\n\\n#***\\ndef fetch_var(var_name):\\n    n = globals.get(var_name, None)\\n    if n == None:\\n        globals[var_name] = n = 0\\n    return n\\n\\n#***\\ndef interp(x):\\n    global globals\\n\\n    if x == None: return None\\n    elif x.node_type == nd_Integer: return int(x.value)\\n    elif x.node_type == nd_Ident:   return fetch_var(x.value)\\n    elif x.node_type == nd_String:  return x.value\\n\\n    elif x.node_type == nd_Assign:\\n                    globals[x.left.value] = interp(x.right)\\n                    return None\\n    elif x.node_type == nd_Add:     return interp(x.left) +   interp(x.right)\\n    elif x.node_type == nd_Sub:     return interp(x.left) -   interp(x.right)\\n    elif x.node_type == nd_Mul:     return interp(x.left) *   interp(x.right)\\n    # use C like division semantics\\n    # another way: abs(x) / abs(y) * cmp(x, 0) * cmp(y, 0)\\n    elif x.node_type == nd_Div:     return int(float(interp(x.left)) / interp(x.right))\\n    elif x.node_type == nd_Mod:     return int(float(interp(x.left)) % interp(x.right))\\n    elif x.node_type == nd_Lss:     return interp(x.left) <   interp(x.right)\\n    elif x.node_type == nd_Gtr:     return interp(x.left) >   interp(x.right)\\n    elif x.node_type == nd_Leq:     return interp(x.left) <=  interp(x.right)\\n    elif x.node_type == nd_Geq:     return interp(x.left) >=  interp(x.right)\\n    elif x.node_type == nd_Eql:     return interp(x.left) ==  interp(x.right)\\n    elif x.node_type == nd_Neq:     return interp(x.left) !=  interp(x.right)\\n    elif x.node_type == nd_And:     return interp(x.left) and interp(x.right)\\n    elif x.node_type == nd_Or:      return interp(x.left) or  interp(x.right)\\n    elif x.node_type == nd_Negate:  return -interp(x.left)\\n    elif x.node_type == nd_Not:     return not interp(x.left)\\n\\n    elif x.node_type ==  nd_If:\\n                    if (interp(x.left)):\\n                        interp(x.right.left)\\n                    else:\\n                        interp(x.right.right)\\n                    return None\\n\\n    elif x.node_type == nd_While:\\n                    while (interp(x.left)):\\n                        interp(x.right)\\n                    return None\\n\\n    elif x.node_type == nd_Prtc:\\n                    print(\""%c\"" % (interp(x.left)), end='')\\n                    return None\\n\\n    elif x.node_type == nd_Prti:\\n                    print(\""%d\"" % (interp(x.left)), end='')\\n                    return None\\n\\n    elif x.node_type == nd_Prts:\\n                    print(interp(x.left), end='')\\n                    return None\\n\\n    elif x.node_type == nd_Sequence:\\n                    interp(x.left)\\n                    interp(x.right)\\n                    return None\\n    else:\\n        error(\""error in code generator - found %d, expecting operator\"" % (x.node_type))\\n\\ndef str_trans(srce):\\n    dest = \""\""\\n    i = 0\\n    srce = srce[1:-1]\\n    while i < len(srce):\\n        if srce[i] == '\\\\' and i + 1 < len(srce):\\n            if srce[i + 1] == 'n':\\n                dest += '\\n'\\n                i += 2\\n            elif srce[i + 1] == '\\\\':\\n                dest += '\\\\'\\n                i += 2\\n        else:\\n            dest += srce[i]\\n            i += 1\\n\\n    return dest\\n\\ndef load_ast():\\n    line = input_file.readline()\\n    line_list = shlex.split(line, False, False)\\n\\n    text = line_list[0]\\n\\n    value = None\\n    if len(line_list) > 1:\\n        value = line_list[1]\\n        if value.isdigit():\\n            value = int(value)\\n\\n    if text == \"";\"":\\n        return None\\n    node_type = all_syms[text]\\n    if value != None:\\n        if node_type == nd_String:\\n            value = str_trans(value)\\n\\n        return make_leaf(node_type, value)\\n    left = load_ast()\\n    right = load_ast()\\n    return make_node(node_type, left, right)\\n\\n#*** main driver\\ninput_file = sys.stdin\\nif len(sys.argv) > 1:\\n    try:\\n        input_file = open(sys.argv[1], \""r\"", 4096)\\n    except IOError as e:\\n        error(0, 0, \""Can't open %s\"" % sys.argv[1])\\n\\nn = load_ast()\\ninterp(n)"
"Python","Compiler/code_generator","A code generator translates the output of the syntax analyzer and/or semantic analyzer\\ninto lower level code, either assembly, object, or virtual.\\nTake the output of the Syntax analyzer task - which is a flattened Abstract Syntax Tree (AST) - and convert it to virtual machine code, that can be run by the\\nVirtual machine interpreter. The output is in text format, and represents virtual assembly code.\\nThe program should read input from a file and/or stdin, and write output to a file and/or\\nstdout.\\nAs shown in the table, above, the output from the syntax analyzer is a flattened AST.\\nIn the AST, Identifier, Integer, and String, are terminal nodes, e.g, they do not have child nodes.\\nLoading this data into an internal parse tree should be as simple as:\\n32-bit integers and strings\\nEach instruction is one byte. The following instructions also have a 32-bit integer operand:\\nwhere index is an index into the data array.\\nwhere index is an index into the data array.\\nwhere value is a 32-bit integer that will be pushed onto the stack.\\nwhere (n) is a 32-bit integer specifying the distance between the current location and the\\ndesired location. addr is an unsigned value of the actual code address.\\nwhere (n) is a 32-bit integer specifying the distance between the current location and the\\ndesired location. addr is an unsigned value of the actual code address.\\nThe following instructions do not have an operand. They perform their operation directly\\nagainst the stack:\\nFor the following instructions, the operation is performed against the top two entries in\\nthe stack:\\nFor the following instructions, the operation is performed against the top entry in the\\nstack:\\nPrint the word at stack top as a character.\\nPrint the word at stack top as an integer.\\nStack top points to an index into the string pool. Print that entry.\\nUnconditional stop.\\nYour solution should pass all the test cases above and the additional tests found Here.\\nThe C and Python versions can be considered reference implementations.\\nBased on the Algol W sample. This generates .NET IL assembler code which can be compiled with the .NET ilasm assembler to generate an exe that can be run under Windows (and presumably Mono though I haven't tried that).\\n\\nApart from the namespace, class and method blocks surrounding the code, the main differences between IL and the task's assembly code are: no \""compare-le\"", \""compare-ge\"", \""compare-ne\"", \""prts\"", \""prtc\"", \""prti\"" and \""not\"" instructions, symbolic labels are used and symbolic local variable names can be used. Some IL instructions have different names, e.g. \""stloc\"" instead of \""store\"". The \""prt*\"" instructions are handled by calling the relevant System.Out.Print method. The compare and \""not\"" instructions are handled by generating equivalent instruction sequences.\\n\\nAs noted in the code, the generated IL is naive - the sample focuses on simplicity.\\n","from __future__ import print_function\\nimport sys, struct, shlex, operator\\n\\nnd_Ident, nd_String, nd_Integer, nd_Sequence, nd_If, nd_Prtc, nd_Prts, nd_Prti, nd_While, \\\\nnd_Assign, nd_Negate, nd_Not, nd_Mul, nd_Div, nd_Mod, nd_Add, nd_Sub, nd_Lss, nd_Leq,     \\\\nnd_Gtr, nd_Geq, nd_Eql, nd_Neq, nd_And, nd_Or = range(25)\\n\\nall_syms = {\\n    \""Identifier\""  : nd_Ident,    \""String\""      : nd_String,\\n    \""Integer\""     : nd_Integer,  \""Sequence\""    : nd_Sequence,\\n    \""If\""          : nd_If,       \""Prtc\""        : nd_Prtc,\\n    \""Prts\""        : nd_Prts,     \""Prti\""        : nd_Prti,\\n    \""While\""       : nd_While,    \""Assign\""      : nd_Assign,\\n    \""Negate\""      : nd_Negate,   \""Not\""         : nd_Not,\\n    \""Multiply\""    : nd_Mul,      \""Divide\""      : nd_Div,\\n    \""Mod\""         : nd_Mod,      \""Add\""         : nd_Add,\\n    \""Subtract\""    : nd_Sub,      \""Less\""        : nd_Lss,\\n    \""LessEqual\""   : nd_Leq,      \""Greater\""     : nd_Gtr,\\n    \""GreaterEqual\"": nd_Geq,      \""Equal\""       : nd_Eql,\\n    \""NotEqual\""    : nd_Neq,      \""And\""         : nd_And,\\n    \""Or\""          : nd_Or}\\n\\nFETCH, STORE, PUSH, ADD, SUB, MUL, DIV, MOD, LT, GT, LE, GE, EQ, NE, AND, OR, NEG, NOT, \\\\nJMP, JZ, PRTC, PRTS, PRTI, HALT = range(24)\\n\\noperators = {nd_Lss: LT, nd_Gtr: GT, nd_Leq: LE, nd_Geq: GE, nd_Eql: EQ, nd_Neq: NE,\\n    nd_And: AND, nd_Or: OR, nd_Sub: SUB, nd_Add: ADD, nd_Div: DIV, nd_Mul: MUL, nd_Mod: MOD}\\n\\nunary_operators = {nd_Negate: NEG, nd_Not: NOT}\\n\\ninput_file  = None\\ncode        = bytearray()\\nstring_pool = {}\\nglobals     = {}\\nstring_n    = 0\\nglobals_n   = 0\\nword_size   = 4\\n\\n#*** show error and exit\\ndef error(msg):\\n    print(\""%s\"" % (msg))\\n    exit(1)\\n\\ndef int_to_bytes(val):\\n    return struct.pack(\"" 1:\\n        value = line_list[1]\\n        if value.isdigit():\\n            value = int(value)\\n        return make_leaf(node_type, value)\\n\\n    left = load_ast()\\n    right = load_ast()\\n    return make_node(node_type, left, right)\\n\\n#*** main driver\\ninput_file = sys.stdin\\nif len(sys.argv) > 1:\\n    try:\\n        input_file = open(sys.argv[1], \""r\"", 4096)\\n    except IOError as e:\\n        error(\""Can't open %s\"" % sys.argv[1])\\n\\nn = load_ast()\\ncode_gen(n)\\ncode_finish()\\nlist_code()"
"Python","Compiler/lexical_analyzer","Definition from Wikipedia:\\nCreate a lexical analyzer for the simple programming language specified below. The\\nprogram should read input from a file and/or stdin, and write output to a file and/or\\nstdout. If the language being used has a lexer module/library/class, it would be great\\nif two versions of the solution are provided: One without the lexer module, and one with.\\nThe simple programming language to be analyzed is more or less a subset of C. It supports the following tokens:\\nThese differ from the the previous tokens, in that each occurrence of them has a value associated with it.\\nFor example, the following two program fragments are equivalent, and should produce the same token stream except for the line and column positions:\\nThe program output should be a sequence of lines, each consisting of the following whitespace-separated fields:\\nThe following error conditions should be caught:\\nTest Case 1:\\nTest Case 2:\\nTest Case 3:\\nTest Case 4:\\nYour solution should pass all the test cases above and the additional tests found Here.\\nThe C and Python versions can be considered reference implementations.\\n","from __future__ import print_function\\nimport sys\\n\\n# following two must remain in the same order\\n\\ntk_EOI, tk_Mul, tk_Div, tk_Mod, tk_Add, tk_Sub, tk_Negate, tk_Not, tk_Lss, tk_Leq, tk_Gtr, \\\\ntk_Geq, tk_Eq, tk_Neq, tk_Assign, tk_And, tk_Or, tk_If, tk_Else, tk_While, tk_Print,       \\\\ntk_Putc, tk_Lparen, tk_Rparen, tk_Lbrace, tk_Rbrace, tk_Semi, tk_Comma, tk_Ident,          \\\\ntk_Integer, tk_String = range(31)\\n\\nall_syms = [\""End_of_input\"", \""Op_multiply\"", \""Op_divide\"", \""Op_mod\"", \""Op_add\"", \""Op_subtract\"",\\n    \""Op_negate\"", \""Op_not\"", \""Op_less\"", \""Op_lessequal\"", \""Op_greater\"", \""Op_greaterequal\"",\\n    \""Op_equal\"", \""Op_notequal\"", \""Op_assign\"", \""Op_and\"", \""Op_or\"", \""Keyword_if\"",\\n    \""Keyword_else\"", \""Keyword_while\"", \""Keyword_print\"", \""Keyword_putc\"", \""LeftParen\"",\\n    \""RightParen\"", \""LeftBrace\"", \""RightBrace\"", \""Semicolon\"", \""Comma\"", \""Identifier\"",\\n    \""Integer\"", \""String\""]\\n\\n# single character only symbols\\nsymbols = { '{': tk_Lbrace, '}': tk_Rbrace, '(': tk_Lparen, ')': tk_Rparen, '+': tk_Add, '-': tk_Sub,\\n    '*': tk_Mul, '%': tk_Mod, ';': tk_Semi, ',': tk_Comma }\\n\\nkey_words = {'if': tk_If, 'else': tk_Else, 'print': tk_Print, 'putc': tk_Putc, 'while': tk_While}\\n\\nthe_ch = \"" \""    # dummy first char - but it must be a space\\nthe_col = 0\\nthe_line = 1\\ninput_file = None\\n\\n#*** show error and exit\\ndef error(line, col, msg):\\n    print(line, col, msg)\\n    exit(1)\\n\\n#*** get the next character from the input\\ndef next_ch():\\n    global the_ch, the_col, the_line\\n\\n    the_ch = input_file.read(1)\\n    the_col += 1\\n    if the_ch == '\\n':\\n        the_line += 1\\n        the_col = 0\\n    return the_ch\\n\\n#*** 'x' - character constants\\ndef char_lit(err_line, err_col):\\n    n = ord(next_ch())              # skip opening quote\\n    if the_ch == '\\'':\\n        error(err_line, err_col, \""empty character constant\"")\\n    elif the_ch == '\\\\':\\n        next_ch()\\n        if the_ch == 'n':\\n            n = 10\\n        elif the_ch == '\\\\':\\n            n = ord('\\\\')\\n        else:\\n            error(err_line, err_col, \""unknown escape sequence \\\\%c\"" % (the_ch))\\n    if next_ch() != '\\'':\\n        error(err_line, err_col, \""multi-character constant\"")\\n    next_ch()\\n    return tk_Integer, err_line, err_col, n\\n\\n#*** process divide or comments\\ndef div_or_cmt(err_line, err_col):\\n    if next_ch() != '*':\\n        return tk_Div, err_line, err_col\\n\\n    # comment found\\n    next_ch()\\n    while True:\\n        if the_ch == '*':\\n            if next_ch() == '/':\\n                next_ch()\\n                return gettok()\\n        elif len(the_ch) == 0:\\n            error(err_line, err_col, \""EOF in comment\"")\\n        else:\\n            next_ch()\\n\\n#*** \""string\""\\ndef string_lit(start, err_line, err_col):\\n    text = \""\""\\n\\n    while next_ch() != start:\\n        if len(the_ch) == 0:\\n            error(err_line, err_col, \""EOF while scanning string literal\"")\\n        if the_ch == '\\n':\\n            error(err_line, err_col, \""EOL while scanning string literal\"")\\n        text += the_ch\\n\\n    next_ch()\\n    return tk_String, err_line, err_col, text\\n\\n#*** handle identifiers and integers\\ndef ident_or_int(err_line, err_col):\\n    is_number = True\\n    text = \""\""\\n\\n    while the_ch.isalnum() or the_ch == '_':\\n        text += the_ch\\n        if not the_ch.isdigit():\\n            is_number = False\\n        next_ch()\\n\\n    if len(text) == 0:\\n        error(err_line, err_col, \""ident_or_int: unrecognized character: (%d) '%c'\"" % (ord(the_ch), the_ch))\\n\\n    if text[0].isdigit():\\n        if not is_number:\\n            error(err_line, err_col, \""invalid number: %s\"" % (text))\\n        n = int(text)\\n        return tk_Integer, err_line, err_col, n\\n\\n    if text in key_words:\\n        return key_words[text], err_line, err_col\\n\\n    return tk_Ident, err_line, err_col, text\\n\\n#*** look ahead for '>=', etc.\\ndef follow(expect, ifyes, ifno, err_line, err_col):\\n    if next_ch() == expect:\\n        next_ch()\\n        return ifyes, err_line, err_col\\n\\n    if ifno == tk_EOI:\\n        error(err_line, err_col, \""follow: unrecognized character: (%d) '%c'\"" % (ord(the_ch), the_ch))\\n\\n    return ifno, err_line, err_col\\n\\n#*** return the next token type\\ndef gettok():\\n    while the_ch.isspace():\\n        next_ch()\\n\\n    err_line = the_line\\n    err_col  = the_col\\n\\n    if len(the_ch) == 0:    return tk_EOI, err_line, err_col\\n    elif the_ch == '/':     return div_or_cmt(err_line, err_col)\\n    elif the_ch == '\\'':    return char_lit(err_line, err_col)\\n    elif the_ch == '<':     return follow('=', tk_Leq, tk_Lss,    err_line, err_col)\\n    elif the_ch == '>':     return follow('=', tk_Geq, tk_Gtr,    err_line, err_col)\\n    elif the_ch == '=':     return follow('=', tk_Eq,  tk_Assign, err_line, err_col)\\n    elif the_ch == '!':     return follow('=', tk_Neq, tk_Not,    err_line, err_col)\\n    elif the_ch == '&':     return follow('&', tk_And, tk_EOI,    err_line, err_col)\\n    elif the_ch == '|':     return follow('|', tk_Or,  tk_EOI,    err_line, err_col)\\n    elif the_ch == '\""':     return string_lit(the_ch, err_line, err_col)\\n    elif the_ch in symbols:\\n        sym = symbols[the_ch]\\n        next_ch()\\n        return sym, err_line, err_col\\n    else: return ident_or_int(err_line, err_col)\\n\\n#*** main driver\\ninput_file = sys.stdin\\nif len(sys.argv) > 1:\\n    try:\\n        input_file = open(sys.argv[1], \""r\"", 4096)\\n    except IOError as e:\\n        error(0, 0, \""Can't open %s\"" % sys.argv[1])\\n\\nwhile True:\\n    t = gettok()\\n    tok  = t[0]\\n    line = t[1]\\n    col  = t[2]\\n\\n    print(\""%5d  %5d   %-14s\"" % (line, col, all_syms[tok]), end='')\\n\\n    if tok == tk_Integer:  print(\""   %5d\"" % (t[3]))\\n    elif tok == tk_Ident:  print(\""  %s\"" %   (t[3]))\\n    elif tok == tk_String: print('  \""%s\""' % (t[3]))\\n    else:                  print(\""\"")\\n\\n    if tok == tk_EOI:\\n        break"
"Python","Compiler/syntax_analyzer","A Syntax analyzer transforms a token stream (from the Lexical analyzer)\\ninto a Syntax tree, based on a grammar.\\nTake the output from the Lexical analyzer task,\\nand convert it to an Abstract Syntax Tree (AST),\\nbased on the grammar below. The output should be in a flattened format.\\nThe program should read input from a file and/or stdin, and write output to a file and/or\\nstdout. If the language being used has a parser module/library/class, it would be great\\nif two versions of the solution are provided: One without the parser module, and one\\nwith.\\nThe simple programming language to be analyzed is more or less a (very tiny) subset of\\nC. The formal grammar in\\nExtended Backus-Naur Form (EBNF):\\nThe resulting AST should be formulated as a Binary Tree.\\nIn the text below, Null/Empty nodes are represented by \"";\"".\\nFor Operators, the following nodes should be created:\\nFor each of the above nodes, the left and right sub-nodes are the operands of the\\nrespective operation.\\nIn pseudo S-Expression format:\\nNegate, Not\\nFor these node types, the left node is the operand, and the right node is null.\\nSequence - sub-nodes are either statements or Sequences.\\nIf - left node is the expression, the right node is If node, with it's left node being the\\nif-true statement part, and the right node being the if-false (else) statement part.\\nIf there is not an else, the tree becomes:\\nPrtc\\nPrts\\nPrti\\nWhile - left node is the expression, the right node is the statement.\\nAssign - left node is the left-hand side of the assignment, the right node is the\\nright-hand side of the assignment.\\nTerminal (leaf) nodes:\\nSequences denote a list node; they are used to represent a list. semicolon's represent a null node, e.g., the end of this path.\\nThis simple program:\\nProduces the following AST, encoded as a binary tree:\\nUnder each non-leaf node are two '|' lines. The first represents the left sub-node, the second represents the right sub-node:\\nIn flattened form:\\n\\nThis program:\\nProduces the following AST:\\nIn flattened form:\\nUses Precedence Climbing for expression parsing, and\\nRecursive Descent for statement parsing. The AST is also built:\\nFinally, the AST can also be tested by running it against one of the AST Interpreter solutions.\\nYour solution should pass all the test cases above and the additional tests found Here.\\nThe C and Python versions can be considered reference implementations.\\n","from __future__ import print_function\\nimport sys, shlex, operator\\n\\ntk_EOI, tk_Mul, tk_Div, tk_Mod, tk_Add, tk_Sub, tk_Negate, tk_Not, tk_Lss, tk_Leq, tk_Gtr, \\\\ntk_Geq, tk_Eql, tk_Neq, tk_Assign, tk_And, tk_Or, tk_If, tk_Else, tk_While, tk_Print,      \\\\ntk_Putc, tk_Lparen, tk_Rparen, tk_Lbrace, tk_Rbrace, tk_Semi, tk_Comma, tk_Ident,          \\\\ntk_Integer, tk_String = range(31)\\n\\nnd_Ident, nd_String, nd_Integer, nd_Sequence, nd_If, nd_Prtc, nd_Prts, nd_Prti, nd_While, \\\\nnd_Assign, nd_Negate, nd_Not, nd_Mul, nd_Div, nd_Mod, nd_Add, nd_Sub, nd_Lss, nd_Leq,     \\\\nnd_Gtr, nd_Geq, nd_Eql, nd_Neq, nd_And, nd_Or = range(25)\\n\\n# must have same order as above\\nTokens = [\\n    [\""EOI\""             , False, False, False, -1, -1        ],\\n    [\""*\""               , False, True,  False, 13, nd_Mul    ],\\n    [\""/\""               , False, True,  False, 13, nd_Div    ],\\n    [\""%\""               , False, True,  False, 13, nd_Mod    ],\\n    [\""+\""               , False, True,  False, 12, nd_Add    ],\\n    [\""-\""               , False, True,  False, 12, nd_Sub    ],\\n    [\""-\""               , False, False, True,  14, nd_Negate ],\\n    [\""!\""               , False, False, True,  14, nd_Not    ],\\n    [\""<\""               , False, True,  False, 10, nd_Lss    ],\\n    [\""<=\""              , False, True,  False, 10, nd_Leq    ],\\n    [\"">\""               , False, True,  False, 10, nd_Gtr    ],\\n    [\"">=\""              , False, True,  False, 10, nd_Geq    ],\\n    [\""==\""              , False, True,  False,  9, nd_Eql    ],\\n    [\""!=\""              , False, True,  False,  9, nd_Neq    ],\\n    [\""=\""               , False, False, False, -1, nd_Assign ],\\n    [\""&&\""              , False, True,  False,  5, nd_And    ],\\n    [\""||\""              , False, True,  False,  4, nd_Or     ],\\n    [\""if\""              , False, False, False, -1, nd_If     ],\\n    [\""else\""            , False, False, False, -1, -1        ],\\n    [\""while\""           , False, False, False, -1, nd_While  ],\\n    [\""print\""           , False, False, False, -1, -1        ],\\n    [\""putc\""            , False, False, False, -1, -1        ],\\n    [\""(\""               , False, False, False, -1, -1        ],\\n    [\"")\""               , False, False, False, -1, -1        ],\\n    [\""{\""               , False, False, False, -1, -1        ],\\n    [\""}\""               , False, False, False, -1, -1        ],\\n    [\"";\""               , False, False, False, -1, -1        ],\\n    [\"",\""               , False, False, False, -1, -1        ],\\n    [\""Ident\""           , False, False, False, -1, nd_Ident  ],\\n    [\""Integer literal\"" , False, False, False, -1, nd_Integer],\\n    [\""String literal\""  , False, False, False, -1, nd_String ]\\n    ]\\n\\nall_syms = {\""End_of_input\""   : tk_EOI,     \""Op_multiply\""    : tk_Mul,\\n            \""Op_divide\""      : tk_Div,     \""Op_mod\""         : tk_Mod,\\n            \""Op_add\""         : tk_Add,     \""Op_subtract\""    : tk_Sub,\\n            \""Op_negate\""      : tk_Negate,  \""Op_not\""         : tk_Not,\\n            \""Op_less\""        : tk_Lss,     \""Op_lessequal\""   : tk_Leq,\\n            \""Op_greater\""     : tk_Gtr,     \""Op_greaterequal\"": tk_Geq,\\n            \""Op_equal\""       : tk_Eql,     \""Op_notequal\""    : tk_Neq,\\n            \""Op_assign\""      : tk_Assign,  \""Op_and\""         : tk_And,\\n            \""Op_or\""          : tk_Or,      \""Keyword_if\""     : tk_If,\\n            \""Keyword_else\""   : tk_Else,    \""Keyword_while\""  : tk_While,\\n            \""Keyword_print\""  : tk_Print,   \""Keyword_putc\""   : tk_Putc,\\n            \""LeftParen\""      : tk_Lparen,  \""RightParen\""     : tk_Rparen,\\n            \""LeftBrace\""      : tk_Lbrace,  \""RightBrace\""     : tk_Rbrace,\\n            \""Semicolon\""      : tk_Semi,    \""Comma\""          : tk_Comma,\\n            \""Identifier\""     : tk_Ident,   \""Integer\""        : tk_Integer,\\n            \""String\""         : tk_String}\\n\\nDisplay_nodes = [\""Identifier\"", \""String\"", \""Integer\"", \""Sequence\"", \""If\"", \""Prtc\"", \""Prts\"",\\n    \""Prti\"", \""While\"", \""Assign\"", \""Negate\"", \""Not\"", \""Multiply\"", \""Divide\"", \""Mod\"", \""Add\"",\\n    \""Subtract\"", \""Less\"", \""LessEqual\"", \""Greater\"", \""GreaterEqual\"", \""Equal\"", \""NotEqual\"",\\n    \""And\"", \""Or\""]\\n\\nTK_NAME         = 0\\nTK_RIGHT_ASSOC  = 1\\nTK_IS_BINARY    = 2\\nTK_IS_UNARY     = 3\\nTK_PRECEDENCE   = 4\\nTK_NODE         = 5\\n\\ninput_file = None\\nerr_line   = None\\nerr_col    = None\\ntok        = None\\ntok_text   = None\\n\\n#*** show error and exit\\ndef error(msg):\\n    print(\""(%d, %d) %s\"" % (int(err_line), int(err_col), msg))\\n    exit(1)\\n\\n#***\\ndef gettok():\\n    global err_line, err_col, tok, tok_text, tok_other\\n    line = input_file.readline()\\n    if len(line) == 0:\\n        error(\""empty line\"")\\n\\n    line_list = shlex.split(line, False, False)\\n    # line col Ident var_name\\n    # 0    1   2     3\\n\\n    err_line = line_list[0]\\n    err_col  = line_list[1]\\n    tok_text = line_list[2]\\n\\n    tok = all_syms.get(tok_text)\\n    if tok == None:\\n        error(\""Unknown token %s\"" % (tok_text))\\n\\n    tok_other = None\\n    if tok in [tk_Integer, tk_Ident, tk_String]:\\n        tok_other = line_list[3]\\n\\nclass Node:\\n    def __init__(self, node_type, left = None, right = None, value = None):\\n        self.node_type  = node_type\\n        self.left  = left\\n        self.right = right\\n        self.value = value\\n\\n#***\\ndef make_node(oper, left, right = None):\\n    return Node(oper, left, right)\\n\\n#***\\ndef make_leaf(oper, n):\\n    return Node(oper, value = n)\\n\\n#***\\ndef expect(msg, s):\\n    if tok == s:\\n        gettok()\\n        return\\n    error(\""%s: Expecting '%s', found '%s'\"" % (msg, Tokens[s][TK_NAME], Tokens[tok][TK_NAME]))\\n\\n#***\\ndef expr(p):\\n    x = None\\n\\n    if tok == tk_Lparen:\\n        x = paren_expr()\\n    elif tok in [tk_Sub, tk_Add]:\\n        op = (tk_Negate if tok == tk_Sub else tk_Add)\\n        gettok()\\n        node = expr(Tokens[tk_Negate][TK_PRECEDENCE])\\n        x = (make_node(nd_Negate, node) if op == tk_Negate else node)\\n    elif tok == tk_Not:\\n        gettok()\\n        x = make_node(nd_Not, expr(Tokens[tk_Not][TK_PRECEDENCE]))\\n    elif tok == tk_Ident:\\n        x = make_leaf(nd_Ident, tok_other)\\n        gettok()\\n    elif tok == tk_Integer:\\n        x = make_leaf(nd_Integer, tok_other)\\n        gettok()\\n    else:\\n        error(\""Expecting a primary, found: %s\"" % (Tokens[tok][TK_NAME]))\\n\\n    while Tokens[tok][TK_IS_BINARY] and Tokens[tok][TK_PRECEDENCE] >= p:\\n        op = tok\\n        gettok()\\n        q = Tokens[op][TK_PRECEDENCE]\\n        if not Tokens[op][TK_RIGHT_ASSOC]:\\n            q += 1\\n\\n        node = expr(q)\\n        x = make_node(Tokens[op][TK_NODE], x, node)\\n\\n    return x\\n\\n#***\\ndef paren_expr():\\n    expect(\""paren_expr\"", tk_Lparen)\\n    node = expr(0)\\n    expect(\""paren_expr\"", tk_Rparen)\\n    return node\\n\\n#***\\ndef stmt():\\n    t = None\\n\\n    if tok == tk_If:\\n        gettok()\\n        e = paren_expr()\\n        s = stmt()\\n        s2 = None\\n        if tok == tk_Else:\\n            gettok()\\n            s2 = stmt()\\n        t = make_node(nd_If, e, make_node(nd_If, s, s2))\\n    elif tok == tk_Putc:\\n        gettok()\\n        e = paren_expr()\\n        t = make_node(nd_Prtc, e)\\n        expect(\""Putc\"", tk_Semi)\\n    elif tok == tk_Print:\\n        gettok()\\n        expect(\""Print\"", tk_Lparen)\\n        while True:\\n            if tok == tk_String:\\n                e = make_node(nd_Prts, make_leaf(nd_String, tok_other))\\n                gettok()\\n            else:\\n                e = make_node(nd_Prti, expr(0))\\n\\n            t = make_node(nd_Sequence, t, e)\\n            if tok != tk_Comma:\\n                break\\n            gettok()\\n        expect(\""Print\"", tk_Rparen)\\n        expect(\""Print\"", tk_Semi)\\n    elif tok == tk_Semi:\\n        gettok()\\n    elif tok == tk_Ident:\\n        v = make_leaf(nd_Ident, tok_other)\\n        gettok()\\n        expect(\""assign\"", tk_Assign)\\n        e = expr(0)\\n        t = make_node(nd_Assign, v, e)\\n        expect(\""assign\"", tk_Semi)\\n    elif tok == tk_While:\\n        gettok()\\n        e = paren_expr()\\n        s = stmt()\\n        t = make_node(nd_While, e, s)\\n    elif tok == tk_Lbrace:\\n        gettok()\\n        while tok != tk_Rbrace and tok != tk_EOI:\\n            t = make_node(nd_Sequence, t, stmt())\\n        expect(\""Lbrace\"", tk_Rbrace)\\n    elif tok == tk_EOI:\\n        pass\\n    else:\\n        error(\""Expecting start of statement, found: %s\"" % (Tokens[tok][TK_NAME]))\\n\\n    return t\\n\\n#***\\ndef parse():\\n    t = None\\n    gettok()\\n    while True:\\n        t = make_node(nd_Sequence, t, stmt())\\n        if tok == tk_EOI or t == None:\\n            break\\n    return t\\n\\ndef prt_ast(t):\\n    if t == None:\\n        print(\"";\"")\\n    else:\\n        print(\""%-14s\"" % (Display_nodes[t.node_type]), end='')\\n        if t.node_type in [nd_Ident, nd_Integer]:\\n            print(\""%s\"" % (t.value))\\n        elif t.node_type == nd_String:\\n            print(\""%s\"" %(t.value))\\n        else:\\n            print(\""\"")\\n            prt_ast(t.left)\\n            prt_ast(t.right)\\n\\n#*** main driver\\ninput_file = sys.stdin\\nif len(sys.argv) > 1:\\n    try:\\n        input_file = open(sys.argv[1], \""r\"", 4096)\\n    except IOError as e:\\n        error(0, 0, \""Can't open %s\"" % sys.argv[1])\\nt = parse()\\nprt_ast(t)"
"Python","Compiler/virtual_machine_interpreter","A virtual machine implements a computer in software.\\nWrite a virtual machine interpreter. This interpreter should be able to run virtual\\nassembly language programs created via the task. This is a\\nbyte-coded, 32-bit word stack based virtual machine.\\nThe program should read input from a file and/or stdin, and write output to a file and/or\\nstdout.\\nInput format:\\nGiven the following program:\\nThe output from the Code generator is a virtual assembly code program:\\nThe first line of the input specifies the datasize required and the number of constant\\nstrings, in the order that they are reference via the code.\\nThe data can be stored in a separate array, or the data can be stored at the beginning of\\nthe stack. Data is addressed starting at 0. If there are 3 variables, the 3rd one if\\nreferenced at address 2.\\nIf there are one or more constant strings, they come next. The code refers to these\\nstrings by their index. The index starts at 0. So if there are 3 strings, and the code\\nwants to reference the 3rd string, 2 will be used.\\nNext comes the actual virtual assembly code. The first number is the code address of that\\ninstruction. After that is the instruction mnemonic, followed by optional operands,\\ndepending on the instruction.\\nRegisters:\\nsp:\\npc:\\nData:\\nInstructions:\\nEach instruction is one byte. The following instructions also have a 32-bit integer\\noperand:\\nwhere index is an index into the data array.\\nwhere index is an index into the data array.\\nwhere value is a 32-bit integer that will be pushed onto the stack.\\nwhere (n) is a 32-bit integer specifying the distance between the current location and the\\ndesired location. addr is an unsigned value of the actual code address.\\nwhere (n) is a 32-bit integer specifying the distance between the current location and the\\ndesired location. addr is an unsigned value of the actual code address.\\nThe following instructions do not have an operand. They perform their operation directly\\nagainst the stack:\\nFor the following instructions, the operation is performed against the top two entries in\\nthe stack:\\nFor the following instructions, the operation is performed against the top entry in the\\nstack:\\nPrint the word at stack top as a character.\\nPrint the word at stack top as an integer.\\nStack top points to an index into the string pool. Print that entry.\\nUnconditional stop.\\nYour solution should pass all the test cases above and the additional tests found Here.\\nThe C and Python versions can be considered reference implementations.\\nTested with gawk 4.1.1 and mawk 1.3.4.\\n","from __future__ import print_function\\nimport sys, struct\\n\\nFETCH, STORE, PUSH, ADD, SUB, MUL, DIV, MOD, LT, GT, LE, GE, EQ, NE, AND, OR, NEG, NOT, \\\\nJMP, JZ, PRTC, PRTS, PRTI, HALT = range(24)\\n\\ncode_map = {\\n    \""fetch\"": FETCH,\\n    \""store\"": STORE,\\n    \""push\"":  PUSH,\\n    \""add\"":   ADD,\\n    \""sub\"":   SUB,\\n    \""mul\"":   MUL,\\n    \""div\"":   DIV,\\n    \""mod\"":   MOD,\\n    \""lt\"":    LT,\\n    \""gt\"":    GT,\\n    \""le\"":    LE,\\n    \""ge\"":    GE,\\n    \""eq\"":    EQ,\\n    \""ne\"":    NE,\\n    \""and\"":   AND,\\n    \""or\"":    OR,\\n    \""not\"":   NOT,\\n    \""neg\"":   NEG,\\n    \""jmp\"":   JMP,\\n    \""jz\"":    JZ,\\n    \""prtc\"":  PRTC,\\n    \""prts\"":  PRTS,\\n    \""prti\"":  PRTI,\\n    \""halt\"":  HALT\\n}\\n\\ninput_file  = None\\ncode        = bytearray()\\nstring_pool = []\\nword_size   = 4\\n\\n#*** show error and exit\\ndef error(msg):\\n    print(\""%s\"" % (msg))\\n    exit(1)\\n\\ndef int_to_bytes(val):\\n    return struct.pack(\""  stack[-1]; stack.pop()\\n        elif op == LE:    stack[-2] = stack[-2] <= stack[-1]; stack.pop()\\n        elif op == GE:    stack[-2] = stack[-2] >= stack[-1]; stack.pop()\\n        elif op == EQ:    stack[-2] = stack[-2] == stack[-1]; stack.pop()\\n        elif op == NE:    stack[-2] = stack[-2] != stack[-1]; stack.pop()\\n        elif op == AND:   stack[-2] = stack[-2] and stack[-1]; stack.pop()\\n        elif op == OR:    stack[-2] = stack[-2] or  stack[-1]; stack.pop()\\n        elif op == NEG:   stack[-1] = -stack[-1]\\n        elif op == NOT:   stack[-1] = not stack[-1]\\n        elif op == JMP:   pc += bytes_to_int(code[pc:pc+word_size])[0]\\n        elif op == JZ:\\n            if stack.pop():\\n                pc += word_size\\n            else:\\n                pc += bytes_to_int(code[pc:pc+word_size])[0]\\n        elif op == PRTC:  print(\""%c\"" % (stack[-1]), end=''); stack.pop()\\n        elif op == PRTS:  print(\""%s\"" % (string_pool[stack[-1]]), end=''); stack.pop()\\n        elif op == PRTI:  print(\""%d\"" % (stack[-1]), end=''); stack.pop()\\n        elif op == HALT:  break\\n\\ndef str_trans(srce):\\n    dest = \""\""\\n    i = 0\\n    while i < len(srce):\\n        if srce[i] == '\\\\' and i + 1 < len(srce):\\n            if srce[i + 1] == 'n':\\n                dest += '\\n'\\n                i += 2\\n            elif srce[i + 1] == '\\\\':\\n                dest += '\\\\'\\n                i += 2\\n        else:\\n            dest += srce[i]\\n            i += 1\\n\\n    return dest\\n\\n#***\\ndef load_code():\\n    global string_pool\\n\\n    line = input_file.readline()\\n    if len(line) == 0:\\n        error(\""empty line\"")\\n\\n    line_list = line.split()\\n    data_size = int(line_list[1])\\n    n_strings = int(line_list[3])\\n\\n    for i in range(n_strings):\\n        string_pool.append(str_trans(input_file.readline().strip('\""\\n')))\\n\\n    while True:\\n        line = input_file.readline()\\n        if len(line) == 0:\\n            break\\n        line_list = line.split()\\n        offset = int(line_list[0])\\n        instr  = line_list[1]\\n        opcode = code_map.get(instr)\\n        if opcode == None:\\n            error(\""Unknown instruction %s at %d\"" % (instr, offset))\\n        emit_byte(opcode)\\n        if opcode in [JMP, JZ]:\\n            p = int(line_list[3])\\n            emit_word(p - (offset + 1))\\n        elif opcode == PUSH:\\n            value = int(line_list[2])\\n            emit_word(value)\\n        elif opcode in [FETCH, STORE]:\\n            value = int(line_list[2].strip('[]'))\\n            emit_word(value)\\n\\n    return data_size\\n\\n#*** main driver\\ninput_file = sys.stdin\\nif len(sys.argv) > 1:\\n    try:\\n        input_file = open(sys.argv[1], \""r\"", 4096)\\n    except IOError as e:\\n        error(0, 0, \""Can't open %s\"" % sys.argv[1])\\n\\ndata_size = load_code()\\nrun_vm(data_size)"
"Python","Compound_data_type","Data Structure\\nThis illustrates a data structure, a means of storing data within a program.\\n\\nCreate a compound data type:\\n\\nA compound data type is one that holds multiple independent values.\\n\\n\\n\\n","X, Y = 0, 1\\np = (3, 4)\\np = [3, 4]\\n\\nprint p[X]"
"Python","Compound_data_type","Data Structure\\nThis illustrates a data structure, a means of storing data within a program.\\n\\nCreate a compound data type:\\n\\nA compound data type is one that holds multiple independent values.\\n\\n\\n\\n","class Point:\\n    def __init__(self, x=0, y=0):\\n        self.x = x\\n        self.y = y\\n\\np = Point()\\nprint p.x"
"Python","Compound_data_type","Data Structure\\nThis illustrates a data structure, a means of storing data within a program.\\n\\nCreate a compound data type:\\n\\nA compound data type is one that holds multiple independent values.\\n\\n\\n\\n","class MyObject(object): pass\\npoint = MyObject()\\npoint.x, point.y = 0, 1\\n# objects directly instantiated from \""object()\""  cannot be \""monkey patched\""\\n# however this can generally be done to it's subclasses"
"Python","Compound_data_type","Data Structure\\nThis illustrates a data structure, a means of storing data within a program.\\n\\nCreate a compound data type:\\n\\nA compound data type is one that holds multiple independent values.\\n\\n\\n\\n","pseudo_object = {'x': 1, 'y': 2}"
"Python","Compound_data_type","Data Structure\\nThis illustrates a data structure, a means of storing data within a program.\\n\\nCreate a compound data type:\\n\\nA compound data type is one that holds multiple independent values.\\n\\n\\n\\n",">>> from collections import namedtuple\\n>>> help(namedtuple)\\nHelp on function namedtuple in module collections:\\n\\nnamedtuple(typename, field_names, verbose=False)\\n    Returns a new subclass of tuple with named fields.\\n    \\n    >>> Point = namedtuple('Point', 'x y')\\n    >>> Point.__doc__                   # docstring for the new class\\n    'Point(x, y)'\\n    >>> p = Point(11, y=22)             # instantiate with positional args or keywords\\n    >>> p[0] + p[1]                     # indexable like a plain tuple\\n    33\\n    >>> x, y = p                        # unpack like a regular tuple\\n    >>> x, y\\n    (11, 22)\\n    >>> p.x + p.y                       # fields also accessable by name\\n    33\\n    >>> d = p._asdict()                 # convert to a dictionary\\n    >>> d['x']\\n    11\\n    >>> Point(**d)                      # convert from a dictionary\\n    Point(x=11, y=22)\\n    >>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\\n    Point(x=100, y=22)\\n\\n>>>"
"Python","Concurrent_computing","Using either native language concurrency syntax or freely available libraries, write a program to display the strings \""Enjoy\"" \""Rosetta\"" \""Code\"", one string per line, in random order.\\nConcurrency syntax must use threads, tasks, co-routines, or whatever concurrency is called in your language.\\n\\nNote that random generator object is local to each task. It cannot be accessed concurrently without mutual exclusion. In order to get different initial states of local generators Reset is called (see ARM A.5.2).\\nBaCon is a BASIC-to-C compiler. Assuming GCC compiler in this demonstration. Based on the C OpenMP source.\\n","Python 3.2 (r32:88445, Feb 20 2011, 21:30:00) [MSC v.1500 64 bit (AMD64)] on win 32\\nType \""help\"", \""copyright\"", \""credits\"" or \""license\"" for more information.\\n>>> from concurrent import futures\\n>>> with futures.ProcessPoolExecutor() as executor:\\n...   _ = list(executor.map(print, 'Enjoy Rosetta Code'.split()))\\n...\\nEnjoy\\nRosetta\\nCode\\n>>>"
"Python","Concurrent_computing","Using either native language concurrency syntax or freely available libraries, write a program to display the strings \""Enjoy\"" \""Rosetta\"" \""Code\"", one string per line, in random order.\\nConcurrency syntax must use threads, tasks, co-routines, or whatever concurrency is called in your language.\\n\\nNote that random generator object is local to each task. It cannot be accessed concurrently without mutual exclusion. In order to get different initial states of local generators Reset is called (see ARM A.5.2).\\nBaCon is a BASIC-to-C compiler. Assuming GCC compiler in this demonstration. Based on the C OpenMP source.\\n","import threading\\nimport random\\n \\ndef echo(text):\\n    print(text)\\n \\nthreading.Timer(random.random(), echo, (\""Enjoy\"",)).start()\\nthreading.Timer(random.random(), echo, (\""Rosetta\"",)).start()\\nthreading.Timer(random.random(), echo, (\""Code\"",)).start()"
"Python","Concurrent_computing","Using either native language concurrency syntax or freely available libraries, write a program to display the strings \""Enjoy\"" \""Rosetta\"" \""Code\"", one string per line, in random order.\\nConcurrency syntax must use threads, tasks, co-routines, or whatever concurrency is called in your language.\\n\\nNote that random generator object is local to each task. It cannot be accessed concurrently without mutual exclusion. In order to get different initial states of local generators Reset is called (see ARM A.5.2).\\nBaCon is a BASIC-to-C compiler. Assuming GCC compiler in this demonstration. Based on the C OpenMP source.\\n","import threading\\nimport random\\n\\ndef echo(text):\\n    print(text)\\n\\nfor text in [\""Enjoy\"", \""Rosetta\"", \""Code\""]:\\n    threading.Timer(random.random(), echo, (text,)).start()"
"Python","Concurrent_computing","Using either native language concurrency syntax or freely available libraries, write a program to display the strings \""Enjoy\"" \""Rosetta\"" \""Code\"", one string per line, in random order.\\nConcurrency syntax must use threads, tasks, co-routines, or whatever concurrency is called in your language.\\n\\nNote that random generator object is local to each task. It cannot be accessed concurrently without mutual exclusion. In order to get different initial states of local generators Reset is called (see ARM A.5.2).\\nBaCon is a BASIC-to-C compiler. Assuming GCC compiler in this demonstration. Based on the C OpenMP source.\\n","import random, sys, time\\nimport threading\\n\\nlock = threading.Lock()\\n\\ndef echo(s):\\n    time.sleep(1e-2*random.random())\\n    # use `.write()` with lock due to `print` prints empty lines occasionally\\n    with lock:\\n        sys.stdout.write(s)\\n        sys.stdout.write('\\n')\\n\\nfor line in 'Enjoy Rosetta Code'.split():\\n    threading.Thread(target=echo, args=(line,)).start()"
"Python","Concurrent_computing","Using either native language concurrency syntax or freely available libraries, write a program to display the strings \""Enjoy\"" \""Rosetta\"" \""Code\"", one string per line, in random order.\\nConcurrency syntax must use threads, tasks, co-routines, or whatever concurrency is called in your language.\\n\\nNote that random generator object is local to each task. It cannot be accessed concurrently without mutual exclusion. In order to get different initial states of local generators Reset is called (see ARM A.5.2).\\nBaCon is a BASIC-to-C compiler. Assuming GCC compiler in this demonstration. Based on the C OpenMP source.\\n","from __future__ import print_function\\nfrom multiprocessing import Pool\\n\\ndef main():\\n    p = Pool()\\n    p.map(print, 'Enjoy Rosetta Code'.split())\\n\\nif __name__==\""__main__\"":\\n    main()"
"Python","Concurrent_computing","Using either native language concurrency syntax or freely available libraries, write a program to display the strings \""Enjoy\"" \""Rosetta\"" \""Code\"", one string per line, in random order.\\nConcurrency syntax must use threads, tasks, co-routines, or whatever concurrency is called in your language.\\n\\nNote that random generator object is local to each task. It cannot be accessed concurrently without mutual exclusion. In order to get different initial states of local generators Reset is called (see ARM A.5.2).\\nBaCon is a BASIC-to-C compiler. Assuming GCC compiler in this demonstration. Based on the C OpenMP source.\\n","import random\\nfrom twisted.internet    import reactor, task, defer\\nfrom twisted.python.util import println\\n\\ndelay = lambda: 1e-4*random.random()\\nd = defer.DeferredList([task.deferLater(reactor, delay(), println, line)\\n                        for line in 'Enjoy Rosetta Code'.split()])\\nd.addBoth(lambda _: reactor.stop())\\nreactor.run()"
"Python","Concurrent_computing","Using either native language concurrency syntax or freely available libraries, write a program to display the strings \""Enjoy\"" \""Rosetta\"" \""Code\"", one string per line, in random order.\\nConcurrency syntax must use threads, tasks, co-routines, or whatever concurrency is called in your language.\\n\\nNote that random generator object is local to each task. It cannot be accessed concurrently without mutual exclusion. In order to get different initial states of local generators Reset is called (see ARM A.5.2).\\nBaCon is a BASIC-to-C compiler. Assuming GCC compiler in this demonstration. Based on the C OpenMP source.\\n","from __future__ import print_function\\nimport random\\nimport gevent\\n\\ndelay = lambda: 1e-4*random.random()\\ngevent.joinall([gevent.spawn_later(delay(), print, line)\\n               for line in 'Enjoy Rosetta Code'.split()])"
"Python","Conjugate_transpose","Suppose that a matrix \\n\\n\\n\\nM\\n\\n\\n{\\displaystyle M}\\n\\n contains complex numbers. Then the conjugate transpose of \\n\\n\\n\\nM\\n\\n\\n{\\displaystyle M}\\n\\n is a matrix \\n\\n\\n\\n\\nM\\n\\nH\\n\\n\\n\\n\\n{\\displaystyle M^{H}}\\n\\n containing the complex conjugates of the matrix transposition of \\n\\n\\n\\nM\\n\\n\\n{\\displaystyle M}\\n\\n.\\n\\nThis means that row \\n\\n\\n\\nj\\n\\n\\n{\\displaystyle j}\\n\\n, column \\n\\n\\n\\ni\\n\\n\\n{\\displaystyle i}\\n\\n of the conjugate transpose equals the\\ncomplex conjugate of row \\n\\n\\n\\ni\\n\\n\\n{\\displaystyle i}\\n\\n, column \\n\\n\\n\\nj\\n\\n\\n{\\displaystyle j}\\n\\n of the original matrix.\\n\\nIn the next list, \\n\\n\\n\\nM\\n\\n\\n{\\displaystyle M}\\n\\n must also be a square matrix.\\n\\n\\nGiven some matrix of complex numbers, find its conjugate transpose.\\nAlso determine if the matrix is a:\\n\\n\\n","def conjugate_transpose(m):\\n    return tuple(tuple(n.conjugate() for n in row) for row in zip(*m))\\n\\ndef mmul( ma, mb):\\n    return tuple(tuple(sum( ea*eb for ea,eb in zip(a,b)) for b in zip(*mb)) for a in ma)\\n\\ndef mi(size):\\n    'Complex Identity matrix'\\n    sz = range(size)\\n    m = [[0 + 0j for i in sz] for j in sz]\\n    for i in range(size):\\n        m[i][i] = 1 + 0j\\n    return tuple(tuple(row) for row in m)\\n\\ndef __allsame(vector):\\n    first, rest = vector[0], vector[1:]\\n    return all(i == first for i in rest)\\n\\ndef __allnearsame(vector, eps=1e-14):\\n    first, rest = vector[0], vector[1:]\\n    return all(abs(first.real - i.real) < eps and abs(first.imag - i.imag) < eps\\n               for i in rest)\\n\\ndef isequal(matrices, eps=1e-14):\\n    'Check any number of matrices for equality within eps'\\n    x = [len(m) for m in matrices]\\n    if not __allsame(x): return False\\n    y = [len(m[0]) for m in matrices]\\n    if not __allsame(y): return False\\n    for s in range(x[0]):\\n        for t in range(y[0]):\\n            if not __allnearsame([m[s][t] for m in matrices], eps): return False\\n    return True\\n    \\n\\ndef ishermitian(m, ct):\\n    return isequal([m, ct])\\n\\ndef isnormal(m, ct):\\n    return isequal([mmul(m, ct), mmul(ct, m)])\\n\\ndef isunitary(m, ct):\\n    mct, ctm = mmul(m, ct), mmul(ct, m)\\n    mctx, mcty, cmx, ctmy = len(mct), len(mct[0]), len(ctm), len(ctm[0])\\n    ident = mi(mctx)\\n    return isequal([mct, ctm, ident])\\n\\ndef printm(comment, m):\\n    print(comment)\\n    fields = [['%g%+gj' % (f.real, f.imag) for f in row] for row in m]\\n    width = max(max(len(f) for f in row) for row in fields)\\n    lines = (', '.join('%*s' % (width, f) for f in row) for row in fields)\\n    print('\\n'.join(lines))\\n\\nif __name__ == '__main__':\\n    for matrix in [\\n            ((( 3.000+0.000j), (+2.000+1.000j)), \\n            (( 2.000-1.000j), (+1.000+0.000j))),\\n\\n            ((( 1.000+0.000j), (+1.000+0.000j), (+0.000+0.000j)), \\n            (( 0.000+0.000j), (+1.000+0.000j), (+1.000+0.000j)), \\n            (( 1.000+0.000j), (+0.000+0.000j), (+1.000+0.000j))),\\n\\n            ((( 2**0.5/2+0.000j), (+2**0.5/2+0.000j), (+0.000+0.000j)), \\n            (( 0.000+2**0.5/2j), (+0.000-2**0.5/2j), (+0.000+0.000j)), \\n            (( 0.000+0.000j), (+0.000+0.000j), (+0.000+1.000j)))]:\\n        printm('\\nMatrix:', matrix)\\n        ct = conjugate_transpose(matrix)\\n        printm('Its conjugate transpose:', ct)\\n        print('Hermitian? %s.' % ishermitian(matrix, ct))\\n        print('Normal?    %s.' % isnormal(matrix, ct))\\n        print('Unitary?   %s.' % isunitary(matrix, ct))"
"Python","Constrained_random_points_on_a_circle","Generate 100 <x,y> coordinate pairs such that x and y are integers sampled from the uniform distribution with the condition that \\n\\n\\n\\n10\\n≤\\n\\n\\n\\nx\\n\\n2\\n\\n\\n+\\n\\ny\\n\\n2\\n\\n\\n\\n\\n≤\\n15\\n\\n\\n{\\displaystyle 10\\leq {\\sqrt {x^{2}+y^{2}}}\\leq 15}\\n\\n. Then display/plot them. The outcome should be a \""fuzzy\"" circle. The actual number of points plotted may be less than 100, given that some pairs may be generated more than once.\\nThere are several possible approaches to accomplish this. Here are two possible algorithms.\\n1) Generate random pairs of integers and filter out those that don't satisfy this condition:\\n2) Precalculate the set of all possible points (there are 404 of them) and select randomly from this set.\\n\\nOutput:\\nSample output:\\nRequires the GDI+ standard library by tic: http://www.autohotkey.com/forum/viewtopic.php?t=32238 Works with individual pixels.\\nPre calculate and plot 100 points to the console\\nConsole output:\\n\\nThe output may be a bit distorted, since even monospace fonts take more vertical space per character than horizontal space.\\nThis uses std.complex because D built-in complex numbers will be deprecated.\\n",">>> from collections import defaultdict\\n>>> from random import choice\\n>>> world = defaultdict(int)\\n>>> possiblepoints = [(x,y) for x in range(-15,16)\\n		  for y in range(-15,16)\\n		  if 10 <= abs(x+y*1j) <= 15]\\n>>> for i in range(100): world[choice(possiblepoints)] += 1\\n\\n>>> for x in range(-15,16):\\n	print(''.join(str(min([9, world[(x,y)]])) if world[(x,y)] else ' '\\n			  for y in range(-15,16)))\\n\\n	\\n                               \\n             1     1           \\n          1 1                  \\n      11 1     1  1     1      \\n     111  1     1211           \\n      1   2    1 1    11       \\n      1  11         21         \\n     1   1            11  1    \\n   1  2                1 1     \\n                               \\n 1  2                          \\n   1 1                      1  \\n   1 1                         \\n   2                      11   \\n  1                         1  \\n                         1     \\n                               \\n                               \\n  1                          1 \\n                         1     \\n                         2     \\n                            1  \\n     1                  1 1    \\n      1                2   1   \\n   1   3            11  2      \\n    11   1    1      1   2     \\n            1   1    2         \\n        1  1                   \\n         1      1     1        \\n          2 2   1              \\n               1               "
"Python","Constrained_random_points_on_a_circle","Generate 100 <x,y> coordinate pairs such that x and y are integers sampled from the uniform distribution with the condition that \\n\\n\\n\\n10\\n≤\\n\\n\\n\\nx\\n\\n2\\n\\n\\n+\\n\\ny\\n\\n2\\n\\n\\n\\n\\n≤\\n15\\n\\n\\n{\\displaystyle 10\\leq {\\sqrt {x^{2}+y^{2}}}\\leq 15}\\n\\n. Then display/plot them. The outcome should be a \""fuzzy\"" circle. The actual number of points plotted may be less than 100, given that some pairs may be generated more than once.\\nThere are several possible approaches to accomplish this. Here are two possible algorithms.\\n1) Generate random pairs of integers and filter out those that don't satisfy this condition:\\n2) Precalculate the set of all possible points (there are 404 of them) and select randomly from this set.\\n\\nOutput:\\nSample output:\\nRequires the GDI+ standard library by tic: http://www.autohotkey.com/forum/viewtopic.php?t=32238 Works with individual pixels.\\nPre calculate and plot 100 points to the console\\nConsole output:\\n\\nThe output may be a bit distorted, since even monospace fonts take more vertical space per character than horizontal space.\\nThis uses std.complex because D built-in complex numbers will be deprecated.\\n",">>> for i in range(1000): world[choice(possiblepoints)] += 1\\n\\n>>> for x in range(-15,16):\\n	print(''.join(str(min([9, world[(x,y)]])) if world[(x,y)] else ' '\\n			  for y in range(-15,16)))\\n\\n	\\n               2               \\n          41341421333          \\n        5133333131253 1        \\n      5231514 14214721 24      \\n     326 21222143234122322     \\n    54235153132123344125 22    \\n   32331432         2422 33    \\n   5453135           4144344   \\n  132595               323123  \\n  4 6353               432224  \\n 5 4323                 3 5313 \\n 23214                   41433 \\n 42454                   33342 \\n 332 4                   34314 \\n 142 1                   35 53 \\n124211                   53131 \\n 22221                   152 4 \\n 22213                   34562 \\n 654 4                   4 212 \\n 24354                   52232 \\n 544222                 283323 \\n  411123               453325  \\n  251321               124332  \\n   2124134           2443226   \\n   2 113315         64324334   \\n    2412452 324 32121132363    \\n      4222434324635 5433       \\n      3113333123432112633      \\n        2131181233  424        \\n          47414232164          \\n               4               "
"Python","Continued_fraction","The task is to write a program which generates such a number and prints a real representation of it. The code should be tested by calculating and printing the square root of 2, Napier's Constant, and Pi, using the following coefficients:\\nFor the square root of 2, use \\n\\n\\n\\n\\na\\n\\n0\\n\\n\\n=\\n1\\n\\n\\n{\\displaystyle a_{0}=1}\\n\\n then \\n\\n\\n\\n\\na\\n\\nN\\n\\n\\n=\\n2\\n\\n\\n{\\displaystyle a_{N}=2}\\n\\n. \\n\\n\\n\\n\\nb\\n\\nN\\n\\n\\n\\n\\n{\\displaystyle b_{N}}\\n\\n is always \\n\\n\\n\\n1\\n\\n\\n{\\displaystyle 1}\\n\\n.\\nFor Napier's Constant, use \\n\\n\\n\\n\\na\\n\\n0\\n\\n\\n=\\n2\\n\\n\\n{\\displaystyle a_{0}=2}\\n\\n, then \\n\\n\\n\\n\\na\\n\\nN\\n\\n\\n=\\nN\\n\\n\\n{\\displaystyle a_{N}=N}\\n\\n. \\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n=\\n1\\n\\n\\n{\\displaystyle b_{1}=1}\\n\\n then \\n\\n\\n\\n\\nb\\n\\nN\\n\\n\\n=\\nN\\n−\\n1\\n\\n\\n{\\displaystyle b_{N}=N-1}\\n\\n.\\nFor Pi, use \\n\\n\\n\\n\\na\\n\\n0\\n\\n\\n=\\n3\\n\\n\\n{\\displaystyle a_{0}=3}\\n\\n then \\n\\n\\n\\n\\na\\n\\nN\\n\\n\\n=\\n6\\n\\n\\n{\\displaystyle a_{N}=6}\\n\\n. \\n\\n\\n\\n\\nb\\n\\nN\\n\\n\\n=\\n(\\n2\\nN\\n−\\n1\\n\\n)\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle b_{N}=(2N-1)^{2}}\\n\\n.\\n\\n(The source text for these examples can also be found on Bitbucket.)\\nGeneric function for estimating continued fractions:\\nTest program using the function above to estimate the square root of 2, Napiers constant and pi:\\nThis example is exactly the same as the preceding one, but implemented using only Ada 95 features.\\n","from fractions import Fraction\\nimport itertools\\ntry: zip = itertools.izip\\nexcept: pass\\n \\n# The Continued Fraction\\ndef CF(a, b, t):\\n  terms = list(itertools.islice(zip(a, b), t))\\n  z = Fraction(1,1)\\n  for a, b in reversed(terms):\\n    z = a + b / z\\n  return z\\n \\n# Approximates a fraction to a string\\ndef pRes(x, d):\\n  q, x = divmod(x, 1)\\n  res = str(q)\\n  res += \"".\""\\n  for i in range(d):\\n    x *= 10\\n    q, x = divmod(x, 1)\\n    res += str(q)\\n  return res\\n \\n# Test the Continued Fraction for sqrt2\\ndef sqrt2_a():\\n  yield 1\\n  for x in itertools.repeat(2):\\n    yield x\\n \\ndef sqrt2_b():\\n  for x in itertools.repeat(1):\\n    yield x\\n \\ncf = CF(sqrt2_a(), sqrt2_b(), 950)\\nprint(pRes(cf, 200))\\n#1.41421356237309504880168872420969807856967187537694807317667973799073247846210703885038753432764157273501384623091229702492483605585073721264412149709993583141322266592750559275579995050115278206057147\\n \\n \\n# Test the Continued Fraction for Napier's Constant\\ndef Napier_a():\\n  yield 2\\n  for x in itertools.count(1):\\n    yield x\\n \\ndef Napier_b():\\n  yield 1\\n  for x in itertools.count(1):\\n    yield x\\n \\ncf = CF(Napier_a(), Napier_b(), 950)\\nprint(pRes(cf, 200))\\n#2.71828182845904523536028747135266249775724709369995957496696762772407663035354759457138217852516642742746639193200305992181741359662904357290033429526059563073813232862794349076323382988075319525101901\\n \\n# Test the Continued Fraction for Pi\\ndef Pi_a():\\n  yield 3\\n  for x in itertools.repeat(6):\\n    yield x\\n \\ndef Pi_b():\\n  for x in itertools.count(1,2):\\n    yield x*x\\n \\ncf = CF(Pi_a(), Pi_b(), 950)\\nprint(pRes(cf, 10))\\n#3.1415926532"
"Python","Continued_fraction","The task is to write a program which generates such a number and prints a real representation of it. The code should be tested by calculating and printing the square root of 2, Napier's Constant, and Pi, using the following coefficients:\\nFor the square root of 2, use \\n\\n\\n\\n\\na\\n\\n0\\n\\n\\n=\\n1\\n\\n\\n{\\displaystyle a_{0}=1}\\n\\n then \\n\\n\\n\\n\\na\\n\\nN\\n\\n\\n=\\n2\\n\\n\\n{\\displaystyle a_{N}=2}\\n\\n. \\n\\n\\n\\n\\nb\\n\\nN\\n\\n\\n\\n\\n{\\displaystyle b_{N}}\\n\\n is always \\n\\n\\n\\n1\\n\\n\\n{\\displaystyle 1}\\n\\n.\\nFor Napier's Constant, use \\n\\n\\n\\n\\na\\n\\n0\\n\\n\\n=\\n2\\n\\n\\n{\\displaystyle a_{0}=2}\\n\\n, then \\n\\n\\n\\n\\na\\n\\nN\\n\\n\\n=\\nN\\n\\n\\n{\\displaystyle a_{N}=N}\\n\\n. \\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n=\\n1\\n\\n\\n{\\displaystyle b_{1}=1}\\n\\n then \\n\\n\\n\\n\\nb\\n\\nN\\n\\n\\n=\\nN\\n−\\n1\\n\\n\\n{\\displaystyle b_{N}=N-1}\\n\\n.\\nFor Pi, use \\n\\n\\n\\n\\na\\n\\n0\\n\\n\\n=\\n3\\n\\n\\n{\\displaystyle a_{0}=3}\\n\\n then \\n\\n\\n\\n\\na\\n\\nN\\n\\n\\n=\\n6\\n\\n\\n{\\displaystyle a_{N}=6}\\n\\n. \\n\\n\\n\\n\\nb\\n\\nN\\n\\n\\n=\\n(\\n2\\nN\\n−\\n1\\n\\n)\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle b_{N}=(2N-1)^{2}}\\n\\n.\\n\\n(The source text for these examples can also be found on Bitbucket.)\\nGeneric function for estimating continued fractions:\\nTest program using the function above to estimate the square root of 2, Napiers constant and pi:\\nThis example is exactly the same as the preceding one, but implemented using only Ada 95 features.\\n","from decimal import Decimal, getcontext\\n\\ndef calc(fun, n):\\n    temp = Decimal(\""0.0\"")\\n\\n    for ni in xrange(n+1, 0, -1):\\n        (a, b) = fun(ni)\\n        temp = Decimal(b) / (a + temp)\\n\\n    return fun(0)[0] + temp\\n\\ndef fsqrt2(n):\\n    return (2 if n > 0 else 1, 1)\\n\\ndef fnapier(n):\\n    return (n if n > 0 else 2, (n - 1) if n > 1 else 1)\\n\\ndef fpi(n):\\n    return (6 if n > 0 else 3, (2 * n - 1) ** 2)\\n\\ngetcontext().prec = 50\\nprint calc(fsqrt2, 200)\\nprint calc(fnapier, 200)\\nprint calc(fpi, 200)"
"Python","Continued_fraction/Arithmetic/Construct_from_rational_number","The purpose of this task is to write a function \\n\\n\\n\\n\\n\\nr\\n2\\nc\\nf\\n\\n\\n(\\n\\ni\\nn\\nt\\n\\n\\n\\n{\\displaystyle {\\mathit {r2cf}}(\\mathrm {int} }\\n\\n \\n\\n\\n\\n\\nN\\n\\n1\\n\\n\\n,\\n\\ni\\nn\\nt\\n\\n\\n\\n{\\displaystyle N_{1},\\mathrm {int} }\\n\\n \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n)\\n\\n\\n{\\displaystyle N_{2})}\\n\\n, or \\n\\n\\n\\n\\n\\nr\\n2\\nc\\nf\\n\\n\\n(\\n\\nF\\nr\\na\\nc\\nt\\ni\\no\\nn\\n\\n\\n\\n{\\displaystyle {\\mathit {r2cf}}(\\mathrm {Fraction} }\\n\\n \\n\\n\\n\\nN\\n)\\n\\n\\n{\\displaystyle N)}\\n\\n, which will output a continued fraction assuming:\\nThe function should output its results one digit at a time each time it is called, in a manner sometimes described as lazy evaluation.\\nTo achieve this it must determine: the integer part; and remainder part, of \\n\\n\\n\\n\\nN\\n\\n1\\n\\n\\n\\n\\n{\\displaystyle N_{1}}\\n\\n divided by \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle N_{2}}\\n\\n. It then sets \\n\\n\\n\\n\\nN\\n\\n1\\n\\n\\n\\n\\n{\\displaystyle N_{1}}\\n\\n to \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle N_{2}}\\n\\n and \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle N_{2}}\\n\\n to the determined remainder part. It then outputs the determined integer part. It does this until \\n\\n\\n\\n\\na\\nb\\ns\\n\\n(\\n\\nN\\n\\n2\\n\\n\\n)\\n\\n\\n{\\displaystyle \\mathrm {abs} (N_{2})}\\n\\n is zero.\\nDemonstrate the function by outputing the continued fraction for:\\n\\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n should approach \\n\\n\\n\\n[\\n1\\n;\\n2\\n,\\n2\\n,\\n2\\n,\\n2\\n,\\n…\\n]\\n\\n\\n{\\displaystyle [1;2,2,2,2,\\ldots ]}\\n\\n try ever closer rational approximations until boredom gets the better of you:\\nTry :\\nObserve how this rational number behaves differently to \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n and convince yourself that, in the same way as \\n\\n\\n\\n3.7\\n\\n\\n{\\displaystyle 3.7}\\n\\n may be represented as \\n\\n\\n\\n3.70\\n\\n\\n{\\displaystyle 3.70}\\n\\n when an extra decimal place is required, \\n\\n\\n\\n[\\n3\\n;\\n7\\n]\\n\\n\\n{\\displaystyle [3;7]}\\n\\n may be represented as \\n\\n\\n\\n[\\n3\\n;\\n7\\n,\\n∞\\n]\\n\\n\\n{\\displaystyle [3;7,\\infty ]}\\n\\n when an extra term is required.\\nC does not implement Lazy evaluation and it is this particular feature which is the real challenge of this particular example. It can however be simulated. The following example uses pointers. It seems that the same data is being passed but since the function accepts pointers, the variables are being changed. One other way to simulate laziness would be to use global variables. Then although it would seem that the same values are being passed even as constants, the job is actually getting done. In my view, that would be plain cheating.\\nAnd the run gives :\\n","def r2cf(n1,n2):\\n  while n2:\\n    n1, (t1, n2) = n2, divmod(n1, n2)\\n    yield t1\\n\\nprint(list(r2cf(1,2)))    # => [0, 2]\\nprint(list(r2cf(3,1)))    # => [3]\\nprint(list(r2cf(23,8)))    # => [2, 1, 7]\\nprint(list(r2cf(13,11)))    # => [1, 5, 2]\\nprint(list(r2cf(22,7)))    # => [3, 7]\\nprint(list(r2cf(14142,10000)))    # => [1, 2, 2, 2, 2, 2, 1, 1, 29]\\nprint(list(r2cf(141421,100000)))    # => [1, 2, 2, 2, 2, 2, 2, 3, 1, 1, 3, 1, 7, 2]\\nprint(list(r2cf(1414214,1000000)))    # => [1, 2, 2, 2, 2, 2, 2, 2, 3, 6, 1, 2, 1, 12]\\nprint(list(r2cf(14142136,10000000)))    # => [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 1, 2, 4, 1, 1, 2]"
"Python","Continued_fraction/Arithmetic/Construct_from_rational_number","The purpose of this task is to write a function \\n\\n\\n\\n\\n\\nr\\n2\\nc\\nf\\n\\n\\n(\\n\\ni\\nn\\nt\\n\\n\\n\\n{\\displaystyle {\\mathit {r2cf}}(\\mathrm {int} }\\n\\n \\n\\n\\n\\n\\nN\\n\\n1\\n\\n\\n,\\n\\ni\\nn\\nt\\n\\n\\n\\n{\\displaystyle N_{1},\\mathrm {int} }\\n\\n \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n)\\n\\n\\n{\\displaystyle N_{2})}\\n\\n, or \\n\\n\\n\\n\\n\\nr\\n2\\nc\\nf\\n\\n\\n(\\n\\nF\\nr\\na\\nc\\nt\\ni\\no\\nn\\n\\n\\n\\n{\\displaystyle {\\mathit {r2cf}}(\\mathrm {Fraction} }\\n\\n \\n\\n\\n\\nN\\n)\\n\\n\\n{\\displaystyle N)}\\n\\n, which will output a continued fraction assuming:\\nThe function should output its results one digit at a time each time it is called, in a manner sometimes described as lazy evaluation.\\nTo achieve this it must determine: the integer part; and remainder part, of \\n\\n\\n\\n\\nN\\n\\n1\\n\\n\\n\\n\\n{\\displaystyle N_{1}}\\n\\n divided by \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle N_{2}}\\n\\n. It then sets \\n\\n\\n\\n\\nN\\n\\n1\\n\\n\\n\\n\\n{\\displaystyle N_{1}}\\n\\n to \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle N_{2}}\\n\\n and \\n\\n\\n\\n\\nN\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle N_{2}}\\n\\n to the determined remainder part. It then outputs the determined integer part. It does this until \\n\\n\\n\\n\\na\\nb\\ns\\n\\n(\\n\\nN\\n\\n2\\n\\n\\n)\\n\\n\\n{\\displaystyle \\mathrm {abs} (N_{2})}\\n\\n is zero.\\nDemonstrate the function by outputing the continued fraction for:\\n\\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n should approach \\n\\n\\n\\n[\\n1\\n;\\n2\\n,\\n2\\n,\\n2\\n,\\n2\\n,\\n…\\n]\\n\\n\\n{\\displaystyle [1;2,2,2,2,\\ldots ]}\\n\\n try ever closer rational approximations until boredom gets the better of you:\\nTry :\\nObserve how this rational number behaves differently to \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n and convince yourself that, in the same way as \\n\\n\\n\\n3.7\\n\\n\\n{\\displaystyle 3.7}\\n\\n may be represented as \\n\\n\\n\\n3.70\\n\\n\\n{\\displaystyle 3.70}\\n\\n when an extra decimal place is required, \\n\\n\\n\\n[\\n3\\n;\\n7\\n]\\n\\n\\n{\\displaystyle [3;7]}\\n\\n may be represented as \\n\\n\\n\\n[\\n3\\n;\\n7\\n,\\n∞\\n]\\n\\n\\n{\\displaystyle [3;7,\\infty ]}\\n\\n when an extra term is required.\\nC does not implement Lazy evaluation and it is this particular feature which is the real challenge of this particular example. It can however be simulated. The following example uses pointers. It seems that the same data is being passed but since the function accepts pointers, the variables are being changed. One other way to simulate laziness would be to use global variables. Then although it would seem that the same values are being passed even as constants, the job is actually getting done. In my view, that would be plain cheating.\\nAnd the run gives :\\n","def real2cf(x):\\n    while True:\\n        t1, f = divmod(x, 1)\\n        yield int(t1)\\n        if not f:\\n            break\\n        x = 1/f\\n\\nfrom fractions import Fraction\\nfrom itertools import islice\\n\\nprint(list(real2cf(Fraction(13, 11))))    # => [1, 5, 2]\\nprint(list(islice(real2cf(2 ** 0.5), 20)))    # => [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]"
"Python","Continued_fraction/Arithmetic/G(matrix_NG,_Contined_Fraction_N)","This task investigates mathmatical operations that can be performed on a single continued fraction. This requires only a baby version of NG:\\nI may perform perform the following operations:\\nI output a term if the integer parts of \\n\\n\\n\\n\\n\\na\\nb\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a}{b}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{1}}{b_{1}}}}\\n\\n are equal. Otherwise I input a term from N. If I need a term from N but N has no more terms I inject \\n\\n\\n\\n∞\\n\\n\\n{\\displaystyle \\infty }\\n\\n.\\nWhen I input a term t my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\na\\n+\\n\\na\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\n\\nb\\n+\\n\\nb\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a+a_{1}*t&a_{1}\\\\b+b_{1}*t&b_{1}\\end{bmatrix}}}\\n\\n\\nWhen I output a term t my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n−\\n\\nb\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\na\\n−\\nb\\n∗\\nt\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}b_{1}&b\\\\a_{1}-b_{1}*t&a-b*t\\end{bmatrix}}}\\n\\n\\nWhen I need a term t but there are no more my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a_{1}\\\\b_{1}&b_{1}\\end{bmatrix}}}\\n\\n\\nI am done when b1 and b are zero.\\nDemonstrate your solution by calculating:\\nUsing a generator for \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n (e.g., from Continued fraction) calculate \\n\\n\\n\\n\\n\\n1\\n\\n2\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {1}{\\sqrt {2}}}}\\n\\n. You are now at the starting line for using Continued Fractions to implement Arithmetic-geometric mean without ulps and epsilons.\\nThe first step in implementing Arithmetic-geometric mean is to calculate \\n\\n\\n\\n\\n\\n\\n1\\n+\\n\\n\\n1\\n\\n2\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\frac {1+{\\frac {1}{\\sqrt {2}}}}{2}}}\\n\\n do this now to cross the starting line and begin the race.\\n","class NG:\\n  def __init__(self, a1, a, b1, b):\\n    self.a1, self.a, self.b1, self.b = a1, a, b1, b\\n\\n  def ingress(self, n):\\n    self.a, self.a1 = self.a1, self.a + self.a1 * n\\n    self.b, self.b1 = self.b1, self.b + self.b1 * n\\n\\n  @property\\n  def needterm(self):\\n    return (self.b == 0 or self.b1 == 0) or not self.a//self.b == self.a1//self.b1\\n\\n  @property\\n  def egress(self):\\n    n = self.a // self.b\\n    self.a,  self.b  = self.b,  self.a  - self.b  * n\\n    self.a1, self.b1 = self.b1, self.a1 - self.b1 * n\\n    return n\\n\\n  @property\\n  def egress_done(self):\\n    if self.needterm: self.a, self.b = self.a1, self.b1\\n    return self.egress\\n\\n  @property\\n  def done(self):\\n    return self.b == 0 and self.b1 == 0"
"Python","Continued_fraction/Arithmetic/G(matrix_NG,_Contined_Fraction_N)","This task investigates mathmatical operations that can be performed on a single continued fraction. This requires only a baby version of NG:\\nI may perform perform the following operations:\\nI output a term if the integer parts of \\n\\n\\n\\n\\n\\na\\nb\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a}{b}}}\\n\\n and \\n\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {a_{1}}{b_{1}}}}\\n\\n are equal. Otherwise I input a term from N. If I need a term from N but N has no more terms I inject \\n\\n\\n\\n∞\\n\\n\\n{\\displaystyle \\infty }\\n\\n.\\nWhen I input a term t my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\na\\n+\\n\\na\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\n\\nb\\n+\\n\\nb\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a+a_{1}*t&a_{1}\\\\b+b_{1}*t&b_{1}\\end{bmatrix}}}\\n\\n\\nWhen I output a term t my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n−\\n\\nb\\n\\n1\\n\\n\\n∗\\nt\\n\\n\\na\\n−\\nb\\n∗\\nt\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}b_{1}&b\\\\a_{1}-b_{1}*t&a-b*t\\end{bmatrix}}}\\n\\n\\nWhen I need a term t but there are no more my internal state: \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\na\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\nb\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a\\\\b_{1}&b\\end{bmatrix}}}\\n\\n is transposed thus \\n\\n\\n\\n\\n\\n[\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\na\\n\\n1\\n\\n\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\nb\\n\\n1\\n\\n\\n\\n\\n\\n]\\n\\n\\n\\n\\n{\\displaystyle {\\begin{bmatrix}a_{1}&a_{1}\\\\b_{1}&b_{1}\\end{bmatrix}}}\\n\\n\\nI am done when b1 and b are zero.\\nDemonstrate your solution by calculating:\\nUsing a generator for \\n\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\sqrt {2}}}\\n\\n (e.g., from Continued fraction) calculate \\n\\n\\n\\n\\n\\n1\\n\\n2\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {1}{\\sqrt {2}}}}\\n\\n. You are now at the starting line for using Continued Fractions to implement Arithmetic-geometric mean without ulps and epsilons.\\nThe first step in implementing Arithmetic-geometric mean is to calculate \\n\\n\\n\\n\\n\\n\\n1\\n+\\n\\n\\n1\\n\\n2\\n\\n\\n\\n\\n2\\n\\n\\n\\n\\n{\\displaystyle {\\frac {1+{\\frac {1}{\\sqrt {2}}}}{2}}}\\n\\n do this now to cross the starting line and begin the race.\\n","data = [[\""[1;5,2] + 1/2\"",      [2,1,0,2], [13,11]],\\n        [\""[3;7] + 1/2\"",        [2,1,0,2], [22, 7]],\\n        [\""[3;7] divided by 4\"", [1,0,0,4], [22, 7]]]\\n\\nfor string, ng, r in data:\\n  print( \""%-20s->\"" % string, end='' )\\n  op = NG(*ng)\\n  for n in r2cf(*r):\\n    if not op.needterm: print( \"" %r\"" % op.egress, end='' )\\n    op.ingress(n)\\n  while True:\\n    print( \"" %r\"" % op.egress_done, end='' )\\n    if op.done: break\\n  print()"
"Python","Convert_decimal_number_to_rational","\\nThe task is to write a program to transform a decimal number into a fraction in lowest terms.\\nIt is not always possible to do this exactly. For instance, while rational numbers can be converted to decimal representation, some of them need an infinite number of digits to be represented exactly in decimal form. Namely, repeating decimals such as 1/3 = 0.333...\\nBecause of this, the following fractions cannot be obtained (reliably) unless the language has some way of representing repeating decimals:\\nAcceptable output:\\nFinite decimals are of course no problem:\\n\\nSpecification of a procedure Real_To_Rational, which is searching for the best approximation of a real number. The procedure is generic. I.e., you can instantiate it by your favorite \""Real\"" type (Float, Long_Float, ...).\\nThe implementation (just brute-force search for the best approximation with Denominator less or equal Bound):\\nThe main program, called \""Convert_Decimal_To_Rational\"", reads reals from the standard input until 0.0. It outputs progressively better rational approximations of the reals, where \""progressively better\"" means a larger Bound for the Denominator:\\nFinally, the output (reading the input from a file):\\n",">>> from fractions import Fraction\\n>>> for d in (0.9054054, 0.518518, 0.75): print(d, Fraction.from_float(d).limit_denominator(100))\\n\\n0.9054054 67/74\\n0.518518 14/27\\n0.75 3/4\\n>>> for d in '0.9054054 0.518518 0.75'.split(): print(d, Fraction(d))\\n\\n0.9054054 4527027/5000000\\n0.518518 259259/500000\\n0.75 3/4\\n>>> "
"Python","Convert_decimal_number_to_rational","\\nThe task is to write a program to transform a decimal number into a fraction in lowest terms.\\nIt is not always possible to do this exactly. For instance, while rational numbers can be converted to decimal representation, some of them need an infinite number of digits to be represented exactly in decimal form. Namely, repeating decimals such as 1/3 = 0.333...\\nBecause of this, the following fractions cannot be obtained (reliably) unless the language has some way of representing repeating decimals:\\nAcceptable output:\\nFinite decimals are of course no problem:\\n\\nSpecification of a procedure Real_To_Rational, which is searching for the best approximation of a real number. The procedure is generic. I.e., you can instantiate it by your favorite \""Real\"" type (Float, Long_Float, ...).\\nThe implementation (just brute-force search for the best approximation with Denominator less or equal Bound):\\nThe main program, called \""Convert_Decimal_To_Rational\"", reads reals from the standard input until 0.0. It outputs progressively better rational approximations of the reals, where \""progressively better\"" means a larger Bound for the Denominator:\\nFinally, the output (reading the input from a file):\\n","from math import (floor)\\n\\n\\n# main :: IO ()\\ndef main():\\n    # Using a tolerance epsilon of 1/1000\\n    for r in map(\\n        compose(showRatio)(approxRatio(0.0001)),\\n        [0.9054054, 0.518518, 0.75]\\n    ):\\n        print(r)\\n\\n\\n# approxRatio :: Real -> Real -> Ratio\\ndef approxRatio(epsilon):\\n    def gcde(e, x, y):\\n        def _gcd(a, b): return a if b < e else _gcd(b, a % b)\\n        return _gcd(abs(x), abs(y))\\n    return lambda n: (lambda c=(\\n        gcde(epsilon if 0 < epsilon else (0.0001), 1, n)\\n    ): Ratio(floor(n / c))(floor(1 / c)))()\\n\\n\\n# Ratio :: Int -> Int -> Ratio\\ndef Ratio(n):\\n    return lambda d: {'type': 'Ratio', 'n': n, 'd': d}\\n\\n\\n# showRatio :: Ratio -> String\\ndef showRatio(r):\\n    return (str(r['n'])) + '/' + (str(r['d']))\\n\\n\\n# compose (<<<) :: (b -> c) -> (a -> b) -> a -> c\\ndef compose(g):\\n    return lambda f: lambda x: g(f(x))\\n\\n\\nmain()"
"Python","Convert_seconds_to_compound_duration","Write a function or program which:\\n\\nDemonstrate that it passes the following three test-cases:\\nTest CasesDetails\\n",">>> def duration(seconds):\\n	t= []\\n	for dm in (60, 60, 24, 7):\\n		seconds, m = divmod(seconds, dm)\\n		t.append(m)\\n	t.append(seconds)\\n	return ', '.join('%d %s' % (num, unit)\\n			 for num, unit in zip(t[::-1], 'wk d hr min sec'.split())\\n			 if num)\\n\\n>>> for seconds in [7259, 86400, 6000000]:\\n	print(\""%7d sec = %s\"" % (seconds, duration(seconds)))\\n\\n	\\n   7259 sec = 2 hr, 59 sec\\n  86400 sec = 1 d\\n6000000 sec = 9 wk, 6 d, 10 hr, 40 min\\n>>> "
"Python","Convert_seconds_to_compound_duration","Write a function or program which:\\n\\nDemonstrate that it passes the following three test-cases:\\nTest CasesDetails\\n",">>> def duration(seconds, _maxweeks=99999999999):\\n    return ', '.join('%d %s' % (num, unit)\\n		     for num, unit in zip([(seconds // d) % m\\n					   for d, m in ((604800, _maxweeks), \\n                                                        (86400, 7), (3600, 24), \\n                                                        (60, 60), (1, 60))],\\n					  ['wk', 'd', 'hr', 'min', 'sec'])\\n		     if num)\\n\\n>>> for seconds in [7259, 86400, 6000000]:\\n	print(\""%7d sec = %s\"" % (seconds, duration(seconds)))\\n\\n	\\n   7259 sec = 2 hr, 59 sec\\n  86400 sec = 1 d\\n6000000 sec = 9 wk, 6 d, 10 hr, 40 min\\n>>> "
"Python","Convex_hull","Find the points which form a convex hull from a set of arbitrary two dimensional points.\\nFor example, given the points (16,3), (12,17), (0,6), (-4,-6), (16,6), (16,-7), (16,-3), (17,-4), (5,19), (19,-8), (3,16), (12,13), (3,-4), (17,5), (-3,15), (-3,-9), (0,11), (-9,-3), (-4,-2) and (12,10) the convex hull would be (-9,-3), (-3,-9), (19,-8), (17,5), (12,17), (5,19) and (-3,15).\\n\\n\\n","from __future__ import print_function\\nfrom shapely.geometry import MultiPoint\\n\\nif __name__==\""__main__\"":\\n	pts = MultiPoint([(16,3), (12,17), (0,6), (-4,-6), (16,6), (16,-7), (16,-3), (17,-4), (5,19), (19,-8), (3,16), (12,13), (3,-4), (17,5), (-3,15), (-3,-9), (0,11), (-9,-3), (-4,-2), (12,10)])\\n	print (pts.convex_hull)"
"Python","Conway's_Game_of_Life","The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.\\nConway's game of life is described   here:\\nA cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.\\nWe calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:\\nAssume cells beyond the boundary are always dead.\\nThe \""game\"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.\\n\\nAlthough you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.\\n\\n\\n\\n","import random\\nfrom collections import defaultdict\\n\\nprintdead, printlive = '-#'\\nmaxgenerations = 3\\ncellcount = 3,3\\ncelltable = defaultdict(int, {\\n (1, 2): 1,\\n (1, 3): 1,\\n (0, 3): 1,\\n } ) # Only need to populate with the keys leading to life\\n\\n##\\n## Start States\\n##\\n# blinker\\nu = universe = defaultdict(int)\\nu[(1,0)], u[(1,1)], u[(1,2)] = 1,1,1\\n\\n## toad\\n#u = universe = defaultdict(int)\\n#u[(5,5)], u[(5,6)], u[(5,7)] = 1,1,1\\n#u[(6,6)], u[(6,7)], u[(6,8)] = 1,1,1\\n\\n## glider\\n#u = universe = defaultdict(int)\\n#maxgenerations = 16\\n#u[(5,5)], u[(5,6)], u[(5,7)] = 1,1,1\\n#u[(6,5)] = 1\\n#u[(7,6)] = 1\\n\\n## random start\\n#universe = defaultdict(int, \\n#                       # array of random start values\\n#                       ( ((row, col), random.choice((0,1)))\\n#                         for col in range(cellcount[0])\\n#                         for row in range(cellcount[1])\\n#                       ) )  # returns 0 for out of bounds\\n\\nfor i in range(maxgenerations):\\n    print \""\\nGeneration %3i:\"" % ( i, )\\n    for row in range(cellcount[1]):\\n        print \""  \"", ''.join(str(universe[(row,col)])\\n                            for col in range(cellcount[0])).replace(\\n                                '0', printdead).replace('1', printlive)\\n    nextgeneration = defaultdict(int)\\n    for row in range(cellcount[1]):\\n        for col in range(cellcount[0]):\\n            nextgeneration[(row,col)] = celltable[\\n                ( universe[(row,col)],\\n                  -universe[(row,col)] + sum(universe[(r,c)]\\n                                             for r in range(row-1,row+2)\\n                                             for c in range(col-1, col+2) )\\n                ) ]\\n    universe = nextgeneration"
"Python","Conway's_Game_of_Life","The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.\\nConway's game of life is described   here:\\nA cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.\\nWe calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:\\nAssume cells beyond the boundary are always dead.\\nThe \""game\"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.\\n\\nAlthough you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.\\n\\n\\n\\n","from collections import Counter\\n\\ndef life(world, N):\\n    \""Play Conway's game of life for N generations from initial world.\""\\n    for g in range(N+1):\\n        display(world, g)\\n        counts = Counter(n for c in world for n in offset(neighboring_cells, c))\\n        world = {c for c in counts \\n                if counts[c] == 3 or (counts[c] == 2 and c in world)}\\n\\nneighboring_cells = [(-1, -1), (-1, 0), (-1, 1), \\n                     ( 0, -1),          ( 0, 1), \\n                     ( 1, -1), ( 1, 0), ( 1, 1)]\\n\\ndef offset(cells, delta):\\n    \""Slide/offset all the cells by delta, a (dx, dy) vector.\""\\n    (dx, dy) = delta\\n    return {(x+dx, y+dy) for (x, y) in cells}\\n\\ndef display(world, g):\\n    \""Display the world as a grid of characters.\""\\n    print '          GENERATION {}:'.format(g)\\n    Xs, Ys = zip(*world)\\n    Xrange = range(min(Xs), max(Xs)+1)\\n    for y in range(min(Ys), max(Ys)+1):\\n        print ''.join('#' if (x, y) in world else '.'\\n                      for x in Xrange)\\n\\nblinker = {(1, 0), (1, 1), (1, 2)}\\nblock   = {(0, 0), (1, 1), (0, 1), (1, 0)}\\ntoad    = {(1, 2), (0, 1), (0, 0), (0, 2), (1, 3), (1, 1)}\\nglider  = {(0, 1), (1, 0), (0, 0), (0, 2), (2, 1)}\\nworld   = (block | offset(blinker, (5, 2)) | offset(glider, (15, 5)) | offset(toad, (25, 5))\\n           | {(18, 2), (19, 2), (20, 2), (21, 2)} | offset(block, (35, 7)))\\n\\n\\nlife(world, 5)"
"Python","Conway's_Game_of_Life","The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.\\nConway's game of life is described   here:\\nA cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.\\nWe calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:\\nAssume cells beyond the boundary are always dead.\\nThe \""game\"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.\\n\\nAlthough you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.\\n\\n\\n\\n","import numpy as np\\nfrom pandas import DataFrame\\nimport matplotlib.pyplot as plt\\n#import time\\n\\ndef conway_life(len=10, wid=10, gen=5):\\n     \\n    curr_gen = DataFrame(np.random.randint(0, 2, (len+2, wid+2)),\\n                         index = range(len+2), \\n                         columns = range(wid+2))\\n    curr_gen[0] = 0\\n    curr_gen[wid+1] = 0\\n    curr_gen[0: 1] = 0\\n    curr_gen[len+1: len+2] = 0    \\n    \\n    for i in range(gen):\\n        \\n        fig, ax = plt.subplots()\\n        draw = curr_gen[1:len+1].drop([0, wid+1], axis=1)\\n        # 画图\\n        \\n        image = draw\\n        ax.imshow(image, cmap=plt.cm.cool, interpolation='nearest')\\n        ax.set_title(\""Conway's game of life.\"")\\n        \\n        # Move left and bottom spines outward by 10 points\\n        ax.spines['left'].set_position(('outward', 10))\\n        ax.spines['bottom'].set_position(('outward', 10))\\n        # Hide the right and top spines\\n        ax.spines['right'].set_visible(False)\\n        ax.spines['top'].set_visible(False)\\n        # Only show ticks on the left and bottom spines\\n        ax.yaxis.set_ticks_position('left')\\n        ax.xaxis.set_ticks_position('bottom')\\n\\n        plt.show()\\n        # time.sleep(1)         \\n        \\n        \\n        # 初始化空表\\n        next_gen = DataFrame(np.random.randint(0, 1, (len+2, wid+2)),\\n                             index = range(len+2), \\n                             columns = range(wid+2))\\n        \\n        \\n        # 生成下一代\\n        for x in range(1, wid+1):\\n            for y in range(1, len+1):\\n                env = (curr_gen[x-1][y-1] + curr_gen[x][y-1] + \\n                       curr_gen[x+1][y-1]+ curr_gen[x-1][y] + \\n                       curr_gen[x+1][y] + curr_gen[x-1][y+1] + \\n                       curr_gen[x][y+1] + curr_gen[x+1][y+1])\\n            \\n                if (not curr_gen[x][y] and env == 3):\\n                    next_gen[x][y] = 1\\n                if (curr_gen[x][y] and env in (2, 3)):\\n                    next_gen[x][y] = 1\\n                \\n        curr_gen = next_gen \\n         \\n\\nconway_life()"
"Python","Copy_a_string","This task is about copying a string.\\n\\nWhere it is relevant, distinguish between copying the contents of a string\\nversus making an additional reference to an existing string.\\n\\nTo copy a string, we use an MVC (Move Character). To make a reference to a string, we use a LA (Load Address).\\nStrings are immutable in ActionScript, and can safely be assigned with the assignment operator, much as they can in Java.[1]\\nAda provides three different kinds of strings.\\nThe String type is a fixed length string.\\nThe Bounded_String type is a string with variable length up to a specified maximum size.\\nThe Unbounded_String type is a variable length string with no specified maximum size.\\nThe Bounded_String type behaves a lot like C strings, while the Unbounded_String type behaves a lot like the C++ String class.\\nAda provides the ability to manipulate slices of strings.\\nAda Bounded_String type provides a number of functions for dealing with slices.\\nThe intrinsic text type is immediate, immutable\\nand cannot be referred more than once.\\nCopying an intrinsic string:\\nData of the non intrinsic byte array type can be referred more than once.\\nCopying a binary array of bytes:\\nIn ALGOL 68 strings are simply flexible length arrays of CHAR;\\n",">>> src = \""hello\""\\n>>> a = src\\n>>> b = src[:]\\n>>> import copy\\n>>> c = copy.copy(src)\\n>>> d = copy.deepcopy(src)\\n>>> src is a is b is c is d\\nTrue"
"Python","Copy_a_string","This task is about copying a string.\\n\\nWhere it is relevant, distinguish between copying the contents of a string\\nversus making an additional reference to an existing string.\\n\\nTo copy a string, we use an MVC (Move Character). To make a reference to a string, we use a LA (Load Address).\\nStrings are immutable in ActionScript, and can safely be assigned with the assignment operator, much as they can in Java.[1]\\nAda provides three different kinds of strings.\\nThe String type is a fixed length string.\\nThe Bounded_String type is a string with variable length up to a specified maximum size.\\nThe Unbounded_String type is a variable length string with no specified maximum size.\\nThe Bounded_String type behaves a lot like C strings, while the Unbounded_String type behaves a lot like the C++ String class.\\nAda provides the ability to manipulate slices of strings.\\nAda Bounded_String type provides a number of functions for dealing with slices.\\nThe intrinsic text type is immediate, immutable\\nand cannot be referred more than once.\\nCopying an intrinsic string:\\nData of the non intrinsic byte array type can be referred more than once.\\nCopying a binary array of bytes:\\nIn ALGOL 68 strings are simply flexible length arrays of CHAR;\\n",">>> a = 'hello'\\n>>> b = ''.join(a)\\n>>> a == b\\nTrue\\n>>> b is a  ### Might be True ... depends on \""interning\"" implementation details!\\nFalse"
"Python","Count_in_factors","Write a program which counts up from   1,   displaying each number as the multiplication of its prime factors.\\nFor the purpose of this task,   1   (unity)   may be shown as itself.\\n\\n      2   is prime,   so it would be shown as itself.\\n      6   is not prime;   it would be shown as   \\n\\n\\n\\n2\\n×\\n3\\n\\n\\n{\\displaystyle 2\\times 3}\\n\\n.\\n2144   is not prime;   it would be shown as   \\n\\n\\n\\n2\\n×\\n2\\n×\\n2\\n×\\n2\\n×\\n2\\n×\\n67\\n\\n\\n{\\displaystyle 2\\times 2\\times 2\\times 2\\times 2\\times 67}\\n\\n.\\n\\n\\n","from functools import lru_cache\\n\\nprimes = [2, 3, 5, 7, 11, 13, 17]    # Will be extended\\n\\n@lru_cache(maxsize=2000)\\ndef pfactor(n):\\n    if n == 1:\\n        return [1]\\n    n2 = n // 2 + 1\\n    for p in primes:\\n        if p <= n2:\\n            d, m = divmod(n, p)\\n            if m == 0:\\n                if d > 1:\\n                    return [p] + pfactor(d)\\n                else:\\n                    return [p]\\n        else:\\n            if n > primes[-1]:\\n                primes.append(n)\\n            return [n]\\n        \\nif __name__ == '__main__':\\n    mx = 5000\\n    for n in range(1, mx + 1):\\n        factors = pfactor(n)\\n        if n <= 10 or n >= mx - 20:\\n            print( '%4i %5s %s' % (n,\\n                                   '' if factors != [n] or n == 1 else 'prime',\\n                                   'x'.join(str(i) for i in factors)) )\\n        if n == 11:\\n            print('...')\\n            \\n    print('\\nNumber of primes gathered up to', n, 'is', len(primes))\\n    print(pfactor.cache_info())"
"Python","Count_in_octal","Produce a sequential count in octal,   starting at zero,   and using an increment of a one for each consecutive number.\\nEach number should appear on a single line,   and the program should count until terminated,   or until the maximum value of the numeric type in use is reached.\\n\\n\\nThe program uses one ASSIST macro (XPRNT) to keep the code as short as possible.\\n","import sys\\nfor n in xrange(sys.maxint):\\n    print oct(n)"
"Python","Count_occurrences_of_a_substring","Create a function,   or show a built-in function,   to count the number of non-overlapping occurrences of a substring inside a string.\\nThe function should take two arguments:\\n\\nIt should return an integer count.\\nThe matching should yield the highest number of non-overlapping matches.\\nIn general, this essentially means matching from left-to-right or right-to-left   (see proof on talk page).\\n\\nMetrics: length\\nSub-string search: Count occurrences of a substring\\nMulti-string operations: LCP, LCS, concatenation\\nManipulation: reverse, lower- and uppercase\\n\\nThe program uses two ASSIST macros (XDECO,XPRNT) to keep the code as short as possible.\\n",">>> \""the three truths\"".count(\""th\"")\\n3\\n>>> \""ababababab\"".count(\""abab\"")\\n2"
"Python","Count_the_coins","There are four types of common coins in   US   currency:\\n\\nThere are six ways to make change for 15 cents:\\n\\nHow many ways are there to make change for a dollar using these common coins?     (1 dollar = 100 cents).\\n\\nLess common are dollar coins (100 cents);   and very rare are half dollars (50 cents).   With the addition of these two coins, how many ways are there to make change for $1000?\\n(Note:   the answer is larger than   232).\\n\\n\\n","def changes(amount, coins):\\n    ways = [0] * (amount + 1)\\n    ways[0] = 1\\n    for coin in coins:\\n        for j in xrange(coin, amount + 1):\\n            ways[j] += ways[j - coin]\\n    return ways[amount]\\n\\nprint changes(100, [1, 5, 10, 25])\\nprint changes(100000, [1, 5, 10, 25, 50, 100])"
"Python","Count_the_coins","There are four types of common coins in   US   currency:\\n\\nThere are six ways to make change for 15 cents:\\n\\nHow many ways are there to make change for a dollar using these common coins?     (1 dollar = 100 cents).\\n\\nLess common are dollar coins (100 cents);   and very rare are half dollars (50 cents).   With the addition of these two coins, how many ways are there to make change for $1000?\\n(Note:   the answer is larger than   232).\\n\\n\\n","try:\\n    import psyco\\n    psyco.full()\\nexcept ImportError:\\n    pass\\n\\ndef count_changes(amount_cents, coins):\\n    n = len(coins)\\n    # max([]) instead of max() for Psyco\\n    cycle = max([c+1 for c in coins if c <= amount_cents]) * n\\n    table = [0] * cycle\\n    for i in xrange(n):\\n        table[i] = 1\\n\\n    pos = n\\n    for s in xrange(1, amount_cents + 1):\\n        for i in xrange(n):\\n            if i == 0 and pos >= cycle:\\n                pos = 0\\n            if coins[i] <= s:\\n                q = pos - coins[i] * n\\n                table[pos]= table[q] if (q >= 0) else table[q + cycle]\\n            if i:\\n                table[pos] += table[pos - 1]\\n            pos += 1\\n    return table[pos - 1]\\n\\ndef main():\\n    us_coins = [100, 50, 25, 10, 5, 1]\\n    eu_coins = [200, 100, 50, 20, 10, 5, 2, 1]\\n\\n    for coins in (us_coins, eu_coins):\\n        print count_changes(     100, coins[2:])\\n        print count_changes(  100000, coins)\\n        print count_changes( 1000000, coins)\\n        print count_changes(10000000, coins), \""\\n\""\\n\\nmain()"
"Python","Cramer's_rule","\\nGiven\\n\\n","\\n# a simple implementation using numpy\\nfrom numpy import linalg\\n\\nA=[[2,-1,5,1],[3,2,2,-6],[1,3,3,-1],[5,-2,-3,3]]\\nB=[-3,-32,-47,49]\\nC=[[2,-1,5,1],[3,2,2,-6],[1,3,3,-1],[5,-2,-3,3]]\\nX=[]\\nfor i in range(0,len(B)):\\n    for j in range(0,len(B)):\\n        C[j][i]=B[j]\\n        if i>0:\\n            C[j][i-1]=A[j][i-1]\\n    X.append(round(linalg.det(C)/linalg.det(A),1))\\n\\nprint('w=%s'%X[0],'x=%s'%X[1],'y=%s'%X[2],'z=%s'%X[3])\\n"
"Python","CRC-32","\\nDemonstrate a method of deriving the Cyclic Redundancy Check from within the language.\\n\\nThe result should be in accordance with ISO 3309, ITU-T V.42, Gzip and PNG.\\nAlgorithms are described on Computation of CRC in Wikipedia.\\nThis variant of CRC-32 uses LSB-first order, sets the initial CRC to FFFFFFFF16, and complements the final CRC.\\nFor the purpose of this task, generate a CRC-32 checksum for the ASCII encoded string:\\n\\n",">>> s = 'The quick brown fox jumps over the lazy dog'\\n>>> import zlib\\n>>> hex(zlib.crc32(s))\\n'0x414fa339'\\n\\n>>> import binascii\\n>>> hex(binascii.crc32(s))\\n'0x414fa339'"
"Python","CRC-32","\\nDemonstrate a method of deriving the Cyclic Redundancy Check from within the language.\\n\\nThe result should be in accordance with ISO 3309, ITU-T V.42, Gzip and PNG.\\nAlgorithms are described on Computation of CRC in Wikipedia.\\nThis variant of CRC-32 uses LSB-first order, sets the initial CRC to FFFFFFFF16, and complements the final CRC.\\nFor the purpose of this task, generate a CRC-32 checksum for the ASCII encoded string:\\n\\n","def create_table():\\n    a = []\\n    for i in range(256):\\n        k = i\\n        for j in range(8):\\n            if k & 1:\\n                k ^= 0x1db710640\\n            k >>= 1\\n        a.append(k)\\n    return a\\n\\ndef crc_update(buf, crc):\\n    crc ^= 0xffffffff\\n    for k in buf:\\n        crc = (crc >> 8) ^ crc_table[(crc & 0xff) ^ k]\\n    return crc ^ 0xffffffff\\n    \\ncrc_table = create_table()\\nprint(hex(crc_update(b\""The quick brown fox jumps over the lazy dog\"", 0)))"
"Python","CRC-32","\\nDemonstrate a method of deriving the Cyclic Redundancy Check from within the language.\\n\\nThe result should be in accordance with ISO 3309, ITU-T V.42, Gzip and PNG.\\nAlgorithms are described on Computation of CRC in Wikipedia.\\nThis variant of CRC-32 uses LSB-first order, sets the initial CRC to FFFFFFFF16, and complements the final CRC.\\nFor the purpose of this task, generate a CRC-32 checksum for the ASCII encoded string:\\n\\n","from functools import (reduce)\\nfrom itertools import (islice)\\n\\n\\n# main :: IO ()\\ndef main():\\n    print (\\n        format(\\n            crc32('The quick brown fox jumps over the lazy dog'),\\n            '02x'\\n        )\\n    )\\n\\n\\n# crc32 :: String -> Int\\ndef crc32(s):\\n    table = list(\\n        map(lambda n: list(\\n            islice(\\n                iterate(\\n                    lambda x: (\\n                        (lambda z: 0xedb88320 ^ z) if (\\n                            x & 1\\n                        ) else (\\n                            lambda z: z\\n                        )\\n                    )(x >> 1)\\n                )(n),\\n                9\\n            )\\n        )[8], list(range(0, 256)))\\n    )\\n    return reduce(\\n        lambda a, c: (a >> 8) ^ table[\\n            (a ^ ord(c)) & 0xff\\n        ],\\n        list(s), (0xffffffff)\\n    ) ^ 0xffffffff\\n\\n\\n# GENERIC ABSTRACTIONS ------------------------------------\\n\\n\\n# iterate :: (a -> a) -> a -> Gen [a]\\ndef iterate(f):\\n    def go(x):\\n        v = x\\n        while True:\\n            yield(v)\\n            v = f(v)\\n    return lambda x: go(x)\\n\\n\\nmain()"
"Python","Create_a_file","In this task, the job is to create a new empty file called \""output.txt\"" of size 0 bytes\\nand an empty directory called \""docs\"". This should be done twice: once \""here\"", i.e. in the current working directory and once in the filesystem root.\\nNotes:\\nNote: file names are Operating System dependent.\\nIt may be best to to use an operating system provided library.\\nAppleScript itself has limited built-in File System access, but folders (directories) can be created by controlling the Mac OS Finder, and files can be created and accessed using the Standard Additions (osax) scripting addition included with AppleScript. Also, the Finder has no concept of the working directory (as it is a GUI). You can however target the frontmost Finder window that is open.\\nCreate a zero-byte text file on the startup disk (root directory). Note: the close command is a memory allocation housekeeping command that should be performed once file access is complete.\\nCreate a new folder (directory) on the startup disk (root directory).\\nCreate a zero-byte text file in the frontmost (open) Finder window.\\nCreate a new folder (directory) in the frontmost (open) Finder window.\\n--Apl.way 21:20, 9 June 2010 (UTC)\\nSince the TI-OS does not have a true filesystem, this task is emulated using an application variable instead of a file.\\n","import os\\nfor directory in ['/', './']:\\n  open(directory + 'output.txt', 'w').close()  # create /output.txt, then ./output.txt\\n  os.mkdir(directory + 'docs')                 # create directory /docs, then ./docs"
"Python","Create_a_file","In this task, the job is to create a new empty file called \""output.txt\"" of size 0 bytes\\nand an empty directory called \""docs\"". This should be done twice: once \""here\"", i.e. in the current working directory and once in the filesystem root.\\nNotes:\\nNote: file names are Operating System dependent.\\nIt may be best to to use an operating system provided library.\\nAppleScript itself has limited built-in File System access, but folders (directories) can be created by controlling the Mac OS Finder, and files can be created and accessed using the Standard Additions (osax) scripting addition included with AppleScript. Also, the Finder has no concept of the working directory (as it is a GUI). You can however target the frontmost Finder window that is open.\\nCreate a zero-byte text file on the startup disk (root directory). Note: the close command is a memory allocation housekeeping command that should be performed once file access is complete.\\nCreate a new folder (directory) on the startup disk (root directory).\\nCreate a zero-byte text file in the frontmost (open) Finder window.\\nCreate a new folder (directory) in the frontmost (open) Finder window.\\n--Apl.way 21:20, 9 June 2010 (UTC)\\nSince the TI-OS does not have a true filesystem, this task is emulated using an application variable instead of a file.\\n","from __future__ import with_statement\\nimport os\\ndef create(directory):\\n    with open(os.path.join(directory, \""output.txt\""), \""w\""):\\n        pass\\n    os.mkdir(os.path.join(directory, \""docs\""))\\n   \\ncreate(\"".\"") # current directory\\ncreate(\""/\"") # root directory"
"Python","Create_a_file_on_magnetic_tape","The task is to create a new file called \""TAPE.FILE\"" of any size on Magnetic Tape.\\nThe program is self explanatory. :)\\nFortran performs reads and writes to some device, without caring much about the precise nature of the device: card reader/punch, paper tape reader/punch, keyboard, display console, and of course magnetic tape. Sequential input or output is normal, but random access by record number is also possible, though the interface between the Fortran program and the device may not support such attempts, as with a card reader or a display screen. There are also special statements, such as REWIND and BACKSPACE, and ENDFILE. The file OPEN statement will specify such matters as record length and block size and so all is in place for dealing with magnetic tapes...\\nOf the simplest sort: \""Unlabelled\"". Such a tape consists of a sequence of data blocks, separated by inter-record-gaps, with two in a row at the end to specify the end-of-data on the tape. Although called inter-record, they are actually inter-block: the tape unit reads or writes blocks of say 5,000 characters, not caring that each block might be regarded as containing 50 records of length 100, or 100 records of length 50, etc. The inter-record gap is a sequence of three quarters of an inch of magnetic tape, containing special magnetisation that can be written or sensed at any speed, because these spaces are where the tape is brought to rest between reads or writes. That is, having written the data of a block at full speed, the tape write head writes an IRG as the tape is brought to a stop, and later, when it resumes motion to reach operating speed for the writing of the next block. With adequate data buffering, tape is moved past the head without pause through the IRG as blocks are read or written. If the tape is being read (and written!) with random access the width of the IRG allows for some slop in positioning. Some caution is in order: a \""fast forward\"" action, followed by a few seconds pause to allow the attainment of maximum speed, then a REWIND resulted in a piece of tape being stretched to double length and half width...\\nUnlabelled tapes are quite inconvenient in a non-user operated computer installation, as mistakes are very easy to make. The wrong tape gets overwritten and the ensuing conversation sours. Computer-readable labels were introduced to supplement human-readable written labels affixed to the tape reel. Co-ordination and standardisation were weak in the 1970s, so there was a lot of variation and partial interoperability between manufacturers and ANSI standards. The first step was of course non-standard labels: some data would be written to the start of the tape that constituted a label, followed by a tape mark, then the actual data file, and so on. Users at an installation would attempt to conform to the local style, and there would be discussions, especially when tapes were exchanged with different systems. A large organisation such as IBM would have its method, and the basic idea was that at the start of the tape would be a volume label and additional information to allow for a data file (or multiple data files) that extended over many reels of tape, each tape identified in turn. This would start with an eighty-character record, beginning \""VOL1\"" - but in EBCDIC, and only later in ASCII. None of this would be visible to the user's programme because it would be handled by the operating system with statements in Job Control Language for the run to identify the file on tape that is to be accessed when the user's programme executes an OPEN statement of a suitable form. And this access would revert to sequential reading or writing with quite ordinary READ and WRITE statements.\\nThis was developed when tape drives used half-inch tapes in lengths up to 2,400 feet and seven or nine-track recording, storing up to about 150MB per reel - much depended on the length lost to IRG usage between blocks, but block sizes beyond 20,000 were considered large. Subsequent tape designs have included 18, 36, and 128 tracks, helical recording and storage capacities in tens of gigabytes. Naturally, the tape labelling protocols have become even more complex, but, these matters are handled by more complex operating systems.\\n\\nTaking a cue from the discussion page, this creates\\nan optionally compressed tar (tape archive) file\\non stdout\\n(or written to a file or a device such as /dev/tape).\\nThe tar archive will contain a single file, called TAPE.FILE by default,\\nwith the contents of the command line -data option.\\n",">>> with open('/dev/tape', 'w') as t: t.write('Hi Tape!\\n')\\n... \\n>>> "
"Python","Create_a_two-dimensional_array_at_runtime","Data Structure\\nThis illustrates a data structure, a means of storing data within a program.\\nGet two integers from the user, then create a two-dimensional array where the two dimensions have the sizes given by those numbers, and which can be accessed in the most natural way possible. Write some element of that array, and then output that element. Finally destroy the array if not done by the language itself.\\nArrays are an integral part of APL. Array size, shape, and data type can be easily manipulated at runtime.\\nAppleScript has no array, but an AppleScript list can be used in a multidimensional fashion. There's no issue with their dimensions, they grow while adding elements. Memory allocation is dynamic.\\nAWK has no multidimensional array; but AWK arrays (which are Associative array indeed) can be used also in a multidimensional fashion. Since AWK arrays are associative arrays, there's no issue in their dimensions: they grow while adding new key-value pair.\\nAllocate multi-dimensional arrays with a single call to malloc. The demonstration code builds a rank 3 array.\\n\\nThis style is supported by all 'C' compilers.\\nThis style also supports more efficient memory utilization if you're only using a portion of the\\narray. If you only need the upper right half of a square array, you can do something like the following.\\nThis approach most closely matches the C99 example, as alloca allocates on the stack, rather than the heap, as malloc does.\\n\\nThe assert will allow the user to reenter the dimensions if they are not positive integers.\\nArrays in Component Pascal are started from zero index. No DISPOSE-like procedures because of garbage collection.\\n","width = int(raw_input(\""Width of myarray: \""))\\nheight = int(raw_input(\""Height of Array: \""))\\nmyarray = [[0] * width for i in xrange(height)]\\nmyarray[0][0] = 3.5\\nprint myarray[0][0]"
"Python","Create_a_two-dimensional_array_at_runtime","Data Structure\\nThis illustrates a data structure, a means of storing data within a program.\\nGet two integers from the user, then create a two-dimensional array where the two dimensions have the sizes given by those numbers, and which can be accessed in the most natural way possible. Write some element of that array, and then output that element. Finally destroy the array if not done by the language itself.\\nArrays are an integral part of APL. Array size, shape, and data type can be easily manipulated at runtime.\\nAppleScript has no array, but an AppleScript list can be used in a multidimensional fashion. There's no issue with their dimensions, they grow while adding elements. Memory allocation is dynamic.\\nAWK has no multidimensional array; but AWK arrays (which are Associative array indeed) can be used also in a multidimensional fashion. Since AWK arrays are associative arrays, there's no issue in their dimensions: they grow while adding new key-value pair.\\nAllocate multi-dimensional arrays with a single call to malloc. The demonstration code builds a rank 3 array.\\n\\nThis style is supported by all 'C' compilers.\\nThis style also supports more efficient memory utilization if you're only using a portion of the\\narray. If you only need the upper right half of a square array, you can do something like the following.\\nThis approach most closely matches the C99 example, as alloca allocates on the stack, rather than the heap, as malloc does.\\n\\nThe assert will allow the user to reenter the dimensions if they are not positive integers.\\nArrays in Component Pascal are started from zero index. No DISPOSE-like procedures because of garbage collection.\\n","myarray = {(w,h): 0 for w in range(width) for h in range(height)}\\n# or, in pre 2.7 versions of Python: myarray = dict(((w,h), 0) for w in range(width) for h in range(height))\\nmyarray[(0,0)] = 3.5\\nprint myarray[(0,0)]"
"Python","Create_an_HTML_table","Create an HTML table.\\n\\n","\\nimport random\\n\\ndef rand9999():\\n    return random.randint(1000, 9999)\\n\\ndef tag(attr='', **kwargs):\\n    for tag, txt in kwargs.items():\\n        return '<{tag}{attr}>{txt}'.format(**locals())\\n\\nif __name__ == '__main__':\\n    header = tag(tr=''.join(tag(th=txt) for txt in ',X,Y,Z'.split(','))) + '\\n'\\n    rows = '\\n'.join(tag(tr=''.join(tag(' style=\""font-weight: bold;\""', td=i)\\n                                    + ''.join(tag(td=rand9999())\\n                                              for j in range(3))))\\n                     for i in range(1, 6))\\n    table = tag(table='\\n' + header + rows + '\\n')\\n    print(table)"
"Python","Create_an_HTML_table","Create an HTML table.\\n\\n","<table>\\n<tr><th>"
"Python","Create_an_HTML_table","Create an HTML table.\\n\\n","from functools import (reduce)\\nimport itertools\\nimport random\\n\\n\\n# HTML RENDERING ----------------------------------------\\n\\n# treeHTML :: tree\\n#      {tag :: String, text :: String, kvs :: Dict}\\n#      -> HTML String\\ndef treeHTML(tree):\\n    return foldTree(\\n        lambda x: lambda xs: (\\n            f\""<{x['tag'] + attribString(x)}>\"" + (\\n                str(x['text']) if 'text' in x else '\\n'\\n            ) + ''.join(xs) + f\""\\n\""\\n        )\\n    )(tree)\\n\\n\\n# attribString :: Dict -> String\\ndef attribString(dct):\\n    kvs = dct['kvs'] if 'kvs' in dct else None\\n    return ' ' + reduce(\\n        lambda a, k: a + k + '=\""' + kvs[k] + '\"" ',\\n        kvs.keys(), ''\\n    ).strip() if kvs else ''\\n\\n\\n# HTML TABLE FROM GENERATED DATA ------------------------\\n\\n\\ndef main():\\n    # Number of columns and rows to generate.\\n    n = 3\\n\\n    # Table details -------------------------------------\\n    strCaption = 'Table generated with Python'\\n    colNames = take(n)(enumFrom('A'))\\n    dataRows = map(\\n        lambda x: (x, map(\\n            lambda _: random.randint(100, 9999),\\n            colNames\\n        )), take(n)(enumFrom(1)))\\n    tableStyle = {\\n        'style': \""width:25%; border:2px solid silver;\""\\n    }\\n    trStyle = {\\n        'style': \""border:1px solid silver;text-align:right;\""\\n    }\\n\\n    # TREE STRUCTURE OF TABLE ---------------------------\\n    tableTree = Node({'tag': 'table', 'kvs': tableStyle})([\\n        Node({\\n            'tag': 'caption',\\n            'text': strCaption\\n        })([]),\\n\\n        # HEADER ROW --------------------------------\\n        (Node({'tag': 'tr'})(\\n            Node({\\n                'tag': 'th',\\n                'kvs': {'style': 'text-align:right;'},\\n                'text': k\\n            })([]) for k in ([''] + colNames)\\n        ))\\n    ] +\\n        # DATA ROWS ---------------------------------\\n        list(Node({'tag': 'tr', 'kvs': trStyle})(\\n            [Node({'tag': 'th', 'text': tpl[0]})([])] +\\n            list(Node(\\n                {'tag': 'td', 'text': str(v)})([]) for v in tpl[1]\\n            )\\n        ) for tpl in dataRows)\\n    )\\n\\n    print(\\n        treeHTML(tableTree)\\n        # dataRows\\n    )\\n\\n\\n# GENERIC -----------------------------------------------\\n\\n# Node :: a -> [Tree a] -> Tree a\\ndef Node(v):\\n    return lambda xs: {'type': 'Node', 'root': v, 'nest': xs}\\n\\n\\n# enumFrom :: Enum a => a -> [a]\\ndef enumFrom(x):\\n    return itertools.count(x) if type(x) is int else (\\n        map(chr, itertools.count(ord(x)))\\n    )\\n\\n\\n# foldTree :: (a -> [b] -> b) -> Tree a -> b\\ndef foldTree(f):\\n    def go(node):\\n        return f(node['root'])(\\n            list(map(go, node['nest']))\\n        )\\n    return lambda tree: go(tree)\\n\\n\\n# take :: Int -> [a] -> [a]\\n# take :: Int -> String -> String\\ndef take(n):\\n    return lambda xs: (\\n        xs[0:n]\\n        if isinstance(xs, list)\\n        else list(itertools.islice(xs, n))\\n    )\\n\\n\\nif __name__ == '__main__':\\n    main()"
"Python","Create_an_HTML_table","Create an HTML table.\\n\\n","\\n<caption>Table generated with Python"
"Python","Create_an_object/Native_demonstration","Create a Hash/Associative Array/Dictionary-like object, initialized with some default key/value pairs using the languages native method of object creation. The object should behave like a native Hash/Associative Array/Dictionary of the language, if any, but with the following differences:\\nIf the language supports Magic Methods, then show how these work.\\n","\\nfrom collections import UserDict\\nimport copy\\n\\nclass Dict(UserDict):\\n    '''\\n    >>> d = Dict(a=1, b=2)\\n    >>> d\\n    Dict({'a': 1, 'b': 2})\\n    >>> d['a'] = 55; d['b'] = 66\\n    >>> d\\n    Dict({'a': 55, 'b': 66})\\n    >>> d.clear()\\n    >>> d\\n    Dict({'a': 1, 'b': 2})\\n    >>> d['a'] = 55; d['b'] = 66\\n    >>> d['a']\\n    55\\n    >>> del d['a']\\n    >>> d\\n    Dict({'a': 1, 'b': 66})\\n    '''\\n    def __init__(self, dict=None, **kwargs):\\n        self.__init = True\\n        super().__init__(dict, **kwargs)\\n        self.default = copy.deepcopy(self.data)\\n        self.__init = False\\n    \\n    def __delitem__(self, key):\\n        if key in self.default:\\n            self.data[key] = self.default[key]\\n        else:\\n            raise NotImplementedError\\n\\n    def __setitem__(self, key, item):\\n        if self.__init:\\n            super().__setitem__(key, item)\\n        elif key in self.data:\\n            self.data[key] = item\\n        else:\\n            raise KeyError\\n\\n    def __repr__(self):\\n        return \""%s(%s)\"" % (type(self).__name__, super().__repr__())\\n    \\n    def fromkeys(cls, iterable, value=None):\\n        if self.__init:\\n            super().fromkeys(cls, iterable, value)\\n        else:\\n            for key in iterable:\\n                if key in self.data:\\n                    self.data[key] = value\\n                else:\\n                    raise KeyError\\n\\n    def clear(self):\\n        self.data.update(copy.deepcopy(self.default))\\n\\n    def pop(self, key, default=None):\\n        raise NotImplementedError\\n\\n    def popitem(self):\\n        raise NotImplementedError\\n\\n    def update(self, E, **F):\\n        if self.__init:\\n            super().update(E, **F)\\n        else:\\n            haskeys = False\\n            try:\\n                keys = E.keys()\\n                haskeys = Ture\\n            except AttributeError:\\n                pass\\n            if haskeys:\\n                for key in keys:\\n                    self[key] = E[key]\\n            else:\\n                for key, val in E:\\n                    self[key] = val\\n            for key in F:\\n                self[key] = F[key]\\n\\n    def setdefault(self, key, default=None):\\n        if key not in self.data:\\n            raise KeyError\\n        else:\\n            return super().setdefault(key, default)"
"Python","CSV_data_manipulation","CSV spreadsheet files are suitable for storing tabular data in a relatively portable way.\\nThe CSV format is flexible but somewhat ill-defined.\\nFor present purposes, authors may assume that the data fields contain no commas, backslashes, or quotation marks.\\n\\nRead a CSV file, change some values and save the changes back to a file.\\nFor this task we will use the following CSV file:\\nSuggestions\\n\\nAda has no build-in or predefined functions to read or write CSV tables. We thus define a (very simplistic) package CSV, which allows to read a row (function Line), to step from column to column (function Next), and to get the items in the column (function Item):\\nThe implementation of the package is\\nFinally, the main program which uses the package CSV:\\n","import fileinput\\n\\nchangerow, changecolumn, changevalue = 2, 4, '\""Spam\""'\\n\\nwith fileinput.input('csv_data_manipulation.csv', inplace=True) as f:\\n    for line in f:\\n        if fileinput.filelineno() == changerow:\\n            fields = line.rstrip().split(',')\\n            fields[changecolumn-1] = changevalue\\n            line = ','.join(fields) + '\\n'\\n        print(line, end='')"
"Python","CSV_to_HTML_translation","Consider a simplified CSV format where all rows are separated by a newline\\nand all columns are separated by commas.\\nNo commas are allowed as field data, but the data may contain\\nother characters and character sequences that would\\nnormally be   escaped   when converted to HTML\\n\\nCreate a function that takes a string representation of the CSV data\\nand returns a text string of an HTML table representing the CSV data.\\nUse the following data as the CSV text to convert, and show your output.\\n\\nOptionally allow special formatting for the first row of the table as if it is the tables header row\\n(via <thead> preferably; CSS if you must).\\n\\ncsv2html.adb:\\ntable.tmplt:\\n","csvtxt = '''\\\\nCharacter,Speech\\nThe multitude,The messiah! Show us the messiah!\\nBrians mother,<angry>Now you listen here! He's not the messiah; he's a very naughty boy! Now go away!"
"Python","CSV_to_HTML_translation","Consider a simplified CSV format where all rows are separated by a newline\\nand all columns are separated by commas.\\nNo commas are allowed as field data, but the data may contain\\nother characters and character sequences that would\\nnormally be   escaped   when converted to HTML\\n\\nCreate a function that takes a string representation of the CSV data\\nand returns a text string of an HTML table representing the CSV data.\\nUse the following data as the CSV text to convert, and show your output.\\n\\nOptionally allow special formatting for the first row of the table as if it is the tables header row\\n(via <thead> preferably; CSS if you must).\\n\\ncsv2html.adb:\\ntable.tmplt:\\n","\\n  <TBODY><TR><TD>Character"
"Python","CSV_to_HTML_translation","Consider a simplified CSV format where all rows are separated by a newline\\nand all columns are separated by commas.\\nNo commas are allowed as field data, but the data may contain\\nother characters and character sequences that would\\nnormally be   escaped   when converted to HTML\\n\\nCreate a function that takes a string representation of the CSV data\\nand returns a text string of an HTML table representing the CSV data.\\nUse the following data as the CSV text to convert, and show your output.\\n\\nOptionally allow special formatting for the first row of the table as if it is the tables header row\\n(via <thead> preferably; CSS if you must).\\n\\ncsv2html.adb:\\ntable.tmplt:\\n","def _row2trextra(row, attr=None):\\n    cols = escape(row).split(',')\\n    attr_tr = attr.get('TR', '')\\n    attr_td = attr.get('TD', '')\\n    return (('' % attr_tr)\\n            + ''.join('%s"
"Python","CSV_to_HTML_translation","Consider a simplified CSV format where all rows are separated by a newline\\nand all columns are separated by commas.\\nNo commas are allowed as field data, but the data may contain\\nother characters and character sequences that would\\nnormally be   escaped   when converted to HTML\\n\\nCreate a function that takes a string representation of the CSV data\\nand returns a text string of an HTML table representing the CSV data.\\nUse the following data as the CSV text to convert, and show your output.\\n\\nOptionally allow special formatting for the first row of the table as if it is the tables header row\\n(via <thead> preferably; CSS if you must).\\n\\ncsv2html.adb:\\ntable.tmplt:\\n","\\n<TR><TD>Character"
"Python","Cumulative_standard_deviation","Write a stateful function, class, generator or co-routine that takes a series of floating point numbers, one at a time, and returns the running standard deviation of the series.\\nThe task implementation should use the most natural programming style of those listed for the function in the implementation language; the task must state which is being used.\\nDo not apply Bessel's correction; the returned standard deviation should always be computed as if the sample seen so far is the entire population.\\n\\nUse this to compute the standard deviation of this demonstration set, \\n\\n\\n\\n{\\n2\\n,\\n4\\n,\\n4\\n,\\n4\\n,\\n5\\n,\\n5\\n,\\n7\\n,\\n9\\n}\\n\\n\\n{\\displaystyle \\{2,4,4,4,5,5,7,9\\}}\\n\\n, which is \\n\\n\\n\\n2\\n\\n\\n{\\displaystyle 2}\\n\\n.\\n\\n\\nFor maximum compatibility, this program uses only the basic instruction set.\\nPart of the code length is due to the square root algorithm and to the nice output.\\n",">>> from math import sqrt\\n>>> def sd(x):\\n    sd.sum  += x\\n    sd.sum2 += x*x\\n    sd.n    += 1.0\\n    sum, sum2, n = sd.sum, sd.sum2, sd.n\\n    return sqrt(sum2/n - sum*sum/n/n)\\n\\n>>> sd.sum = sd.sum2 = sd.n = 0\\n>>> for value in (2,4,4,4,5,5,7,9):\\n    print (value, sd(value))\\n\\n    \\n(2, 0.0)\\n(4, 1.0)\\n(4, 0.94280904158206258)\\n(4, 0.8660254037844386)\\n(5, 0.97979589711327075)\\n(5, 1.0)\\n(7, 1.3997084244475311)\\n(9, 2.0)\\n>>>"
"Python","Cumulative_standard_deviation","Write a stateful function, class, generator or co-routine that takes a series of floating point numbers, one at a time, and returns the running standard deviation of the series.\\nThe task implementation should use the most natural programming style of those listed for the function in the implementation language; the task must state which is being used.\\nDo not apply Bessel's correction; the returned standard deviation should always be computed as if the sample seen so far is the entire population.\\n\\nUse this to compute the standard deviation of this demonstration set, \\n\\n\\n\\n{\\n2\\n,\\n4\\n,\\n4\\n,\\n4\\n,\\n5\\n,\\n5\\n,\\n7\\n,\\n9\\n}\\n\\n\\n{\\displaystyle \\{2,4,4,4,5,5,7,9\\}}\\n\\n, which is \\n\\n\\n\\n2\\n\\n\\n{\\displaystyle 2}\\n\\n.\\n\\n\\nFor maximum compatibility, this program uses only the basic instruction set.\\nPart of the code length is due to the square root algorithm and to the nice output.\\n",">>> class SD(object): # Plain () for python 3.x\\n	def __init__(self):\\n		self.sum, self.sum2, self.n = (0,0,0)\\n	def sd(self, x):\\n		self.sum  += x\\n		self.sum2 += x*x\\n		self.n    += 1.0\\n		sum, sum2, n = self.sum, self.sum2, self.n\\n		return sqrt(sum2/n - sum*sum/n/n)\\n\\n>>> sd_inst = SD()\\n>>> for value in (2,4,4,4,5,5,7,9):\\n	print (value, sd_inst.sd(value))"
"Python","Cumulative_standard_deviation","Write a stateful function, class, generator or co-routine that takes a series of floating point numbers, one at a time, and returns the running standard deviation of the series.\\nThe task implementation should use the most natural programming style of those listed for the function in the implementation language; the task must state which is being used.\\nDo not apply Bessel's correction; the returned standard deviation should always be computed as if the sample seen so far is the entire population.\\n\\nUse this to compute the standard deviation of this demonstration set, \\n\\n\\n\\n{\\n2\\n,\\n4\\n,\\n4\\n,\\n4\\n,\\n5\\n,\\n5\\n,\\n7\\n,\\n9\\n}\\n\\n\\n{\\displaystyle \\{2,4,4,4,5,5,7,9\\}}\\n\\n, which is \\n\\n\\n\\n2\\n\\n\\n{\\displaystyle 2}\\n\\n.\\n\\n\\nFor maximum compatibility, this program uses only the basic instruction set.\\nPart of the code length is due to the square root algorithm and to the nice output.\\n",">>> from math import sqrt\\n>>> def sdcreator():\\n	sum = sum2 = n = 0\\n	def sd(x):\\n		nonlocal sum, sum2, n\\n\\n		sum  += x\\n		sum2 += x*x\\n		n    += 1.0\\n		return sqrt(sum2/n - sum*sum/n/n)\\n	return sd\\n\\n>>> sd = sdcreator()\\n>>> for value in (2,4,4,4,5,5,7,9):\\n	print (value, sd(value))\\n\\n	\\n2 0.0\\n4 1.0\\n4 0.942809041582\\n4 0.866025403784\\n5 0.979795897113\\n5 1.0\\n7 1.39970842445\\n9 2.0"
"Python","Cumulative_standard_deviation","Write a stateful function, class, generator or co-routine that takes a series of floating point numbers, one at a time, and returns the running standard deviation of the series.\\nThe task implementation should use the most natural programming style of those listed for the function in the implementation language; the task must state which is being used.\\nDo not apply Bessel's correction; the returned standard deviation should always be computed as if the sample seen so far is the entire population.\\n\\nUse this to compute the standard deviation of this demonstration set, \\n\\n\\n\\n{\\n2\\n,\\n4\\n,\\n4\\n,\\n4\\n,\\n5\\n,\\n5\\n,\\n7\\n,\\n9\\n}\\n\\n\\n{\\displaystyle \\{2,4,4,4,5,5,7,9\\}}\\n\\n, which is \\n\\n\\n\\n2\\n\\n\\n{\\displaystyle 2}\\n\\n.\\n\\n\\nFor maximum compatibility, this program uses only the basic instruction set.\\nPart of the code length is due to the square root algorithm and to the nice output.\\n",">>> from math import sqrt\\n>>> def sdcreator():\\n	sum = sum2 = n = 0\\n	while True:\\n		x = yield sqrt(sum2/n - sum*sum/n/n) if n else None\\n\\n		sum  += x\\n		sum2 += x*x\\n		n    += 1.0\\n\\n>>> sd = sdcreator()\\n>>> sd.send(None)\\n>>> for value in (2,4,4,4,5,5,7,9):\\n	print (value, sd.send(value))\\n\\n	\\n2 0.0\\n4 1.0\\n4 0.942809041582\\n4 0.866025403784\\n5 0.979795897113\\n5 1.0\\n7 1.39970842445\\n9 2.0"
"Python","Cumulative_standard_deviation","Write a stateful function, class, generator or co-routine that takes a series of floating point numbers, one at a time, and returns the running standard deviation of the series.\\nThe task implementation should use the most natural programming style of those listed for the function in the implementation language; the task must state which is being used.\\nDo not apply Bessel's correction; the returned standard deviation should always be computed as if the sample seen so far is the entire population.\\n\\nUse this to compute the standard deviation of this demonstration set, \\n\\n\\n\\n{\\n2\\n,\\n4\\n,\\n4\\n,\\n4\\n,\\n5\\n,\\n5\\n,\\n7\\n,\\n9\\n}\\n\\n\\n{\\displaystyle \\{2,4,4,4,5,5,7,9\\}}\\n\\n, which is \\n\\n\\n\\n2\\n\\n\\n{\\displaystyle 2}\\n\\n.\\n\\n\\nFor maximum compatibility, this program uses only the basic instruction set.\\nPart of the code length is due to the square root algorithm and to the nice output.\\n",">>> myMean = lambda MyList : reduce(lambda x, y: x + y, MyList) / float(len(MyList))\\n>>> myStd = lambda MyList : (reduce(lambda x,y : x + y , map(lambda x: (x-myMean(MyList))**2 , MyList)) / float(len(MyList)))**.5\\n\\n>>> print myStd([2,4,4,4,5,5,7,9])\\n2.0\\n"
"Python","Currency","Show how to represent currency in a simple example, using a data type that represent exact values of dollars and cents.\\n\\nThe IEEE 754 binary floating point representations of numbers like   2.86   and   .0765   are not exact.\\nFor this example, data will be two items with prices in dollars and cents, a quantity for each, and a tax rate.\\nUse the values:\\n\\n(That number of hamburgers is a 4 with 15 zeros after it.   The number is contrived to exclude naïve task solutions using 64 bit floating point types.)\\nCompute and output (show results on this page):\\n\\nThe tax value must be computed by rounding to the nearest whole cent and this exact value must be added to the total price before tax.\\nThe output must show dollars and cents with a decimal point.\\nThe three results displayed should be:\\n\\nDollar signs and thousands separators are optional.\\n\\n","from decimal import Decimal as D\\nfrom collections import namedtuple\\n\\nItem = namedtuple('Item', 'price, quant')\\n\\nitems = dict( hamburger=Item(D('5.50'), D('4000000000000000')),\\n              milkshake=Item(D('2.86'), D('2')) )\\ntax_rate = D('0.0765')\\n\\nfmt = \""%-10s %8s %18s %22s\""\\nprint(fmt % tuple('Item Price Quantity Extension'.upper().split()))\\n\\ntotal_before_tax = 0\\nfor item, (price, quant) in sorted(items.items()):\\n    ext = price * quant\\n    print(fmt % (item, price, quant, ext))\\n    total_before_tax += ext\\nprint(fmt % ('', '', '', '--------------------'))\\nprint(fmt % ('', '', 'subtotal', total_before_tax))\\n\\ntax = (tax_rate * total_before_tax).quantize(D('0.00'))\\nprint(fmt % ('', '', 'Tax', tax))\\n\\ntotal = total_before_tax + tax\\nprint(fmt % ('', '', '', '--------------------'))\\nprint(fmt % ('', '', 'Total', total))"
"Python","Currying","\\nCreate a simple demonstrative example of Currying in a specific language.\\nAdd any historic details as to how the feature made its way into the language.\\n\\nIn 1968 C.H. Lindsey proposed for partial parametrisation for ALGOL 68, this is implemented as an extension in wp:ALGOL 68G.\\n\\nThe nearest thing to a first-class function in AppleScript is a 'script' in which a 'handler' (with some default or vanilla name like 'call' or 'lambda' is embedded). First class use of an ordinary 2nd class 'handler' function requires 'lifting' it into an enclosing script – a process which can be abstracted to a general mReturn function.\\n"," def addN(n):\\n     def adder(x):\\n         return x + n\\n     return adder"
"Python","Currying","\\nCreate a simple demonstrative example of Currying in a specific language.\\nAdd any historic details as to how the feature made its way into the language.\\n\\nIn 1968 C.H. Lindsey proposed for partial parametrisation for ALGOL 68, this is implemented as an extension in wp:ALGOL 68G.\\n\\nThe nearest thing to a first-class function in AppleScript is a 'script' in which a 'handler' (with some default or vanilla name like 'call' or 'lambda' is embedded). First class use of an ordinary 2nd class 'handler' function requires 'lifting' it into an enclosing script – a process which can be abstracted to a general mReturn function.\\n"," >>> add2 = addN(2)\\n >>> add2\\n \\n >>> add2(7)\\n 9"
"Python","Currying","\\nCreate a simple demonstrative example of Currying in a specific language.\\nAdd any historic details as to how the feature made its way into the language.\\n\\nIn 1968 C.H. Lindsey proposed for partial parametrisation for ALGOL 68, this is implemented as an extension in wp:ALGOL 68G.\\n\\nThe nearest thing to a first-class function in AppleScript is a 'script' in which a 'handler' (with some default or vanilla name like 'call' or 'lambda' is embedded). First class use of an ordinary 2nd class 'handler' function requires 'lifting' it into an enclosing script – a process which can be abstracted to a general mReturn function.\\n",">>> from functools import partial\\n>>> from operator import add\\n>>> add2 = partial(add, 2)\\n>>> add2\\nfunctools.partial(, 2)\\n>>> add2(7)\\n9\\n>>> double = partial(map, lambda x: x*2)\\n>>> print(*double(range(5)))\\n0 2 4 6 8"
"Python","Currying","\\nCreate a simple demonstrative example of Currying in a specific language.\\nAdd any historic details as to how the feature made its way into the language.\\n\\nIn 1968 C.H. Lindsey proposed for partial parametrisation for ALGOL 68, this is implemented as an extension in wp:ALGOL 68G.\\n\\nThe nearest thing to a first-class function in AppleScript is a 'script' in which a 'handler' (with some default or vanilla name like 'call' or 'lambda' is embedded). First class use of an ordinary 2nd class 'handler' function requires 'lifting' it into an enclosing script – a process which can be abstracted to a general mReturn function.\\n",">>> from toolz import curry\\n>>> import operator\\n>>> add = curry(operator.add)\\n>>> add2 = add(2)\\n>>> add2\\n\\n>>> add2(7)\\n9\\n>>> # Toolz also has pre-curried versions of most HOFs from builtins, stdlib, and toolz\\n>>>from toolz.curried import map\\n>>> double = map(lambda x: x*2)\\n>>> print(*double(range(5)))\\n0 2 4 6 8"
"Python","Currying","\\nCreate a simple demonstrative example of Currying in a specific language.\\nAdd any historic details as to how the feature made its way into the language.\\n\\nIn 1968 C.H. Lindsey proposed for partial parametrisation for ALGOL 68, this is implemented as an extension in wp:ALGOL 68G.\\n\\nThe nearest thing to a first-class function in AppleScript is a 'script' in which a 'handler' (with some default or vanilla name like 'call' or 'lambda' is embedded). First class use of an ordinary 2nd class 'handler' function requires 'lifting' it into an enclosing script – a process which can be abstracted to a general mReturn function.\\n","# AUTOMATIC CURRYING AND UNCURRYING OF EXISTING FUNCTIONS\\n\\n\\n# curry :: ((a, b) -> c) -> a -> b -> c\\ndef curry(f):\\n    return lambda a: lambda b: f(a, b)\\n\\n\\n# uncurry :: (a -> b -> c) -> ((a, b) -> c)\\ndef uncurry(f):\\n    return lambda x, y: f(x)(y)\\n\\n\\n# EXAMPLES --------------------------------------\\n\\n# A plain uncurried function with 2 arguments,\\n\\n# justifyLeft :: Int -> String -> String\\ndef justifyLeft(n, s):\\n    return (s + (n * ' '))[:n]\\n\\n\\n# and a similar, but manually curried, function.\\n\\n# justifyRight :: Int -> String -> String\\ndef justifyRight(n):\\n    return lambda s: (\\n        ((n * ' ') + s)[-n:]\\n    )\\n\\n\\n# CURRYING and UNCURRYING at run-time:\\n\\ndef main():\\n    for s in [\\n        'Manually curried using a lambda:',\\n        '\\n'.join(map(\\n            justifyRight(5),\\n            ['1', '9', '10', '99', '100', '1000']\\n        )),\\n\\n        '\\nAutomatically uncurried:',\\n        uncurry(justifyRight)(5, '10000'),\\n\\n        '\\nAutomatically curried',\\n        '\\n'.join(map(\\n            curry(justifyLeft)(10),\\n            ['1', '9', '10', '99', '100', '1000']\\n        ))\\n    ]:\\n        print (s)\\n\\n\\nmain()"
"Python","CUSIP","\\nA   CUSIP   is a nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades. The CUSIP was adopted as an American National Standard under Accredited Standards X9.6.\\n\\nEnsure the last digit   (i.e., the   check digit)   of the CUSIP code (the 1st column) is correct, against the following:\\n\\n\\n\\n","#!/usr/bin/env python3\\n\\nimport math\\n\\ndef cusip_check(cusip):\\n    if len(cusip) != 9:\\n        raise ValueError('CUSIP must be 9 characters')\\n\\n    cusip = cusip.upper()\\n    total = 0\\n    for i in range(8):\\n        c = cusip[i]\\n        if c.isdigit():\\n            v = int(c)\\n        elif c.isalpha():\\n            p = ord(c) - ord('A') + 1\\n            v = p + 9\\n        elif c == '*':\\n            v = 36\\n        elif c == '@':\\n            v = 37\\n        elif c == '#':\\n            v = 38\\n\\n        if i % 2 != 0:\\n            v *= 2\\n\\n        total += int(v / 10) + v % 10\\n    check = (10 - (total % 10)) % 10\\n    return str(check) == cusip[-1]\\n\\nif __name__ == '__main__':\\n    codes = [\\n            '037833100',\\n            '17275R102',\\n            '38259P508',\\n            '594918104',\\n            '68389X106',\\n            '68389X105'\\n            ]\\n    for code in codes:\\n        print(f'{code} -> {cusip_check(code)}')\\n"
"Python","Cut_a_rectangle","A given rectangle is made from m × n squares. If m and n are not both odd, then it is possible to cut a path through the rectangle along the square edges such that the rectangle splits into two connected pieces with the same shape (after rotating one of the pieces by 180°). All such paths for 2 × 2 and 4 × 3 rectangles are shown below.\\n\\nWrite a program that calculates the number of different ways to cut an m × n rectangle. Optionally, show each of the cuts.\\nPossibly related task: Maze generation for depth-first search.\\nExhaustive search on the cutting path. Symmetric configurations are only calculated once, which helps with larger sized grids.\\nMore awkward solution: after compiling, run ./a.out -v [width] [height] for display of cuts.\\nCount only.\\n","def cut_it(h, w):\\n    dirs = ((1, 0), (-1, 0), (0, -1), (0, 1))\\n    if h & 1: h, w = w, h\\n    if h & 1: return 0\\n    if w == 1: return 1\\n    count = 0\\n\\n    next = [w + 1, -w - 1, -1, 1]\\n    blen = (h + 1) * (w + 1) - 1\\n    grid = [False] * (blen + 1)\\n\\n    def walk(y, x, count):\\n        if not y or y == h or not x or x == w:\\n            return count + 1\\n\\n        t = y * (w + 1) + x\\n        grid[t] = grid[blen - t] = True\\n\\n        if not grid[t + next[0]]:\\n            count = walk(y + dirs[0][0], x + dirs[0][1], count)\\n        if not grid[t + next[1]]:\\n            count = walk(y + dirs[1][0], x + dirs[1][1], count)\\n        if not grid[t + next[2]]:\\n            count = walk(y + dirs[2][0], x + dirs[2][1], count)\\n        if not grid[t + next[3]]:\\n            count = walk(y + dirs[3][0], x + dirs[3][1], count)\\n\\n        grid[t] = grid[blen - t] = False\\n        return count\\n\\n    t = h // 2 * (w + 1) + w // 2\\n    if w & 1:\\n        grid[t] = grid[t + 1] = True\\n        count = walk(h // 2, w // 2 - 1, count)\\n        res = count\\n        count = 0\\n        count = walk(h // 2 - 1, w // 2, count)\\n        return res + count * 2\\n    else:\\n        grid[t] = True\\n        count = walk(h // 2, w // 2 - 1, count)\\n        if h == w:\\n            return count * 2\\n        count = walk(h // 2 - 1, w // 2, count)\\n        return count\\n\\ndef main():\\n    for w in xrange(1, 10):\\n        for h in xrange(1, w + 1):\\n            if not((w * h) & 1):\\n                print \""%d x %d: %d\"" % (w, h, cut_it(w, h))\\n\\nmain()"
"Python","Cut_a_rectangle","A given rectangle is made from m × n squares. If m and n are not both odd, then it is possible to cut a path through the rectangle along the square edges such that the rectangle splits into two connected pieces with the same shape (after rotating one of the pieces by 180°). All such paths for 2 × 2 and 4 × 3 rectangles are shown below.\\n\\nWrite a program that calculates the number of different ways to cut an m × n rectangle. Optionally, show each of the cuts.\\nPossibly related task: Maze generation for depth-first search.\\nExhaustive search on the cutting path. Symmetric configurations are only calculated once, which helps with larger sized grids.\\nMore awkward solution: after compiling, run ./a.out -v [width] [height] for display of cuts.\\nCount only.\\n","try:\\n    import psyco\\nexcept ImportError:\\n    pass\\nelse:\\n    psyco.full()\\n\\nw, h = 0, 0\\ncount = 0\\nvis = []\\n\\ndef cwalk(y, x, d):\\n    global vis, count, w, h\\n    if not y or y == h or not x or x == w:\\n        count += 1\\n        return\\n\\n    vis[y][x] = vis[h - y][w - x] = 1\\n\\n    if x and not vis[y][x - 1]:\\n        cwalk(y, x - 1, d | 1)\\n    if (d & 1) and x < w and not vis[y][x+1]:\\n        cwalk(y, x + 1, d|1)\\n    if y and not vis[y - 1][x]:\\n        cwalk(y - 1, x, d | 2)\\n    if (d & 2) and y < h and not vis[y + 1][x]:\\n        cwalk(y + 1, x, d | 2)\\n\\n    vis[y][x] = vis[h - y][w - x] = 0\\n\\ndef count_only(x, y):\\n    global vis, count, w, h\\n    count = 0\\n    w = x\\n    h = y\\n\\n    if (h * w) & 1:\\n        return count\\n    if h & 1:\\n        w, h = h, w\\n\\n    vis = [[0] * (w + 1) for _ in xrange(h + 1)]\\n    vis[h // 2][w // 2] = 1\\n\\n    if w & 1:\\n        vis[h // 2][w // 2 + 1] = 1\\n\\n    res = 0\\n    if w > 1:\\n        cwalk(h // 2, w // 2 - 1, 1)\\n        res = 2 * count - 1\\n        count = 0\\n        if w != h:\\n            cwalk(h // 2 + 1, w // 2, 3 if (w & 1) else 2)\\n\\n        res += 2 * count - (not (w & 1))\\n    else:\\n        res = 1\\n\\n    if w == h:\\n        res = 2 * res + 2\\n    return res\\n\\ndef main():\\n    for y in xrange(1, 10):\\n        for x in xrange(1, y + 1):\\n            if not (x & 1) or not (y & 1):\\n                print \""%d x %d: %d\"" % (y, x, count_only(x, y))\\n\\nmain()"
"Python","Cycle_detection","Detect a cycle in an iterated function using Brent's algorithm.\\n\\nDetecting cycles in iterated function sequences is a sub-problem in many computer algorithms, such as factoring prime numbers. Some such algorithms are highly space efficient, such as Floyd's cycle-finding algorithm, also called the \""tortoise and the hare algorithm\"". A more time efficient algorithm than \""tortoise and hare\"" is Brent's Cycle algorithm. This task will implement Brent's algorithm.\\nSee https://en.wikipedia.org/wiki/Cycle_detection for a discussion of the theory and discussions of other algorithms that are used to solve the problem.\\nWhen testing the cycle detecting function, you need two things:\\n1) An iterated function\\n2) A starting value\\nThe iterated function used in this example is: f(x) = (x*x + 1) modulo 255.\\nThe starting value used is 3.\\nWith these as inputs, a sample program output would be:\\n3,10,101,2,5,26,167,95,101,2,5,26,167,95,101,2,5,26,167,95,101,2,5,26,167,95,101,2,5,26,167,95,101,2,5,26,167,95,101,2,5\\nCycle length = 6\\nStart index = 2\\nThe output prints the first several items in the number series produced by the iterated function, then identifies how long the cycle is (6) followed by the zero-based index of the start of the first cycle (2). From this you can see that the cycle is:\\n101,2,5,26,167,95\\n","import itertools\\n\\ndef brent(f, x0):\\n    # main phase: search successive powers of two\\n    power = lam = 1\\n    tortoise = x0\\n    hare = f(x0)  # f(x0) is the element/node next to x0.\\n    while tortoise != hare:\\n        if power == lam:  # time to start a new power of two?\\n            tortoise = hare\\n            power *= 2\\n            lam = 0\\n        hare = f(hare)\\n        lam += 1\\n\\n    # Find the position of the first repetition of length lam\\n    mu = 0\\n    tortoise = hare = x0\\n    for i in range(lam):\\n    # range(lam) produces a list with the values 0, 1, ... , lam-1\\n        hare = f(hare)\\n    # The distance between the hare and tortoise is now lam.\\n\\n    # Next, the hare and tortoise move at same speed until they agree\\n    while tortoise != hare:\\n        tortoise = f(tortoise)\\n        hare = f(hare)\\n        mu += 1\\n \\n    return lam, mu\\n\\ndef iterate(f, x0):\\n    while True:\\n        yield x0\\n        x0 = f(x0)\\n\\nif __name__ == '__main__':\\n    f = lambda x: (x * x + 1) % 255\\n    x0 = 3\\n    lam, mu = brent(f, x0)\\n    print(\""Cycle length: %d\"" % lam)\\n    print(\""Cycle start index: %d\"" % mu)\\n    print(\""Cycle: %s\"" % list(itertools.islice(iterate(f, x0), mu, mu+lam)))"
"Python","Cycle_detection","Detect a cycle in an iterated function using Brent's algorithm.\\n\\nDetecting cycles in iterated function sequences is a sub-problem in many computer algorithms, such as factoring prime numbers. Some such algorithms are highly space efficient, such as Floyd's cycle-finding algorithm, also called the \""tortoise and the hare algorithm\"". A more time efficient algorithm than \""tortoise and hare\"" is Brent's Cycle algorithm. This task will implement Brent's algorithm.\\nSee https://en.wikipedia.org/wiki/Cycle_detection for a discussion of the theory and discussions of other algorithms that are used to solve the problem.\\nWhen testing the cycle detecting function, you need two things:\\n1) An iterated function\\n2) A starting value\\nThe iterated function used in this example is: f(x) = (x*x + 1) modulo 255.\\nThe starting value used is 3.\\nWith these as inputs, a sample program output would be:\\n3,10,101,2,5,26,167,95,101,2,5,26,167,95,101,2,5,26,167,95,101,2,5,26,167,95,101,2,5,26,167,95,101,2,5,26,167,95,101,2,5\\nCycle length = 6\\nStart index = 2\\nThe output prints the first several items in the number series produced by the iterated function, then identifies how long the cycle is (6) followed by the zero-based index of the start of the first cycle (2). From this you can see that the cycle is:\\n101,2,5,26,167,95\\n","import itertools\\n\\ndef brent_length(f, x0):\\n    # main phase: search successive powers of two\\n    hare = x0\\n    power = 1\\n    while True:\\n        tortoise = hare\\n        for i in range(1, power+1):\\n            hare = f(hare)\\n            if tortoise == hare:\\n                return i\\n        power *= 2\\n\\ndef brent(f, x0):\\n    lam = brent_length(f, x0)\\n\\n    # Find the position of the first repetition of length lam\\n    mu = 0\\n    hare = x0\\n    for i in range(lam):\\n    # range(lam) produces a list with the values 0, 1, ... , lam-1\\n        hare = f(hare)\\n    # The distance between the hare and tortoise is now lam.\\n\\n    # Next, the hare and tortoise move at same speed until they agree\\n    tortoise = x0\\n    while tortoise != hare:\\n        tortoise = f(tortoise)\\n        hare = f(hare)\\n        mu += 1\\n \\n    return lam, mu\\n\\ndef iterate(f, x0):\\n    while True:\\n        yield x0\\n        x0 = f(x0)\\n\\nif __name__ == '__main__':\\n    f = lambda x: (x * x + 1) % 255\\n    x0 = 3\\n    lam, mu = brent(f, x0)\\n    print(\""Cycle length: %d\"" % lam)\\n    print(\""Cycle start index: %d\"" % mu)\\n    print(\""Cycle: %s\"" % list(itertools.islice(iterate(f, x0), mu, mu+lam)))"
"Python","Data_Encryption_Standard","Demonstrate the Data Encryption Standard. For a complete description of the algorithm see: The DES Algorithm Illustrated\\n\\nTask:\\nUse the\\nBonus (optional): add standard padding to match the C#, Java, Modula-2, Kotlin, and Phix entries, so the above encrypted result would instead be 0000000000000000A913F4CB0BD30F97.\\n\\n","#!/usr/bin/python\\n#!/usr/bin/python\\n\\n# Permutation tables and Sboxes\\nIP = (\\n    58, 50, 42, 34, 26, 18, 10, 2,\\n    60, 52, 44, 36, 28, 20, 12, 4,\\n    62, 54, 46, 38, 30, 22, 14, 6,\\n    64, 56, 48, 40, 32, 24, 16, 8,\\n    57, 49, 41, 33, 25, 17, 9,  1,\\n    59, 51, 43, 35, 27, 19, 11, 3,\\n    61, 53, 45, 37, 29, 21, 13, 5,\\n    63, 55, 47, 39, 31, 23, 15, 7\\n)\\nIP_INV = (\\n    40,  8, 48, 16, 56, 24, 64, 32,\\n    39,  7, 47, 15, 55, 23, 63, 31,\\n    38,  6, 46, 14, 54, 22, 62, 30,\\n    37,  5, 45, 13, 53, 21, 61, 29,\\n    36,  4, 44, 12, 52, 20, 60, 28,\\n    35,  3, 43, 11, 51, 19, 59, 27,\\n    34,  2, 42, 10, 50, 18, 58, 26,\\n    33,  1, 41,  9, 49, 17, 57, 25\\n)\\nPC1 = (\\n    57, 49, 41, 33, 25, 17, 9,\\n    1,  58, 50, 42, 34, 26, 18,\\n    10, 2,  59, 51, 43, 35, 27,\\n    19, 11, 3,  60, 52, 44, 36,\\n    63, 55, 47, 39, 31, 23, 15,\\n    7,  62, 54, 46, 38, 30, 22,\\n    14, 6,  61, 53, 45, 37, 29,\\n    21, 13, 5,  28, 20, 12, 4\\n)\\nPC2 = (\\n    14, 17, 11, 24, 1,  5,\\n    3,  28, 15, 6,  21, 10,\\n    23, 19, 12, 4,  26, 8,\\n    16, 7,  27, 20, 13, 2,\\n    41, 52, 31, 37, 47, 55,\\n    30, 40, 51, 45, 33, 48,\\n    44, 49, 39, 56, 34, 53,\\n    46, 42, 50, 36, 29, 32\\n)\\n\\nE  = (\\n    32, 1,  2,  3,  4,  5,\\n    4,  5,  6,  7,  8,  9,\\n    8,  9,  10, 11, 12, 13,\\n    12, 13, 14, 15, 16, 17,\\n    16, 17, 18, 19, 20, 21,\\n    20, 21, 22, 23, 24, 25,\\n    24, 25, 26, 27, 28, 29,\\n    28, 29, 30, 31, 32, 1\\n)\\n\\nSboxes = {\\n    0: (\\n        14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7,\\n        0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8,\\n        4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0,\\n        15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13\\n    ),\\n    1: (\\n        15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10,\\n        3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5,\\n        0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15,\\n        13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9 \\n    ),\\n    2: (\\n        10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8,\\n        13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1,\\n        13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7,\\n        1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12 \\n    ),\\n    3: (\\n        7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15,\\n        13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9,\\n        10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4,\\n        3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14\\n    ),\\n    4: (\\n        2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9,\\n        14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6,\\n        4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14,\\n        11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3\\n    ),\\n    5: (\\n        12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11,\\n        10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8,\\n        9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6,\\n        4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13\\n    ),\\n    6: (\\n        4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1,\\n        13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6,\\n        1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2,\\n        6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12\\n    ),\\n    7: (\\n        13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7,\\n        1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2,\\n        7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8,\\n        2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11\\n    )\\n}\\n\\nP = (\\n    16,  7, 20, 21,\\n    29, 12, 28, 17,\\n    1, 15, 23, 26,\\n    5, 18, 31, 10,\\n    2,  8, 24, 14,\\n    32, 27,  3,  9,\\n    19, 13, 30,  6,\\n    22, 11, 4,  25\\n)\\n    \\ndef encrypt(msg, key, decrypt=False):\\n    # only encrypt single blocks\\n    assert isinstance(msg, int) and isinstance(key, int)\\n    assert not msg.bit_length() > 64\\n    assert not key.bit_length() > 64\\n\\n    # permutate by table PC1\\n    key = permutation_by_table(key, 64, PC1) # 64bit -> PC1 -> 56bit\\n\\n    # split up key in two halves\\n    # generate the 16 round keys\\n    C0 = key >> 28\\n    D0 = key & (2**28-1)\\n    round_keys = generate_round_keys(C0, D0) # 56bit -> PC2 -> 48bit\\n\\n    msg_block = permutation_by_table(msg, 64, IP)\\n    L0 = msg_block >> 32\\n    R0 = msg_block & (2**32-1)\\n\\n    # apply thr round function 16 times in following scheme (feistel cipher):\\n    L_last = L0\\n    R_last = R0\\n    for i in range(1,17):\\n        if decrypt: # just use the round keys in reversed order\\n            i = 17-i\\n        L_round = R_last\\n        R_round = L_last ^ round_function(R_last, round_keys[i])\\n        L_last = L_round\\n        R_last = R_round\\n\\n    # concatenate reversed\\n    cipher_block = (R_round<<32) + L_round\\n\\n    # final permutation\\n    cipher_block = permutation_by_table(cipher_block, 64, IP_INV)\\n\\n    return cipher_block\\n\\ndef round_function(Ri, Ki):\\n    # expand Ri from 32 to 48 bit using table E\\n    Ri = permutation_by_table(Ri, 32, E)\\n\\n    # xor with round key\\n    Ri ^= Ki\\n\\n    # split Ri into 8 groups of 6 bit\\n    Ri_blocks = [((Ri & (0b111111 << shift_val)) >> shift_val) for shift_val in (42,36,30,24,18,12,6,0)]\\n\\n    # interpret each block as address for the S-boxes\\n    for i, block in enumerate(Ri_blocks):\\n        # grab the bits we need\\n        row = ((0b100000 & block) >> 4) + (0b1 & block)\\n        col = (0b011110 & block) >> 1\\n        # sboxes are stored as one-dimensional tuple, so we need to calc the index this way\\n        Ri_blocks[i] = Sboxes[i][16*row+col]\\n\\n    # pack the blocks together again by concatenating\\n    Ri_blocks = zip(Ri_blocks, (28,24,20,16,12,8,4,0))\\n    Ri = 0\\n    for block, lshift_val in Ri_blocks:\\n        Ri += (block << lshift_val)\\n\\n    # another permutation 32bit -> 32bit\\n    Ri = permutation_by_table(Ri, 32, P)\\n\\n    return Ri\\n\\ndef permutation_by_table(block, block_len, table):\\n    # quick and dirty casting to str\\n    block_str = bin(block)[2:].zfill(block_len)\\n    perm = []\\n    for pos in range(len(table)):\\n        perm.append(block_str[table[pos]-1])\\n    return int(''.join(perm), 2)\\n\\ndef generate_round_keys(C0, D0):\\n    # returns dict of 16 keys (one for each round)\\n\\n    round_keys = dict.fromkeys(range(0,17))\\n    lrot_values = (1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1)\\n\\n    # left-rotation function\\n    lrot = lambda val, r_bits, max_bits: \\\\n    (val << r_bits%max_bits) & (2**max_bits-1) | \\\\n    ((val & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))\\n\\n    # initial rotation\\n    C0 = lrot(C0, 0, 28)\\n    D0 = lrot(D0, 0, 28)\\n    round_keys[0] = (C0, D0)\\n\\n    # create 16 more different key pairs\\n    for i, rot_val in enumerate(lrot_values):\\n        i+=1\\n        Ci = lrot(round_keys[i-1][0], rot_val, 28)\\n        Di = lrot(round_keys[i-1][1], rot_val, 28)\\n        round_keys[i] = (Ci, Di)\\n\\n    # round_keys[1] for first round\\n    #           [16] for 16th round\\n    # dont need round_keys[0] anymore, remove\\n    del round_keys[0]\\n\\n    # now form the keys from concatenated CiDi 1<=i<=16 and by apllying PC2\\n    for i, (Ci, Di) in round_keys.items():\\n        Ki = (Ci << 28) + Di\\n        round_keys[i] = permutation_by_table(Ki, 56, PC2) # 56bit -> 48bit\\n\\n    return round_keys\\n\\nk = 0x0e329232ea6d0d73 # 64 bit\\nk2 = 0x133457799BBCDFF1\\nm = 0x8787878787878787\\nm2 = 0x0123456789ABCDEF\\n\\ndef prove(key, msg):\\n    print('key:       {:x}'.format(key))\\n    print('message:   {:x}'.format(msg))\\n    cipher_text = encrypt(msg, key)\\n    print('encrypted: {:x}'.format(cipher_text))\\n    plain_text = encrypt(cipher_text, key, decrypt=True)\\n    print('decrypted: {:x}'.format(plain_text))\\n\\nprove(k, m)\\nprint('----------')\\nprove(k2, m2)\\n\\n"
"Python","Date_format","\\nDisplay the   current date   in the formats of:\\n\\n","import datetime\\ntoday = datetime.date.today()\\n# This one is built in:\\nprint today.isoformat()\\n# Or use a format string for full flexibility:\\nprint today.strftime('%Y-%m-%d')"
"Python","Date_manipulation","Given the date string \""March 7 2009 7:30pm EST\"", \\noutput the time 12 hours later in any human-readable format.\\nAs extra credit, display the resulting time in a time zone different from your own.\\n\\nThe Ada way: long, type-based, clear, reliable.\\nMost of the code consists of declarations.\\nOnly standard libraries are required.\\nResult:\\nAppleScript has a built-in date class and can coerce a string to a date automatically. It also has reserved constants such as hours which are defined in the unit of seconds. There is no built-in support for time zones.\\nResult is:\\n","import datetime\\n\\ndef mt():\\n	datime1=\""March 7 2009 7:30pm EST\""\\n	formatting = \""%B %d %Y %I:%M%p \""\\n	datime2 = datime1[:-3]  # format can't handle \""EST\"" for some reason\\n	tdelta = datetime.timedelta(hours=12)		# twelve hours..\\n	s3 = datetime.datetime.strptime(datime2, formatting)\\n	datime2 = s3+tdelta\\n	print datime2.strftime(\""%B %d %Y %I:%M%p %Z\"") + datime1[-3:]\\n\\nmt()"
"Python","Day_of_the_week","A company decides that whenever Xmas falls on a Sunday they will give their workers all extra paid holidays so that, together with any public holidays, workers will not have to work the following week (between the 25th of December and the first of January).\\n\\nIn what years between 2008 and 2121 will the 25th of December be a Sunday?\\nUsing any standard date handling libraries of your programming language;\\ncompare the dates calculated with the output of other languages to discover any anomalies in the handling of dates which may be due to, for example, overflow in types used to represent dates/times similar to   y2k   type problems.\\n\\nThe program uses two ASSIST macro (XDECO,XPRNT) to keep the code as short as possible.\\n","from calendar import weekday, SUNDAY\\n\\n[year for year in range(2008, 2122) if weekday(year, 12, 25) == SUNDAY]"
"Python","Day_of_the_week","A company decides that whenever Xmas falls on a Sunday they will give their workers all extra paid holidays so that, together with any public holidays, workers will not have to work the following week (between the 25th of December and the first of January).\\n\\nIn what years between 2008 and 2121 will the 25th of December be a Sunday?\\nUsing any standard date handling libraries of your programming language;\\ncompare the dates calculated with the output of other languages to discover any anomalies in the handling of dates which may be due to, for example, overflow in types used to represent dates/times similar to   y2k   type problems.\\n\\nThe program uses two ASSIST macro (XDECO,XPRNT) to keep the code as short as possible.\\n","import datetime\\n\\n\\n# xmasIsSunday :: Int -> Bool\\ndef xmasIsSunday(y):\\n    return 6 == datetime.date(y, 12, 25).weekday()\\n\\n\\n# main :: IO ()\\ndef main():\\n    print(\\n        [y for y in enumFromTo(2008)(2121) if xmasIsSunday(y)]\\n    )\\n\\n\\n# GENERIC -------------------------------------------------\\n\\n# enumFromTo :: Int -> Int -> [Int]\\ndef enumFromTo(m):\\n    return lambda n: list(range(m, 1 + n))\\n\\n\\n# MAIN --\\nmain()"
"Python","Deal_cards_for_FreeCell","Free Cell is the solitaire card game that Paul Alfille introduced to the PLATO system in 1978. Jim Horne, at Microsoft, changed the name to FreeCell and reimplemented the game for DOS, then Windows. \\nThis version introduced 32000 numbered deals. (The FreeCell FAQ tells this history.)\\nAs the game became popular, Jim Horne disclosed the algorithm, and other implementations of FreeCell began to reproduce the Microsoft deals. \\nThese deals are numbered from 1 to 32000.\\nNewer versions from Microsoft have 1 million deals, numbered from 1 to 1000000; some implementations allow numbers outside that range.\\nThe algorithm uses this linear congruential generator from Microsoft C:\\n\\nThe algorithm follows:\\nDeals can also be checked against FreeCell solutions to 1000000 games.\\n(Summon a video solution, and it displays the initial deal.)\\nWrite a program to take a deal number and deal cards in the same order as this algorithm.\\nThe program may display the cards with ASCII, with Unicode, by drawing graphics, or any other way.\\n\\n","from sys import argv\\n\\ndef randomGenerator(seed=1):\\n    max_int32 = (1 << 31) - 1\\n    seed = seed & max_int32\\n\\n    while True:\\n        seed = (seed * 214013 + 2531011) & max_int32\\n        yield seed >> 16\\n\\ndef deal(seed):\\n    nc = 52\\n    cards = range(nc - 1, -1, -1)\\n    rnd = randomGenerator(seed)\\n    for i, r in zip(range(nc), rnd):\\n        j = (nc - 1) - r % (nc - i)\\n        cards[i], cards[j] = cards[j], cards[i]\\n    return cards\\n\\ndef show(cards):\\n    l = [\""A23456789TJQK\""[c / 4] + \""CDHS\""[c % 4] for c in cards]\\n    for i in range(0, len(cards), 8):\\n        print \"" \"", \"" \"".join(l[i : i+8])\\n\\nif __name__ == '__main__':\\n    seed = int(argv[1]) if len(argv) == 2 else 11982\\n    print \""Hand\"", seed\\n    deck = deal(seed)\\n    show(deck)"
"Python","Death_Star","Display a region that consists of a large sphere with part of a smaller sphere removed from it as a result of geometric subtraction.\\n(This will basically produce a shape like a \""death star\"".)\\n\\n\\nPrimitive ray tracing.\\nThe output is the same of the C version.\\n\\nLayer circles and gradients to achieve result similar to that of the Wikipedia page for the Death Star.\\nRez a box on the ground, raise it up a few meters, add the following as a New Script.\\nOutput:\\n\\nWrites a PGM to stdout.\\n\\n\\nwrite an image in BMP format:\\nCreate the death star image:\\n\\n\\n(Apologies for the comments making the lines so wide, but it was easier to read and compare to the original   D   source.)\\noutput\\nOutputs:\\n(it's the best I could do!)\\nWrites a PGM to stdout.\\nNote that this code has a significant amount of refactoring relative to the C version, including the addition of specular reflections and the separation of the scene code from the raytracing from the rendering.\\nOutput:\\nTo render it as an image, we just supply different code to map the intensities to displayable values:\\n","import sys, math, collections\\n\\nSphere = collections.namedtuple(\""Sphere\"", \""cx cy cz r\"")\\nV3 = collections.namedtuple(\""V3\"", \""x y z\"")\\n\\ndef normalize((x, y, z)):\\n    len = math.sqrt(x**2 + y**2 + z**2)\\n    return V3(x / len, y / len, z / len)\\n\\ndef dot(v1, v2):\\n    d = v1.x*v2.x + v1.y*v2.y + v1.z*v2.z\\n    return -d if d < 0 else 0.0\\n\\ndef hit_sphere(sph, x0, y0):\\n    x = x0 - sph.cx\\n    y = y0 - sph.cy\\n    zsq = sph.r ** 2 - (x ** 2 + y ** 2)\\n    if zsq < 0:\\n        return (False, 0, 0)\\n    szsq = math.sqrt(zsq)\\n    return (True, sph.cz - szsq, sph.cz + szsq)\\n\\ndef draw_sphere(k, ambient, light):\\n    shades = \"".:!*oe&#%@\""\\n    pos = Sphere(20.0, 20.0, 0.0, 20.0)\\n    neg = Sphere(1.0, 1.0, -6.0, 20.0)\\n\\n    for i in xrange(int(math.floor(pos.cy - pos.r)),\\n                    int(math.ceil(pos.cy + pos.r) + 1)):\\n        y = i + 0.5\\n        for j in xrange(int(math.floor(pos.cx - 2 * pos.r)),\\n                        int(math.ceil(pos.cx + 2 * pos.r) + 1)):\\n            x = (j - pos.cx) / 2.0 + 0.5 + pos.cx\\n\\n            (h, zb1, zb2) = hit_sphere(pos, x, y)\\n            if not h:\\n                hit_result = 0\\n            else:\\n                (h, zs1, zs2) = hit_sphere(neg, x, y)\\n                if not h:\\n                    hit_result = 1\\n                elif zs1 > zb1:\\n                    hit_result = 1\\n                elif zs2 > zb2:\\n                    hit_result = 0\\n                elif zs2 > zb1:\\n                    hit_result = 2\\n                else:\\n                    hit_result = 1\\n\\n            if hit_result == 0:\\n                sys.stdout.write(' ')\\n                continue\\n            elif hit_result == 1:\\n                vec = V3(x - pos.cx, y - pos.cy, zb1 - pos.cz)\\n            elif hit_result == 2:\\n                vec = V3(neg.cx-x, neg.cy-y, neg.cz-zs2)\\n            vec = normalize(vec)\\n\\n            b = dot(light, vec) ** k + ambient\\n            intensity = int((1 - b) * len(shades))\\n            intensity = min(len(shades), max(0, intensity))\\n            sys.stdout.write(shades[intensity])\\n        print\\n\\nlight = normalize(V3(-50, 30, 50))\\ndraw_sphere(2, 0.5, light)</lang>\\n"
"Python","Decimal_floating_point_number_to_binary","Create a program that takes a decimal floating point number and displays its binary representation and vice versa: takes a floating point binary number and outputs its decimal representation.\\n\\nThe output might be something like this:\\n\\nInteractively:\\nDirectly on the command line:\\nFrom the manpage: \""To enter a negative number, begin the number with '_'. '-' cannot be used for this, as it is a binary operator for subtraction instead.\""\\n\\n","hex2bin = dict('{:x} {:04b}'.format(x,x).split() for x in range(16))\\nbin2hex = dict('{:b} {:x}'.format(x,x).split() for x in range(16))\\n\\ndef float_dec2bin(d):\\n    neg = False\\n    if d < 0:\\n        d = -d\\n        neg = True\\n    hx = float(d).hex()\\n    p = hx.index('p')\\n    bn = ''.join(hex2bin.get(char, char) for char in hx[2:p])\\n    return (('-' if neg else '') + bn.strip('0') + hx[p:p+2]\\n            + bin(int(hx[p+2:]))[2:])\\n\\ndef float_bin2dec(bn):\\n    neg = False\\n    if bn[0] == '-':\\n        bn = bn[1:]\\n        neg = True\\n    dp = bn.index('.')\\n    extra0 = '0' * (4 - (dp % 4))\\n    bn2 = extra0 + bn\\n    dp = bn2.index('.')\\n    p = bn2.index('p')\\n    hx = ''.join(bin2hex.get(bn2[i:min(i+4, p)].lstrip('0'), bn2[i])\\n                 for i in range(0, dp+1, 4))\\n    bn3 = bn2[dp+1:p]\\n    extra0 = '0' * (4 - (len(bn3) % 4))\\n    bn4 = bn3 + extra0\\n    hx += ''.join(bin2hex.get(bn4[i:i+4].lstrip('0'))\\n                  for i in range(0, len(bn4), 4))\\n    hx = (('-' if neg else '') + '0x' + hx + bn2[p:p+2]\\n          + str(int('0b' + bn2[p+2:], 2)))\\n    return float.fromhex(hx)"
"Python","Decision_tables","Decision Tables are a precise yet compact way to model complicated logic.\\n\\nDemonstrate how your language implements decision tables.\\nUse the example of Printer Troubleshooting given in the Wikipedia article.\\n\\n\\nFirst the specification of a generic decision table package:\\nNext, the implementation of the generic decision table package:\\nThat was easy! Now we implement the printer troubleshooting application:\\nSample output:\\ndecision table:Output:","\\n'''\\nCreate a Decision table then use it\\n'''\\n\\ndef dt_creator():\\n    print(\""\\n\\nCREATING THE DECISION TABLE\\n\"")\\n    conditions = input(\""Input conditions, in order, separated by commas: \"")\\n    conditions = [c.strip() for c in conditions.split(',')]\\n    print( (\""\\nThat was %s conditions:\\n  \"" % len(conditions))\\n           + '\\n  '.join(\""%i: %s\"" % x for x in enumerate(conditions, 1)) )\\n    print(\""\\nInput an action, a semicolon, then a list of tuples of rules that trigger it. End with a blank line\"")\\n    action2rules, action = [], ' '\\n    while action:\\n        action = input(\""%i: \"" % (len(action2rules) + 1)).strip()\\n        if action:\\n            name, _, rules = [x.strip() for x in action.partition(';')]\\n            rules = eval(rules)\\n            assert all(len(rule) == len(conditions) for rule in rules), \\\\n                   \""The number of conditions in a rule to trigger this action is wrong\"" \\n            action2rules.append((name, rules))\\n    actions = [x[0] for x in action2rules]\\n    # Map condition to actions\\n    rule2actions = dict((y,[]) for y in set(sum((x[1] for x in action2rules), [])))\\n    for action, rules in action2rules:\\n        for r in rules:\\n            rule2actions[r].append( action )\\n    return conditions, rule2actions\\n\\ndef dt_user(dt, default=['Pray!']):\\n    conditions, rule2actions = dt\\n    print(\""\\n\\nUSING THE DECISION TABLE\\n\"")\\n    rule = tuple(int('y' == input(\""%s? (Answer y if statement is true or n): \"" % c)) for c in conditions)\\n    print(\""Try this:\\n  \"" + '\\n  '.join(rule2actions.get(rule, default)))\\n\\nif __name__ == '__main__':\\n    dt = dt_creator()\\n    dt_user(dt)\\n    dt_user(dt)\\n    dt_user(dt)"
"Python","Deconvolution/1D","The convolution of two functions \\n\\n\\n\\n\\n\\nF\\n\\n\\n\\n\\n{\\displaystyle {\\mathit {F}}}\\n\\n and \\n\\n\\n\\n\\n\\nH\\n\\n\\n\\n\\n{\\displaystyle {\\mathit {H}}}\\n\\n of\\nan integer variable is defined as the function \\n\\n\\n\\n\\n\\nG\\n\\n\\n\\n\\n{\\displaystyle {\\mathit {G}}}\\n\\n\\nsatisfying\\nfor all integers \\n\\n\\n\\n\\n\\nn\\n\\n\\n\\n\\n{\\displaystyle {\\mathit {n}}}\\n\\n. Assume \\n\\n\\n\\nF\\n(\\nn\\n)\\n\\n\\n{\\displaystyle F(n)}\\n\\n can be non-zero only for \\n\\n\\n\\n0\\n\\n\\n{\\displaystyle 0}\\n\\n ≤ \\n\\n\\n\\n\\n\\nn\\n\\n\\n\\n\\n{\\displaystyle {\\mathit {n}}}\\n\\n ≤ \\n\\n\\n\\n\\n|\\n\\n\\n\\nF\\n\\n\\n\\n|\\n\\n\\n\\n{\\displaystyle |{\\mathit {F}}|}\\n\\n, where \\n\\n\\n\\n\\n|\\n\\n\\n\\nF\\n\\n\\n\\n|\\n\\n\\n\\n{\\displaystyle |{\\mathit {F}}|}\\n\\n is the \""length\"" of \\n\\n\\n\\n\\n\\nF\\n\\n\\n\\n\\n{\\displaystyle {\\mathit {F}}}\\n\\n, and similarly for \\n\\n\\n\\n\\n\\nG\\n\\n\\n\\n\\n{\\displaystyle {\\mathit {G}}}\\n\\n and \\n\\n\\n\\n\\n\\nH\\n\\n\\n\\n\\n{\\displaystyle {\\mathit {H}}}\\n\\n, so that the functions can be modeled as finite sequences by identifying \\n\\n\\n\\n\\nf\\n\\n0\\n\\n\\n,\\n\\nf\\n\\n1\\n\\n\\n,\\n\\nf\\n\\n2\\n\\n\\n,\\n…\\n\\n\\n{\\displaystyle f_{0},f_{1},f_{2},\\dots }\\n\\n with \\n\\n\\n\\nF\\n(\\n0\\n)\\n,\\nF\\n(\\n1\\n)\\n,\\nF\\n(\\n2\\n)\\n,\\n…\\n\\n\\n{\\displaystyle F(0),F(1),F(2),\\dots }\\n\\n, etc.\\nThen for example, values of \\n\\n\\n\\n\\n|\\n\\n\\n\\nF\\n\\n\\n\\n|\\n\\n=\\n6\\n\\n\\n{\\displaystyle |{\\mathit {F}}|=6}\\n\\n and \\n\\n\\n\\n\\n|\\n\\n\\n\\nH\\n\\n\\n\\n|\\n\\n=\\n5\\n\\n\\n{\\displaystyle |{\\mathit {H}}|=5}\\n\\n would determine the following value of \\n\\n\\n\\n\\n\\ng\\n\\n\\n\\n\\n{\\displaystyle {\\mathit {g}}}\\n\\n by definition.\\nWe can write this in matrix form as:\\nor\\nFor this task, implement a function (or method, procedure, subroutine, etc.) deconv to perform deconvolution (i.e., the inverse of convolution) by constructing and solving such a system of equations represented by the above matrix \\n\\n\\n\\nA\\n\\n\\n{\\displaystyle A}\\n\\n for \\n\\n\\n\\n\\n\\nh\\n\\n\\n\\n\\n{\\displaystyle {\\mathit {h}}}\\n\\n given \\n\\n\\n\\n\\n\\nf\\n\\n\\n\\n\\n{\\displaystyle {\\mathit {f}}}\\n\\n and \\n\\n\\n\\n\\n\\ng\\n\\n\\n\\n\\n{\\displaystyle {\\mathit {g}}}\\n\\n.\\n\\nh = [-8,-9,-3,-1,-6,7]\\nf = [-3,-6,-1,8,-6,3,-1,-9,-9,3,-2,5,2,-2,-7,-1]\\ng = [24,75,71,-34,3,22,-45,23,245,25,52,25,-67,-96,96,31,55,36,29,-43,-7]\\n\\nAs several others, this is a translation of the D solution.\\n","def ToReducedRowEchelonForm( M ):\\n    if not M: return\\n    lead = 0\\n    rowCount = len(M)\\n    columnCount = len(M[0])\\n    for r in range(rowCount):\\n        if lead >= columnCount:\\n            return\\n        i = r\\n        while M[i][lead] == 0:\\n            i += 1\\n            if i == rowCount:\\n                i = r\\n                lead += 1\\n                if columnCount == lead:\\n                    return\\n        M[i],M[r] = M[r],M[i]\\n        lv = M[r][lead]\\n        M[r] = [ mrx / lv for mrx in M[r]]\\n        for i in range(rowCount):\\n            if i != r:\\n                lv = M[i][lead]\\n                M[i] = [ iv - lv*rv for rv,iv in zip(M[r],M[i])]\\n        lead += 1\\n    return M\\n \\ndef pmtx(mtx):\\n    print ('\\n'.join(''.join(' %4s' % col for col in row) for row in mtx))\\n \\ndef convolve(f, h):\\n    g = [0] * (len(f) + len(h) - 1)\\n    for hindex, hval in enumerate(h):\\n        for findex, fval in enumerate(f):\\n            g[hindex + findex] += fval * hval\\n    return g\\n\\ndef deconvolve(g, f):\\n    lenh = len(g) - len(f) + 1\\n    mtx = [[0 for x in range(lenh+1)] for y in g]\\n    for hindex in range(lenh):\\n        for findex, fval in enumerate(f):\\n            gindex = hindex + findex\\n            mtx[gindex][hindex] = fval\\n    for gindex, gval in enumerate(g):        \\n        mtx[gindex][lenh] = gval\\n    ToReducedRowEchelonForm( mtx )\\n    return [mtx[i][lenh] for i in range(lenh)]  # h\\n\\nif __name__ == '__main__':\\n    h = [-8,-9,-3,-1,-6,7]\\n    f = [-3,-6,-1,8,-6,3,-1,-9,-9,3,-2,5,2,-2,-7,-1]\\n    g = [24,75,71,-34,3,22,-45,23,245,25,52,25,-67,-96,96,31,55,36,29,-43,-7]\\n    assert convolve(f,h) == g\\n    assert deconvolve(g, f) == h"
"Python","Deepcopy","Demonstrate how to copy data structures containing complex heterogeneous and cyclic semantics.\\nThis is often referred to as deep copying, and is normally required where structures are mutable and to ensure that independent copies can be manipulated without side-effects.\\nIf this facility is not built into the language, it is permissible to use functions from a common library, or a coded procedure.\\n\\nThe task should show:\\n\\n","import copy\\ndeepcopy_of_obj = copy.deepcopy(obj)"
"Python","Define_a_primitive_data_type","Demonstrate how to define a type that behaves like an integer but has a lowest valid value of 1 and a highest valid value of 10. Include all bounds checking you need to write, or explain how the compiler or interpreter creates those bounds checks for you.\\nThe compiler identifies the range of valid values from the range specification 1..10 and automatically builds in bounds checking where it is needed. The compiler is smart enough to omit bounds checking when it is not needed.\\nThe compiler will omit bounds checking for the assignment of A to B above because both values are of My_Type. A cannot hold a value outside the range of 1..10, therefore the assignment cannot produce an out of bounds result.\\nBounded data types are not part of standard ALGOL 68, but can be implemented.\\nOutput:\\nAs of February 2009 no open source libraries to do this task have been located.\\nThis class relies on implicit conversions to do most int operations; however the combined operations with assignment have to be coded explicitly.\\nUse proxy on java.lang.Number so it can be used in Clojure's math operations.\\n",">>> class num(int):\\n    def __init__(self, b):\\n        if 1 <= b <= 10:\\n            return int.__init__(self+0)\\n        else:\\n            raise ValueError,\""Value %s should be >=0 and <= 10\"" % b\\n\\n        \\n>>> x = num(3)\\n>>> x = num(11)\\n\\nTraceback (most recent call last):\\n  File \""<pyshell#394>\"", line 1, in <module>\\n    x = num(11)\\n  File \""<pyshell#392>\"", line 6, in __init__\\n    raise ValueError,\""Value %s should be >=0 and <= 10\"" % b\\nValueError: Value 11 should be >=0 and <= 10\\n>>> x\\n3\\n>>> type(x)\\n\\n>>>"
"Python","Delegates","A delegate is a helper object used by another object. The delegator may send the delegate certain messages, and provide a default implementation when there is no delegate or the delegate does not respond to a message. This pattern is heavily used in Cocoa framework on Mac OS X. See also wp:Delegation pattern.\\nObjects responsibilities:\\nDelegator:\\nDelegate:\\nShow how objects are created and used. First, without a delegate, then with a delegate that does not implement \""thing\"", and last with a delegate that implements \""thing\"".\\nAll that is needed in order to implement this is a common base type. The delegator holds a pointer to an \""untyped\"" object from the base class. Querying if the target implements the delegate interface is done using run-time type identification.\\nSample output:\\nAs Algol 68 doesn't have classes, we supply a non-OO approximation, similar to the C version.\\n","class Delegator:\\n   def __init__(self):\\n      self.delegate = None\\n   def operation(self):\\n       if hasattr(self.delegate, 'thing') and callable(self.delegate.thing):\\n          return self.delegate.thing()\\n       return 'default implementation'\\n\\nclass Delegate:\\n   def thing(self):\\n      return 'delegate implementation'\\n\\nif __name__ == '__main__':\\n\\n   # No delegate\\n   a = Delegator()\\n   assert a.operation() == 'default implementation'\\n\\n   # With a delegate that does not implement \""thing\""\\n   a.delegate = 'A delegate may be any object'\\n   assert a.operation() == 'default implementation'\\n\\n   # With delegate that implements \""thing\""\\n   a.delegate = Delegate()\\n   assert a.operation() == 'delegate implementation'"
"Python","Delete_a_file","Delete a file called \""input.txt\"" and delete a directory called \""docs\"".\\nThis should be done twice: once \""here\"", i.e. in the current working directory and once in the filesystem root.\\n\\nThe 'drop' removes the result (true or false, indicating success or failure). It is not strictly necessary to do so, but it keeps the stack clean.\\nand then\\nNaming conventions for the file path are OS-specific. The language does not specify the encoding of the file paths, the directory separators or brackets, the file extension delimiter, the file version delimiter and syntax. The example provided works under Linux and Windows.\\nThe remove function removes either a file or a directory (the directory must be empty for this to work). Exception is thrown if this fails.\\nNote: scratch does not appear to do anything on ALGOL 68G. Also note that file names are Operating System dependent.\\nSource: DeleteFile @github by jNizM\\nAssuming we are on a Unix/Linux or at least Cygwin system:\\nSome versions of Qbasic may have had a builtin RMDIR command. However this is not documented in the manual, so we use the external MSDOS command in this example.\\nBaCon has a DELETE instruction, that accepts FILE|DIRECTORY|RECURSIVE options.\\nErrors can be caught with the CATCH GOTO label instruction (which allows RESUME from the labelled code section).\\nThe ZX Spectrum microdrive had only a main directory, and filenames did not have\\nfile extensions. Here we delete the file named INPUTTXT from the first microdrive:\\nAnd for disc drive of ZX Spectrum +3:\\nIf the names are known as constants at compile time:\\nIf the names are known only at run time:\\nISO C:\\nPOSIX:\\nTo delete files or directories in COBOL we need to use unofficial extensions. The following are built-in subroutines originally created as part of some of the COBOL products created by Micro Focus.\\nAlternate method of deleting files using the DELETE FILE statement.\\nTo delete directories we need an implementation specific extension. In clisp this is ext:delete-dir.\\nOr you can use the portability library CL-FAD:\\nPOSIX:\\nELENA 3.4 :\\nThere is no means to delete directories in ANS Forth.\\nI don't know a way of deleting directories in Fortran\\nOn most *nix systems, this must be run as sudo for the files in root to be deleted. If you don't have permissions, it will silently fail to delete those files. I would recommend against running anything you find on the internet as sudo.\\nor\\nIcon supports 'remove' for files.\\nNote Icon and Unicon accept both / and \\ for directory separators.\\nThe J standard library comes with a set of file access utilities.\\nThe function above actually uses a foreign conjunction and defined in the files library like so:\\nThis means that you can directly erase files and directories without loading the files library.\\nor\\nSynchronous\\nAsynchronous\\n","import os\\n# current directory\\nos.remove(\""output.txt\"")\\nos.rmdir(\""docs\"")\\n# root directory\\nos.remove(\""/output.txt\"")\\nos.rmdir(\""/docs\"")"
"Python","Delete_a_file","Delete a file called \""input.txt\"" and delete a directory called \""docs\"".\\nThis should be done twice: once \""here\"", i.e. in the current working directory and once in the filesystem root.\\n\\nThe 'drop' removes the result (true or false, indicating success or failure). It is not strictly necessary to do so, but it keeps the stack clean.\\nand then\\nNaming conventions for the file path are OS-specific. The language does not specify the encoding of the file paths, the directory separators or brackets, the file extension delimiter, the file version delimiter and syntax. The example provided works under Linux and Windows.\\nThe remove function removes either a file or a directory (the directory must be empty for this to work). Exception is thrown if this fails.\\nNote: scratch does not appear to do anything on ALGOL 68G. Also note that file names are Operating System dependent.\\nSource: DeleteFile @github by jNizM\\nAssuming we are on a Unix/Linux or at least Cygwin system:\\nSome versions of Qbasic may have had a builtin RMDIR command. However this is not documented in the manual, so we use the external MSDOS command in this example.\\nBaCon has a DELETE instruction, that accepts FILE|DIRECTORY|RECURSIVE options.\\nErrors can be caught with the CATCH GOTO label instruction (which allows RESUME from the labelled code section).\\nThe ZX Spectrum microdrive had only a main directory, and filenames did not have\\nfile extensions. Here we delete the file named INPUTTXT from the first microdrive:\\nAnd for disc drive of ZX Spectrum +3:\\nIf the names are known as constants at compile time:\\nIf the names are known only at run time:\\nISO C:\\nPOSIX:\\nTo delete files or directories in COBOL we need to use unofficial extensions. The following are built-in subroutines originally created as part of some of the COBOL products created by Micro Focus.\\nAlternate method of deleting files using the DELETE FILE statement.\\nTo delete directories we need an implementation specific extension. In clisp this is ext:delete-dir.\\nOr you can use the portability library CL-FAD:\\nPOSIX:\\nELENA 3.4 :\\nThere is no means to delete directories in ANS Forth.\\nI don't know a way of deleting directories in Fortran\\nOn most *nix systems, this must be run as sudo for the files in root to be deleted. If you don't have permissions, it will silently fail to delete those files. I would recommend against running anything you find on the internet as sudo.\\nor\\nIcon supports 'remove' for files.\\nNote Icon and Unicon accept both / and \\ for directory separators.\\nThe J standard library comes with a set of file access utilities.\\nThe function above actually uses a foreign conjunction and defined in the files library like so:\\nThis means that you can directly erase files and directories without loading the files library.\\nor\\nSynchronous\\nAsynchronous\\n","import shutil\\nshutil.rmtree(\""docs\"")"
"Python","Deming's_Funnel","W Edwards Deming was an American statistician and management guru who used physical demonstrations to illuminate his teachings. In one demonstration Deming repeatedly dropped marbles through a funnel at a target, marking where they landed, and observing the resulting pattern. He applied a sequence of \""rules\"" to try to improve performance. In each case the experiment begins with the funnel positioned directly over the target.\\nApply the four rules to the set of 50 pseudorandom displacements provided (e.g in the Racket solution) for the dxs and dys. Output: calculate the mean and standard-deviations of the resulting x and y values for each rule.\\nNote that rules 2, 3, and 4 give successively worse results. Trying to deterministically compensate for a random process is counter-productive, but -- according to Deming -- quite a popular pastime: see the Further Information, below for examples.\\nStretch goal 1: Generate fresh pseudorandom data. The radial displacement of the drop from the funnel position is given by a Gaussian distribution (standard deviation is 1.0) and the angle of displacement is uniformly distributed.\\nStretch goal 2: Show scatter plots of all four results.\\n\\n","import math \\n\\ndxs = [-0.533, 0.27, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275, 1.251,\\n       -0.231, -0.401, 0.269, 0.491, 0.951, 1.15, 0.001, -0.382, 0.161, 0.915,\\n       2.08, -2.337, 0.034, -0.126, 0.014, 0.709, 0.129, -1.093, -0.483, -1.193, \\n       0.02, -0.051, 0.047, -0.095, 0.695, 0.34, -0.182, 0.287, 0.213, -0.423,\\n       -0.021, -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315, 0.201, \\n       0.034, 0.097, -0.17, 0.054, -0.553, -0.024, -0.181, -0.7, -0.361, -0.789,\\n       0.279, -0.174, -0.009, -0.323, -0.658, 0.348, -0.528, 0.881, 0.021, -0.853,\\n       0.157, 0.648, 1.774, -1.043, 0.051, 0.021, 0.247, -0.31, 0.171, 0.0, 0.106,\\n       0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017, 0.281, -0.749,\\n       -0.149, -2.436, -0.909, 0.394, -0.113, -0.598, 0.443, -0.521, -0.799, \\n       0.087]\\n\\ndys = [0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395, 0.49, -0.682,\\n       -0.065, 0.242, -0.288, 0.658, 0.459, 0.0, 0.426, 0.205, -0.765, -2.188, \\n       -0.742, -0.01, 0.089, 0.208, 0.585, 0.633, -0.444, -0.351, -1.087, 0.199,\\n       0.701, 0.096, -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007, \\n       0.009, 0.508, -0.79, 0.723, 0.881, -0.508, 0.393, -0.226, 0.71, 0.038, \\n       -0.217, 0.831, 0.48, 0.407, 0.447, -0.295, 1.126, 0.38, 0.549, -0.445, \\n       -0.046, 0.428, -0.074, 0.217, -0.822, 0.491, 1.347, -0.141, 1.23, -0.044, \\n       0.079, 0.219, 0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104, \\n       -0.729, 0.65, -1.103, 0.154, -1.72, 0.051, -0.385, 0.477, 1.537, -0.901, \\n       0.939, -0.411, 0.341, -0.411, 0.106, 0.224, -0.947, -1.424, -0.542, -1.032]\\n\\ndef funnel(dxs, rule):\\n    x, rxs = 0, []\\n    for dx in dxs:\\n        rxs.append(x + dx)\\n        x = rule(x, dx)\\n    return rxs\\n\\ndef mean(xs): return sum(xs) / len(xs)\\n\\ndef stddev(xs):\\n    m = mean(xs)\\n    return math.sqrt(sum((x-m)**2 for x in xs) / len(xs))\\n\\ndef experiment(label, rule):\\n    rxs, rys = funnel(dxs, rule), funnel(dys, rule)\\n    print label\\n    print 'Mean x, y    : %.4f, %.4f' % (mean(rxs), mean(rys))\\n    print 'Std dev x, y : %.4f, %.4f' % (stddev(rxs), stddev(rys))\\n    print\\n\\n\\nexperiment('Rule 1:', lambda z, dz: 0)\\nexperiment('Rule 2:', lambda z, dz: -dz)\\nexperiment('Rule 3:', lambda z, dz: -(z+dz))\\nexperiment('Rule 4:', lambda z, dz: z+dz)"
"Python","Deming's_Funnel","W Edwards Deming was an American statistician and management guru who used physical demonstrations to illuminate his teachings. In one demonstration Deming repeatedly dropped marbles through a funnel at a target, marking where they landed, and observing the resulting pattern. He applied a sequence of \""rules\"" to try to improve performance. In each case the experiment begins with the funnel positioned directly over the target.\\nApply the four rules to the set of 50 pseudorandom displacements provided (e.g in the Racket solution) for the dxs and dys. Output: calculate the mean and standard-deviations of the resulting x and y values for each rule.\\nNote that rules 2, 3, and 4 give successively worse results. Trying to deterministically compensate for a random process is counter-productive, but -- according to Deming -- quite a popular pastime: see the Further Information, below for examples.\\nStretch goal 1: Generate fresh pseudorandom data. The radial displacement of the drop from the funnel position is given by a Gaussian distribution (standard deviation is 1.0) and the angle of displacement is uniformly distributed.\\nStretch goal 2: Show scatter plots of all four results.\\n\\n","from random import gauss\\nfrom math import sqrt\\nfrom pprint import pprint as pp\\n\\nNMAX=50\\n\\ndef statscreator():\\n    sum_ = sum2 = n = 0\\n    def stats(x):\\n        nonlocal sum_, sum2, n\\n\\n        sum_ += x\\n        sum2 += x*x\\n        n    += 1.0\\n        return sum_/n, sqrt(sum2/n - sum_*sum_/n/n)\\n    return stats\\n\\ndef drop(target, sigma=1.0):\\n    'Drop ball at target'\\n    return gauss(target, sigma)\\n\\ndef deming(rule, nmax=NMAX):\\n    ''' Simulate Demings funnel in 1D. '''\\n    \\n    stats = statscreator()\\n    target = 0\\n    for i in range(nmax):\\n        value = drop(target)\\n        mean, sdev = stats(value)\\n        target = rule(target, value)\\n        if i == nmax - 1:\\n            return mean, sdev\\n\\ndef d1(target, value):\\n    ''' Keep Funnel over target. '''\\n\\n    return target\\n\\n\\ndef d2(target, value):\\n    ''' The new target starts at the center, 0,0 then is adjusted to\\n    be the previous target _minus_ the offset of the new drop from the\\n    previous target. '''\\n    \\n    return -value   # - (target - (target - value)) = - value\\n\\ndef d3(target, value):\\n    ''' The new target starts at the center, 0,0 then is adjusted to\\n    be the previous target _minus_ the offset of the new drop from the\\n    center, 0.0. '''\\n    \\n    return target - value\\n\\ndef d4(target, value):\\n    ''' (Dumb). The new target is where it last dropped. '''\\n    \\n    return value\\n\\n\\ndef printit(rule, trials=5):\\n    print('\\nDeming simulation. %i trials using rule %s:\\n %s'\\n          % (trials, rule.__name__.upper(), rule.__doc__))\\n    for i in range(trials):\\n        print('    Mean: %7.3f, Sdev: %7.3f' % deming(rule))\\n\\n\\nif __name__ == '__main__':\\n    rcomments = [ (d1, 'Should have smallest deviations ~1.0, and be centered on 0.0'),\\n                  (d2, 'Should be centred on 0.0 with larger deviations than D1'),\\n                  (d3, 'Should be centred on 0.0 with larger deviations than D1'),\\n                  (d4, 'Center wanders all over the place, with deviations to match!'),\\n                ]\\n    for rule, comment in rcomments:\\n        printit(rule)\\n        print('  %s\\n' % comment)"
"Python","Department_Numbers","There is a highly organized city that has decided to assign a number to each of their departments:\\n\\nEach department can have a number between 1 and 7   (inclusive).\\nThe three department numbers are to be unique (different from each other) and must add up to the number 12.\\nThe Chief of the Police doesn't like odd numbers and wants to have an even number for his department.\\n\\nWrite a program which outputs all valid combinations.\\n\\nPossible output:\\n1 2 9 \\n5 3 4\\n\\nAs noted in the Fortran sample, once the police and sanitation departments are posited, the fire department value is fixed\\n","from itertools import permutations\\n \\ndef solve():\\n    c, p, f, s = \""\\\\,Police,Fire,Sanitation\"".split(',')\\n    print(f\""{c:>3}  {p:^6} {f:^4} {s:^10}\"")\\n    c = 1\\n    for p, f, s in permutations(range(1, 8), r=3):\\n        if p + s + f == 12 and p % 2 == 0:\\n            print(f\""{c:>3}: {p:^6} {f:^4} {s:^10}\"")\\n            c += 1\\n \\nif __name__ == '__main__':\\n    solve()"
"Python","Department_Numbers","There is a highly organized city that has decided to assign a number to each of their departments:\\n\\nEach department can have a number between 1 and 7   (inclusive).\\nThe three department numbers are to be unique (different from each other) and must add up to the number 12.\\nThe Chief of the Police doesn't like odd numbers and wants to have an even number for his department.\\n\\nWrite a program which outputs all valid combinations.\\n\\nPossible output:\\n1 2 9 \\n5 3 4\\n\\nAs noted in the Fortran sample, once the police and sanitation departments are posited, the fire department value is fixed\\n","from functools import (reduce)\\nfrom operator import (add)\\n\\n\\n# options :: Int -> Int -> Int -> [(Int, Int, Int)]\\ndef options(lo, hi, total):\\n    ds = range(lo, 1 + hi)\\n    return bind(filter(lambda x: 0 == x % 2, ds))(\\n        lambda x: bind(filter(lambda d: d != x, ds))(\\n            lambda y: bind([total - (x + y)])(\\n                lambda z: [(x, y, z)] if (\\n                    z != y and z >= lo and z <= hi\\n                ) else []\\n            )\\n        )\\n    )\\n\\n\\n# TEST ----------------------------------------------------\\n\\n\\n# main :: IO ()\\ndef main():\\n    xs = options(1, 7, 12)\\n    print (('Police', 'Sanitation', 'Fire'))\\n    for tpl in xs:\\n        print (tpl)\\n    print ('\\nNo. of options: ' + str(len(xs)))\\n\\n\\n# GENERIC ABSTRACTION -------------------------------------\\n\\n# bind (>>=) :: [a] -> (a -> [b]) -> [b]\\ndef bind(xs):\\n    return lambda f: reduce(add, map(f, xs), [])\\n\\n\\nmain()"
"Python","Detect_division_by_zero","Write a function to detect a   divide by zero error   without checking if the denominator is zero.\\n\\nDivision by zero results in the value \""Inf\"":\\n","def div_check(x, y):\\n  try:\\n    x / y\\n  except ZeroDivisionError:\\n    return True\\n  else:\\n    return False"
"Python","Determinant_and_permanent","For a given matrix, return the determinant and the permanent of the matrix.\\nThe determinant is given by\\nwhile the permanent is given by\\nIn both cases the sum is over the permutations \\n\\n\\n\\nσ\\n\\n\\n{\\displaystyle \\sigma }\\n\\n of the permutations of 1, 2, ..., n. (A permutation's sign is 1 if there are an even number of inversions and -1 otherwise; see parity of a permutation.)\\nMore efficient algorithms for the determinant are known: LU decomposition, see for example wp:LU decomposition#Computing the determinant. Efficient methods for calculating the permanent are not known.\\n\\n\\nFor maximum compatibility, this program uses only the basic instruction set (S/360)\\nand two ASSIST macros (XDECO,XPRNT) to keep it as short as possible.\\nIt works on OS/360 family (MVS,z/OS), on DOS/360 family (z/VSE) use GETVIS,FREEVIS instead of GETMAIN,FREEMAIN.\\n","from itertools import permutations\\nfrom operator import mul\\nfrom math import fsum\\nfrom spermutations import spermutations\\n\\ndef prod(lst):\\n    return reduce(mul, lst, 1)\\n\\ndef perm(a):\\n    n = len(a)\\n    r = range(n)\\n    s = permutations(r)\\n    return fsum(prod(a[i][sigma[i]] for i in r) for sigma in s)\\n\\ndef det(a):\\n    n = len(a)\\n    r = range(n)\\n    s = spermutations(n)\\n    return fsum(sign * prod(a[i][sigma[i]] for i in r)\\n                for sigma, sign in s)\\n\\nif __name__ == '__main__':\\n    from pprint import pprint as pp\\n\\n    for a in ( \\n            [\\n             [1, 2], \\n             [3, 4]], \\n\\n            [\\n             [1, 2, 3, 4],\\n             [4, 5, 6, 7],\\n             [7, 8, 9, 10],\\n             [10, 11, 12, 13]],        \\n\\n            [\\n             [ 0,  1,  2,  3,  4],\\n             [ 5,  6,  7,  8,  9],\\n             [10, 11, 12, 13, 14],\\n             [15, 16, 17, 18, 19],\\n             [20, 21, 22, 23, 24]],\\n        ):\\n        print('')\\n        pp(a)\\n        print('Perm: %s Det: %s' % (perm(a), det(a)))"
"Python","Determine_if_a_string_is_numeric","Create a boolean function which takes in a string and tells whether it is a numeric string (floating point and negative numbers included) in the syntax the language uses for numeric literals or numbers converted from strings.\\n\\nThe first file is the package interface containing the declaration of the Is_Numeric function.\\nThe second file is the package body containing the implementation of the Is_Numeric function.\\nThe last file shows how the Is_Numeric function can be called.\\n","def is_numeric(s):\\n    try:\\n        float(s)\\n        return True\\n    except (ValueError, TypeError):\\n        return False\\n\\nis_numeric('123.0')"
"Python","Determine_if_a_string_is_numeric","Create a boolean function which takes in a string and tells whether it is a numeric string (floating point and negative numbers included) in the syntax the language uses for numeric literals or numbers converted from strings.\\n\\nThe first file is the package interface containing the declaration of the Is_Numeric function.\\nThe second file is the package body containing the implementation of the Is_Numeric function.\\nThe last file shows how the Is_Numeric function can be called.\\n","'123'.isdigit()"
"Python","Determine_if_a_string_is_numeric","Create a boolean function which takes in a string and tells whether it is a numeric string (floating point and negative numbers included) in the syntax the language uses for numeric literals or numbers converted from strings.\\n\\nThe first file is the package interface containing the declaration of the Is_Numeric function.\\nThe second file is the package body containing the implementation of the Is_Numeric function.\\nThe last file shows how the Is_Numeric function can be called.\\n","def is_numeric(literal):\\n    \""\""\""Return whether a literal can be parsed as a numeric value\""\""\""\\n    castings = [int, float, complex,\\n        lambda s: int(s,2),  #binary\\n        lambda s: int(s,8),  #octal\\n        lambda s: int(s,16)] #hex\\n    for cast in castings:\\n        try:\\n            cast(literal)\\n            return True\\n        except ValueError:\\n            pass\\n    return False"
"Python","Determine_if_a_string_is_numeric","Create a boolean function which takes in a string and tells whether it is a numeric string (floating point and negative numbers included) in the syntax the language uses for numeric literals or numbers converted from strings.\\n\\nThe first file is the package interface containing the declaration of the Is_Numeric function.\\nThe second file is the package body containing the implementation of the Is_Numeric function.\\nThe last file shows how the Is_Numeric function can be called.\\n","def numeric(literal):\\n    \""\""\""Return value of numeric literal or None if can't parse a value\""\""\""\\n    castings = [int, float, complex,\\n        lambda s: int(s,2),  #binary\\n        lambda s: int(s,8),  #octal\\n        lambda s: int(s,16)] #hex\\n    for cast in castings:\\n        try:\\n            return cast(literal)\\n        except ValueError:\\n            pass\\n    return None\\n\\n\\ntests = [\\n    '0', '0.', '00', '123', '0123', '+123', '-123', '-123.', '-123e-4', '-.8E-04',\\n    '0.123', '(5)', '-123+4.5j', '0b0101', ' +0B101 ', '0o123', '-0xABC', '0x1a1',\\n    '12.5%', '1/2', '½', '3¼', 'π', 'Ⅻ', '1,000,000', '1 000', '- 001.20e+02', \\n    'NaN', 'inf', '-Infinity']\\n\\nfor s in tests:\\n    print(\""%14s -> %-14s %-20s is_numeric: %-5s  str.isnumeric: %s\"" % (\\n        '\""'+s+'\""', numeric(s), type(numeric(s)), is_numeric(s), s.isnumeric() ))"
"Python","Determine_if_only_one_instance_is_running","This task is to determine if there is only one instance of an application running. If the program discovers that an instance of it is already running, then it should display a message indicating that it is already running and exit.\\nThe following solution tries to open a file for reading. If the file does not exist, a 'Name_Error' is raised. The exception handler creates that file, allows the program to perform its task, and, eventually, makes sure the file is deleted. If no exception is raised, the file exists, so another instance is running, and the program stops. It also stops if the wrong exception is raised, i.e., any exception other than 'Name_Error'.\\nNote that there is a race condition: If another instance tries to open the file for reading, before the first one has created it, then more than one instance will actually run.\\nAutoHotkey has a #SingleInstance command. If you run two scripts that don't have it at the same time, it alerts the user. #SingleInstance FORCE closes the older instance when a newer one is run, and #SingleInstance IGNORE does nothing when you try to open a new instance of an already-running script.\\nChange 'UniqueLockName' to something more likely to be unique, such as a GUID.\\nThis solution opens ~/rosetta-code-lock and uses fcntl() to set a write lock on the file. Only one instance can set this lock. If fcntl() fails, this program assumes that another instance is running. This program always clears its lock when it terminates.\\nThe user might use an interrupt or other signal to terminate the program. If so, the lock file survives, but the system still clears the lock. The user can run the program again.\\nNote that the underlying file system needs to support file locking; for example if ~/ directory is on a NFS mounted partition, success in a locking fcntl() call is not always meaningful.\\nThis solution opens a file with O_CREAT|O_EXCL. If the file already exists, this program assumes that another instance is running. This solution is not as good as file locking, because the program might terminate without deleting the file.\\nThe program, when terminating, must be sure to unlink() the file. This example has unlink() at two places: at the end of main(), and at a SIGINT handler. If you interrupt the program, it will probably delete /tmp/MyUniqueName, but not if SIGINT wins a race before the program installs its handler. If you terminate the program with a different signal, then you will get stuck, because /tmp/MyUniqueName will still exist, preventing another execution of the program. One might add code to catch some other signals, but there is no way to catch SIGKILL!\\nThis program uses a regular file, with open() and unlink(). There is an older version that uses a semaphore, with sem_open() and sem_unlink(). The switch from a semaphore to a regular file was easy, because the program never used the semaphore as a semaphore; it only checked the existence of a semaphore. If you get stuck, rm /tmp/MyUniqueName might be easier than deleting a semaphore.\\nThis line needs to be near the top of the file (or in stdafx.h, if you use one.)\\nYou need a variable of type HANDLE with the same lifetime as your program. Perhaps as a member of your CWinApp object.\\nAt the earliest possible point in your program, you need to initialize it and perform your check. \""MyApp\"" should be a string unique to your application. See here for full details.\\nFinally, near the end of your program, you need to close the mutex.\\nFrom the Erlang shell, or in a program, register the application process. If this works, the process is the only one.\\n","import __main__, os\\n\\ndef isOnlyInstance():\\n    # Determine if there are more than the current instance of the application\\n    # running at the current time.\\n    return os.system(\""(( $(ps -ef | grep python | grep '[\"" +\\n                     __main__.__file__[0] + \""]\"" + __main__.__file__[1:] +\\n                     \""' | wc -l) > 1 ))\"") != 0"
"Python","Determine_if_two_triangles_overlap","Determine which of these pairs of triangles overlap in 2D:\\nOptionally, see what the result is when only a single corner is in contact (there is no definitively correct answer):\\n","from __future__ import print_function\\nimport numpy as np\\n\\ndef CheckTriWinding(tri, allowReversed):\\n	trisq = np.ones((3,3))\\n	trisq[:,0:2] = np.array(tri)\\n	detTri = np.linalg.det(trisq)\\n	if detTri < 0.0:\\n		if allowReversed:\\n			a = trisq[2,:].copy()\\n			trisq[2,:] = trisq[1,:]\\n			trisq[1,:] = a\\n		else: raise ValueError(\""triangle has wrong winding direction\"")\\n	return trisq\\n\\ndef TriTri2D(t1, t2, eps = 0.0, allowReversed = False, onBoundary = True):\\n	#Trangles must be expressed anti-clockwise\\n	t1s = CheckTriWinding(t1, allowReversed)\\n	t2s = CheckTriWinding(t2, allowReversed)\\n\\n	if onBoundary:\\n		#Points on the boundary are considered as colliding\\n		chkEdge = lambda x: np.linalg.det(x) < eps\\n	else:\\n		#Points on the boundary are not considered as colliding\\n		chkEdge = lambda x: np.linalg.det(x) <= eps\\n\\n	#For edge E of trangle 1,\\n	for i in range(3):\\n		edge = np.roll(t1s, i, axis=0)[:2,:]\\n\\n		#Check all points of trangle 2 lay on the external side of the edge E. If\\n		#they do, the triangles do not collide.\\n		if (chkEdge(np.vstack((edge, t2s[0]))) and\\n			chkEdge(np.vstack((edge, t2s[1]))) and  \\n			chkEdge(np.vstack((edge, t2s[2])))):\\n			return False\\n\\n	#For edge E of trangle 2,\\n	for i in range(3):\\n		edge = np.roll(t2s, i, axis=0)[:2,:]\\n\\n		#Check all points of trangle 1 lay on the external side of the edge E. If\\n		#they do, the triangles do not collide.\\n		if (chkEdge(np.vstack((edge, t1s[0]))) and\\n			chkEdge(np.vstack((edge, t1s[1]))) and  \\n			chkEdge(np.vstack((edge, t1s[2])))):\\n			return False\\n\\n	#The triangles collide\\n	return True\\n\\nif __name__==\""__main__\"":\\n	t1 = [[0,0],[5,0],[0,5]]\\n	t2 = [[0,0],[5,0],[0,6]]\\n	print (TriTri2D(t1, t2), True)\\n\\n	t1 = [[0,0],[0,5],[5,0]]\\n	t2 = [[0,0],[0,6],[5,0]]\\n	print (TriTri2D(t1, t2, allowReversed = True), True)\\n\\n	t1 = [[0,0],[5,0],[0,5]]\\n	t2 = [[-10,0],[-5,0],[-1,6]]\\n	print (TriTri2D(t1, t2), False)\\n\\n	t1 = [[0,0],[5,0],[2.5,5]]\\n	t2 = [[0,4],[2.5,-1],[5,4]]\\n	print (TriTri2D(t1, t2), True)\\n\\n	t1 = [[0,0],[1,1],[0,2]]\\n	t2 = [[2,1],[3,0],[3,2]]\\n	print (TriTri2D(t1, t2), False)\\n\\n	t1 = [[0,0],[1,1],[0,2]]\\n	t2 = [[2,1],[3,-2],[3,4]]\\n	print (TriTri2D(t1, t2), False)\\n\\n	#Barely touching\\n	t1 = [[0,0],[1,0],[0,1]]\\n	t2 = [[1,0],[2,0],[1,1]]\\n	print (TriTri2D(t1, t2, onBoundary = True), True)\\n\\n	#Barely touching\\n	t1 = [[0,0],[1,0],[0,1]]\\n	t2 = [[1,0],[2,0],[1,1]]\\n	print (TriTri2D(t1, t2, onBoundary = False), False)"
"Python","Determine_if_two_triangles_overlap","Determine which of these pairs of triangles overlap in 2D:\\nOptionally, see what the result is when only a single corner is in contact (there is no definitively correct answer):\\n","from __future__ import print_function\\nfrom shapely.geometry import Polygon\\n\\ndef PolyOverlaps(poly1, poly2):\\n	poly1s = Polygon(poly1)\\n	poly2s = Polygon(poly2)\\n	return poly1s.intersects(poly2s)\\n\\nif __name__==\""__main__\"":\\n	t1 = [[0,0],[5,0],[0,5]]\\n	t2 = [[0,0],[5,0],[0,6]]\\n	print (PolyOverlaps(t1, t2), True)\\n \\n	t1 = [[0,0],[0,5],[5,0]]\\n	t2 = [[0,0],[0,6],[5,0]]\\n	print (PolyOverlaps(t1, t2), True)\\n \\n	t1 = [[0,0],[5,0],[0,5]]\\n	t2 = [[-10,0],[-5,0],[-1,6]]\\n	print (PolyOverlaps(t1, t2), False)\\n \\n	t1 = [[0,0],[5,0],[2.5,5]]\\n	t2 = [[0,4],[2.5,-1],[5,4]]\\n	print (PolyOverlaps(t1, t2), True)\\n \\n	t1 = [[0,0],[1,1],[0,2]]\\n	t2 = [[2,1],[3,0],[3,2]]\\n	print (PolyOverlaps(t1, t2), False)\\n \\n	t1 = [[0,0],[1,1],[0,2]]\\n	t2 = [[2,1],[3,-2],[3,4]]\\n	print (PolyOverlaps(t1, t2), False)\\n \\n	#Barely touching\\n	t1 = [[0,0],[1,0],[0,1]]\\n	t2 = [[1,0],[2,0],[1,1]]\\n	print (PolyOverlaps(t1, t2), \""?\"")"
"Python","Dice_game_probabilities","Two players have a set of dice each. The first player has nine dice with four faces each, with numbers one to four. The second player has six normal dice with six faces each, each face has the usual numbers from one to six.\\nThey roll their dice and sum the totals of the faces. The player with the highest total wins (it's a draw if the totals are the same). What's the probability of the first player beating the second player?\\nLater the two players use a different set of dice each. Now the first player has five dice with ten faces each, and the second player has six dice with seven faces each. Now what's the probability of the first player beating the second player?\\nThis task was adapted from the Project Euler Problem n.205:\\nhttps://projecteuler.net/problem=205\\n","from itertools import product\\n\\ndef gen_dict(n_faces, n_dice):\\n    counts = [0] * ((n_faces + 1) * n_dice)\\n    for t in product(range(1, n_faces + 1), repeat=n_dice):\\n        counts[sum(t)] += 1\\n    return counts, n_faces ** n_dice\\n\\ndef beating_probability(n_sides1, n_dice1, n_sides2, n_dice2):\\n    c1, p1 = gen_dict(n_sides1, n_dice1)\\n    c2, p2 = gen_dict(n_sides2, n_dice2)\\n    p12 = float(p1 * p2)\\n\\n    return sum(p[1] * q[1] / p12\\n               for p, q in product(enumerate(c1), enumerate(c2))\\n               if p[0] > q[0])\\n\\nprint beating_probability(4, 9, 6, 6)\\nprint beating_probability(10, 5, 7, 6)"
"Python","Dice_game_probabilities","Two players have a set of dice each. The first player has nine dice with four faces each, with numbers one to four. The second player has six normal dice with six faces each, each face has the usual numbers from one to six.\\nThey roll their dice and sum the totals of the faces. The player with the highest total wins (it's a draw if the totals are the same). What's the probability of the first player beating the second player?\\nLater the two players use a different set of dice each. Now the first player has five dice with ten faces each, and the second player has six dice with seven faces each. Now what's the probability of the first player beating the second player?\\nThis task was adapted from the Project Euler Problem n.205:\\nhttps://projecteuler.net/problem=205\\n","from __future__ import print_function, division\\n\\ndef combos(sides, n):\\n    if not n: return [1]\\n    ret = [0] * (max(sides)*n + 1)\\n    for i,v in enumerate(combos(sides, n - 1)):\\n        if not v: continue\\n        for s in sides: ret[i + s] += v\\n    return ret\\n\\ndef winning(sides1, n1, sides2, n2):\\n    p1, p2 = combos(sides1, n1), combos(sides2, n2)\\n    win,loss,tie = 0,0,0 # 'win' is 1 beating 2\\n    for i,x1 in enumerate(p1):\\n        # using accumulated sum on p2 could save some time\\n        win += x1*sum(p2[:i])\\n        tie += x1*sum(p2[i:i+1])\\n        loss+= x1*sum(p2[i+1:])\\n    s = sum(p1)*sum(p2)\\n    return win/s, tie/s, loss/s\\n\\nprint(winning(range(1,5), 9, range(1,7), 6))\\nprint(winning(range(1,11), 5, range(1,8), 6)) # this seem hardly fair\\n\\n# mountains of dice test case\\n# print(winning((1, 2, 3, 5, 9), 700, (1, 2, 3, 4, 5, 6), 800))"
"Python","Dice_game_probabilities","Two players have a set of dice each. The first player has nine dice with four faces each, with numbers one to four. The second player has six normal dice with six faces each, each face has the usual numbers from one to six.\\nThey roll their dice and sum the totals of the faces. The player with the highest total wins (it's a draw if the totals are the same). What's the probability of the first player beating the second player?\\nLater the two players use a different set of dice each. Now the first player has five dice with ten faces each, and the second player has six dice with seven faces each. Now what's the probability of the first player beating the second player?\\nThis task was adapted from the Project Euler Problem n.205:\\nhttps://projecteuler.net/problem=205\\n","from __future__ import division, print_function\\nfrom itertools import accumulate # Python3 only\\n\\ndef combos(sides, n):\\n    ret = [1] + [0]*(n + 1)*sides # extra length for negative indices\\n    for p in range(1, n + 1):\\n        rolling_sum = 0\\n        for i in range(p*sides, p - 1, -1):\\n            rolling_sum += ret[i - sides] - ret[i]\\n            ret[i] = rolling_sum\\n        ret[p - 1] = 0\\n    return ret\\n\\ndef winning(d1, n1, d2, n2):\\n    c1, c2 = combos(d1, n1), combos(d2, n2)\\n    ac = list(accumulate(c2 + [0]*(len(c1) - len(c2))))\\n\\n    return sum(v*a for  v,a in zip(c1[1:], ac)) / (ac[-1]*sum(c1))\\n\\n\\nprint(winning(4, 9, 6, 6))\\nprint(winning(5, 10, 6, 7))\\n\\n#print(winning(6, 700, 8, 540))"
"Python","Digital_root","The digital root, \\n\\n\\n\\nX\\n\\n\\n{\\displaystyle X}\\n\\n, of a number, \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n, is calculated:\\nThe additive persistence is the number of summations required to obtain the single digit.\\nThe task is to calculate the additive persistence and the digital root of a number, e.g.:\\nThe digital root may be calculated in bases other than 10.\\n\\n\\n","def digital_root (n):\\n    ap = 0\\n    n = abs(int(n))\\n    while n >= 10:\\n        n = sum(int(digit) for digit in str(n))\\n        ap += 1\\n    return ap, n\\n\\nif __name__ == '__main__':\\n    for n in [627615, 39390, 588225, 393900588225, 55]:\\n        persistance, root = digital_root(n)\\n        print(\""%12i has additive persistance %2i and digital root %i.\"" \\n              % (n, persistance, root))"
"Python","Digital_root/Multiplicative_digital_root","The multiplicative digital root (MDR) and multiplicative persistence (MP) of a number, \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n, is calculated rather like the Digital root except digits are multiplied instead of being added:\\n\\nShow all output on this page.\\n\\n\\nThe solution uses the Package \""Generic_Root\"" from the additive digital roots [[1]].\\n","try:\\n    from functools import reduce\\nexcept:\\n    pass\\n\\ndef mdroot(n):\\n    'Multiplicative digital root'\\n    mdr = [n]\\n    while mdr[-1] > 9:\\n        mdr.append(reduce(int.__mul__, (int(dig) for dig in str(mdr[-1])), 1))\\n    return len(mdr) - 1, mdr[-1]\\n\\nif __name__ == '__main__':\\n    print('Number: (MP, MDR)\\n======  =========')\\n    for n in (123321, 7739, 893, 899998):\\n        print('%6i: %r' % (n, mdroot(n)))\\n        \\n    table, n = {i: [] for i in range(10)}, 0\\n    while min(len(row) for row in table.values()) < 5:\\n        mpersistence, mdr = mdroot(n)\\n        table[mdr].append(n)\\n        n += 1\\n    print('\\nMP: [n0..n4]\\n==  ========')\\n    for mp, val in sorted(table.items()):\\n        print('%2i: %r' % (mp, val[:5]))"
"Python","Digital_root/Multiplicative_digital_root","The multiplicative digital root (MDR) and multiplicative persistence (MP) of a number, \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n, is calculated rather like the Digital root except digits are multiplied instead of being added:\\n\\nShow all output on this page.\\n\\n\\nThe solution uses the Package \""Generic_Root\"" from the additive digital roots [[1]].\\n","def mdroot(n):\\n    count, mdr = 0, n \\n    while mdr > 9:\\n        m, digitsMul = mdr, 1\\n        while m:\\n            m, md = divmod(m, 10)\\n            digitsMul *= md\\n        mdr = digitsMul\\n        count += 1\\n    return count, mdr"
"Python","Dijkstra's_algorithm","\\nDijkstra's algorithm, conceived by Dutch computer scientist Edsger Dijkstra in 1956 and published in 1959, is a graph search algorithm that solves the single-source shortest path problem for a graph with non-negative edge path costs, producing a shortest path tree.\\nThis algorithm is often used in routing and as a subroutine in other graph algorithms.\\n\\nFor a given source vertex (node) in the graph, the algorithm finds the path with lowest cost (i.e. the shortest path) between that vertex and every other vertex.\\n\\nIf the vertices of the graph represent cities and edge path costs represent driving distances between pairs of cities connected by a direct road, Dijkstra's algorithm can be used to find the shortest route between one city and all other cities.\\nAs a result, the shortest path first is widely used in network routing protocols, most notably:\\n\\nThe inputs to Dijkstra's algorithm are a directed and weighted graph consisting of 2 or more nodes, generally represented by:\\nA destination node is not specified.\\nThe output is a set of edges depicting the shortest path to each destination node.\\n\\n\\nYou can use numbers or names to identify vertices in your program.\\n\\n\\nThis solution uses a generic package and Ada 2012 (containers, extended return statements, expression functions).\\nThe very convenient 'Img attribute is a GNAT feature.\\nThe testing main procedure :\\n","from collections import namedtuple, deque\\nfrom pprint import pprint as pp\\n\\n\\ninf = float('inf')\\nEdge = namedtuple('Edge', 'start, end, cost')\\n\\nclass Graph():\\n    def __init__(self, edges):\\n        self.edges = edges2 = [Edge(*edge) for edge in edges]\\n        self.vertices = set(sum(([e.start, e.end] for e in edges2), []))\\n\\n    def dijkstra(self, source, dest):\\n        assert source in self.vertices\\n        dist = {vertex: inf for vertex in self.vertices}\\n        previous = {vertex: None for vertex in self.vertices}\\n        dist[source] = 0\\n        q = self.vertices.copy()\\n        neighbours = {vertex: set() for vertex in self.vertices}\\n        for start, end, cost in self.edges:\\n            neighbours[start].add((end, cost))\\n        #pp(neighbours)\\n\\n        while q:\\n            u = min(q, key=lambda vertex: dist[vertex])\\n            q.remove(u)\\n            if dist[u] == inf or u == dest:\\n                break\\n            for v, cost in neighbours[u]:\\n                alt = dist[u] + cost\\n                if alt < dist[v]:                                  # Relax (u,v,a)\\n                    dist[v] = alt\\n                    previous[v] = u\\n        #pp(previous)\\n        s, u = deque(), dest\\n        while previous[u]:\\n            s.appendleft(u)\\n            u = previous[u]\\n        s.appendleft(u)\\n        return s\\n\\n\\ngraph = Graph([(\""a\"", \""b\"", 7),  (\""a\"", \""c\"", 9),  (\""a\"", \""f\"", 14), (\""b\"", \""c\"", 10),\\n               (\""b\"", \""d\"", 15), (\""c\"", \""d\"", 11), (\""c\"", \""f\"", 2),  (\""d\"", \""e\"", 6),\\n               (\""e\"", \""f\"", 9)])\\npp(graph.dijkstra(\""a\"", \""e\""))"
"Python","Dining_philosophers","The dining philosophers problem illustrates non-composability of low-level synchronization primitives like semaphores. It is a modification of a problem posed by Edsger Dijkstra.\\nFive philosophers, Aristotle, Kant, Spinoza, Marx, and Russell (the tasks) spend their time thinking and eating spaghetti. They eat at a round table with five individual seats. For eating each philosopher needs two forks (the resources). There are five forks on the table, one left and one right of each seat. When a philosopher cannot grab both forks it sits and waits. Eating takes random time, then the philosopher puts the forks down and leaves the dining room. After spending some random time thinking about the nature of the universe, he again becomes hungry, and the circle repeats itself.\\nIt can be observed that a straightforward solution, when forks are implemented by semaphores, is exposed to deadlock. There exist two deadlock states when all five philosophers are sitting at the table holding one fork each. One deadlock state is when each philosopher has grabbed the fork left of him, and another is when each has the fork on his right.\\nThere are many solutions of the problem, program at least one, and explain how the deadlock is prevented.\\nThe following solution uses an array of mutexes in order to model the forks. The forks used by a philosopher compose a subset in the array. When the the philosopher seizes his forks from the subset the array object prevents deadlocking since it is an atomic operation.\\nIn the following solution forks are implemented as plain mutexes. The deadlock is prevented by ordering mutexes. Philosopher tasks seize them in same order 1, 2, 3, 4, 5.\\nBoth deadlocks happen when all philosophers are in the dining room. The following solution has a host of the room who chatters the last philosopher while four of them are in the room. So there are never more than four of them in there, which prevents deadlock. Now the forks can be picked up in a \""wrong\"" order, i.e. the left one first.\\nAutoHotkey doesn't support concurrency, so we fake it with timers.\\nDeadlock is prevented by releasing a single fork when the other is unobtainable.\\nLivelock is prevented by randomly trying for the opposite fork first.\\nStarvation will only occur if one (or more) of the philosophers never stops eating.\\nTry changing EnoughForks to 4 and fork supply per philosopher to 2.\\n","import threading\\nimport random\\nimport time\\n\\n# Dining philosophers, 5 Phillies with 5 forks. Must have two forks to eat.\\n#\\n# Deadlock is avoided by never waiting for a fork while holding a fork (locked)\\n# Procedure is to do block while waiting to get first fork, and a nonblocking\\n# acquire of second fork.  If failed to get second fork, release first fork,\\n# swap which fork is first and which is second and retry until getting both.\\n#  \\n# See discussion page note about 'live lock'.\\n\\nclass Philosopher(threading.Thread):\\n    \\n    running = True\\n\\n    def __init__(self, xname, forkOnLeft, forkOnRight):\\n        threading.Thread.__init__(self)\\n        self.name = xname\\n        self.forkOnLeft = forkOnLeft\\n        self.forkOnRight = forkOnRight\\n\\n    def run(self):\\n        while(self.running):\\n            #  Philosopher is thinking (but really is sleeping).\\n            time.sleep( random.uniform(3,13))\\n            print '%s is hungry.' % self.name\\n            self.dine()\\n\\n    def dine(self):\\n        fork1, fork2 = self.forkOnLeft, self.forkOnRight\\n\\n        while self.running:\\n            fork1.acquire(True)\\n            locked = fork2.acquire(False)\\n            if locked: break\\n            fork1.release()\\n            print '%s swaps forks' % self.name\\n            fork1, fork2 = fork2, fork1\\n        else:\\n            return\\n\\n        self.dining()\\n        fork2.release()\\n        fork1.release()\\n\\n    def dining(self):			\\n        print '%s starts eating '% self.name\\n        time.sleep(random.uniform(1,10))\\n        print '%s finishes eating and leaves to think.' % self.name\\n\\ndef DiningPhilosophers():\\n    forks = [threading.Lock() for n in range(5)]\\n    philosopherNames = ('Aristotle','Kant','Buddha','Marx', 'Russel')\\n\\n    philosophers= [Philosopher(philosopherNames[i], forks[i%5], forks[(i+1)%5]) \\\\n            for i in range(5)]\\n\\n    random.seed(507129)\\n    Philosopher.running = True\\n    for p in philosophers: p.start()\\n    time.sleep(100)\\n    Philosopher.running = False\\n    print (\""Now we're finishing.\"")\\n\\nDiningPhilosophers()"
"Python","Discordian_date","\\nConvert a given date from the   Gregorian calendar   to the   Discordian calendar.\\n\\ndiscordian.adb:\\n","import datetime, calendar\\n\\nDISCORDIAN_SEASONS = [\""Chaos\"", \""Discord\"", \""Confusion\"", \""Bureaucracy\"", \""The Aftermath\""]\\n\\ndef ddate(year, month, day):\\n    today = datetime.date(year, month, day)\\n    is_leap_year = calendar.isleap(year)\\n    if is_leap_year and month == 2 and day == 29:\\n        return \""St. Tib's Day, YOLD \"" + (year + 1166)\\n    \\n    day_of_year = today.timetuple().tm_yday - 1\\n    \\n    if is_leap_year and day_of_year >= 60:\\n        day_of_year -= 1 # Compensate for St. Tib's Day\\n    \\n    season, dday = divmod(day_of_year, 73)\\n    return \""%s %d, YOLD %d\"" % (DISCORDIAN_SEASONS[season], dday + 1, year + 1166)\\n"
"Python","Display_a_linear_combination","Display a finite linear combination in an infinite vector basis \\n\\n\\n\\n(\\n\\ne\\n\\n1\\n\\n\\n,\\n\\ne\\n\\n2\\n\\n\\n,\\n…\\n)\\n\\n\\n{\\displaystyle (e_{1},e_{2},\\ldots )}\\n\\n.\\nWrite a function that, when given a finite list of scalars \\n\\n\\n\\n(\\n\\nα\\n\\n1\\n\\n\\n,\\n\\nα\\n\\n2\\n\\n\\n,\\n…\\n)\\n\\n\\n{\\displaystyle (\\alpha ^{1},\\alpha ^{2},\\ldots )}\\n\\n, creates a string representing the linear combination \\n\\n\\n\\n\\n∑\\n\\ni\\n\\n\\n\\nα\\n\\ni\\n\\n\\n\\ne\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle \\sum _{i}\\alpha ^{i}e_{i}}\\n\\n in an explicit format often used in mathematics, that is:\\nwhere \\n\\n\\n\\n\\nα\\n\\n\\ni\\n\\nk\\n\\n\\n\\n\\n≠\\n0\\n\\n\\n{\\displaystyle \\alpha ^{i_{k}}\\neq 0}\\n\\n\\n\\n\\nThe output must comply to the following rules:\\n\\nShow here output for the following lists of scalars:\\n\\nAccepts vector coefficients from the command line, prints usage syntax if invoked with no arguments. This implementation can handle floating point values but displays integer values as integers. All test case results shown with invocation. A multiplication sign is not shown between a coefficient and the unit vector when a vector is written out by hand ( i.e. human readable) and is thus not shown here as well.\\n","\\ndef linear(x):\\n    return ' + '.join(['{}e({})'.format('-' if v == -1 else '' if v == 1 else str(v) + '*', i + 1)\\n        for i, v in enumerate(x) if v] or ['0']).replace(' + -', ' - ')\\n\\nlist(map(lambda x: print(linear(x)), [[1, 2, 3], [0, 1, 2, 3], [1, 0, 3, 4], [1, 2, 0],\\n        [0, 0, 0], [0], [1, 1, 1], [-1, -1, -1], [-1, -2, 0, 3], [-1]]))\\n"
"Python","Distributed_programming","Write two programs (or one program with two modes) which run on networked computers, and send some messages between them.\\nThe protocol used may be language-specific or not, and should be suitable for general distributed programming; that is, the protocol should be generic (not designed just for the particular example application), readily capable of handling the independent communications of many different components of a single application, and the transferring of arbitrary data structures natural for the language.\\nThis task is intended to demonstrate high-level communication facilities beyond just creating sockets.\\nAda defines facilities for distributed systems in its standard (Annex E, also called DSA).\\nThis example works with PolyORB and the GNAT GPL 2010 compiler from AdaCore.\\nserver.ads:\\nserver.adb:\\nclient.adb:\\nrequired config (dsa.cfg):\\ncompilation:\\npreparation (run PolyORB name service):\\nYou have to set the environment variable POLYORB_DSA_NAME_SERVICE to one of the two values given by po_ioc_naming for the server/client partitions.\\nrunning server:\\nrunning client:\\nSee Distributed program/AutoHotkey.\\nUsing PVM [[1]\\nThis program is in a sense both a server and a client, depending on if its task is spawned with a command-line argument: if yes, it spawns another task of the same executible on the parallel virtual machine and waits for it to transmit data; if no, it transmits data and is done.\\nStart the program with \""server\"" parameter to start the server, and \""client\"" to start the client. The client will send data to the server and receive a response. The server will wait for data, display the data received, and send a response.\\nUses the rpc library:\\nhttps://github.com/adamdruppe/misc-stuff-including-D-programming-language-web-stuff/blob/master/rpc.d\\nThis library is not standard, so this code (by Adam D. Ruppe) could and should be rewritten using more standard means.\\nProtocol: Pluribus\\nThis service cannot be used except by clients which know the URL designating it, messages are encrypted, and the client authenticates the server. However, it is vulnerable to denial-of-service by any client knowing the URL.\\n(The protocol is symmetric; this program is the server only in that it is the one which is started first and exports an object.)\\nThis will print the URL of the service and run it until aborted.\\nThe URL provided by the server is given as the argument to this program.\\nThe protocol is erlang's own\\nsrv.erl\\nclient.erl\\nrunning it (*comes later)\\nThe protocol is the one provided by Factor (concurrency.distributed, concurrency.messaging)\\nExample summary:\\n- A server node is listening for messages made of natural data types and structures, and simply prettyprint them.\\n- A client node is sending such data structure: an array of one string and one hashtable (with one key/value pair).\\nNote: we are using QUALIFIED: with the concurrency.messaging vocabulary because the \""receive\"" word is defined in io.sockets vocabulary too. If someone have a cleaner way to handle this.\\nHow to Run:\\n- Copy/Paste the server code in an instance of Factor Listener\\n- Copy/Paste the client code in another instance of Factor Listener.\\nThe server node should prettyprint the data structure send by the client: { \""Hello Remote Factor!\"" H{ { \""key1\"" \""value1\"" } } }\\nPackage net/rpc in the Go standard library serializes data with the Go-native \""gob\"" type. The example here sends only a single floating point number, but the package will send any user-defined data type, including of course structs with multiple fields.\\nServer:\\nClient:\\n","#!/usr/bin/env python\\n# -*- coding: utf-8 -*-\\n\\nimport SimpleXMLRPCServer\\n\\nclass MyHandlerInstance:\\n    def echo(self, data):\\n        '''Method for returning data got from client'''\\n        return 'Server responded: %s' % data\\n\\n    def div(self, num1, num2):\\n        '''Method for divide 2 numbers'''\\n        return num1/num2\\n\\ndef foo_function():\\n    '''A function (not an instance method)'''\\n    return True\\n\\nHOST = \""localhost\""\\nPORT = 8000\\n\\nserver = SimpleXMLRPCServer.SimpleXMLRPCServer((HOST, PORT))\\n\\n# register built-in system.* functions.\\nserver.register_introspection_functions()\\n\\n# register our instance\\nserver.register_instance(MyHandlerInstance())\\n\\n# register our function as well\\nserver.register_function(foo_function)\\n\\ntry:\\n    # serve forever\\n    server.serve_forever()\\nexcept KeyboardInterrupt:\\n    print 'Exiting...'\\n    server.server_close()"
"Python","Distributed_programming","Write two programs (or one program with two modes) which run on networked computers, and send some messages between them.\\nThe protocol used may be language-specific or not, and should be suitable for general distributed programming; that is, the protocol should be generic (not designed just for the particular example application), readily capable of handling the independent communications of many different components of a single application, and the transferring of arbitrary data structures natural for the language.\\nThis task is intended to demonstrate high-level communication facilities beyond just creating sockets.\\nAda defines facilities for distributed systems in its standard (Annex E, also called DSA).\\nThis example works with PolyORB and the GNAT GPL 2010 compiler from AdaCore.\\nserver.ads:\\nserver.adb:\\nclient.adb:\\nrequired config (dsa.cfg):\\ncompilation:\\npreparation (run PolyORB name service):\\nYou have to set the environment variable POLYORB_DSA_NAME_SERVICE to one of the two values given by po_ioc_naming for the server/client partitions.\\nrunning server:\\nrunning client:\\nSee Distributed program/AutoHotkey.\\nUsing PVM [[1]\\nThis program is in a sense both a server and a client, depending on if its task is spawned with a command-line argument: if yes, it spawns another task of the same executible on the parallel virtual machine and waits for it to transmit data; if no, it transmits data and is done.\\nStart the program with \""server\"" parameter to start the server, and \""client\"" to start the client. The client will send data to the server and receive a response. The server will wait for data, display the data received, and send a response.\\nUses the rpc library:\\nhttps://github.com/adamdruppe/misc-stuff-including-D-programming-language-web-stuff/blob/master/rpc.d\\nThis library is not standard, so this code (by Adam D. Ruppe) could and should be rewritten using more standard means.\\nProtocol: Pluribus\\nThis service cannot be used except by clients which know the URL designating it, messages are encrypted, and the client authenticates the server. However, it is vulnerable to denial-of-service by any client knowing the URL.\\n(The protocol is symmetric; this program is the server only in that it is the one which is started first and exports an object.)\\nThis will print the URL of the service and run it until aborted.\\nThe URL provided by the server is given as the argument to this program.\\nThe protocol is erlang's own\\nsrv.erl\\nclient.erl\\nrunning it (*comes later)\\nThe protocol is the one provided by Factor (concurrency.distributed, concurrency.messaging)\\nExample summary:\\n- A server node is listening for messages made of natural data types and structures, and simply prettyprint them.\\n- A client node is sending such data structure: an array of one string and one hashtable (with one key/value pair).\\nNote: we are using QUALIFIED: with the concurrency.messaging vocabulary because the \""receive\"" word is defined in io.sockets vocabulary too. If someone have a cleaner way to handle this.\\nHow to Run:\\n- Copy/Paste the server code in an instance of Factor Listener\\n- Copy/Paste the client code in another instance of Factor Listener.\\nThe server node should prettyprint the data structure send by the client: { \""Hello Remote Factor!\"" H{ { \""key1\"" \""value1\"" } } }\\nPackage net/rpc in the Go standard library serializes data with the Go-native \""gob\"" type. The example here sends only a single floating point number, but the package will send any user-defined data type, including of course structs with multiple fields.\\nServer:\\nClient:\\n","#!/usr/bin/env python\\n# -*- coding: utf-8 -*-\\n\\nimport xmlrpclib\\n\\nHOST = \""localhost\""\\nPORT = 8000\\n\\nrpc = xmlrpclib.ServerProxy(\""http://%s:%d\"" % (HOST, PORT))\\n\\n# print what functions does server support \\nprint 'Server supports these functions:',\\nprint ' '.join(rpc.system.listMethods())\\n\\n# echo something\\nrpc.echo(\""We sent this data to server\"")\\n\\n# div numbers\\nprint 'Server says: 8 / 4 is: %d' % rpc.div(8, 4)\\n\\n# control if foo_function returns True\\nif rpc.foo_function():\\n    print 'Server says: foo_function returned True'"
"Python","Distributed_programming","Write two programs (or one program with two modes) which run on networked computers, and send some messages between them.\\nThe protocol used may be language-specific or not, and should be suitable for general distributed programming; that is, the protocol should be generic (not designed just for the particular example application), readily capable of handling the independent communications of many different components of a single application, and the transferring of arbitrary data structures natural for the language.\\nThis task is intended to demonstrate high-level communication facilities beyond just creating sockets.\\nAda defines facilities for distributed systems in its standard (Annex E, also called DSA).\\nThis example works with PolyORB and the GNAT GPL 2010 compiler from AdaCore.\\nserver.ads:\\nserver.adb:\\nclient.adb:\\nrequired config (dsa.cfg):\\ncompilation:\\npreparation (run PolyORB name service):\\nYou have to set the environment variable POLYORB_DSA_NAME_SERVICE to one of the two values given by po_ioc_naming for the server/client partitions.\\nrunning server:\\nrunning client:\\nSee Distributed program/AutoHotkey.\\nUsing PVM [[1]\\nThis program is in a sense both a server and a client, depending on if its task is spawned with a command-line argument: if yes, it spawns another task of the same executible on the parallel virtual machine and waits for it to transmit data; if no, it transmits data and is done.\\nStart the program with \""server\"" parameter to start the server, and \""client\"" to start the client. The client will send data to the server and receive a response. The server will wait for data, display the data received, and send a response.\\nUses the rpc library:\\nhttps://github.com/adamdruppe/misc-stuff-including-D-programming-language-web-stuff/blob/master/rpc.d\\nThis library is not standard, so this code (by Adam D. Ruppe) could and should be rewritten using more standard means.\\nProtocol: Pluribus\\nThis service cannot be used except by clients which know the URL designating it, messages are encrypted, and the client authenticates the server. However, it is vulnerable to denial-of-service by any client knowing the URL.\\n(The protocol is symmetric; this program is the server only in that it is the one which is started first and exports an object.)\\nThis will print the URL of the service and run it until aborted.\\nThe URL provided by the server is given as the argument to this program.\\nThe protocol is erlang's own\\nsrv.erl\\nclient.erl\\nrunning it (*comes later)\\nThe protocol is the one provided by Factor (concurrency.distributed, concurrency.messaging)\\nExample summary:\\n- A server node is listening for messages made of natural data types and structures, and simply prettyprint them.\\n- A client node is sending such data structure: an array of one string and one hashtable (with one key/value pair).\\nNote: we are using QUALIFIED: with the concurrency.messaging vocabulary because the \""receive\"" word is defined in io.sockets vocabulary too. If someone have a cleaner way to handle this.\\nHow to Run:\\n- Copy/Paste the server code in an instance of Factor Listener\\n- Copy/Paste the client code in another instance of Factor Listener.\\nThe server node should prettyprint the data structure send by the client: { \""Hello Remote Factor!\"" H{ { \""key1\"" \""value1\"" } } }\\nPackage net/rpc in the Go standard library serializes data with the Go-native \""gob\"" type. The example here sends only a single floating point number, but the package will send any user-defined data type, including of course structs with multiple fields.\\nServer:\\nClient:\\n","#!/usr/bin/python\\n# -*- coding: utf-8 -*-\\n\\nimport BaseHTTPServer\\n\\nHOST = \""localhost\""\\nPORT = 8000\\n\\n# we just want to write own class, we replace do_GET method. This could be extended, I just added basics\\n# see; http://docs.python.org/lib/module-BaseHTTPServer.html\\nclass MyHTTPHandler(BaseHTTPServer.BaseHTTPRequestHandler):\\n    def do_GET(self):\\n        # send 200 (OK) message\\n        self.send_response(200)\\n        # send header\\n        self.send_header(\""Content-type\"", \""text/html\"")\\n        self.end_headers()\\n\\n        # send context\\n        self.wfile.write(\""<html><head><title>Our Web Title"
"Python","Distributed_programming","Write two programs (or one program with two modes) which run on networked computers, and send some messages between them.\\nThe protocol used may be language-specific or not, and should be suitable for general distributed programming; that is, the protocol should be generic (not designed just for the particular example application), readily capable of handling the independent communications of many different components of a single application, and the transferring of arbitrary data structures natural for the language.\\nThis task is intended to demonstrate high-level communication facilities beyond just creating sockets.\\nAda defines facilities for distributed systems in its standard (Annex E, also called DSA).\\nThis example works with PolyORB and the GNAT GPL 2010 compiler from AdaCore.\\nserver.ads:\\nserver.adb:\\nclient.adb:\\nrequired config (dsa.cfg):\\ncompilation:\\npreparation (run PolyORB name service):\\nYou have to set the environment variable POLYORB_DSA_NAME_SERVICE to one of the two values given by po_ioc_naming for the server/client partitions.\\nrunning server:\\nrunning client:\\nSee Distributed program/AutoHotkey.\\nUsing PVM [[1]\\nThis program is in a sense both a server and a client, depending on if its task is spawned with a command-line argument: if yes, it spawns another task of the same executible on the parallel virtual machine and waits for it to transmit data; if no, it transmits data and is done.\\nStart the program with \""server\"" parameter to start the server, and \""client\"" to start the client. The client will send data to the server and receive a response. The server will wait for data, display the data received, and send a response.\\nUses the rpc library:\\nhttps://github.com/adamdruppe/misc-stuff-including-D-programming-language-web-stuff/blob/master/rpc.d\\nThis library is not standard, so this code (by Adam D. Ruppe) could and should be rewritten using more standard means.\\nProtocol: Pluribus\\nThis service cannot be used except by clients which know the URL designating it, messages are encrypted, and the client authenticates the server. However, it is vulnerable to denial-of-service by any client knowing the URL.\\n(The protocol is symmetric; this program is the server only in that it is the one which is started first and exports an object.)\\nThis will print the URL of the service and run it until aborted.\\nThe URL provided by the server is given as the argument to this program.\\nThe protocol is erlang's own\\nsrv.erl\\nclient.erl\\nrunning it (*comes later)\\nThe protocol is the one provided by Factor (concurrency.distributed, concurrency.messaging)\\nExample summary:\\n- A server node is listening for messages made of natural data types and structures, and simply prettyprint them.\\n- A client node is sending such data structure: an array of one string and one hashtable (with one key/value pair).\\nNote: we are using QUALIFIED: with the concurrency.messaging vocabulary because the \""receive\"" word is defined in io.sockets vocabulary too. If someone have a cleaner way to handle this.\\nHow to Run:\\n- Copy/Paste the server code in an instance of Factor Listener\\n- Copy/Paste the client code in another instance of Factor Listener.\\nThe server node should prettyprint the data structure send by the client: { \""Hello Remote Factor!\"" H{ { \""key1\"" \""value1\"" } } }\\nPackage net/rpc in the Go standard library serializes data with the Go-native \""gob\"" type. The example here sends only a single floating point number, but the package will send any user-defined data type, including of course structs with multiple fields.\\nServer:\\nClient:\\n","#!/usr/bin/python\\n# -*- coding: utf-8 -*-\\n\\nimport httplib\\n\\nHOST = \""localhost\""\\nPORT = 8000\\n\\nconn = httplib.HTTPConnection(HOST, PORT)\\nconn.request(\""GET\"", \""/somefile\"")\\n\\nresponse = conn.getresponse()\\nprint 'Server Status: %d' % response.status\\n\\nprint 'Server Message: %s' % response.read()"
"Python","Distributed_programming","Write two programs (or one program with two modes) which run on networked computers, and send some messages between them.\\nThe protocol used may be language-specific or not, and should be suitable for general distributed programming; that is, the protocol should be generic (not designed just for the particular example application), readily capable of handling the independent communications of many different components of a single application, and the transferring of arbitrary data structures natural for the language.\\nThis task is intended to demonstrate high-level communication facilities beyond just creating sockets.\\nAda defines facilities for distributed systems in its standard (Annex E, also called DSA).\\nThis example works with PolyORB and the GNAT GPL 2010 compiler from AdaCore.\\nserver.ads:\\nserver.adb:\\nclient.adb:\\nrequired config (dsa.cfg):\\ncompilation:\\npreparation (run PolyORB name service):\\nYou have to set the environment variable POLYORB_DSA_NAME_SERVICE to one of the two values given by po_ioc_naming for the server/client partitions.\\nrunning server:\\nrunning client:\\nSee Distributed program/AutoHotkey.\\nUsing PVM [[1]\\nThis program is in a sense both a server and a client, depending on if its task is spawned with a command-line argument: if yes, it spawns another task of the same executible on the parallel virtual machine and waits for it to transmit data; if no, it transmits data and is done.\\nStart the program with \""server\"" parameter to start the server, and \""client\"" to start the client. The client will send data to the server and receive a response. The server will wait for data, display the data received, and send a response.\\nUses the rpc library:\\nhttps://github.com/adamdruppe/misc-stuff-including-D-programming-language-web-stuff/blob/master/rpc.d\\nThis library is not standard, so this code (by Adam D. Ruppe) could and should be rewritten using more standard means.\\nProtocol: Pluribus\\nThis service cannot be used except by clients which know the URL designating it, messages are encrypted, and the client authenticates the server. However, it is vulnerable to denial-of-service by any client knowing the URL.\\n(The protocol is symmetric; this program is the server only in that it is the one which is started first and exports an object.)\\nThis will print the URL of the service and run it until aborted.\\nThe URL provided by the server is given as the argument to this program.\\nThe protocol is erlang's own\\nsrv.erl\\nclient.erl\\nrunning it (*comes later)\\nThe protocol is the one provided by Factor (concurrency.distributed, concurrency.messaging)\\nExample summary:\\n- A server node is listening for messages made of natural data types and structures, and simply prettyprint them.\\n- A client node is sending such data structure: an array of one string and one hashtable (with one key/value pair).\\nNote: we are using QUALIFIED: with the concurrency.messaging vocabulary because the \""receive\"" word is defined in io.sockets vocabulary too. If someone have a cleaner way to handle this.\\nHow to Run:\\n- Copy/Paste the server code in an instance of Factor Listener\\n- Copy/Paste the client code in another instance of Factor Listener.\\nThe server node should prettyprint the data structure send by the client: { \""Hello Remote Factor!\"" H{ { \""key1\"" \""value1\"" } } }\\nPackage net/rpc in the Go standard library serializes data with the Go-native \""gob\"" type. The example here sends only a single floating point number, but the package will send any user-defined data type, including of course structs with multiple fields.\\nServer:\\nClient:\\n","#!/usr/bin/python\\n# -*- coding: utf-8 -*-\\n \\nimport SocketServer\\nimport pickle\\n \\nHOST = \""localhost\""\\nPORT = 8000\\n\\nclass RPCServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):\\n    # The object_to_proxy member should be set to the object we want\\n    # methods called on. Unfortunately, we can't do this in the constructor\\n    # because the constructor should not be overridden in TCPServer...\\n\\n    daemon_threads = True\\n\\nclass RPCHandler(SocketServer.StreamRequestHandler):\\n    def handle(self):\\n        in_channel = pickle.Unpickler(self.rfile)\\n        out_channel = pickle.Pickler(self.wfile, protocol=2)\\n        while True:\\n            try:\\n                name, args, kwargs = in_channel.load()\\n                print 'got %s %s %s' % (name, args, kwargs)\\n            except EOFError:\\n                # EOF means we're done with this request.\\n                # Catching this exception to detect EOF is a bit hackish,\\n                # but will work for a quick demo like this\\n                break\\n            try:\\n                method = getattr(self.server.object_to_proxy, name)\\n                result = method(*args, **kwargs)\\n            except Exception, e:\\n                out_channel.dump(('Error',e))\\n            else:\\n                out_channel.dump(('OK',result))\\n\\nclass MyHandlerInstance(object):\\n    def echo(self, data):\\n        '''Method for returning data got from client'''\\n        return 'Server responded: %s' % data\\n \\n    def div(self, dividend, divisor):\\n        '''Method to divide 2 numbers'''\\n        return dividend/divisor\\n \\n    def is_computer_on(self):\\n        return True\\n \\nif __name__ == '__main__':\\n    rpcserver = RPCServer((HOST, PORT), RPCHandler)\\n    rpcserver.object_to_proxy = MyHandlerInstance()\\n    try:\\n        rpcserver.serve_forever()\\n    except KeyboardInterrupt:\\n        print 'Exiting...'\\n        rpcserver.server_close()\\n"
"Python","Distributed_programming","Write two programs (or one program with two modes) which run on networked computers, and send some messages between them.\\nThe protocol used may be language-specific or not, and should be suitable for general distributed programming; that is, the protocol should be generic (not designed just for the particular example application), readily capable of handling the independent communications of many different components of a single application, and the transferring of arbitrary data structures natural for the language.\\nThis task is intended to demonstrate high-level communication facilities beyond just creating sockets.\\nAda defines facilities for distributed systems in its standard (Annex E, also called DSA).\\nThis example works with PolyORB and the GNAT GPL 2010 compiler from AdaCore.\\nserver.ads:\\nserver.adb:\\nclient.adb:\\nrequired config (dsa.cfg):\\ncompilation:\\npreparation (run PolyORB name service):\\nYou have to set the environment variable POLYORB_DSA_NAME_SERVICE to one of the two values given by po_ioc_naming for the server/client partitions.\\nrunning server:\\nrunning client:\\nSee Distributed program/AutoHotkey.\\nUsing PVM [[1]\\nThis program is in a sense both a server and a client, depending on if its task is spawned with a command-line argument: if yes, it spawns another task of the same executible on the parallel virtual machine and waits for it to transmit data; if no, it transmits data and is done.\\nStart the program with \""server\"" parameter to start the server, and \""client\"" to start the client. The client will send data to the server and receive a response. The server will wait for data, display the data received, and send a response.\\nUses the rpc library:\\nhttps://github.com/adamdruppe/misc-stuff-including-D-programming-language-web-stuff/blob/master/rpc.d\\nThis library is not standard, so this code (by Adam D. Ruppe) could and should be rewritten using more standard means.\\nProtocol: Pluribus\\nThis service cannot be used except by clients which know the URL designating it, messages are encrypted, and the client authenticates the server. However, it is vulnerable to denial-of-service by any client knowing the URL.\\n(The protocol is symmetric; this program is the server only in that it is the one which is started first and exports an object.)\\nThis will print the URL of the service and run it until aborted.\\nThe URL provided by the server is given as the argument to this program.\\nThe protocol is erlang's own\\nsrv.erl\\nclient.erl\\nrunning it (*comes later)\\nThe protocol is the one provided by Factor (concurrency.distributed, concurrency.messaging)\\nExample summary:\\n- A server node is listening for messages made of natural data types and structures, and simply prettyprint them.\\n- A client node is sending such data structure: an array of one string and one hashtable (with one key/value pair).\\nNote: we are using QUALIFIED: with the concurrency.messaging vocabulary because the \""receive\"" word is defined in io.sockets vocabulary too. If someone have a cleaner way to handle this.\\nHow to Run:\\n- Copy/Paste the server code in an instance of Factor Listener\\n- Copy/Paste the client code in another instance of Factor Listener.\\nThe server node should prettyprint the data structure send by the client: { \""Hello Remote Factor!\"" H{ { \""key1\"" \""value1\"" } } }\\nPackage net/rpc in the Go standard library serializes data with the Go-native \""gob\"" type. The example here sends only a single floating point number, but the package will send any user-defined data type, including of course structs with multiple fields.\\nServer:\\nClient:\\n","#!/usr/bin/python\\n# -*- coding: utf-8 -*-\\n \\nimport socket\\nimport pickle\\n \\nHOST = \""localhost\""\\nPORT = 8000\\n\\nclass RPCClient(object):\\n    def __init__(self, host, port):\\n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\\n        self.socket.connect((host, port))\\n        self.rfile = self.socket.makefile('rb')\\n        self.wfile = self.socket.makefile('wb')\\n        self.in_channel = pickle.Unpickler(self.rfile)\\n        self.out_channel = pickle.Pickler(self.wfile, protocol=2)\\n\\n    def _close(self):\\n        self.socket.close()\\n        self.rfile.close()\\n        self.wfile.close()\\n\\n    # Make calling remote methods easy by overriding attribute access.\\n    # Accessing any attribute on our instances will give a proxy method that\\n    # calls the method with the same name on the remote machine.\\n    def __getattr__(self, name):\\n        def proxy(*args, **kwargs):\\n            self.out_channel.dump((name, args, kwargs))\\n            self.wfile.flush() # to make sure the server won't wait forever\\n            status, result = self.in_channel.load()\\n            if status == 'OK':\\n                return result\\n            else:\\n                raise result\\n\\n        return proxy\\n \\nif __name__ == '__main__':\\n    # connect to server and send data\\n    rpcclient = RPCClient(HOST, PORT)\\n\\n    print 'Testing the echo() method:'\\n    print rpcclient.echo('Hello world!')\\n    print\\n    print 'Calculating 42/2 on the remote machine:'\\n    print rpcclient.div(42, 2)\\n    print\\n    print 'is_computer_on on the remote machine returns:'\\n    print rpcclient.is_computer_on()\\n    print\\n    print 'Testing keyword args:'\\n    print '42/2 is:', rpcclient.div(divisor=2, dividend=42)\\n    rpcclient._close()\\n    del rpcclient"
"Python","Distributed_programming","Write two programs (or one program with two modes) which run on networked computers, and send some messages between them.\\nThe protocol used may be language-specific or not, and should be suitable for general distributed programming; that is, the protocol should be generic (not designed just for the particular example application), readily capable of handling the independent communications of many different components of a single application, and the transferring of arbitrary data structures natural for the language.\\nThis task is intended to demonstrate high-level communication facilities beyond just creating sockets.\\nAda defines facilities for distributed systems in its standard (Annex E, also called DSA).\\nThis example works with PolyORB and the GNAT GPL 2010 compiler from AdaCore.\\nserver.ads:\\nserver.adb:\\nclient.adb:\\nrequired config (dsa.cfg):\\ncompilation:\\npreparation (run PolyORB name service):\\nYou have to set the environment variable POLYORB_DSA_NAME_SERVICE to one of the two values given by po_ioc_naming for the server/client partitions.\\nrunning server:\\nrunning client:\\nSee Distributed program/AutoHotkey.\\nUsing PVM [[1]\\nThis program is in a sense both a server and a client, depending on if its task is spawned with a command-line argument: if yes, it spawns another task of the same executible on the parallel virtual machine and waits for it to transmit data; if no, it transmits data and is done.\\nStart the program with \""server\"" parameter to start the server, and \""client\"" to start the client. The client will send data to the server and receive a response. The server will wait for data, display the data received, and send a response.\\nUses the rpc library:\\nhttps://github.com/adamdruppe/misc-stuff-including-D-programming-language-web-stuff/blob/master/rpc.d\\nThis library is not standard, so this code (by Adam D. Ruppe) could and should be rewritten using more standard means.\\nProtocol: Pluribus\\nThis service cannot be used except by clients which know the URL designating it, messages are encrypted, and the client authenticates the server. However, it is vulnerable to denial-of-service by any client knowing the URL.\\n(The protocol is symmetric; this program is the server only in that it is the one which is started first and exports an object.)\\nThis will print the URL of the service and run it until aborted.\\nThe URL provided by the server is given as the argument to this program.\\nThe protocol is erlang's own\\nsrv.erl\\nclient.erl\\nrunning it (*comes later)\\nThe protocol is the one provided by Factor (concurrency.distributed, concurrency.messaging)\\nExample summary:\\n- A server node is listening for messages made of natural data types and structures, and simply prettyprint them.\\n- A client node is sending such data structure: an array of one string and one hashtable (with one key/value pair).\\nNote: we are using QUALIFIED: with the concurrency.messaging vocabulary because the \""receive\"" word is defined in io.sockets vocabulary too. If someone have a cleaner way to handle this.\\nHow to Run:\\n- Copy/Paste the server code in an instance of Factor Listener\\n- Copy/Paste the client code in another instance of Factor Listener.\\nThe server node should prettyprint the data structure send by the client: { \""Hello Remote Factor!\"" H{ { \""key1\"" \""value1\"" } } }\\nPackage net/rpc in the Go standard library serializes data with the Go-native \""gob\"" type. The example here sends only a single floating point number, but the package will send any user-defined data type, including of course structs with multiple fields.\\nServer:\\nClient:\\n","#!/usr/bin/python\\n# -*- coding: utf-8 -*-\\n\\nimport Pyro.core\\nimport Pyro.naming\\n\\n# create instance that will return upper case\\nclass StringInstance(Pyro.core.ObjBase):\\n    def makeUpper(self, data):\\n        return data.upper()\\n\\nclass MathInstance(Pyro.core.ObjBase):\\n    def div(self, num1, num2):\\n        return num1/num2\\n\\nif __name__ == '__main__':\\n    server = Pyro.core.Daemon()\\n    name_server = Pyro.naming.NameServerLocator().getNS()\\n    server.useNameServer(name_server)\\n    server.connect(StringInstance(), 'string')\\n    server.connect(MathInstance(), 'math')\\n    try:\\n        server.requestLoop()\\n    except KeyboardInterrupt:\\n        print 'Exiting...'\\n        server.shutdown()"
"Python","Distributed_programming","Write two programs (or one program with two modes) which run on networked computers, and send some messages between them.\\nThe protocol used may be language-specific or not, and should be suitable for general distributed programming; that is, the protocol should be generic (not designed just for the particular example application), readily capable of handling the independent communications of many different components of a single application, and the transferring of arbitrary data structures natural for the language.\\nThis task is intended to demonstrate high-level communication facilities beyond just creating sockets.\\nAda defines facilities for distributed systems in its standard (Annex E, also called DSA).\\nThis example works with PolyORB and the GNAT GPL 2010 compiler from AdaCore.\\nserver.ads:\\nserver.adb:\\nclient.adb:\\nrequired config (dsa.cfg):\\ncompilation:\\npreparation (run PolyORB name service):\\nYou have to set the environment variable POLYORB_DSA_NAME_SERVICE to one of the two values given by po_ioc_naming for the server/client partitions.\\nrunning server:\\nrunning client:\\nSee Distributed program/AutoHotkey.\\nUsing PVM [[1]\\nThis program is in a sense both a server and a client, depending on if its task is spawned with a command-line argument: if yes, it spawns another task of the same executible on the parallel virtual machine and waits for it to transmit data; if no, it transmits data and is done.\\nStart the program with \""server\"" parameter to start the server, and \""client\"" to start the client. The client will send data to the server and receive a response. The server will wait for data, display the data received, and send a response.\\nUses the rpc library:\\nhttps://github.com/adamdruppe/misc-stuff-including-D-programming-language-web-stuff/blob/master/rpc.d\\nThis library is not standard, so this code (by Adam D. Ruppe) could and should be rewritten using more standard means.\\nProtocol: Pluribus\\nThis service cannot be used except by clients which know the URL designating it, messages are encrypted, and the client authenticates the server. However, it is vulnerable to denial-of-service by any client knowing the URL.\\n(The protocol is symmetric; this program is the server only in that it is the one which is started first and exports an object.)\\nThis will print the URL of the service and run it until aborted.\\nThe URL provided by the server is given as the argument to this program.\\nThe protocol is erlang's own\\nsrv.erl\\nclient.erl\\nrunning it (*comes later)\\nThe protocol is the one provided by Factor (concurrency.distributed, concurrency.messaging)\\nExample summary:\\n- A server node is listening for messages made of natural data types and structures, and simply prettyprint them.\\n- A client node is sending such data structure: an array of one string and one hashtable (with one key/value pair).\\nNote: we are using QUALIFIED: with the concurrency.messaging vocabulary because the \""receive\"" word is defined in io.sockets vocabulary too. If someone have a cleaner way to handle this.\\nHow to Run:\\n- Copy/Paste the server code in an instance of Factor Listener\\n- Copy/Paste the client code in another instance of Factor Listener.\\nThe server node should prettyprint the data structure send by the client: { \""Hello Remote Factor!\"" H{ { \""key1\"" \""value1\"" } } }\\nPackage net/rpc in the Go standard library serializes data with the Go-native \""gob\"" type. The example here sends only a single floating point number, but the package will send any user-defined data type, including of course structs with multiple fields.\\nServer:\\nClient:\\n","#!/usr/bin/python\\n# -*- coding: utf-8 -*-\\n\\nimport Pyro.core\\n\\nDATA = \""my name is eren\""\\nNUM1 = 10\\nNUM2 = 5\\n\\nstring = Pyro.core.getProxyForURI(\""PYRONAME://string\"")\\nmath = Pyro.core.getProxyForURI(\""PYRONAME://math\"")\\n\\nprint 'We sent: %s' % DATA\\nprint 'Server responded: %s\\n' % string.makeUpper(DATA)\\n\\nprint 'We sent two numbers to divide: %d and %d' % (NUM1, NUM2)\\nprint 'Server responded the result: %s' % math.div(NUM1, NUM2)"
"Python","Distributed_programming","Write two programs (or one program with two modes) which run on networked computers, and send some messages between them.\\nThe protocol used may be language-specific or not, and should be suitable for general distributed programming; that is, the protocol should be generic (not designed just for the particular example application), readily capable of handling the independent communications of many different components of a single application, and the transferring of arbitrary data structures natural for the language.\\nThis task is intended to demonstrate high-level communication facilities beyond just creating sockets.\\nAda defines facilities for distributed systems in its standard (Annex E, also called DSA).\\nThis example works with PolyORB and the GNAT GPL 2010 compiler from AdaCore.\\nserver.ads:\\nserver.adb:\\nclient.adb:\\nrequired config (dsa.cfg):\\ncompilation:\\npreparation (run PolyORB name service):\\nYou have to set the environment variable POLYORB_DSA_NAME_SERVICE to one of the two values given by po_ioc_naming for the server/client partitions.\\nrunning server:\\nrunning client:\\nSee Distributed program/AutoHotkey.\\nUsing PVM [[1]\\nThis program is in a sense both a server and a client, depending on if its task is spawned with a command-line argument: if yes, it spawns another task of the same executible on the parallel virtual machine and waits for it to transmit data; if no, it transmits data and is done.\\nStart the program with \""server\"" parameter to start the server, and \""client\"" to start the client. The client will send data to the server and receive a response. The server will wait for data, display the data received, and send a response.\\nUses the rpc library:\\nhttps://github.com/adamdruppe/misc-stuff-including-D-programming-language-web-stuff/blob/master/rpc.d\\nThis library is not standard, so this code (by Adam D. Ruppe) could and should be rewritten using more standard means.\\nProtocol: Pluribus\\nThis service cannot be used except by clients which know the URL designating it, messages are encrypted, and the client authenticates the server. However, it is vulnerable to denial-of-service by any client knowing the URL.\\n(The protocol is symmetric; this program is the server only in that it is the one which is started first and exports an object.)\\nThis will print the URL of the service and run it until aborted.\\nThe URL provided by the server is given as the argument to this program.\\nThe protocol is erlang's own\\nsrv.erl\\nclient.erl\\nrunning it (*comes later)\\nThe protocol is the one provided by Factor (concurrency.distributed, concurrency.messaging)\\nExample summary:\\n- A server node is listening for messages made of natural data types and structures, and simply prettyprint them.\\n- A client node is sending such data structure: an array of one string and one hashtable (with one key/value pair).\\nNote: we are using QUALIFIED: with the concurrency.messaging vocabulary because the \""receive\"" word is defined in io.sockets vocabulary too. If someone have a cleaner way to handle this.\\nHow to Run:\\n- Copy/Paste the server code in an instance of Factor Listener\\n- Copy/Paste the client code in another instance of Factor Listener.\\nThe server node should prettyprint the data structure send by the client: { \""Hello Remote Factor!\"" H{ { \""key1\"" \""value1\"" } } }\\nPackage net/rpc in the Go standard library serializes data with the Go-native \""gob\"" type. The example here sends only a single floating point number, but the package will send any user-defined data type, including of course structs with multiple fields.\\nServer:\\nClient:\\n","#!/usr/bin/python\\n# -*- coding: utf-8 -*-\\n\\nimport spread\\n\\nPORT = '4803'\\n\\n# connect spread daemon\\nconn = spread.connect(PORT)\\n# join the room\\nconn.join('test')\\n\\nprint 'Waiting for messages... If you want to stop this script, please stop spread daemon'\\nwhile True:\\n    recv = conn.receive()\\n    if hasattr(recv, 'sender') and hasattr(recv, 'message'):\\n        print 'Sender: %s' % recv.sender\\n        print 'Message: %s' % recv.message"
"Python","Distributed_programming","Write two programs (or one program with two modes) which run on networked computers, and send some messages between them.\\nThe protocol used may be language-specific or not, and should be suitable for general distributed programming; that is, the protocol should be generic (not designed just for the particular example application), readily capable of handling the independent communications of many different components of a single application, and the transferring of arbitrary data structures natural for the language.\\nThis task is intended to demonstrate high-level communication facilities beyond just creating sockets.\\nAda defines facilities for distributed systems in its standard (Annex E, also called DSA).\\nThis example works with PolyORB and the GNAT GPL 2010 compiler from AdaCore.\\nserver.ads:\\nserver.adb:\\nclient.adb:\\nrequired config (dsa.cfg):\\ncompilation:\\npreparation (run PolyORB name service):\\nYou have to set the environment variable POLYORB_DSA_NAME_SERVICE to one of the two values given by po_ioc_naming for the server/client partitions.\\nrunning server:\\nrunning client:\\nSee Distributed program/AutoHotkey.\\nUsing PVM [[1]\\nThis program is in a sense both a server and a client, depending on if its task is spawned with a command-line argument: if yes, it spawns another task of the same executible on the parallel virtual machine and waits for it to transmit data; if no, it transmits data and is done.\\nStart the program with \""server\"" parameter to start the server, and \""client\"" to start the client. The client will send data to the server and receive a response. The server will wait for data, display the data received, and send a response.\\nUses the rpc library:\\nhttps://github.com/adamdruppe/misc-stuff-including-D-programming-language-web-stuff/blob/master/rpc.d\\nThis library is not standard, so this code (by Adam D. Ruppe) could and should be rewritten using more standard means.\\nProtocol: Pluribus\\nThis service cannot be used except by clients which know the URL designating it, messages are encrypted, and the client authenticates the server. However, it is vulnerable to denial-of-service by any client knowing the URL.\\n(The protocol is symmetric; this program is the server only in that it is the one which is started first and exports an object.)\\nThis will print the URL of the service and run it until aborted.\\nThe URL provided by the server is given as the argument to this program.\\nThe protocol is erlang's own\\nsrv.erl\\nclient.erl\\nrunning it (*comes later)\\nThe protocol is the one provided by Factor (concurrency.distributed, concurrency.messaging)\\nExample summary:\\n- A server node is listening for messages made of natural data types and structures, and simply prettyprint them.\\n- A client node is sending such data structure: an array of one string and one hashtable (with one key/value pair).\\nNote: we are using QUALIFIED: with the concurrency.messaging vocabulary because the \""receive\"" word is defined in io.sockets vocabulary too. If someone have a cleaner way to handle this.\\nHow to Run:\\n- Copy/Paste the server code in an instance of Factor Listener\\n- Copy/Paste the client code in another instance of Factor Listener.\\nThe server node should prettyprint the data structure send by the client: { \""Hello Remote Factor!\"" H{ { \""key1\"" \""value1\"" } } }\\nPackage net/rpc in the Go standard library serializes data with the Go-native \""gob\"" type. The example here sends only a single floating point number, but the package will send any user-defined data type, including of course structs with multiple fields.\\nServer:\\nClient:\\n","#!/usr/bin/python\\n# -*- coding: utf-8 -*-\\n\\nimport spread\\n\\nPORT = '4803'\\n\\nconn = spread.connect(PORT)\\nconn.join('test')\\n\\nconn.multicast(spread.RELIABLE_MESS, 'test', 'hello, this is message sent from python')\\nconn.disconnect()"
"Python","DNS_query","DNS is an internet service that maps domain names, like rosettacode.org, to IP addresses, like 66.220.0.231.\\nUse DNS to resolve www.kame.net to both IPv4 and IPv6 addresses. Print these addresses.\\n\\nThis code uses Windows built-in 'nslookup' command (and a temporary file):\\n",">>> import socket\\n>>> ips = set(i[4][0] for i in socket.getaddrinfo('www.kame.net', 80))\\n>>> for ip in ips: print ip\\n...\\n2001:200:dff:fff1:216:3eff:feb1:44d7\\n203.178.141.194"
"Python","Documentation","\\n\\nIn some ways, Ada is a self documenting language by design. When building packages (the equivalent of modules in python), you have to create two separate files: a spec and a body. The spec resides in a .ads file, and contains the interface to the package that is visible to someone using it.\\nAll functions, procedures and data-types that can be used in other Ada programs have to have an entry in the spec that defines how they are used. The only requirement for the body file is that it give definitions for everything found in the spec. You can also include other functions in the body file to help build the functions defined in the spec. Anything that doesn't appear in the .ads file won't be accessible to a programmer who uses that particular package.\\nThe ada spec file gives you all the information you need to know to effectively use the functions in that package, and as such is the primary documentation that you want to look at. If you have the .adb and .ads files physically available to you, you can also verify that the information is correct by re-compiling the package, the Ada compiler checks to make sure that the spec and the body agree, and that everything defined in the spec is implemented in the body.\\nExample ADS file for instrumenting sorting functions:\\nThere is also a tool called AdaDoc. This can be used to generate documentation of an Ada module (or modules?) for a variety of different formats: HTML, LaTeX, plain text and more.\\nYou can use the GenDocs library.\\nIt generates html documentation in the style of the canonical ahk documentation. \\nBBCode is supported for markup. \\nA common tool for generating documentation is Doxygen:\\nROBODoc allows for documentation extracts from pretty much any language that\\nallows comments. Includes highlighting of source code. This feature has been\\nextended for COBOL to allow dashes in names, along with the normal C based\\nunderscore divider. ROBODoc looks for start and end triggers.\\nDocumentation keywords, and comment marker triggers, are managed by\\nconfiguration settings and ROBODoc ships with quite a few predefined special\\nwords. Lines after the colon terminated keywords are each extracted into\\ndifferent paragraph types. Graphviz can also be invoked to include DOT\\ndrawings, images can be embedded, and shell commands can also be invoked during\\nthe HTML generation process.\\nAnother style of auto generated documentation involves the Compiler Directive\\nFacility and using special defines to mingle documentation blocks within lines\\nof the source file, which can then be extracted and passed through various\\nmarkup processors, like Sphinx ReStructureText or Markdown.\\nExtraction of documentation segments is feasible using just the Compiler\\nDirective Facility, but it is usually easier to use sed or other tools.\\nOtherwise any Compiler Directives within the documentation become live and\\ndocumentation may trigger other conditional compile statements, usually to bad\\neffect. In the case of COBOL, this includes both the COPY and\\nREPLACE Text Manipulation keywords, which can easily show up within\\ndocumentation segments. It is safer to use an undefined conditional to simply\\nskip documentation blocks during actual code compilation and extract the\\ndocumentation lines with a separate tool before passing the extract to a markup\\nprocessor.\\nCommon Lisp allows the definition of documentation strings for functions, variables, classes, ... It also allows retrieval of documentation strings.\\nThis documentation method will work perfectly with the built in object browser in Visual Studio. The object browser can then show detailed information for each component. To make documentation that can be parsed, a triple slash (///) must be used. Further information can be found in this tutorial. A list of available xml elements for use in documentation is here.\\nD compiler comes with a builtin documentation system called Ddoc. Alternative systems may be used (a common alternative is Doxygen which includes some D support).\\nXML comments are shown in the IDE and is included in the XML documentation produced by the compiler when using --docs.\\nE's documentation facilities outside of comments are directly inspired by Javadoc and use a similar basic syntax; however, they are part of the language rather than being an idiom about using comments.\\nObjects, methods, and functions have doc-comments (much as in Python or Common Lisp); the syntax for them is /** ... */ immediately preceding the definition of the object, method, or function. (Note that E does not recognize the /*...*/ comment syntax in general.)\\nThe documentation syntax is in some ways underdefined: there is no layer which discards the leading '*'s as in Javadoc, so the documentation string contains all leading indentation (which is problematic for the source prettyprinter), and there is no formal definition yet of the syntax used within the doc-comments.\\nVariables may not have doc-comments, because they are never part of the public interface of an object.\\nThe Eiffel language was designed with a goal of producing documentation directly from software text. Certain comments, contracts for publicly accessible routines, and the class invariant are all extracted into the documentation views of a class.\\nThe following is a simple class written in Eiffel:\\nBelow is the Contract (documentation) view of the same class. It is the view that potential reuse consumers would reference when writing clients.\\nIt is important to notice what is missing from this view. It shows only the specification of the class. The implementations of routines and any routines which are not public are not visible. The notes and comments, public features (including contracts for routines), and the class invariant all remain as components of the specification.\\nThis view was produced by EiffelStudio which also supports an Interface view which is similar to the Contract view above, but also includes contracts for any inherited routines, and the complete inherited class invariant. EiffelStudio can publish these and other documentation view in HTML and other formats suitable for sharing.\\n\\nElixir uses ExDoc in order to document code. ExDoc allows users to pull data (such as name, version, source link) into their app. For example (taken from the ExDoc documentation):\\nIndividual modules can be documented using the @moduledoc attribute and heredocs (with markdown):\\nIn defun, defmacro and defsubst an optional docstring can follow the formal parameters.\\nFor defvar, defconst or defcustom an optional docstring follows the value.\\nMost other defining forms have similar optional docstrings. In all cases they must be a string constant.\\nDocstrings have no effect on code execution but are available to the user or programmer in C-h f (describe-function) etc. The docstring of a major mode function is its C-h m help (describe-mode). The Emacs Lisp Reference Manual \""Tips for Documentation Strings\"" describes various stylistic conventions.\\nThe byte compiler (of Emacs 19.29 up) generates \""dynamic docstrings\"" in the .elc files which means docstrings are not loaded into memory until actually viewed.\\nErlang has Edoc. From the documentation: \""EDoc is the Erlang program documentation generator. Inspired by the Javadoc(TM) tool for the Java(TM) programming language, EDoc is adapted to the conventions of the Erlang world, and has several features not found in Javadoc.\""\\nIt is also possible to document functions and their arguments with type information. These can be used by Dialyzer. From the documentation: \""The Dialyzer is a static analysis tool that identifies software discrepancies such as definite type errors, code which has become dead or unreachable due to some programming error, unnecessary tests, etc. in single Erlang modules or entire (sets of) applications.\""\\nFactor has an extensive documentation system built in. See docs.factorcode.org : [1]\\nFortran offers no language facilities for including documentation within a programme's code. Being typically a compiled language, the details of the source file (and any documentation that it may contain) are long gone by the time the compiled code is executing. Unlike interpreted languages, it has no access to its \""source code\"" form for self-inspection (or modification!) nor are facilities provided to attach auxiliary information to the components of a programme that might be reported at run time. A determined and diligent programmer could develop such a scheme but only by writing a lot of extra code without any special assistance from the language.\\nThere are slight exceptions to the absence of source information in the code file. The B6700 compiler offered a pseudo text variable that contains the contents of columns 73-80 (the line sequence field) of the line in which it appeared that might be passed as a parameter to a routine reporting an error message, thereby identifying the location that recognised the error. This is not a standard feature! The standard NAMELIST facility does enable a code file to read or write selected variables \""by name\"" in the format <NameOfVariable> = <Value(s)Of Variable> with a detailed form dependent on the type of the variable, and arrays have a repetition count if successive elements have equal values. This is useful when wishing to write out a complex state, or indeed to read in a complex set of data so as to supply parameters to a run without having to worry over their precise layout.\\nA compiler may produce a \""symbol table\"" identifying the names of all routines and variables, and in the older days, their addresses so that when studying a memory dump there is some hope of discovering what went wrong. But \""dump snuffling\"" is rare these days. Similarly, a run-time error such as divide-by-zero usually elicits a message giving the memory address of the divide instruction and the report may include some indication of the line number (or source sequence field) of the statement, plus the name of the routine in which it lay.\\nPut another way, reverse-compiling the code file will be unlikely to recover even the names of variables, let alone any documentation.\\nThus, documentation depends on whatever the programmer sees fit to provide in the source file, possibly under protest. Originally, only \""block\"" comments could be provided, signified by a C in column one (and in some extensions, a letter D in column one signified \""debugging\"" statements that would be compiled in or not according to the setting of a compiler option), however this vertical alternation of layers of code and commentary can be obstructive to the reader. F90 standardised the \""escape\"" comment style whereby outside a text literal, everything following an exclamation mark to the end of the line was regarded as a comment (B6700 Fortran used a %-symbol), thus code and commentary can be arranged in two non-clashing columns - especially if the source is listed via a reformatting system with that in mind. There is no comment start - comment stop facility as with {blah} in Pascal or /*blah*/ in pl/i, etc. and compilers may or may not recognise non-Fortran control lines such as $Omit or similar.\\nFortran 90 also introduced the ability to specify INTENT IN, OUT, or INOUT for parameters to routines, as well as the usual type indications. Its MODULE protocol includes an INTERFACE specification to assist in the description of collections of functions or subroutines with different types and numbers of parameters. These change what the compiler allows or rejects, but are also often important parts of documentation.\\nOtherwise, aside from separately-prepared files, the documentation resides in the source file, with layout, choice of names and organised design being the key and subject to style disputes and fashion. One special feature of Fortran is that statement labels can be used to identify logical blocks or sections in a way similar to the numbering of paragraphs in some documents. Labels might be incremented by 100 for sections, 10 for blocks within sections and 1 for stages within blocks - even if many such labels are never used in the code.\\nOutside systems are available to assist. It is common for text editors to employ syntax highlighting, but their designers rarely handle the full complexity of Fortran syntax correctly. For instance, the format of a number such as -3.145E+07 is difficult to scan, especially since in Fortran source, spaces are ignored outside of text literals. Then, consider the FORMAT codes, such as 31E16.7 and similar sequences. More serious efforts scan the Fortran source in order to extract information useful for documentation. There have long been available systems that will identify every routine in a programme and for each identify what routine calls it, and what routines it calls, along with further analysis on their parameters and their usage - this well before F90 introduced the optional INTENT feature. Similarly, within each routine, identify which variables are used (possibly as parameters) where and whether they are read or written there. And, analyse the usage of COMMON variables... Likewise, documentation might include a flowchart, and systems exist to produce these as well.\\nQuite useful documentation could be extracted just from that. By mixing actual source statements with the commentary and extracting both, inane clashes can be reduced, as in CHARACTER*6 TLA  !Three-character name. that arose because a modification to the nature of the parameter had been made, but, while revising every routine that employed such a parameter, the programmer's consciousness faded out as soon as it saw the comment start and noted \""non-Fortran source\"", to the puzzlement of subsequent readers. A system that extracted only the commentary part from that would not give a correct report, whereas with it known that the actual declaration would be included, there would be no longer any need to repeat its details in the comment and the comment could confine itself to expounding on meaning and usage. On the other hand, F90 introduced a verbose scheme for declarations wherein something like SELECTED_REAL_KIND(6, 70) might appear and copying that may well merely copy obfuscation.\\nSimilarly, there could be a convention in the file-naming scheme whereby a code file could gain access to its source file, and with further conventions put to use, it could recognise its own commands and messages and nearby find further text with explanations or examples, etc. or indeed find its own manual and print it on request. It is much better to have one file (and to maintain synchrony within it), than to have two separate files, possibly maintained by personnel in two different departments who speak different languages. An accomplished programme might even modify its own source code, say to maintain a version number - if the source code's value matches the compiled-in value then this is the first run of the new version, so increment the counter in the source code. By keeping track of the date and time, and the timestamp of each user's last use, then a user could be advised of changes to the system since their last use. Given that the update log is also within the source file and suitably identified and timestamped.\\nBut none of this is within the Fortran language definition itself.\\nCommon comments in the source code is lines starting by \""\\ \"" do not forget the space\\nexample :\\nAnother good practice is describing the stack use of a function : function ( stack before -- stack at end )\\nexample :\\nAlthough FreeBASIC has several kinds of comments it does not currently support 'documentation comments' as such.\\nHowever, there is a third party tool called fb-doc which is free software and acts as a bridge to existing C documentation generators such as gtk-doc and Doxygen.\\nGo source has both single line and block comments.\\nGodoc is an external command that extracts documentation from source code and outputs it as text or serves it as HTML. Godoc extracts exported top-level declarations and comments that preceede them. To be extracted, comments must immediately preceed the declaration with no intervening blank line. Godoc may or may not reformat comments, depending on output options, but it does this in a general way and there are no markup rules to follow.\\nExample code demonstrating what godoc extracts and what it doesn't:\\nText output of godoc: (HTML looks nicer, of course)\\nNew commands can have optional help text between the command name line and the opening { brace.\\nAny literal braces in the text must be backslash escaped \\{. The text is shown by the online help system, similar to builtin commands.\\n(See section \""Simple New Command\"" in the GRI manual.)\\n\\nHaddock is a popular documentation generator for the Haskell language.\\nSee this chapter for more information about the markup.\\nThere are no formal conventions for documentation built into the Icon/Unicon. However, there are conventions for the different libraries that are supported by automation.\\n\\nTBD\\nUse scripdoc:\\nDocumentation is typically given using Javadoc comments. Documentation is generated from these comments using the Javadoc tool. The default output (from the standard doclet) takes the form of an HTML page with frames, so HTML is frequently embedded in the comments. The comments all start with /**, end with */, and usually have \""tags\"" embedded starting with @.\\nJulia has a built-in documentation system for functions, types, and similar user-defined entities.\\nQuoting the Julia documentation pages:\\nAny string appearing at the top-level right before an object (function, macro, type or instance) will be interpreted as documenting it (these are called docstrings). Note that no blank lines or comments may intervene between a docstring and the documented object. Here is a basic example:\\nDocumentation is interpreted as Markdown, so you can use indentation and code fences to delimit code examples from text. Technically, any object can be associated with any other as metadata; Markdown happens to be the default, but one can construct other string macros and pass them to the @doc macro just as well.\\nHere is a more complex example, still using Markdown:\\nKotlin uses a system of comments called KDoc to document source code. This is similar to Java's Javadoc though there are some additional block tags to support Kotlin-specific constructs.\\nInline markup uses an extended form of the Markdown syntax.\\nThe documentation is generated using a tool called Dokka.\\nThe following is a slightly extended version of the example in the official Kotlin documentation:\\nLogtalk provides a set of entity and predicate documenting directives. The content of these and other directives can be retrieved using the language reflection features. A companion tool, \""lgtdoc\"", uses the reflection API to extract the documenting information and export it as XML files and provides a set of stylesheets to convert these file to e.g. HTML and PDF files.\\nMathematica inline documentation can be accessed directly in the code by pressing F1. No external tools required\\nThe comments will be revealed. However, a test with Octave elicited only the comment on the \""function\"" line. If the file contained merely a sequence of commands (i.e. did not constitute the definition of a function) the first line of the above example would be absent and the file would start with a comment block.\\nThe feature does not care what file type is used for input, and most C sources for Neko libraries include documentation blocks of this type.\\nCommon tools include [Doxygen http://doxygen.org], [HeaderDoc http://developer.apple.com/mac/library/documentation/DeveloperTools/Conceptual/HeaderDoc/intro/intro.html] and GSDoc. The use of doxygen is much like in C.\\nOCamldoc is a documentation generator that is included with OCaml. Documentation comments all start with (** (but no more than two asterisks) and end with *). Like Javadoc, \""tags\"" can be embedded starting with @.\\nThe primary method for documenting GP functions is the addhelp() command:\\nPARI documentation is done as for C.\\nPerl's documentation mechanism is called POD (Plain Old Documentation). Basically, any line that starts with an equal sign followed by a word (e.g. =head1) starts a documentation comment; and it lasts until a line that begins with =cut. Many formatting commands are recognized; for example, a line beginning with =item starts a section for an item, text wrapped in I< ... > is italicized, text wrapped in C< ... > is formatted as code, etc. See the perlpod and perlpodspec manuals for more details about the format.\\nSimilarly to Perl 5, Perl 6 is documented using Pod (a redesigned version of POD). However, it's not simply ignored by the parser as in Perl 5, it's an internal part of the language spec and can be used to attach documentation objects to almost any part of the code.\\nA compiler has a built-in --doc switch that will generate documentation from a given source file.\\nphpDocumentor (phpdoc) is a documentor for PHP. The syntax is similar to Javadoc.\\nPicoLisp doesn't yet support inline documentation directly in the code. However, it has built-in runtime documentation via the 'doc' function. This requires no external tools, except that the interpreter must have been started in debug mode.\\nThere is no provision for attaching documentation to functions, procedures or variables in the code, other than what may be written by the programmer as additional code, and if so, that would be without special support. The source file may contain documentation in the form of in-line comments, permitted wherever a space would appear (outside of text literals) and marked /*...comment...*/ that may continue across as many lines as desired. There is no \""nesting\"" of comments and an omitted */ might cause trouble. Being typically compiled code, such commentary is long gone when a programme is running, as is the source text. There is no provision for code examination similar to reverse compilation, so there is no way for a routine to identify its caller, or the line in the source file that is being executed. However, a programme might read its own source file and extract information therefrom. With suitable conventions, it could print a copy of its manual and so forth.\\nThere are special functions that provide the date and time that might be of use for documentation. DATE || TIME might return something like \""870304090130388\"" and yes, in the 80's it was still a two-digit year number. At compile time, say to determine the timestamp of the compilation as a part of version control and update logging, matters were a little more difficult because the results via the pre-processor were texts and not quoted. Using \""DATE\"" won't work because that is a quoted literal of four letters. Rather than stammering \""\""\""\"", confusion could be reduced by TIMESTAMP = QUOTE || DATE || TIME || QUOTE where QUOTE was a pre-processor variable that contained a quote character, stammered once. The pre-processor variable TIMESTAMP would be a text that started and ended with a quote, and could be used in normal source statements as such.\\nPowerShell includes complete built-in help for comment-based help: Just run help about_comment_based_help.\\nThis would as an example be shown in the code over view as the picture below.\\n\\nA string literal which is the first expression in a class, function, or module definition is called a docstring. It can be subsequently accessed at runtime using the .__doc__ attribute of the class, function, or module.\\npydoc, a module of the Python standard library, can automatically generate documentation gleaned from docstrings of modules. The documentation can be presented as pages of text on a terminal; automatically served to a Web Browser; or saved as HTML. The command line pydoc command , in addition, can display docstring information in a TK based GUI browser.\\nThe built-in help() function uses the pydoc module to display docstring information at the command prompt of the Python interactive shell.\\nThe Sphinx Documentation generator suite is used to generate the new Python documentation.\\nR objects are documented in files written in \""R documentation\"" (Rd) format, which is similar to LaTeX markup. See Chapter 2 of Writing R Extensions for the full details. Example function document files can be created using\\nAn example documentation file for a function 'f', taking arguments 'x' and 'y' is\\nRacket documentation is written in an integrated documentation\\ndomain-specific language called Scribble:\\nPrograms can also be written with inline documentation using either the\\nscribble/srcdoc or scribble/lp (literate programming)\\nlibraries.\\nOutput:\\nRetro allows for insertion of documentation blocks. The contents of these can be in any format desired, though the standard Retro system uses Restructured Text for all embedded and external documentation.\\n\\nOne technique with REXX is to use in-line documentation as REXX supports the accessing of\\nthe REXX program's source, which can include documentation if properly fenced.\\nThis particular example uses lowercase fences of:\\nto delineate the documentation.   But, any two unique strings could be used.\\nNote that the documentation is bracketed by the standard REXX comment delimiters to preserve program lexicographical integrity.\\nRDoc is the de-facto documentation tool that's bundled with Ruby distributions. From it's documentation:\\nRDoc produces output that looks like this.\\nRuby's documentation comments look like Perl's PODs. Translating Java's example:\\nExcellent documentation about ScalaDoc is given here in the Scala Style Guide.\\n(Squeak/Pharo)\\nDocumentation is written in files with extension .sthlp, in Stata Markup and Control Language.\\nFor instance, say we have an ado file hello.ado:\\nThe documentation file, hello.sthlp, could be:\\nPut these two file in a directory visible in the ado path. Then call the command by typing hello, and open its help file by typing help hello.\\nSee also the documentation of the help command.\\nSwift uses reStructuredText. This third-party article has some information.\\nDocumentation for Tcl code is usually prepared in separate files using a tool like doctools, but inline docs (with all their inherent limitations) can be done with the likes of Robodoc. For example:\\nBoth doctools and robodoc can produce output in multiple formats.\\nInline documentation is limited to comments within the code. However, there is no inbuilt extraction tool, so this would need to be written. The example shows how documentation for a variable and a function could be embedded within the code:\\nAlternatively, it is possible to embed documentation into LPRINT statements within a subroutine, allowing the language to print its own documentation. In the example below, the command GOSUB 2000 would print the documentation:\\n","class Doc(object):\\n   \""\""\""\\n   This is a class docstring. Traditionally triple-quoted strings are used because\\n   they can span multiple lines and you can include quotation marks without escaping.\\n   \""\""\""\\n   def method(self, num):\\n      \""\""\""This is a method docstring.\""\""\""\\n      pass"
"Python","Documentation","\\n\\nIn some ways, Ada is a self documenting language by design. When building packages (the equivalent of modules in python), you have to create two separate files: a spec and a body. The spec resides in a .ads file, and contains the interface to the package that is visible to someone using it.\\nAll functions, procedures and data-types that can be used in other Ada programs have to have an entry in the spec that defines how they are used. The only requirement for the body file is that it give definitions for everything found in the spec. You can also include other functions in the body file to help build the functions defined in the spec. Anything that doesn't appear in the .ads file won't be accessible to a programmer who uses that particular package.\\nThe ada spec file gives you all the information you need to know to effectively use the functions in that package, and as such is the primary documentation that you want to look at. If you have the .adb and .ads files physically available to you, you can also verify that the information is correct by re-compiling the package, the Ada compiler checks to make sure that the spec and the body agree, and that everything defined in the spec is implemented in the body.\\nExample ADS file for instrumenting sorting functions:\\nThere is also a tool called AdaDoc. This can be used to generate documentation of an Ada module (or modules?) for a variety of different formats: HTML, LaTeX, plain text and more.\\nYou can use the GenDocs library.\\nIt generates html documentation in the style of the canonical ahk documentation. \\nBBCode is supported for markup. \\nA common tool for generating documentation is Doxygen:\\nROBODoc allows for documentation extracts from pretty much any language that\\nallows comments. Includes highlighting of source code. This feature has been\\nextended for COBOL to allow dashes in names, along with the normal C based\\nunderscore divider. ROBODoc looks for start and end triggers.\\nDocumentation keywords, and comment marker triggers, are managed by\\nconfiguration settings and ROBODoc ships with quite a few predefined special\\nwords. Lines after the colon terminated keywords are each extracted into\\ndifferent paragraph types. Graphviz can also be invoked to include DOT\\ndrawings, images can be embedded, and shell commands can also be invoked during\\nthe HTML generation process.\\nAnother style of auto generated documentation involves the Compiler Directive\\nFacility and using special defines to mingle documentation blocks within lines\\nof the source file, which can then be extracted and passed through various\\nmarkup processors, like Sphinx ReStructureText or Markdown.\\nExtraction of documentation segments is feasible using just the Compiler\\nDirective Facility, but it is usually easier to use sed or other tools.\\nOtherwise any Compiler Directives within the documentation become live and\\ndocumentation may trigger other conditional compile statements, usually to bad\\neffect. In the case of COBOL, this includes both the COPY and\\nREPLACE Text Manipulation keywords, which can easily show up within\\ndocumentation segments. It is safer to use an undefined conditional to simply\\nskip documentation blocks during actual code compilation and extract the\\ndocumentation lines with a separate tool before passing the extract to a markup\\nprocessor.\\nCommon Lisp allows the definition of documentation strings for functions, variables, classes, ... It also allows retrieval of documentation strings.\\nThis documentation method will work perfectly with the built in object browser in Visual Studio. The object browser can then show detailed information for each component. To make documentation that can be parsed, a triple slash (///) must be used. Further information can be found in this tutorial. A list of available xml elements for use in documentation is here.\\nD compiler comes with a builtin documentation system called Ddoc. Alternative systems may be used (a common alternative is Doxygen which includes some D support).\\nXML comments are shown in the IDE and is included in the XML documentation produced by the compiler when using --docs.\\nE's documentation facilities outside of comments are directly inspired by Javadoc and use a similar basic syntax; however, they are part of the language rather than being an idiom about using comments.\\nObjects, methods, and functions have doc-comments (much as in Python or Common Lisp); the syntax for them is /** ... */ immediately preceding the definition of the object, method, or function. (Note that E does not recognize the /*...*/ comment syntax in general.)\\nThe documentation syntax is in some ways underdefined: there is no layer which discards the leading '*'s as in Javadoc, so the documentation string contains all leading indentation (which is problematic for the source prettyprinter), and there is no formal definition yet of the syntax used within the doc-comments.\\nVariables may not have doc-comments, because they are never part of the public interface of an object.\\nThe Eiffel language was designed with a goal of producing documentation directly from software text. Certain comments, contracts for publicly accessible routines, and the class invariant are all extracted into the documentation views of a class.\\nThe following is a simple class written in Eiffel:\\nBelow is the Contract (documentation) view of the same class. It is the view that potential reuse consumers would reference when writing clients.\\nIt is important to notice what is missing from this view. It shows only the specification of the class. The implementations of routines and any routines which are not public are not visible. The notes and comments, public features (including contracts for routines), and the class invariant all remain as components of the specification.\\nThis view was produced by EiffelStudio which also supports an Interface view which is similar to the Contract view above, but also includes contracts for any inherited routines, and the complete inherited class invariant. EiffelStudio can publish these and other documentation view in HTML and other formats suitable for sharing.\\n\\nElixir uses ExDoc in order to document code. ExDoc allows users to pull data (such as name, version, source link) into their app. For example (taken from the ExDoc documentation):\\nIndividual modules can be documented using the @moduledoc attribute and heredocs (with markdown):\\nIn defun, defmacro and defsubst an optional docstring can follow the formal parameters.\\nFor defvar, defconst or defcustom an optional docstring follows the value.\\nMost other defining forms have similar optional docstrings. In all cases they must be a string constant.\\nDocstrings have no effect on code execution but are available to the user or programmer in C-h f (describe-function) etc. The docstring of a major mode function is its C-h m help (describe-mode). The Emacs Lisp Reference Manual \""Tips for Documentation Strings\"" describes various stylistic conventions.\\nThe byte compiler (of Emacs 19.29 up) generates \""dynamic docstrings\"" in the .elc files which means docstrings are not loaded into memory until actually viewed.\\nErlang has Edoc. From the documentation: \""EDoc is the Erlang program documentation generator. Inspired by the Javadoc(TM) tool for the Java(TM) programming language, EDoc is adapted to the conventions of the Erlang world, and has several features not found in Javadoc.\""\\nIt is also possible to document functions and their arguments with type information. These can be used by Dialyzer. From the documentation: \""The Dialyzer is a static analysis tool that identifies software discrepancies such as definite type errors, code which has become dead or unreachable due to some programming error, unnecessary tests, etc. in single Erlang modules or entire (sets of) applications.\""\\nFactor has an extensive documentation system built in. See docs.factorcode.org : [1]\\nFortran offers no language facilities for including documentation within a programme's code. Being typically a compiled language, the details of the source file (and any documentation that it may contain) are long gone by the time the compiled code is executing. Unlike interpreted languages, it has no access to its \""source code\"" form for self-inspection (or modification!) nor are facilities provided to attach auxiliary information to the components of a programme that might be reported at run time. A determined and diligent programmer could develop such a scheme but only by writing a lot of extra code without any special assistance from the language.\\nThere are slight exceptions to the absence of source information in the code file. The B6700 compiler offered a pseudo text variable that contains the contents of columns 73-80 (the line sequence field) of the line in which it appeared that might be passed as a parameter to a routine reporting an error message, thereby identifying the location that recognised the error. This is not a standard feature! The standard NAMELIST facility does enable a code file to read or write selected variables \""by name\"" in the format <NameOfVariable> = <Value(s)Of Variable> with a detailed form dependent on the type of the variable, and arrays have a repetition count if successive elements have equal values. This is useful when wishing to write out a complex state, or indeed to read in a complex set of data so as to supply parameters to a run without having to worry over their precise layout.\\nA compiler may produce a \""symbol table\"" identifying the names of all routines and variables, and in the older days, their addresses so that when studying a memory dump there is some hope of discovering what went wrong. But \""dump snuffling\"" is rare these days. Similarly, a run-time error such as divide-by-zero usually elicits a message giving the memory address of the divide instruction and the report may include some indication of the line number (or source sequence field) of the statement, plus the name of the routine in which it lay.\\nPut another way, reverse-compiling the code file will be unlikely to recover even the names of variables, let alone any documentation.\\nThus, documentation depends on whatever the programmer sees fit to provide in the source file, possibly under protest. Originally, only \""block\"" comments could be provided, signified by a C in column one (and in some extensions, a letter D in column one signified \""debugging\"" statements that would be compiled in or not according to the setting of a compiler option), however this vertical alternation of layers of code and commentary can be obstructive to the reader. F90 standardised the \""escape\"" comment style whereby outside a text literal, everything following an exclamation mark to the end of the line was regarded as a comment (B6700 Fortran used a %-symbol), thus code and commentary can be arranged in two non-clashing columns - especially if the source is listed via a reformatting system with that in mind. There is no comment start - comment stop facility as with {blah} in Pascal or /*blah*/ in pl/i, etc. and compilers may or may not recognise non-Fortran control lines such as $Omit or similar.\\nFortran 90 also introduced the ability to specify INTENT IN, OUT, or INOUT for parameters to routines, as well as the usual type indications. Its MODULE protocol includes an INTERFACE specification to assist in the description of collections of functions or subroutines with different types and numbers of parameters. These change what the compiler allows or rejects, but are also often important parts of documentation.\\nOtherwise, aside from separately-prepared files, the documentation resides in the source file, with layout, choice of names and organised design being the key and subject to style disputes and fashion. One special feature of Fortran is that statement labels can be used to identify logical blocks or sections in a way similar to the numbering of paragraphs in some documents. Labels might be incremented by 100 for sections, 10 for blocks within sections and 1 for stages within blocks - even if many such labels are never used in the code.\\nOutside systems are available to assist. It is common for text editors to employ syntax highlighting, but their designers rarely handle the full complexity of Fortran syntax correctly. For instance, the format of a number such as -3.145E+07 is difficult to scan, especially since in Fortran source, spaces are ignored outside of text literals. Then, consider the FORMAT codes, such as 31E16.7 and similar sequences. More serious efforts scan the Fortran source in order to extract information useful for documentation. There have long been available systems that will identify every routine in a programme and for each identify what routine calls it, and what routines it calls, along with further analysis on their parameters and their usage - this well before F90 introduced the optional INTENT feature. Similarly, within each routine, identify which variables are used (possibly as parameters) where and whether they are read or written there. And, analyse the usage of COMMON variables... Likewise, documentation might include a flowchart, and systems exist to produce these as well.\\nQuite useful documentation could be extracted just from that. By mixing actual source statements with the commentary and extracting both, inane clashes can be reduced, as in CHARACTER*6 TLA  !Three-character name. that arose because a modification to the nature of the parameter had been made, but, while revising every routine that employed such a parameter, the programmer's consciousness faded out as soon as it saw the comment start and noted \""non-Fortran source\"", to the puzzlement of subsequent readers. A system that extracted only the commentary part from that would not give a correct report, whereas with it known that the actual declaration would be included, there would be no longer any need to repeat its details in the comment and the comment could confine itself to expounding on meaning and usage. On the other hand, F90 introduced a verbose scheme for declarations wherein something like SELECTED_REAL_KIND(6, 70) might appear and copying that may well merely copy obfuscation.\\nSimilarly, there could be a convention in the file-naming scheme whereby a code file could gain access to its source file, and with further conventions put to use, it could recognise its own commands and messages and nearby find further text with explanations or examples, etc. or indeed find its own manual and print it on request. It is much better to have one file (and to maintain synchrony within it), than to have two separate files, possibly maintained by personnel in two different departments who speak different languages. An accomplished programme might even modify its own source code, say to maintain a version number - if the source code's value matches the compiled-in value then this is the first run of the new version, so increment the counter in the source code. By keeping track of the date and time, and the timestamp of each user's last use, then a user could be advised of changes to the system since their last use. Given that the update log is also within the source file and suitably identified and timestamped.\\nBut none of this is within the Fortran language definition itself.\\nCommon comments in the source code is lines starting by \""\\ \"" do not forget the space\\nexample :\\nAnother good practice is describing the stack use of a function : function ( stack before -- stack at end )\\nexample :\\nAlthough FreeBASIC has several kinds of comments it does not currently support 'documentation comments' as such.\\nHowever, there is a third party tool called fb-doc which is free software and acts as a bridge to existing C documentation generators such as gtk-doc and Doxygen.\\nGo source has both single line and block comments.\\nGodoc is an external command that extracts documentation from source code and outputs it as text or serves it as HTML. Godoc extracts exported top-level declarations and comments that preceede them. To be extracted, comments must immediately preceed the declaration with no intervening blank line. Godoc may or may not reformat comments, depending on output options, but it does this in a general way and there are no markup rules to follow.\\nExample code demonstrating what godoc extracts and what it doesn't:\\nText output of godoc: (HTML looks nicer, of course)\\nNew commands can have optional help text between the command name line and the opening { brace.\\nAny literal braces in the text must be backslash escaped \\{. The text is shown by the online help system, similar to builtin commands.\\n(See section \""Simple New Command\"" in the GRI manual.)\\n\\nHaddock is a popular documentation generator for the Haskell language.\\nSee this chapter for more information about the markup.\\nThere are no formal conventions for documentation built into the Icon/Unicon. However, there are conventions for the different libraries that are supported by automation.\\n\\nTBD\\nUse scripdoc:\\nDocumentation is typically given using Javadoc comments. Documentation is generated from these comments using the Javadoc tool. The default output (from the standard doclet) takes the form of an HTML page with frames, so HTML is frequently embedded in the comments. The comments all start with /**, end with */, and usually have \""tags\"" embedded starting with @.\\nJulia has a built-in documentation system for functions, types, and similar user-defined entities.\\nQuoting the Julia documentation pages:\\nAny string appearing at the top-level right before an object (function, macro, type or instance) will be interpreted as documenting it (these are called docstrings). Note that no blank lines or comments may intervene between a docstring and the documented object. Here is a basic example:\\nDocumentation is interpreted as Markdown, so you can use indentation and code fences to delimit code examples from text. Technically, any object can be associated with any other as metadata; Markdown happens to be the default, but one can construct other string macros and pass them to the @doc macro just as well.\\nHere is a more complex example, still using Markdown:\\nKotlin uses a system of comments called KDoc to document source code. This is similar to Java's Javadoc though there are some additional block tags to support Kotlin-specific constructs.\\nInline markup uses an extended form of the Markdown syntax.\\nThe documentation is generated using a tool called Dokka.\\nThe following is a slightly extended version of the example in the official Kotlin documentation:\\nLogtalk provides a set of entity and predicate documenting directives. The content of these and other directives can be retrieved using the language reflection features. A companion tool, \""lgtdoc\"", uses the reflection API to extract the documenting information and export it as XML files and provides a set of stylesheets to convert these file to e.g. HTML and PDF files.\\nMathematica inline documentation can be accessed directly in the code by pressing F1. No external tools required\\nThe comments will be revealed. However, a test with Octave elicited only the comment on the \""function\"" line. If the file contained merely a sequence of commands (i.e. did not constitute the definition of a function) the first line of the above example would be absent and the file would start with a comment block.\\nThe feature does not care what file type is used for input, and most C sources for Neko libraries include documentation blocks of this type.\\nCommon tools include [Doxygen http://doxygen.org], [HeaderDoc http://developer.apple.com/mac/library/documentation/DeveloperTools/Conceptual/HeaderDoc/intro/intro.html] and GSDoc. The use of doxygen is much like in C.\\nOCamldoc is a documentation generator that is included with OCaml. Documentation comments all start with (** (but no more than two asterisks) and end with *). Like Javadoc, \""tags\"" can be embedded starting with @.\\nThe primary method for documenting GP functions is the addhelp() command:\\nPARI documentation is done as for C.\\nPerl's documentation mechanism is called POD (Plain Old Documentation). Basically, any line that starts with an equal sign followed by a word (e.g. =head1) starts a documentation comment; and it lasts until a line that begins with =cut. Many formatting commands are recognized; for example, a line beginning with =item starts a section for an item, text wrapped in I< ... > is italicized, text wrapped in C< ... > is formatted as code, etc. See the perlpod and perlpodspec manuals for more details about the format.\\nSimilarly to Perl 5, Perl 6 is documented using Pod (a redesigned version of POD). However, it's not simply ignored by the parser as in Perl 5, it's an internal part of the language spec and can be used to attach documentation objects to almost any part of the code.\\nA compiler has a built-in --doc switch that will generate documentation from a given source file.\\nphpDocumentor (phpdoc) is a documentor for PHP. The syntax is similar to Javadoc.\\nPicoLisp doesn't yet support inline documentation directly in the code. However, it has built-in runtime documentation via the 'doc' function. This requires no external tools, except that the interpreter must have been started in debug mode.\\nThere is no provision for attaching documentation to functions, procedures or variables in the code, other than what may be written by the programmer as additional code, and if so, that would be without special support. The source file may contain documentation in the form of in-line comments, permitted wherever a space would appear (outside of text literals) and marked /*...comment...*/ that may continue across as many lines as desired. There is no \""nesting\"" of comments and an omitted */ might cause trouble. Being typically compiled code, such commentary is long gone when a programme is running, as is the source text. There is no provision for code examination similar to reverse compilation, so there is no way for a routine to identify its caller, or the line in the source file that is being executed. However, a programme might read its own source file and extract information therefrom. With suitable conventions, it could print a copy of its manual and so forth.\\nThere are special functions that provide the date and time that might be of use for documentation. DATE || TIME might return something like \""870304090130388\"" and yes, in the 80's it was still a two-digit year number. At compile time, say to determine the timestamp of the compilation as a part of version control and update logging, matters were a little more difficult because the results via the pre-processor were texts and not quoted. Using \""DATE\"" won't work because that is a quoted literal of four letters. Rather than stammering \""\""\""\"", confusion could be reduced by TIMESTAMP = QUOTE || DATE || TIME || QUOTE where QUOTE was a pre-processor variable that contained a quote character, stammered once. The pre-processor variable TIMESTAMP would be a text that started and ended with a quote, and could be used in normal source statements as such.\\nPowerShell includes complete built-in help for comment-based help: Just run help about_comment_based_help.\\nThis would as an example be shown in the code over view as the picture below.\\n\\nA string literal which is the first expression in a class, function, or module definition is called a docstring. It can be subsequently accessed at runtime using the .__doc__ attribute of the class, function, or module.\\npydoc, a module of the Python standard library, can automatically generate documentation gleaned from docstrings of modules. The documentation can be presented as pages of text on a terminal; automatically served to a Web Browser; or saved as HTML. The command line pydoc command , in addition, can display docstring information in a TK based GUI browser.\\nThe built-in help() function uses the pydoc module to display docstring information at the command prompt of the Python interactive shell.\\nThe Sphinx Documentation generator suite is used to generate the new Python documentation.\\nR objects are documented in files written in \""R documentation\"" (Rd) format, which is similar to LaTeX markup. See Chapter 2 of Writing R Extensions for the full details. Example function document files can be created using\\nAn example documentation file for a function 'f', taking arguments 'x' and 'y' is\\nRacket documentation is written in an integrated documentation\\ndomain-specific language called Scribble:\\nPrograms can also be written with inline documentation using either the\\nscribble/srcdoc or scribble/lp (literate programming)\\nlibraries.\\nOutput:\\nRetro allows for insertion of documentation blocks. The contents of these can be in any format desired, though the standard Retro system uses Restructured Text for all embedded and external documentation.\\n\\nOne technique with REXX is to use in-line documentation as REXX supports the accessing of\\nthe REXX program's source, which can include documentation if properly fenced.\\nThis particular example uses lowercase fences of:\\nto delineate the documentation.   But, any two unique strings could be used.\\nNote that the documentation is bracketed by the standard REXX comment delimiters to preserve program lexicographical integrity.\\nRDoc is the de-facto documentation tool that's bundled with Ruby distributions. From it's documentation:\\nRDoc produces output that looks like this.\\nRuby's documentation comments look like Perl's PODs. Translating Java's example:\\nExcellent documentation about ScalaDoc is given here in the Scala Style Guide.\\n(Squeak/Pharo)\\nDocumentation is written in files with extension .sthlp, in Stata Markup and Control Language.\\nFor instance, say we have an ado file hello.ado:\\nThe documentation file, hello.sthlp, could be:\\nPut these two file in a directory visible in the ado path. Then call the command by typing hello, and open its help file by typing help hello.\\nSee also the documentation of the help command.\\nSwift uses reStructuredText. This third-party article has some information.\\nDocumentation for Tcl code is usually prepared in separate files using a tool like doctools, but inline docs (with all their inherent limitations) can be done with the likes of Robodoc. For example:\\nBoth doctools and robodoc can produce output in multiple formats.\\nInline documentation is limited to comments within the code. However, there is no inbuilt extraction tool, so this would need to be written. The example shows how documentation for a variable and a function could be embedded within the code:\\nAlternatively, it is possible to embed documentation into LPRINT statements within a subroutine, allowing the language to print its own documentation. In the example below, the command GOSUB 2000 would print the documentation:\\n",">>> def somefunction():\\n	\""takes no args and returns None after doing not a lot\""\\n\\n	\\n>>> help(somefunction)\\nHelp on function somefunction in module __main__:\\n\\nsomefunction()\\n    takes no args and returns None after doing not a lot\\n\\n>>>"
"Python","Dot_product","Create a function/use an in-built function, to compute the   dot product,   also known as the   scalar product   of two vectors.\\nIf possible, make the vectors of arbitrary length.\\n\\nAs an example, compute the dot product of the vectors:\\n\\nIf implementing the dot product of two vectors directly:\\n\\n\\n","def dotp(a,b):\\n    assert len(a) == len(b), 'Vector sizes must match'\\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\\n\\nif __name__ == '__main__':\\n    a, b = [1, 3, -5], [4, -2, -1]\\n    assert dotp(a,b) == 3"
"Python","Doubly-linked_list/Element_definition","Define the data structure for a doubly-linked list element.\\nThe element should include a data member to hold its value and pointers to both the next element in the list and the previous element in the list.\\nThe pointers should be mutable.\\n\\n\\nUsing generics, the specification might look like this:\\nIn Ada 2005 this example can be written without declaration of an access type:\\nHere the list element is created already pointing to itself, so that no further initialization is required. The type of the element is marked as limited indicating that such elements have referential semantics and cannot be copied.\\nAda's standard container library includes a generic doubly linked list. The structure of the link element is private.\\n\\nsee Doubly-linked list/AutoHotkey\\nC++ has doubly linked list class template in standard library. However actual list noded are treated as implementation detail and encapsulated inside list. If we were to reimplement list, then node could look like that:\\nThis sort of mutable structure is not idiomatic in Clojure. Doubly-linked list/Definition#Clojure or a finger tree implementation would be better.\\nSee the functions on the Doubly-Linked List page for the usage of these structures.\\nA default constructor is implicit:\\nThis does no type-checking, under the assumption that it is being used by a containing doubly-linked list object which enforces that invariant along with others such as that element.getNext().getPrev() == element. See Doubly-Linked List#E for an actual implementation (which uses slightly more elaborate nodes than this).\\nUsing the code in Doubly-linked_list/Definition the element is defined by:\\nIn ISO Fortran 95 or later:\\nOr, using the container/list package:\\nHaskell in general doesn't have mutability so the following 'mutator' functions use lazy evaluation instead.\\nNote that unlike naive pointer manipulation which could corrupt the doubly-linked list, updateLeft and updateRight will always yield a well-formed data structure.\\nUses Unicon classes.\\nAs discussed in Doubly-linked_list/Definition#J, doubly linked lists are antithetical to J's design. Defining individual elements as independent structures is even worse. Now each element of the list must contain three arrays (everything in J is an array), all so that we can implement a list.\\nYo Dawg, we heard you like lists, so we put lists in your lists so you can list while you list.\\nNevertheless, this is doable, though it necessarily departs from the definition specified at Doubly-linked_list/Definition#J.\\nHere, when we create a new list element, we need to specify its successor node and its predecessor node and the data to be stored in the node. To start a new list we will need a node that can be the head and the tail of the list -- this will be the successor node for the last element of the list and the predecessor node for the first element of the list:\\nFor use with Java 1.4 and below, delete all \""<T>\""s and replace T's with \""Object\"".\\nInherits from LinkedList (see Singly-Linked_List_(element)#JavaScript)\\n","class Node(object):\\n     def __init__(self, data = None, prev = None, next = None):\\n         self.prev = prev\\n         self.next = next\\n         self.data = data\\n     def __str__(self):\\n         return str(self.data)\\n     def __repr__(self):\\n         return repr(self.data)\\n     def iter_forward(self):\\n         c = self\\n         while c != None:\\n             yield c\\n             c = c.next\\n     def iter_backward(self):\\n         c = self\\n         while c != None:\\n             yield c\\n             c = c.prev"
"Python","Doubly-linked_list/Element_insertion","This is much like inserting into a Singly-Linked List, but with added assignments so that the backwards-pointing links remain correct.\\nDefine the procedure:\\nCreate links and form the list.\\nElement insertion using the generic doubly linked list defined in the standard Ada containers library.\\nOutput:\\nsee Doubly-linked list/AutoHotkey\\nDefine the function:\\nProduction code should also include checks that the passed links are valid (e.g. not null pointers). There should also be code to handle special cases, such as when *anchor is the end of the existing list (i.e. anchor->next is a null pointer).\\n\\nTo call the function:\\nCreate links, and form the list:\\nThis list is now {a,b}, and c is separate.\\nNow call the function:\\nThis function call changes the list from {a,b} to {a,b,c}.\\n\\nC++ already has own linked list structure. If we were to roll our own linked list, we could implement function inserting new value after specific node like that:\\n\\nThe function handles creation of nodes in addition to inserting them.\\nExample use:\\nThis sort of mutable structure is not idiomatic in Clojure. Doubly-linked list/Definition#Clojure or a finger tree implementation would be better.\\nCode is on the Doubly-Linked List page, in function insert-between.\\n","def insert(anchor, new):\\n    new.next = anchor.next\\n    new.prev = anchor\\n    anchor.next.prev = new\\n    anchor.next = new"
"Python","Doubly-linked_list/Traversal","Traverse from the beginning of a doubly-linked list to the end, and from the end to the beginning.\\n","class List:\\n    def __init__(self, data, next=None, prev=None):\\n        self.data = data\\n        self.next = next\\n        self.prev = prev\\n\\n    def append(self, data):\\n        if self.next == None:\\n            self.next = List(data, None, self)\\n            return self.next\\n        else:\\n            return self.next.append(data)\\n\\n# Build the list\\ntail = head = List(10)\\nfor i in [ 20, 30, 40 ]:\\n    tail = tail.append(i)\\n\\n# Traverse forwards\\nnode = head\\nwhile node != None:\\n    print(node.data)\\n    node = node.next\\n\\n# Traverse Backwards\\nnode = tail\\nwhile node != None:\\n    print(node.data)\\n    node = node.prev"
"Python","Doubly-linked_list/Traversal","Traverse from the beginning of a doubly-linked list to the end, and from the end to the beginning.\\n","l = [ 10, 20, 30, 40 ]\\nfor i in l:\\n    print(i)\\nfor i in reversed(l):    # reversed produces an iterator, so only O(1) memory is used\\n    print(i)"
"Python","Dragon_curve","Create and display a dragon curve fractal.\\n(You may either display the curve directly or write it to an image file.)\\n\\nHere are some brief notes the algorithms used and how they might suit various languages.\\nThis always has F at even positions and S at odd. Eg. after 3 levels F_S_F_S_F_S_F_S. The +/- turns in between bend to the left or right the same as the \""successive approximation\"" method above. Read more at for instance Joel Castellanos' L-system page.\\nVariations are possible if you have only a single symbol for line draw, for example the Icon and Unicon and Xfractint code. The angles can also be broken into 45-degree parts to keep the expansion in a single direction rather than the endpoint rotating around.\\nThe string rewrites can be done recursively without building the whole string, just follow its instructions at the target level. See for example C by IFS Drawing code. The effect is the same as \""recursive with parameter\"" above but can draw other curves defined by L-systems. \\nOutput:\\nNote: each Dragon curve is composed of many smaller dragon curves (shown in a different colour).\\nExample code using mutual recursion can be found in Recursion Example of \""A Beginner's Guide to Amiga E\"".\\nApple IIe BASIC code can be found in Thomas Bannon, \""Fractals and Transformations\"", Mathematics Teacher, March 1991, pages 178-185. (At JSTOR.)\\nThe Asymptote source code includes an examples/dragon.asy which draws the dragon curve (four interlocking copies actually),\\nAs of its version 2.15 it uses the successive approximation method. Vertices are represented as an array of \""pairs\"" (complex numbers). Between each two vertices a new vertex is is introduced so as to double the segments, repeated to a desired level.\\nSee: Dragon curve/AutoHotkey\\n\\nSee also Sydney Afriat \""Dragon Curves\"" paper for various approaches in BASIC\\nAnd TRS-80 BASIC code in Dan Rollins, \""A Tiger Meets a Dragon: An examination of the mathematical properties of dragon curves and a program to print them on an IDS Paper Tiger\"", Byte Magazine, December 1983. (Based on generating a string of turns by appending middle turn and reversed copy. Options for the middle turn give the alternate paper folding curve and more too. The turns are then followed for the plot.)\\nThis is loosely based on the M4 predicate algorithm, only it produces a more compact ASCII output (which is also a little easier to implement), and it lets you choose the depth of the expansion rather than having to specify the coordinates of the viewing area.\\nIn Befunge-93 the 8-bit cell size restricts you to a maximum depth of 15, but in Befunge-98 you should be able go quite a bit deeper before other limits of the implementation come into play.\\n","from turtle import *\\n\\ndef dragon(step, length):\\n    dcr(step, length)\\n\\ndef dcr(step, length):\\n    step -= 1\\n    length /= 1.41421\\n    if step > 0:\\n        right(45)\\n        dcr(step, length)\\n        left(90)\\n        dcl(step, length)\\n        right(45)\\n    else:\\n        right(45)\\n        forward(length)\\n        left(90)\\n        forward(length)\\n        right(45)\\n\\ndef dcl(step, length):\\n    step -= 1\\n    length /= 1.41421\\n\\n    if step > 0:\\n        left(45)\\n        dcr(step, length)\\n        right(90)\\n        dcl(step, length)\\n        left(45)\\n    else:\\n        left(45)\\n        forward(length)\\n        right(90)\\n        forward(length)\\n        left(45)"
"Python","Dragon_curve","Create and display a dragon curve fractal.\\n(You may either display the curve directly or write it to an image file.)\\n\\nHere are some brief notes the algorithms used and how they might suit various languages.\\nThis always has F at even positions and S at odd. Eg. after 3 levels F_S_F_S_F_S_F_S. The +/- turns in between bend to the left or right the same as the \""successive approximation\"" method above. Read more at for instance Joel Castellanos' L-system page.\\nVariations are possible if you have only a single symbol for line draw, for example the Icon and Unicon and Xfractint code. The angles can also be broken into 45-degree parts to keep the expansion in a single direction rather than the endpoint rotating around.\\nThe string rewrites can be done recursively without building the whole string, just follow its instructions at the target level. See for example C by IFS Drawing code. The effect is the same as \""recursive with parameter\"" above but can draw other curves defined by L-systems. \\nOutput:\\nNote: each Dragon curve is composed of many smaller dragon curves (shown in a different colour).\\nExample code using mutual recursion can be found in Recursion Example of \""A Beginner's Guide to Amiga E\"".\\nApple IIe BASIC code can be found in Thomas Bannon, \""Fractals and Transformations\"", Mathematics Teacher, March 1991, pages 178-185. (At JSTOR.)\\nThe Asymptote source code includes an examples/dragon.asy which draws the dragon curve (four interlocking copies actually),\\nAs of its version 2.15 it uses the successive approximation method. Vertices are represented as an array of \""pairs\"" (complex numbers). Between each two vertices a new vertex is is introduced so as to double the segments, repeated to a desired level.\\nSee: Dragon curve/AutoHotkey\\n\\nSee also Sydney Afriat \""Dragon Curves\"" paper for various approaches in BASIC\\nAnd TRS-80 BASIC code in Dan Rollins, \""A Tiger Meets a Dragon: An examination of the mathematical properties of dragon curves and a program to print them on an IDS Paper Tiger\"", Byte Magazine, December 1983. (Based on generating a string of turns by appending middle turn and reversed copy. Options for the middle turn give the alternate paper folding curve and more too. The turns are then followed for the plot.)\\nThis is loosely based on the M4 predicate algorithm, only it produces a more compact ASCII output (which is also a little easier to implement), and it lets you choose the depth of the expansion rather than having to specify the coordinates of the viewing area.\\nIn Befunge-93 the 8-bit cell size restricts you to a maximum depth of 15, but in Befunge-98 you should be able go quite a bit deeper before other limits of the implementation come into play.\\n","from turtle import right, left, forward, speed, exitonclick, hideturtle\\n\\ndef dragon(level=4, size=200, zig=right, zag=left):\\n    if level <= 0:\\n        forward(size)\\n        return\\n\\n    size /= 1.41421\\n    zig(45)\\n    dragon(level-1, size, right, left)\\n    zag(90)\\n    dragon(level-1, size, left, right)\\n    zig(45)\\n\\nspeed(0)\\nhideturtle()\\ndragon(6)\\nexitonclick() # click to exit"
"Python","Dragon_curve","Create and display a dragon curve fractal.\\n(You may either display the curve directly or write it to an image file.)\\n\\nHere are some brief notes the algorithms used and how they might suit various languages.\\nThis always has F at even positions and S at odd. Eg. after 3 levels F_S_F_S_F_S_F_S. The +/- turns in between bend to the left or right the same as the \""successive approximation\"" method above. Read more at for instance Joel Castellanos' L-system page.\\nVariations are possible if you have only a single symbol for line draw, for example the Icon and Unicon and Xfractint code. The angles can also be broken into 45-degree parts to keep the expansion in a single direction rather than the endpoint rotating around.\\nThe string rewrites can be done recursively without building the whole string, just follow its instructions at the target level. See for example C by IFS Drawing code. The effect is the same as \""recursive with parameter\"" above but can draw other curves defined by L-systems. \\nOutput:\\nNote: each Dragon curve is composed of many smaller dragon curves (shown in a different colour).\\nExample code using mutual recursion can be found in Recursion Example of \""A Beginner's Guide to Amiga E\"".\\nApple IIe BASIC code can be found in Thomas Bannon, \""Fractals and Transformations\"", Mathematics Teacher, March 1991, pages 178-185. (At JSTOR.)\\nThe Asymptote source code includes an examples/dragon.asy which draws the dragon curve (four interlocking copies actually),\\nAs of its version 2.15 it uses the successive approximation method. Vertices are represented as an array of \""pairs\"" (complex numbers). Between each two vertices a new vertex is is introduced so as to double the segments, repeated to a desired level.\\nSee: Dragon curve/AutoHotkey\\n\\nSee also Sydney Afriat \""Dragon Curves\"" paper for various approaches in BASIC\\nAnd TRS-80 BASIC code in Dan Rollins, \""A Tiger Meets a Dragon: An examination of the mathematical properties of dragon curves and a program to print them on an IDS Paper Tiger\"", Byte Magazine, December 1983. (Based on generating a string of turns by appending middle turn and reversed copy. Options for the middle turn give the alternate paper folding curve and more too. The turns are then followed for the plot.)\\nThis is loosely based on the M4 predicate algorithm, only it produces a more compact ASCII output (which is also a little easier to implement), and it lets you choose the depth of the expansion rather than having to specify the coordinates of the viewing area.\\nIn Befunge-93 the 8-bit cell size restricts you to a maximum depth of 15, but in Befunge-98 you should be able go quite a bit deeper before other limits of the implementation come into play.\\n","from turtle import right, left, forward, speed, exitonclick, hideturtle\\n\\ndef dragon(level=4, size=200, direction=45):\\n    if level:\\n        right(direction)\\n        dragon(level-1, size/1.41421356237, 45)\\n        left(direction * 2)\\n        dragon(level-1, size/1.41421356237, -45)\\n        right(direction)\\n    else:\\n        forward(size)\\n\\nspeed(0)\\nhideturtle()\\ndragon(6)\\nexitonclick() # click to exit"
"Python","Draw_a_clock","Draw a clock.\\n\\nMore specific:\\n\\n\\nrequires the GDI+ Library from http://www.autohotkey.com/forum/viewtopic.php?t=32238\\nthis code from http://www.autohotkey.com/forum/viewtopic.php?p=231836#231836\\ndraws a very nice clock with GDI+\\n","import time\\n\\ndef chunks(l, n=5):\\n    return [l[i:i+n] for i in range(0, len(l), n)]\\n\\ndef binary(n, digits=8):\\n    n=int(n)\\n    return '{0:0{1}b}'.format(n, digits)\\n\\ndef secs(n):\\n    n=int(n)\\n    h='x' * n\\n    return \""|\"".join(chunks(h))\\n\\ndef bin_bit(h):\\n    h=h.replace(\""1\"",\""x\"")\\n    h=h.replace(\""0\"",\"" \"")\\n    return \""|\"".join(list(h))\\n\\n\\nx=str(time.ctime()).split()\\ny=x[3].split(\"":\"")\\n\\ns=y[-1]\\ny=map(binary,y[:-1])\\n\\nprint bin_bit(y[0])\\nprint\\nprint bin_bit(y[1])\\nprint\\nprint secs(s)"
"Python","Draw_a_cuboid","Draw a cuboid with relative dimensions of  2x3x4.  The cuboid can be represented graphically, or in ASCII art, depending on the language capabilities. To fulfill the criteria of being a cuboid, three faces must be visible.\\nEither static or rotational projection is acceptable for this task.\\n\\n\\nASCII-Art output, one width unit is two characters long ('--').\\n","def _pr(t, x, y, z):\\n    txt = '\\n'.join(''.join(t[(n,m)] for n in range(3+x+z)).rstrip()\\n                    for m in reversed(range(3+y+z)))\\n    return txt\\n		\\ndef cuboid(x,y,z):\\n    t = {(n,m):' ' for n in range(3+x+z) for m in range(3+y+z)}\\n    xrow = ['+'] + ['%i' % (i % 10) for i in range(x)] + ['+']\\n    for i,ch in enumerate(xrow):\\n        t[(i,0)] = t[(i,1+y)] = t[(1+z+i,2+y+z)] = ch\\n    if _debug: print(_pr(t, x, y, z))\\n    ycol = ['+'] + ['%i' % (j % 10) for j in range(y)] + ['+']\\n    for j,ch in enumerate(ycol):\\n        t[(0,j)] = t[(x+1,j)] = t[(2+x+z,1+z+j)] = ch\\n    zdepth = ['+'] + ['%i' % (k % 10) for k in range(z)] + ['+']\\n    if _debug: print(_pr(t, x, y, z))\\n    for k,ch in enumerate(zdepth):\\n        t[(k,1+y+k)] = t[(1+x+k,1+y+k)] = t[(1+x+k,k)] = ch\\n	\\n    return _pr(t, x, y, z)\\n\\n\\n_debug = False\\nif __name__ == '__main__':\\n    for dim in ((2,3,4), (3,4,2), (4,2,3)):\\n        print(\""CUBOID%r\"" % (dim,), cuboid(*dim), sep='\\n')"
"Python","Draw_a_cuboid","Draw a cuboid with relative dimensions of  2x3x4.  The cuboid can be represented graphically, or in ASCII art, depending on the language capabilities. To fulfill the criteria of being a cuboid, three faces must be visible.\\nEither static or rotational projection is acceptable for this task.\\n\\n\\nASCII-Art output, one width unit is two characters long ('--').\\n","from visual import *\\nmybox = box(pos=(0,0,0), length=4, height=2, width=3, axis=(-0.1,-0.1,0.1) ) \\nscene.title = \""VPython: cuboid\"""
"Python","Draw_a_cuboid","Draw a cuboid with relative dimensions of  2x3x4.  The cuboid can be represented graphically, or in ASCII art, depending on the language capabilities. To fulfill the criteria of being a cuboid, three faces must be visible.\\nEither static or rotational projection is acceptable for this task.\\n\\n\\nASCII-Art output, one width unit is two characters long ('--').\\n","\\nfrom __future__ import print_function, division\\nfrom visual import *\\nimport itertools\\n\\ntitle = \""VPython: Draw a cuboid\""\\nscene.title = title\\nprint( \""%s\\n\"" % title )\\n\\nmsg = \""\""\""\\nDrag with right mousebutton to rotate view.\\nDrag up+down with middle mousebutton to zoom.\\nLeft mouseclick to show info.\\n\\nPress x,X, y,Y, z,Z to rotate the box in single steps.\\nPress b, c,o,m to change background, color, opacity, material.\\nPress r,R to rotate, d,a for demo, automatic,  space to stop.\\nPress h to show this help,  ESC or q to quit.\\n\""\""\""\\n\\n#...+....1....+....2....+....3....+....4....+....5....+....6....+....7....+...\\n\\n## Rotate one step per keypress:\\n\\ndef rotX(obj, a) :\\n    obj.rotate( angle=a, axis=(1,0,0) )\\ndef rotY(obj, a) :\\n    obj.rotate( angle=a, axis=(0,1,0) )\\ndef rotZ(obj, a) :\\n    obj.rotate( angle=a, axis=(0,0,1) )\\n\\n## Selection of background-colors:\\n\\nbg_list = [color.gray(0.2), color.gray(0.4), color.gray(0.7), color.gray(0.9)]\\nbg = itertools.cycle(bg_list)\\ndef backgr() :\\n    b = next(bg)\\n    print(\""BackgroundColor=\"",b)\\n    scene.background = b\\n\\n## Selection of colors:\\n\\ncol_list = [color.white, color.red,  color.orange, color.yellow,  \\n            color.green, color.blue, color.cyan,   color.magenta, \\n            color.black]\\ncol = itertools.cycle(col_list)\\n#c = col.next()\\n#c = next(col)\\ndef paint(obj) :\\n    c = next(col)\\n    print(\""Color=\"",c)\\n    obj.color = c\\n\\n## Selection of opacity / transparancy :\\n\\nopa_list = [1.0, 0.7, 0.5, 0.2]\\nopa = itertools.cycle(opa_list)\\ndef solid(obj) :\\n    o = next(opa)\\n    print(\""opacity =\"",o)\\n    obj.opacity = o\\n\\n## Selection of materials:\\n\\nmName_list = [\""None\"",\\n              \""wood\"",\\n              \""rough\"",\\n              \""bricks\"",\\n              \""glass\"",\\n              \""earth\"",\\n              \""plastic\"",\\n              \""ice\"",\\n              \""diffuse\"",\\n              \""marble\"" ]\\nmat_list  = [ None,\\n              materials.wood,\\n              materials.rough,\\n              materials.bricks,\\n              materials.glass,\\n              materials.earth,\\n              materials.plastic,\\n              materials.ice,\\n              materials.diffuse,\\n              materials.marble ]\\nmName = itertools.cycle(mName_list)\\nmat   = itertools.cycle(mat_list)\\ndef surface(obj) :\\n    mM = next(mat)\\n    mN = next(mName)\\n    print(\""Material:\"", mN)\\n    obj.material = mM\\n    obj.mat      = mN\\n\\n## Selection for rotation-angle & axis :\\n\\nrotAng_list = [ 0.0, 0.005, 0.0, -0.005 ]\\nrotDir_list = [ (1,0,0), (0,1,0), (0,0,1) ]\\n\\nrotAng = itertools.cycle(rotAng_list)\\nrotDir = itertools.cycle(rotDir_list)\\n\\nrotAn = next(rotAng)     # rotAn = 0.005\\nrotAx = next(rotDir)     # rotAx = (1,0,0)\\n\\ndef rotAngle() :\\n    global rotAn\\n    rotAn = next(rotAng)\\n    print(\""RotateAngle=\"",rotAn)\\n\\ndef rotAxis() :\\n    global rotAx\\n    rotAx = next(rotDir)\\n    print(\""RotateAxis=\"",rotAx)\\n\\n## List of keypresses for demo:\\n\\n#demoC_list = [ \""h\"", \""c\"", \""a\"", \""o\"", \""m\"", \""b\"" ]\\ndemoCmd_list = \""rcbr\""+\""robr\""+\""rmR_r?\""\\ndemoCmd = itertools.cycle(demoCmd_list)\\ndef demoStep() :\\n    k = next(demoCmd)\\n    print(\""Demo:\"",k)\\n    cmd(k)\\n\\n#...+....1....+....2....+....3....+....4....+....5....+....6....+....7....+...\\n\\ndef objCount():\\n    n=0\\n    for obj in scene.objects:\\n        n=n+1\\n    return n\\n            \\ndef objInfo(obj) :\\n    print( \""\\nObject:\"", obj )\\n    print( \""Pos:\"",  obj.pos,   \""Size:\"", obj.size )\\n    print( \""Axis:\"", obj.axis,  \""Up:\"",   obj.up )\\n    print( \""Color\"", obj.color, obj.opacity )\\n    print( \""Mat:\"",  obj.mat,   obj.material )\\n\\ndef sceneInfo(sc) :\\n    print( \""\\nScene:\"",  sc )\\n    print( \"".width x height:\"",   sc.width, \""x\"", sc.height )\\n    print( \"".range:\"",   sc.range, \"".scale:\"", sc.scale )\\n    print( \"".center:\"",  sc.center )    # Camera\\n    print( \"".forward:\"", sc.forward, \"".fov:\"", sc.fov )\\n    print( \""Mouse:\"",    sc.mouse.camera, \""ray:\"", sc.mouse.ray )\\n    print( \"".ambient:\"", sc.ambient )\\n    print( \""Lights:\"",   sc.lights  )    # distant_light\\n    print( \""objects:\"", objCount(), scene.objects )\\n    \\n#...+....1....+....2....+....3....+....4....+....5....+....6....+....7....+...\\n\\nscene.width  = 600\\nscene.height = 400\\nscene.range  = 4\\n#scene.autocenter = True\\n#scene.background = color.gray(0.2)\\nscene.background = next(bg)\\n\\nautoDemo = -1\\n\\nprint( msg )\\n\\n\\n## Create cuboid (aka \""box\"") :\\n\\n# c = box()     # using default-values --> cube\\n# c = box(pos=(0,0,0), length=4, height=2, width=3, axis=(-0.1,-0.1,0.1) )\\n##c  = box(pos =( 0.0, 0.0, 0.0 ),\\n##         size=( 4, 2, 3 ),            # L,H,W\\n##         axis=( 1.0, 0.0, 0.0 ),\\n##         up  =( 0.0, 1.0, 0.0 ),\\n##         color   = color.orange,\\n##         opacity = 1.0,\\n##         material= materials.marble\\n##         )\\nc  = box(pos =( 0.0, 0.0, 0.0 ),\\n         size=( 4, 2, 3 ),            # L,H,W\\n         axis=( 1.0, 0.0, 0.0 ),\\n         up  =( 0.0, 1.0, 0.0 )\\n         )\\nprint(\""Box:\"", c)\\npaint(c)     # c.color    = color.red\\nsolid(c)     # c.opacity  = 1.0\\nsurface(c)   # c.material = materials.marble\\n\\nrotX(c,0.4)         # rotate box, to bring three faces into view\\nrotY(c,0.6)\\n\\n#sceneInfo(scene)\\n#objInfo(c)\\nprint(\""\\nPress 'a' to start auto-running demo.\"")\\n\\n#...+....1....+....2....+....3....+....4....+....5....+....6....+....7....+...\\n\\n\\n## Processing of input:\\n\\ncCount = 0\\ndef click():\\n    global cCount\\n    cCount=cCount+1\\n    sceneInfo(scene)\\n    objInfo(c)\\nscene.bind( 'click', click )\\n\\ndef keyInput():\\n    key = scene.kb.getkey()\\n    print( 'Key: \""%s\""' % key )\\n\\n    if ( (key == 'esc') or (key == 'q') ) :\\n        print( \""Bye!\"" )\\n        exit(0)\\n    else :\\n        cmd(key)\\nscene.bind('keydown', keyInput)\\n\\ndef cmd(key):\\n    global autoDemo\\n    if (key == 'h') :  print( msg )\\n    if (key == '?') :  print( msg )\\n    if (key == 's') :  sceneInfo(scene)\\n    if (key == 'i') :  objInfo(c)\\n\\n    if (key == 'x') :  rotX(c, 0.1)\\n    if (key == 'X') :  rotX(c,-0.1)\\n    if (key == 'y') :  rotY(c, 0.1)\\n    if (key == 'Y') :  rotY(c,-0.1)\\n    if (key == 'z') :  rotZ(c, 0.1)\\n    if (key == 'Z') :  rotZ(c,-0.1)\\n\\n    if (key == 'c') :  paint(c)\\n    if (key == 'o') :  solid(c)\\n    if (key == 'm') :  surface(c)\\n\\n    if (key == 'b') :  backgr()\\n    if (key == 'r') :  rotAngle()\\n    if (key == 'R') :  rotAxis()\\n    if (key == 'd') :  demoStep()\\n    if (key == 'a') :  autoDemo = -autoDemo\\n    if (key == 'A') :  autoDemo = -autoDemo\\n    if (key == ' ') :  stop()\\n\\ndef stop() :\\n    global autoDemo, rotAn\\n    autoDemo = -1\\n    while rotAn <> 0 :\\n      rotAngle() \\n    print(\""**Stop**\"")\\n      \\nr=100\\nt=0\\nwhile True:                 # Animation-loop\\n    rate(50)\\n    t = t+1\\n    if rotAn != 0 :\\n        c.rotate( angle=rotAn, axis=rotAx )\\n\\n    if t>=r :\\n        t=0\\n        if autoDemo>0 :\\n            demoStep()\\n"
"Python","Draw_a_pixel","Create a window and draw a pixel in it, subject to the following:\\n\\nIt seems that the program should be this. And the BASIC256 tutorial programs work on my ubuntu system. This program neither draws the pixel nor resizes the window. Can't see anything when I plot many spots. Oh well. I've tried the rgb(255,0,0) function as well as the fastgraphics/refresh statements.\\nRequires the WinBGIm library.\\nExample 1: Commodore 64\\nThere are no graphics commands in Commodore 64 BASIC. High resolution (hires) graphics are programmed by directly manipulating the hardware registers and memory.\\nThe Commodore 64 hires bitmap is 320×200, subdivided into 8×8 cells starting at the top left and moving right. Each cell is addressed top to bottom by 8 bytes. Each byte controls a horizontal row of 8 bits. This requires calculation on the programmer's part to translate X,Y coordinates into a specific memory address/value combination (lines 30 through 60).\\nExample 2: Commodore Plus 4 and 128\\n","from PIL import Image\\n\\nimg = Image.new('RGB', (320, 240))\\npixels = img.load()\\npixels[100,100] = (255,0,0)\\nimg.show()\\n"
"Python","Draw_a_rotating_cube","Draw a rotating cube.\\nIt should be oriented with one vertex pointing straight up, and its opposite vertex on the main diagonal (the one farthest away) straight down. It can be solid or wire-frame, and you can use ASCII art if your language doesn't have graphical capabilities. Perspective is optional.\\n\\n\\nRotating wireframe cube in OpenGL, windowing implementation via freeglut\\nAmong the capabilities of FutureBasic (or FB as it's called by its developers) is the ability to compile Open GL code as demonstrated here.\\nAs of Go 1.9, it looks as if the only standard library supporting animated graphics is image/gif - so we create an animated GIF...\\nThis implementation compiles to JavaScript that runs in a browser using the ghcjs compiler  . The reflex-dom  library is used to help with svg rendering and animation.\\nLink to live demo: https://dc25.github.io/drawRotatingCubeHaskell/\\nRun at the Julia REPL command line.\\nPerl6 has no native graphics libraries built in, but makes it fairly easy to bind to third party libraries. Here we'll use bindings to Libcaca, the Color ASCII Art library to generate a rotating cube in an ASCII terminal.\\nDon't send this to your printer!\\nSee also: Draw_a_cuboid\\n\\nSee also Draw a cuboid. This implementation uses tcllib's Linear Algebra module for some matrix ops to handle the screen transform and (animated!) rotation. Rendering is in a Tk canvas.\\nThe *Matrix* procedure is something unique to Tcl: it's essentially a control construct that leverages *expr* to make declaring matrices much more convenient than hand-rolling lists.\\nThere is a bit of wander in the top and bottom points, which might just be due to rounding error in the cube's initial \""rotation into position\"".\\nSee this wiki page (and others linked from it) for many similar examples.\\nI%, PV, and FV are all finance variables that can be found in the finance menu (inside the APPS menu on TI-83+ and up).\\nFinance variables are much faster than normal variables.\\n","from visual import *\\nscene.title = \""VPython: Draw a rotating cube\""\\n\\nscene.range = 2\\nscene.autocenter = True\\n\\nprint \""Drag with right mousebutton to rotate view.\""\\nprint \""Drag up+down with middle mousebutton to zoom.\""\\n\\ndeg45 = math.radians(45.0)  # 0.785398163397\\n\\ncube = box()    # using defaults, see http://www.vpython.org/contents/docs/defaults.html \\ncube.rotate( angle=deg45, axis=(1,0,0) )\\ncube.rotate( angle=deg45, axis=(0,0,1) )\\n\\nwhile True:                 # Animation-loop\\n    rate(50)\\n    cube.rotate( angle=0.005, axis=(0,1,0) )\\n"
"Python","Draw_a_sphere","Draw a sphere.\\nThe sphere can be represented graphically, or in ASCII art, depending on the language capabilities.\\nEither static or rotational projection is acceptable for this task.\\n\\nTranslation from the C code at http://cairographics.org/samples/gradient\\nUses the Cairo component of GtkAda to create and save as png\\nThis uses a very loose binding to SDL as found in any GPS installation. For it to work, you must choose New Project From Templte|Empty Game\\n","import math\\n\\nshades = ('.',':','!','*','o','e','&','#','%','@')\\n\\ndef normalize(v):\\n	len = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)\\n	return (v[0]/len, v[1]/len, v[2]/len)\\n\\ndef dot(x,y):\\n	d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2]\\n	return -d if d < 0 else 0\\n\\ndef draw_sphere(r, k, ambient, light):\\n	for i in range(int(math.floor(-r)),int(math.ceil(r)+1)):\\n		x = i + 0.5\\n		line = ''\\n\\n		for j in range(int(math.floor(-2*r)),int(math.ceil(2*r)+1)):\\n			y = j/2 + 0.5\\n			if x*x + y*y <= r*r:\\n				vec = normalize((x,y,math.sqrt(r*r - x*x - y*y)))\\n				b = dot(light,vec)**k + ambient\\n				intensity = int((1-b)*(len(shades)-1))\\n				line += shades[intensity] if 0 <= intensity < len(shades) else shades[0]\\n			else:\\n				line += ' '\\n\\n		print(line)\\n\\nlight = normalize((30,30,-50))\\ndraw_sphere(20,4,0.1, light)\\ndraw_sphere(10,2,0.4, light)"
"Python","Dutch_national_flag_problem","The Dutch national flag is composed of three coloured bands in the order red then white and lastly blue. The problem posed by Edsger Dijkstra is:\\nWhen the problem was first posed, Dijkstra then went on to successively refine a solution, minimising the number of swaps and the number of times the colour of a ball needed to determined and restricting the balls to end in an array, ...\\n\\n\\nThis works for ABAP Version 7.40 and above, the color blue is excluded as an option for the last entry to insure an unsorted sequence.\\n","import random\\n\\ncolours_in_order = 'Red White Blue'.split()\\n\\ndef dutch_flag_sort(items, order=colours_in_order):\\n    'return sort of items using the given order'\\n    reverse_index = dict((x,i) for i,x in enumerate(order))\\n    return sorted(items, key=lambda x: reverse_index[x])\\n\\ndef dutch_flag_check(items, order=colours_in_order):\\n    'Return True if each item of items is in the given order'\\n    reverse_index = dict((x,i) for i,x in enumerate(order))\\n    order_of_items = [reverse_index[item] for item in items]\\n    return all(x <= y for x, y in zip(order_of_items, order_of_items[1:]))\\n\\ndef random_balls(mx=5):\\n    'Select from 1 to mx balls of each colour, randomly'\\n    balls = sum([[colour] * random.randint(1, mx)\\n                 for colour in colours_in_order], [])\\n    random.shuffle(balls)\\n    return balls\\n\\ndef main():\\n    # Ensure we start unsorted\\n    while True:\\n        balls = random_balls()\\n        if not dutch_flag_check(balls):\\n            break\\n    print(\""Original Ball order:\"", balls)\\n    sorted_balls = dutch_flag_sort(balls)\\n    print(\""Sorted Ball Order:\"", sorted_balls)\\n    assert dutch_flag_check(sorted_balls), 'Whoops. Not sorted!'\\n\\nif __name__ == '__main__':\\n    main()"
"Python","Dutch_national_flag_problem","The Dutch national flag is composed of three coloured bands in the order red then white and lastly blue. The problem posed by Edsger Dijkstra is:\\nWhen the problem was first posed, Dijkstra then went on to successively refine a solution, minimising the number of swaps and the number of times the colour of a ball needed to determined and restricting the balls to end in an array, ...\\n\\n\\nThis works for ABAP Version 7.40 and above, the color blue is excluded as an option for the last entry to insure an unsorted sequence.\\n","from itertools import chain\\ndef dutch_flag_sort2(items, order=colours_in_order):\\n    'return summed filter of items using the given order'\\n    return list(chain.from_iterable(filter(lambda c: c==colour, items)\\n                                    for colour in order))"
"Python","Dutch_national_flag_problem","The Dutch national flag is composed of three coloured bands in the order red then white and lastly blue. The problem posed by Edsger Dijkstra is:\\nWhen the problem was first posed, Dijkstra then went on to successively refine a solution, minimising the number of swaps and the number of times the colour of a ball needed to determined and restricting the balls to end in an array, ...\\n\\n\\nThis works for ABAP Version 7.40 and above, the color blue is excluded as an option for the last entry to insure an unsorted sequence.\\n","def dutch_flag_sort2(items, order=colours_in_order):\\n    'return summed filter of items using the given order'\\n    return [c for colour in order for c in items if c==colour]"
"Python","Dutch_national_flag_problem","The Dutch national flag is composed of three coloured bands in the order red then white and lastly blue. The problem posed by Edsger Dijkstra is:\\nWhen the problem was first posed, Dijkstra then went on to successively refine a solution, minimising the number of swaps and the number of times the colour of a ball needed to determined and restricting the balls to end in an array, ...\\n\\n\\nThis works for ABAP Version 7.40 and above, the color blue is excluded as an option for the last entry to insure an unsorted sequence.\\n","def dutch_flag_sort3(items, order=colours_in_order):\\n    'counts each colour to construct flag'\\n    return sum([[colour] * items.count(colour) for colour in order], [])"
"Python","Dutch_national_flag_problem","The Dutch national flag is composed of three coloured bands in the order red then white and lastly blue. The problem posed by Edsger Dijkstra is:\\nWhen the problem was first posed, Dijkstra then went on to successively refine a solution, minimising the number of swaps and the number of times the colour of a ball needed to determined and restricting the balls to end in an array, ...\\n\\n\\nThis works for ABAP Version 7.40 and above, the color blue is excluded as an option for the last entry to insure an unsorted sequence.\\n","import random\\n\\ncolours_in_order = 'Red White Blue'.split()\\n\\ndef dutch_flag_sort(items):\\n    '''\\\\n    In-place sort of list items using the given order.\\n    Python idiom is to return None when argument is modified in-place\\n\\n    O(n)? Algorithm from Go language implementation of\\n    http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Sort/Flag/'''\\n\\n    lo, mid, hi = 0, 0, len(items)-1\\n    while mid <= hi:\\n        colour = items[mid]\\n        if colour == 'Red':\\n            items[lo], items[mid] = items[mid], items[lo]\\n            lo += 1\\n            mid += 1\\n        elif colour == 'White':\\n            mid += 1\\n        else:\\n            items[mid], items[hi] = items[hi], items[mid]\\n            hi -= 1\\n\\ndef dutch_flag_check(items, order=colours_in_order):\\n    'Return True if each item of items is in the given order'\\n    order_of_items = [order.index(item) for item in items]\\n    return all(x <= y for x, y in zip(order_of_items, order_of_items[1:]))\\n\\ndef random_balls(mx=5):\\n    'Select from 1 to mx balls of each colour, randomly'\\n    balls = sum(([[colour] * random.randint(1, mx)\\n                 for colour in colours_in_order]), [])\\n    random.shuffle(balls)\\n    return balls\\n\\ndef main():\\n    # Ensure we start unsorted\\n    while 1:\\n        balls = random_balls()\\n        if not dutch_flag_check(balls):\\n            break\\n    print(\""Original Ball order:\"", balls)\\n    dutch_flag_sort(balls)\\n    print(\""Sorted Ball Order:\"", balls)\\n    assert dutch_flag_check(balls), 'Whoops. Not sorted!'\\n\\nif __name__ == '__main__':\\n    main()"
"Python","Dynamic_variable_names","Create a variable with a user-defined name.\\nThe variable name should not be written in the program text, but should be taken from the user dynamically.\\n\\n\\nNot exactly a variable, but ExpandoObject allows adding properties at runtime.\\n",">>> name = raw_input(\""Enter a variable name: \"")\\nEnter a variable name: X\\n>>> globals()[name] = 42\\n>>> X\\n42"
"Python","Dynamic_variable_names","Create a variable with a user-defined name.\\nThe variable name should not be written in the program text, but should be taken from the user dynamically.\\n\\n\\nNot exactly a variable, but ExpandoObject allows adding properties at runtime.\\n",">>> name = input(\""Enter a variable name: \"")\\nEnter a variable name: X\\n>>> globals()[name] = 42\\n>>> X\\n42"
"Python","Echo_server","Create a network service that sits on TCP port 12321, which accepts connections on that port, and which echoes complete lines (using a carriage-return/line-feed sequence as line separator) back to clients. No error handling is required. For the purposes of testing, it is only necessary to support connections from localhost (127.0.0.1 or perhaps ::1). Logging of connection information to standard output is recommended.\\nThe implementation must be able to handle simultaneous connections from multiple clients. A multi-threaded or multi-process solution may be used. Each connection must be able to echo more than a single line.\\nThe implementation must not stop responding to other clients if one client sends a partial line or stops reading responses.\\nsingle-threaded, one client served at a time.\\nMulti-threaded, multiple clients served. On OS X 10.10.5 with gcc 4.9.1, serves a maximum of about 2000 threads (communication tasks) per process.\\nechoserver.ahk, modified from\\nscript by zed gecko.\\nA client is also available for testing this code.\\nSample output:\\nThis is a rather standard code (details apart); the reference guide for such a code is the Beej's Guide to Network programming. The dependency from POSIX is mainly in the use of the read and write functions, (using the socket as a file descriptor sometimes make things simpler).\\nNote here that an auto-flushing PrintWriter needs to be created, otherwise 'output' could simply be passed to write-lines.\\nHere is a basic :usocket example (it should work with any Common Lisp):\\nIt's single threaded, so you can't REPL around with a running server. You'll need to start a second Lisp prompt, load the above and\\nThe return value of that call should be \""You said: Hello echo!\"".\\nThis is a very basic server that processes the buffers one character at a time. In a real-world application, the buffers would be larger. More seriously, it processes one listener at a time. If the currSock.receive() blocks, the loop will not process other clients. This opens the door for a trivial denial-of-service attack. A realistic echo service must multiplex clients.\\nThis example will handle many connections.\\nConnections get logged to /place-where-factor-is/logs/echo-server.\\nTODO: use tasker.fs and non-blocking semantics to handle mutliple connections\\nThe following is Unicon-specific:\\n\\n","import SocketServer\\n\\nHOST = \""localhost\""\\nPORT = 12321\\n\\n# this server uses ThreadingMixIn - one thread per connection\\n# replace with ForkMixIn to spawn a new process per connection\\n\\nclass EchoServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):\\n    # no need to override anything - default behavior is just fine\\n    pass\\n\\nclass EchoRequestHandler(SocketServer.StreamRequestHandler):\\n    \""\""\""\\n    Handles one connection to the client.\\n    \""\""\""\\n    def handle(self):\\n        print \""connection from %s\"" % self.client_address[0]\\n        while True:\\n            line = self.rfile.readline()\\n            if not line: break\\n            print \""%s wrote: %s\"" % (self.client_address[0], line.rstrip())\\n            self.wfile.write(line)\\n        print \""%s disconnected\"" % self.client_address[0]\\n\\n\\n# Create the server\\nserver = EchoServer((HOST, PORT), EchoRequestHandler)\\n\\n# Activate the server; this will keep running until you\\n# interrupt the program with Ctrl-C\\nprint \""server listening on %s:%s\"" % server.server_address\\nserver.serve_forever()"
"Python","Echo_server","Create a network service that sits on TCP port 12321, which accepts connections on that port, and which echoes complete lines (using a carriage-return/line-feed sequence as line separator) back to clients. No error handling is required. For the purposes of testing, it is only necessary to support connections from localhost (127.0.0.1 or perhaps ::1). Logging of connection information to standard output is recommended.\\nThe implementation must be able to handle simultaneous connections from multiple clients. A multi-threaded or multi-process solution may be used. Each connection must be able to echo more than a single line.\\nThe implementation must not stop responding to other clients if one client sends a partial line or stops reading responses.\\nsingle-threaded, one client served at a time.\\nMulti-threaded, multiple clients served. On OS X 10.10.5 with gcc 4.9.1, serves a maximum of about 2000 threads (communication tasks) per process.\\nechoserver.ahk, modified from\\nscript by zed gecko.\\nA client is also available for testing this code.\\nSample output:\\nThis is a rather standard code (details apart); the reference guide for such a code is the Beej's Guide to Network programming. The dependency from POSIX is mainly in the use of the read and write functions, (using the socket as a file descriptor sometimes make things simpler).\\nNote here that an auto-flushing PrintWriter needs to be created, otherwise 'output' could simply be passed to write-lines.\\nHere is a basic :usocket example (it should work with any Common Lisp):\\nIt's single threaded, so you can't REPL around with a running server. You'll need to start a second Lisp prompt, load the above and\\nThe return value of that call should be \""You said: Hello echo!\"".\\nThis is a very basic server that processes the buffers one character at a time. In a real-world application, the buffers would be larger. More seriously, it processes one listener at a time. If the currSock.receive() blocks, the loop will not process other clients. This opens the door for a trivial denial-of-service attack. A realistic echo service must multiplex clients.\\nThis example will handle many connections.\\nConnections get logged to /place-where-factor-is/logs/echo-server.\\nTODO: use tasker.fs and non-blocking semantics to handle mutliple connections\\nThe following is Unicon-specific:\\n\\n","\\n#!/usr/bin/env python\\n# $ printf 'echo\\r\\n' | nc localhost 12321\\n# echo\\nimport asyncio\\nimport logging\\nimport os\\n\\nlogger = logging.getLogger('echoserver')\\n\\nasync def echo_handler(reader, writer):\\n  address = writer.get_extra_info('peername')\\n  logger.debug('accept: %s', address)\\n  message = await reader.readline()\\n  writer.write(message)\\n  await writer.drain()\\n  writer.close()\\n\\nif __name__ == '__main__':\\n  logging.basicConfig()\\n  logger.setLevel(logging.DEBUG)\\n  loop = asyncio.get_event_loop()\\n  factory = asyncio.start_server(\\n    echo_handler,\\n    os.environ.get('HOST'),\\n    os.environ.get('PORT', 12321)\\n  )\\n  server = loop.run_until_complete(factory)\\n  try:\\n    loop.run_forever()\\n  except KeyboardInterrupt:\\n    pass\\n  server.close()\\n  loop.run_until_complete(server.wait_closed())\\n  loop.close()\\n"
"Python","Echo_server","Create a network service that sits on TCP port 12321, which accepts connections on that port, and which echoes complete lines (using a carriage-return/line-feed sequence as line separator) back to clients. No error handling is required. For the purposes of testing, it is only necessary to support connections from localhost (127.0.0.1 or perhaps ::1). Logging of connection information to standard output is recommended.\\nThe implementation must be able to handle simultaneous connections from multiple clients. A multi-threaded or multi-process solution may be used. Each connection must be able to echo more than a single line.\\nThe implementation must not stop responding to other clients if one client sends a partial line or stops reading responses.\\nsingle-threaded, one client served at a time.\\nMulti-threaded, multiple clients served. On OS X 10.10.5 with gcc 4.9.1, serves a maximum of about 2000 threads (communication tasks) per process.\\nechoserver.ahk, modified from\\nscript by zed gecko.\\nA client is also available for testing this code.\\nSample output:\\nThis is a rather standard code (details apart); the reference guide for such a code is the Beej's Guide to Network programming. The dependency from POSIX is mainly in the use of the read and write functions, (using the socket as a file descriptor sometimes make things simpler).\\nNote here that an auto-flushing PrintWriter needs to be created, otherwise 'output' could simply be passed to write-lines.\\nHere is a basic :usocket example (it should work with any Common Lisp):\\nIt's single threaded, so you can't REPL around with a running server. You'll need to start a second Lisp prompt, load the above and\\nThe return value of that call should be \""You said: Hello echo!\"".\\nThis is a very basic server that processes the buffers one character at a time. In a real-world application, the buffers would be larger. More seriously, it processes one listener at a time. If the currSock.receive() blocks, the loop will not process other clients. This opens the door for a trivial denial-of-service attack. A realistic echo service must multiplex clients.\\nThis example will handle many connections.\\nConnections get logged to /place-where-factor-is/logs/echo-server.\\nTODO: use tasker.fs and non-blocking semantics to handle mutliple connections\\nThe following is Unicon-specific:\\n\\n","\\n    #!usr/bin/env python\\n    import socket\\n    import threading\\n\\n    HOST = 'localhost'\\n    PORT = 12321\\n    SOCKET_TIMEOUT = 30\\n\\n    # This function handles reading data sent by a client, echoing it back\\n    # and closing the connection in case of timeout (30s) or \""quit\"" command\\n    # This function is meant to be started in a separate thread\\n    # (one thread per client)\\n    def handle_echo(client_connection, client_address):\\n        client_connection.settimeout(SOCKET_TIMEOUT)\\n        try:\\n            while True:\\n                data = client_connection.recv(1024)\\n                # Close connection if \""quit\"" received from client\\n                if data == b'quit\\r\\n' or data == b'quit\\n':\\n                    print('{} disconnected'.format(client_address))\\n                    client_connection.shutdown(1)\\n                    client_connection.close()\\n                    break\\n                # Echo back to client\\n                elif data:\\n                    print('FROM {} : {}'.format(client_address,data))\\n                    client_connection.send(data)\\n        # Timeout and close connection after 30s of inactivity\\n        except socket.timeout:\\n            print('{} timed out'.format(client_address))\\n            client_connection.shutdown(1)\\n            client_connection.close()\\n\\n    # This function opens a socket and listens on specified port. As soon as a\\n    # connection is received, it is transfered to another socket so that the main\\n    # socket is not blocked and can accept new clients.\\n    def listen(host, port):\\n        # Create the main socket (IPv4, TCP)\\n        connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\\n        connection.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\\n        connection.bind((host, port))\\n        # Listen for clients (max 10 clients in waiting)\\n        connection.listen(10)\\n        # Every time a client connects, allow a dedicated socket and a dedicated\\n        # thread to handle communication with that client without blocking others.\\n        # Once the new thread has taken over, wait for the next client.\\n        while True:\\n            current_connection, client_address = connection.accept()\\n            print('{} connected'.format(client_address))\\n            handler_thread = threading.Thread( \\\\n                target = handle_echo, \\\\n                args = (current_connection,client_address) \\\\n            )\\n            # daemon makes sure all threads are killed if the main server process\\n            # gets killed\\n            handler_thread.daemon = True\\n            handler_thread.start()\\n\\n    if __name__ == \""__main__\"":\\n        try:\\n            listen(HOST, PORT)\\n        except KeyboardInterrupt:\\n            print('exiting')\\n            pass\\n"
"Python","Eertree","An eertree is a data structure designed for efficient processing of certain palindrome tasks, for instance counting the number of sub-palindromes in an input string.\\nThe data structure has commonalities to both tries and suffix trees.\\n  See links below.\\n\\nConstruct an eertree for the string \""eertree\"", then output all sub-palindromes by traversing the tree.\\n\\n\\n","#!/bin/python\\nfrom __future__ import print_function\\n\\nclass Node(object):\\n	def __init__(self):\\n		self.edges = {} # edges (or forward links)\\n		self.link = None # suffix link (backward links)\\n		self.len = 0 # the length of the node\\n\\nclass Eertree(object):\\n	def __init__(self):\\n		self.nodes = []\\n		# two initial root nodes\\n		self.rto = Node() #odd length root node, or node -1\\n		self.rte = Node() #even length root node, or node 0\\n\\n		# Initialize empty tree\\n		self.rto.link = self.rte.link = self.rto;\\n		self.rto.len = -1\\n		self.rte.len = 0\\n		self.S = [0] # accumulated input string, T=S[1..i]\\n		self.maxSufT = self.rte # maximum suffix of tree T\\n\\n	def get_max_suffix_pal(self, startNode, a):\\n		# We traverse the suffix-palindromes of T in the order of decreasing length.\\n		# For each palindrome we read its length k and compare T[i-k] against a\\n		# until we get an equality or arrive at the -1 node.\\n		u = startNode\\n		i = len(self.S)\\n		k = u.len\\n		while id(u) != id(self.rto) and self.S[i - k - 1] != a:\\n			assert id(u) != id(u.link) #Prevent infinte loop\\n			u = u.link\\n			k = u.len\\n\\n		return u\\n	\\n	def add(self, a):\\n\\n		# We need to find the maximum suffix-palindrome P of Ta\\n		# Start by finding maximum suffix-palindrome Q of T.\\n		# To do this, we traverse the suffix-palindromes of T\\n		# in the order of decreasing length, starting with maxSuf(T)\\n		Q = self.get_max_suffix_pal(self.maxSufT, a)\\n\\n		# We check Q to see whether it has an outgoing edge labeled by a.\\n		createANewNode = not a in Q.edges\\n\\n		if createANewNode:\\n			# We create the node P of length Q+2\\n			P = Node()\\n			self.nodes.append(P)\\n			P.len = Q.len + 2\\n			if P.len == 1:\\n				# if P = a, create the suffix link (P,0)\\n				P.link = self.rte\\n			else:\\n				# It remains to create the suffix link from P if |P|>1. Just\\n				# continue traversing suffix-palindromes of T starting with the suffix \\n				# link of Q.\\n				P.link = self.get_max_suffix_pal(Q.link, a).edges[a]\\n\\n			# create the edge (Q,P)\\n			Q.edges[a] = P\\n\\n		#P becomes the new maxSufT\\n		self.maxSufT = Q.edges[a]\\n\\n		#Store accumulated input string\\n		self.S.append(a)\\n\\n		return createANewNode\\n	\\n	def get_sub_palindromes(self, nd, nodesToHere, charsToHere, result):\\n		#Each node represents a palindrome, which can be reconstructed\\n		#by the path from the root node to each non-root node.\\n\\n		#Traverse all edges, since they represent other palindromes\\n		for lnkName in nd.edges:\\n			nd2 = nd.edges[lnkName] #The lnkName is the character used for this edge\\n			self.get_sub_palindromes(nd2, nodesToHere+[nd2], charsToHere+[lnkName], result)\\n\\n		#Reconstruct based on charsToHere characters.\\n		if id(nd) != id(self.rto) and id(nd) != id(self.rte): #Don't print for root nodes\\n			tmp = \""\"".join(charsToHere)\\n			if id(nodesToHere[0]) == id(self.rte): #Even string\\n				assembled = tmp[::-1] + tmp\\n			else: #Odd string\\n				assembled = tmp[::-1] + tmp[1:]\\n			result.append(assembled)\\n\\nif __name__==\""__main__\"":\\n	st = \""eertree\""\\n	print (\""Processing string\"", st)\\n	eertree = Eertree()\\n	for ch in st:\\n		eertree.add(ch)\\n\\n	print (\""Number of sub-palindromes:\"", len(eertree.nodes))\\n\\n	#Traverse tree to find sub-palindromes\\n	result = []\\n	eertree.get_sub_palindromes(eertree.rto, [eertree.rto], [], result) #Odd length words\\n	eertree.get_sub_palindromes(eertree.rte, [eertree.rte], [], result) #Even length words\\n	print (\""Sub-palindromes:\"", result)"
"Python","Egyptian_division","Egyptian division is a method of dividing integers using addition and\\ndoubling that is similar to the algorithm of Ethiopian multiplication\\nAlgorithm:\\nGiven two numbers where the dividend is to be divided by the divisor:\\n\\nExample: 580 / 34\\n Table creation: \\n Initialization of sums: \\n Considering table rows, bottom-up: \\nWhen a row is considered it is shown crossed out if it is not accumulated, or bold if the row causes summations.\\nAnswer\\nSo 580 divided by 34 using the Egyptian method is 17 remainder (578 - 580) or 2.\\n\\nTask\\nThe task is to create a function that does Egyptian division. The function should\\nclosely follow the description above in using a list/array of powers of two, and\\nanother of doublings.\\n\\n\\n\\n","from itertools import product\\n\\ndef egyptian_divmod(dividend, divisor):\\n    assert divisor != 0\\n    pwrs, dbls = [1], [divisor]\\n    while dbls[-1] <= dividend:\\n        pwrs.append(pwrs[-1] * 2)\\n        dbls.append(pwrs[-1] * divisor)\\n    ans, accum = 0, 0\\n    for pwr, dbl in zip(pwrs[-2::-1], dbls[-2::-1]):\\n        if accum + dbl <= dividend:\\n            accum += dbl\\n            ans += pwr\\n    return ans, abs(accum - dividend)\\n\\nif __name__ == \""__main__\"":\\n    # Test it gives the same results as the divmod built-in\\n    for i, j in product(range(13), range(1, 13)):\\n            assert egyptian_divmod(i, j) == divmod(i, j)\\n    # Mandated result\\n    i, j = 580, 34\\n    print(f'{i} divided by {j} using the Egyption method is %i remainder %i'\\n          % egyptian_divmod(i, j))"
"Python","Egyptian_division","Egyptian division is a method of dividing integers using addition and\\ndoubling that is similar to the algorithm of Ethiopian multiplication\\nAlgorithm:\\nGiven two numbers where the dividend is to be divided by the divisor:\\n\\nExample: 580 / 34\\n Table creation: \\n Initialization of sums: \\n Considering table rows, bottom-up: \\nWhen a row is considered it is shown crossed out if it is not accumulated, or bold if the row causes summations.\\nAnswer\\nSo 580 divided by 34 using the Egyptian method is 17 remainder (578 - 580) or 2.\\n\\nTask\\nThe task is to create a function that does Egyptian division. The function should\\nclosely follow the description above in using a list/array of powers of two, and\\nanother of doublings.\\n\\n\\n\\n","from functools import (reduce)\\n\\n\\n# eqyptianQuotRem :: Int -> Int -> (Int, Int)\\ndef eqyptianQuotRem(m):\\n    # Next row of doubles (unless limit reached).\\n    def expansion(xi):\\n        x, i = xi\\n        return Nothing() if x > m else Just(\\n            ((x + x, i + i), xi)\\n        )\\n\\n    # Addition from a row (if smaller than remainder).\\n    def collapse(qr, ix):\\n        i, x = ix\\n        q, r = qr\\n        return (q + i, r - x) if x < r else qr\\n\\n    return lambda n: reduce(\\n        collapse,\\n        unfoldl(expansion)((1, n)),\\n        (0, m)\\n    )\\n\\n\\n# TEST --------------------------------------------------\\ndef main():\\n    print(\\n        eqyptianQuotRem(580)(34)\\n    )\\n\\n\\n# GENERIC FUNCTIONS -------------------------------------\\n\\n# Just :: a -> Maybe a\\ndef Just(x):\\n    return {'type': 'Maybe', 'Nothing': False, 'Just': x}\\n\\n\\n# Nothing :: Maybe a\\ndef Nothing():\\n    return {'type': 'Maybe', 'Nothing': True}\\n\\n\\n# Dual of reduce – constructs a list from a seed value.\\n\\n# unfoldl :: (b -> Maybe (b, a)) -> b -> [a]\\ndef unfoldl(f):\\n    def go(xr):\\n        mb = f(xr[0])\\n        if mb.get('Nothing'):\\n            return []\\n        else:\\n            y, r = mb.get('Just')\\n            return go((y, r)) + [r]\\n\\n    return lambda x: go((x, x))\\n\\n\\n# MAIN --------------------------------------------------\\nif __name__ == '__main__':\\n    main()"
"Python","Egyptian_fractions","An   Egyptian fraction   is the sum of distinct unit fractions such as:\\nEach fraction in the expression has a numerator equal to   1   (unity)   and a denominator that is a positive integer,   and all the denominators are distinct   (i.e., no repetitions).\\nFibonacci's   Greedy algorithm for Egyptian fractions   expands the fraction    \\n\\n\\n\\n\\n\\n\\nx\\ny\\n\\n\\n\\n\\n\\n{\\displaystyle {\\tfrac {x}{y}}}\\n\\n    to be represented by repeatedly performing the replacement\\n\\n(simplifying the 2nd term in this replacement as necessary, and where    \\n\\n\\n\\n⌈\\nx\\n⌉\\n\\n\\n{\\displaystyle \\lceil x\\rceil }\\n\\n    is the   ceiling   function).\\n\\nFor this task,   Proper and improper fractions   must be able to be expressed.\\n\\nProper  fractions   are of the form    \\n\\n\\n\\n\\n\\n\\na\\nb\\n\\n\\n\\n\\n\\n{\\displaystyle {\\tfrac {a}{b}}}\\n\\n    where    \\n\\n\\n\\na\\n\\n\\n{\\displaystyle a}\\n\\n    and    \\n\\n\\n\\nb\\n\\n\\n{\\displaystyle b}\\n\\n    are positive integers, such that    \\n\\n\\n\\na\\n<\\nb\\n\\n\\n{\\displaystyle a<b}\\n\\n,     and\\nimproper fractions are of the form    \\n\\n\\n\\n\\n\\n\\na\\nb\\n\\n\\n\\n\\n\\n{\\displaystyle {\\tfrac {a}{b}}}\\n\\n    where    \\n\\n\\n\\na\\n\\n\\n{\\displaystyle a}\\n\\n    and    \\n\\n\\n\\nb\\n\\n\\n{\\displaystyle b}\\n\\n    are positive integers, such that    a ≥ b.\\n\\n(See the REXX programming example to view one method of expressing the whole number part of an improper fraction.)\\nFor improper fractions, the integer part of any improper fraction should be first isolated and shown preceding the Egyptian unit fractions, and be surrounded by square brackets [n].\\n\\n\\n\\n","from fractions import Fraction\\nfrom math import ceil\\n\\nclass Fr(Fraction):\\n    def __repr__(self):\\n        return '%s/%s' % (self.numerator, self.denominator)\\n\\ndef ef(fr):\\n    ans = []\\n    if fr >= 1:\\n        if fr.denominator == 1:\\n            return [[int(fr)], Fr(0, 1)]\\n        intfr = int(fr)\\n        ans, fr = [[intfr]], fr - intfr\\n    x, y = fr.numerator, fr.denominator\\n    while x != 1:\\n        ans.append(Fr(1, ceil(1/fr)))\\n        fr = Fr(-y % x, y* ceil(1/fr))\\n        x, y = fr.numerator, fr.denominator\\n    ans.append(fr)\\n    return ans\\n\\nif __name__ == '__main__':\\n    for fr in [Fr(43, 48), Fr(5, 121), Fr(2014, 59)]:\\n        print('%r ─► %s' % (fr, ' '.join(str(x) for x in ef(fr))))\\n    lenmax = denommax = (0, None) \\n    for fr in set(Fr(a, b) for a in range(1,100) for b in range(1, 100)):\\n        e = ef(fr)\\n        #assert sum((f[0] if type(f) is list else f) for f in e) == fr, 'Whoops!'\\n        elen, edenom = len(e), e[-1].denominator\\n        if elen > lenmax[0]:\\n            lenmax = (elen, fr, e)\\n        if edenom > denommax[0]:\\n            denommax = (edenom, fr, e)\\n    print('Term max is %r with %i terms' % (lenmax[1], lenmax[0]))\\n    dstr = str(denommax[0])\\n    print('Denominator max is %r with %i digits %s...%s' %\\n          (denommax[1], len(dstr), dstr[:5], dstr[-5:]))"
"Python","EKG_sequence_convergence","The sequence is from the natural numbers and is defined by:\\nThe sequence is called the EKG sequence (after its visual similarity to an electrocardiogram when graphed).\\nVariants of the sequence can be generated starting 1, N where N is any natural number larger than one. For the purposes of this task let us call:\\n\\nIf an algorithm that keeps track of the minimum amount of numbers and their corresponding prime factors used to generate the next term is used, then this may be known as the generators essential state. Two EKG generators with differing starts can converge to produce the same sequence after initial differences.\\nEKG(N1) and EKG(N2) are said to to have converged at and after generation a(c) if state_of(EKG(N1).a(c)) == state_of(EKG(N2).a(c)).\\n\\n\\n\\n","from itertools import count, islice, takewhile\\nfrom math import gcd\\n\\ndef EKG_gen(start=2):\\n    \""\""\""\\\\n    Generate the next term of the EKG together with the minimum cache of \\n    numbers left in its production; (the \""state\"" of the generator).\\n    Using math.gcd\\n    \""\""\""\\n    c = count(start + 1)\\n    last, so_far = start, list(range(2, start))\\n    yield 1, []\\n    yield last, []\\n    while True:\\n        for index, sf in enumerate(so_far):\\n            if gcd(last, sf) > 1:\\n                last = so_far.pop(index)\\n                yield last, so_far[::]\\n                break\\n        else:\\n            so_far.append(next(c))\\n\\ndef find_convergence(ekgs=(5,7)):\\n    \""Returns the convergence point or zero if not found within the limit\""\\n    ekg = [EKG_gen(n) for n in ekgs]\\n    for e in ekg:\\n        next(e)    # skip initial 1 in each sequence\\n    return 2 + len(list(takewhile(lambda state: not all(state[0] == s for  s in state[1:]),\\n                                  zip(*ekg))))\\n\\nif __name__ == '__main__':\\n    for start in 2, 5, 7, 9, 10:\\n        print(f\""EKG({start}):\"", str([n[0] for n in islice(EKG_gen(start), 10)])[1: -1])\\n    print(f\""\\nEKG(5) and EKG(7) converge at term {find_convergence(ekgs=(5,7))}!\"")"
"Python","EKG_sequence_convergence","The sequence is from the natural numbers and is defined by:\\nThe sequence is called the EKG sequence (after its visual similarity to an electrocardiogram when graphed).\\nVariants of the sequence can be generated starting 1, N where N is any natural number larger than one. For the purposes of this task let us call:\\n\\nIf an algorithm that keeps track of the minimum amount of numbers and their corresponding prime factors used to generate the next term is used, then this may be known as the generators essential state. Two EKG generators with differing starts can converge to produce the same sequence after initial differences.\\nEKG(N1) and EKG(N2) are said to to have converged at and after generation a(c) if state_of(EKG(N1).a(c)) == state_of(EKG(N2).a(c)).\\n\\n\\n\\n","# After running the above, in the terminal:\\nfrom pprint import pprint as pp\\n\\nfor start in 5, 7:\\n    print(f\""EKG({start}):\\n[(<next>, [<state>]), ...]\"")\\n    pp(([n for n in islice(EKG_gen(start), 21)]))"
"Python","Element-wise_operations","This task is similar to:\\n\\nImplement basic element-wise matrix-matrix and scalar-matrix operations, which can be referred to in other, higher-order tasks.\\nImplement:\\n\\nExtend the task if necessary to include additional basic operations, which should not require their own specialised task.\\n\\nUsing Generics, the task is quite trivial in Ada. Here is the main program:\\n",">>> import random\\n>>> from operator import add, sub, mul, floordiv\\n>>> from pprint import pprint as pp\\n>>> \\n>>> def ewise(matrix1, matrix2, op):\\n	return [[op(e1,e2) for e1,e2 in zip(row1, row2)] for row1,row2 in zip(matrix1, matrix2)]\\n\\n>>> m,n = 3,4 	# array dimensions\\n>>> a0 = [[random.randint(1,9) for y in range(n)] for x in range(m)]\\n>>> a1 = [[random.randint(1,9) for y in range(n)] for x in range(m)]\\n>>> pp(a0); pp(a1)\\n[[7, 8, 7, 4], [4, 9, 4, 1], [2, 3, 6, 4]]\\n[[4, 5, 1, 6], [6, 8, 3, 4], [2, 2, 6, 3]]\\n>>> pp(ewise(a0, a1, add))\\n[[11, 13, 8, 10], [10, 17, 7, 5], [4, 5, 12, 7]]\\n>>> pp(ewise(a0, a1, sub))\\n[[3, 3, 6, -2], [-2, 1, 1, -3], [0, 1, 0, 1]]\\n>>> pp(ewise(a0, a1, mul))\\n[[28, 40, 7, 24], [24, 72, 12, 4], [4, 6, 36, 12]]\\n>>> pp(ewise(a0, a1, floordiv))\\n[[1, 1, 7, 0], [0, 1, 1, 0], [1, 1, 1, 1]]\\n>>> pp(ewise(a0, a1, pow))\\n[[2401, 32768, 7, 4096], [4096, 43046721, 64, 1], [4, 9, 46656, 64]]\\n>>> pp(ewise(a0, a1, lambda x, y:2*x - y))\\n[[10, 11, 13, 2], [2, 10, 5, -2], [2, 4, 6, 5]]\\n>>> \\n>>> def s_ewise(scalar1, matrix1, op):\\n	return [[op(scalar1, e1) for e1 in row1] for row1 in matrix1]\\n\\n>>> scalar = 10\\n>>> a0\\n[[7, 8, 7, 4], [4, 9, 4, 1], [2, 3, 6, 4]]\\n>>> for op in ( add, sub, mul, floordiv, pow, lambda x, y:2*x - y ):\\n	print(\""%10s :\"" % op.__name__, s_ewise(scalar, a0, op))\\n\\n	\\n       add : [[17, 18, 17, 14], [14, 19, 14, 11], [12, 13, 16, 14]]\\n       sub : [[3, 2, 3, 6], [6, 1, 6, 9], [8, 7, 4, 6]]\\n       mul : [[70, 80, 70, 40], [40, 90, 40, 10], [20, 30, 60, 40]]\\n  floordiv : [[1, 1, 1, 2], [2, 1, 2, 10], [5, 3, 1, 2]]\\n       pow : [[10000000, 100000000, 10000000, 10000], [10000, 1000000000, 10000, 10], [100, 1000, 1000000, 10000]]\\n  <lambda> : [[13, 12, 13, 16], [16, 11, 16, 19], [18, 17, 14, 16]]\\n>>> "
"Python","Elementary_cellular_automaton/Infinite_length","The purpose of this task is to create a version of an Elementary cellular automaton whose number of cells is only limited by the memory size of the computer.\\nTo be precise, consider the state of the automaton to be made of an infinite number of cells, but with a bounded support. In other words, to describe the state of the automaton, you need a finite number of adjacent cells, along with their individual state, and you then consider that the individual state of each of all other cells is the negation of the closest individual cell among the previously defined finite number of cells.\\nExamples:\\nMore complex methods can be imagined, provided it is possible to somehow encode the infinite sections. But for this task we will stick to this simple version.\\n","def _notcell(c):\\n    return '0' if c == '1' else '1'\\n\\ndef eca_infinite(cells, rule):\\n    lencells = len(cells)\\n    rulebits = '{0:08b}'.format(rule)\\n    neighbours2next = {'{0:03b}'.format(n):rulebits[::-1][n] for n in range(8)}\\n    c = cells\\n    while True:\\n        yield c\\n        c = _notcell(c[0])*2 + c + _notcell(c[-1])*2    # Extend and pad the ends\\n\\n        c = ''.join(neighbours2next[c[i-1:i+2]] for i in range(1,len(c) - 1))\\n        #yield c[1:-1]\\n\\nif __name__ == '__main__':\\n    lines = 25\\n    for rule in (90, 30):\\n        print('\\nRule: %i' % rule)\\n        for i, c in zip(range(lines), eca_infinite('1', rule)):\\n            print('%2i: %s%s' % (i, ' '*(lines - i), c.replace('0', '.').replace('1', '#')))"
"Python","Elementary_cellular_automaton/Random_Number_Generator","Rule 30 is considered to be chaotic enough to generate good pseudo-random numbers. As a matter of fact, rule 30 is used by the Mathematica software for its default random number generator.\\nSteven Wolfram's recommendation for random number generation from rule 30 consists in extracting successive bits in a fixed position in the array of cells, as the automaton changes state.\\nThe purpose of this task is to demonstrate this. With the code written in the parent task, which you don't need to re-write here, show the ten first bytes that emerge from this recommendation. To be precise, you will start with a state of all cells but one equal to zero, and you'll follow the evolution of the particular cell whose state was initially one. Then you'll regroup those bits by packets of eight, reconstituting bytes with the first bit being the most significant.\\nYou can pick which ever length you want for the initial array but it should be visible in the code so that your output can be reproduced with an other language.\\nFor extra-credits, you will make this algorithm run as fast as possible in your language, for instance with an extensive use of bitwise logic.\\n64-bits array size, cyclic borders.\\n","from elementary_cellular_automaton import eca, eca_wrap\\n\\ndef rule30bytes(lencells=100):\\n    cells = '1' + '0' * (lencells - 1)\\n    gen = eca(cells, 30)\\n    while True:\\n        yield int(''.join(next(gen)[0] for i in range(8)), 2)\\n\\nif __name__ == '__main__':\\n    print([b for i,b in zip(range(10), rule30bytes())])"
"Python","Elementary_cellular_automaton/Random_Number_Generator","Rule 30 is considered to be chaotic enough to generate good pseudo-random numbers. As a matter of fact, rule 30 is used by the Mathematica software for its default random number generator.\\nSteven Wolfram's recommendation for random number generation from rule 30 consists in extracting successive bits in a fixed position in the array of cells, as the automaton changes state.\\nThe purpose of this task is to demonstrate this. With the code written in the parent task, which you don't need to re-write here, show the ten first bytes that emerge from this recommendation. To be precise, you will start with a state of all cells but one equal to zero, and you'll follow the evolution of the particular cell whose state was initially one. Then you'll regroup those bits by packets of eight, reconstituting bytes with the first bit being the most significant.\\nYou can pick which ever length you want for the initial array but it should be visible in the code so that your output can be reproduced with an other language.\\nFor extra-credits, you will make this algorithm run as fast as possible in your language, for instance with an extensive use of bitwise logic.\\n64-bits array size, cyclic borders.\\n","def rule30bytes(lencells=100):\\n    cells = '1' + '0' * (lencells - 1)\\n    gen = eca_wrap(cells, 30)\\n    while True:\\n        yield int(''.join(next(gen)[0] for i in range(8)), 2))"
"Python","Elliptic_curve_arithmetic","Elliptic curves   are sometimes used in   cryptography   as a way to perform   digital signatures.\\nThe purpose of this task is to implement a simplified (without modular arithmetic) version of the elliptic curve arithmetic which is required by the   elliptic curve DSA   protocol.\\nIn a nutshell, an elliptic curve is a bi-dimensional curve defined by the following relation between the x and y coordinates of any point on the curve:\\na and b are arbitrary parameters that define the specific curve which is used.\\nFor this particular task, we'll use the following parameters:\\nThe most interesting thing about elliptic curves is the fact that it is possible to define a   group   structure on it.\\nTo do so we define an   internal composition   rule with an additive notation +,   such that for any three distinct points P, Q and R on the curve, whenever these points are aligned, we have:\\nHere   0   (zero)   is the infinity point,   for which the x and y values are not defined.   It's basically the same kind of point which defines the horizon in   projective geometry.\\nWe'll also assume here that this infinity point is unique and defines the   neutral element   of the addition.\\nThis was not the definition of the addition, but only its desired property.   For a more accurate definition, we proceed as such:\\nGiven any three aligned points P, Q and R,   we define the sum   S = P + Q   as the point (possibly the infinity point) such that   S, R   and the infinity point are aligned.\\nConsidering the symmetry of the curve around the x-axis, it's easy to convince oneself that two points S and R can be aligned with the infinity point if and only if S and R are symmetric of one another towards the x-axis   (because in that case there is no other candidate than the infinity point to complete the alignment triplet).\\nS is thus defined as the symmetric of R towards the x axis.\\nThe task consists in defining the addition which, for any two points of the curve, returns the sum of these two points.   You will pick two random points on the curve, compute their sum and show that the symmetric of the sum is aligned with the two initial points.\\nYou will use the a and b parameters of secp256k1, i.e. respectively zero and seven.\\nHint:   You might need to define a \""doubling\"" function, that returns P+P for any given point P.\\nExtra credit:   define the full elliptic curve arithmetic (still not modular, though) by defining a \""multiply\"" function that returns,\\nfor any point P and integer n,   the point P + P + ... + P     (n times).\\n\\n","#!/usr/bin/env python3\\n\\nclass Point:\\n    b = 7\\n    def __init__(self, x=float('inf'), y=float('inf')):\\n        self.x = x\\n        self.y = y\\n\\n    def copy(self):\\n        return Point(self.x, self.y)\\n\\n    def is_zero(self):\\n        return self.x > 1e20 or self.x < -1e20\\n\\n    def neg(self):\\n        return Point(self.x, -self.y)\\n\\n    def dbl(self):\\n        if self.is_zero():\\n            return self.copy()\\n        try:\\n            L = (3 * self.x * self.x) / (2 * self.y)\\n        except ZeroDivisionError:\\n            return Point()\\n        x = L * L - 2 * self.x\\n        return Point(x, L * (self.x - x) - self.y)\\n\\n    def add(self, q):\\n        if self.x == q.x and self.y == q.y:\\n            return self.dbl()\\n        if self.is_zero():\\n            return q.copy()\\n        if q.is_zero():\\n            return self.copy()\\n        try:\\n            L = (q.y - self.y) / (q.x - self.x)\\n        except ZeroDivisionError:\\n            return Point()\\n        x = L * L - self.x - q.x\\n        return Point(x, L * (self.x - x) - self.y)\\n\\n    def mul(self, n):\\n        p = self.copy()\\n        r = Point()\\n        i = 1\\n        while i <= n:\\n            if i&n:\\n                r = r.add(p)\\n            p = p.dbl()\\n            i <<= 1\\n        return r\\n\\n    def __str__(self):\\n        return \""({:.3f}, {:.3f})\"".format(self.x, self.y)\\n\\ndef show(s, p):\\n    print(s, \""Zero\"" if p.is_zero() else p)\\n\\ndef from_y(y):\\n    n = y * y - Point.b\\n    x = n**(1./3) if n>=0 else -((-n)**(1./3))\\n    return Point(x, y)\\n\\n# demonstrate\\na = from_y(1)\\nb = from_y(2)\\nshow(\""a =\"", a)\\nshow(\""b =\"", b)\\nc = a.add(b)\\nshow(\""c = a + b =\"", c)\\nd = c.neg()\\nshow(\""d = -c =\"", d)\\nshow(\""c + d =\"", c.add(d))\\nshow(\""a + b + d =\"", a.add(b.add(d)))\\nshow(\""a * 12345 =\"", a.mul(12345))"
"Python","Emirp_primes","An   emirp   (prime spelled backwards)   are primes that when reversed   (in their decimal representation)   are a different prime.\\n(This rules out palindromic primes.)\\n\\n\\nIn each list, the numbers should be in order.\\nInvoke the (same) program once per task requirement, this will show what limit is used as the upper bound for calculating surplus (regular) primes.\\nThe specific method of how to determine if a range or if specific values are to be shown will be left to the programmer.\\n\\n\\nhe solution uses the package Miller_Rabin from the Miller-Rabin primality test.\\n","from __future__ import print_function\\nfrom prime_decomposition import primes, is_prime\\nfrom heapq import *\\nfrom itertools import islice\\n\\ndef emirp():\\n    largest = set()\\n    emirps = []\\n    heapify(emirps)\\n    for pr in primes():\\n        while emirps and pr > emirps[0]:\\n            yield heappop(emirps)\\n        if pr in largest:\\n            yield pr\\n        else:\\n            rp = int(str(pr)[::-1])\\n            if rp > pr and is_prime(rp):\\n                heappush(emirps, pr)\\n                largest.add(rp)\\n\\nprint('First 20:\\n  ', list(islice(emirp(), 20)))\\nprint('Between 7700 and 8000:\\n  [', end='')\\nfor pr in emirp():\\n    if pr >= 8000: break\\n    if pr >= 7700: print(pr, end=', ')\\nprint(']')\\nprint('10000th:\\n  ', list(islice(emirp(), 10000-1, 10000)))"
"Python","Empty_string","Languages may have features for dealing specifically with empty strings\\n(those containing no characters).\\n\\n\\nAssign an empty string to a variable:\\nCheck that the string is empty:\\nThe check for a non-empty string is the same, but with \""not\"" after the n:=\\nTo check if a string is empty:\\nAutoHotkey has both \""Traditional\"" or literal text, and \""Expression\"" mode.\\nThis code demonstrates the task using both methods.\\n","s = ''\\nif not s:\\n    print('String s is empty.')\\nif s:\\n    print('String s is not empty.')"
"Python","Enforced_immutability","Demonstrate any means your language has to prevent the modification of values, or to create objects that cannot be modified after they have been created.\\n\\nItems in 8th are constants if they are declared inside a word (function). Otherwise, they are mutable, unless the \""const\"" word is used:\\nThat declares that the number 123 is constant and may not be modified (not that the variable named 'one-two-three' is constant)\\nAll variables in ACL2 are constants, with the exception of those accessed using (assign ...) and accessed using (@ ...)\\nTo declare a global constant, use:\\nSubsequent attempts to redefine the constant give an error:\\nAda provides the constant keyword:\\nTypes can be declared as limited: Objects of these types cannot be changed and also not compared nor copied:\\nWhen a name is defined it can be identified as a constant value with an equality, eg pi = 355/113.\\nFor a variable an assignment \"":=\"" would be used instead, eg pi := 355/113;\\nIt should be noted that Enforced immutability goes against the nature of AHK. However, it can be achieved using objects:\\nYou could still use ObjInsert/ObjRemove functions, since they are designed to bypass any custom behaviour implemented by the object. Also, technically you could still use the SetCapacity method to truncate the object, or the GetAddress method to modify the object using memory addresses.\\nMany BASICs support the CONST keyword:\\nSome flavors of BASIC support other methods of declaring constants. For example, FreeBASIC supports C-style defines:\\nBBC BASIC doesn't have named constants. The closest you can get is to use a function:\\nAll values (expressions) in Bracmat are immutable, except those that contain = operators.\\n",">>> s = \""Hello\""\\n>>> s[0] = \""h\""\\n\\nTraceback (most recent call last):\\n  File \""<pyshell#1>\"", line 1, in <module>\\n    s[0] = \""h\""\\nTypeError: 'str' object does not support item assignment"
"Python","Enforced_immutability","Demonstrate any means your language has to prevent the modification of values, or to create objects that cannot be modified after they have been created.\\n\\nItems in 8th are constants if they are declared inside a word (function). Otherwise, they are mutable, unless the \""const\"" word is used:\\nThat declares that the number 123 is constant and may not be modified (not that the variable named 'one-two-three' is constant)\\nAll variables in ACL2 are constants, with the exception of those accessed using (assign ...) and accessed using (@ ...)\\nTo declare a global constant, use:\\nSubsequent attempts to redefine the constant give an error:\\nAda provides the constant keyword:\\nTypes can be declared as limited: Objects of these types cannot be changed and also not compared nor copied:\\nWhen a name is defined it can be identified as a constant value with an equality, eg pi = 355/113.\\nFor a variable an assignment \"":=\"" would be used instead, eg pi := 355/113;\\nIt should be noted that Enforced immutability goes against the nature of AHK. However, it can be achieved using objects:\\nYou could still use ObjInsert/ObjRemove functions, since they are designed to bypass any custom behaviour implemented by the object. Also, technically you could still use the SetCapacity method to truncate the object, or the GetAddress method to modify the object using memory addresses.\\nMany BASICs support the CONST keyword:\\nSome flavors of BASIC support other methods of declaring constants. For example, FreeBASIC supports C-style defines:\\nBBC BASIC doesn't have named constants. The closest you can get is to use a function:\\nAll values (expressions) in Bracmat are immutable, except those that contain = operators.\\n",">>> class Immut(object):\\n	def __setattr__(self, *args):\\n		raise TypeError(\\n			\""'Immut' object does not support item assignment\"")\\n	\\n        __delattr__ = __setattr__\\n	\\n        def __repr__(self):\\n		return str(self.value)\\n	\\n        def __init__(self, value):\\n                # assign to the un-assignable the hard way.\\n		super(Immut, self).__setattr__(\""value\"", value)\\n\\n>>> im = Immut(123)\\n>>> im\\n123\\n>>> im.value = 124\\n\\nTraceback (most recent call last):\\n  File \""<pyshell#27>\"", line 1, in <module>\\n    del a.value\\n  File \""<pyshell#23>\"", line 4, in __setattr__\\n    \""'Immut' object does not support item assignment\"")\\nTypeError: 'Immut' object does not support item assignment\\n>>>"
"Python","Entropy","Calculate the Shannon entropy   H   of a given input string.\\nGiven the discrete random variable \\n\\n\\n\\nX\\n\\n\\n{\\displaystyle X}\\n\\n that is a string of \\n\\n\\n\\nN\\n\\n\\n{\\displaystyle N}\\n\\n \""symbols\"" (total characters) consisting of \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n different characters (n=2 for binary), the Shannon entropy of X in bits/symbol is :\\nwhere \\n\\n\\n\\nc\\no\\nu\\nn\\n\\nt\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle count_{i}}\\n\\n is the count of character \\n\\n\\n\\n\\nn\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle n_{i}}\\n\\n.\\nFor this task, use X=\""1223334444\"" as an example. The result should be 1.84644... bits/symbol. This assumes X was a random variable, which may not be the case, or it may depend on the observer.\\nThis coding problem calculates the \""specific\"" or \""intensive\"" entropy that finds its parallel in physics with \""specific entropy\"" S0 which is entropy per kg or per mole, not like physical entropy S and therefore not the \""information\"" content of a file. It comes from Boltzmann's H-theorem where \\n\\n\\n\\nS\\n=\\n\\nk\\n\\nB\\n\\n\\nN\\nH\\n\\n\\n{\\displaystyle S=k_{B}NH}\\n\\n where N=number of molecules. Boltzmann's H is the same equation as Shannon's H, and it gives the specific entropy H on a \""per molecule\"" basis.\\nThe \""total\"", \""absolute\"", or \""extensive\"" information entropy is\\nThis is not the entropy being coded here, but it is the closest to physical entropy and a measure of the information content of a string. But it does not look for any patterns that might be available for compression, so it is a very restricted, basic, and certain measure of \""information\"". Every binary file with an equal number of 1's and 0's will have S=N bits. All hex files with equal symbol frequencies will have \\n\\n\\n\\nS\\n=\\nN\\n\\nlog\\n\\n2\\n\\n\\n⁡\\n(\\n16\\n)\\n\\n\\n{\\displaystyle S=N\\log _{2}(16)}\\n\\n bits of entropy. The total entropy in bits of the example above is S= 10*18.4644 = 18.4644 bits.\\nThe H function does not look for any patterns in data or check if X was a random variable. For example, X=000000111111 gives the same calculated entropy in all senses as Y=010011100101. For most purposes it is usually more relevant to divide the gzip length by the length of the original data to get an informal measure of how much \""order\"" was in the data.\\nTwo other \""entropies\"" are useful:\\nNormalized specific entropy:\\nwhich varies from 0 to 1 and it has units of \""entropy/symbol\"" or just 1/symbol. For this example, Hn<\\sub>= 0.923.\\nNormalized total (extensive) entropy:\\nwhich varies from 0 to N and does not have units. It is simply the \""entropy\"", but it needs to be called \""total normalized extensive entropy\"" so that it is not confused with Shannon's (specific) entropy or physical entropy. For this example, Sn<\\sub>= 9.23.\\nShannon himself is the reason his \""entropy/symbol\"" H function is very confusingly called \""entropy\"". That's like calling a function that returns a speed a \""meter\"". See section 1.7 of his classic A Mathematical Theory of Communication and search on \""per symbol\"" and \""units\"" to see he always stated his entropy H has units of \""bits/symbol\"" or \""entropy/symbol\"" or \""information/symbol\"". So it is legitimate to say entropy NH is \""information\"".\\nIn keeping with Landauer's limit, the physics entropy generated from erasing N bits is \\n\\n\\n\\nS\\n=\\n\\nH\\n\\n2\\n\\n\\nN\\n\\nk\\n\\nB\\n\\n\\nln\\n⁡\\n(\\n2\\n)\\n\\n\\n{\\displaystyle S=H_{2}Nk_{B}\\ln(2)}\\n\\n if the bit storage device is perfectly efficient. This can be solved for H2*N to (arguably) get the number of bits of information that a physical entropy represents.\\n\\nUses Ada 2012.\\nExamples:\\n","from __future__ import division\\nimport math\\n\\ndef hist(source):\\n    hist = {}; l = 0;\\n    for e in source:\\n        l += 1\\n        if e not in hist:\\n            hist[e] = 0\\n        hist[e] += 1\\n    return (l,hist)\\n\\ndef entropy(hist,l):\\n    elist = []\\n    for v in hist.values():\\n        c = v / l\\n        elist.append(-c * math.log(c ,2))\\n    return sum(elist)\\n\\ndef printHist(h):\\n    flip = lambda (k,v) : (v,k)\\n    h = sorted(h.iteritems(), key = flip)\\n    print 'Sym\\thi\\tfi\\tInf'\\n    for (k,v) in h:\\n        print '%s\\t%f\\t%f\\t%f'%(k,v,v/l,-math.log(v/l, 2))\\n    \\n    \\n\\nsource = \""1223334444\""\\n(l,h) = hist(source);\\nprint '.[Results].'\\nprint 'Length',l\\nprint 'Entropy:', entropy(h, l)\\nprintHist(h)"
"Python","Entropy","Calculate the Shannon entropy   H   of a given input string.\\nGiven the discrete random variable \\n\\n\\n\\nX\\n\\n\\n{\\displaystyle X}\\n\\n that is a string of \\n\\n\\n\\nN\\n\\n\\n{\\displaystyle N}\\n\\n \""symbols\"" (total characters) consisting of \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n different characters (n=2 for binary), the Shannon entropy of X in bits/symbol is :\\nwhere \\n\\n\\n\\nc\\no\\nu\\nn\\n\\nt\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle count_{i}}\\n\\n is the count of character \\n\\n\\n\\n\\nn\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle n_{i}}\\n\\n.\\nFor this task, use X=\""1223334444\"" as an example. The result should be 1.84644... bits/symbol. This assumes X was a random variable, which may not be the case, or it may depend on the observer.\\nThis coding problem calculates the \""specific\"" or \""intensive\"" entropy that finds its parallel in physics with \""specific entropy\"" S0 which is entropy per kg or per mole, not like physical entropy S and therefore not the \""information\"" content of a file. It comes from Boltzmann's H-theorem where \\n\\n\\n\\nS\\n=\\n\\nk\\n\\nB\\n\\n\\nN\\nH\\n\\n\\n{\\displaystyle S=k_{B}NH}\\n\\n where N=number of molecules. Boltzmann's H is the same equation as Shannon's H, and it gives the specific entropy H on a \""per molecule\"" basis.\\nThe \""total\"", \""absolute\"", or \""extensive\"" information entropy is\\nThis is not the entropy being coded here, but it is the closest to physical entropy and a measure of the information content of a string. But it does not look for any patterns that might be available for compression, so it is a very restricted, basic, and certain measure of \""information\"". Every binary file with an equal number of 1's and 0's will have S=N bits. All hex files with equal symbol frequencies will have \\n\\n\\n\\nS\\n=\\nN\\n\\nlog\\n\\n2\\n\\n\\n⁡\\n(\\n16\\n)\\n\\n\\n{\\displaystyle S=N\\log _{2}(16)}\\n\\n bits of entropy. The total entropy in bits of the example above is S= 10*18.4644 = 18.4644 bits.\\nThe H function does not look for any patterns in data or check if X was a random variable. For example, X=000000111111 gives the same calculated entropy in all senses as Y=010011100101. For most purposes it is usually more relevant to divide the gzip length by the length of the original data to get an informal measure of how much \""order\"" was in the data.\\nTwo other \""entropies\"" are useful:\\nNormalized specific entropy:\\nwhich varies from 0 to 1 and it has units of \""entropy/symbol\"" or just 1/symbol. For this example, Hn<\\sub>= 0.923.\\nNormalized total (extensive) entropy:\\nwhich varies from 0 to N and does not have units. It is simply the \""entropy\"", but it needs to be called \""total normalized extensive entropy\"" so that it is not confused with Shannon's (specific) entropy or physical entropy. For this example, Sn<\\sub>= 9.23.\\nShannon himself is the reason his \""entropy/symbol\"" H function is very confusingly called \""entropy\"". That's like calling a function that returns a speed a \""meter\"". See section 1.7 of his classic A Mathematical Theory of Communication and search on \""per symbol\"" and \""units\"" to see he always stated his entropy H has units of \""bits/symbol\"" or \""entropy/symbol\"" or \""information/symbol\"". So it is legitimate to say entropy NH is \""information\"".\\nIn keeping with Landauer's limit, the physics entropy generated from erasing N bits is \\n\\n\\n\\nS\\n=\\n\\nH\\n\\n2\\n\\n\\nN\\n\\nk\\n\\nB\\n\\n\\nln\\n⁡\\n(\\n2\\n)\\n\\n\\n{\\displaystyle S=H_{2}Nk_{B}\\ln(2)}\\n\\n if the bit storage device is perfectly efficient. This can be solved for H2*N to (arguably) get the number of bits of information that a physical entropy represents.\\n\\nUses Ada 2012.\\nExamples:\\n",">>> import math\\n>>> from collections import Counter\\n>>> \\n>>> def entropy(s):\\n...     p, lns = Counter(s), float(len(s))\\n...     return -sum( count/lns * math.log(count/lns, 2) for count in p.values())\\n... \\n>>> entropy(\""1223334444\"")\\n1.8464393446710154\\n>>> "
"Python","Entropy","Calculate the Shannon entropy   H   of a given input string.\\nGiven the discrete random variable \\n\\n\\n\\nX\\n\\n\\n{\\displaystyle X}\\n\\n that is a string of \\n\\n\\n\\nN\\n\\n\\n{\\displaystyle N}\\n\\n \""symbols\"" (total characters) consisting of \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n different characters (n=2 for binary), the Shannon entropy of X in bits/symbol is :\\nwhere \\n\\n\\n\\nc\\no\\nu\\nn\\n\\nt\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle count_{i}}\\n\\n is the count of character \\n\\n\\n\\n\\nn\\n\\ni\\n\\n\\n\\n\\n{\\displaystyle n_{i}}\\n\\n.\\nFor this task, use X=\""1223334444\"" as an example. The result should be 1.84644... bits/symbol. This assumes X was a random variable, which may not be the case, or it may depend on the observer.\\nThis coding problem calculates the \""specific\"" or \""intensive\"" entropy that finds its parallel in physics with \""specific entropy\"" S0 which is entropy per kg or per mole, not like physical entropy S and therefore not the \""information\"" content of a file. It comes from Boltzmann's H-theorem where \\n\\n\\n\\nS\\n=\\n\\nk\\n\\nB\\n\\n\\nN\\nH\\n\\n\\n{\\displaystyle S=k_{B}NH}\\n\\n where N=number of molecules. Boltzmann's H is the same equation as Shannon's H, and it gives the specific entropy H on a \""per molecule\"" basis.\\nThe \""total\"", \""absolute\"", or \""extensive\"" information entropy is\\nThis is not the entropy being coded here, but it is the closest to physical entropy and a measure of the information content of a string. But it does not look for any patterns that might be available for compression, so it is a very restricted, basic, and certain measure of \""information\"". Every binary file with an equal number of 1's and 0's will have S=N bits. All hex files with equal symbol frequencies will have \\n\\n\\n\\nS\\n=\\nN\\n\\nlog\\n\\n2\\n\\n\\n⁡\\n(\\n16\\n)\\n\\n\\n{\\displaystyle S=N\\log _{2}(16)}\\n\\n bits of entropy. The total entropy in bits of the example above is S= 10*18.4644 = 18.4644 bits.\\nThe H function does not look for any patterns in data or check if X was a random variable. For example, X=000000111111 gives the same calculated entropy in all senses as Y=010011100101. For most purposes it is usually more relevant to divide the gzip length by the length of the original data to get an informal measure of how much \""order\"" was in the data.\\nTwo other \""entropies\"" are useful:\\nNormalized specific entropy:\\nwhich varies from 0 to 1 and it has units of \""entropy/symbol\"" or just 1/symbol. For this example, Hn<\\sub>= 0.923.\\nNormalized total (extensive) entropy:\\nwhich varies from 0 to N and does not have units. It is simply the \""entropy\"", but it needs to be called \""total normalized extensive entropy\"" so that it is not confused with Shannon's (specific) entropy or physical entropy. For this example, Sn<\\sub>= 9.23.\\nShannon himself is the reason his \""entropy/symbol\"" H function is very confusingly called \""entropy\"". That's like calling a function that returns a speed a \""meter\"". See section 1.7 of his classic A Mathematical Theory of Communication and search on \""per symbol\"" and \""units\"" to see he always stated his entropy H has units of \""bits/symbol\"" or \""entropy/symbol\"" or \""information/symbol\"". So it is legitimate to say entropy NH is \""information\"".\\nIn keeping with Landauer's limit, the physics entropy generated from erasing N bits is \\n\\n\\n\\nS\\n=\\n\\nH\\n\\n2\\n\\n\\nN\\n\\nk\\n\\nB\\n\\n\\nln\\n⁡\\n(\\n2\\n)\\n\\n\\n{\\displaystyle S=H_{2}Nk_{B}\\ln(2)}\\n\\n if the bit storage device is perfectly efficient. This can be solved for H2*N to (arguably) get the number of bits of information that a physical entropy represents.\\n\\nUses Ada 2012.\\nExamples:\\n","def Entropy(text):\\n    import math\\n    log2=lambda x:math.log(x)/math.log(2)\\n    exr={}\\n    infoc=0\\n    for each in text:\\n        try:\\n            exr[each]+=1\\n        except:\\n            exr[each]=1\\n    textlen=len(text)\\n    for k,v in exr.items():\\n        freq  =  1.0*v/textlen\\n        infoc+=freq*log2(freq)\\n    infoc*=-1\\n    return infoc\\n\\nwhile True:\\n    print Entropy(raw_input('>>>'))"
"Python","Entropy/Narcissist","Write a computer program that computes and shows its own   entropy.\\n\\n\\nAssumes the source file is in the current directory and called \""entropyNarcissist.a68\"".\\n\\nNote that the source here uses spaces, not tabs, hence the low entropy, replacing all runs of four spaces with a single space\\nresults in an entropy of +4.64524532762062e +0.\\n","import math\\nfrom collections import Counter\\n\\ndef entropy(s):\\n    p, lns = Counter(s), float(len(s))\\n    return -sum( count/lns * math.log(count/lns, 2) for count in p.values())\\n\\nwith open(__file__) as f:\\n    b=f.read()\\n    \\nprint(entropy(b))"
"Python","Enumerations","Create an enumeration of constants with and without explicit values.\\n\\nACL2 doesn't have built-in enumerated types, but these macros add some basic support:\\nAda enumeration types have three distinct attributes, the enumeration literal, the enumeration position, and the representation value. The position value (starting with 0) is implied from the order of specification of the enumeration literals in the type declaration; it provides the ordering for the enumeration values. In the example below, apple (position 0) is less than banana (position 1) which is less than cherry (position 3) due to their positions, not due to their enumeration literal. An enumeration representation, when given, must not violate the order.\\nAda enumeration types are non-numeric discrete types. They can be used to index arrays, but there are no arithmetic operators for enumeration types; instead, there are predecessor and successor operations. Characters are implemented as an enumeration type in Ada.\\nNote: In this first example ALGOL 68's MODE does not create\\nFRUITS as a distinct enumerated type. In particular FRUITS remain\\ncompatible with INT and so FRUITS inherit/share all INT's operators\\nand procedures.\\n",">>> from enum import Enum\\n>>> Contact = Enum('Contact', 'FIRST_NAME, LAST_NAME, PHONE')\\n>>> Contact.__members__\\nmappingproxy(OrderedDict([('FIRST_NAME', ), ('LAST_NAME', ), ('PHONE', )]))\\n>>> \\n>>> # Explicit\\n>>> class Contact2(Enum):\\n	FIRST_NAME = 1\\n	LAST_NAME = 2\\n	PHONE = 3\\n\\n	\\n>>> Contact2.__members__\\nmappingproxy(OrderedDict([('FIRST_NAME', ), ('LAST_NAME', ), ('PHONE', )]))\\n>>> "
"Python","Enumerations","Create an enumeration of constants with and without explicit values.\\n\\nACL2 doesn't have built-in enumerated types, but these macros add some basic support:\\nAda enumeration types have three distinct attributes, the enumeration literal, the enumeration position, and the representation value. The position value (starting with 0) is implied from the order of specification of the enumeration literals in the type declaration; it provides the ordering for the enumeration values. In the example below, apple (position 0) is less than banana (position 1) which is less than cherry (position 3) due to their positions, not due to their enumeration literal. An enumeration representation, when given, must not violate the order.\\nAda enumeration types are non-numeric discrete types. They can be used to index arrays, but there are no arithmetic operators for enumeration types; instead, there are predecessor and successor operations. Characters are implemented as an enumeration type in Ada.\\nNote: In this first example ALGOL 68's MODE does not create\\nFRUITS as a distinct enumerated type. In particular FRUITS remain\\ncompatible with INT and so FRUITS inherit/share all INT's operators\\nand procedures.\\n","FIRST_NAME, LAST_NAME, PHONE = range(3)"
"Python","Enumerations","Create an enumeration of constants with and without explicit values.\\n\\nACL2 doesn't have built-in enumerated types, but these macros add some basic support:\\nAda enumeration types have three distinct attributes, the enumeration literal, the enumeration position, and the representation value. The position value (starting with 0) is implied from the order of specification of the enumeration literals in the type declaration; it provides the ordering for the enumeration values. In the example below, apple (position 0) is less than banana (position 1) which is less than cherry (position 3) due to their positions, not due to their enumeration literal. An enumeration representation, when given, must not violate the order.\\nAda enumeration types are non-numeric discrete types. They can be used to index arrays, but there are no arithmetic operators for enumeration types; instead, there are predecessor and successor operations. Characters are implemented as an enumeration type in Ada.\\nNote: In this first example ALGOL 68's MODE does not create\\nFRUITS as a distinct enumerated type. In particular FRUITS remain\\ncompatible with INT and so FRUITS inherit/share all INT's operators\\nand procedures.\\n","vars().update((key,val) for val,key in enumerate((\""FIRST_NAME\"",\""LAST_NAME\"",\""PHONE\"")))"
"Python","Environment_variables","Show how to get one of your process's environment variables.\\nThe available variables vary by system;   some of the common ones available on Unix include:\\n\\nPrint a single environment variable.\\nPrint all environment variable names and values.\\n\\nUses Matreshka.\\n","import os\\nos.environ['HOME']"
"Python","Equilibrium_index","An equilibrium index of a sequence is an index into the sequence such that the sum of elements at lower indices is equal to the sum of elements at higher indices.\\n\\nFor example, in a sequence   \\n\\n\\n\\nA\\n\\n\\n{\\displaystyle A}\\n\\n:\\n3   is an equilibrium index, because:\\n6   is also an equilibrium index, because:\\n(sum of zero elements is zero)\\n7   is not an equilibrium index, because it is not a valid index of sequence \\n\\n\\n\\nA\\n\\n\\n{\\displaystyle A}\\n\\n.\\n\\nWrite a function that, given a sequence, returns its equilibrium indices (if any).\\nAssume that the sequence may be very long.\\n\\nGeneric solution that returns a Vector of Indices.\\nequilibrium.ads:\\nequilibrium.adb:\\nTest program using two different versions, one with vectors and one with arrays:\\n","def eqindex2Pass(data):\\n    \""Two pass\""\\n    suml, sumr, ddelayed = 0, sum(data), 0\\n    for i, d in enumerate(data):\\n        suml += ddelayed\\n        sumr -= d\\n        ddelayed = d\\n        if suml == sumr:\\n            yield i"
"Python","Equilibrium_index","An equilibrium index of a sequence is an index into the sequence such that the sum of elements at lower indices is equal to the sum of elements at higher indices.\\n\\nFor example, in a sequence   \\n\\n\\n\\nA\\n\\n\\n{\\displaystyle A}\\n\\n:\\n3   is an equilibrium index, because:\\n6   is also an equilibrium index, because:\\n(sum of zero elements is zero)\\n7   is not an equilibrium index, because it is not a valid index of sequence \\n\\n\\n\\nA\\n\\n\\n{\\displaystyle A}\\n\\n.\\n\\nWrite a function that, given a sequence, returns its equilibrium indices (if any).\\nAssume that the sequence may be very long.\\n\\nGeneric solution that returns a Vector of Indices.\\nequilibrium.ads:\\nequilibrium.adb:\\nTest program using two different versions, one with vectors and one with arrays:\\n","def eqindexMultiPass(data):\\n    \""Multi pass\""\\n    for i in range(len(data)):\\n        suml, sumr = sum(data[:i]), sum(data[i+1:])\\n        if suml == sumr:\\n            yield i"
"Python","Equilibrium_index","An equilibrium index of a sequence is an index into the sequence such that the sum of elements at lower indices is equal to the sum of elements at higher indices.\\n\\nFor example, in a sequence   \\n\\n\\n\\nA\\n\\n\\n{\\displaystyle A}\\n\\n:\\n3   is an equilibrium index, because:\\n6   is also an equilibrium index, because:\\n(sum of zero elements is zero)\\n7   is not an equilibrium index, because it is not a valid index of sequence \\n\\n\\n\\nA\\n\\n\\n{\\displaystyle A}\\n\\n.\\n\\nWrite a function that, given a sequence, returns its equilibrium indices (if any).\\nAssume that the sequence may be very long.\\n\\nGeneric solution that returns a Vector of Indices.\\nequilibrium.ads:\\nequilibrium.adb:\\nTest program using two different versions, one with vectors and one with arrays:\\n","def eqindexMultiPass(s):\\n    return [i for i in xrange(len(s)) if sum(s[:i]) == sum(s[i+1:])]\\n\\nprint eqindexMultiPass([-7, 1, 5, 2, -4, 3, 0])"
"Python","Equilibrium_index","An equilibrium index of a sequence is an index into the sequence such that the sum of elements at lower indices is equal to the sum of elements at higher indices.\\n\\nFor example, in a sequence   \\n\\n\\n\\nA\\n\\n\\n{\\displaystyle A}\\n\\n:\\n3   is an equilibrium index, because:\\n6   is also an equilibrium index, because:\\n(sum of zero elements is zero)\\n7   is not an equilibrium index, because it is not a valid index of sequence \\n\\n\\n\\nA\\n\\n\\n{\\displaystyle A}\\n\\n.\\n\\nWrite a function that, given a sequence, returns its equilibrium indices (if any).\\nAssume that the sequence may be very long.\\n\\nGeneric solution that returns a Vector of Indices.\\nequilibrium.ads:\\nequilibrium.adb:\\nTest program using two different versions, one with vectors and one with arrays:\\n","from collections import defaultdict\\n\\ndef eqindex1Pass(data):\\n    \""One pass\""\\n    l, h = 0, defaultdict(list)\\n    for i, c in enumerate(data):\\n        l += c\\n        h[l * 2 - c].append(i)\\n    return h[l]"
"Python","Equilibrium_index","An equilibrium index of a sequence is an index into the sequence such that the sum of elements at lower indices is equal to the sum of elements at higher indices.\\n\\nFor example, in a sequence   \\n\\n\\n\\nA\\n\\n\\n{\\displaystyle A}\\n\\n:\\n3   is an equilibrium index, because:\\n6   is also an equilibrium index, because:\\n(sum of zero elements is zero)\\n7   is not an equilibrium index, because it is not a valid index of sequence \\n\\n\\n\\nA\\n\\n\\n{\\displaystyle A}\\n\\n.\\n\\nWrite a function that, given a sequence, returns its equilibrium indices (if any).\\nAssume that the sequence may be very long.\\n\\nGeneric solution that returns a Vector of Indices.\\nequilibrium.ads:\\nequilibrium.adb:\\nTest program using two different versions, one with vectors and one with arrays:\\n","f = (eqindex2Pass, eqindexMultiPass, eqindex1Pass)\\nd = ([-7, 1, 5, 2, -4, 3, 0],\\n     [2, 4, 6],\\n     [2, 9, 2],\\n     [1, -1, 1, -1, 1, -1, 1])\\n\\nfor data in d:\\n    print(\""d = %r\"" % data)\\n    for func in f:\\n        print(\""  %16s(d) -> %r\"" % (func.__name__, list(func(data))))"
"Python","Ethiopian_multiplication","Ethiopian multiplication is a method of multiplying integers using only addition, doubling, and halving.\\n\\nMethod: \\n\\nFor example:   17 × 34\\nHalving the first column:\\nDoubling the second column:\\nStrike-out rows whose first cell is even:\\nSum the remaining numbers in the right-hand column:\\nSo 17 multiplied by 34, by the Ethiopian method is 578.\\n\\nThe task is to define three named functions/methods/procedures/subroutines:\\n\\nUse these functions to create a function that does Ethiopian multiplication.\\n\\n\\n","tutor = True\\n\\ndef halve(x):\\n    return x // 2\\n\\ndef double(x):\\n    return x * 2\\n\\ndef even(x):\\n    return not x % 2\\n\\ndef ethiopian(multiplier, multiplicand):\\n    if tutor:\\n        print(\""Ethiopian multiplication of %i and %i\"" %\\n              (multiplier, multiplicand))\\n    result = 0\\n    while multiplier >= 1:\\n        if even(multiplier):\\n            if tutor:\\n                print(\""%4i %6i STRUCK\"" %\\n                      (multiplier, multiplicand))\\n        else:\\n            if tutor:\\n                print(\""%4i %6i KEPT\"" %\\n                      (multiplier, multiplicand))\\n            result += multiplicand\\n        multiplier   = halve(multiplier)\\n        multiplicand = double(multiplicand)\\n    if tutor:\\n        print()\\n    return result"
"Python","Ethiopian_multiplication","Ethiopian multiplication is a method of multiplying integers using only addition, doubling, and halving.\\n\\nMethod: \\n\\nFor example:   17 × 34\\nHalving the first column:\\nDoubling the second column:\\nStrike-out rows whose first cell is even:\\nSum the remaining numbers in the right-hand column:\\nSo 17 multiplied by 34, by the Ethiopian method is 578.\\n\\nThe task is to define three named functions/methods/procedures/subroutines:\\n\\nUse these functions to create a function that does Ethiopian multiplication.\\n\\n\\n","halve  = lambda x: x // 2\\ndouble = lambda x: x*2\\neven   = lambda x: not x % 2\\n \\ndef ethiopian(multiplier, multiplicand):\\n    result = 0\\n\\n    while multiplier >= 1:\\n        if not even(multiplier):\\n            result += multiplicand\\n        multiplier   = halve(multiplier)\\n        multiplicand = double(multiplicand)\\n\\n    return result"
"Python","Ethiopian_multiplication","Ethiopian multiplication is a method of multiplying integers using only addition, doubling, and halving.\\n\\nMethod: \\n\\nFor example:   17 × 34\\nHalving the first column:\\nDoubling the second column:\\nStrike-out rows whose first cell is even:\\nSum the remaining numbers in the right-hand column:\\nSo 17 multiplied by 34, by the Ethiopian method is 578.\\n\\nThe task is to define three named functions/methods/procedures/subroutines:\\n\\nUse these functions to create a function that does Ethiopian multiplication.\\n\\n\\n","tutor = True\\n\\nfrom itertools import izip, takewhile\\n\\ndef iterate(function, arg):\\n    while 1:\\n        yield arg\\n        arg = function(arg)\\n\\ndef halve(x): return x // 2\\ndef double(x): return x * 2\\ndef even(x): return x % 2 == 0\\n\\ndef show_heading(multiplier, multiplicand):\\n    print \""Multiplying %d by %d\"" % (multiplier, multiplicand),\\n    print \""using Ethiopian multiplication:\""\\n    print\\n\\nTABLE_FORMAT = \""%8s %8s %8s %8s %8s\""\\n\\ndef show_table(table):\\n    for p, q in table:\\n        print TABLE_FORMAT % (p, q, \""->\"",\\n                              p, q if not even(p) else \""-\"" * len(str(q)))\\n\\ndef show_result(result):\\n    print TABLE_FORMAT % ('', '', '', '', \""=\"" * (len(str(result)) + 1))\\n    print TABLE_FORMAT % ('', '', '', '', result)\\n\\ndef ethiopian(multiplier, multiplicand):\\n    def column1(x): return takewhile(lambda v: v >= 1, iterate(halve, x))\\n    def column2(x): return iterate(double, x)\\n    def rows(x, y): return izip(column1(x), column2(y))\\n    table = rows(multiplier, multiplicand)\\n    if tutor: \\n        table = list(table)\\n        show_heading(multiplier, multiplicand)\\n        show_table(table)\\n    result = sum(q for p, q in table if not even(p))\\n    if tutor: \\n        show_result(result)\\n    return result"
"Python","Euler_method","Euler's method numerically approximates solutions of first-order ordinary differential equations (ODEs) with a given initial value.   It is an explicit method for solving initial value problems (IVPs), as described in the wikipedia page.\\nThe ODE has to be provided in the following form:\\nwith an initial value\\nTo get a numeric solution, we replace the derivative on the   LHS   with a finite difference approximation:\\nthen solve for \\n\\n\\n\\ny\\n(\\nt\\n+\\nh\\n)\\n\\n\\n{\\displaystyle y(t+h)}\\n\\n:\\nwhich is the same as\\nThe iterative solution rule is then:\\nwhere   \\n\\n\\n\\nh\\n\\n\\n{\\displaystyle h}\\n\\n   is the step size, the most relevant parameter for accuracy of the solution.   A smaller step size increases accuracy but also the computation cost, so it has always has to be hand-picked according to the problem at hand.\\n\\nExample: Newton's Cooling Law\\nNewton's cooling law describes how an object of initial temperature   \\n\\n\\n\\nT\\n(\\n\\nt\\n\\n0\\n\\n\\n)\\n=\\n\\nT\\n\\n0\\n\\n\\n\\n\\n{\\displaystyle T(t_{0})=T_{0}}\\n\\n   cools down in an environment of temperature   \\n\\n\\n\\n\\nT\\n\\nR\\n\\n\\n\\n\\n{\\displaystyle T_{R}}\\n\\n:\\nor\\n\\nIt says that the cooling rate   \\n\\n\\n\\n\\n\\n\\nd\\nT\\n(\\nt\\n)\\n\\n\\nd\\nt\\n\\n\\n\\n\\n\\n{\\displaystyle {\\frac {dT(t)}{dt}}}\\n\\n   of the object is proportional to the current temperature difference   \\n\\n\\n\\nΔ\\nT\\n=\\n(\\nT\\n(\\nt\\n)\\n−\\n\\nT\\n\\nR\\n\\n\\n)\\n\\n\\n{\\displaystyle \\Delta T=(T(t)-T_{R})}\\n\\n   to the surrounding environment.\\nThe analytical solution, which we will compare to the numerical approximation, is\\n\\nImplement a routine of Euler's method and then to use it to solve the given example of Newton's cooling law with it for three different step sizes of:\\nand to compare with the analytical solution.\\n\\n\\nA reference solution (Common Lisp) can be seen below.   We see that bigger step sizes lead to reduced approximation accuracy.\\nThe solution is generic, usable for any floating point type. The package specification:\\nThe function Solve returns the solution of the differential equation for each of N+1 points, starting from the point T0. The implementation:\\nThe test program:\\nSample output:\\nOuput:\\nOutput:\\noutputs (steps 5 and 10)\\nLast part of output:\\nExample output:\\nThe following is in the Managed COBOL dialect:\\nExample output:\\n","def euler(f,y0,a,b,h):\\n	t,y = a,y0\\n	while t <= b:\\n		print \""%6.3f %6.3f\"" % (t,y)\\n		t += h\\n		y += h * f(t,y)\\n\\ndef newtoncooling(time, temp):\\n	return -0.07 * (temp - 20)\\n\\neuler(newtoncooling,100,0,100,10)\\n"
"Python","Euler's_identity","\\nIn mathematics,   Euler's identity   (also known as   Euler's equation)   is the equality:\\nwhere\\nEuler's identity is often cited as an example of deep mathematical beauty. Three of the basic arithmetic operations occur exactly once each: addition, multiplication, and exponentiation. The identity also links five fundamental mathematical constants:\\nShow in your language that Euler's identity is true. As much as possible and practical, mimic the Euler's identity equation.\\nMost languages are limited to IEEE 754 floating point calculations so will have some error in the calculation.\\nIf that is the case, or there is some other limitation, show\\nthat   ei\\n\\n\\n\\nπ\\n\\n\\n{\\displaystyle \\pi }\\n\\n + 1   is approximately equal to zero and\\nshow the amount of error in the calculation.\\nIf your language is capable of symbolic calculations, show\\nthat   ei\\n\\n\\n\\nπ\\n\\n\\n{\\displaystyle \\pi }\\n\\n + 1   is exactly equal to zero for bonus kudos points.\\n\\nWhilst Algol 68 has complex numbers as standard, it does not have a standard complex exp function.\\n\\nWe could use the identity exp(x + iy) = exp(x)( cos y + i sin y ), however the following uses a series expansion for exp(ix).\\n",">>> import math\\n>>> math.e ** (math.pi * 1j) + 1\\n1.2246467991473532e-16j"
"Python","Euler's_sum_of_powers_conjecture","There is a conjecture in mathematics that held for over two hundred years before it was disproved by the finding of a counterexample in 1966 by Lander and Parkin.\\n\\nLander and Parkin are known to have used a brute-force search on a   CDC 6600   computer restricting numbers to those less than 250.\\n\\nWrite a program to search for an integer solution for:\\n\\n","def eulers_sum_of_powers():\\n    max_n = 250\\n    pow_5 = [n**5 for n in range(max_n)]\\n    pow5_to_n = {n**5: n for n in range(max_n)}\\n    for x0 in range(1, max_n):\\n        for x1 in range(1, x0):\\n            for x2 in range(1, x1):\\n                for x3 in range(1, x2):\\n                    pow_5_sum = sum(pow_5[i] for i in (x0, x1, x2, x3))\\n                    if pow_5_sum in pow5_to_n:\\n                        y = pow5_to_n[pow_5_sum]\\n                        return (x0, x1, x2, x3, y)\\n\\nprint(\""%i**5 + %i**5 + %i**5 + %i**5 == %i**5\"" % eulers_sum_of_powers())"
"Python","Euler's_sum_of_powers_conjecture","There is a conjecture in mathematics that held for over two hundred years before it was disproved by the finding of a counterexample in 1966 by Lander and Parkin.\\n\\nLander and Parkin are known to have used a brute-force search on a   CDC 6600   computer restricting numbers to those less than 250.\\n\\nWrite a program to search for an integer solution for:\\n\\n","from itertools import combinations\\n\\ndef eulers_sum_of_powers():\\n    max_n = 250\\n    pow_5 = [n**5 for n in range(max_n)]\\n    pow5_to_n = {n**5: n for n in range(max_n)}\\n    for x0, x1, x2, x3 in combinations(range(1, max_n), 4):\\n        pow_5_sum = sum(pow_5[i] for i in (x0, x1, x2, x3))\\n        if pow_5_sum in pow5_to_n:\\n            y = pow5_to_n[pow_5_sum]\\n            return (x0, x1, x2, x3, y)\\n\\nprint(\""%i**5 + %i**5 + %i**5 + %i**5 == %i**5\"" % eulers_sum_of_powers())"
"Python","Euler's_sum_of_powers_conjecture","There is a conjecture in mathematics that held for over two hundred years before it was disproved by the finding of a counterexample in 1966 by Lander and Parkin.\\n\\nLander and Parkin are known to have used a brute-force search on a   CDC 6600   computer restricting numbers to those less than 250.\\n\\nWrite a program to search for an integer solution for:\\n\\n","MAX = 250\\np5, sum2 = {}, {}\\n\\nfor i in range(1, MAX):\\n	p5[i**5] = i\\n	for j in range(i, MAX):\\n		sum2[i**5 + j**5] = (i, j)\\n\\nsk = sorted(sum2.keys())\\nfor p in sorted(p5.keys()):\\n	for s in sk:\\n		if p <= s: break\\n		if p - s in sum2:\\n			print(p5[p], sum2[s] + sum2[p-s])\\n			exit()"
"Python","Evaluate_binomial_coefficients","This programming task, is to calculate ANY binomial coefficient.\\nHowever, it has to be able to output   \\n\\n\\n\\n\\n\\n\\n(\\n\\n\\n5\\n3\\n\\n\\n)\\n\\n\\n\\n\\n\\n{\\displaystyle {\\binom {5}{3}}}\\n\\n,   which is   10.\\nThis formula is recommended:\\n\\n","def binomialCoeff(n, k):\\n    result = 1\\n    for i in range(1, k+1):\\n        result = result * (n-i+1) / i\\n    return result\\n\\nif __name__ == \""__main__\"":\\n    print(binomialCoeff(5, 3))"
"Python","Evaluate_binomial_coefficients","This programming task, is to calculate ANY binomial coefficient.\\nHowever, it has to be able to output   \\n\\n\\n\\n\\n\\n\\n(\\n\\n\\n5\\n3\\n\\n\\n)\\n\\n\\n\\n\\n\\n{\\displaystyle {\\binom {5}{3}}}\\n\\n,   which is   10.\\nThis formula is recommended:\\n\\n","from operator import mul\\nfrom functools import reduce\\n\\n\\ndef comb(n,r):\\n    ''' calculate nCr - the binomial coefficient\\n    >>> comb(3,2)\\n    3\\n    >>> comb(9,4)\\n    126\\n    >>> comb(9,6)\\n    84\\n    >>> comb(20,14)\\n    38760\\n    '''\\n \\n    if r > n-r:\\n        # r = n-r   for smaller intermediate values during computation\\n        return ( reduce( mul, range((n - (n-r) + 1), n + 1), 1)\\n                 // reduce( mul, range(1, (n-r) + 1), 1) )\\n    else:\\n        return ( reduce( mul, range((n - r + 1), n + 1), 1)\\n                 // reduce( mul, range(1, r + 1), 1) )"
"Python","Evaluate_binomial_coefficients","This programming task, is to calculate ANY binomial coefficient.\\nHowever, it has to be able to output   \\n\\n\\n\\n\\n\\n\\n(\\n\\n\\n5\\n3\\n\\n\\n)\\n\\n\\n\\n\\n\\n{\\displaystyle {\\binom {5}{3}}}\\n\\n,   which is   10.\\nThis formula is recommended:\\n\\n","from functools import reduce\\n\\n\\n# binomialCoefficient :: Int -> Int -> Int\\ndef binomialCoefficient(n):\\n    return lambda k: product(\\n        enumFromTo(1 + k)(n)\\n    ) // factorial(n - k)\\n\\n\\n# GENERIC -------------------------------------------------\\n\\n# enumFromTo :: Int -> Int -> [Int]\\ndef enumFromTo(m):\\n    return lambda n: list(range(m, 1 + n))\\n\\n\\n# factorial :: Int -> Int\\ndef factorial(x):\\n    return product(enumFromTo(1)(x))\\n\\n\\n# product :: [Num] -> Num\\ndef product(xs):\\n    return reduce(lambda a, b: a * b, xs, 1)\\n\\n\\n# TESTS ---------------------------------------------------\\nif __name__ == '__main__':\\n\\n    print(\\n        binomialCoefficient(5)(3)\\n    )\\n\\n    # k=0 to k=5, where n=5\\n    print(\\n        list(map(\\n            binomialCoefficient(5),\\n            enumFromTo(0)(5)\\n        ))\\n    )"
"Python","Evaluate_binomial_coefficients","This programming task, is to calculate ANY binomial coefficient.\\nHowever, it has to be able to output   \\n\\n\\n\\n\\n\\n\\n(\\n\\n\\n5\\n3\\n\\n\\n)\\n\\n\\n\\n\\n\\n{\\displaystyle {\\binom {5}{3}}}\\n\\n,   which is   10.\\nThis formula is recommended:\\n\\n","from typing import (Callable, List, Any)\\nfrom functools import reduce\\nfrom operator import mul\\n\\n\\ndef binomialCoefficient(n: int) -> Callable[[int], int]:\\n    return lambda k: product(enumFromTo(1 + k)(n)) // factorial(n - k)\\n\\n\\ndef enumFromTo(m: int) -> Callable[[int], List[Any]]:\\n    return lambda n: list(range(m, 1 + n))\\n\\n\\ndef factorial(x: int) -> int:\\n    return product(enumFromTo(1)(x))\\n\\n\\ndef product(xs: List[Any]) -> int:\\n    return reduce(mul, xs, 1)\\n\\n\\nif __name__ == '__main__':\\n    print(binomialCoefficient(5)(3))\\n    # k=0 to k=5, where n=5\\n    print(list(map(binomialCoefficient(5), enumFromTo(0)(5))))"
"Python","Even_or_odd","Test whether an integer is even or odd.\\nThere is more than one way to solve this task:\\n\\nThe 'mod' method also works, but the bit method is fastest.\\nThis could be shortened to:\\n",">>> def is_odd(i): return bool(i & 1)\\n\\n>>> def is_even(i): return not is_odd(i)\\n\\n>>> [(j, is_odd(j)) for j in range(10)]\\n[(0, False), (1, True), (2, False), (3, True), (4, False), (5, True), (6, False), (7, True), (8, False), (9, True)]\\n>>> [(j, is_even(j)) for j in range(10)]\\n[(0, True), (1, False), (2, True), (3, False), (4, True), (5, False), (6, True), (7, False), (8, True), (9, False)]\\n>>> "
"Python","Even_or_odd","Test whether an integer is even or odd.\\nThere is more than one way to solve this task:\\n\\nThe 'mod' method also works, but the bit method is fastest.\\nThis could be shortened to:\\n",">> def is_even(i):\\n        return (i % 2) == 0\\n\\n>>> is_even(1)\\nFalse\\n>>> is_even(2)\\nTrue\\n>>>"
"Python","Events","Event is a synchronization object. An event has two states signaled and reset. A task may await for the event to enter the desired state, usually the signaled state. It is released once the state is entered. Releasing waiting tasks is called event notification. Programmatically controlled events can be set by a task into one of its states.\\nIn concurrent programming event also refers to a notification that some state has been reached through an asynchronous activity. The source of the event can be:\\nEvent is a low-level synchronization mechanism. It neither identify the state that caused it signaled, nor the source of, nor who is the subject of notification. Events augmented by data and/or publisher-subscriber schemes are often referred as messages, signals etc.\\nIn the context of general programming event-driven architecture refers to a design that deploy events in order to synchronize tasks with the asynchronous activities they must be aware of. The opposite approach is polling sometimes called busy waiting, when the synchronization is achieved by an explicit periodic querying the state of the activity. As the name suggests busy waiting consumes system resources even when the external activity does not change its state.\\nEvent-driven architectures are widely used in GUI design and SCADA systems. They are flexible and have relatively short response times. At the same time event-driven architectures suffer to the problems related to their unpredictability. They face race condition, deadlocking, live locks and priority inversion. For this reason real-time systems tend to polling schemes, trading performance for predictability in the worst case scenario.\\nThis event changes its state by an explicit request of a task. I.e. once signaled it remains in this state until it will be explicitly reset.\\nA pulse event when signaled releases all tasks awaiting it and then is automatically reset.\\nShow how a manual-reset event can be implemented in the language or else use an API to a library that provides events. Write a program that waits 1s and then signals the event to a task waiting for the event.\\nAda provides higher-level concurrency primitives, which are complete in the sense that they also allow implementations of the lower-level ones, like event. Here is an implementation of the manual-reset event.\\nThe event interface:\\nThe event implementation:\\nWith the event defined above:\\nSample output:\\nThis uses a Windows event object:\\nThis uses a simple variable as a semaphore:\\nUsing pipe to communicate to forked child. Since child will be blocking trying to read the other end of the pipe, this can be used for synchronization.\\nSample output:\\n","\\nimport threading\\nimport time\\n\\n\\ndef wait_for_event(event):\\n    event.wait()\\n    print(\""Thread: Got event\"")\\n\\ne = threading.Event()\\n\\nt = threading.Thread(target=wait_for_event, args=(e,))\\nt.start()\\n\\nprint(\""Main: Waiting one second\"")\\ntime.sleep(1.0)\\nprint(\""Main: Setting event\"")\\ne.set()\\ntime.sleep(1.0)\\nprint(\""Main: Done\"")\\nt.join()\\n"
"Python","Evolutionary_algorithm","Starting with:\\n\\n\\nNote: to aid comparison, try and ensure the variables and functions mentioned in the task description appear in solutions\\n\\nA cursory examination of a few of the solutions reveals that the instructions have not been followed rigorously in some solutions. Specifically,\\nNote that some of the the solutions given retain characters in the mutated string that are correct in the target string. However, the instruction above does not state to retain any of the characters while performing the mutation. Although some may believe to do so is implied from the use of \""converges\""\\nStrictly speaking, the new parent should be selected from the new pool of mutations, and then the new parent used to generate the next set of mutations with parent characters getting retained only by not being mutated. It then becomes possible that the new set of mutations has no member that is fitter than the parent!\\nAs illustration of this error, the code for 8th has the following remark.\\nNOTE: this has been changed, the 8th version is completely random now\\nClearly, this algo will be applying the mutation function only to the parent characters that don't match to the target characters!\\nTo ensure that the new parent is never less fit than the prior parent, both the parent and all of the latest mutations are subjected to the fitness test to select the next parent.\\n\\nThe output:\\nVery simple fitness determination. For testing purposes you can add a static seed value to the RNG initializations (sample output uses '12345' for both).\\nsample output:\\n","from string import letters\\nfrom random import choice, random\\n \\ntarget  = list(\""METHINKS IT IS LIKE A WEASEL\"")\\ncharset = letters + ' '\\nparent  = [choice(charset) for _ in range(len(target))]\\nminmutaterate  = .09\\nC = range(100)\\n \\nperfectfitness = float(len(target))\\n    \\ndef fitness(trial):\\n    'Sum of matching chars by position'\\n    return sum(t==h for t,h in zip(trial, target))\\n \\ndef mutaterate():\\n    'Less mutation the closer the fit of the parent'\\n    return 1-((perfectfitness - fitness(parent)) / perfectfitness * (1 - minmutaterate))\\n \\ndef mutate(parent, rate):\\n    return [(ch if random() <= rate else choice(charset)) for ch in parent]\\n \\ndef que():\\n    '(from the favourite saying of Manuel in Fawlty Towers)'\\n    print (\""#%-4i, fitness: %4.1f%%, '%s'\"" %\\n           (iterations, fitness(parent)*100./perfectfitness, ''.join(parent)))\\n\\ndef mate(a, b):\\n    place = 0\\n    if choice(xrange(10)) < 7:\\n        place = choice(xrange(len(target)))\\n    else:\\n        return a, b\\n    \\n    return a, b, a[:place] + b[place:], b[:place] + a[place:]\\n\\niterations = 0\\ncenter = len(C)/2\\nwhile parent != target:\\n    rate = mutaterate()\\n    iterations += 1\\n    if iterations % 100 == 0: que()\\n    copies = [ mutate(parent, rate) for _ in C ]  + [parent]\\n    parent1 = max(copies[:center], key=fitness)\\n    parent2 = max(copies[center:], key=fitness)\\n    parent = max(mate(parent1, parent2), key=fitness)\\nque()"
"Python","Evolutionary_algorithm","Starting with:\\n\\n\\nNote: to aid comparison, try and ensure the variables and functions mentioned in the task description appear in solutions\\n\\nA cursory examination of a few of the solutions reveals that the instructions have not been followed rigorously in some solutions. Specifically,\\nNote that some of the the solutions given retain characters in the mutated string that are correct in the target string. However, the instruction above does not state to retain any of the characters while performing the mutation. Although some may believe to do so is implied from the use of \""converges\""\\nStrictly speaking, the new parent should be selected from the new pool of mutations, and then the new parent used to generate the next set of mutations with parent characters getting retained only by not being mutated. It then becomes possible that the new set of mutations has no member that is fitter than the parent!\\nAs illustration of this error, the code for 8th has the following remark.\\nNOTE: this has been changed, the 8th version is completely random now\\nClearly, this algo will be applying the mutation function only to the parent characters that don't match to the target characters!\\nTo ensure that the new parent is never less fit than the prior parent, both the parent and all of the latest mutations are subjected to the fitness test to select the next parent.\\n\\nThe output:\\nVery simple fitness determination. For testing purposes you can add a static seed value to the RNG initializations (sample output uses '12345' for both).\\nsample output:\\n","from random import choice, random\\n\\ntarget  = list(\""METHINKS IT IS LIKE A WEASEL\"")\\nalphabet = \"" ABCDEFGHIJLKLMNOPQRSTUVWXYZ\""\\np = 0.05 # mutation probability\\nc = 100  # number of children in each generation\\n\\ndef neg_fitness(trial):\\n    return sum(t != h for t,h in zip(trial, target))\\n\\ndef mutate(parent):\\n    return [(choice(alphabet) if random() < p else ch) for ch in parent]\\n\\nparent = [choice(alphabet) for _ in xrange(len(target))]\\ni = 0\\nprint \""%3d\"" % i, \""\"".join(parent)\\nwhile parent != target:\\n    copies = (mutate(parent) for _ in xrange(c))\\n    parent = min(copies, key=neg_fitness)\\n    print \""%3d\"" % i, \""\"".join(parent)\\n    i += 1"
"Python","Exceptions","These are examples of control structures. You may also be interested in:\\nThis task is to give an example of an exception handling routine\\nand to \""throw\"" a new exception.\\n\\n\\nDefine an exception\\nRaise an exception\\nRe-raising once caught exception:\\nHandle an exception\\nAda.Exceptions\\nThe standard package Ada.Exceptions provides a possibility to attach messages to exceptions, to get exception occurrence information and textual description of exceptions. The following example illustrates basic functionality of:\\nAikido provides try, catch and throw statements.\\nCatching exceptions\\nThere is one catch clause per try statement. The variable caught is whatever is thrown. It does not have to be a particular type, although there is a System.Exception class defined for system exceptions.\\nThrowing exceptions\\nYou can throw any value.\\nSimple Exception Throwing\\n","import exceptions\\nclass SillyError(exceptions.Exception):\\n    def __init__(self,args=None):\\n         self.args=args"
"Python","Exceptions","These are examples of control structures. You may also be interested in:\\nThis task is to give an example of an exception handling routine\\nand to \""throw\"" a new exception.\\n\\n\\nDefine an exception\\nRaise an exception\\nRe-raising once caught exception:\\nHandle an exception\\nAda.Exceptions\\nThe standard package Ada.Exceptions provides a possibility to attach messages to exceptions, to get exception occurrence information and textual description of exceptions. The following example illustrates basic functionality of:\\nAikido provides try, catch and throw statements.\\nCatching exceptions\\nThere is one catch clause per try statement. The variable caught is whatever is thrown. It does not have to be a particular type, although there is a System.Exception class defined for system exceptions.\\nThrowing exceptions\\nYou can throw any value.\\nSimple Exception Throwing\\n","class MyInvalidArgument(ValueError):\\n   pass"
"Python","Exceptions","These are examples of control structures. You may also be interested in:\\nThis task is to give an example of an exception handling routine\\nand to \""throw\"" a new exception.\\n\\n\\nDefine an exception\\nRaise an exception\\nRe-raising once caught exception:\\nHandle an exception\\nAda.Exceptions\\nThe standard package Ada.Exceptions provides a possibility to attach messages to exceptions, to get exception occurrence information and textual description of exceptions. The following example illustrates basic functionality of:\\nAikido provides try, catch and throw statements.\\nCatching exceptions\\nThere is one catch clause per try statement. The variable caught is whatever is thrown. It does not have to be a particular type, although there is a System.Exception class defined for system exceptions.\\nThrowing exceptions\\nYou can throw any value.\\nSimple Exception Throwing\\n","def spam():\\n    raise SillyError # equivalent to raise SillyError()"
"Python","Exceptions","These are examples of control structures. You may also be interested in:\\nThis task is to give an example of an exception handling routine\\nand to \""throw\"" a new exception.\\n\\n\\nDefine an exception\\nRaise an exception\\nRe-raising once caught exception:\\nHandle an exception\\nAda.Exceptions\\nThe standard package Ada.Exceptions provides a possibility to attach messages to exceptions, to get exception occurrence information and textual description of exceptions. The following example illustrates basic functionality of:\\nAikido provides try, catch and throw statements.\\nCatching exceptions\\nThere is one catch clause per try statement. The variable caught is whatever is thrown. It does not have to be a particular type, although there is a System.Exception class defined for system exceptions.\\nThrowing exceptions\\nYou can throw any value.\\nSimple Exception Throwing\\n","def spam():\\n    raise SillyError, 'egg' # equivalent to raise SillyError('egg')"
"Python","Exceptions","These are examples of control structures. You may also be interested in:\\nThis task is to give an example of an exception handling routine\\nand to \""throw\"" a new exception.\\n\\n\\nDefine an exception\\nRaise an exception\\nRe-raising once caught exception:\\nHandle an exception\\nAda.Exceptions\\nThe standard package Ada.Exceptions provides a possibility to attach messages to exceptions, to get exception occurrence information and textual description of exceptions. The following example illustrates basic functionality of:\\nAikido provides try, catch and throw statements.\\nCatching exceptions\\nThere is one catch clause per try statement. The variable caught is whatever is thrown. It does not have to be a particular type, although there is a System.Exception class defined for system exceptions.\\nThrowing exceptions\\nYou can throw any value.\\nSimple Exception Throwing\\n","def spam():\\n    raise SillyError('egg')"
"Python","Exceptions","These are examples of control structures. You may also be interested in:\\nThis task is to give an example of an exception handling routine\\nand to \""throw\"" a new exception.\\n\\n\\nDefine an exception\\nRaise an exception\\nRe-raising once caught exception:\\nHandle an exception\\nAda.Exceptions\\nThe standard package Ada.Exceptions provides a possibility to attach messages to exceptions, to get exception occurrence information and textual description of exceptions. The following example illustrates basic functionality of:\\nAikido provides try, catch and throw statements.\\nCatching exceptions\\nThere is one catch clause per try statement. The variable caught is whatever is thrown. It does not have to be a particular type, although there is a System.Exception class defined for system exceptions.\\nThrowing exceptions\\nYou can throw any value.\\nSimple Exception Throwing\\n","try:\\n   foo()\\nexcept SillyError, se:\\n   print se.args\\n   bar()\\nelse:\\n   # no exception occurred\\n   quux()\\nfinally:\\n   baz()"
"Python","Exceptions","These are examples of control structures. You may also be interested in:\\nThis task is to give an example of an exception handling routine\\nand to \""throw\"" a new exception.\\n\\n\\nDefine an exception\\nRaise an exception\\nRe-raising once caught exception:\\nHandle an exception\\nAda.Exceptions\\nThe standard package Ada.Exceptions provides a possibility to attach messages to exceptions, to get exception occurrence information and textual description of exceptions. The following example illustrates basic functionality of:\\nAikido provides try, catch and throw statements.\\nCatching exceptions\\nThere is one catch clause per try statement. The variable caught is whatever is thrown. It does not have to be a particular type, although there is a System.Exception class defined for system exceptions.\\nThrowing exceptions\\nYou can throw any value.\\nSimple Exception Throwing\\n","try:\\n   foo()\\nexcept SillyError as se:\\n   print(se.args)\\n   bar()\\nelse:\\n   # no exception occurred\\n   quux()\\nfinally:\\n   baz()"
"Python","Exceptions/Catch_an_exception_thrown_in_a_nested_call","Show how to create a user-defined exception   and   show how to catch an exception raised from several nested calls away.\\n\\nShow/describe what happens when the program is run.\\n\\n","class U0(Exception): pass\\nclass U1(Exception): pass\\n\\ndef foo():\\n    for i in range(2):\\n        try:\\n            bar(i)\\n        except U0:\\n            print(\""Function foo caught exception U0\"")\\n\\ndef bar(i):\\n    baz(i) # Nest those calls\\n\\ndef baz(i):\\n    raise U1 if i else U0\\n\\nfoo()"
"Python","Execute_a_Markov_algorithm","\\nCreate an interpreter for a Markov Algorithm.\\nRules have the syntax:\\nThere is one rule per line.\\nIf there is a   .   (period)   present before the   <replacement>,   then this is a terminating rule in which case the interpreter must halt execution.\\nA ruleset consists of a sequence of rules, with optional comments.\\n\\n Rulesets \\nUse the following tests on entries:\\n\\nSample text of:\\nShould generate the output:\\n\\nA test of the terminating rule\\nSample text of:\\nShould generate:\\n\\nThis tests for correct substitution order and may trap simple regexp based replacement routines if special regexp characters are not escaped.\\nSample text of:\\nShould generate:\\n\\nThis tests for correct order of scanning of rules, and may trap replacement routines that scan in the wrong order.   It implements a general unary multiplication engine.   (Note that the input expression must be placed within underscores in this implementation.)\\nSample text of:\\nshould generate the output:\\n\\nA simple Turing machine,\\nimplementing a three-state busy beaver.\\nThe tape consists of 0s and 1s,   the states are A, B, C and H (for Halt), and the head position is indicated by writing the state letter before the character where the head is.\\nAll parts of the initial tape the machine operates on have to be given in the input.\\nBesides demonstrating that the Markov algorithm is Turing-complete, it also made me catch a bug in the C++ implementation which wasn't caught by the first four rulesets.\\nThis ruleset should turn\\ninto\\n\\nmarkov.ads:\\nmarkov.adb:\\ntest_markov.adb:\\nOutput (rulesX contains the ruleset of above examples and testX the example text):\\nOutput:\\nSave the following text to a file \""markov.bra\"":\\nTest:\\nNote: Non-use of iswhite is intentional, since depending on the locale, other chars besides space and tab might be detected by that function.\\nI should mention that this uses the regular expression machinery present in Allegro Lisp but not Common Lisp generally (though there are public domain Lisp libraries).\\nTesting:\\n","import re\\n\\ndef extractreplacements(grammar):\\n    return [ (matchobj.group('pat'), matchobj.group('repl'), bool(matchobj.group('term')))\\n                for matchobj in re.finditer(syntaxre, grammar)\\n                if matchobj.group('rule')]\\n \\ndef replace(text, replacements):\\n    while True:\\n        for pat, repl, term in replacements:\\n            if pat in text:\\n                text = text.replace(pat, repl, 1)\\n                if term:\\n                    return text\\n                break\\n        else:\\n            return text\\n\\nsyntaxre = r\""\""\""(?mx)\\n^(?: \\n  (?: (?P<comment> \\# .* ) ) |\\n  (?: (?P<blank>   \\s*  ) (?: \\n | $ )  ) |\\n  (?: (?P<rule>    (?P<pat> .+? ) \\s+ -> \\s+ (?P<term> \\.)? (?P<repl> .+) ) )\\n)$\\n\""\""\""\\n \\ngrammar1 = \""\""\""\\\\n# This rules file is extracted from Wikipedia:\\n# http://en.wikipedia.org/wiki/Markov_Algorithm\\nA -> apple\\nB -> bag\\nS -> shop\\nT -> the\\nthe shop -> my brother\\na never used -> .terminating rule\\n\""\""\""\\n \\ngrammar2 = '''\\\\n# Slightly modified from the rules on Wikipedia\\nA -> apple\\nB -> bag\\nS -> .shop\\nT -> the\\nthe shop -> my brother\\na never used -> .terminating rule\\n'''\\n \\ngrammar3 = '''\\\\n# BNF Syntax testing rules\\nA -> apple\\nWWWW -> with\\nBgage -> ->.*\\nB -> bag\\n->.* -> money\\nW -> WW\\nS -> .shop\\nT -> the\\nthe shop -> my brother\\na never used -> .terminating rule\\n'''\\n\\ngrammar4 = '''\\\\n### Unary Multiplication Engine, for testing Markov Algorithm implementations\\n### By Donal Fellows.\\n# Unary addition engine\\n_+1 -> _1+\\n1+1 -> 11+\\n# Pass for converting from the splitting of multiplication into ordinary\\n# addition\\n1! -> !1\\n,! -> !+\\n_! -> _\\n# Unary multiplication by duplicating left side, right side times\\n1*1 -> x,@y\\n1x -> xX\\nX, -> 1,1\\nX1 -> 1X\\n_x -> _X\\n,x -> ,X\\ny1 -> 1y\\ny_ -> _\\n# Next phase of applying\\n1@1 -> x,@y\\n1@_ -> @_\\n,@_ -> !_\\n++ -> +\\n# Termination cleanup for addition\\n_1 -> 1\\n1+_ -> 1\\n_+_ -> \\n'''\\n\\ngrammar5 = '''\\\\n# Turing machine: three-state busy beaver\\n#\\n# state A, symbol 0 => write 1, move right, new state B\\nA0 -> 1B\\n# state A, symbol 1 => write 1, move left, new state C\\n0A1 -> C01\\n1A1 -> C11\\n# state B, symbol 0 => write 1, move left, new state A\\n0B0 -> A01\\n1B0 -> A11\\n# state B, symbol 1 => write 1, move right, new state B\\nB1 -> 1B\\n# state C, symbol 0 => write 1, move left, new state B\\n0C0 -> B01\\n1C0 -> B11\\n# state C, symbol 1 => write 1, move left, halt\\n0C1 -> H01\\n1C1 -> H11\\n'''\\n\\ntext1 = \""I bought a B of As from T S.\""\\n \\ntext2 = \""I bought a B of As W my Bgage from T S.\""\\n\\ntext3 = '_1111*11111_'\\n\\ntext4 = '000000A000000'\\n\\n \\nif __name__ == '__main__':\\n    assert replace(text1, extractreplacements(grammar1)) \\\\n           == 'I bought a bag of apples from my brother.'\\n    assert replace(text1, extractreplacements(grammar2)) \\\\n           == 'I bought a bag of apples from T shop.'\\n    # Stretch goals\\n    assert replace(text2, extractreplacements(grammar3)) \\\\n           == 'I bought a bag of apples with my money from T shop.'\\n    assert replace(text3, extractreplacements(grammar4)) \\\\n           == '11111111111111111111'\\n    assert replace(text4, extractreplacements(grammar5)) \\\\n           == '00011H1111000'"
"Python","Execute_a_system_command","Run either the   ls   system command   (dir   on Windows),   or the   pause   system command.\\n\\n\\nABAP report which checks if there is an external command called 'ls' for the os of the current application server. When running on Windows, it calls dir, for all other platforms ls. A new command is created if not existing and run.\\nUsing the IEEE POSIX Ada standard, P1003.5c:\\nImporting the C system() function:\\nUsing the GNAT run-time library:\\nThe simplest way to do this is using the system() function. It returns a vector of strings (the output from the command).\\nIf you don't want to process the output you can use the exec function. It writes the output to the standard output stream by default;\\nYou also have the regular fork and execv calls available:\\nOr the classic \""!\"" shell escape can be implemented as an \""!\"" operator:\\nUsing system() function:\\nUsing getline command:\\nOn Acorn computers the *CAT command catalogues the current directory, the equivalent of the Unix ls command or the DOS/Windows dir command. The BBC BASIC OSCLI command passes a string to the Command Line Interpreter to execute a system command, it is the equivalent of C's system() command.\\nWith BBC BASIC for Windows you can execute the Windows dir command:\\nAnd if running BBC BASIC on a Unix host, you can execute the ls command:\\nISO C & POSIX:\\nUsing Windows / .NET:\\nBecause of a quirk in the implementation (cmExecuteProcessCommand.cxx and ProcessUNIX.c), CMake diverts the standard output to a pipe. The effect is like running ls | cat in the shell. The ls process inherits the original standard input and standard error, but receives a new pipe for standard output. CMake then reads this pipe and copies all data to the original standard output.\\nexecute_process() can also chain commands in a pipeeline, and capture output.\\nstd.process.system() is deprecated.\\nIn ERRE language you have the SHELL command followed, eventually, by a string command.\\nSHELL itself opens a new DOS/Windows shell: you must use EXIT to end.\\nFor example\\nlists the current directory and then returns to the program.\\nEuphoria has 2 systems command functions: system() and system_exec().\\nThe Process class handles creating and running external processes. in/out/err streams can be redirected, but default to the usual stdin/stdout/stderr. So following program prints result of 'ls' to the command line:\\nexecute_command_line subroutine in Fortran 2008 and later runs a system command\\nThe SYSTEM subroutine (and function) are a GNU extension.\\nThis simple example prints the output to a console window. With its open \""Unix\"" command, FB has robust capability as a system interface to the Free BSD Unix core of Macintosh OS X 10.x.\\nOutput:\\nClick this link to run this code\\nOutput:\\nSee also: the System.Process module\\nHolyC is the official programming language for The Temple Operating System (TempleOS). The Temple Operating System interpreter executes just-in-time compiled HolyC code. All HolyC code is effectively executed as system commands.\\nFor example, to execute the Dir command:\\nThe code below selects the 'ls' or 'dir' command at runtime based on the UNIX feature.\\nUnicon extends system to allow specification of files and a wait/nowait parameter as in the examples below.\\nWill execute \""ls\"" with output to the screen.\\nwill execute it and store the result in the string array \""result\"".\\nwill execute it asynchronously and direct any output from it into the LUN \""unit\"" from whence it can be read at any (later) time.\\nThe system command interface in J is provided by the standard \""task\"" script:\\nNote that on unix systems, you can also use the 2!:x family of foreign verbs to execute system commands.\\nThere are two ways to run system commands. The simple way, which will hang the JVM (I would be interested in some kind of reason). -- this happens because the the inputStream buffer fills up and blocks until it gets read. Moving your .waitFor after reading the InputStream would fix your issue (as long as your error stream doesn't fill up)\\nAnd the right way, which uses threading to read the InputStream given by the process.\\nJavaScript does not have any facilities to interact with the OS. However, host environments can provide this ability.\\nThe Julia manual has an excellent section on this topic, which is worth a read. The short answer on Linux is:\\n","import os\\nexit_code = os.system('ls')       # Just execute the command, return a success/fail code\\noutput    = os.popen('ls').read() # If you want to get the output data. Deprecated."
"Python","Execute_a_system_command","Run either the   ls   system command   (dir   on Windows),   or the   pause   system command.\\n\\n\\nABAP report which checks if there is an external command called 'ls' for the os of the current application server. When running on Windows, it calls dir, for all other platforms ls. A new command is created if not existing and run.\\nUsing the IEEE POSIX Ada standard, P1003.5c:\\nImporting the C system() function:\\nUsing the GNAT run-time library:\\nThe simplest way to do this is using the system() function. It returns a vector of strings (the output from the command).\\nIf you don't want to process the output you can use the exec function. It writes the output to the standard output stream by default;\\nYou also have the regular fork and execv calls available:\\nOr the classic \""!\"" shell escape can be implemented as an \""!\"" operator:\\nUsing system() function:\\nUsing getline command:\\nOn Acorn computers the *CAT command catalogues the current directory, the equivalent of the Unix ls command or the DOS/Windows dir command. The BBC BASIC OSCLI command passes a string to the Command Line Interpreter to execute a system command, it is the equivalent of C's system() command.\\nWith BBC BASIC for Windows you can execute the Windows dir command:\\nAnd if running BBC BASIC on a Unix host, you can execute the ls command:\\nISO C & POSIX:\\nUsing Windows / .NET:\\nBecause of a quirk in the implementation (cmExecuteProcessCommand.cxx and ProcessUNIX.c), CMake diverts the standard output to a pipe. The effect is like running ls | cat in the shell. The ls process inherits the original standard input and standard error, but receives a new pipe for standard output. CMake then reads this pipe and copies all data to the original standard output.\\nexecute_process() can also chain commands in a pipeeline, and capture output.\\nstd.process.system() is deprecated.\\nIn ERRE language you have the SHELL command followed, eventually, by a string command.\\nSHELL itself opens a new DOS/Windows shell: you must use EXIT to end.\\nFor example\\nlists the current directory and then returns to the program.\\nEuphoria has 2 systems command functions: system() and system_exec().\\nThe Process class handles creating and running external processes. in/out/err streams can be redirected, but default to the usual stdin/stdout/stderr. So following program prints result of 'ls' to the command line:\\nexecute_command_line subroutine in Fortran 2008 and later runs a system command\\nThe SYSTEM subroutine (and function) are a GNU extension.\\nThis simple example prints the output to a console window. With its open \""Unix\"" command, FB has robust capability as a system interface to the Free BSD Unix core of Macintosh OS X 10.x.\\nOutput:\\nClick this link to run this code\\nOutput:\\nSee also: the System.Process module\\nHolyC is the official programming language for The Temple Operating System (TempleOS). The Temple Operating System interpreter executes just-in-time compiled HolyC code. All HolyC code is effectively executed as system commands.\\nFor example, to execute the Dir command:\\nThe code below selects the 'ls' or 'dir' command at runtime based on the UNIX feature.\\nUnicon extends system to allow specification of files and a wait/nowait parameter as in the examples below.\\nWill execute \""ls\"" with output to the screen.\\nwill execute it and store the result in the string array \""result\"".\\nwill execute it asynchronously and direct any output from it into the LUN \""unit\"" from whence it can be read at any (later) time.\\nThe system command interface in J is provided by the standard \""task\"" script:\\nNote that on unix systems, you can also use the 2!:x family of foreign verbs to execute system commands.\\nThere are two ways to run system commands. The simple way, which will hang the JVM (I would be interested in some kind of reason). -- this happens because the the inputStream buffer fills up and blocks until it gets read. Moving your .waitFor after reading the InputStream would fix your issue (as long as your error stream doesn't fill up)\\nAnd the right way, which uses threading to read the InputStream given by the process.\\nJavaScript does not have any facilities to interact with the OS. However, host environments can provide this ability.\\nThe Julia manual has an excellent section on this topic, which is worth a read. The short answer on Linux is:\\n","import subprocess\\n# if the exit code was non-zero these commands raise a CalledProcessError\\nexit_code = subprocess.check_call(['ls', '-l'])   # Python 2.5+\\nassert exit_code == 0\\noutput    = subprocess.check_output(['ls', '-l']) # Python 2.7+"
"Python","Execute_a_system_command","Run either the   ls   system command   (dir   on Windows),   or the   pause   system command.\\n\\n\\nABAP report which checks if there is an external command called 'ls' for the os of the current application server. When running on Windows, it calls dir, for all other platforms ls. A new command is created if not existing and run.\\nUsing the IEEE POSIX Ada standard, P1003.5c:\\nImporting the C system() function:\\nUsing the GNAT run-time library:\\nThe simplest way to do this is using the system() function. It returns a vector of strings (the output from the command).\\nIf you don't want to process the output you can use the exec function. It writes the output to the standard output stream by default;\\nYou also have the regular fork and execv calls available:\\nOr the classic \""!\"" shell escape can be implemented as an \""!\"" operator:\\nUsing system() function:\\nUsing getline command:\\nOn Acorn computers the *CAT command catalogues the current directory, the equivalent of the Unix ls command or the DOS/Windows dir command. The BBC BASIC OSCLI command passes a string to the Command Line Interpreter to execute a system command, it is the equivalent of C's system() command.\\nWith BBC BASIC for Windows you can execute the Windows dir command:\\nAnd if running BBC BASIC on a Unix host, you can execute the ls command:\\nISO C & POSIX:\\nUsing Windows / .NET:\\nBecause of a quirk in the implementation (cmExecuteProcessCommand.cxx and ProcessUNIX.c), CMake diverts the standard output to a pipe. The effect is like running ls | cat in the shell. The ls process inherits the original standard input and standard error, but receives a new pipe for standard output. CMake then reads this pipe and copies all data to the original standard output.\\nexecute_process() can also chain commands in a pipeeline, and capture output.\\nstd.process.system() is deprecated.\\nIn ERRE language you have the SHELL command followed, eventually, by a string command.\\nSHELL itself opens a new DOS/Windows shell: you must use EXIT to end.\\nFor example\\nlists the current directory and then returns to the program.\\nEuphoria has 2 systems command functions: system() and system_exec().\\nThe Process class handles creating and running external processes. in/out/err streams can be redirected, but default to the usual stdin/stdout/stderr. So following program prints result of 'ls' to the command line:\\nexecute_command_line subroutine in Fortran 2008 and later runs a system command\\nThe SYSTEM subroutine (and function) are a GNU extension.\\nThis simple example prints the output to a console window. With its open \""Unix\"" command, FB has robust capability as a system interface to the Free BSD Unix core of Macintosh OS X 10.x.\\nOutput:\\nClick this link to run this code\\nOutput:\\nSee also: the System.Process module\\nHolyC is the official programming language for The Temple Operating System (TempleOS). The Temple Operating System interpreter executes just-in-time compiled HolyC code. All HolyC code is effectively executed as system commands.\\nFor example, to execute the Dir command:\\nThe code below selects the 'ls' or 'dir' command at runtime based on the UNIX feature.\\nUnicon extends system to allow specification of files and a wait/nowait parameter as in the examples below.\\nWill execute \""ls\"" with output to the screen.\\nwill execute it and store the result in the string array \""result\"".\\nwill execute it asynchronously and direct any output from it into the LUN \""unit\"" from whence it can be read at any (later) time.\\nThe system command interface in J is provided by the standard \""task\"" script:\\nNote that on unix systems, you can also use the 2!:x family of foreign verbs to execute system commands.\\nThere are two ways to run system commands. The simple way, which will hang the JVM (I would be interested in some kind of reason). -- this happens because the the inputStream buffer fills up and blocks until it gets read. Moving your .waitFor after reading the InputStream would fix your issue (as long as your error stream doesn't fill up)\\nAnd the right way, which uses threading to read the InputStream given by the process.\\nJavaScript does not have any facilities to interact with the OS. However, host environments can provide this ability.\\nThe Julia manual has an excellent section on this topic, which is worth a read. The short answer on Linux is:\\n","from subprocess import PIPE, Popen, STDOUT\\np = Popen('ls', stdout=PIPE, stderr=STDOUT)\\nprint p.communicate()[0]"
"Python","Execute_a_system_command","Run either the   ls   system command   (dir   on Windows),   or the   pause   system command.\\n\\n\\nABAP report which checks if there is an external command called 'ls' for the os of the current application server. When running on Windows, it calls dir, for all other platforms ls. A new command is created if not existing and run.\\nUsing the IEEE POSIX Ada standard, P1003.5c:\\nImporting the C system() function:\\nUsing the GNAT run-time library:\\nThe simplest way to do this is using the system() function. It returns a vector of strings (the output from the command).\\nIf you don't want to process the output you can use the exec function. It writes the output to the standard output stream by default;\\nYou also have the regular fork and execv calls available:\\nOr the classic \""!\"" shell escape can be implemented as an \""!\"" operator:\\nUsing system() function:\\nUsing getline command:\\nOn Acorn computers the *CAT command catalogues the current directory, the equivalent of the Unix ls command or the DOS/Windows dir command. The BBC BASIC OSCLI command passes a string to the Command Line Interpreter to execute a system command, it is the equivalent of C's system() command.\\nWith BBC BASIC for Windows you can execute the Windows dir command:\\nAnd if running BBC BASIC on a Unix host, you can execute the ls command:\\nISO C & POSIX:\\nUsing Windows / .NET:\\nBecause of a quirk in the implementation (cmExecuteProcessCommand.cxx and ProcessUNIX.c), CMake diverts the standard output to a pipe. The effect is like running ls | cat in the shell. The ls process inherits the original standard input and standard error, but receives a new pipe for standard output. CMake then reads this pipe and copies all data to the original standard output.\\nexecute_process() can also chain commands in a pipeeline, and capture output.\\nstd.process.system() is deprecated.\\nIn ERRE language you have the SHELL command followed, eventually, by a string command.\\nSHELL itself opens a new DOS/Windows shell: you must use EXIT to end.\\nFor example\\nlists the current directory and then returns to the program.\\nEuphoria has 2 systems command functions: system() and system_exec().\\nThe Process class handles creating and running external processes. in/out/err streams can be redirected, but default to the usual stdin/stdout/stderr. So following program prints result of 'ls' to the command line:\\nexecute_command_line subroutine in Fortran 2008 and later runs a system command\\nThe SYSTEM subroutine (and function) are a GNU extension.\\nThis simple example prints the output to a console window. With its open \""Unix\"" command, FB has robust capability as a system interface to the Free BSD Unix core of Macintosh OS X 10.x.\\nOutput:\\nClick this link to run this code\\nOutput:\\nSee also: the System.Process module\\nHolyC is the official programming language for The Temple Operating System (TempleOS). The Temple Operating System interpreter executes just-in-time compiled HolyC code. All HolyC code is effectively executed as system commands.\\nFor example, to execute the Dir command:\\nThe code below selects the 'ls' or 'dir' command at runtime based on the UNIX feature.\\nUnicon extends system to allow specification of files and a wait/nowait parameter as in the examples below.\\nWill execute \""ls\"" with output to the screen.\\nwill execute it and store the result in the string array \""result\"".\\nwill execute it asynchronously and direct any output from it into the LUN \""unit\"" from whence it can be read at any (later) time.\\nThe system command interface in J is provided by the standard \""task\"" script:\\nNote that on unix systems, you can also use the 2!:x family of foreign verbs to execute system commands.\\nThere are two ways to run system commands. The simple way, which will hang the JVM (I would be interested in some kind of reason). -- this happens because the the inputStream buffer fills up and blocks until it gets read. Moving your .waitFor after reading the InputStream would fix your issue (as long as your error stream doesn't fill up)\\nAnd the right way, which uses threading to read the InputStream given by the process.\\nJavaScript does not have any facilities to interact with the OS. However, host environments can provide this ability.\\nThe Julia manual has an excellent section on this topic, which is worth a read. The short answer on Linux is:\\n","import commands\\nstat, out = commands.getstatusoutput('ls')\\nif not stat:\\n    print out"
"Python","Exponentiation_operator","Most programming languages have a built-in implementation of exponentiation.\\n\\nRe-implement integer exponentiation for both   intint   and   floatint   as both a procedure,   and an operator (if your language supports operator definition).\\nIf the language supports operator (or procedure) overloading, then an overloaded form should be provided for both   intint   and   floatint   variants.\\n\\nFirst we declare the specifications of the two procedures and the two corresponding operators (written as functions with quoted operators as their names):\\nNow we can create a test program:\\nFinally we can implement the procedures and operations:\\n","MULTIPLY = lambda x, y: x*y\\n\\nclass num(float):\\n    # the following method has complexity O(b)\\n    # rather than O(log b) via the rapid exponentiation\\n    def __pow__(self, b):\\n        return reduce(MULTIPLY, [self]*b, 1)\\n\\n# works with ints as function or operator\\nprint num(2).__pow__(3)\\nprint num(2) ** 3\\n\\n# works with floats as function or operator\\nprint num(2.3).__pow__(8)\\nprint num(2.3) ** 8"
"Python","Exponentiation_order","This task will demonstrate the order of exponentiation   (xy)    when there are multiple exponents.\\n(Many programming languages, especially those with extended-precision integer arithmetic, usually support one of **, ^, ↑ or some such for exponentiation.)\\n\\nShow the result of a language's evaluation of multiple exponentiation (either as an integer or floating point).\\nIf your language's exponentiation operator is not one of the usual ones, please comment on how to recognize it.\\n\\nUsing whatever operator or syntax your language supports (if any), show the results in three lines (with identification):\\n\\n",">>> 5**3**2\\n1953125\\n>>> (5**3)**2\\n15625\\n>>> 5**(3**2)\\n1953125\\n>>> # The following is not normally done\\n>>> try: from functools import reduce # Py3K\\nexcept: pass\\n\\n>>> reduce(pow, (5, 3, 2))\\n15625\\n>>> "
"Python","Extensible_prime_generator","Write a generator of prime numbers, in order, that will automatically adjust to accommodate the generation of any reasonably high prime.\\nThe routine should demonstrably rely on either:\\n\\nThe routine should be used to:\\n\\nShow output on this page.\\nNote: You may reference code already on this site if it is written to be imported/included, then only the code necessary for import and the performance of this task need be shown. (It is also important to leave a forward link on the referenced tasks entry so that later editors know that the code is used for multiple tasks).\\nNote 2: If a languages in-built prime generator is extensible or is guaranteed to generate primes up to a system limit, (231 or memory overflow for example), then this may be used as long as an explanation of the limits of the prime generator is also given. (Which may include a link to/excerpt from, language documentation).\\nWebsite with vast count of primes. Small ones for the first 10000 and up to 1,000,000,000,000 aka 1E12, divided in subranges : \""Each compressed file contains 10 million primes\"" \\nhttp://www.primos.mat.br/indexen.html\\n\\n\\n\\nThe solution is based on an open-ended counter, named \""Current\"" counting up to the limit from the Compiler, namely 2**63-1.\\nThe solution uses the package Miller_Rabin from the Miller-Rabin primality test. When using the gnat Ada compiler, the largest integer we can deal with is 2**63-1. For anything larger, we could use a big-num package.\\n","islice(count(7), 0, None, 2)"
"Python","Extensible_prime_generator","Write a generator of prime numbers, in order, that will automatically adjust to accommodate the generation of any reasonably high prime.\\nThe routine should demonstrably rely on either:\\n\\nThe routine should be used to:\\n\\nShow output on this page.\\nNote: You may reference code already on this site if it is written to be imported/included, then only the code necessary for import and the performance of this task need be shown. (It is also important to leave a forward link on the referenced tasks entry so that later editors know that the code is used for multiple tasks).\\nNote 2: If a languages in-built prime generator is extensible or is guaranteed to generate primes up to a system limit, (231 or memory overflow for example), then this may be used as long as an explanation of the limits of the prime generator is also given. (Which may include a link to/excerpt from, language documentation).\\nWebsite with vast count of primes. Small ones for the first 10000 and up to 1,000,000,000,000 aka 1E12, divided in subranges : \""Each compressed file contains 10 million primes\"" \\nhttp://www.primos.mat.br/indexen.html\\n\\n\\n\\nThe solution is based on an open-ended counter, named \""Current\"" counting up to the limit from the Compiler, namely 2**63-1.\\nThe solution uses the package Miller_Rabin from the Miller-Rabin primality test. When using the gnat Ada compiler, the largest integer we can deal with is 2**63-1. For anything larger, we could use a big-num package.\\n","from __future__ import print_function\\nfrom prime_decomposition import primes\\nfrom itertools import islice\\n\\n\\ndef p_range(lower_inclusive, upper_exclusive):\\n    'Primes in the range'\\n    for p in primes():\\n        if p >= upper_exclusive: break\\n        if p >= lower_inclusive: yield p\\n\\nif __name__ == '__main__':\\n    print('The first twenty primes:\\n  ', list(islice(primes(),20)))\\n    print('The primes between 100 and 150:\\n  ', list(p_range(100, 150)))\\n    print('The ''number'' of primes between 7,700 and 8,000:\\n  ', len(list(p_range(7700, 8000))))\\n    print('The 10,000th prime:\\n  ', next(islice(primes(),10000-1, 10000)))"
"Python","Extensible_prime_generator","Write a generator of prime numbers, in order, that will automatically adjust to accommodate the generation of any reasonably high prime.\\nThe routine should demonstrably rely on either:\\n\\nThe routine should be used to:\\n\\nShow output on this page.\\nNote: You may reference code already on this site if it is written to be imported/included, then only the code necessary for import and the performance of this task need be shown. (It is also important to leave a forward link on the referenced tasks entry so that later editors know that the code is used for multiple tasks).\\nNote 2: If a languages in-built prime generator is extensible or is guaranteed to generate primes up to a system limit, (231 or memory overflow for example), then this may be used as long as an explanation of the limits of the prime generator is also given. (Which may include a link to/excerpt from, language documentation).\\nWebsite with vast count of primes. Small ones for the first 10000 and up to 1,000,000,000,000 aka 1E12, divided in subranges : \""Each compressed file contains 10 million primes\"" \\nhttp://www.primos.mat.br/indexen.html\\n\\n\\n\\nThe solution is based on an open-ended counter, named \""Current\"" counting up to the limit from the Compiler, namely 2**63-1.\\nThe solution uses the package Miller_Rabin from the Miller-Rabin primality test. When using the gnat Ada compiler, the largest integer we can deal with is 2**63-1. For anything larger, we could use a big-num package.\\n","def wsieve():       # ideone.com/mqO25A\\n    wh11 = [ 2,4,2,4,6,2,6,4,2,4,6,6, 2,6,4,2,6,4,6,8,4,2,4,2,\\n             4,8,6,4,6,2,4,6,2,6,6,4, 2,4,6,2,6,4,2,4,2,10,2,10]\\n    cs = accumulate( chain( [11], cycle( wh11)))\\n    yield( next( cs))  # cf. ideone.com/WFv4f\\n    ps = wsieve()      #     codereview.stackexchange.com/q/92365/9064\\n    p = next(ps)       # 11         stackoverflow.com/q/30553925/849891\\n    psq = p*p          # 121\\n    D = dict( zip( accumulate( chain( [0], wh11)), count(0)))   # start from\\n    mults = {}\\n    for c in cs:\\n        if c in mults:\\n            wheel = mults.pop(c)  \\n        elif c < psq:              \\n            yield c ; continue   \\n        else:          # c==psq:  map (p*) (roll wh from p) = roll (wh*p) from (p*p)\\n            x = [p*d for d in wh11]\\n            i = D[ (p-11) % 210]\\n            wheel = accumulate( chain( [psq+x[i]], cycle( x[i+1:] + x[:i+1])))\\n            p = next(ps) ; psq = p*p \\n        for m in wheel: \\n            if not m in mults: \\n                break\\n        mults[m] = wheel\\n\\ndef primes(): \\n	yield from (2, 3, 5, 7)\\n	yield from wsieve() \\n\\nprint( list( islice( primes(), 0, 20)))\\nprint( list( takewhile( lambda x: x<150, \\n                   dropwhile( lambda x: x<100, primes()))))\\nprint( len( list( takewhile( lambda x: x<8000, \\n                   dropwhile( lambda x: x<7700, primes())))))\\nprint( list( islice( primes(), 10000-1, 10000))[0])"
"Python","Extensible_prime_generator","Write a generator of prime numbers, in order, that will automatically adjust to accommodate the generation of any reasonably high prime.\\nThe routine should demonstrably rely on either:\\n\\nThe routine should be used to:\\n\\nShow output on this page.\\nNote: You may reference code already on this site if it is written to be imported/included, then only the code necessary for import and the performance of this task need be shown. (It is also important to leave a forward link on the referenced tasks entry so that later editors know that the code is used for multiple tasks).\\nNote 2: If a languages in-built prime generator is extensible or is guaranteed to generate primes up to a system limit, (231 or memory overflow for example), then this may be used as long as an explanation of the limits of the prime generator is also given. (Which may include a link to/excerpt from, language documentation).\\nWebsite with vast count of primes. Small ones for the first 10000 and up to 1,000,000,000,000 aka 1E12, divided in subranges : \""Each compressed file contains 10 million primes\"" \\nhttp://www.primos.mat.br/indexen.html\\n\\n\\n\\nThe solution is based on an open-ended counter, named \""Current\"" counting up to the limit from the Compiler, namely 2**63-1.\\nThe solution uses the package Miller_Rabin from the Miller-Rabin primality test. When using the gnat Ada compiler, the largest integer we can deal with is 2**63-1. For anything larger, we could use a big-num package.\\n","from itertools import count, takewhile, islice\\n\\ndef prime_sieve():\\n    sieved = count(2)\\n    prime = next(sieved)\\n    yield prime\\n    primes = [prime]\\n    for x in sieved:\\n        if any(x % prime == 0 for prime in primes):\\n            continue\\n        yield x\\n        primes.append(x)\\n\\nif __name__ == '__main__':\\n    def leq_150(x): return x <= 150\\n    def leq_8000(x): return x <= 8000\\n    \\n    print(\""Show the first twenty primes.\\n   =\"",\\n        list(islice(prime_sieve(), 20)))\\n    print(\""Show the primes between 100 and 150\\n   =\"",\\n        [x for x in takewhile(leq_150, prime_sieve()) if x >= 100])\\n    print(\""Show the number of primes between 7,700 and 8,000.\\n   =\"",\\n        sum(1 for x in takewhile(leq_8000, prime_sieve()) if x >= 7700))\\n    print(\""Show the 10,000th prime.\\n   =\"",\\n        next(islice(prime_sieve(), 10000-1, 10000)))"
"Python","Extract_file_extension","Filename extensions are a rudimentary but commonly used way of identifying files types.\\nWrite a function or program that\\n\\nIf your programming language (or standard library) has built-in functionality for extracting a filename extension, show how it would be used and how exactly its behavior differs from this specification.\\nFor the purposes of this task, a filename extension\\n","import re\\ndef extractExt(url):\\n  m = re.search(r'\\.[A-Za-z0-9]+$', url)\\n  return m.group(0) if m else \""\""\\n"
"Python","Extreme_floating_point_values","The IEEE floating point specification defines certain 'extreme' floating point values such as minus zero, -0.0, a value distinct from plus zero; not a number, NaN; and plus and minus infinity.\\nThe task is to use expressions involving other 'normal' floating point values in your language to calculate these, (and maybe other), extreme floating point values in your language and assign them to variables.\\nPrint the values of these variables if possible; and show some arithmetic with these values and variables.\\nIf your language can directly enter these extreme floating point values then show it.\\n\\n\\n\\nThe language specifies model floating-point numbers independent of the underlying hardware. Even if the machine numbers are IEEE 754, the user-defined floating-point numbers are guaranteed to have no IEEE 754 semantics. In particular, their values do not include any non-numeric ideals. Constraint_Error exception is propagated when the result of a numeric operation assigned to a floating-point variable is not in the range (the range is always numeric).\\nFor performance reasons, the built-in floating-point types like Float and Long_Float are allowed to have IEEE 754 semantics if the machine numbers are IEEE 754. But the language provides means to exclude all non numbers from these types by defining a subtype with an explicit range:\\nIn general in properly written Ada programs variables may not become invalid when standard numeric operations are applied. The language also provides the attribute 'Valid to verify values obtained from unsafe sources e.g. from input, unchecked conversions etc.\\nAs stated above on a machine where Float is implemented by an IEEE 754 machine number, IEEE 754 is permitted leak through. The following program illustrates how this leak can be exploited:\\nThe expression -1.0 / 0.0 were non-numeric and thus could not be used.\\nTo fool the compiler the variable Zero is used,\\nwhich circumvents type checks giving desired broken result.\\n",">>> # Extreme values from expressions\\n>>> inf = 1e234 * 1e234\\n>>> _inf = 1e234 * -1e234\\n>>> _zero = 1 / _inf\\n>>> nan = inf + _inf\\n>>> inf, _inf, _zero, nan\\n(inf, -inf, -0.0, nan)\\n>>> # Print\\n>>> for value in (inf, _inf, _zero, nan): print (value)\\n\\ninf\\n-inf\\n-0.0\\nnan\\n>>> # Extreme values from other means\\n>>> float('nan')\\nnan\\n>>> float('inf')\\ninf\\n>>> float('-inf')\\n-inf\\n>>> -0.\\n-0.0\\n>>> # Some arithmetic\\n>>> nan == nan\\nFalse\\n>>> nan is nan\\nTrue\\n>>> 0. == -0.\\nTrue\\n>>> 0. is -0.\\nFalse\\n>>> inf + _inf\\nnan\\n>>> 0.0 * nan\\nnan\\n>>> nan * 0.0\\nnan\\n>>> 0.0 * inf\\nnan\\n>>> inf * 0.0\\nnan"
"Python","Extreme_floating_point_values","The IEEE floating point specification defines certain 'extreme' floating point values such as minus zero, -0.0, a value distinct from plus zero; not a number, NaN; and plus and minus infinity.\\nThe task is to use expressions involving other 'normal' floating point values in your language to calculate these, (and maybe other), extreme floating point values in your language and assign them to variables.\\nPrint the values of these variables if possible; and show some arithmetic with these values and variables.\\nIf your language can directly enter these extreme floating point values then show it.\\n\\n\\n\\nThe language specifies model floating-point numbers independent of the underlying hardware. Even if the machine numbers are IEEE 754, the user-defined floating-point numbers are guaranteed to have no IEEE 754 semantics. In particular, their values do not include any non-numeric ideals. Constraint_Error exception is propagated when the result of a numeric operation assigned to a floating-point variable is not in the range (the range is always numeric).\\nFor performance reasons, the built-in floating-point types like Float and Long_Float are allowed to have IEEE 754 semantics if the machine numbers are IEEE 754. But the language provides means to exclude all non numbers from these types by defining a subtype with an explicit range:\\nIn general in properly written Ada programs variables may not become invalid when standard numeric operations are applied. The language also provides the attribute 'Valid to verify values obtained from unsafe sources e.g. from input, unchecked conversions etc.\\nAs stated above on a machine where Float is implemented by an IEEE 754 machine number, IEEE 754 is permitted leak through. The following program illustrates how this leak can be exploited:\\nThe expression -1.0 / 0.0 were non-numeric and thus could not be used.\\nTo fool the compiler the variable Zero is used,\\nwhich circumvents type checks giving desired broken result.\\n",">>> # But note!\\n>>> 1 / -0.0\\n\\nTraceback (most recent call last):\\n  File \""<pyshell#106>\"", line 1, in <module>\\n    1 / -0.0\\nZeroDivisionError: float division by zero\\n>>> # (Not minus infinity)"
"Python","Factorial","\\nWrite a function to return the factorial of a number.\\nSolutions can be iterative or recursive.\\nSupport for trapping negative    n    errors is optional.\\n\\n\\nThis is an iterative solution which outputs the factorial of each number supplied on standard input.\\n","import math\\nmath.factorial(n)"
"Python","Factorial","\\nWrite a function to return the factorial of a number.\\nSolutions can be iterative or recursive.\\nSupport for trapping negative    n    errors is optional.\\n\\n\\nThis is an iterative solution which outputs the factorial of each number supplied on standard input.\\n","def factorial(n):\\n    result = 1\\n    for i in range(1, n+1):\\n        result *= i\\n    return result"
"Python","Factorial","\\nWrite a function to return the factorial of a number.\\nSolutions can be iterative or recursive.\\nSupport for trapping negative    n    errors is optional.\\n\\n\\nThis is an iterative solution which outputs the factorial of each number supplied on standard input.\\n","from operator import mul\\nfrom functools import reduce\\n\\ndef factorial(n):\\n    return reduce(mul, range(1,n+1), 1)"
"Python","Factorial","\\nWrite a function to return the factorial of a number.\\nSolutions can be iterative or recursive.\\nSupport for trapping negative    n    errors is optional.\\n\\n\\nThis is an iterative solution which outputs the factorial of each number supplied on standard input.\\n","def factorial(n):\\n    z=1\\n    if n>1:\\n        z=n*factorial(n-1)\\n    return z"
"Python","Factorial","\\nWrite a function to return the factorial of a number.\\nSolutions can be iterative or recursive.\\nSupport for trapping negative    n    errors is optional.\\n\\n\\nThis is an iterative solution which outputs the factorial of each number supplied on standard input.\\n","from cmath import *\\n\\n# Coefficients used by the GNU Scientific Library\\ng = 7\\np = [0.99999999999980993, 676.5203681218851, -1259.1392167224028,\\n     771.32342877765313, -176.61502916214059, 12.507343278686905,\\n     -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7]\\n\\ndef gamma(z):\\n  z = complex(z)\\n  # Reflection formula\\n  if z.real < 0.5:\\n    return pi / (sin(pi*z)*gamma(1-z))\\n  else:\\n    z -= 1\\n    x = p[0]\\n    for i in range(1, g+2):\\n      x += p[i]/(z+i)\\n    t = z + g + 0.5\\n    return sqrt(2*pi) * t**(z+0.5) * exp(-t) * x\\n\\ndef factorial(n):\\n  return gamma(n+1)\\n\\nprint \""factorial(-0.5)**2=\"",factorial(-0.5)**2\\nfor i in range(10):\\n  print \""factorial(%d)=%s\""%(i,factorial(i))"
"Python","Factors_of_a_Mersenne_number","A Mersenne number is a number in the form of 2P-1.\\nIf P is prime, the Mersenne number may be a Mersenne prime\\n(if P is not prime, the Mersenne number is also not prime).\\nIn the search for Mersenne prime numbers it is advantageous to eliminate exponents by finding a small factor before starting a, potentially lengthy, Lucas-Lehmer test.\\nThere are very efficient algorithms for determining if a number divides 2P-1 (or equivalently, if 2P mod (the number) = 1).\\nSome languages already have built-in implementations of this exponent-and-mod operation (called modPow or similar).\\nThe following is how to implement this modPow yourself:\\nFor example, let's compute 223 mod 47.\\nConvert the exponent 23 to binary, you get 10111. Starting with square = 1, repeatedly square it.\\nRemove the top bit of the exponent, and if it's 1 multiply square by the base of the exponentiation (2), then compute square modulo 47.\\nUse the result of the modulo from the last step as the initial value of square in the next step:\\nSince 223 mod 47 = 1, 47 is a factor of 2P-1.\\n(To see this, subtract 1 from both sides: 223-1 = 0 mod 47.)\\nSince we've shown that 47 is a factor, 223-1 is not prime.\\nFurther properties of Mersenne numbers allow us to refine the process even more.\\nAny factor q of 2P-1 must be of the form 2kP+1, k being a positive integer or zero. Furthermore, q must be 1 or 7 mod 8.\\nFinally any potential factor q must be prime.\\nAs in other trial division algorithms, the algorithm stops when 2kP+1 > sqrt(N).\\nThese primality tests only work on Mersenne numbers where P is prime. For example, M4=15 yields no factors using these techniques, but factors into 3 and 5, neither of which fit 2kP+1.\\n\\nUsing the above method find a factor of 2929-1 (aka M929)\\n\\n\\n\\nUse of bitwise operations\\n(TM (Test under Mask), SLA (Shift Left Arithmetic),SRA (Shift Right Arithmetic)).\\n","def is_prime(number):\\n    return True # code omitted - see Primality by Trial Division\\n\\ndef m_factor(p):\\n    max_k = 16384 / p # arbitrary limit; since Python automatically uses long's, it doesn't overflow\\n    for k in xrange(max_k):\\n        q = 2*p*k + 1\\n        if not is_prime(q):\\n            continue\\n        elif q % 8 != 1 and q % 8 != 7:\\n            continue\\n        elif pow(2, p, q) == 1:\\n            return q\\n    return None\\n\\nif __name__ == '__main__':\\n    exponent = int(raw_input(\""Enter exponent of Mersenne number: \""))\\n    if not is_prime(exponent):\\n        print \""Exponent is not prime: %d\"" % exponent\\n    else:\\n        factor = m_factor(exponent)\\n        if not factor:\\n            print \""No factor found for M%d\"" % exponent\\n        else:\\n            print \""M%d has a factor: %d\"" % (exponent, factor)"
"Python","Factors_of_an_integer","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\nCompute the   factors   of a positive integer.\\nThese factors are the positive integers by which the number being factored can be divided to yield a positive integer result.\\n(Though the concepts function correctly for zero and negative integers, the set of factors of zero has countably infinite members, and the factors of negative integers can be obtained from the factors of related positive numbers without difficulty;   this task does not require handling of either of these cases).\\nNote that every prime number has two factors:   1   and itself.\\n\\n\\nVery compact version.\\n",">>> def factors(n):\\n      return [i for i in range(1, n + 1) if not n%i]"
"Python","Factors_of_an_integer","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\nCompute the   factors   of a positive integer.\\nThese factors are the positive integers by which the number being factored can be divided to yield a positive integer result.\\n(Though the concepts function correctly for zero and negative integers, the set of factors of zero has countably infinite members, and the factors of negative integers can be obtained from the factors of related positive numbers without difficulty;   this task does not require handling of either of these cases).\\nNote that every prime number has two factors:   1   and itself.\\n\\n\\nVery compact version.\\n",">>> def factors(n):\\n      return [i for i in range(1, n//2 + 1) if not n%i] + [n]\\n\\n>>> factors(45)\\n[1, 3, 5, 9, 15, 45]"
"Python","Factors_of_an_integer","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\nCompute the   factors   of a positive integer.\\nThese factors are the positive integers by which the number being factored can be divided to yield a positive integer result.\\n(Though the concepts function correctly for zero and negative integers, the set of factors of zero has countably infinite members, and the factors of negative integers can be obtained from the factors of related positive numbers without difficulty;   this task does not require handling of either of these cases).\\nNote that every prime number has two factors:   1   and itself.\\n\\n\\nVery compact version.\\n",">>> from math import sqrt\\n>>> def factor(n):\\n      factors = set()\\n      for x in range(1, int(sqrt(n)) + 1):\\n        if n % x == 0:\\n          factors.add(x)\\n          factors.add(n//x)\\n      return sorted(factors)\\n\\n>>> for i in (45, 53, 64): print( \""%i: factors: %s\"" % (i, factor(i)) )\\n\\n45: factors: [1, 3, 5, 9, 15, 45]\\n53: factors: [1, 53]\\n64: factors: [1, 2, 4, 8, 16, 32, 64]"
"Python","Factors_of_an_integer","Basic Data Operation\\nThis is a basic data operation. It represents a fundamental action on a basic data type.\\nYou may see other such operations in the Basic Data Operations category, or:\\nInteger Operations\\n\\nArithmetic |\\nComparison\\nBoolean Operations\\n\\nBitwise |\\nLogical\\nString Operations\\n\\nConcatenation |\\nInterpolation |\\nComparison |\\nMatching\\nMemory Operations\\n\\nPointers & references |\\nAddresses\\nCompute the   factors   of a positive integer.\\nThese factors are the positive integers by which the number being factored can be divided to yield a positive integer result.\\n(Though the concepts function correctly for zero and negative integers, the set of factors of zero has countably infinite members, and the factors of negative integers can be obtained from the factors of related positive numbers without difficulty;   this task does not require handling of either of these cases).\\nNote that every prime number has two factors:   1   and itself.\\n\\n\\nVery compact version.\\n","from itertools import chain, cycle, accumulate # last of which is Python 3 only\\n\\ndef factors(n):\\n    def prime_powers(n):\\n        # c goes through 2, 3, 5, then the infinite (6n+1, 6n+5) series\\n        for c in accumulate(chain([2, 1, 2], cycle([2,4]))):\\n            if c*c > n: break\\n            if n%c: continue\\n            d,p = (), c\\n            while not n%c:\\n                n,p,d = n//c, p*c, d + (p,)\\n            yield(d)\\n        if n > 1: yield((n,))\\n\\n    r = [1]\\n    for e in prime_powers(n):\\n        r += [a*b for a in r for b in e]\\n    return r"
"Python","Farey_sequence","The   Farey sequence    Fn   of order   n   is the sequence of completely reduced fractions between   0   and   1   which, when in lowest terms, have denominators less than or equal to   n,   arranged in order of increasing size.\\nThe   Farey sequence   is sometimes incorrectly called a   Farey series.\\n\\nEach Farey sequence:\\n\\nThe Farey sequences of orders   1   to   5   are:\\n\\n\\n","from fractions import Fraction\\n\\n\\nclass Fr(Fraction):\\n    def __repr__(self):\\n        return '(%s/%s)' % (self.numerator, self.denominator)\\n\\n\\ndef farey(n, length=False):\\n    if not length:\\n        return [Fr(0, 1)] + sorted({Fr(m, k) for k in range(1, n+1) for m in range(1, k+1)})\\n    else:\\n        #return 1         +    len({Fr(m, k) for k in range(1, n+1) for m in range(1, k+1)})\\n        return  (n*(n+3))//2 - sum(farey(n//k, True) for k in range(2, n+1))\\n        \\nif __name__ == '__main__':\\n    print('Farey sequence for order 1 through 11 (inclusive):')\\n    for n in range(1, 12): \\n        print(farey(n))\\n    print('Number of fractions in the Farey sequence for order 100 through 1,000 (inclusive) by hundreds:')\\n    print([farey(i, length=True) for i in range(100, 1001, 100)])"
"Python","Fast_Fourier_transform","Calculate the   FFT   (Fast Fourier Transform)   of an input sequence.\\nThe most general case allows for complex numbers at the input\\nand results in a sequence of equal length, again of complex numbers.\\nIf you need to restrict yourself to real numbers, the output should\\nbe the magnitude (i.e. sqrt(re²+im²)) of the complex result.\\nThe classic version is the recursive Cooley–Tukey FFT. Wikipedia has pseudo-code for that.\\nFurther optimizations are possible but not required.\\n\\nThe FFT function is defined as a generic function, instantiated upon\\na user instance of Ada.Numerics.Generic_Complex_Arrays.\\nExample:\\n","from cmath import exp, pi\\n\\ndef fft(x):\\n    N = len(x)\\n    if N <= 1: return x\\n    even = fft(x[0::2])\\n    odd =  fft(x[1::2])\\n    T= [exp(-2j*pi*k/N)*odd[k] for k in range(N//2)]\\n    return [even[k] + T[k] for k in range(N//2)] + \\\\n           [even[k] - T[k] for k in range(N//2)]\\n\\nprint( ' '.join(\""%5.3f\"" % abs(f) \\n                for f in fft([1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0])) )"
"Python","Fast_Fourier_transform","Calculate the   FFT   (Fast Fourier Transform)   of an input sequence.\\nThe most general case allows for complex numbers at the input\\nand results in a sequence of equal length, again of complex numbers.\\nIf you need to restrict yourself to real numbers, the output should\\nbe the magnitude (i.e. sqrt(re²+im²)) of the complex result.\\nThe classic version is the recursive Cooley–Tukey FFT. Wikipedia has pseudo-code for that.\\nFurther optimizations are possible but not required.\\n\\nThe FFT function is defined as a generic function, instantiated upon\\na user instance of Ada.Numerics.Generic_Complex_Arrays.\\nExample:\\n",">>> from numpy.fft import fft\\n>>> from numpy import array\\n>>> a = array([1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0])\\n>>> print( ' '.join(\""%5.3f\"" % abs(f) for f in fft(a)) )\\n4.000 2.613 0.000 1.082 0.000 1.082 0.000 2.613"
"Python","FASTA_format","In bioinformatics, long character strings are often encoded in a format called FASTA.\\nA FASTA file can contain several strings, each identified by a name marked by a > (greater than) character at the beginning of the line.\\n\\nWrite a program that reads a FASTA file such as:\\n","import io\\n\\nFASTA='''\\\\n>Rosetta_Example_1\\nTHERECANBENOSPACE\\n>Rosetta_Example_2\\nTHERECANBESEVERAL\\nLINESBUTTHEYALLMUST\\nBECONCATENATED'''\\n\\ninfile = io.StringIO(FASTA)\\n\\ndef fasta_parse(infile):\\n    key = ''\\n    for line in infile:\\n        if line.startswith('>'):\\n            if key:\\n                yield key, val\\n            key, val = line[1:].rstrip().split()[0], ''\\n        elif key:\\n            val += line.rstrip()\\n    if key:\\n        yield key, val\\n\\nprint('\\n'.join('%s: %s' % keyval for keyval in fasta_parse(infile)))"
"Python","Faulhaber's_formula","In mathematics, Faulhaber's formula, named after Johann Faulhaber, expresses the sum of the p-th powers of the first n positive integers as a (p + 1)th-degree polynomial function of n, the coefficients involving Bernoulli numbers.\\nGenerate the first 10 closed-form expressions, starting with p = 0.\\n","from fractions import Fraction\\n\\ndef nextu(a):\\n    n = len(a)\\n    a.append(1)\\n    for i in range(n - 1, 0, -1):\\n        a[i] = i * a[i] + a[i - 1]\\n    return a\\n\\ndef nextv(a):\\n    n = len(a) - 1\\n    b = [(1 - n) * x for x in a]\\n    b.append(1)\\n    for i in range(n):\\n        b[i + 1] += a[i]\\n    return b\\n\\ndef sumpol(n):\\n    u = [0, 1]\\n    v = [[1], [1, 1]]\\n    yield [Fraction(0), Fraction(1)]\\n    for i in range(1, n):\\n        v.append(nextv(v[-1]))\\n        t = [0] * (i + 2)\\n        p = 1\\n        for j, r in enumerate(u):\\n            r = Fraction(r, j + 1)\\n            for k, s in enumerate(v[j + 1]):\\n                t[k] += r * s\\n        yield t\\n        u = nextu(u)\\n\\ndef polstr(a):\\n    s = \""\""\\n    q = False\\n    n = len(a) - 1\\n    for i, x in enumerate(reversed(a)):\\n        i = n - i\\n        if i < 2:\\n            m = \""n\"" if i == 1 else \""\""\\n        else:\\n            m = \""n^%d\"" % i\\n        c = str(abs(x))\\n        if i > 0:\\n            if c == \""1\"":\\n                c = \""\""\\n            else:\\n                m = \"" \"" + m\\n        if x != 0:\\n            if q:\\n                t = \"" + \"" if x > 0 else \"" - \""\\n                s += \""%s%s%s\"" % (t, c, m)\\n            else:\\n                t = \""\"" if x > 0 else \""-\""\\n                s = \""%s%s%s\"" % (t, c, m)\\n                q = True\\n    if q:\\n        return s\\n    else:\\n        return \""0\""\\n\\nfor i, p in enumerate(sumpol(10)):\\n    print(i, \"":\"", polstr(p))"
"Python","Faulhaber's_triangle","Named after Johann Faulhaber, the rows of Faulhaber's triangle are the coefficients of polynomials that represent sums of integer powers, which are extracted from Faulhaber's formula:\\n\\n\\nwhere \\n\\n\\n\\n\\nB\\n\\nn\\n\\n\\n\\n\\n{\\displaystyle B_{n}}\\n\\n is the nth-Bernoulli number.\\n\\nThe first 5 rows of Faulhaber's triangle, are:\\n\\nUsing the third row of the triangle, we have:\\n\\n\\n\\n\\n\\n∑\\n\\nk\\n=\\n1\\n\\n\\nn\\n\\n\\n\\nk\\n\\n2\\n\\n\\n=\\n\\n\\n1\\n6\\n\\n\\nn\\n+\\n\\n\\n1\\n2\\n\\n\\n\\nn\\n\\n2\\n\\n\\n+\\n\\n\\n1\\n3\\n\\n\\n\\nn\\n\\n3\\n\\n\\n\\n\\n{\\displaystyle \\sum _{k=1}^{n}k^{2}={1 \\over 6}n+{1 \\over 2}n^{2}+{1 \\over 3}n^{3}}\\n\\n\\n\\n\\n","from itertools import (accumulate, count, islice, starmap)\\nfrom fractions import (Fraction)\\n\\n\\n# faulhaber :: Integer -> Integer -> Integer\\ndef faulhaber(p, n):\\n    \""\""\""Sum of the p-th powers of the first n positive integers\""\""\""\\n    return sum(\\n        list(starmap(\\n            lambda x, y: y * (n ** x),\\n            zip(count(1), faulhaberTriangle(p)[-1])\\n        ))\\n    )\\n\\n\\n# faulhaberTriangle :: Int -> [[Fraction]]\\ndef faulhaberTriangle(m):\\n    def go(rs, n):\\n        xs = list(starmap(\\n            lambda x, y: Fraction(n, x) * y,\\n            zip(islice(count(2), m), rs)\\n        ))\\n        return [1 - sum(xs)] + xs\\n    return list(accumulate(\\n        [[]] + list(islice(count(0), 1 + m)),\\n        go\\n    ))[1:]\\n\\n\\n# TEST ----------------------------------------------------\\n\\nfaulhabers = map(\\n    lambda ln: list(map(\\n        lambda r: str(r.numerator).rjust(2, ' ') + (\\n            '/' + str(r.denominator).ljust(5, ' ') if (\\n                r.denominator > 1\\n            ) else '      '\\n        ),\\n        ln\\n    )),\\n    faulhaberTriangle(9)\\n)\\n\\nfor row in faulhabers:\\n    print (''.join(row))\\nprint ('')\\nprint (\\n    faulhaber(17, 1000)\\n)"
"Python","Feigenbaum_constant_calculation","\\nCalculate the Feigenbaum constant.\\n\\n\\n","max_it = 13\\nmax_it_j = 10\\na1 = 1.0\\na2 = 0.0\\nd1 = 3.2\\na = 0.0\\n\\nprint \"" i       d\""\\nfor i in range(2, max_it + 1):\\n    a = a1 + (a1 - a2) / d1\\n    for j in range(1, max_it_j + 1):\\n        x = 0.0\\n        y = 0.0\\n        for k in range(1, (1 << i) + 1):\\n            y = 1.0 - 2.0 * y * x\\n            x = a - x * x\\n        a = a - x / y\\n    d = (a1 - a2) / (a - a1)\\n    print(\""{0:2d}    {1:.8f}\"".format(i, d))\\n    d1 = d\\n    a2 = a1\\n    a1 = a"
"Python","Fibonacci_heap","\\n\\nA package. Implementation follows Fredman and Tarjan's 1987 paper.\\nA demonstration:\\n","class FibonacciHeap:\\n    \\n    # internal node class \\n    class Node:\\n        def __init__(self, data):\\n            self.data = data\\n            self.parent = self.child = self.left = self.right = None\\n            self.degree = 0\\n            self.mark = False\\n            \\n    # function to iterate through a doubly linked list\\n    def iterate(self, head):\\n        node = stop = head\\n        flag = False\\n        while True:\\n            if node == stop and flag is True:\\n                break\\n            elif node == stop:\\n                flag = True\\n            yield node\\n            node = node.right\\n    \\n    # pointer to the head and minimum node in the root list\\n    root_list, min_node = None, None\\n    \\n    # maintain total node count in full fibonacci heap\\n    total_nodes = 0\\n    \\n    # return min node in O(1) time\\n    def find_min(self):\\n        return self.min_node\\n         \\n    # extract (delete) the min node from the heap in O(log n) time\\n    # amortized cost analysis can be found here (http://bit.ly/1ow1Clm)\\n    def extract_min(self):\\n        z = self.min_node\\n        if z is not None:\\n            if z.child is not None:\\n                # attach child nodes to root list\\n                children = [x for x in self.iterate(z.child)]\\n                for i in xrange(0, len(children)):\\n                    self.merge_with_root_list(children[i])\\n                    children[i].parent = None\\n            self.remove_from_root_list(z)\\n            # set new min node in heap\\n            if z == z.right:\\n                self.min_node = self.root_list = None\\n            else:\\n                self.min_node = z.right\\n                self.consolidate()\\n            self.total_nodes -= 1\\n        return z\\n                    \\n    # insert new node into the unordered root list in O(1) time\\n    def insert(self, data):\\n        n = self.Node(data)\\n        n.left = n.right = n\\n        self.merge_with_root_list(n)\\n        if self.min_node is None or n.data < self.min_node.data:\\n            self.min_node = n\\n        self.total_nodes += 1\\n        \\n    # modify the data of some node in the heap in O(1) time\\n    def decrease_key(self, x, k):\\n        if k > x.data:\\n            return None\\n        x.data = k\\n        y = x.parent\\n        if y is not None and x.data < y.data:\\n            self.cut(x, y)\\n            self.cascading_cut(y)\\n        if x.data < self.min_node.data:\\n            self.min_node = x\\n            \\n    # merge two fibonacci heaps in O(1) time by concatenating the root lists\\n    # the root of the new root list becomes equal to the first list and the second\\n    # list is simply appended to the end (then the proper min node is determined)\\n    def merge(self, h2):\\n        H = FibonacciHeap()\\n        H.root_list, H.min_node = self.root_list, self.min_node\\n        # fix pointers when merging the two heaps\\n        last = h2.root_list.left\\n        h2.root_list.left = H.root_list.left\\n        H.root_list.left.right = h2.root_list\\n        H.root_list.left = last\\n        H.root_list.left.right = H.root_list\\n        # update min node if needed\\n        if h2.min_node.data < H.min_node.data:\\n            H.min_node = h2.min_node\\n        # update total nodes\\n        H.total_nodes = self.total_nodes + h2.total_nodes\\n        return H\\n        \\n    # if a child node becomes smaller than its parent node we\\n    # cut this child node off and bring it up to the root list\\n    def cut(self, x, y):\\n        self.remove_from_child_list(y, x)\\n        y.degree -= 1\\n        self.merge_with_root_list(x)\\n        x.parent = None\\n        x.mark = False\\n    \\n    # cascading cut of parent node to obtain good time bounds\\n    def cascading_cut(self, y):\\n        z = y.parent\\n        if z is not None:\\n            if y.mark is False:\\n                y.mark = True\\n            else:\\n                self.cut(y, z)\\n                self.cascading_cut(z)\\n    \\n    # combine root nodes of equal degree to consolidate the heap\\n    # by creating a list of unordered binomial trees\\n    def consolidate(self):\\n        A = [None] * self.total_nodes\\n        nodes = [w for w in self.iterate(self.root_list)]\\n        for w in xrange(0, len(nodes)):\\n            x = nodes[w]\\n            d = x.degree\\n            while A[d] != None:\\n                y = A[d] \\n                if x.data > y.data:\\n                    temp = x\\n                    x, y = y, temp\\n                self.heap_link(y, x)\\n                A[d] = None\\n                d += 1\\n            A[d] = x\\n        # find new min node - no need to reconstruct new root list below\\n        # because root list was iteratively changing as we were moving \\n        # nodes around in the above loop\\n        for i in xrange(0, len(A)):\\n            if A[i] is not None:\\n                if A[i].data < self.min_node.data:\\n                    self.min_node = A[i]\\n        \\n    # actual linking of one node to another in the root list\\n    # while also updating the child linked list\\n    def heap_link(self, y, x):\\n        self.remove_from_root_list(y)\\n        y.left = y.right = y\\n        self.merge_with_child_list(x, y)\\n        x.degree += 1\\n        y.parent = x\\n        y.mark = False\\n        \\n    # merge a node with the doubly linked root list   \\n    def merge_with_root_list(self, node):\\n        if self.root_list is None:\\n            self.root_list = node\\n        else:\\n            node.right = self.root_list.right\\n            node.left = self.root_list\\n            self.root_list.right.left = node\\n            self.root_list.right = node\\n            \\n    # merge a node with the doubly linked child list of a root node\\n    def merge_with_child_list(self, parent, node):\\n        if parent.child is None:\\n            parent.child = node\\n        else:\\n            node.right = parent.child.right\\n            node.left = parent.child\\n            parent.child.right.left = node\\n            parent.child.right = node\\n            \\n    # remove a node from the doubly linked root list\\n    def remove_from_root_list(self, node):\\n        if node == self.root_list:\\n            self.root_list = node.right\\n        node.left.right = node.right\\n        node.right.left = node.left\\n        \\n    # remove a node from the doubly linked child list\\n    def remove_from_child_list(self, parent, node):\\n        if parent.child == parent.child.right:\\n            parent.child = None\\n        elif parent.child == node:\\n            parent.child = node.right\\n            node.right.parent = parent\\n        node.left.right = node.right\\n        node.right.left = node.left"
"Python","Fibonacci_n-step_number_sequences","These number series are an expansion of the ordinary Fibonacci sequence where:\\nFor small values of \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n, Greek numeric prefixes are sometimes used to individually name each series.\\nAllied sequences can be generated where the initial values are changed:\\n\\n\\n\\n\\n\\nFirst, we specify a package Bonacci, that defines the type Sequence (of Positive numbers), a function Generate that takes a given Start sequence and outputs a generalized N-Bonacci Sequence of a spefified Length, and some constant start sequences.\\nThe implementation is quite straightforward.\\nFinally, we actually generate some sequences, as required by the task. For convenience, we define a procedure Print that outputs a sequence,\\nThe output:\\nOutput:\\n",">>> def fiblike(start):\\n	addnum = len(start)\\n	memo = start[:]\\n	def fibber(n):\\n		try:\\n			return memo[n]\\n		except IndexError:\\n			ans = sum(fibber(i) for i in range(n-addnum, n))\\n			memo.append(ans)\\n			return ans\\n	return fibber\\n\\n>>> fibo = fiblike([1,1])\\n>>> [fibo(i) for i in range(10)]\\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\\n>>> lucas = fiblike([2,1])\\n>>> [lucas(i) for i in range(10)]\\n[2, 1, 3, 4, 7, 11, 18, 29, 47, 76]\\n>>> for n, name in zip(range(2,11), 'fibo tribo tetra penta hexa hepta octo nona deca'.split()) :\\n	fibber = fiblike([1] + [2**i for i in range(n-1)])\\n	print('n=%2i, %5snacci -> %s ...' % (n, name, ' '.join(str(fibber(i)) for i in range(15))))\\n\\n	\\nn= 2,  fibonacci -> 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...\\nn= 3, tribonacci -> 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...\\nn= 4, tetranacci -> 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...\\nn= 5, pentanacci -> 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...\\nn= 6,  hexanacci -> 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...\\nn= 7, heptanacci -> 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...\\nn= 8,  octonacci -> 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...\\nn= 9,  nonanacci -> 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...\\nn=10,  decanacci -> 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...\\n>>> "
"Python","Fibonacci_n-step_number_sequences","These number series are an expansion of the ordinary Fibonacci sequence where:\\nFor small values of \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n, Greek numeric prefixes are sometimes used to individually name each series.\\nAllied sequences can be generated where the initial values are changed:\\n\\n\\n\\n\\n\\nFirst, we specify a package Bonacci, that defines the type Sequence (of Positive numbers), a function Generate that takes a given Start sequence and outputs a generalized N-Bonacci Sequence of a spefified Length, and some constant start sequences.\\nThe implementation is quite straightforward.\\nFinally, we actually generate some sequences, as required by the task. For convenience, we define a procedure Print that outputs a sequence,\\nThe output:\\nOutput:\\n",">>> class Fiblike():\\n	def __init__(self, start):\\n		self.addnum = len(start)\\n		self.memo = start[:]\\n	def __call__(self, n):\\n		try:\\n			return self.memo[n]\\n		except IndexError:\\n			ans = sum(self(i) for i in range(n-self.addnum, n))\\n			self.memo.append(ans)\\n			return ans\\n\\n		\\n>>> fibo = Fiblike([1,1])\\n>>> [fibo(i) for i in range(10)]\\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\\n>>> lucas = Fiblike([2,1])\\n>>> [lucas(i) for i in range(10)]\\n[2, 1, 3, 4, 7, 11, 18, 29, 47, 76]\\n>>> for n, name in zip(range(2,11), 'fibo tribo tetra penta hexa hepta octo nona deca'.split()) :\\n	fibber = Fiblike([1] + [2**i for i in range(n-1)])\\n	print('n=%2i, %5snacci -> %s ...' % (n, name, ' '.join(str(fibber(i)) for i in range(15))))\\n\\n	\\nn= 2,  fibonacci -> 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...\\nn= 3, tribonacci -> 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...\\nn= 4, tetranacci -> 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...\\nn= 5, pentanacci -> 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...\\nn= 6,  hexanacci -> 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...\\nn= 7, heptanacci -> 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...\\nn= 8,  octonacci -> 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...\\nn= 9,  nonanacci -> 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...\\nn=10,  decanacci -> 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...\\n>>> "
"Python","Fibonacci_n-step_number_sequences","These number series are an expansion of the ordinary Fibonacci sequence where:\\nFor small values of \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n, Greek numeric prefixes are sometimes used to individually name each series.\\nAllied sequences can be generated where the initial values are changed:\\n\\n\\n\\n\\n\\nFirst, we specify a package Bonacci, that defines the type Sequence (of Positive numbers), a function Generate that takes a given Start sequence and outputs a generalized N-Bonacci Sequence of a spefified Length, and some constant start sequences.\\nThe implementation is quite straightforward.\\nFinally, we actually generate some sequences, as required by the task. For convenience, we define a procedure Print that outputs a sequence,\\nThe output:\\nOutput:\\n","from itertools import islice, cycle\\n\\ndef fiblike(tail):\\n    for x in tail:\\n        yield x\\n    for i in cycle(xrange(len(tail))):\\n        tail[i] = x = sum(tail)\\n        yield x\\n\\nfibo = fiblike([1, 1])\\nprint list(islice(fibo, 10))\\nlucas = fiblike([2, 1])\\nprint list(islice(lucas, 10))\\n\\nsuffixes = \""fibo tribo tetra penta hexa hepta octo nona deca\""\\nfor n, name in zip(xrange(2, 11), suffixes.split()):\\n    fib = fiblike([1] + [2 ** i for i in xrange(n - 1)])\\n    items = list(islice(fib, 15))\\n    print \""n=%2i, %5snacci -> %s ...\"" % (n, name, items)"
"Python","Fibonacci_n-step_number_sequences","These number series are an expansion of the ordinary Fibonacci sequence where:\\nFor small values of \\n\\n\\n\\nn\\n\\n\\n{\\displaystyle n}\\n\\n, Greek numeric prefixes are sometimes used to individually name each series.\\nAllied sequences can be generated where the initial values are changed:\\n\\n\\n\\n\\n\\nFirst, we specify a package Bonacci, that defines the type Sequence (of Positive numbers), a function Generate that takes a given Start sequence and outputs a generalized N-Bonacci Sequence of a spefified Length, and some constant start sequences.\\nThe implementation is quite straightforward.\\nFinally, we actually generate some sequences, as required by the task. For convenience, we define a procedure Print that outputs a sequence,\\nThe output:\\nOutput:\\n","# Start sequence -> Number of terms -> terms\\n\\n\\n# takeNFibs :: [Int] -> Int -> [Int]\\ndef takeNFibs(xs):\\n    def go(xs):\\n        return lambda n: (\\n            cons(head(xs))(\\n                go(\\n                    append(tail(xs))\\n                    ([sum(xs)])\\n                )\\n                (n - 1)\\n            )\\n        ) if (0 < n and 0 < len(xs)) else []\\n    return lambda n: go(xs)(n)\\n\\n\\n# fibInit :: Int -> [Int]\\ndef fibInit(n):\\n    return (\\n        cons(1)(\\n            list(\\n                map_(lambda x: 2**x)\\n                (enumFromTo(0)(n - 2))\\n            )\\n        )\\n    )\\n\\n# CURRIED SIMPLES -----------------------------------------\\n\\n\\n# append :: [a] -> [a] -> [a]\\ndef append(xs):\\n    return lambda ys: xs + ys\\n\\n\\n# cons :: a -> [a] -> [a]\\ndef cons(x):\\n    return lambda xs: [x] + xs\\n\\n\\n# enumFromTo :: Int -> Int -> [Int]\\ndef enumFromTo(m):\\n    return lambda n: list(range(m, 1 + n))\\n\\n\\n# head :: [a] -> a\\ndef head(xs):\\n    return xs[0]\\n\\n\\n# justifyLeft :: Int -> Char -> String -> String\\ndef justifyLeft(n):\\n    return lambda cFiller: lambda s: (\\n        (s + (n * cFiller))[:n]\\n    )\\n\\n\\n# map :: (a -> b) -> [a] -> [b]\\ndef map_(f):\\n    return lambda xs: map(f, xs)\\n\\n\\n# showList :: [a] -> String\\ndef showList(xs):\\n    return '[' + ', '.join(str(x) for x in xs) + ']'\\n\\n\\n# tail :: [a] -> [a]\\ndef tail(xs):\\n    return xs[1:]\\n\\n\\n# take :: Int -> [a] -> [a]\\n# take :: Int -> String -> String\\ndef take(n):\\n    return lambda xs: xs[0:n]\\n\\n\\n# unlines :: [String] -> String\\ndef unlines(xs):\\n    return '\\n'.join(xs)\\n\\n\\n# words :: String -> [String]\\ndef words(s):\\n    return s.split()\\n\\n\\n# zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\\ndef zipWith(f):\\n    return (\\n        lambda xs: lambda ys:\\n            [f(a)(b) for (a, b) in zip(xs, ys)]\\n    )\\n\\n\\n# MAIN ----------------------------------------------------\\ndef main():\\n    print (\\n        justifyLeft(12)\\n        (' ')\\n        ('Lucas') + ' -> ' + showList(\\n            takeNFibs([2, 1])\\n            (15)\\n        )\\n    )\\n    print (\\n        unlines(\\n            zipWith(\\n                lambda s: lambda n:\\n                justifyLeft(12)\\n                (' ')\\n                (s + 'nacci') + ' -> ' + showList(\\n                    takeNFibs(fibInit(n))\\n                    (15)\\n                )\\n            )\\n            (words('fibo tribo tetra penta hexa hepta octo nona deca'))\\n            (enumFromTo(2)(10))\\n        )\\n    )\\n\\n\\nmain()"
"Python","Fibonacci_sequence","The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:\\n\\nWrite a function to generate the    nth    Fibonacci number.\\nSolutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).\\nThe sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:\\nsupport for negative      n      in the solution is optional.\\n\\n\\n\\nFor maximum compatibility, programs use only the basic instruction set.\\n","def fib(n,x=[0,1]):\\n   for i in range(abs(n)-1): x=[x[1],sum(x)]\\n   return x[1]*pow(-1,abs(n)-1) if n<0 else x[1] if n else 0\\n\\nfor i in range(-30,31): print fib(i),"
"Python","Fibonacci_sequence","The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:\\n\\nWrite a function to generate the    nth    Fibonacci number.\\nSolutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).\\nThe sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:\\nsupport for negative      n      in the solution is optional.\\n\\n\\n\\nFor maximum compatibility, programs use only the basic instruction set.\\n","from math import *\\n\\ndef analytic_fibonacci(n):\\n  sqrt_5 = sqrt(5);\\n  p = (1 + sqrt_5) / 2;\\n  q = 1/p;\\n  return int( (p**n + q**n) / sqrt_5 + 0.5 )\\n\\nfor i in range(1,31):\\n  print analytic_fibonacci(i),"
"Python","Fibonacci_sequence","The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:\\n\\nWrite a function to generate the    nth    Fibonacci number.\\nSolutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).\\nThe sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:\\nsupport for negative      n      in the solution is optional.\\n\\n\\n\\nFor maximum compatibility, programs use only the basic instruction set.\\n","def fibIter(n):\\n    if n < 2:\\n        return n\\n    fibPrev = 1\\n    fib = 1\\n    for num in xrange(2, n):\\n        fibPrev, fib = fib, fib + fibPrev\\n    return fib"
"Python","Fibonacci_sequence","The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:\\n\\nWrite a function to generate the    nth    Fibonacci number.\\nSolutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).\\nThe sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:\\nsupport for negative      n      in the solution is optional.\\n\\n\\n\\nFor maximum compatibility, programs use only the basic instruction set.\\n","def fibRec(n):\\n    if n < 2:\\n        return n\\n    else:\\n        return fibRec(n-1) + fibRec(n-2)"
"Python","Fibonacci_sequence","The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:\\n\\nWrite a function to generate the    nth    Fibonacci number.\\nSolutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).\\nThe sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:\\nsupport for negative      n      in the solution is optional.\\n\\n\\n\\nFor maximum compatibility, programs use only the basic instruction set.\\n","def fibMemo():\\n    pad = {0:0, 1:1}\\n    def func(n):\\n        if n not in pad:\\n            pad[n] = func(n-1) + func(n-2)\\n        return pad[n]\\n    return func\\n\\nfm = fibMemo()\\nfor i in range(1,31):\\n    print fm(i),"
"Python","Fibonacci_sequence","The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:\\n\\nWrite a function to generate the    nth    Fibonacci number.\\nSolutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).\\nThe sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:\\nsupport for negative      n      in the solution is optional.\\n\\n\\n\\nFor maximum compatibility, programs use only the basic instruction set.\\n","def fibFastRec(n):\\n    def fib(prvprv, prv, c):\\n        if c < 1: \\n            return prvprv\\n        else: \\n            return fib(prv, prvprv + prv, c - 1) \\n    return fib(0, 1, n)"
"Python","Fibonacci_sequence","The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:\\n\\nWrite a function to generate the    nth    Fibonacci number.\\nSolutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).\\nThe sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:\\nsupport for negative      n      in the solution is optional.\\n\\n\\n\\nFor maximum compatibility, programs use only the basic instruction set.\\n","def fibGen(n):\\n    a, b = 0, 1\\n    while n>0:\\n        yield a\\n        a, b, n = b, a+b, n-1"
"Python","Fibonacci_sequence","The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:\\n\\nWrite a function to generate the    nth    Fibonacci number.\\nSolutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).\\nThe sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:\\nsupport for negative      n      in the solution is optional.\\n\\n\\n\\nFor maximum compatibility, programs use only the basic instruction set.\\n","\\n>>> [i for i in fibGen(11)]\\n\\n[0,1,1,2,3,5,8,13,21,34,55]\\n"
"Python","Fibonacci_sequence","The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:\\n\\nWrite a function to generate the    nth    Fibonacci number.\\nSolutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).\\nThe sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:\\nsupport for negative      n      in the solution is optional.\\n\\n\\n\\nFor maximum compatibility, programs use only the basic instruction set.\\n","\\ndef prevPowTwo(n):\\n    'Gets the power of two that is less than or equal to the given input'\\n    if ((n & -n) == n):\\n        return n\\n    else:\\n        n -= 1\\n        n |= n >> 1\\n        n |= n >> 2\\n        n |= n >> 4\\n        n |= n >> 8\\n        n |= n >> 16\\n        n += 1\\n        return (n/2)\\n\\ndef crazyFib(n):\\n    'Crazy fast fibonacci number calculation'\\n    powTwo = prevPowTwo(n)\\n    \\n    q = r = i = 1\\n    s = 0\\n    \\n    while(i < powTwo):\\n        i *= 2\\n        q, r, s = q*q + r*r, r * (q + s), (r*r + s*s)\\n        \\n    while(i < n):\\n        i += 1\\n        q, r, s = q+r, q, r\\n        \\n    return q\\n"
"Python","Fibonacci_sequence","The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:\\n\\nWrite a function to generate the    nth    Fibonacci number.\\nSolutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).\\nThe sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:\\nsupport for negative      n      in the solution is optional.\\n\\n\\n\\nFor maximum compatibility, programs use only the basic instruction set.\\n","def fib(n, c={0:1, 1:1}):\\n    if n not in c:\\n        x = n // 2\\n        c[n] = fib(x-1) * fib(n-x-1) + fib(x) * fib(n - x)\\n    return c[n]\\n\\nfib(10000000)  # calculating it takes a few seconds, printing it takes eons"
"Python","Fibonacci_sequence","The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:\\n\\nWrite a function to generate the    nth    Fibonacci number.\\nSolutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).\\nThe sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:\\nsupport for negative      n      in the solution is optional.\\n\\n\\n\\nFor maximum compatibility, programs use only the basic instruction set.\\n","F = {0: 0, 1: 1, 2: 1}\\ndef fib(n):\\n    if n in F:\\n        return F[n]\\n    f1 = fib(n // 2 + 1)\\n    f2 = fib((n - 1) // 2)\\n    F[n] = (f1 * f1 + f2 * f2 if n & 1 else f1 * f1 - f2 * f2)\\n    return F[n]"
"Python","Fibonacci_sequence","The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:\\n\\nWrite a function to generate the    nth    Fibonacci number.\\nSolutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).\\nThe sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:\\nsupport for negative      n      in the solution is optional.\\n\\n\\n\\nFor maximum compatibility, programs use only the basic instruction set.\\n","def fib():\\n    \""\""\""Yield fib[n+1] + fib[n]\""\""\""\\n    yield 1  # have to start somewhere\\n    lhs, rhs = fib(), fib()\\n    yield next(lhs) # move lhs one iteration ahead\\n    while True:\\n        yield next(lhs)+next(rhs)\\n\\nf=fib()\\nprint [next(f) for _ in range(9)]"
"Python","Fibonacci_sequence","The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:\\n\\nWrite a function to generate the    nth    Fibonacci number.\\nSolutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).\\nThe sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:\\nsupport for negative      n      in the solution is optional.\\n\\n\\n\\nFor maximum compatibility, programs use only the basic instruction set.\\n","from itertools import islice\\n\\ndef fib():\\n    yield 0\\n    yield 1\\n    a, b = fib(), fib()\\n    next(b)\\n    while True:\\n        yield next(a)+next(b)\\n \\nprint(tuple(islice(fib(), 10)))"
"Python","Fibonacci_word","The   Fibonacci Word   may be created in a manner analogous to the   Fibonacci Sequence   as described here:\\n\\nPerform the above steps for     n = 37.\\nYou may display the first few but not the larger values of   n.\\n{Doing so will get the task's author into trouble with them what be (again!).} \\nInstead, create a table for   F_Words   1   to   37   which shows:\\n\\n\\nOutput\\n",">>> import math\\n>>> from collections import Counter\\n>>> \\n>>> def entropy(s):\\n...     p, lns = Counter(s), float(len(s))\\n...     return -sum( count/lns * math.log(count/lns, 2) for count in p.values())\\n... \\n>>> \\n>>> def fibword(nmax=37):\\n...     fwords = ['1', '0']\\n...     print('%-3s %10s %-10s %s' % tuple('N Length Entropy Fibword'.split()))\\n...     def pr(n, fwords):\\n...         while len(fwords) < n:\\n...             fwords += [''.join(fwords[-2:][::-1])]\\n...         v = fwords[n-1]\\n...         print('%3i %10i %10.7g %s' % (n, len(v), entropy(v), v if len(v) < 20 else ''))\\n...     for n in range(1, nmax+1): pr(n, fwords)\\n... \\n>>> fibword()\\nN       Length Entropy    Fibword\\n  1          1         -0 1\\n  2          1         -0 0\\n  3          2          1 01\\n  4          3  0.9182958 010\\n  5          5  0.9709506 01001\\n  6          8   0.954434 01001010\\n  7         13  0.9612366 0100101001001\\n  8         21  0.9587119 \\n  9         34  0.9596869 \\n 10         55   0.959316 \\n 11         89  0.9594579 \\n 12        144  0.9594038 \\n 13        233  0.9594244 \\n 14        377  0.9594165 \\n 15        610  0.9594196 \\n 16        987  0.9594184 \\n 17       1597  0.9594188 \\n 18       2584  0.9594187 \\n 19       4181  0.9594187 \\n 20       6765  0.9594187 \\n 21      10946  0.9594187 \\n 22      17711  0.9594187 \\n 23      28657  0.9594187 \\n 24      46368  0.9594187 \\n 25      75025  0.9594187 \\n 26     121393  0.9594187 \\n 27     196418  0.9594187 \\n 28     317811  0.9594187 \\n 29     514229  0.9594187 \\n 30     832040  0.9594187 \\n 31    1346269  0.9594187 \\n 32    2178309  0.9594187 \\n 33    3524578  0.9594187 \\n 34    5702887  0.9594187 \\n 35    9227465  0.9594187 \\n 36   14930352  0.9594187 \\n 37   24157817  0.9594187 \\n>>> "
"Python","Fibonacci_word/fractal","The Fibonacci word may be represented as a fractal as described here:\\n\\nCreate and display a fractal similar to Fig 1.\\n\\nPrints F_Word30 currently. Segment length and F_Wordn can be adjusted.\\nWrites an EPS file that has the 26th fractal. This is probably cheating.\\nThis uses the turtle module from the Dragon Curve Task, and the module from the Grayscale Image task.\\nIt prints the level 25 word as the Python entry.\\nOutput is same as Ruby.\\nWe output an SVG or rather an HTML with an embedded SVGPoints to note:","from functools import wraps\\nfrom turtle import *\\n\\ndef memoize(obj):\\n    cache = obj.cache = {}\\n    @wraps(obj)\\n    def memoizer(*args, **kwargs):\\n        key = str(args) + str(kwargs)\\n        if key not in cache:\\n            cache[key] = obj(*args, **kwargs)\\n        return cache[key]\\n    return memoizer\\n\\n@memoize\\ndef fibonacci_word(n):\\n    assert n > 0\\n    if n == 1:\\n        return \""1\""\\n    if n == 2:\\n        return \""0\""\\n    return fibonacci_word(n - 1) + fibonacci_word(n - 2)\\n\\ndef draw_fractal(word, step):\\n    for i, c in enumerate(word, 1):\\n        forward(step)\\n        if c == \""0\"":\\n            if i % 2 == 0:\\n                left(90)\\n            else:\\n                right(90)\\n\\ndef main():\\n    n = 25 # Fibonacci Word to use.\\n    step = 1 # Segment length.\\n    width = 1050 # Width of plot area.\\n    height = 1050 # Height of plot area.\\n    w = fibonacci_word(n)\\n\\n    setup(width=width, height=height)\\n    speed(0)\\n    setheading(90)\\n    left(90)\\n    penup()\\n    forward(500)\\n    right(90)\\n    backward(500)\\n    pendown()\\n    tracer(10000)\\n    hideturtle()\\n\\n    draw_fractal(w, step)\\n\\n    # Save Poscript image.\\n    getscreen().getcanvas().postscript(file=\""fibonacci_word_fractal.eps\"")\\n    exitonclick()\\n\\nif __name__ == '__main__':\\n    main()"
"Python","File_extension_is_in_extensions_list","Given an arbitrary filename and a list of extensions, tell whether the filename has one of those extensions.\\nNotes:\\n\\nThe following test cases all assume this list of extensions:   zip, rar, 7z, gz, archive, A##\\nIf your solution does the extra credit requirement, add tar.bz2 to the list of extensions, and check the following additional test cases:\\nChecking if a file is in a certain category of file formats with known extensions (e.g. archive files, or image files) is a common problem in practice, and may be approached differently from extracting and outputting an arbitrary extension (see e.g. FileNameExtensionFilter in Java).\\nIt also requires less assumptions about the format of an extension, because the calling code can decide what extensions are valid.\\nFor these reasons, this task exists in addition to the Extract file extension task.\\n","\\ndef isExt(fileName, extensions):\\n  return True in map(fileName.lower().endswith, (\"".\"" + e.lower() for e in extensions))\\n"
"Python","File_input/output","Create a file called   \""output.txt\"",   and place in it the contents of the file   \""input.txt\"",   via an intermediate variable.\\nIn other words, your program will demonstrate:\\n\\nOneliners that skip the intermediate variable are of secondary interest — operating systems have copy commands for that.\\n\\nAssuming everything is fine and no error handling is required, this solution is sufficient:\\nExpanded with proper error handling and reporting it reads:\\nThe following example reads and writes each file one character at a time. (You should of course add error reporting as in the example above.)\\nThe following solution uses stream I/O. Any file of Ada.Text_IO can be used to obtain a corresponding stream. Reading and writing streams is more efficient than reading text files directly, because it skips formatting.\\nMethod 1: the input file can be processed line by line.\\nMethod 2: the input file can be read at once if it is less than 1 GB.\\nMethod 3: the file can be copied without I/O.\\nBinary I/O is possible with this library from Laszlo.\\n(This does not handle properly binary files)\\nThe spirit of Babel is to manipulate things on the stack whenever feasible. In this example,\\nI showed how to save it into a symbolic variable (foo) but this step would not be necessary\\nfor many simple file-processing tasks, such as splitting on newlines or spaces.\\nAlso note that the >>> (slurp) and <<< (spit) operators only handle \""small\"" files - the limit is\\nconfigurable but the default limit is 100MB. If you want to open very large files or if you need\\nto perform a lot of interactive file I/O, Babel provides operators that wrap the C standard library\\nfopen()/fclose() functions.\\nThis is only meant to copy a sequential text file. It is very unlikely that this works copying a random access text file.\\nor\\nor\\nThere may be other techniques too.\\nBBC BASIC for Windows has a file copy command:\\nAlternatively the copy can be done explicitly:\\nThis linear program tries to open \""input.txt\"" as text file (or aborts).\\nIt then writes the content in text mode (i.e. minus trailing spaces) to \""output.txt\"" (or aborts).\\nA couple of remarks on the preceding example:\\nIt uses fgetc to read one character at a time. Each character is visited, even though there's nothing to do with it. Copying bigger blocks of data is much more efficient.\\nThe following example addresses those issues. To avoid buffered I/O, it uses open(), read(), write() and close(), which are part of POSIX.\\nThe long way:\\nThe short way:\\nSimpler version:\\nUsing istream- and ostream- iterators:\\nEven simpler way:\\nDefine a function that copies the content from one file to another.\\nApply this function to the world to copy a file.\\nFlags used for Micro Focus COBOL:\\nBy lines:\\nBy arbitrary blocks and for possibly-binary files:\\nIf you're on an odd platform which actually stores text/binary/... type information for files and your CL implementation will use this information, then in should be opened with :element-type :default.\\nvery plainly, with an intermediate variable:\\nvia an intermediate buffer variable:\\nCopy the content from one file to another (exceptions are handled by Tango):\\nOr a shorter example without explicitly closing the output file:\\nDelphi supports both typed and untyped as well as a textfile type for files. Delphi provides a default 128 byte buffer for text files. This may be enlarged via a call to SetTextBuff(Var F: Text; Var Buf [Size : integer]) procedure. All other files have no buffer at all and it is the programmers option to do buffering.\\nThe following file I/O procedures have existed since Turbo Pascal V-3.\\nFiles are opened using:\\nAssignFile(f,{fully qualified path and file name})\\nAssigns the file name to the file structure in preparation for opening.\\nReset(f)\\nOpens and existing file. If it does not exist EIOError is raised.\\nRewrite(f)\\nCreates a new file and opens it for I/O. If the files exists is is overwritten.\\nDelphi implemented Streams of which a variant is TFileStream and are very closely related to the Windows API for file handling.\\n- Text File I/O -\\n\\n- Untyped File I/O -\\nThis is perhaps one of the most powerful I/O functions built into Pascal. This will allow you to open and read a file of ANY type, regardless of structure, size or content. Note the usage of Reset(). This is using the optional size parameter that instructs the record size of file I/O. This could have been called with SizeOf(Buff) as the optional parameter but that would have limited flexibility. Calling it with a size of ONE byte allows you to adjust the buffer size on the fly, as conditions warrant. Also note the use of the BytesRead parameter. When included in the BlockRead() function it will return the number of bytes actually read. If this is not included, then if your directive to read n bytes is greater then the size of the file, the EOF will be encountered unexpectedly and EIOError will be raised.\\n- Typed File I/O -\\nTyped file I/O is very useful when reading and writing structures. An Address List is quiet easy to write when using this type of I/O. The same file procedures are used with some subtle differences. Bite below in the blockread and blockwrite procedures that the bytes to read or write are 1. Also note that the reset procedure is not called with a buffer size. When performing Typed File I/O the size of the type definition is the buffer size. In the BlockRead() and BlockWrite() procedures I elected to read one record. Had I declared a very large buffer of type tAddressBook of say 500 records, I could have set bytes to read as SizeOf(Buffer) thereby reading a minimum of 500 records.\\n(This version holds the entire contents in memory.)\\nELENA 3.4 :\\nRead in the whole file and write the contents to a new file.\\nBuilt in function:\\nUsing an intermediate variable for the input file content is not ideomatic in functional programming. Nevertheless...\\nHolds entire file content in memory:\\nA bit longer, but only holds a small amount of data in memory. If opening the file for writing fails, we want to clean up the file that's open for reading:\\nPossibly cheating:\\nForth traditionally has not had any file handling capabilities, preferring instead to operate on a disk image block by block. Most modern Forth systems however run under an existing operating system and provide methods for disk access.\\nNote the use of \""2 pick\"" to get the input file handle and \""3 pick\"" to get the output file handle. Local or global variables could have been used, but in this implementation simple stack manipulation was chosen. Also, only maxstring bytes are copied at a time, and the global \""pad\"" memory area is used to hold the data. For faster copies, allocating a larger buffer could be advantageous.\\nAlso, abort\"" can be used instead of throw if desired.\\nA good practice is to ask the user the file name he wants to create like in this short example\\nIt uses the access=\""stream\"" which is defined in Fortran 2003 standard and should allow to \""copy\"" also binary data easily.\\n","import shutil\\nshutil.copyfile('input.txt', 'output.txt')"
"Python","File_input/output","Create a file called   \""output.txt\"",   and place in it the contents of the file   \""input.txt\"",   via an intermediate variable.\\nIn other words, your program will demonstrate:\\n\\nOneliners that skip the intermediate variable are of secondary interest — operating systems have copy commands for that.\\n\\nAssuming everything is fine and no error handling is required, this solution is sufficient:\\nExpanded with proper error handling and reporting it reads:\\nThe following example reads and writes each file one character at a time. (You should of course add error reporting as in the example above.)\\nThe following solution uses stream I/O. Any file of Ada.Text_IO can be used to obtain a corresponding stream. Reading and writing streams is more efficient than reading text files directly, because it skips formatting.\\nMethod 1: the input file can be processed line by line.\\nMethod 2: the input file can be read at once if it is less than 1 GB.\\nMethod 3: the file can be copied without I/O.\\nBinary I/O is possible with this library from Laszlo.\\n(This does not handle properly binary files)\\nThe spirit of Babel is to manipulate things on the stack whenever feasible. In this example,\\nI showed how to save it into a symbolic variable (foo) but this step would not be necessary\\nfor many simple file-processing tasks, such as splitting on newlines or spaces.\\nAlso note that the >>> (slurp) and <<< (spit) operators only handle \""small\"" files - the limit is\\nconfigurable but the default limit is 100MB. If you want to open very large files or if you need\\nto perform a lot of interactive file I/O, Babel provides operators that wrap the C standard library\\nfopen()/fclose() functions.\\nThis is only meant to copy a sequential text file. It is very unlikely that this works copying a random access text file.\\nor\\nor\\nThere may be other techniques too.\\nBBC BASIC for Windows has a file copy command:\\nAlternatively the copy can be done explicitly:\\nThis linear program tries to open \""input.txt\"" as text file (or aborts).\\nIt then writes the content in text mode (i.e. minus trailing spaces) to \""output.txt\"" (or aborts).\\nA couple of remarks on the preceding example:\\nIt uses fgetc to read one character at a time. Each character is visited, even though there's nothing to do with it. Copying bigger blocks of data is much more efficient.\\nThe following example addresses those issues. To avoid buffered I/O, it uses open(), read(), write() and close(), which are part of POSIX.\\nThe long way:\\nThe short way:\\nSimpler version:\\nUsing istream- and ostream- iterators:\\nEven simpler way:\\nDefine a function that copies the content from one file to another.\\nApply this function to the world to copy a file.\\nFlags used for Micro Focus COBOL:\\nBy lines:\\nBy arbitrary blocks and for possibly-binary files:\\nIf you're on an odd platform which actually stores text/binary/... type information for files and your CL implementation will use this information, then in should be opened with :element-type :default.\\nvery plainly, with an intermediate variable:\\nvia an intermediate buffer variable:\\nCopy the content from one file to another (exceptions are handled by Tango):\\nOr a shorter example without explicitly closing the output file:\\nDelphi supports both typed and untyped as well as a textfile type for files. Delphi provides a default 128 byte buffer for text files. This may be enlarged via a call to SetTextBuff(Var F: Text; Var Buf [Size : integer]) procedure. All other files have no buffer at all and it is the programmers option to do buffering.\\nThe following file I/O procedures have existed since Turbo Pascal V-3.\\nFiles are opened using:\\nAssignFile(f,{fully qualified path and file name})\\nAssigns the file name to the file structure in preparation for opening.\\nReset(f)\\nOpens and existing file. If it does not exist EIOError is raised.\\nRewrite(f)\\nCreates a new file and opens it for I/O. If the files exists is is overwritten.\\nDelphi implemented Streams of which a variant is TFileStream and are very closely related to the Windows API for file handling.\\n- Text File I/O -\\n\\n- Untyped File I/O -\\nThis is perhaps one of the most powerful I/O functions built into Pascal. This will allow you to open and read a file of ANY type, regardless of structure, size or content. Note the usage of Reset(). This is using the optional size parameter that instructs the record size of file I/O. This could have been called with SizeOf(Buff) as the optional parameter but that would have limited flexibility. Calling it with a size of ONE byte allows you to adjust the buffer size on the fly, as conditions warrant. Also note the use of the BytesRead parameter. When included in the BlockRead() function it will return the number of bytes actually read. If this is not included, then if your directive to read n bytes is greater then the size of the file, the EOF will be encountered unexpectedly and EIOError will be raised.\\n- Typed File I/O -\\nTyped file I/O is very useful when reading and writing structures. An Address List is quiet easy to write when using this type of I/O. The same file procedures are used with some subtle differences. Bite below in the blockread and blockwrite procedures that the bytes to read or write are 1. Also note that the reset procedure is not called with a buffer size. When performing Typed File I/O the size of the type definition is the buffer size. In the BlockRead() and BlockWrite() procedures I elected to read one record. Had I declared a very large buffer of type tAddressBook of say 500 records, I could have set bytes to read as SizeOf(Buffer) thereby reading a minimum of 500 records.\\n(This version holds the entire contents in memory.)\\nELENA 3.4 :\\nRead in the whole file and write the contents to a new file.\\nBuilt in function:\\nUsing an intermediate variable for the input file content is not ideomatic in functional programming. Nevertheless...\\nHolds entire file content in memory:\\nA bit longer, but only holds a small amount of data in memory. If opening the file for writing fails, we want to clean up the file that's open for reading:\\nPossibly cheating:\\nForth traditionally has not had any file handling capabilities, preferring instead to operate on a disk image block by block. Most modern Forth systems however run under an existing operating system and provide methods for disk access.\\nNote the use of \""2 pick\"" to get the input file handle and \""3 pick\"" to get the output file handle. Local or global variables could have been used, but in this implementation simple stack manipulation was chosen. Also, only maxstring bytes are copied at a time, and the global \""pad\"" memory area is used to hold the data. For faster copies, allocating a larger buffer could be advantageous.\\nAlso, abort\"" can be used instead of throw if desired.\\nA good practice is to ask the user the file name he wants to create like in this short example\\nIt uses the access=\""stream\"" which is defined in Fortran 2003 standard and should allow to \""copy\"" also binary data easily.\\n","infile = open('input.txt', 'r')\\noutfile = open('output.txt', 'w')\\nfor line in infile:\\n   outfile.write(line)\\noutfile.close()\\ninfile.close()"
"Python","File_input/output","Create a file called   \""output.txt\"",   and place in it the contents of the file   \""input.txt\"",   via an intermediate variable.\\nIn other words, your program will demonstrate:\\n\\nOneliners that skip the intermediate variable are of secondary interest — operating systems have copy commands for that.\\n\\nAssuming everything is fine and no error handling is required, this solution is sufficient:\\nExpanded with proper error handling and reporting it reads:\\nThe following example reads and writes each file one character at a time. (You should of course add error reporting as in the example above.)\\nThe following solution uses stream I/O. Any file of Ada.Text_IO can be used to obtain a corresponding stream. Reading and writing streams is more efficient than reading text files directly, because it skips formatting.\\nMethod 1: the input file can be processed line by line.\\nMethod 2: the input file can be read at once if it is less than 1 GB.\\nMethod 3: the file can be copied without I/O.\\nBinary I/O is possible with this library from Laszlo.\\n(This does not handle properly binary files)\\nThe spirit of Babel is to manipulate things on the stack whenever feasible. In this example,\\nI showed how to save it into a symbolic variable (foo) but this step would not be necessary\\nfor many simple file-processing tasks, such as splitting on newlines or spaces.\\nAlso note that the >>> (slurp) and <<< (spit) operators only handle \""small\"" files - the limit is\\nconfigurable but the default limit is 100MB. If you want to open very large files or if you need\\nto perform a lot of interactive file I/O, Babel provides operators that wrap the C standard library\\nfopen()/fclose() functions.\\nThis is only meant to copy a sequential text file. It is very unlikely that this works copying a random access text file.\\nor\\nor\\nThere may be other techniques too.\\nBBC BASIC for Windows has a file copy command:\\nAlternatively the copy can be done explicitly:\\nThis linear program tries to open \""input.txt\"" as text file (or aborts).\\nIt then writes the content in text mode (i.e. minus trailing spaces) to \""output.txt\"" (or aborts).\\nA couple of remarks on the preceding example:\\nIt uses fgetc to read one character at a time. Each character is visited, even though there's nothing to do with it. Copying bigger blocks of data is much more efficient.\\nThe following example addresses those issues. To avoid buffered I/O, it uses open(), read(), write() and close(), which are part of POSIX.\\nThe long way:\\nThe short way:\\nSimpler version:\\nUsing istream- and ostream- iterators:\\nEven simpler way:\\nDefine a function that copies the content from one file to another.\\nApply this function to the world to copy a file.\\nFlags used for Micro Focus COBOL:\\nBy lines:\\nBy arbitrary blocks and for possibly-binary files:\\nIf you're on an odd platform which actually stores text/binary/... type information for files and your CL implementation will use this information, then in should be opened with :element-type :default.\\nvery plainly, with an intermediate variable:\\nvia an intermediate buffer variable:\\nCopy the content from one file to another (exceptions are handled by Tango):\\nOr a shorter example without explicitly closing the output file:\\nDelphi supports both typed and untyped as well as a textfile type for files. Delphi provides a default 128 byte buffer for text files. This may be enlarged via a call to SetTextBuff(Var F: Text; Var Buf [Size : integer]) procedure. All other files have no buffer at all and it is the programmers option to do buffering.\\nThe following file I/O procedures have existed since Turbo Pascal V-3.\\nFiles are opened using:\\nAssignFile(f,{fully qualified path and file name})\\nAssigns the file name to the file structure in preparation for opening.\\nReset(f)\\nOpens and existing file. If it does not exist EIOError is raised.\\nRewrite(f)\\nCreates a new file and opens it for I/O. If the files exists is is overwritten.\\nDelphi implemented Streams of which a variant is TFileStream and are very closely related to the Windows API for file handling.\\n- Text File I/O -\\n\\n- Untyped File I/O -\\nThis is perhaps one of the most powerful I/O functions built into Pascal. This will allow you to open and read a file of ANY type, regardless of structure, size or content. Note the usage of Reset(). This is using the optional size parameter that instructs the record size of file I/O. This could have been called with SizeOf(Buff) as the optional parameter but that would have limited flexibility. Calling it with a size of ONE byte allows you to adjust the buffer size on the fly, as conditions warrant. Also note the use of the BytesRead parameter. When included in the BlockRead() function it will return the number of bytes actually read. If this is not included, then if your directive to read n bytes is greater then the size of the file, the EOF will be encountered unexpectedly and EIOError will be raised.\\n- Typed File I/O -\\nTyped file I/O is very useful when reading and writing structures. An Address List is quiet easy to write when using this type of I/O. The same file procedures are used with some subtle differences. Bite below in the blockread and blockwrite procedures that the bytes to read or write are 1. Also note that the reset procedure is not called with a buffer size. When performing Typed File I/O the size of the type definition is the buffer size. In the BlockRead() and BlockWrite() procedures I elected to read one record. Had I declared a very large buffer of type tAddressBook of say 500 records, I could have set bytes to read as SizeOf(Buffer) thereby reading a minimum of 500 records.\\n(This version holds the entire contents in memory.)\\nELENA 3.4 :\\nRead in the whole file and write the contents to a new file.\\nBuilt in function:\\nUsing an intermediate variable for the input file content is not ideomatic in functional programming. Nevertheless...\\nHolds entire file content in memory:\\nA bit longer, but only holds a small amount of data in memory. If opening the file for writing fails, we want to clean up the file that's open for reading:\\nPossibly cheating:\\nForth traditionally has not had any file handling capabilities, preferring instead to operate on a disk image block by block. Most modern Forth systems however run under an existing operating system and provide methods for disk access.\\nNote the use of \""2 pick\"" to get the input file handle and \""3 pick\"" to get the output file handle. Local or global variables could have been used, but in this implementation simple stack manipulation was chosen. Also, only maxstring bytes are copied at a time, and the global \""pad\"" memory area is used to hold the data. For faster copies, allocating a larger buffer could be advantageous.\\nAlso, abort\"" can be used instead of throw if desired.\\nA good practice is to ask the user the file name he wants to create like in this short example\\nIt uses the access=\""stream\"" which is defined in Fortran 2003 standard and should allow to \""copy\"" also binary data easily.\\n","import sys\\ntry:\\n    infile = open('input.txt', 'r')\\nexcept IOError:\\n    print >> sys.stderr, \""Unable to open input.txt for input\""\\n    sys.exit(1)\\ntry:\\n    outfile = open('output.txt', 'w')\\nexcept IOError:\\n    print >> sys.stderr, \""Unable to open output.txt for output\""\\n    sys.exit(1)\\ntry:  # for finally\\n    try: # for I/O\\n        for line in infile:\\n            outfile.write(line)\\n    except IOError, e:\\n        print >> sys.stderr, \""Some I/O Error occurred (reading from input.txt or writing to output.txt)\""\\nfinally:\\n    infile.close()\\n    outfile.close()"
"Python","File_input/output","Create a file called   \""output.txt\"",   and place in it the contents of the file   \""input.txt\"",   via an intermediate variable.\\nIn other words, your program will demonstrate:\\n\\nOneliners that skip the intermediate variable are of secondary interest — operating systems have copy commands for that.\\n\\nAssuming everything is fine and no error handling is required, this solution is sufficient:\\nExpanded with proper error handling and reporting it reads:\\nThe following example reads and writes each file one character at a time. (You should of course add error reporting as in the example above.)\\nThe following solution uses stream I/O. Any file of Ada.Text_IO can be used to obtain a corresponding stream. Reading and writing streams is more efficient than reading text files directly, because it skips formatting.\\nMethod 1: the input file can be processed line by line.\\nMethod 2: the input file can be read at once if it is less than 1 GB.\\nMethod 3: the file can be copied without I/O.\\nBinary I/O is possible with this library from Laszlo.\\n(This does not handle properly binary files)\\nThe spirit of Babel is to manipulate things on the stack whenever feasible. In this example,\\nI showed how to save it into a symbolic variable (foo) but this step would not be necessary\\nfor many simple file-processing tasks, such as splitting on newlines or spaces.\\nAlso note that the >>> (slurp) and <<< (spit) operators only handle \""small\"" files - the limit is\\nconfigurable but the default limit is 100MB. If you want to open very large files or if you need\\nto perform a lot of interactive file I/O, Babel provides operators that wrap the C standard library\\nfopen()/fclose() functions.\\nThis is only meant to copy a sequential text file. It is very unlikely that this works copying a random access text file.\\nor\\nor\\nThere may be other techniques too.\\nBBC BASIC for Windows has a file copy command:\\nAlternatively the copy can be done explicitly:\\nThis linear program tries to open \""input.txt\"" as text file (or aborts).\\nIt then writes the content in text mode (i.e. minus trailing spaces) to \""output.txt\"" (or aborts).\\nA couple of remarks on the preceding example:\\nIt uses fgetc to read one character at a time. Each character is visited, even though there's nothing to do with it. Copying bigger blocks of data is much more efficient.\\nThe following example addresses those issues. To avoid buffered I/O, it uses open(), read(), write() and close(), which are part of POSIX.\\nThe long way:\\nThe short way:\\nSimpler version:\\nUsing istream- and ostream- iterators:\\nEven simpler way:\\nDefine a function that copies the content from one file to another.\\nApply this function to the world to copy a file.\\nFlags used for Micro Focus COBOL:\\nBy lines:\\nBy arbitrary blocks and for possibly-binary files:\\nIf you're on an odd platform which actually stores text/binary/... type information for files and your CL implementation will use this information, then in should be opened with :element-type :default.\\nvery plainly, with an intermediate variable:\\nvia an intermediate buffer variable:\\nCopy the content from one file to another (exceptions are handled by Tango):\\nOr a shorter example without explicitly closing the output file:\\nDelphi supports both typed and untyped as well as a textfile type for files. Delphi provides a default 128 byte buffer for text files. This may be enlarged via a call to SetTextBuff(Var F: Text; Var Buf [Size : integer]) procedure. All other files have no buffer at all and it is the programmers option to do buffering.\\nThe following file I/O procedures have existed since Turbo Pascal V-3.\\nFiles are opened using:\\nAssignFile(f,{fully qualified path and file name})\\nAssigns the file name to the file structure in preparation for opening.\\nReset(f)\\nOpens and existing file. If it does not exist EIOError is raised.\\nRewrite(f)\\nCreates a new file and opens it for I/O. If the files exists is is overwritten.\\nDelphi implemented Streams of which a variant is TFileStream and are very closely related to the Windows API for file handling.\\n- Text File I/O -\\n\\n- Untyped File I/O -\\nThis is perhaps one of the most powerful I/O functions built into Pascal. This will allow you to open and read a file of ANY type, regardless of structure, size or content. Note the usage of Reset(). This is using the optional size parameter that instructs the record size of file I/O. This could have been called with SizeOf(Buff) as the optional parameter but that would have limited flexibility. Calling it with a size of ONE byte allows you to adjust the buffer size on the fly, as conditions warrant. Also note the use of the BytesRead parameter. When included in the BlockRead() function it will return the number of bytes actually read. If this is not included, then if your directive to read n bytes is greater then the size of the file, the EOF will be encountered unexpectedly and EIOError will be raised.\\n- Typed File I/O -\\nTyped file I/O is very useful when reading and writing structures. An Address List is quiet easy to write when using this type of I/O. The same file procedures are used with some subtle differences. Bite below in the blockread and blockwrite procedures that the bytes to read or write are 1. Also note that the reset procedure is not called with a buffer size. When performing Typed File I/O the size of the type definition is the buffer size. In the BlockRead() and BlockWrite() procedures I elected to read one record. Had I declared a very large buffer of type tAddressBook of say 500 records, I could have set bytes to read as SizeOf(Buffer) thereby reading a minimum of 500 records.\\n(This version holds the entire contents in memory.)\\nELENA 3.4 :\\nRead in the whole file and write the contents to a new file.\\nBuilt in function:\\nUsing an intermediate variable for the input file content is not ideomatic in functional programming. Nevertheless...\\nHolds entire file content in memory:\\nA bit longer, but only holds a small amount of data in memory. If opening the file for writing fails, we want to clean up the file that's open for reading:\\nPossibly cheating:\\nForth traditionally has not had any file handling capabilities, preferring instead to operate on a disk image block by block. Most modern Forth systems however run under an existing operating system and provide methods for disk access.\\nNote the use of \""2 pick\"" to get the input file handle and \""3 pick\"" to get the output file handle. Local or global variables could have been used, but in this implementation simple stack manipulation was chosen. Also, only maxstring bytes are copied at a time, and the global \""pad\"" memory area is used to hold the data. For faster copies, allocating a larger buffer could be advantageous.\\nAlso, abort\"" can be used instead of throw if desired.\\nA good practice is to ask the user the file name he wants to create like in this short example\\nIt uses the access=\""stream\"" which is defined in Fortran 2003 standard and should allow to \""copy\"" also binary data easily.\\n","import sys\\ntry:\\n    with open('input.txt') as infile:\\n        with open('output.txt', 'w') as outfile:\\n            for line in infile:\\n                outfile.write(line)\\nexcept IOError:\\n    print >> sys.stderr, \""Some I/O Error occurred\""\\n    sys.exit(1)"
"Python","File_modification_time","Get and set the modification time of a file.\\n\\nAda does not allow you to change the date of a file but you can definitely read it:\\nDefinition of the PROC is lifted from the Algol68 Genie documentation.\\n","import os\\n\\n#Get modification time:\\nmodtime = os.path.getmtime('filename')\\n\\n#Set the access and modification times:\\nos.utime('path', (actime, mtime))\\n\\n#Set just the modification time:\\nos.utime('path', (os.path.getatime('path'), mtime))\\n\\n#Set the access and modification times to the current time:\\nos.utime('path', None)"
"Python","Filter","Select certain elements from an Array into a new Array in a generic way.\\n\\nTo demonstrate, select all even numbers from an Array.\\nAs an option, give a second solution which filters destructively,\\nby modifying the original Array rather than creating a new Array.\\n\\nActionscript 3\\nHere is a non-recursive solution:\\n","values = range(10)\\nevens = [x for x in values if not x & 1]\\nievens = (x for x in values if not x & 1) # lazy\\n# alternately but less idiomatic:\\nevens = filter(lambda x: not x & 1, values)"
"Python","Filter","Select certain elements from an Array into a new Array in a generic way.\\n\\nTo demonstrate, select all even numbers from an Array.\\nAs an option, give a second solution which filters destructively,\\nby modifying the original Array rather than creating a new Array.\\n\\nActionscript 3\\nHere is a non-recursive solution:\\n","values = range(10)\\nevens = values[::2]"
"Python","Filter","Select certain elements from an Array into a new Array in a generic way.\\n\\nTo demonstrate, select all even numbers from an Array.\\nAs an option, give a second solution which filters destructively,\\nby modifying the original Array rather than creating a new Array.\\n\\nActionscript 3\\nHere is a non-recursive solution:\\n","values = range(10)\\nvalues[::2] = [11,13,15,17,19]\\nprint values\\n11, 1, 13, 3, 15, 5, 17, 7, 19, 9"
"Python","Find_common_directory_path","Create a routine that, given a set of strings representing directory paths and a single character directory separator, will return a string representing that part of the directory tree that is common to all the directories.\\nTest your routine using the forward slash '/' character as the directory separator and the following three strings as input paths:\\nNote: The resultant path should be the valid directory '/home/user1/tmp' and not the longest common string '/home/user1/tmp/cove'.\\nIf your language has a routine that performs this function (even if it does not have a changeable separator character), then mention it as part of the task.\\n\\n\\nOutput:\\nOutput:\\nMessage box shows:\\nPrints /home/user1/tmp.\\nThis version is a little smarter than the one above... but not much. This version could be turned into an actual useful utility by changing it to compare command-line parameters, instead of built-in data.\\nAlso, under FreeBASIC, the pathSep arg to commonPath$ could be made optional, or even system-dependent.\\n",">>> import os\\n>>> os.path.commonprefix(['/home/user1/tmp/coverage/test', \\n                          '/home/user1/tmp/covert/operator', '/home/user1/tmp/coven/members'])\\n'/home/user1/tmp/cove'"
"Python","Find_common_directory_path","Create a routine that, given a set of strings representing directory paths and a single character directory separator, will return a string representing that part of the directory tree that is common to all the directories.\\nTest your routine using the forward slash '/' character as the directory separator and the following three strings as input paths:\\nNote: The resultant path should be the valid directory '/home/user1/tmp' and not the longest common string '/home/user1/tmp/cove'.\\nIf your language has a routine that performs this function (even if it does not have a changeable separator character), then mention it as part of the task.\\n\\n\\nOutput:\\nOutput:\\nMessage box shows:\\nPrints /home/user1/tmp.\\nThis version is a little smarter than the one above... but not much. This version could be turned into an actual useful utility by changing it to compare command-line parameters, instead of built-in data.\\nAlso, under FreeBASIC, the pathSep arg to commonPath$ could be made optional, or even system-dependent.\\n",">>> def commonprefix(args, sep='/'):\\n	return os.path.commonprefix(args).rpartition(sep)[0]\\n\\n>>> commonprefix(['/home/user1/tmp/coverage/test', \\n                  '/home/user1/tmp/covert/operator', '/home/user1/tmp/coven/members'])\\n'/home/user1/tmp'"
"Python","Find_common_directory_path","Create a routine that, given a set of strings representing directory paths and a single character directory separator, will return a string representing that part of the directory tree that is common to all the directories.\\nTest your routine using the forward slash '/' character as the directory separator and the following three strings as input paths:\\nNote: The resultant path should be the valid directory '/home/user1/tmp' and not the longest common string '/home/user1/tmp/cove'.\\nIf your language has a routine that performs this function (even if it does not have a changeable separator character), then mention it as part of the task.\\n\\n\\nOutput:\\nOutput:\\nMessage box shows:\\nPrints /home/user1/tmp.\\nThis version is a little smarter than the one above... but not much. This version could be turned into an actual useful utility by changing it to compare command-line parameters, instead of built-in data.\\nAlso, under FreeBASIC, the pathSep arg to commonPath$ could be made optional, or even system-dependent.\\n",">>> paths = ['/home/user1/tmp/coverage/test', '/home/user1/tmp/covert/operator', '/home/user1/tmp/coven/members']\\n>>> os.path.dirname(os.path.commonprefix(paths))\\n'/home/user1/tmp'"
"Python","Find_common_directory_path","Create a routine that, given a set of strings representing directory paths and a single character directory separator, will return a string representing that part of the directory tree that is common to all the directories.\\nTest your routine using the forward slash '/' character as the directory separator and the following three strings as input paths:\\nNote: The resultant path should be the valid directory '/home/user1/tmp' and not the longest common string '/home/user1/tmp/cove'.\\nIf your language has a routine that performs this function (even if it does not have a changeable separator character), then mention it as part of the task.\\n\\n\\nOutput:\\nOutput:\\nMessage box shows:\\nPrints /home/user1/tmp.\\nThis version is a little smarter than the one above... but not much. This version could be turned into an actual useful utility by changing it to compare command-line parameters, instead of built-in data.\\nAlso, under FreeBASIC, the pathSep arg to commonPath$ could be made optional, or even system-dependent.\\n",">>> from itertools import takewhile\\n>>> def allnamesequal(name):\\n	return all(n==name[0] for n in name[1:])\\n\\n>>> def commonprefix(paths, sep='/'):\\n	bydirectorylevels = zip(*[p.split(sep) for p in paths])\\n	return sep.join(x[0] for x in takewhile(allnamesequal, bydirectorylevels))\\n\\n>>> commonprefix(['/home/user1/tmp/coverage/test', \\n                  '/home/user1/tmp/covert/operator', '/home/user1/tmp/coven/members'])\\n'/home/user1/tmp'\\n>>> # And also\\n>>> commonprefix(['/home/user1/tmp', '/home/user1/tmp/coverage/test',\\n                  '/home/user1/tmp/covert/operator', '/home/user1/tmp/coven/members'])\\n'/home/user1/tmp'\\n>>> "
"Python","Find_duplicate_files","The program may be command-line or graphical, and duplicate content may be determined by direct comparison or by calculating a hash of the data. Specify which filesystems or operating systems your program works with if it has any filesystem- or OS-specific requirements. Identify hard links (filenames referencing the same content) in the output if applicable for the filesystem. For extra points detect when whole directory sub-trees are identical, or optionally remove or link identical files.\\n","from __future__ import print_function\\nimport os\\nimport hashlib\\nimport datetime\\n\\ndef FindDuplicateFiles(pth, minSize = 0, hashName = \""md5\""):\\n	knownFiles = {}\\n\\n	#Analyse files\\n	for root, dirs, files in os.walk(pth):\\n		for fina in files:\\n			fullFina = os.path.join(root, fina)\\n			isSymLink = os.path.islink(fullFina)\\n			if isSymLink:\\n				continue # Skip symlinks\\n			si = os.path.getsize(fullFina)\\n			if si < minSize:\\n				continue\\n			if si not in knownFiles:\\n				knownFiles[si] = {}\\n			h = hashlib.new(hashName)\\n			h.update(open(fullFina, \""rb\"").read())\\n			hashed = h.digest()\\n			if hashed in knownFiles[si]:\\n				fileRec = knownFiles[si][hashed]\\n				fileRec.append(fullFina)\\n			else:\\n				knownFiles[si][hashed] = [fullFina]\\n\\n	#Print result\\n	sizeList = list(knownFiles.keys())\\n	sizeList.sort(reverse=True)\\n	for si in sizeList:\\n		filesAtThisSize = knownFiles[si]\\n		for hashVal in filesAtThisSize:\\n			if len(filesAtThisSize[hashVal]) < 2:\\n				continue\\n			fullFinaLi = filesAtThisSize[hashVal]\\n			print (\""=======Duplicate=======\"")\\n			for fullFina in fullFinaLi:\\n				st = os.stat(fullFina)\\n				isHardLink = st.st_nlink > 1 \\n				infoStr = []\\n				if isHardLink:\\n					infoStr.append(\""(Hard linked)\"")\\n				fmtModTime = datetime.datetime.utcfromtimestamp(st.st_mtime).strftime('%Y-%m-%dT%H:%M:%SZ')\\n				print (fmtModTime, si, os.path.relpath(fullFina, pth), \"" \"".join(infoStr))\\n\\nif __name__==\""__main__\"":\\n\\n	FindDuplicateFiles('/home/tim/Dropbox', 1024*1024)\\n"
"Python","Find_first_and_last_set_bit_of_a_long_integer","Clarification: This task is asking for the position of two bits in the binary representation of a positive integer. Some parts of this task assume that this is the native representation in the language you are working in. Any part of this task which makes assumptions about native representation should be treated as a recommendation which is only relevant in some contexts. A bit is defined as the exponent in a binary polynomial -- an exponent corresponding to a power of 2 which has a non-zero multiplier in the summation sequence of powers of two which yields the desired positive integer, where the only allowed coefficients are 0 and 1.\\nDefine routines (or operators) lwb and upb that find the first and last set bit in a binary value. Implement using a binary search to find the location of the particular upper/lower bit.\\nAlso: Define the reverse routines (or operators) rlwb and rupb that find host's positive integers least- and most-significant set bit in a binary value expressed in LSB 0 bit numbering, i.e. indexed from the extreme right bit.\\nUse primarily bit operations, such as and, or, and bit shifting. Avoid additions, multiplications and especially avoid divisions.\\nTwo implementations:\\nTest cases:\\nAdditionally:\\nIn a particular language, there maybe (at least) two alternative approaches of calculating the required values:\\nIf any of these approaches are available, then also note the library or built-in name.\\nSee also:\\n(This task is not complete, the second part will be added later.)\\n","def msb(x):\\n    return x.bit_length() - 1\\n\\ndef lsb(x):\\n    return msb(x & -x)\\n\\nfor i in range(6):\\n    x = 42 ** i\\n    print(\""%10d MSB: %2d LSB: %2d\"" % (x, msb(x), lsb(x)))\\n\\nfor i in range(6):\\n    x = 1302 ** i\\n    print(\""%20d MSB: %2d LSB: %2d\"" % (x, msb(x), lsb(x)))"
"Python","Find_largest_left_truncatable_prime_in_a_given_base","A truncatable prime is one where all non-empty substrings that finish at the end of the number (right-substrings) are also primes when understood as numbers in a particular base. The largest such prime in a given (integer) base is therefore computable, provided the base is larger than 2.\\nLet's consider what happens in base 10. Obviously the right most digit must be prime, so in base 10 candidates are 2,3,5,7. Putting a digit in the range 1 to base-1 in front of each candidate must result in a prime. So 2 and 5, like the whale and the petunias in The Hitchhiker's Guide to the Galaxy, come into existence only to be extinguished before they have time to realize it, because 2 and 5 preceded by any digit in the range 1 to base-1 is not prime. Some numbers formed by preceding 3 or 7 by a digit in the range 1 to base-1 are prime. So 13,17,23,37,43,47,53,67,73,83,97 are candidates. Again, putting a digit in the range 1 to base-1 in front of each candidate must be a prime. Repeating until there are no larger candidates finds the largest left truncatable prime.\\nLet's work base 3 by hand:\\n0 and 1 are not prime so the last digit must be 2. 123 = 510 which is prime, 223 = 810 which is not so 123 is the only candidate. 1123 = 1410 which is not prime, 2123 = 2310 which is, so 2123 is the only candidate. 12123 = 5010 which is not prime, 22123 = 7710 which also is not prime. So there are no more candidates, therefore 23 is the largest left truncatable prime in base 3.\\nThe task is to reconstruct as much, and possibly more, of the table in the OEIS as you are able.\\nRelated Tasks:\\n\\nUses the Huge Integer Math & Encryption library from http://devotechs.com/\\nOutput:\\n","import random\\n\\ndef is_probable_prime(n,k):\\n    #this uses the miller-rabin primality test found from rosetta code\\n    if n==0 or n==1:\\n        return False\\n    if n==2:\\n        return True\\n    if n % 2 == 0:\\n        return False\\n    s = 0\\n    d = n-1\\n\\n    while True:\\n        quotient, remainder = divmod(d, 2)\\n        if remainder == 1:\\n            break\\n        s += 1\\n        d = quotient\\n\\n    def try_composite(a):\\n        if pow(a, d, n) == 1:\\n            return False\\n        for i in range(s):\\n            if pow(a, 2**i * d, n) == n-1:\\n                return False\\n        return True # n is definitely composite\\n \\n    for i in range(k):\\n        a = random.randrange(2, n)\\n        if try_composite(a):\\n            return False\\n \\n    return True # no base tested showed n as composite    \\n    \\n    \\ndef largest_left_truncatable_prime(base):    \\n    radix = 0\\n    candidates = [0]\\n    while True:\\n        new_candidates=[]\\n        multiplier = base**radix\\n        for i in range(1,base):\\n            new_candidates += [x+i*multiplier for x in candidates if is_probable_prime(x+i*multiplier,30)]\\n        if len(new_candidates)==0:\\n            return max(candidates)\\n        candidates = new_candidates\\n        radix += 1\\n\\nfor b in range(3,24):\\n    print(\""%d:%d\\n\"" % (b,largest_left_truncatable_prime(b)))\\n"
"Python","Find_limit_of_recursion","Find the limit of recursion.\\n\\n","import sys\\nprint(sys.getrecursionlimit())"
"Python","Find_limit_of_recursion","Find the limit of recursion.\\n\\n","import sys\\nsys.setrecursionlimit(12345)"
"Python","Find_limit_of_recursion","Find the limit of recursion.\\n\\n","def recurse(counter):\\n  print(counter)\\n  counter += 1\\n  recurse(counter)"
"Python","Find_limit_of_recursion","Find the limit of recursion.\\n\\n","File \""<stdin>\"", line 2, in recurse\\nRecursionError: maximum recursion depth exceeded while calling a Python object\\n996"
"Python","Find_palindromic_numbers_in_both_binary_and_ternary_bases","\\n\\nIt's permissible to assume the first two numbers and simply list them.\\n\\n\\n","from itertools import islice\\n\\ndigits = \""0123456789abcdefghijklmnopqrstuvwxyz\""\\n\\ndef baseN(num,b):\\n  if num == 0: return \""0\""\\n  result = \""\""\\n  while num != 0:\\n    num, d = divmod(num, b)\\n    result += digits[d]\\n  return result[::-1] # reverse\\n\\ndef pal2(num):\\n    if num == 0 or num == 1: return True\\n    based = bin(num)[2:]\\n    return based == based[::-1]\\n\\ndef pal_23():\\n    yield 0\\n    yield 1\\n    n = 1\\n    while True:\\n        n += 1\\n        b = baseN(n, 3)\\n        revb = b[::-1]\\n        #if len(b) > 12: break\\n        for trial in ('{0}{1}'.format(b, revb), '{0}0{1}'.format(b, revb),\\n                      '{0}1{1}'.format(b, revb), '{0}2{1}'.format(b, revb)):\\n            t = int(trial, 3)\\n            if pal2(t):\\n                yield t\\n\\nfor pal23 in islice(pal_23(), 6):\\n    print(pal23, baseN(pal23, 3), baseN(pal23, 2))"
"Python","Find_palindromic_numbers_in_both_binary_and_ternary_bases","\\n\\nIt's permissible to assume the first two numbers and simply list them.\\n\\n\\n","from functools import (reduce)\\nfrom itertools import (islice)\\n\\n\\n# palinBoth :: Generator [Int]\\ndef palinBoth():\\n    yield 0\\n    yield 1\\n    n = 2\\n    while(True):\\n        v = until(isBoth)(succ)(n)\\n        yield nthPal(v)\\n        n = succ(v)\\n\\n\\n# isBoth :: Int -> Bool\\ndef isBoth(n):\\n    s = showBase3(n)\\n    b = bin(int(s + '1' + s[::-1], 3))[2:]\\n    return b == b[::-1]\\n\\n\\n# nthPal :: Int -> Int\\ndef nthPal(n):\\n    s = showBase3(n)\\n    return int(s + '1' + s[::-1], 3)\\n\\n\\n# GENERIC -------------------------------------------------\\n\\n# justifyLeft :: Int -> Char -> String -> String\\ndef justifyLeft(n):\\n    return lambda cFiller: lambda a: (\\n        (str(a) + (n * cFiller))[:n]\\n    )\\n\\n\\n# maximumBy :: (a -> a -> a) -> [a] -> a\\ndef maximumBy(f):\\n    def go(x, y):\\n        return y if f(y) > f(x) else x\\n    return lambda xs: reduce(go, xs[1:], xs[0])\\n\\n\\n# showBase3 :: Int -> String\\ndef showBase3(n):\\n    return showIntAtBase(3)(\\n        lambda i: '012'[i]\\n    )(n)('')\\n\\n\\n# showIntAtBase :: Int -> (Int -> Char) -> Int -> String -> String\\ndef showIntAtBase(base):\\n    def wrap(toChr, n, rs):\\n        def go(nd, r):\\n            (n, d) = nd\\n            r_ = toChr(d) + r\\n            return go(divmod(n, base), r_) if 0 != n else r_\\n        return 'unsupported base' if 1 >= base else (\\n            'negative number' if 0 > n else (\\n                go(divmod(n, base), rs))\\n        )\\n    return lambda toChr: lambda n: lambda rs: (\\n        wrap(toChr, n, rs)\\n    )\\n\\n\\n# succ :: Int -> Int\\ndef succ(x):\\n    return 1 + x\\n\\n\\n# take :: Int -> [a] -> [a]\\n# take :: Int -> String -> String\\ndef take(n):\\n    return lambda xs: (\\n        xs[0:n]\\n        if isinstance(xs, list)\\n        else list(islice(xs, n))\\n    )\\n\\n\\n# transpose :: [[a]] -> [[a]]\\ndef transpose(xs):\\n    return list(map(list, zip(*xs)))\\n\\n\\n# unlines :: [String] -> String\\ndef unlines(xs):\\n    return '\\n'.join(xs)\\n\\n\\n# unwords :: [String] -> String\\ndef unwords(xs):\\n    return ' '.join(xs)\\n\\n\\n# until :: (a -> Bool) -> (a -> a) -> a -> a\\ndef until(p):\\n    def go(f, x):\\n        v = x\\n        while not p(v):\\n            v = f(v)\\n        return v\\n    return lambda f: lambda x: go(f, x)\\n\\n\\n# TEST ----------------------------------------------------\\nif __name__ == '__main__':\\n    rows = [['Decimal', 'Ternary', 'Binary']] + list(\\n        map(\\n            lambda n: [str(n), showBase3(n), bin(n)[2:]],\\n            take(6)(\\n                palinBoth()\\n            )\\n        )\\n    )\\n    cols = transpose(rows)\\n    widths = list(map(\\n        lambda xs: len(maximumBy(len)(xs)),\\n        cols\\n    ))\\n    print (\\n        unlines(\\n            map(\\n                unwords,\\n                transpose(\\n                    map(\\n                        lambda c: map(\\n                            lambda x: justifyLeft(widths[c[0]])(' ')(x),\\n                            c[1]\\n                        ),\\n                        enumerate(cols)\\n                    )\\n                )\\n            )\\n        )\\n    )"
"Python","Find_the_intersection_of_a_line_with_a_plane","Find the point of intersection for the infinite ray with direction (0,-1,-1) passing through position (0, 0, 10) with the infinite plane with a normal vector of (0, 0, 1) and which passes through [0, 0, 5].\\nStraightforward application of the intersection formula, prints usage on incorrect invocation.\\nInvocation and output:\\n","#!/bin/python\\nfrom __future__ import print_function\\nimport numpy as np\\n\\ndef LinePlaneCollision(planeNormal, planePoint, rayDirection, rayPoint, epsilon=1e-6):\\n\\n	ndotu = planeNormal.dot(rayDirection)\\n	if abs(ndotu) < epsilon:\\n		raise RuntimeError(\""no intersection or line is within plane\"")\\n\\n	w = rayPoint - planePoint\\n	si = -planeNormal.dot(w) / ndotu\\n	Psi = w + si * rayDirection + planePoint\\n	return Psi\\n\\n\\nif __name__==\""__main__\"":\\n	#Define plane\\n	planeNormal = np.array([0, 0, 1])\\n	planePoint = np.array([0, 0, 5]) #Any point on the plane\\n\\n	#Define ray\\n	rayDirection = np.array([0, -1, -1])\\n	rayPoint = np.array([0, 0, 10]) #Any point along the ray\\n\\n	Psi = LinePlaneCollision(planeNormal, planePoint, rayDirection, rayPoint)\\n	print (\""intersection at\"", Psi)"
"Python","Find_the_intersection_of_two_lines","\\nFind the point of intersection of two lines in 2D.\\n\\nThe 1st line passes though    (4,0)    and    (6,10) .\\nThe 2nd line passes though    (0,3)    and    (10,7) .\\n\\nUsing \""school maths\"".\\n","from __future__ import print_function\\nfrom shapely.geometry import LineString\\n\\nif __name__==\""__main__\"":\\n	line1 = LineString([(4.0,0.0), (6.0,10.0)])\\n	line2 = LineString([(0.0,3.0), (10.0,7.0)])\\n	print (line1.intersection(line2))"
"Python","Find_the_last_Sunday_of_each_month","Write a program or a script that returns the last Sundays of each month of a given year. The year may be given through any simple input method in your language (command line, std in, etc).\\nExample of an expected output:\\n\\n\\nThe program uses one ASSIST macro (XPRNT) to keep the code as short as possible.\\n","\\nimport sys\\nimport calendar\\n\\nyear = 2013\\nif len(sys.argv) > 1:\\n    try:\\n        year = int(sys.argv[-1])\\n    except ValueError:\\n        pass\\n\\nfor month in range(1, 13):\\n    last_sunday = max(week[-1] for week in calendar.monthcalendar(year, month))\\n    print('{}-{}-{:2}'.format(year, calendar.month_abbr[month], last_sunday))\\n"
"Python","Find_the_missing_permutation","Listed above are all of the permutations of the symbols   A,   B,   C,   and   D,   except   for one permutation that's   not   listed.\\n\\nFind that missing permutation.\\n\\n\\n\\nVery compact version, thanks to the clever Perl 6 \""xor\"" algorithm.\\n","from itertools import permutations\\n\\ngiven = '''ABCD CABD ACDB DACB BCDA ACBD ADCB CDAB DABC BCAD CADB CDBA\\n           CBAD ABDC ADBC BDCA DCBA BACD BADC BDAC CBDA DBCA DCAB'''.split()\\n\\nallPerms = [''.join(x) for x in permutations(given[0])]\\n\\nmissing = list(set(allPerms) - set(given)) # ['DBAC']"
"Python","Find_the_missing_permutation","Listed above are all of the permutations of the symbols   A,   B,   C,   and   D,   except   for one permutation that's   not   listed.\\n\\nFind that missing permutation.\\n\\n\\n\\nVery compact version, thanks to the clever Perl 6 \""xor\"" algorithm.\\n","\\ndef missing_permutation(arr):\\n  \""Find the missing permutation in an array of N! - 1 permutations.\""\\n  \\n  # We won't validate every precondition, but we do have some basic\\n  # guards.\\n  if len(arr) == 0: raise Exception(\""Need more data\"")\\n  if len(arr) == 1:\\n      return [arr[0][1] + arr[0][0]]\\n  \\n  # Now we know that for each position in the string, elements should appear\\n  # an even number of times (N-1 >= 2).  We can use a set to detect the element appearing\\n  # an odd number of times.  Detect odd occurrences by toggling admission/expulsion\\n  # to and from the set for each value encountered.  At the end of each pass one element\\n  # will remain in the set.\\n  missing_permutation = ''\\n  for pos in range(len(arr[0])):\\n      s = set()\\n      for permutation in arr:\\n          c = permutation[pos]\\n          if c in s:\\n            s.remove(c)\\n          else:\\n            s.add(c)\\n      missing_permutation += list(s)[0]\\n  return missing_permutation\\n  \\ngiven = '''ABCD CABD ACDB DACB BCDA ACBD ADCB CDAB DABC BCAD CADB CDBA\\n           CBAD ABDC ADBC BDCA DCBA BACD BADC BDAC CBDA DBCA DCAB'''.split()\\n           \\nprint missing_permutation(given)\\n"
"Python","Find_the_missing_permutation","Listed above are all of the permutations of the symbols   A,   B,   C,   and   D,   except   for one permutation that's   not   listed.\\n\\nFind that missing permutation.\\n\\n\\n\\nVery compact version, thanks to the clever Perl 6 \""xor\"" algorithm.\\n",">>> from collections import Counter\\n>>> given = '''ABCD CABD ACDB DACB BCDA ACBD ADCB CDAB DABC BCAD CADB CDBA\\n           CBAD ABDC ADBC BDCA DCBA BACD BADC BDAC CBDA DBCA DCAB'''.split()\\n>>> ''.join(Counter(x).most_common()[-1][0] for x in zip(*given))\\n'DBAC'\\n>>> "
"Python","Find_the_missing_permutation","Listed above are all of the permutations of the symbols   A,   B,   C,   and   D,   except   for one permutation that's   not   listed.\\n\\nFind that missing permutation.\\n\\n\\n\\nVery compact version, thanks to the clever Perl 6 \""xor\"" algorithm.\\n",">>> from pprint import pprint as pp\\n>>> pp(list(zip(*given)), width=120)\\n[('A', 'C', 'A', 'D', 'B', 'A', 'A', 'C', 'D', 'B', 'C', 'C', 'C', 'A', 'A', 'B', 'D', 'B', 'B', 'B', 'C', 'D', 'D'),\\n ('B', 'A', 'C', 'A', 'C', 'C', 'D', 'D', 'A', 'C', 'A', 'D', 'B', 'B', 'D', 'D', 'C', 'A', 'A', 'D', 'B', 'B', 'C'),\\n ('C', 'B', 'D', 'C', 'D', 'B', 'C', 'A', 'B', 'A', 'D', 'B', 'A', 'D', 'B', 'C', 'B', 'C', 'D', 'A', 'D', 'C', 'A'),\\n ('D', 'D', 'B', 'B', 'A', 'D', 'B', 'B', 'C', 'D', 'B', 'A', 'D', 'C', 'C', 'A', 'A', 'D', 'C', 'C', 'A', 'A', 'B')]\\n>>> pp([Counter(x).most_common() for x in zip(*given)])\\n[[('C', 6), ('B', 6), ('A', 6), ('D', 5)],\\n [('D', 6), ('C', 6), ('A', 6), ('B', 5)],\\n [('D', 6), ('C', 6), ('B', 6), ('A', 5)],\\n [('D', 6), ('B', 6), ('A', 6), ('C', 5)]]\\n>>> pp([Counter(x).most_common()[-1] for x in zip(*given)])\\n[('D', 5), ('B', 5), ('A', 5), ('C', 5)]\\n>>> pp([Counter(x).most_common()[-1][0] for x in zip(*given)])\\n['D', 'B', 'A', 'C']\\n>>> ''.join([Counter(x).most_common()[-1][0] for x in zip(*given)])\\n'DBAC'\\n>>> "
"Python","First-class_functions","A language has first-class functions if it can do each of the following without recursively invoking a compiler or interpreter or otherwise metaprogramming:\\n\\n\\nWrite a program to create an ordered collection A of functions of a real number. At least one function should be built-in and at least one should be user-defined; try using the sine, cosine, and cubing functions. Fill another collection B with the inverse of each function in A. Implement function composition as in Functional Composition. Finally, demonstrate that the result of applying the composition of each function in A and its inverse in B to a value, is the original value. (Within the limits of computational accuracy).\\n(A solution need not actually call the collections \""A\"" and \""B\"". These names are only used in the preceding paragraph for clarity.)\\n\\nFirst-class Numbers\\n\\nOutput:\\nEven if the example below solves the task, there are some limitations to how dynamically you can create, store and use functions in Ada, so it is debatable if Ada really has first class functions.\\nIt is bad style (but an explicit requirement in the task description) to put the functions and their inverses in separate arrays rather than keeping each pair in a record and then having an array of that record type.\\nNote: Returning PROC (REAL x)REAL: f1(f2(x)) from a function apparently\\nviolates standard ALGOL 68's scoping rules. ALGOL 68G warns about this during\\nparsing, and then - if run out of scope - rejects during runtime.\\nOutput:\\nAppleScript does not have built-in functions like sine or cosine.\\nPutting math libraries aside for the moment (we can always shell out to bash functions like bc), a deeper issue is that the architectural position of functions in the AppleScript type system is simply a little too incoherent and second class to facilitate really frictionless work with first-class functions. (This is clearly not what AppleScript was originally designed for).\\nIncoherent, in the sense that built-in functions and operators do not have the same place in the type system as user functions. The former are described as 'commands' in parser errors, and have to be wrapped in user handlers if they are to be used interchangeably with other functions.\\nSecond class, in the sense that user functions (or 'handlers' in the terminology of Apple's documentation), are properties of scripts. The scripts are autonomous first class objects, but the handlers are not. Functions which accept other functions as arguments will internally need to use an mReturn or mInject function which 'lifts' handlers into script object types. Functions which return functions will similarly have to return them embedded in such script objects.\\nOnce we have a function like mReturn, however, we can readily write higher order functions like map, zipWith and mCompose below.\\n",">>> # Some built in functions and their inverses\\n>>> from math import sin, cos, acos, asin\\n>>> # Add a user defined function and its inverse\\n>>> cube = lambda x: x * x * x\\n>>> croot = lambda x: x ** (1/3.0)\\n>>> # First class functions allow run-time creation of functions from functions\\n>>> # return function compose(f,g)(x) == f(g(x))\\n>>> compose = lambda f1, f2: ( lambda x: f1(f2(x)) )\\n>>> # first class functions should be able to be members of collection types\\n>>> funclist = [sin, cos, cube]\\n>>> funclisti = [asin, acos, croot]\\n>>> # Apply functions from lists as easily as integers\\n>>> [compose(inversef, f)(.5) for f, inversef in zip(funclist, funclisti)]\\n[0.5, 0.4999999999999999, 0.5]\\n>>>"
"Python","First-class_functions","A language has first-class functions if it can do each of the following without recursively invoking a compiler or interpreter or otherwise metaprogramming:\\n\\n\\nWrite a program to create an ordered collection A of functions of a real number. At least one function should be built-in and at least one should be user-defined; try using the sine, cosine, and cubing functions. Fill another collection B with the inverse of each function in A. Implement function composition as in Functional Composition. Finally, demonstrate that the result of applying the composition of each function in A and its inverse in B to a value, is the original value. (Within the limits of computational accuracy).\\n(A solution need not actually call the collections \""A\"" and \""B\"". These names are only used in the preceding paragraph for clarity.)\\n\\nFirst-class Numbers\\n\\nOutput:\\nEven if the example below solves the task, there are some limitations to how dynamically you can create, store and use functions in Ada, so it is debatable if Ada really has first class functions.\\nIt is bad style (but an explicit requirement in the task description) to put the functions and their inverses in separate arrays rather than keeping each pair in a record and then having an array of that record type.\\nNote: Returning PROC (REAL x)REAL: f1(f2(x)) from a function apparently\\nviolates standard ALGOL 68's scoping rules. ALGOL 68G warns about this during\\nparsing, and then - if run out of scope - rejects during runtime.\\nOutput:\\nAppleScript does not have built-in functions like sine or cosine.\\nPutting math libraries aside for the moment (we can always shell out to bash functions like bc), a deeper issue is that the architectural position of functions in the AppleScript type system is simply a little too incoherent and second class to facilitate really frictionless work with first-class functions. (This is clearly not what AppleScript was originally designed for).\\nIncoherent, in the sense that built-in functions and operators do not have the same place in the type system as user functions. The former are described as 'commands' in parser errors, and have to be wrapped in user handlers if they are to be used interchangeably with other functions.\\nSecond class, in the sense that user functions (or 'handlers' in the terminology of Apple's documentation), are properties of scripts. The scripts are autonomous first class objects, but the handlers are not. Functions which accept other functions as arguments will internally need to use an mReturn or mInject function which 'lifts' handlers into script object types. Functions which return functions will similarly have to return them embedded in such script objects.\\nOnce we have a function like mReturn, however, we can readily write higher order functions like map, zipWith and mCompose below.\\n","from math import (acos, cos, asin, sin)\\n\\n\\n# main :: IO ()\\ndef main():\\n    fs = [sin, cos, lambda x: x ** 3.0]\\n    ifs = [asin, acos, lambda x: x ** (1 / 3.0)]\\n\\n    return map(\\n        lambda f: f(0.5),\\n        zipWith(compose)(fs)(ifs)\\n    )\\n\\n\\n# GENERIC FUNCTIONS ------------------------------\\n\\n\\n# compose (>>>) :: (a -> b) -> (b -> c) -> a -> c\\ndef compose(f):\\n    return lambda (g): lambda x: f(g(x))\\n\\n\\n# zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\\ndef zipWith(f):\\n    return (\\n        lambda xs: lambda ys:\\n            [f(a)(b) for (a, b) in zip(xs, ys)]\\n    )\\n\\n\\nprint main()"
"Python","Five_weekends","The month of October in 2010 has five Fridays, five Saturdays, and five Sundays.\\n\\n\\nAlgorithm suggestions\\n\\nExtra credit\\nCount and/or show all of the years which do not have at least one five-weekend month (there should be 29).\\n\\n\\nFor maximum compatibility, this program uses only the basic instruction set (S/360)\\nand two ASSIST macros (XDECO, XPRNT) to keep the code as short as possible.\\n","from datetime import timedelta, date\\n\\nDAY     = timedelta(days=1)\\nSTART, STOP = date(1900, 1, 1), date(2101, 1, 1)\\nWEEKEND = {6, 5, 4}     # Sunday is day 6\\nFMT     = '%Y %m(%B)'\\n\\ndef fiveweekendspermonth(start=START, stop=STOP):\\n    'Compute months with five weekends between dates'\\n    \\n    when = start\\n    lastmonth = weekenddays = 0\\n    fiveweekends = []\\n    while when < stop:\\n        year, mon, _mday, _h, _m, _s, wday, _yday, _isdst = when.timetuple()\\n        if mon != lastmonth:\\n            if weekenddays >= 15:\\n                fiveweekends.append(when - DAY)\\n            weekenddays = 0\\n            lastmonth = mon\\n        if wday in WEEKEND:\\n            weekenddays += 1\\n        when += DAY\\n    return fiveweekends\\n\\ndates = fiveweekendspermonth()\\nindent = '  '\\nprint('There are %s months of which the first and last five are:' % len(dates))\\nprint(indent +('\\n'+indent).join(d.strftime(FMT) for d in dates[:5]))\\nprint(indent +'...')\\nprint(indent +('\\n'+indent).join(d.strftime(FMT) for d in dates[-5:]))\\n\\nprint('\\nThere are %i years in the range that do not have months with five weekends'\\n      % len(set(range(START.year, STOP.year)) - {d.year for d in dates}))"
"Python","Five_weekends","The month of October in 2010 has five Fridays, five Saturdays, and five Sundays.\\n\\n\\nAlgorithm suggestions\\n\\nExtra credit\\nCount and/or show all of the years which do not have at least one five-weekend month (there should be 29).\\n\\n\\nFor maximum compatibility, this program uses only the basic instruction set (S/360)\\nand two ASSIST macros (XDECO, XPRNT) to keep the code as short as possible.\\n","LONGMONTHS = (1, 3, 5, 7, 8, 10, 12) # Jan Mar May Jul Aug Oct Dec\\ndef fiveweekendspermonth2(start=START, stop=STOP):\\n    return [date(yr, month, 31)\\n            for yr in range(START.year, STOP.year)\\n            for month in LONGMONTHS\\n            if date(yr, month, 31).timetuple()[6] == 6 # Sunday\\n            ]\\n\\ndates2 = fiveweekendspermonth2()\\nassert dates2 == dates"
"Python","Fivenum","Many big data or scientific programs use boxplots to show distributions of data.   In addition, sometimes saving large arrays for boxplots can be impractical and use extreme amounts of RAM.   It can be useful to save large arrays as arrays with five numbers to save memory.\\nFor example, the   R   programming language implements Tukey's five-number summary as the fivenum function.\\n\\nGiven an array of numbers, compute the five-number summary.\\n\\nWhile these five numbers can be used to draw a boxplot, statistical packages will typically need extra data. Moreover, while there is a consensus about the \""box\"" of the boxplot, there are variations among statistical packages for the whiskers.\\n\\n","from __future__ import division\\nimport math\\nimport sys\\n\\ndef fivenum(array):\\n    n = len(array)\\n    if n == 0:\\n        print(\""you entered an empty array.\"")\\n        sys.exit()\\n    x = sorted(array)\\n    \\n    n4 = math.floor((n+3.0)/2.0)/2.0\\n    d = [1, n4, (n+1)/2, n+1-n4, n]\\n    sum_array = []\\n    \\n    for e in range(5):\\n        floor = int(math.floor(d[e] - 1))\\n        ceil = int(math.ceil(d[e] - 1))\\n        sum_array.append(0.5 * (x[floor] + x[ceil]))\\n    \\n    return sum_array\\n\\nx = [0.14082834, 0.09748790, 1.73131507, 0.87636009, -1.95059594, 0.73438555, -0.03035726, 1.46675970,\\n-0.74621349, -0.72588772, 0.63905160, 0.61501527, -0.98983780, -1.00447874, -0.62759469, 0.66206163,\\n1.04312009, -0.10305385, 0.75775634, 0.32566578]\\n\\ny = fivenum(x)\\nprint(y)"
"Python","Fivenum","Many big data or scientific programs use boxplots to show distributions of data.   In addition, sometimes saving large arrays for boxplots can be impractical and use extreme amounts of RAM.   It can be useful to save large arrays as arrays with five numbers to save memory.\\nFor example, the   R   programming language implements Tukey's five-number summary as the fivenum function.\\n\\nGiven an array of numbers, compute the five-number summary.\\n\\nWhile these five numbers can be used to draw a boxplot, statistical packages will typically need extra data. Moreover, while there is a consensus about the \""box\"" of the boxplot, there are variations among statistical packages for the whiskers.\\n\\n","import pandas as pd\\npd.DataFrame([1, 2, 3, 4, 5, 6]).describe()"
"Python","Fivenum","Many big data or scientific programs use boxplots to show distributions of data.   In addition, sometimes saving large arrays for boxplots can be impractical and use extreme amounts of RAM.   It can be useful to save large arrays as arrays with five numbers to save memory.\\nFor example, the   R   programming language implements Tukey's five-number summary as the fivenum function.\\n\\nGiven an array of numbers, compute the five-number summary.\\n\\nWhile these five numbers can be used to draw a boxplot, statistical packages will typically need extra data. Moreover, while there is a consensus about the \""box\"" of the boxplot, there are variations among statistical packages for the whiskers.\\n\\n","import pandas as pd\\npd.DataFrame([1, 2, 3, 4, 5, 6]).quantile([.0, .25, .50, .75, 1.00], interpolation='nearest')"
"Python","Fivenum","Many big data or scientific programs use boxplots to show distributions of data.   In addition, sometimes saving large arrays for boxplots can be impractical and use extreme amounts of RAM.   It can be useful to save large arrays as arrays with five numbers to save memory.\\nFor example, the   R   programming language implements Tukey's five-number summary as the fivenum function.\\n\\nGiven an array of numbers, compute the five-number summary.\\n\\nWhile these five numbers can be used to draw a boxplot, statistical packages will typically need extra data. Moreover, while there is a consensus about the \""box\"" of the boxplot, there are variations among statistical packages for the whiskers.\\n\\n","# fiveNums :: [Float] -> (Float, Float, Float, Float, Float)\\ndef fiveNums(xs):\\n    def median(xs):\\n        lng = len(xs)\\n        m = lng // 2\\n        return xs[m] if (\\n            0 != lng % 2\\n        ) else (xs[m - 1] + xs[m]) / 2\\n \\n    ys = sorted(xs)\\n    lng = len(ys)\\n    m = lng // 2\\n    return (\\n        ys[0], \\n        median(ys[0:(m + (lng % 2))]),\\n        median(ys), \\n        median(ys[m:]), \\n        ys[-1]\\n    ) if 0 < lng else None\\n \\n \\n# TEST --------------------------------------------------------------------\\nfor xs in [[15, 6, 42, 41, 7, 36, 49, 40, 39, 47, 43],\\n           [36, 40, 7, 39, 41, 15],\\n           [\\n               0.14082834, 0.09748790, 1.73131507, 0.87636009, -1.95059594,\\n               0.73438555, -0.03035726, 1.46675970, -0.74621349, -0.72588772,\\n               0.63905160, 0.61501527, -0.98983780, -1.00447874, -0.62759469,\\n               0.66206163, 1.04312009, -0.10305385, 0.75775634, 0.32566578\\n           ]]:\\n    print(\\n        fiveNums(xs)\\n    )"
"Python","FizzBuzz","Write a program that prints the integers from   1   to   100   (inclusive).\\n\\nBut:\\n\\nThe   FizzBuzz   problem was presented as the lowest level of comprehension required to illustrate adequacy.\\n\\n\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nThe ActionScript solution works just like the JavaScript solution (they share the ECMAScript specification). The difference is that ActionScript has the trace command to write out to a console.\\nor simply:\\n\\nSlightly different approach that makes use of the Decode function (⊥):\\nThe idea is to first calculate the residues for all numbers 1..100 after\\ndivision with both 3 and 5. This generates 100 pairs of numbers a b, where\\na is either 0,1,2 and b is either 0,1,2,3,4.\\nThese pairs are then put through the sign function which returns 0 for a 0,\\nand a 1 for anything greater than 0. Now we have binary pairs.\\nThe binary pairs are encoded with a left argument of 2 resulting in 0,1,2,3.\\nThese are treated as indices for the \""FizzBuzz vector\"" where 0 is in position 3.\\nVariable A holds this new vector of words and zeros.\\nVariable I is assigned the zeros' positions.\\nFinally A[I] is replaced with corresponding indices.\\nIf you have an aversion against mixed vectors, consider inserting ⍕¨ before the\\nfinal (i.e. left-most) assignment.\\nHere's a Dyalog-specific solution taking advantage of its anonymous function extension:\\n\\nOr, using map(), enumFromTo(), and a more functional pattern of composition:\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang#AsciiDots\\nSearch autohotkey.com: [1]\\nA short example with cascading ternary operators and graphical output. Press Esc to close the window.\\nOutput via MsgBox():\\nOutput via console, logfile and/or messagebox:\\nSee FizzBuzz/AWK\\nSee FizzBuzz/Basic#BaCon\\nAny bash hacker would do this as a one liner at the shell, so...\\nFor the sake of readability...\\nHere's a very concise approach, with only 75 characters total.\\nUnfortunately it relies on aspects of Bash which are rarely used.\\nHere's the concise approach again, this time separated into multiple lines.\\nIt's a bit silly to optimize such a small & fast program,\\nbut for the sake of algorithm analysis it's worth noting that\\nthe concise approach is reasonably efficient in several ways.\\nEach divisibility test appears in the code exactly once,\\nonly two variables are created,\\nand the approach avoids setting variables unnecessarily.\\nAs far as I can tell,\\nthe divisibility tests only fire the minimum number of times required\\nfor the general case (e.g. where the 100/3/5 constants can be changed),\\nunless you introduce more variables and test types.\\nCorrections invited.\\nI avoided analyzing the non-general case where 100/3/5 never change,\\nbecause one \""optimal\"" solution is to simply print the pre-computed answer,\\nSee FizzBuzz/Basic\\nFOR /L version:\\nLoop version:\\nFOR /L with a block instead of very-high-overhead subroutine call:\\nSee FizzBuzz/Basic\\nThis solution never uses else, because bc has no else keyword (but some implementations add else as an extension).\\nAlso see on FizzBuzz/EsoLang\\n“Ordinary” FizzBuzz solution:\\n\\nExample without double mod 5 check, using a flag instead, to check if Fizz already got printed (in this case the number n must not be printed if mod 5 is > 0):\\nSee FizzBuzz/EsoLang\\nSame code, pretty printed:\\nSee FizzBuzz/EsoLang\\nThe following C code was inspired by this ( low SignalToNoise, EasyToModify ) JavaScript:\\nWith 2 prime numbers, the C code is:\\nWith 4 prime numbers:\\nOne line version, with pretty printing\\nImplicit int main and return 0 (C99+):\\nobfuscated:\\nWithout conditionals, anything in the loop body gcc compiles with branching, duplicate tests or duplicate strings. Depends on ASCII and two's complement arithmetic:\\nTDD using delegates.\\nAlternate version not using modulo 15:\\nAlternate version that avoids using modulo. (Modulo can be expensive on some architectures.)\\nA version using std::transform:\\nVersion computing FizzBuzz at compile time with metaprogramming:\\nHardcore templates (compile with -ftemplate-depth-9000 -std=c++0x):\\nNote: it takes up lots of memory and takes several seconds to compile. To enable compilation for 7 < n <= 25, please, modify include/boost/mpl/limits/string.hpp BOOST_MPL_LIMIT_STRING_SIZE to 128 instead of 32).\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang\\nAlso compiles with Harbour (Harbour 3.2.0dev (r1405201749))\\nThe advantage of this approach is that it is trivial to add another factor:\\nI know this doesn't have the full-bodied, piquant flavor\\nexpected from COBOL, but it is a little shorter.\\nI think this shows clearly that it's resolving the problem and illuminating the rules specified\\nA solution that simply evaluates and adds.\\ncfscript version\\nSolution 1:\\nSolution 2:\\nSolution 3:\\nSolution 4:\\nSolution 5:\\nSolution 6:\\nSolution 7:\\nFirst 16 lines of output:\\nI use Allegro CL 10.1\\nOutput:\\nThe bc translation written in dc style.\\nFizzBuzz, realized using two different methods for string/character output:\\nOutput to STDOUT via single character output.\\nOutput to STDOUT, using stored strings and a separately defined string output operator:\\nused case\\nAlternate approach using pipes and cond:\\nused Stream.cycle version:\\nYet another approach:\\nused anonymous function\\nEnum.at version: Returns nil if index is out of bounds.\\nThe Stream.cycle version above, but as an overpowered FizzBuzz DSL.\\nA bit too simple:\\nA bit too clever:\\nThis is based on the VBScript example.\\nAnother example using (unnecessary) partial active pattern :D\\nMore flexible variant without divisibility tests.\\nSee FizzBuzz/EsoLang\\nNo 'MOD 15' needed.\\n","for i in xrange(1, 101):\\n    if i % 15 == 0:\\n        print \""FizzBuzz\""\\n    elif i % 3 == 0:\\n        print \""Fizz\""\\n    elif i % 5 == 0:\\n        print \""Buzz\""\\n    else:\\n        print i"
"Python","FizzBuzz","Write a program that prints the integers from   1   to   100   (inclusive).\\n\\nBut:\\n\\nThe   FizzBuzz   problem was presented as the lowest level of comprehension required to illustrate adequacy.\\n\\n\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nThe ActionScript solution works just like the JavaScript solution (they share the ECMAScript specification). The difference is that ActionScript has the trace command to write out to a console.\\nor simply:\\n\\nSlightly different approach that makes use of the Decode function (⊥):\\nThe idea is to first calculate the residues for all numbers 1..100 after\\ndivision with both 3 and 5. This generates 100 pairs of numbers a b, where\\na is either 0,1,2 and b is either 0,1,2,3,4.\\nThese pairs are then put through the sign function which returns 0 for a 0,\\nand a 1 for anything greater than 0. Now we have binary pairs.\\nThe binary pairs are encoded with a left argument of 2 resulting in 0,1,2,3.\\nThese are treated as indices for the \""FizzBuzz vector\"" where 0 is in position 3.\\nVariable A holds this new vector of words and zeros.\\nVariable I is assigned the zeros' positions.\\nFinally A[I] is replaced with corresponding indices.\\nIf you have an aversion against mixed vectors, consider inserting ⍕¨ before the\\nfinal (i.e. left-most) assignment.\\nHere's a Dyalog-specific solution taking advantage of its anonymous function extension:\\n\\nOr, using map(), enumFromTo(), and a more functional pattern of composition:\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang#AsciiDots\\nSearch autohotkey.com: [1]\\nA short example with cascading ternary operators and graphical output. Press Esc to close the window.\\nOutput via MsgBox():\\nOutput via console, logfile and/or messagebox:\\nSee FizzBuzz/AWK\\nSee FizzBuzz/Basic#BaCon\\nAny bash hacker would do this as a one liner at the shell, so...\\nFor the sake of readability...\\nHere's a very concise approach, with only 75 characters total.\\nUnfortunately it relies on aspects of Bash which are rarely used.\\nHere's the concise approach again, this time separated into multiple lines.\\nIt's a bit silly to optimize such a small & fast program,\\nbut for the sake of algorithm analysis it's worth noting that\\nthe concise approach is reasonably efficient in several ways.\\nEach divisibility test appears in the code exactly once,\\nonly two variables are created,\\nand the approach avoids setting variables unnecessarily.\\nAs far as I can tell,\\nthe divisibility tests only fire the minimum number of times required\\nfor the general case (e.g. where the 100/3/5 constants can be changed),\\nunless you introduce more variables and test types.\\nCorrections invited.\\nI avoided analyzing the non-general case where 100/3/5 never change,\\nbecause one \""optimal\"" solution is to simply print the pre-computed answer,\\nSee FizzBuzz/Basic\\nFOR /L version:\\nLoop version:\\nFOR /L with a block instead of very-high-overhead subroutine call:\\nSee FizzBuzz/Basic\\nThis solution never uses else, because bc has no else keyword (but some implementations add else as an extension).\\nAlso see on FizzBuzz/EsoLang\\n“Ordinary” FizzBuzz solution:\\n\\nExample without double mod 5 check, using a flag instead, to check if Fizz already got printed (in this case the number n must not be printed if mod 5 is > 0):\\nSee FizzBuzz/EsoLang\\nSame code, pretty printed:\\nSee FizzBuzz/EsoLang\\nThe following C code was inspired by this ( low SignalToNoise, EasyToModify ) JavaScript:\\nWith 2 prime numbers, the C code is:\\nWith 4 prime numbers:\\nOne line version, with pretty printing\\nImplicit int main and return 0 (C99+):\\nobfuscated:\\nWithout conditionals, anything in the loop body gcc compiles with branching, duplicate tests or duplicate strings. Depends on ASCII and two's complement arithmetic:\\nTDD using delegates.\\nAlternate version not using modulo 15:\\nAlternate version that avoids using modulo. (Modulo can be expensive on some architectures.)\\nA version using std::transform:\\nVersion computing FizzBuzz at compile time with metaprogramming:\\nHardcore templates (compile with -ftemplate-depth-9000 -std=c++0x):\\nNote: it takes up lots of memory and takes several seconds to compile. To enable compilation for 7 < n <= 25, please, modify include/boost/mpl/limits/string.hpp BOOST_MPL_LIMIT_STRING_SIZE to 128 instead of 32).\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang\\nAlso compiles with Harbour (Harbour 3.2.0dev (r1405201749))\\nThe advantage of this approach is that it is trivial to add another factor:\\nI know this doesn't have the full-bodied, piquant flavor\\nexpected from COBOL, but it is a little shorter.\\nI think this shows clearly that it's resolving the problem and illuminating the rules specified\\nA solution that simply evaluates and adds.\\ncfscript version\\nSolution 1:\\nSolution 2:\\nSolution 3:\\nSolution 4:\\nSolution 5:\\nSolution 6:\\nSolution 7:\\nFirst 16 lines of output:\\nI use Allegro CL 10.1\\nOutput:\\nThe bc translation written in dc style.\\nFizzBuzz, realized using two different methods for string/character output:\\nOutput to STDOUT via single character output.\\nOutput to STDOUT, using stored strings and a separately defined string output operator:\\nused case\\nAlternate approach using pipes and cond:\\nused Stream.cycle version:\\nYet another approach:\\nused anonymous function\\nEnum.at version: Returns nil if index is out of bounds.\\nThe Stream.cycle version above, but as an overpowered FizzBuzz DSL.\\nA bit too simple:\\nA bit too clever:\\nThis is based on the VBScript example.\\nAnother example using (unnecessary) partial active pattern :D\\nMore flexible variant without divisibility tests.\\nSee FizzBuzz/EsoLang\\nNo 'MOD 15' needed.\\n","for i in range(1, 101):\\n    if i % 15 == 0:\\n        print (\""FizzBuzz\"")\\n    elif i % 3 == 0:\\n        print (\""Fizz\"")\\n    elif i % 5 == 0:\\n        print (\""Buzz\"")\\n    else:\\n        print (i)"
"Python","FizzBuzz","Write a program that prints the integers from   1   to   100   (inclusive).\\n\\nBut:\\n\\nThe   FizzBuzz   problem was presented as the lowest level of comprehension required to illustrate adequacy.\\n\\n\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nThe ActionScript solution works just like the JavaScript solution (they share the ECMAScript specification). The difference is that ActionScript has the trace command to write out to a console.\\nor simply:\\n\\nSlightly different approach that makes use of the Decode function (⊥):\\nThe idea is to first calculate the residues for all numbers 1..100 after\\ndivision with both 3 and 5. This generates 100 pairs of numbers a b, where\\na is either 0,1,2 and b is either 0,1,2,3,4.\\nThese pairs are then put through the sign function which returns 0 for a 0,\\nand a 1 for anything greater than 0. Now we have binary pairs.\\nThe binary pairs are encoded with a left argument of 2 resulting in 0,1,2,3.\\nThese are treated as indices for the \""FizzBuzz vector\"" where 0 is in position 3.\\nVariable A holds this new vector of words and zeros.\\nVariable I is assigned the zeros' positions.\\nFinally A[I] is replaced with corresponding indices.\\nIf you have an aversion against mixed vectors, consider inserting ⍕¨ before the\\nfinal (i.e. left-most) assignment.\\nHere's a Dyalog-specific solution taking advantage of its anonymous function extension:\\n\\nOr, using map(), enumFromTo(), and a more functional pattern of composition:\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang#AsciiDots\\nSearch autohotkey.com: [1]\\nA short example with cascading ternary operators and graphical output. Press Esc to close the window.\\nOutput via MsgBox():\\nOutput via console, logfile and/or messagebox:\\nSee FizzBuzz/AWK\\nSee FizzBuzz/Basic#BaCon\\nAny bash hacker would do this as a one liner at the shell, so...\\nFor the sake of readability...\\nHere's a very concise approach, with only 75 characters total.\\nUnfortunately it relies on aspects of Bash which are rarely used.\\nHere's the concise approach again, this time separated into multiple lines.\\nIt's a bit silly to optimize such a small & fast program,\\nbut for the sake of algorithm analysis it's worth noting that\\nthe concise approach is reasonably efficient in several ways.\\nEach divisibility test appears in the code exactly once,\\nonly two variables are created,\\nand the approach avoids setting variables unnecessarily.\\nAs far as I can tell,\\nthe divisibility tests only fire the minimum number of times required\\nfor the general case (e.g. where the 100/3/5 constants can be changed),\\nunless you introduce more variables and test types.\\nCorrections invited.\\nI avoided analyzing the non-general case where 100/3/5 never change,\\nbecause one \""optimal\"" solution is to simply print the pre-computed answer,\\nSee FizzBuzz/Basic\\nFOR /L version:\\nLoop version:\\nFOR /L with a block instead of very-high-overhead subroutine call:\\nSee FizzBuzz/Basic\\nThis solution never uses else, because bc has no else keyword (but some implementations add else as an extension).\\nAlso see on FizzBuzz/EsoLang\\n“Ordinary” FizzBuzz solution:\\n\\nExample without double mod 5 check, using a flag instead, to check if Fizz already got printed (in this case the number n must not be printed if mod 5 is > 0):\\nSee FizzBuzz/EsoLang\\nSame code, pretty printed:\\nSee FizzBuzz/EsoLang\\nThe following C code was inspired by this ( low SignalToNoise, EasyToModify ) JavaScript:\\nWith 2 prime numbers, the C code is:\\nWith 4 prime numbers:\\nOne line version, with pretty printing\\nImplicit int main and return 0 (C99+):\\nobfuscated:\\nWithout conditionals, anything in the loop body gcc compiles with branching, duplicate tests or duplicate strings. Depends on ASCII and two's complement arithmetic:\\nTDD using delegates.\\nAlternate version not using modulo 15:\\nAlternate version that avoids using modulo. (Modulo can be expensive on some architectures.)\\nA version using std::transform:\\nVersion computing FizzBuzz at compile time with metaprogramming:\\nHardcore templates (compile with -ftemplate-depth-9000 -std=c++0x):\\nNote: it takes up lots of memory and takes several seconds to compile. To enable compilation for 7 < n <= 25, please, modify include/boost/mpl/limits/string.hpp BOOST_MPL_LIMIT_STRING_SIZE to 128 instead of 32).\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang\\nAlso compiles with Harbour (Harbour 3.2.0dev (r1405201749))\\nThe advantage of this approach is that it is trivial to add another factor:\\nI know this doesn't have the full-bodied, piquant flavor\\nexpected from COBOL, but it is a little shorter.\\nI think this shows clearly that it's resolving the problem and illuminating the rules specified\\nA solution that simply evaluates and adds.\\ncfscript version\\nSolution 1:\\nSolution 2:\\nSolution 3:\\nSolution 4:\\nSolution 5:\\nSolution 6:\\nSolution 7:\\nFirst 16 lines of output:\\nI use Allegro CL 10.1\\nOutput:\\nThe bc translation written in dc style.\\nFizzBuzz, realized using two different methods for string/character output:\\nOutput to STDOUT via single character output.\\nOutput to STDOUT, using stored strings and a separately defined string output operator:\\nused case\\nAlternate approach using pipes and cond:\\nused Stream.cycle version:\\nYet another approach:\\nused anonymous function\\nEnum.at version: Returns nil if index is out of bounds.\\nThe Stream.cycle version above, but as an overpowered FizzBuzz DSL.\\nA bit too simple:\\nA bit too clever:\\nThis is based on the VBScript example.\\nAnother example using (unnecessary) partial active pattern :D\\nMore flexible variant without divisibility tests.\\nSee FizzBuzz/EsoLang\\nNo 'MOD 15' needed.\\n","for i in range(1,101): print(\""Fizz\""*(i%3==0) + \""Buzz\""*(i%5==0) or i)"
"Python","FizzBuzz","Write a program that prints the integers from   1   to   100   (inclusive).\\n\\nBut:\\n\\nThe   FizzBuzz   problem was presented as the lowest level of comprehension required to illustrate adequacy.\\n\\n\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nThe ActionScript solution works just like the JavaScript solution (they share the ECMAScript specification). The difference is that ActionScript has the trace command to write out to a console.\\nor simply:\\n\\nSlightly different approach that makes use of the Decode function (⊥):\\nThe idea is to first calculate the residues for all numbers 1..100 after\\ndivision with both 3 and 5. This generates 100 pairs of numbers a b, where\\na is either 0,1,2 and b is either 0,1,2,3,4.\\nThese pairs are then put through the sign function which returns 0 for a 0,\\nand a 1 for anything greater than 0. Now we have binary pairs.\\nThe binary pairs are encoded with a left argument of 2 resulting in 0,1,2,3.\\nThese are treated as indices for the \""FizzBuzz vector\"" where 0 is in position 3.\\nVariable A holds this new vector of words and zeros.\\nVariable I is assigned the zeros' positions.\\nFinally A[I] is replaced with corresponding indices.\\nIf you have an aversion against mixed vectors, consider inserting ⍕¨ before the\\nfinal (i.e. left-most) assignment.\\nHere's a Dyalog-specific solution taking advantage of its anonymous function extension:\\n\\nOr, using map(), enumFromTo(), and a more functional pattern of composition:\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang#AsciiDots\\nSearch autohotkey.com: [1]\\nA short example with cascading ternary operators and graphical output. Press Esc to close the window.\\nOutput via MsgBox():\\nOutput via console, logfile and/or messagebox:\\nSee FizzBuzz/AWK\\nSee FizzBuzz/Basic#BaCon\\nAny bash hacker would do this as a one liner at the shell, so...\\nFor the sake of readability...\\nHere's a very concise approach, with only 75 characters total.\\nUnfortunately it relies on aspects of Bash which are rarely used.\\nHere's the concise approach again, this time separated into multiple lines.\\nIt's a bit silly to optimize such a small & fast program,\\nbut for the sake of algorithm analysis it's worth noting that\\nthe concise approach is reasonably efficient in several ways.\\nEach divisibility test appears in the code exactly once,\\nonly two variables are created,\\nand the approach avoids setting variables unnecessarily.\\nAs far as I can tell,\\nthe divisibility tests only fire the minimum number of times required\\nfor the general case (e.g. where the 100/3/5 constants can be changed),\\nunless you introduce more variables and test types.\\nCorrections invited.\\nI avoided analyzing the non-general case where 100/3/5 never change,\\nbecause one \""optimal\"" solution is to simply print the pre-computed answer,\\nSee FizzBuzz/Basic\\nFOR /L version:\\nLoop version:\\nFOR /L with a block instead of very-high-overhead subroutine call:\\nSee FizzBuzz/Basic\\nThis solution never uses else, because bc has no else keyword (but some implementations add else as an extension).\\nAlso see on FizzBuzz/EsoLang\\n“Ordinary” FizzBuzz solution:\\n\\nExample without double mod 5 check, using a flag instead, to check if Fizz already got printed (in this case the number n must not be printed if mod 5 is > 0):\\nSee FizzBuzz/EsoLang\\nSame code, pretty printed:\\nSee FizzBuzz/EsoLang\\nThe following C code was inspired by this ( low SignalToNoise, EasyToModify ) JavaScript:\\nWith 2 prime numbers, the C code is:\\nWith 4 prime numbers:\\nOne line version, with pretty printing\\nImplicit int main and return 0 (C99+):\\nobfuscated:\\nWithout conditionals, anything in the loop body gcc compiles with branching, duplicate tests or duplicate strings. Depends on ASCII and two's complement arithmetic:\\nTDD using delegates.\\nAlternate version not using modulo 15:\\nAlternate version that avoids using modulo. (Modulo can be expensive on some architectures.)\\nA version using std::transform:\\nVersion computing FizzBuzz at compile time with metaprogramming:\\nHardcore templates (compile with -ftemplate-depth-9000 -std=c++0x):\\nNote: it takes up lots of memory and takes several seconds to compile. To enable compilation for 7 < n <= 25, please, modify include/boost/mpl/limits/string.hpp BOOST_MPL_LIMIT_STRING_SIZE to 128 instead of 32).\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang\\nAlso compiles with Harbour (Harbour 3.2.0dev (r1405201749))\\nThe advantage of this approach is that it is trivial to add another factor:\\nI know this doesn't have the full-bodied, piquant flavor\\nexpected from COBOL, but it is a little shorter.\\nI think this shows clearly that it's resolving the problem and illuminating the rules specified\\nA solution that simply evaluates and adds.\\ncfscript version\\nSolution 1:\\nSolution 2:\\nSolution 3:\\nSolution 4:\\nSolution 5:\\nSolution 6:\\nSolution 7:\\nFirst 16 lines of output:\\nI use Allegro CL 10.1\\nOutput:\\nThe bc translation written in dc style.\\nFizzBuzz, realized using two different methods for string/character output:\\nOutput to STDOUT via single character output.\\nOutput to STDOUT, using stored strings and a separately defined string output operator:\\nused case\\nAlternate approach using pipes and cond:\\nused Stream.cycle version:\\nYet another approach:\\nused anonymous function\\nEnum.at version: Returns nil if index is out of bounds.\\nThe Stream.cycle version above, but as an overpowered FizzBuzz DSL.\\nA bit too simple:\\nA bit too clever:\\nThis is based on the VBScript example.\\nAnother example using (unnecessary) partial active pattern :D\\nMore flexible variant without divisibility tests.\\nSee FizzBuzz/EsoLang\\nNo 'MOD 15' needed.\\n","for i in range(100):print(i%3//2*'Fizz'+i%5//4*'Buzz'or i+1)"
"Python","FizzBuzz","Write a program that prints the integers from   1   to   100   (inclusive).\\n\\nBut:\\n\\nThe   FizzBuzz   problem was presented as the lowest level of comprehension required to illustrate adequacy.\\n\\n\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nThe ActionScript solution works just like the JavaScript solution (they share the ECMAScript specification). The difference is that ActionScript has the trace command to write out to a console.\\nor simply:\\n\\nSlightly different approach that makes use of the Decode function (⊥):\\nThe idea is to first calculate the residues for all numbers 1..100 after\\ndivision with both 3 and 5. This generates 100 pairs of numbers a b, where\\na is either 0,1,2 and b is either 0,1,2,3,4.\\nThese pairs are then put through the sign function which returns 0 for a 0,\\nand a 1 for anything greater than 0. Now we have binary pairs.\\nThe binary pairs are encoded with a left argument of 2 resulting in 0,1,2,3.\\nThese are treated as indices for the \""FizzBuzz vector\"" where 0 is in position 3.\\nVariable A holds this new vector of words and zeros.\\nVariable I is assigned the zeros' positions.\\nFinally A[I] is replaced with corresponding indices.\\nIf you have an aversion against mixed vectors, consider inserting ⍕¨ before the\\nfinal (i.e. left-most) assignment.\\nHere's a Dyalog-specific solution taking advantage of its anonymous function extension:\\n\\nOr, using map(), enumFromTo(), and a more functional pattern of composition:\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang#AsciiDots\\nSearch autohotkey.com: [1]\\nA short example with cascading ternary operators and graphical output. Press Esc to close the window.\\nOutput via MsgBox():\\nOutput via console, logfile and/or messagebox:\\nSee FizzBuzz/AWK\\nSee FizzBuzz/Basic#BaCon\\nAny bash hacker would do this as a one liner at the shell, so...\\nFor the sake of readability...\\nHere's a very concise approach, with only 75 characters total.\\nUnfortunately it relies on aspects of Bash which are rarely used.\\nHere's the concise approach again, this time separated into multiple lines.\\nIt's a bit silly to optimize such a small & fast program,\\nbut for the sake of algorithm analysis it's worth noting that\\nthe concise approach is reasonably efficient in several ways.\\nEach divisibility test appears in the code exactly once,\\nonly two variables are created,\\nand the approach avoids setting variables unnecessarily.\\nAs far as I can tell,\\nthe divisibility tests only fire the minimum number of times required\\nfor the general case (e.g. where the 100/3/5 constants can be changed),\\nunless you introduce more variables and test types.\\nCorrections invited.\\nI avoided analyzing the non-general case where 100/3/5 never change,\\nbecause one \""optimal\"" solution is to simply print the pre-computed answer,\\nSee FizzBuzz/Basic\\nFOR /L version:\\nLoop version:\\nFOR /L with a block instead of very-high-overhead subroutine call:\\nSee FizzBuzz/Basic\\nThis solution never uses else, because bc has no else keyword (but some implementations add else as an extension).\\nAlso see on FizzBuzz/EsoLang\\n“Ordinary” FizzBuzz solution:\\n\\nExample without double mod 5 check, using a flag instead, to check if Fizz already got printed (in this case the number n must not be printed if mod 5 is > 0):\\nSee FizzBuzz/EsoLang\\nSame code, pretty printed:\\nSee FizzBuzz/EsoLang\\nThe following C code was inspired by this ( low SignalToNoise, EasyToModify ) JavaScript:\\nWith 2 prime numbers, the C code is:\\nWith 4 prime numbers:\\nOne line version, with pretty printing\\nImplicit int main and return 0 (C99+):\\nobfuscated:\\nWithout conditionals, anything in the loop body gcc compiles with branching, duplicate tests or duplicate strings. Depends on ASCII and two's complement arithmetic:\\nTDD using delegates.\\nAlternate version not using modulo 15:\\nAlternate version that avoids using modulo. (Modulo can be expensive on some architectures.)\\nA version using std::transform:\\nVersion computing FizzBuzz at compile time with metaprogramming:\\nHardcore templates (compile with -ftemplate-depth-9000 -std=c++0x):\\nNote: it takes up lots of memory and takes several seconds to compile. To enable compilation for 7 < n <= 25, please, modify include/boost/mpl/limits/string.hpp BOOST_MPL_LIMIT_STRING_SIZE to 128 instead of 32).\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang\\nAlso compiles with Harbour (Harbour 3.2.0dev (r1405201749))\\nThe advantage of this approach is that it is trivial to add another factor:\\nI know this doesn't have the full-bodied, piquant flavor\\nexpected from COBOL, but it is a little shorter.\\nI think this shows clearly that it's resolving the problem and illuminating the rules specified\\nA solution that simply evaluates and adds.\\ncfscript version\\nSolution 1:\\nSolution 2:\\nSolution 3:\\nSolution 4:\\nSolution 5:\\nSolution 6:\\nSolution 7:\\nFirst 16 lines of output:\\nI use Allegro CL 10.1\\nOutput:\\nThe bc translation written in dc style.\\nFizzBuzz, realized using two different methods for string/character output:\\nOutput to STDOUT via single character output.\\nOutput to STDOUT, using stored strings and a separately defined string output operator:\\nused case\\nAlternate approach using pipes and cond:\\nused Stream.cycle version:\\nYet another approach:\\nused anonymous function\\nEnum.at version: Returns nil if index is out of bounds.\\nThe Stream.cycle version above, but as an overpowered FizzBuzz DSL.\\nA bit too simple:\\nA bit too clever:\\nThis is based on the VBScript example.\\nAnother example using (unnecessary) partial active pattern :D\\nMore flexible variant without divisibility tests.\\nSee FizzBuzz/EsoLang\\nNo 'MOD 15' needed.\\n","\\nfor n in range(1, 100):\\n    fb = ''.join([ denom[1] if n % denom[0] == 0 else '' for denom in [(3,'fizz'),(5,'buzz')] ])\\n    print fb if fb else n\\n"
"Python","FizzBuzz","Write a program that prints the integers from   1   to   100   (inclusive).\\n\\nBut:\\n\\nThe   FizzBuzz   problem was presented as the lowest level of comprehension required to illustrate adequacy.\\n\\n\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nThe ActionScript solution works just like the JavaScript solution (they share the ECMAScript specification). The difference is that ActionScript has the trace command to write out to a console.\\nor simply:\\n\\nSlightly different approach that makes use of the Decode function (⊥):\\nThe idea is to first calculate the residues for all numbers 1..100 after\\ndivision with both 3 and 5. This generates 100 pairs of numbers a b, where\\na is either 0,1,2 and b is either 0,1,2,3,4.\\nThese pairs are then put through the sign function which returns 0 for a 0,\\nand a 1 for anything greater than 0. Now we have binary pairs.\\nThe binary pairs are encoded with a left argument of 2 resulting in 0,1,2,3.\\nThese are treated as indices for the \""FizzBuzz vector\"" where 0 is in position 3.\\nVariable A holds this new vector of words and zeros.\\nVariable I is assigned the zeros' positions.\\nFinally A[I] is replaced with corresponding indices.\\nIf you have an aversion against mixed vectors, consider inserting ⍕¨ before the\\nfinal (i.e. left-most) assignment.\\nHere's a Dyalog-specific solution taking advantage of its anonymous function extension:\\n\\nOr, using map(), enumFromTo(), and a more functional pattern of composition:\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang#AsciiDots\\nSearch autohotkey.com: [1]\\nA short example with cascading ternary operators and graphical output. Press Esc to close the window.\\nOutput via MsgBox():\\nOutput via console, logfile and/or messagebox:\\nSee FizzBuzz/AWK\\nSee FizzBuzz/Basic#BaCon\\nAny bash hacker would do this as a one liner at the shell, so...\\nFor the sake of readability...\\nHere's a very concise approach, with only 75 characters total.\\nUnfortunately it relies on aspects of Bash which are rarely used.\\nHere's the concise approach again, this time separated into multiple lines.\\nIt's a bit silly to optimize such a small & fast program,\\nbut for the sake of algorithm analysis it's worth noting that\\nthe concise approach is reasonably efficient in several ways.\\nEach divisibility test appears in the code exactly once,\\nonly two variables are created,\\nand the approach avoids setting variables unnecessarily.\\nAs far as I can tell,\\nthe divisibility tests only fire the minimum number of times required\\nfor the general case (e.g. where the 100/3/5 constants can be changed),\\nunless you introduce more variables and test types.\\nCorrections invited.\\nI avoided analyzing the non-general case where 100/3/5 never change,\\nbecause one \""optimal\"" solution is to simply print the pre-computed answer,\\nSee FizzBuzz/Basic\\nFOR /L version:\\nLoop version:\\nFOR /L with a block instead of very-high-overhead subroutine call:\\nSee FizzBuzz/Basic\\nThis solution never uses else, because bc has no else keyword (but some implementations add else as an extension).\\nAlso see on FizzBuzz/EsoLang\\n“Ordinary” FizzBuzz solution:\\n\\nExample without double mod 5 check, using a flag instead, to check if Fizz already got printed (in this case the number n must not be printed if mod 5 is > 0):\\nSee FizzBuzz/EsoLang\\nSame code, pretty printed:\\nSee FizzBuzz/EsoLang\\nThe following C code was inspired by this ( low SignalToNoise, EasyToModify ) JavaScript:\\nWith 2 prime numbers, the C code is:\\nWith 4 prime numbers:\\nOne line version, with pretty printing\\nImplicit int main and return 0 (C99+):\\nobfuscated:\\nWithout conditionals, anything in the loop body gcc compiles with branching, duplicate tests or duplicate strings. Depends on ASCII and two's complement arithmetic:\\nTDD using delegates.\\nAlternate version not using modulo 15:\\nAlternate version that avoids using modulo. (Modulo can be expensive on some architectures.)\\nA version using std::transform:\\nVersion computing FizzBuzz at compile time with metaprogramming:\\nHardcore templates (compile with -ftemplate-depth-9000 -std=c++0x):\\nNote: it takes up lots of memory and takes several seconds to compile. To enable compilation for 7 < n <= 25, please, modify include/boost/mpl/limits/string.hpp BOOST_MPL_LIMIT_STRING_SIZE to 128 instead of 32).\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang\\nAlso compiles with Harbour (Harbour 3.2.0dev (r1405201749))\\nThe advantage of this approach is that it is trivial to add another factor:\\nI know this doesn't have the full-bodied, piquant flavor\\nexpected from COBOL, but it is a little shorter.\\nI think this shows clearly that it's resolving the problem and illuminating the rules specified\\nA solution that simply evaluates and adds.\\ncfscript version\\nSolution 1:\\nSolution 2:\\nSolution 3:\\nSolution 4:\\nSolution 5:\\nSolution 6:\\nSolution 7:\\nFirst 16 lines of output:\\nI use Allegro CL 10.1\\nOutput:\\nThe bc translation written in dc style.\\nFizzBuzz, realized using two different methods for string/character output:\\nOutput to STDOUT via single character output.\\nOutput to STDOUT, using stored strings and a separately defined string output operator:\\nused case\\nAlternate approach using pipes and cond:\\nused Stream.cycle version:\\nYet another approach:\\nused anonymous function\\nEnum.at version: Returns nil if index is out of bounds.\\nThe Stream.cycle version above, but as an overpowered FizzBuzz DSL.\\nA bit too simple:\\nA bit too clever:\\nThis is based on the VBScript example.\\nAnother example using (unnecessary) partial active pattern :D\\nMore flexible variant without divisibility tests.\\nSee FizzBuzz/EsoLang\\nNo 'MOD 15' needed.\\n","\\nprint (', '.join([(x%3<1)*'Fizz'+(x%5<1)*'Buzz' or str(x) for x in range(1,101)]))  \\n"
"Python","FizzBuzz","Write a program that prints the integers from   1   to   100   (inclusive).\\n\\nBut:\\n\\nThe   FizzBuzz   problem was presented as the lowest level of comprehension required to illustrate adequacy.\\n\\n\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nThe ActionScript solution works just like the JavaScript solution (they share the ECMAScript specification). The difference is that ActionScript has the trace command to write out to a console.\\nor simply:\\n\\nSlightly different approach that makes use of the Decode function (⊥):\\nThe idea is to first calculate the residues for all numbers 1..100 after\\ndivision with both 3 and 5. This generates 100 pairs of numbers a b, where\\na is either 0,1,2 and b is either 0,1,2,3,4.\\nThese pairs are then put through the sign function which returns 0 for a 0,\\nand a 1 for anything greater than 0. Now we have binary pairs.\\nThe binary pairs are encoded with a left argument of 2 resulting in 0,1,2,3.\\nThese are treated as indices for the \""FizzBuzz vector\"" where 0 is in position 3.\\nVariable A holds this new vector of words and zeros.\\nVariable I is assigned the zeros' positions.\\nFinally A[I] is replaced with corresponding indices.\\nIf you have an aversion against mixed vectors, consider inserting ⍕¨ before the\\nfinal (i.e. left-most) assignment.\\nHere's a Dyalog-specific solution taking advantage of its anonymous function extension:\\n\\nOr, using map(), enumFromTo(), and a more functional pattern of composition:\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang#AsciiDots\\nSearch autohotkey.com: [1]\\nA short example with cascading ternary operators and graphical output. Press Esc to close the window.\\nOutput via MsgBox():\\nOutput via console, logfile and/or messagebox:\\nSee FizzBuzz/AWK\\nSee FizzBuzz/Basic#BaCon\\nAny bash hacker would do this as a one liner at the shell, so...\\nFor the sake of readability...\\nHere's a very concise approach, with only 75 characters total.\\nUnfortunately it relies on aspects of Bash which are rarely used.\\nHere's the concise approach again, this time separated into multiple lines.\\nIt's a bit silly to optimize such a small & fast program,\\nbut for the sake of algorithm analysis it's worth noting that\\nthe concise approach is reasonably efficient in several ways.\\nEach divisibility test appears in the code exactly once,\\nonly two variables are created,\\nand the approach avoids setting variables unnecessarily.\\nAs far as I can tell,\\nthe divisibility tests only fire the minimum number of times required\\nfor the general case (e.g. where the 100/3/5 constants can be changed),\\nunless you introduce more variables and test types.\\nCorrections invited.\\nI avoided analyzing the non-general case where 100/3/5 never change,\\nbecause one \""optimal\"" solution is to simply print the pre-computed answer,\\nSee FizzBuzz/Basic\\nFOR /L version:\\nLoop version:\\nFOR /L with a block instead of very-high-overhead subroutine call:\\nSee FizzBuzz/Basic\\nThis solution never uses else, because bc has no else keyword (but some implementations add else as an extension).\\nAlso see on FizzBuzz/EsoLang\\n“Ordinary” FizzBuzz solution:\\n\\nExample without double mod 5 check, using a flag instead, to check if Fizz already got printed (in this case the number n must not be printed if mod 5 is > 0):\\nSee FizzBuzz/EsoLang\\nSame code, pretty printed:\\nSee FizzBuzz/EsoLang\\nThe following C code was inspired by this ( low SignalToNoise, EasyToModify ) JavaScript:\\nWith 2 prime numbers, the C code is:\\nWith 4 prime numbers:\\nOne line version, with pretty printing\\nImplicit int main and return 0 (C99+):\\nobfuscated:\\nWithout conditionals, anything in the loop body gcc compiles with branching, duplicate tests or duplicate strings. Depends on ASCII and two's complement arithmetic:\\nTDD using delegates.\\nAlternate version not using modulo 15:\\nAlternate version that avoids using modulo. (Modulo can be expensive on some architectures.)\\nA version using std::transform:\\nVersion computing FizzBuzz at compile time with metaprogramming:\\nHardcore templates (compile with -ftemplate-depth-9000 -std=c++0x):\\nNote: it takes up lots of memory and takes several seconds to compile. To enable compilation for 7 < n <= 25, please, modify include/boost/mpl/limits/string.hpp BOOST_MPL_LIMIT_STRING_SIZE to 128 instead of 32).\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang\\nAlso compiles with Harbour (Harbour 3.2.0dev (r1405201749))\\nThe advantage of this approach is that it is trivial to add another factor:\\nI know this doesn't have the full-bodied, piquant flavor\\nexpected from COBOL, but it is a little shorter.\\nI think this shows clearly that it's resolving the problem and illuminating the rules specified\\nA solution that simply evaluates and adds.\\ncfscript version\\nSolution 1:\\nSolution 2:\\nSolution 3:\\nSolution 4:\\nSolution 5:\\nSolution 6:\\nSolution 7:\\nFirst 16 lines of output:\\nI use Allegro CL 10.1\\nOutput:\\nThe bc translation written in dc style.\\nFizzBuzz, realized using two different methods for string/character output:\\nOutput to STDOUT via single character output.\\nOutput to STDOUT, using stored strings and a separately defined string output operator:\\nused case\\nAlternate approach using pipes and cond:\\nused Stream.cycle version:\\nYet another approach:\\nused anonymous function\\nEnum.at version: Returns nil if index is out of bounds.\\nThe Stream.cycle version above, but as an overpowered FizzBuzz DSL.\\nA bit too simple:\\nA bit too clever:\\nThis is based on the VBScript example.\\nAnother example using (unnecessary) partial active pattern :D\\nMore flexible variant without divisibility tests.\\nSee FizzBuzz/EsoLang\\nNo 'MOD 15' needed.\\n","[print(\""FizzBuzz\"") if i % 15 == 0 else print(\""Fizz\"") if i % 3 == 0 else print(\""Buzz\"") if i % 5 == 0 else print(i) for i in range(1,101)]"
"Python","FizzBuzz","Write a program that prints the integers from   1   to   100   (inclusive).\\n\\nBut:\\n\\nThe   FizzBuzz   problem was presented as the lowest level of comprehension required to illustrate adequacy.\\n\\n\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nSee FizzBuzz/Assembly\\nThe ActionScript solution works just like the JavaScript solution (they share the ECMAScript specification). The difference is that ActionScript has the trace command to write out to a console.\\nor simply:\\n\\nSlightly different approach that makes use of the Decode function (⊥):\\nThe idea is to first calculate the residues for all numbers 1..100 after\\ndivision with both 3 and 5. This generates 100 pairs of numbers a b, where\\na is either 0,1,2 and b is either 0,1,2,3,4.\\nThese pairs are then put through the sign function which returns 0 for a 0,\\nand a 1 for anything greater than 0. Now we have binary pairs.\\nThe binary pairs are encoded with a left argument of 2 resulting in 0,1,2,3.\\nThese are treated as indices for the \""FizzBuzz vector\"" where 0 is in position 3.\\nVariable A holds this new vector of words and zeros.\\nVariable I is assigned the zeros' positions.\\nFinally A[I] is replaced with corresponding indices.\\nIf you have an aversion against mixed vectors, consider inserting ⍕¨ before the\\nfinal (i.e. left-most) assignment.\\nHere's a Dyalog-specific solution taking advantage of its anonymous function extension:\\n\\nOr, using map(), enumFromTo(), and a more functional pattern of composition:\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang#AsciiDots\\nSearch autohotkey.com: [1]\\nA short example with cascading ternary operators and graphical output. Press Esc to close the window.\\nOutput via MsgBox():\\nOutput via console, logfile and/or messagebox:\\nSee FizzBuzz/AWK\\nSee FizzBuzz/Basic#BaCon\\nAny bash hacker would do this as a one liner at the shell, so...\\nFor the sake of readability...\\nHere's a very concise approach, with only 75 characters total.\\nUnfortunately it relies on aspects of Bash which are rarely used.\\nHere's the concise approach again, this time separated into multiple lines.\\nIt's a bit silly to optimize such a small & fast program,\\nbut for the sake of algorithm analysis it's worth noting that\\nthe concise approach is reasonably efficient in several ways.\\nEach divisibility test appears in the code exactly once,\\nonly two variables are created,\\nand the approach avoids setting variables unnecessarily.\\nAs far as I can tell,\\nthe divisibility tests only fire the minimum number of times required\\nfor the general case (e.g. where the 100/3/5 constants can be changed),\\nunless you introduce more variables and test types.\\nCorrections invited.\\nI avoided analyzing the non-general case where 100/3/5 never change,\\nbecause one \""optimal\"" solution is to simply print the pre-computed answer,\\nSee FizzBuzz/Basic\\nFOR /L version:\\nLoop version:\\nFOR /L with a block instead of very-high-overhead subroutine call:\\nSee FizzBuzz/Basic\\nThis solution never uses else, because bc has no else keyword (but some implementations add else as an extension).\\nAlso see on FizzBuzz/EsoLang\\n“Ordinary” FizzBuzz solution:\\n\\nExample without double mod 5 check, using a flag instead, to check if Fizz already got printed (in this case the number n must not be printed if mod 5 is > 0):\\nSee FizzBuzz/EsoLang\\nSame code, pretty printed:\\nSee FizzBuzz/EsoLang\\nThe following C code was inspired by this ( low SignalToNoise, EasyToModify ) JavaScript:\\nWith 2 prime numbers, the C code is:\\nWith 4 prime numbers:\\nOne line version, with pretty printing\\nImplicit int main and return 0 (C99+):\\nobfuscated:\\nWithout conditionals, anything in the loop body gcc compiles with branching, duplicate tests or duplicate strings. Depends on ASCII and two's complement arithmetic:\\nTDD using delegates.\\nAlternate version not using modulo 15:\\nAlternate version that avoids using modulo. (Modulo can be expensive on some architectures.)\\nA version using std::transform:\\nVersion computing FizzBuzz at compile time with metaprogramming:\\nHardcore templates (compile with -ftemplate-depth-9000 -std=c++0x):\\nNote: it takes up lots of memory and takes several seconds to compile. To enable compilation for 7 < n <= 25, please, modify include/boost/mpl/limits/string.hpp BOOST_MPL_LIMIT_STRING_SIZE to 128 instead of 32).\\nSee FizzBuzz/Basic\\nSee FizzBuzz/EsoLang\\nAlso compiles with Harbour (Harbour 3.2.0dev (r1405201749))\\nThe advantage of this approach is that it is trivial to add another factor:\\nI know this doesn't have the full-bodied, piquant flavor\\nexpected from COBOL, but it is a little shorter.\\nI think this shows clearly that it's resolving the problem and illuminating the rules specified\\nA solution that simply evaluates and adds.\\ncfscript version\\nSolution 1:\\nSolution 2:\\nSolution 3:\\nSolution 4:\\nSolution 5:\\nSolution 6:\\nSolution 7:\\nFirst 16 lines of output:\\nI use Allegro CL 10.1\\nOutput:\\nThe bc translation written in dc style.\\nFizzBuzz, realized using two different methods for string/character output:\\nOutput to STDOUT via single character output.\\nOutput to STDOUT, using stored strings and a separately defined string output operator:\\nused case\\nAlternate approach using pipes and cond:\\nused Stream.cycle version:\\nYet another approach:\\nused anonymous function\\nEnum.at version: Returns nil if index is out of bounds.\\nThe Stream.cycle version above, but as an overpowered FizzBuzz DSL.\\nA bit too simple:\\nA bit too clever:\\nThis is based on the VBScript example.\\nAnother example using (unnecessary) partial active pattern :D\\nMore flexible variant without divisibility tests.\\nSee FizzBuzz/EsoLang\\nNo 'MOD 15' needed.\\n","from itertools import cycle, izip, count, islice\\n\\nfizzes = cycle([\""\""] * 2 + [\""Fizz\""])\\nbuzzes = cycle([\""\""] * 4 + [\""Buzz\""])\\nboth = (f + b for f, b in izip(fizzes, buzzes))\\n\\n# if the string is \""\"", yield the number\\n# otherwise yield the string\\nfizzbuzz = (word or n for word, n in izip(both, count(1)))\\n\\n# print the first 100\\nfor i in islice(fizzbuzz, 100):\\n    print i"
"Python","Flatten_a_list","Write a function to flatten the nesting in an arbitrary   list of values.\\n\\nYour program should work on the equivalent of this list:\\nWhere the correct result would be the list:\\n\\n\\n",">>> def flatten(lst):\\n	return sum( ([x] if not isinstance(x, list) else flatten(x)\\n		     for x in lst), [] )\\n\\n>>> lst = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\\n>>> flatten(lst)\\n[1, 2, 3, 4, 5, 6, 7, 8]"
"Python","Flatten_a_list","Write a function to flatten the nesting in an arbitrary   list of values.\\n\\nYour program should work on the equivalent of this list:\\nWhere the correct result would be the list:\\n\\n\\n","from itertools import (chain)\\n\\n\\ndef flatten(x):\\n    return concatMap(flatten, x) if isinstance(x, list) else [x]\\n\\n\\ndef main():\\n    print(\\n        flatten([[1], 2, [[3, 4], 5], [[[]]], [[[6]]], 7, 8, []])\\n    )\\n\\n\\n# GENERIC -------------------------------------------------\\n\\n\\n# concatMap :: (a -> [b]) -> [a] -> [b]\\ndef concatMap(f, xs):\\n    return list(chain.from_iterable(map(f, xs)))\\n\\n\\nif __name__ == '__main__':\\n    main()"
"Python","Flatten_a_list","Write a function to flatten the nesting in an arbitrary   list of values.\\n\\nYour program should work on the equivalent of this list:\\nWhere the correct result would be the list:\\n\\n\\n","# concatMap :: (a -> [b]) -> [a] -> [b]\\ndef concatMap(f, xs):\\n    return sum(map(f, xs), [])"
"Python","Flatten_a_list","Write a function to flatten the nesting in an arbitrary   list of values.\\n\\nYour program should work on the equivalent of this list:\\nWhere the correct result would be the list:\\n\\n\\n",">>> def flat(lst):\\n    i=0\\n    while i>> lst = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\\n>>> flat(lst)\\n>>> lst\\n[1, 2, 3, 4, 5, 6, 7, 8]"
"Python","Flatten_a_list","Write a function to flatten the nesting in an arbitrary   list of values.\\n\\nYour program should work on the equivalent of this list:\\nWhere the correct result would be the list:\\n\\n\\n","from functools import (reduce)\\nfrom itertools import (chain)\\n\\n\\ndef flatten(xs):\\n    return reduce(\\n        lambda a, x: a + until(_all(notList))(\\n            concatMap(list)\\n        )([x]),\\n        xs, []\\n    )\\n\\n\\ndef main():\\n    print(\\n        flatten([1, [[[3]]], [[[4, 5, 6]]]])\\n    )\\n\\n\\n# GENERIC -------------------------------------------------------\\n\\n\\n# A generalised wrapper for the built-in `all` function,\\n# extending its range to non-Boolean lists.\\n# _all :: (a -> Bool) -> [a] -> Bool\\ndef _all(p):\\n    return lambda xs: all(map(p, xs))\\n\\n\\n# concatMap :: (a -> [b]) -> [a] -> [b]\\ndef concatMap(f):\\n    return lambda xs: list(chain.from_iterable(map(f, xs)))\\n\\n\\n# notList :: a -> Bool\\ndef notList(x):\\n    return not isinstance(x, list)\\n\\n\\n# until :: (a -> Bool) -> (a -> a) -> a -> a\\ndef until(p):\\n    def go(f, x):\\n        v = x\\n        while not p(v):\\n            v = f(v)\\n        return v\\n    return lambda f: lambda x: go(f, x)\\n\\n\\nmain()"
"Python","Flatten_a_list","Write a function to flatten the nesting in an arbitrary   list of values.\\n\\nYour program should work on the equivalent of this list:\\nWhere the correct result would be the list:\\n\\n\\n",">>> def flatten(lst):\\n     for x in lst:\\n         if isinstance(x, list):\\n             for x in flatten(x):\\n                 yield x\\n         else:\\n             yield x\\n \\n \\n>>> lst = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\\n>>> print list(flatten(lst)) \\n[1, 2, 3, 4, 5, 6, 7, 8]"
"Python","Flipping_bits_game","Given an N by N square array of zeroes or ones in an initial\\nconfiguration, and a target configuration of zeroes and ones\\nThe task is to transform one to the other in as few moves as\\npossible by inverting whole numbered rows or whole lettered\\ncolumns at once, as one move.\\nIn an inversion any 1 becomes 0, and any 0 becomes 1 for that\\nwhole row or column.\\nCreate a program to score for the Flipping bits game.\\n\\nShow an example of a short game here, on this page, for a 3 by 3 array of bits.\\n\\nThis solution determines the size of the playground from the command line.\\n","\""\""\""\\nGiven a %i by %i sqare array of zeroes or ones in an initial\\nconfiguration, and a target configuration of zeroes and ones\\nThe task is to transform one to the other in as few moves as \\npossible by inverting whole numbered rows or whole lettered \\ncolumns at once.\\nIn an inversion any 1 becomes 0 and any 0 becomes 1 for that\\nwhole row or column.\\n\\n\""\""\""\\n\\nfrom random import randrange\\nfrom copy import deepcopy\\nfrom string import ascii_lowercase\\n\\n\\ntry:    # 2to3 fix\\n    input = raw_input\\nexcept:\\n    pass\\n\\nN = 3   # N x N Square arrray\\n\\nboard  = [[0]* N for i in range(N)]\\n\\ndef setbits(board, count=1):\\n    for i in range(count):\\n        board[randrange(N)][randrange(N)] ^= 1\\n\\ndef shuffle(board, count=1):\\n    for i in range(count):\\n        if randrange(0, 2):\\n            fliprow(randrange(N))\\n        else:\\n            flipcol(randrange(N))\\n\\n\\ndef pr(board, comment=''):\\n    print(str(comment))\\n    print('     ' + ' '.join(ascii_lowercase[i] for i in range(N)))\\n    print('  ' + '\\n  '.join(' '.join(['%2s' % j] + [str(i) for i in line])\\n                             for j, line in enumerate(board, 1)))\\n\\ndef init(board):\\n    setbits(board, count=randrange(N)+1)\\n    target = deepcopy(board)\\n    while board == target:\\n        shuffle(board, count=2 * N)\\n    prompt = '  X, T, or 1-%i / %s-%s to flip: ' % (N, ascii_lowercase[0], \\n                                                    ascii_lowercase[N-1])\\n    return target, prompt\\n\\ndef fliprow(i):\\n    board[i-1][:] = [x ^ 1 for x in board[i-1] ]\\n    \\ndef flipcol(i):\\n    for row in board:\\n        row[i] ^= 1\\n\\nif __name__ == '__main__':\\n    print(__doc__ % (N, N))\\n    target, prompt = init(board)\\n    pr(target, 'Target configuration is:')\\n    print('')\\n    turns = 0\\n    while board != target:\\n        turns += 1\\n        pr(board, '%i:' % turns)\\n        ans = input(prompt).strip()\\n        if (len(ans) == 1 \\n            and ans in ascii_lowercase and ascii_lowercase.index(ans) < N):\\n            flipcol(ascii_lowercase.index(ans))\\n        elif ans and all(ch in '0123456789' for ch in ans) and 1 <= int(ans) <= N:\\n            fliprow(int(ans))\\n        elif ans == 'T':\\n            pr(target, 'Target configuration is:')\\n            turns -= 1\\n        elif ans == 'X':\\n            break\\n        else:\\n            print(\""  I don't understand %r... Try again. \""\\n                  \""(X to exit or T to show target)\\n\"" % ans[:9])\\n            turns -= 1\\n    else:\\n        print('\\nWell done!\\nBye.')"
"Python","Floyd's_triangle","Floyd's triangle   lists the natural numbers in a right triangle aligned to the left where\\n\\nThe first few lines of a Floyd triangle looks like this:\\n\\n\\nA very concise coding, an illustration of CISC power of the S/360 operation codes. Also an example of the use of EDMK and EX instructions.\\nFor macro usage see Structured Macros .\\n",">>> def floyd(rowcount=5):\\n	rows = [[1]]\\n	while len(rows) < rowcount:\\n		n = rows[-1][-1] + 1\\n		rows.append(list(range(n, n + len(rows[-1]) + 1)))\\n	return rows\\n\\n>>> floyd()\\n[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10], [11, 12, 13, 14, 15]]\\n>>> def pfloyd(rows=[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]):\\n	colspace = [len(str(n)) for n in rows[-1]]\\n	for row in rows:\\n		print( ' '.join('%*i' % space_n for space_n in zip(colspace, row)))\\n\\n		\\n>>> pfloyd()\\n1\\n2 3\\n4 5 6\\n7 8 9 10\\n>>> pfloyd(floyd(5))\\n 1\\n 2  3\\n 4  5  6\\n 7  8  9 10\\n11 12 13 14 15\\n>>> pfloyd(floyd(14))\\n 1\\n 2  3\\n 4  5  6\\n 7  8  9 10\\n11 12 13 14 15\\n16 17 18 19 20 21\\n22 23 24 25 26 27 28\\n29 30 31 32 33 34 35 36\\n37 38 39 40 41 42 43 44  45\\n46 47 48 49 50 51 52 53  54  55\\n56 57 58 59 60 61 62 63  64  65  66\\n67 68 69 70 71 72 73 74  75  76  77  78\\n79 80 81 82 83 84 85 86  87  88  89  90  91\\n92 93 94 95 96 97 98 99 100 101 102 103 104 105\\n>>> "
"Python","Floyd's_triangle","Floyd's triangle   lists the natural numbers in a right triangle aligned to the left where\\n\\nThe first few lines of a Floyd triangle looks like this:\\n\\n\\nA very concise coding, an illustration of CISC power of the S/360 operation codes. Also an example of the use of EDMK and EX instructions.\\nFor macro usage see Structured Macros .\\n","def floyd(rowcount=5):\\n    return [list(range(i*(i-1)//2+1, i*(i+1)//2+1))\\n            for i in range(1, rowcount+1)]"
"Python","Floyd's_triangle","Floyd's triangle   lists the natural numbers in a right triangle aligned to the left where\\n\\nThe first few lines of a Floyd triangle looks like this:\\n\\n\\nA very concise coding, an illustration of CISC power of the S/360 operation codes. Also an example of the use of EDMK and EX instructions.\\nFor macro usage see Structured Macros .\\n","from itertools import (islice)\\n\\n\\n# main :: IO ()\\ndef main():\\n    print(\\n        showFloyd(floydN(5))\\n    )\\n\\n\\n# floyd :: [Int] -> [Int]\\ndef floyd(xs):\\n    n = succ(len(xs))\\n    return [1] if n < 2 else (\\n        enumFromTo(succ(n * pred(n) // 2))(\\n            n * succ(n) // 2\\n        )\\n    )\\n\\n\\n# floydN :: Int -> [[Int]]\\ndef floydN(n):\\n    return take(n)(iterate(floyd)([1]))\\n\\n\\n# showFloyd :: [[Int]] -> String\\ndef showFloyd(xs):\\n    return unlines(str(x) for x in xs)\\n\\n\\n# GENERIC ABSTRACTIONS ------------------------------------\\n\\n\\n# enumFromTo :: Int -> Int -> [Int]\\ndef enumFromTo(m):\\n    return lambda n: list(range(m, 1 + n))\\n\\n\\n# iterate :: (a -> a) -> a -> Gen [a]\\ndef iterate(f):\\n    def go(x):\\n        v = x\\n        while True:\\n            yield(v)\\n            v = f(v)\\n    return lambda x: go(x)\\n\\n\\n# pred :: Int -> Int\\ndef pred(x):\\n    return x - 1\\n\\n\\n# succ :: Int -> Int\\ndef succ(x):\\n    return 1 + x\\n\\n\\n# take :: Int -> [a] -> [a]\\n# take :: Int -> String -> String\\ndef take(n):\\n    return lambda xs: (\\n        xs[0:n]\\n        if isinstance(xs, list)\\n        else list(islice(xs, n))\\n    )\\n\\n\\n# unlines :: [String] -> String\\ndef unlines(xs):\\n    return '\\n'.join(xs)\\n\\n\\nmain()"
"Python","Forest_fire","\\nImplement the Drossel and Schwabl definition of the forest-fire model.\\n\\nIt is basically a 2D   cellular automaton   where each cell can be in three distinct states (empty, tree and burning) and evolves according to the following rules (as given by Wikipedia)\\nNeighborhood is the   Moore neighborhood;   boundary conditions are so that on the boundary the cells are always empty (\""fixed\"" boundary condition).\\nAt the beginning, populate the lattice with empty and tree cells according to a specific probability (e.g. a cell has the probability 0.5 to be a tree). Then, let the system evolve.\\nTask's requirements do not include graphical display or the ability to change parameters (probabilities    p    and    f )   through a graphical or command line interface.\\n\\n\\nSample output:\\nOutput:\\nThis implementation uses AutoHotkey's pseudo-arrays to contain each cell.\\nThe size of the (square) map, probabilities, and characters which correspond to burning, tree, or empty can be edited at the beginning of the script.\\nSample Output using the default settings:\\nOutput:\\n\\n\\nFreeBASIC[edit]\\n'[RC] Forest Fire'written for FreeBASIC 'Program code based on BASIC256 from Rosettacode website'http://rosettacode.org/wiki/Forest_fire#BASIC256'06-10-2016 updated/tweaked the code'compile with fbc -s gui #Define M 400#Define N 640 Dim As Double     p = 0.003Dim As Double  fire = 0.00003'Dim As Double number1Dim As Integer gen, x, yDim As String press 'f0() and fn() use memory from the memory poolDim As UByte f0(), fn()ReDim f0(-1 To N +2, -1 To M +2)ReDim fn(-1 To N +2, -1 To M +2) Dim As UByte white  = 15  'color 15 is whiteDim As UByte yellow = 14  'color 14 is yellowDim As UByte black  = 0   'color 0 is blackDim As UByte green  = 2   'color 2 is greenDim As UByte red    = 4   'color 4 is red Screen 18 'Resolution 640x480 with at least 256 colorsRandomize Timer Locate 28,1BeepPrint \"" Welcome to Forest Fire\""Locate 29,1Print \"" press any key to start\""Sleep'Locate 28,1'Print \"" Welcome to Forest Fire\""Locate 29,1Print \""                       \"" ' 1 tree, 0 empty, 2 fireColor green ' this is green color for treesFor x = 1 To N  For y = 1 To M    If Rnd < 0.5 Then 'populate original tree density      f0(x,y) = 1      PSet (x,y)    End If  Next yNext x Color whiteLocate 29,1Print \"" Press any key to continue                        \""SleepLocate 29,1Print \"" Press 'space bar' to continue/pause, ESC to stop \"" Do  press = InKey  ScreenLock  For x = 1 To N    For y = 1 To M      If Not f0(x,y) And Rnd<P Then fn(x,y)=1      If f0(x,y)=2 Then fn(x,y)=0      If f0(x,y)=1 Then        fn(x,y) = 1        If f0(x-1,y-1)=2 OrElse f0(x,y-1)=2 OrElse f0(x+1,y-1)=2 Then fn(x,y)=2        If f0(x-1,y)=2 OrElse f0(x+1,y)=2 OrElse Rnd<fire Then fn(x,y)=2        If f0(x-1,y+1)=2 OrElse f0(x,y+1)=2 OrElse f0(x+1,y+1)=2 Then fn(x,y)=2      End If      'set up color and drawing      '0 empty (black),  1 tree (green), 2 fire (white)      If fn(x,y)=0 Then Color black 'empty      If fn(x,y)=1 Then Color green 'tree      If fn(x,y)=2 Then Color red   'fire      'plot x-1,y-1      PSet (x-1,y-1)    Next y  Next x  'print generation number  gen = gen + 1  Locate 28,1  Color white 'this is white color  Print \"" Generation number # \"";gen  'transfer new generation to current generation  For x = 1 To N    For y = 1 To M      f0(x,y) = fn(x,y)    Next y  Next x  ScreenUnlock   ' amount for sleep is in milliseconds, 1 = ignore key press  Sleep 50, 1  ' slow down a little ... goes too fast otherwise  If press = \"" \"" Then Sleep : press = InKey  If press = \""s\"" Then Sleep  ' return to do loop up top until \""esc\"" key is pressed.  ' clicking close windows \""X\"", closes the window immediately Loop Until press = Chr(27) OrElse press = Chr(255)+\""k\""If press = Chr(255) + \""k\"" Then End Locate 28,1Color whitePrint \"" You entered ESC - goodbye                        \""Print \"" Press any key to exit                            \""Sleep\\nGFA Basic[edit]\\n width%=80height%=50DIM world%(width%+2,height%+2,2)clock%=0'empty%=0 ! some mnemonic codes for the different statesburning%=1tree%=2'f=0.0003p=0.03max_clock%=100'@open_window@setup_worldDO  clock%=clock%+1  EXIT IF clock%>max_clock%  @display_world  @update_worldLOOP@close_window'' Setup the world'PROCEDURE setup_world  LOCAL i%,j%  '  RANDOMIZE 0  ARRAYFILL world%(),empty%  ' with Probability 0.5, create tree in cells  FOR i%=1 TO width%    FOR j%=1 TO height%      IF RND>0.5        world%(i%,j%,0)=tree%      ENDIF    NEXT j%  NEXT i%  '  cur%=0  new%=1RETURN'' Display world on window'PROCEDURE display_world  LOCAL size%,i%,j%,offsetx%,offsety%,x%,y%  '  size%=5  offsetx%=10  offsety%=20  '  VSETCOLOR 0,15,15,15 ! colour for empty  VSETCOLOR 1,15,0,0 ! colour for burning  VSETCOLOR 2,0,15,0 ! colour for tree  VSETCOLOR 3,0,0,0 ! colour for text  DEFTEXT 3  PRINT AT(1,1);\""Clock: \"";clock%  '  FOR i%=1 TO width%    FOR j%=1 TO height%      x%=offsetx%+size%*i%      y%=offsety%+size%*j%      SELECT world%(i%,j%,cur%)      CASE empty%        DEFFILL 0      CASE tree%        DEFFILL 2      CASE burning%        DEFFILL 1      ENDSELECT      PBOX x%,y%,x%+size%,y%+size%    NEXT j%  NEXT i%RETURN'' Check if a neighbour is burning'FUNCTION neighbour_burning(i%,j%)  LOCAL x%  '  IF world%(i%,j%-1,cur%)=burning%    RETURN TRUE  ENDIF  IF world%(i%,j%+1,cur%)=burning%    RETURN TRUE  ENDIF  FOR x%=-1 TO 1    IF world%(i%-1,j%+x%,cur%)=burning% OR world%(i%+1,j%+x%,cur%)=burning%      RETURN TRUE    ENDIF  NEXT x%  RETURN FALSEENDFUNC'' Update the world state'PROCEDURE update_world  LOCAL i%,j%  '  FOR i%=1 TO width%    FOR j%=1 TO height%      world%(i%,j%,new%)=world%(i%,j%,cur%)      SELECT world%(i%,j%,cur%)      CASE empty%        IF RND>1-p          world%(i%,j%,new%)=tree%        ENDIF      CASE tree%        IF @neighbour_burning(i%,j%) OR RND>1-f          world%(i%,j%,new%)=burning%        ENDIF      CASE burning%        world%(i%,j%,new%)=empty%      ENDSELECT    NEXT j%  NEXT i%  '  cur%=1-cur%  new%=1-new%RETURN'' open and clear window'PROCEDURE open_window  OPENW 1  CLEARW 1  VSETCOLOR 4,8,8,0  DEFFILL 4  PBOX 0,0,500,400RETURN'' close the window after keypress'PROCEDURE close_window  ~INP(2)  CLOSEW 1RETURN \\nPureBasic[edit]\\n; Some systems reports high CPU-load while running this code.; This may likely be due to the graphic driver used in the ; 2D-function Plot().; If experiencing this problem, please reduce the #Width & #Height; or activate the parameter #UnLoadCPU below with a parameter 1 or 2.;; This code should work with the demo version of PureBasic on both PC & Linux ; General parameters for the world#f    = 1e-6#p    = 1e-2#SeedATree  = 0.005#Width      = 400#Height     = 400 ; Setting up colours#Fire       = $080CF7#BackGround = $BFD5D3#YoungTree  = $00E300#NormalTree = $00AC00#MatureTree = $009500#OldTree    = $007600#Black      = $000000 ; Depending on your hardware, use this to control the speed/CPU-load.; 0 = No load reduction; 1 = Only active about every second frame; 2 = '1' & release the CPU after each horizontal line.#UnLoadCPU  = 0 Enumeration  #Empty  =0  #Ignited  #Burning  #Tree  #Old=#Tree+20EndEnumeration Global Dim Forest.i(#Width, #Height)Global Title$=\""Forest fire in PureBasic\""Global Cnt Macro Rnd()  (Random(2147483647)/2147483647.0)EndMacro Procedure Limit(n, min, max)  If n<min    n=min  ElseIf n>max    n=max  EndIf  ProcedureReturn nEndProcedure Procedure SpreadFire(x,y)  Protected cnt=0, i, j  For i=Limit(x-1, 0, #Width) To Limit(x+1, 0, #Width)    For j=Limit(y-1, 0, #Height) To Limit(y+1, 0, #Height)       If Forest(i,j)>=#Tree        Forest(i,j)=#Ignited      EndIf    Next  NextEndProcedure Procedure InitMap()  Protected x, y, type  For y=1 To #Height    For x=1 To #Width      If Rnd()<=#SeedATree        type=#Tree      Else        type=#Empty      EndIf      Forest(x,y)=type    Next  NextEndProcedure Procedure UpdateMap()  Protected x, y  For y=1 To #Height    For x=1 To #Width      Select Forest(x,y)        Case #Burning          Forest(x,y)=#Empty          SpreadFire(x,y)        Case #Ignited          Forest(x,y)=#Burning        Case #Empty          If Rnd()<=#p            Forest(x,y)=#Tree          EndIf        Default          If Rnd()<=#f            Forest(x,y)=#Burning          Else            Forest(x,y)+1          EndIf      EndSelect    Next  NextEndProcedure Procedure PresentMap()  Protected x, y, c    cnt+1  SetWindowTitle(0,Title$+\"", time frame=\""+Str(cnt))  StartDrawing(ImageOutput(1))  For y=0 To OutputHeight()-1    For x=0 To OutputWidth()-1      Select Forest(x,y)        Case #Empty          c=#BackGround        Case #Burning, #Ignited          c=#Fire        Default          If Forest(x,y)<#Tree+#Old            c=#YoungTree          ElseIf Forest(x,y)<#Tree+2*#Old            c=#NormalTree          ElseIf Forest(x,y)<#Tree+3*#Old            c=#MatureTree          ElseIf Forest(x,y)<#Tree+4*#Old            c=#OldTree          Else ; Tree died of old age            Forest(x,y)=#Empty            c=#Black          EndIf      EndSelect      Plot(x,y,c)    Next    CompilerIf #UnLoadCPU>1      Delay(1)    CompilerEndIf  Next  StopDrawing()  ImageGadget(1, 0, 0, #Width, #Height, ImageID(1))EndProcedure If OpenWindow(0, 10, 30, #Width, #Height, Title$, #PB_Window_MinimizeGadget)  SmartWindowRefresh(0, 1)  If CreateImage(1, #Width, #Height)    Define Event, freq    If ExamineDesktops() And DesktopFrequency(0)      freq=DesktopFrequency(0)    Else      freq=60    EndIf    AddWindowTimer(0,0,5000/freq)    InitMap()    Repeat      Event = WaitWindowEvent()      Select Event        Case #PB_Event_CloseWindow          End        Case #PB_Event_Timer          CompilerIf #UnLoadCPU>0            Delay(25)          CompilerEndIf          UpdateMap()          PresentMap()      EndSelect    ForEver  EndIf EndIf\\n\\n\\nREALbasic[edit]\\nThis example puts all of the forestry logic into a Thread class. This allows the UI to remain responsive while the Thread does all the work in the background. We create a Thread by subclassing the Thread object in the IDE, in this case creating forestfire as a subclass of the Thread object and put the following code in its Run() event:\\n\\n Sub Run()  //Handy named constants  Const empty = 0  Const tree = 1  Const fire = 2  Const ablaze = &cFF0000    //Using the &c numeric operator to indicate a color in hex  Const alive = &c00FF00  Const dead = &c804040   //Our forest  Dim worldPic As New Picture(480, 480, 32)  Dim newWorld(120, 120) As Integer  Dim oldWorld(120, 120) As Integer   //Initialize forest  Dim rand As New Random  For x as Integer = 0 to 119    For y as Integer = 0 to 119      if rand.InRange(0, 2) = 0 Or x = 119 or y = 119 or x = 0 or y = 0 Then        newWorld(x, y) = empty        worldPic.Graphics.ForeColor = dead        worldPic.Graphics.FillRect(x*4, y*4, 4, 4)      Else        newWorld(x, y) = tree        worldPic.Graphics.ForeColor = alive        worldPic.Graphics.FillRect(x*4, y*4, 4, 4)      end if    Next  Next  oldWorld = newWorld   //Burn, baby burn!  While Window1.stop = False    For x as Integer = 0 To 119      For y As Integer = 0 to 119        Dim willBurn As Integer = rand.InRange(0, Window1.burnProb.Value)        Dim willGrow As Integer = rand.InRange(0, Window1.growProb.Value)        if x = 119 or y = 119 or x = 0 or y = 0 Then          Continue        end if        Select Case oldWorld(x, y)        Case empty          If willGrow = (Window1.growProb.Value) Then            newWorld(x, y) = tree            worldPic.Graphics.ForeColor = alive            worldPic.Graphics.FillRect(x*4, y*4, 4, 4)          end if        Case tree          if oldWorld(x - 1, y) = fire Or oldWorld(x, y - 1) = fire Or oldWorld(x + 1, y) = fire Or oldWorld(x, y + 1) = fire Or oldWorld(x + 1, y + 1) = fire Or oldWorld(x - 1, y - 1) = fire Or oldWorld(x - 1, y + 1) = fire Or oldWorld(x + 1, y - 1) = fire Or willBurn = (Window1.burnProb.Value) Then            newWorld(x, y) = fire            worldPic.Graphics.ForeColor = ablaze            worldPic.Graphics.FillRect(x*4, y*4, 4, 4)          end if        Case fire          newWorld(x, y) = empty          worldPic.Graphics.ForeColor = dead          worldPic.Graphics.FillRect(x*4, y*4, 4, 4)        End Select      Next    Next    Window1.Canvas1.Graphics.DrawPicture(worldPic, 0, 0)    oldWorld = newWorld    me.Sleep(Window1.speed.Value)  WendEnd Sub \\nAs you can see, this Thread is expecting a Window object called Window1 with several other objects within it. The IDE will automatically create a Window object called Window1 when a new GUI application is created. Our Window1 has 5 objects (widgets) in it: a Canvas (for displaying graphics), three sliders, and a pushbutton.\\n\\n Sub Open()  //First method to run on the creation of a new Window. We instantiate an instance of our forestFire thread and run it.  Dim fire As New forestFire  fire.Run()End Sub stop As Boolean  //a globally accessible property of Window1. Boolean properties default to False. Sub Pushbutton1.Action()  stop = TrueEnd Sub \\n\\n\\nRun BASIC[edit]\\ngraphic #g, 200,200dim preGen(200,200)dim newGen(200,200) for gen = 1 to 200  for x = 1 to 199    for y = 1 to 199      select case preGen(x,y)        case 0          if rnd(0) > .99 then newGen(x,y) = 1  : #g \""color green ; set \""; x; \"" \""; y        case 2          newGen(x,y) = 0                       : #g \""color brown ; set \""; x; \"" \""; y        case 1          if preGen(x-1,y-1) = 2 or preGen(x-1,y)   = 2 or preGen(x-1,y+1) = 2 _          or preGen(x,y-1)   = 2 or preGen(x,y+1)   = 2 or preGen(x+1,y-1) = 2 _          or preGen(x+1,y)   = 2 or preGen(x+1,y+1) = 2 or rnd(0) > .999 then              #g \""color red ; set \""; x; \"" \""; y              newGen(x,y) = 2          end if      end select      preGen(x-1,y-1) = newGen(x-1,y-1)    next y  next xnext genrender #g\\n\\n\\nSinclair ZX81 BASIC[edit]\\nRequires 16k of RAM.\\nIn essence this is an enhanced version of my ZX Spectrum implementation (see below). The main improvement is that this version shows the ages of the trees: the age is represented using 0 to 9, then A to Z, followed theoretically by the special characters £$:?()><=+-*/;,. (in that order) and only then cycling back to 0. Realistically, no tree is likely to live that long.\\nThe subroutine at line 1000 takes a number N and returns its inverse-video string representation as I$.\\nA couple of other notes on the listing:\\n(1) some characters need to be entered in Graphics mode, which is accessed using SHIFT9. I have represented this using square brackets: so if the listing says [ROSETTA CODE], you need to go into G mode and type ROSETTA CODE (which will be displayed on the ZX81 screen in inverse video). As a special case, [a] means for you to go into G mode and then type SHIFTA. The ZX81 character set does not include either square brackets or lower-case letters, so I hope this convention will not lead to too much confusion.\\n(2) this program differs from most BASIC examples on Rosetta Code, but resembles most real BASIC programs of more than about 20 lines, in that the line numbers do not always go up smoothly in multiples of ten.\\n\\n  10 DIM F$(20,30)  20 DIM N$(20,30)  30 LET INIT=.5  40 LET F=.02  50 LET P=.05  60 PRINT AT 0,1;\""[FOREST FIRE   FOR ROSETTA CODE]\""  70 FOR I=0 TO 21  80 PRINT AT I,0;\""[ ]\""  90 PRINT AT I,31;\""[ ]\"" 100 NEXT I 110 FOR I=1 TO 30 120 PRINT AT 21,I;\""[ ]\"" 130 NEXT I 140 LET G=0 150 LET T=0 160 PRINT AT 21,1;\""[GENERATION 0]\"" 170 PRINT AT 21,20;\""[COVER]\"" 180 FOR I=1 TO 20 190 FOR J=1 TO 30 200 IF RND>=INIT THEN GOTO 240 210 PRINT AT I,J;\""0\"" 220 LET F$(I,J)=\""0\"" 230 LET T=T+1 240 NEXT J 250 NEXT I 300 PRINT AT 21,26;\""[      ]\"" 310 LET N=INT (.5+T/6) 320 GOSUB 1000 330 PRINT AT 21,26;I$;\""[ PC]\"" 340 FOR I=1 TO 20 350 PRINT AT I,0;\""[>]\"" 360 FOR J=1 TO 30 380 IF F$(I,J)<>\""[a]\"" THEN GOTO 410 390 LET N$(I,J)=\"" \"" 400 GOTO 530 410 IF F$(I,J)<>\"" \"" THEN GOTO 433 420 IF RND<=P THEN LET N$(I,J)=\""0\"" 430 GOTO 530 433 LET N$(I,J)=CHR$ (1+CODE F$(I,J)) 437 IF N$(I,J)>\""Z\"" THEN LET N$(I,J)=\""£\"" 440 FOR K=I-1 TO I+1 450 FOR L=J-1 TO J+1 460 IF K=0 OR L=0 OR K=21 OR L=21 THEN GOTO 480 470 IF F$(K,L)=\""[a]\"" THEN GOTO 510 480 NEXT L 490 NEXT K 500 GOTO 520 510 LET N$(I,J)=\""[a]\"" 520 IF RND<=F THEN LET N$(I,J)=\""[a]\"" 530 NEXT J 540 PRINT AT I,0;\""[ ]\"" 550 NEXT I 552 LET G=G+1 554 LET N=G 556 GOSUB 1000 558 PRINT AT 21,12;I$ 560 LET T=0 570 FOR I=1 TO 20 575 PRINT AT I,31;\""[<]\"" 580 FOR J=1 TO 30 590 IF N$(I,J)<>\""[a]\"" AND N$(I,J)<>\"" \"" THEN LET T=T+1 600 NEXT J 610 LET F$(I)=N$(I) 620 PRINT AT I,1;F$(I) 625 PRINT AT I,31;\""[ ]\"" 630 GOTO 3001000 LET S$=STR$ N1010 LET I$=\""\""1020 FOR K=1 TO LEN S$1030 LET I$=I$+CHR$ (128+CODE S$(K))1040 NEXT K1050 RETURN\\n\\nOutput:\\nThis example puts all of the forestry logic into a Thread class. This allows the UI to remain responsive while the Thread does all the work in the background. We create a Thread by subclassing the Thread object in the IDE, in this case creating forestfire as a subclass of the Thread object and put the following code in its Run() event:\\nAs you can see, this Thread is expecting a Window object called Window1 with several other objects within it. The IDE will automatically create a Window object called Window1 when a new GUI application is created. Our Window1 has 5 objects (widgets) in it: a Canvas (for displaying graphics), three sliders, and a pushbutton.\\n\\n\\nRequires 16k of RAM.\\nIn essence this is an enhanced version of my ZX Spectrum implementation (see below). The main improvement is that this version shows the ages of the trees: the age is represented using 0 to 9, then A to Z, followed theoretically by the special characters £$:?()><=+-*/;,. (in that order) and only then cycling back to 0. Realistically, no tree is likely to live that long.\\nThe subroutine at line 1000 takes a number N and returns its inverse-video string representation as I$.\\nA couple of other notes on the listing:\\n(1) some characters need to be entered in Graphics mode, which is accessed using SHIFT9. I have represented this using square brackets: so if the listing says [ROSETTA CODE], you need to go into G mode and type ROSETTA CODE (which will be displayed on the ZX81 screen in inverse video). As a special case, [a] means for you to go into G mode and then type SHIFTA. The ZX81 character set does not include either square brackets or lower-case letters, so I hope this convention will not lead to too much confusion.\\n(2) this program differs from most BASIC examples on Rosetta Code, but resembles most real BASIC programs of more than about 20 lines, in that the line numbers do not always go up smoothly in multiples of ten.\\n","'''\\nForest-Fire Cellular automation\\n See: http://en.wikipedia.org/wiki/Forest-fire_model\\n'''\\n\\nL = 15\\n# d = 2 # Fixed\\ninitial_trees = 0.55\\np = 0.01\\nf = 0.001\\n\\ntry:\\n    raw_input\\nexcept:\\n    raw_input = input\\n    \\nimport random\\n\\n\\ntree, burning, space = 'TB.'\\nhood = ((-1,-1), (-1,0), (-1,1),\\n        (0,-1),          (0, 1),\\n        (1,-1),  (1,0),  (1,1))\\n\\ndef initialise():\\n    grid = {(x,y): (tree if random.random()<= initial_trees else space)\\n            for x in range(L)\\n            for y in range(L) }\\n    return grid\\n\\ndef gprint(grid):\\n    txt = '\\n'.join(''.join(grid[(x,y)] for x in range(L))\\n                    for y in range(L))\\n    print(txt)\\n\\ndef quickprint(grid):\\n    t = b = 0\\n    ll = L * L\\n    for x in range(L):\\n        for y in range(L):\\n            if grid[(x,y)] in (tree, burning):\\n                t += 1\\n                if grid[(x,y)] == burning:\\n                    b += 1\\n    print(('Of %6i cells, %6i are trees of which %6i are currently burning.'\\n          + ' (%6.3f%%, %6.3f%%)')\\n          % (ll, t, b, 100. * t / ll, 100. * b / ll))\\n                \\n\\ndef gnew(grid):\\n    newgrid = {}\\n    for x in range(L):\\n        for y in range(L):\\n            if grid[(x,y)] == burning:\\n                newgrid[(x,y)] = space\\n            elif grid[(x,y)] == space:\\n                newgrid[(x,y)] = tree if random.random()<= p else space\\n            elif grid[(x,y)] == tree:\\n                newgrid[(x,y)] = (burning\\n                                   if any(grid.get((x+dx,y+dy),space) == burning\\n                                            for dx,dy in hood)\\n                                        or random.random()<= f \\n                                   else tree)\\n    return newgrid\\n\\nif __name__ == '__main__':\\n    grid = initialise()\\n    iter = 0\\n    while True:\\n        quickprint(grid)\\n        inp = raw_input('Print/Quit/<int>/<return> %6i: ' % iter).lower().strip()\\n        if inp:\\n            if inp[0] == 'p':\\n                gprint(grid)\\n            elif inp.isdigit():\\n                for i in range(int(inp)):\\n                    iter +=1\\n                    grid = gnew(grid)\\n                    quickprint(grid)\\n            elif inp[0] == 'q':\\n                break\\n        grid = gnew(grid)\\n        iter +=1"
"Python","Fork","Spawn a new process which can run simultaneously with, and independently of, the original parent process.\\n\\nOutput:\\n","import os\\n\\npid = os.fork()\\nif pid > 0:\\n # parent code\\nelse:\\n # child code"
"Python","Formal_power_series","A power series is an infinite sum of the form\\n\\n\\n\\n\\n\\na\\n\\n0\\n\\n\\n+\\n\\na\\n\\n1\\n\\n\\n⋅\\nx\\n+\\n\\na\\n\\n2\\n\\n\\n⋅\\n\\nx\\n\\n2\\n\\n\\n+\\n\\na\\n\\n3\\n\\n\\n⋅\\n\\nx\\n\\n3\\n\\n\\n+\\n⋯\\n\\n\\n{\\displaystyle a_{0}+a_{1}\\cdot x+a_{2}\\cdot x^{2}+a_{3}\\cdot x^{3}+\\cdots }\\n\\n\\nThe ai are called the coefficients of the series. Such sums can be added, multiplied etc., where the new coefficients of the powers of x are calculated according to the usual rules.\\nIf one is not interested in evaluating such a series for particular values of x, or in other words, if convergence doesn't play a role, then such a collection of coefficients is called formal power series. It can be treated like a new kind of number.\\nTask: Implement formal power series as a numeric type. Operations should at least include addition, multiplication, division and additionally non-numeric operations like differentiation and integration (with an integration constant of zero). Take care that your implementation deals with the potentially infinite number of coefficients.\\nAs an example, define the power series of sine and cosine in terms of each other using integration, as in\\n\\n\\n\\n\\nsin\\n⁡\\nx\\n=\\n\\n∫\\n\\n0\\n\\n\\nx\\n\\n\\ncos\\n⁡\\nt\\n\\nd\\nt\\n\\n\\n{\\displaystyle \\sin x=\\int _{0}^{x}\\cos t\\,dt}\\n\\n\\n\\n\\n\\n\\ncos\\n⁡\\nx\\n=\\n1\\n−\\n\\n∫\\n\\n0\\n\\n\\nx\\n\\n\\nsin\\n⁡\\nt\\n\\nd\\nt\\n\\n\\n{\\displaystyle \\cos x=1-\\int _{0}^{x}\\sin t\\,dt}\\n\\n\\nGoals: Demonstrate how the language handles new numeric types and delayed (or lazy) evaluation.\\nThe Taylor series package is generic to be instantiated with any rational type implementation provided by the task Rational Arithmetic:\\nThe package implementation:\\nThe procedure Normalize is used to truncate the series when the coefficients are zero. The summation of a series (function Value) uses Horner scheme.\\nSample output:\\nThis version takes advantage of the laziness of most of Clojure's sequence functions, including map, for, take-while, concat, and drop. A formal power series (FPS) is represented as a sequence of coefficients; for example, [1 2 3] represents 1 + 2*x + 3*x*x.\\nFirst addition and subtraction. Note that most of the complication arises in allowing for finite and infinite FPSs; if only infinite power series were at issue, the function (defn ips+ [ips0 ips1] (map + ips0 ips1)) would suffice.\\nMultiplication next; again most of the complication is dealing with both finite and infinite FPS. This function explicitly uses the standard function lazy-seq to define the product sequence.\\nAs with most of the other examples on this page, there's no definition for division. Mathematically, FPS is a commutative ring (in fact a Euclidean domain), but not a field: the set of FPSs is not closed under division.\\nNow we can define integration and differentiation:\\nSome examples of using these functions; in each case a println call (which forces the lazy sequence) is followed by a comment showing the output.\\nAnd some examples using infinite FPSs. First define the sequence of factorials (facts), then define sin and cos Taylor series.\\nBy using letfn, which supports defining mutually recursive functions, we can define the sin and cos power series directly in terms of integrals of the other series:\\nCommon Lisp isn't lazy, and doesn't define the arithmetic operators as generic functions. As such, this implementation defines lazy primitives (delay and force), and a lazy list built on top of them (lons, lar, ldr). This implementation also defines a package #:formal-power-series which uses all the symbols of the \""COMMON-LISP\"" package except for +, -, *, and /, which are shadowed. Shadowing these symbols allows for definitions of generic functions which can be specialized for the power series, can default to the normal CL arithmetic operations for other kinds of objects, and can do \""the right thing\"" for mixes thereof.\\nA few utilities to make working with lazy lists easier.\\nThe mathematical operations here are translations of the Haskell code, but we specialize the operations in various ways so that behavior for normal numeric operations is preserved.\\nFollowing is a simple implementation of formal power series in C. It's not \""new datatype for the language\"" per se, but does demonstrate how lazy evaluation and infinite list generation can be done for this task. Note that, to be of real use, one should also cache terms looked up and free up memory. Both are trivially done (I actually had them, but removed them for simplicity).\\nCos: 1 0 -0.5 0 0.0416667 0 -0.00138889 0 2.48016e-05 0\\nTan: 0 1 0 0.333333 0 0.133333 0 0.0539683 0 0.0218695\\nSee Formal_power_series/D.\\nWe implement infinite formal power series (FPS) using streams. No operator overloading in EchoLisp, so we provide the operators s-add, s-mul ,.. which implement the needed operations. poly->stream converts a finite polynomial into an infinite FPS, and s-value gives the value of a FPS at x.\\n","''' \\\\nFor a discussion on pipe() and head() see\\n  http://paddy3118.blogspot.com/2009/05/pipe-fitting-with-python-generators.html\\n'''\\n\\nfrom itertools import islice\\nfrom fractions import Fraction\\nfrom functools import reduce\\ntry:\\n    from itertools import izip as zip # for 2.6\\nexcept:\\n    pass\\n\\ndef head(n):\\n    ''' return a generator that passes through at most n items\\n    '''\\n    return lambda seq: islice(seq, n)\\n\\ndef pipe(gen, *cmds):\\n    ''' pipe(a,b,c,d, ...) -> yield from ...d(c(b(a)))\\n    '''\\n    return reduce(lambda gen, cmd: cmd(gen), cmds, gen)\\n\\ndef sinepower():\\n    n = 0\\n    fac = 1\\n    sign = +1\\n    zero = 0\\n    yield zero\\n    while True:\\n        n +=1\\n        fac *= n\\n        yield Fraction(1, fac*sign)\\n        sign = -sign\\n        n +=1\\n        fac *= n\\n        yield zero\\ndef cosinepower():\\n    n = 0\\n    fac = 1\\n    sign = +1\\n    yield Fraction(1,fac)\\n    zero = 0\\n    while True:\\n        n +=1\\n        fac *= n\\n        yield zero\\n        sign = -sign\\n        n +=1\\n        fac *= n\\n        yield Fraction(1, fac*sign)\\ndef pluspower(*powergenerators):\\n    for elements in zip(*powergenerators):\\n        yield sum(elements)\\ndef minuspower(*powergenerators):\\n    for elements in zip(*powergenerators):\\n        yield elements[0] - sum(elements[1:])\\ndef mulpower(fgen,ggen):\\n    'From: http://en.wikipedia.org/wiki/Power_series#Multiplication_and_division'\\n    a,b = [],[]\\n    for f,g in zip(fgen, ggen):\\n        a.append(f)\\n        b.append(g)\\n        yield sum(f*g for f,g in zip(a, reversed(b)))\\ndef constpower(n):\\n    yield n\\n    while True:\\n        yield 0\\ndef diffpower(gen):\\n    'differentiatiate power series'\\n    next(gen)\\n    for n, an in enumerate(gen, start=1):\\n        yield an*n\\ndef intgpower(k=0):\\n    'integrate power series with constant k'\\n    def _intgpower(gen):\\n        yield k\\n        for n, an in enumerate(gen, start=1):\\n            yield an * Fraction(1,n)\\n    return _intgpower\\n\\n\\nprint(\""cosine\"")\\nc = list(pipe(cosinepower(), head(10)))\\nprint(c)\\nprint(\""sine\"")\\ns = list(pipe(sinepower(), head(10)))\\nprint(s)\\n# integrate cosine\\nintegc = list(pipe(cosinepower(),intgpower(0), head(10)))\\n# 1 - (integrate sine)\\nintegs1 = list(minuspower(pipe(constpower(1), head(10)),\\n                          pipe(sinepower(),intgpower(0), head(10))))\\n\\nassert s == integc, \""The integral of cos should be sin\""\\nassert c == integs1, \""1 minus the integral of sin should be cos\"""
"Python","Formal_power_series","A power series is an infinite sum of the form\\n\\n\\n\\n\\n\\na\\n\\n0\\n\\n\\n+\\n\\na\\n\\n1\\n\\n\\n⋅\\nx\\n+\\n\\na\\n\\n2\\n\\n\\n⋅\\n\\nx\\n\\n2\\n\\n\\n+\\n\\na\\n\\n3\\n\\n\\n⋅\\n\\nx\\n\\n3\\n\\n\\n+\\n⋯\\n\\n\\n{\\displaystyle a_{0}+a_{1}\\cdot x+a_{2}\\cdot x^{2}+a_{3}\\cdot x^{3}+\\cdots }\\n\\n\\nThe ai are called the coefficients of the series. Such sums can be added, multiplied etc., where the new coefficients of the powers of x are calculated according to the usual rules.\\nIf one is not interested in evaluating such a series for particular values of x, or in other words, if convergence doesn't play a role, then such a collection of coefficients is called formal power series. It can be treated like a new kind of number.\\nTask: Implement formal power series as a numeric type. Operations should at least include addition, multiplication, division and additionally non-numeric operations like differentiation and integration (with an integration constant of zero). Take care that your implementation deals with the potentially infinite number of coefficients.\\nAs an example, define the power series of sine and cosine in terms of each other using integration, as in\\n\\n\\n\\n\\nsin\\n⁡\\nx\\n=\\n\\n∫\\n\\n0\\n\\n\\nx\\n\\n\\ncos\\n⁡\\nt\\n\\nd\\nt\\n\\n\\n{\\displaystyle \\sin x=\\int _{0}^{x}\\cos t\\,dt}\\n\\n\\n\\n\\n\\n\\ncos\\n⁡\\nx\\n=\\n1\\n−\\n\\n∫\\n\\n0\\n\\n\\nx\\n\\n\\nsin\\n⁡\\nt\\n\\nd\\nt\\n\\n\\n{\\displaystyle \\cos x=1-\\int _{0}^{x}\\sin t\\,dt}\\n\\n\\nGoals: Demonstrate how the language handles new numeric types and delayed (or lazy) evaluation.\\nThe Taylor series package is generic to be instantiated with any rational type implementation provided by the task Rational Arithmetic:\\nThe package implementation:\\nThe procedure Normalize is used to truncate the series when the coefficients are zero. The summation of a series (function Value) uses Horner scheme.\\nSample output:\\nThis version takes advantage of the laziness of most of Clojure's sequence functions, including map, for, take-while, concat, and drop. A formal power series (FPS) is represented as a sequence of coefficients; for example, [1 2 3] represents 1 + 2*x + 3*x*x.\\nFirst addition and subtraction. Note that most of the complication arises in allowing for finite and infinite FPSs; if only infinite power series were at issue, the function (defn ips+ [ips0 ips1] (map + ips0 ips1)) would suffice.\\nMultiplication next; again most of the complication is dealing with both finite and infinite FPS. This function explicitly uses the standard function lazy-seq to define the product sequence.\\nAs with most of the other examples on this page, there's no definition for division. Mathematically, FPS is a commutative ring (in fact a Euclidean domain), but not a field: the set of FPSs is not closed under division.\\nNow we can define integration and differentiation:\\nSome examples of using these functions; in each case a println call (which forces the lazy sequence) is followed by a comment showing the output.\\nAnd some examples using infinite FPSs. First define the sequence of factorials (facts), then define sin and cos Taylor series.\\nBy using letfn, which supports defining mutually recursive functions, we can define the sin and cos power series directly in terms of integrals of the other series:\\nCommon Lisp isn't lazy, and doesn't define the arithmetic operators as generic functions. As such, this implementation defines lazy primitives (delay and force), and a lazy list built on top of them (lons, lar, ldr). This implementation also defines a package #:formal-power-series which uses all the symbols of the \""COMMON-LISP\"" package except for +, -, *, and /, which are shadowed. Shadowing these symbols allows for definitions of generic functions which can be specialized for the power series, can default to the normal CL arithmetic operations for other kinds of objects, and can do \""the right thing\"" for mixes thereof.\\nA few utilities to make working with lazy lists easier.\\nThe mathematical operations here are translations of the Haskell code, but we specialize the operations in various ways so that behavior for normal numeric operations is preserved.\\nFollowing is a simple implementation of formal power series in C. It's not \""new datatype for the language\"" per se, but does demonstrate how lazy evaluation and infinite list generation can be done for this task. Note that, to be of real use, one should also cache terms looked up and free up memory. Both are trivially done (I actually had them, but removed them for simplicity).\\nCos: 1 0 -0.5 0 0.0416667 0 -0.00138889 0 2.48016e-05 0\\nTan: 0 1 0 0.333333 0 0.133333 0 0.0539683 0 0.0218695\\nSee Formal_power_series/D.\\nWe implement infinite formal power series (FPS) using streams. No operator overloading in EchoLisp, so we provide the operators s-add, s-mul ,.. which implement the needed operations. poly->stream converts a finite polynomial into an infinite FPS, and s-value gives the value of a FPS at x.\\n","from itertools import islice, tee\\nfrom fractions import Fraction\\ntry:\\n    from itertools import izip as zip # for 2.6\\nexcept:\\n    pass\\n\\ndef pluspower(*powergenerators):\\n    for elements in zip(*powergenerators):\\n        yield sum(elements)\\ndef minuspower(*powergenerators):\\n    for elements in zip(*powergenerators):\\n        yield elements[0] - sum(elements[1:])\\ndef mulpower(fgen,ggen):\\n    'From: http://en.wikipedia.org/wiki/Power_series#Multiplication_and_division'\\n    a,b = [],[]\\n    for f,g in zip(fgen, ggen):\\n        a.append(f)\\n        b.append(g)\\n        yield sum(f*g for f,g in zip(a, reversed(b)))\\ndef constpower(n):\\n    yield n\\n    while True:\\n        yield 0\\ndef diffpower(gen):\\n    'differentiatiate power series'\\n    next(gen)\\n    for n, an in enumerate(gen, start=1):\\n        yield an*n\\ndef intgpower(gen):\\n    'integrate power series with bounds from 0 to x'\\n    yield 0\\n    for n, an in enumerate(gen, start=1):\\n        yield an * Fraction(1,n)\\n\\n\\ndef sine_cosine_series():\\n    def deferred_sin():\\n        for i in sinx_temp:\\n            yield i\\n    def deferred_cos():\\n        for i in cosx_temp:\\n            yield i\\n\\n    sinx_result, sinx_copy1 = tee(deferred_sin(), 2)\\n    cosx_result, cosx_copy1 = tee(deferred_cos(), 2)\\n\\n    sinx_temp = intgpower(cosx_copy1)\\n    cosx_temp = minuspower(constpower(1), intgpower(sinx_copy1))\\n\\n    return sinx_result, cosx_result\\n\\nsinx, cosx = sine_cosine_series()\\n\\nprint(\""cosine\"")\\nprint(list(islice(sinx, 10)))\\nprint(\""sine\"")\\nprint(list(islice(cosx, 10)))"
"Python","Formal_power_series","A power series is an infinite sum of the form\\n\\n\\n\\n\\n\\na\\n\\n0\\n\\n\\n+\\n\\na\\n\\n1\\n\\n\\n⋅\\nx\\n+\\n\\na\\n\\n2\\n\\n\\n⋅\\n\\nx\\n\\n2\\n\\n\\n+\\n\\na\\n\\n3\\n\\n\\n⋅\\n\\nx\\n\\n3\\n\\n\\n+\\n⋯\\n\\n\\n{\\displaystyle a_{0}+a_{1}\\cdot x+a_{2}\\cdot x^{2}+a_{3}\\cdot x^{3}+\\cdots }\\n\\n\\nThe ai are called the coefficients of the series. Such sums can be added, multiplied etc., where the new coefficients of the powers of x are calculated according to the usual rules.\\nIf one is not interested in evaluating such a series for particular values of x, or in other words, if convergence doesn't play a role, then such a collection of coefficients is called formal power series. It can be treated like a new kind of number.\\nTask: Implement formal power series as a numeric type. Operations should at least include addition, multiplication, division and additionally non-numeric operations like differentiation and integration (with an integration constant of zero). Take care that your implementation deals with the potentially infinite number of coefficients.\\nAs an example, define the power series of sine and cosine in terms of each other using integration, as in\\n\\n\\n\\n\\nsin\\n⁡\\nx\\n=\\n\\n∫\\n\\n0\\n\\n\\nx\\n\\n\\ncos\\n⁡\\nt\\n\\nd\\nt\\n\\n\\n{\\displaystyle \\sin x=\\int _{0}^{x}\\cos t\\,dt}\\n\\n\\n\\n\\n\\n\\ncos\\n⁡\\nx\\n=\\n1\\n−\\n\\n∫\\n\\n0\\n\\n\\nx\\n\\n\\nsin\\n⁡\\nt\\n\\nd\\nt\\n\\n\\n{\\displaystyle \\cos x=1-\\int _{0}^{x}\\sin t\\,dt}\\n\\n\\nGoals: Demonstrate how the language handles new numeric types and delayed (or lazy) evaluation.\\nThe Taylor series package is generic to be instantiated with any rational type implementation provided by the task Rational Arithmetic:\\nThe package implementation:\\nThe procedure Normalize is used to truncate the series when the coefficients are zero. The summation of a series (function Value) uses Horner scheme.\\nSample output:\\nThis version takes advantage of the laziness of most of Clojure's sequence functions, including map, for, take-while, concat, and drop. A formal power series (FPS) is represented as a sequence of coefficients; for example, [1 2 3] represents 1 + 2*x + 3*x*x.\\nFirst addition and subtraction. Note that most of the complication arises in allowing for finite and infinite FPSs; if only infinite power series were at issue, the function (defn ips+ [ips0 ips1] (map + ips0 ips1)) would suffice.\\nMultiplication next; again most of the complication is dealing with both finite and infinite FPS. This function explicitly uses the standard function lazy-seq to define the product sequence.\\nAs with most of the other examples on this page, there's no definition for division. Mathematically, FPS is a commutative ring (in fact a Euclidean domain), but not a field: the set of FPSs is not closed under division.\\nNow we can define integration and differentiation:\\nSome examples of using these functions; in each case a println call (which forces the lazy sequence) is followed by a comment showing the output.\\nAnd some examples using infinite FPSs. First define the sequence of factorials (facts), then define sin and cos Taylor series.\\nBy using letfn, which supports defining mutually recursive functions, we can define the sin and cos power series directly in terms of integrals of the other series:\\nCommon Lisp isn't lazy, and doesn't define the arithmetic operators as generic functions. As such, this implementation defines lazy primitives (delay and force), and a lazy list built on top of them (lons, lar, ldr). This implementation also defines a package #:formal-power-series which uses all the symbols of the \""COMMON-LISP\"" package except for +, -, *, and /, which are shadowed. Shadowing these symbols allows for definitions of generic functions which can be specialized for the power series, can default to the normal CL arithmetic operations for other kinds of objects, and can do \""the right thing\"" for mixes thereof.\\nA few utilities to make working with lazy lists easier.\\nThe mathematical operations here are translations of the Haskell code, but we specialize the operations in various ways so that behavior for normal numeric operations is preserved.\\nFollowing is a simple implementation of formal power series in C. It's not \""new datatype for the language\"" per se, but does demonstrate how lazy evaluation and infinite list generation can be done for this task. Note that, to be of real use, one should also cache terms looked up and free up memory. Both are trivially done (I actually had them, but removed them for simplicity).\\nCos: 1 0 -0.5 0 0.0416667 0 -0.00138889 0 2.48016e-05 0\\nTan: 0 1 0 0.333333 0 0.133333 0 0.0539683 0 0.0218695\\nSee Formal_power_series/D.\\nWe implement infinite formal power series (FPS) using streams. No operator overloading in EchoLisp, so we provide the operators s-add, s-mul ,.. which implement the needed operations. poly->stream converts a finite polynomial into an infinite FPS, and s-value gives the value of a FPS at x.\\n","from itertools import count, chain, tee, islice, cycle\\nfrom fractions import Fraction\\n\\n# infinite polynomial class\\nclass Poly:\\n    def __init__(self, gen = None):\\n        self.gen, self.source = (None, gen) if type(gen) is Poly \\\\n            else (gen, None)\\n\\n    def __iter__(self):\\n        # We're essentially tee'ing it everytime the iterator\\n        # is, well, iterated.  This may be excessive.\\n        return Poly(self)\\n\\n    def getsource(self):\\n        if self.gen == None:\\n            s = self.source\\n            s.getsource()\\n            (a,b) = tee(s.gen, 2)\\n            s.gen = a\\n            self.gen = b\\n\\n    def next(self):\\n        self.getsource()\\n        return next(self.gen)\\n\\n    __next__ = next\\n\\n    # Overload \""<<\"" as stream input operator. Hey, C++ does it.\\n    def __lshift__(self, a): self.gen = a\\n\\n    # The other operators are pretty much what one would expect\\n    def __neg__(self): return Poly(-x for x in self)\\n\\n    def __sub__(a, b): return a + (-b)\\n\\n    def __rsub__(a, n):\\n        a = Poly(a)\\n        def gen():\\n            yield(n - next(a))\\n            for x in a: yield(-x)\\n        return Poly(gen())\\n\\n    def __add__(a, b):\\n        if type(b) is Poly:\\n            return Poly(x + y for (x,y) in zip(a,b))\\n\\n        a = Poly(a)\\n        def gen():\\n            yield(next(a) + b)\\n            for x in a: yield(x)\\n        return Poly(gen())\\n\\n    def __radd__(a,b):\\n        return a + b\\n\\n    def __mul__(a,b):\\n        if not type(b) is Poly:\\n            return Poly(x*b for x in a)\\n\\n        def gen():\\n            s = Poly(cycle([0]))\\n            for y in b:\\n                s += y*a\\n                yield(next(s))\\n\\n        return Poly(gen())\\n\\n    def __rmul__(a,b): return a*b\\n\\n    def __truediv__(a,b):\\n        if not type(b) is Poly:\\n            return Poly(Fraction(x, b) for x in a)\\n\\n        a, b = Poly(a), Poly(b)\\n        def gen():\\n            r, bb = a,next(b)\\n            while True:\\n                aa = next(r)\\n                q = Fraction(aa, bb)\\n                yield(q)\\n                r -= q*b\\n\\n        return Poly(gen())\\n\\n# these two would probably be better as class methods\\ndef inte(a):\\n    def gen():\\n        yield(0)\\n        for (x,n) in zip(a, count(1)):\\n            yield(Fraction(x,n))\\n    return Poly(gen())\\n\\ndef diff(a):\\n    def gen():\\n        for (x, n) in zip(a, count(0)):\\n            if n: yield(x*n)\\n    return Poly(gen())\\n\\n\\n# all that for the syntactic sugar\\nsinx, cosx, tanx, expx = Poly(), Poly(), Poly(), Poly()\\n\\nsinx << inte(cosx)\\ncosx << 1 - inte(sinx)\\ntanx << sinx / cosx        # \""=\"" would also work here\\nexpx << 1 + inte(expx)\\n\\nfor n,x in zip((\""sin\"", \""cos\"", \""tan\"", \""exp\""), (sinx, cosx, tanx, expx)):\\n    print(n, ', '.join(map(str, list(islice(x, 10)))))"
"Python","Formatted_numeric_output","Express a number in decimal as a fixed-length string with leading zeros.\\n\\nFor example, the number   7.125   could be expressed as   00007.125.\\n\\n","from math import pi, exp\\nr = exp(pi)-pi\\nprint r\\nprint \""e=%e f=%f g=%g G=%G s=%s r=%r!\""%(r,r,r,r,r,r)\\nprint \""e=%9.4e f=%9.4f g=%9.4g!\""%(-r,-r,-r)\\nprint \""e=%9.4e f=%9.4f g=%9.4g!\""%(r,r,r)\\nprint \""e=%-9.4e f=%-9.4f g=%-9.4g!\""%(r,r,r)\\nprint \""e=%09.4e f=%09.4f g=%09.4g!\""%(-r,-r,-r)\\nprint \""e=%09.4e f=%09.4f g=%09.4g!\""%(r,r,r)\\nprint \""e=%-09.4e f=%-09.4f g=%-09.4g!\""%(r,r,r)"
"Python","Formatted_numeric_output","Express a number in decimal as a fixed-length string with leading zeros.\\n\\nFor example, the number   7.125   could be expressed as   00007.125.\\n\\n","from math import pi, exp\\nr = exp(pi)-pi\\nprint(r)\\nprint(\""e={0:e} f={0:f} g={0:g} G={0:G} s={0!s} r={0!r}!\"".format(r))\\nprint(\""e={0:9.4e} f={0:9.4f} g={0:9.4g}!\"".format(-r))\\nprint(\""e={0:9.4e} f={0:9.4f} g={0:9.4g}!\"".format(r))\\nprint(\""e={0:-9.4e} f={0:-9.4f} g={0:-9.4g}!\"".format(r))\\nprint(\""e={0:09.4e} f={0:09.4f} g={0:09.4g}!\"".format(-r))\\nprint(\""e={0:09.4e} f={0:09.4f} g={0:09.4g}!\"".format(r))\\nprint(\""e={0:-09.4e} f={0:-09.4f} g={0:-09.4g}!\"".format(r))"
"Python","Forward_difference","Provide code that produces a list of numbers which is the   nth  order forward difference, given a non-negative integer (specifying the order) and a list of numbers.\\n\\nThe first-order forward difference of a list of numbers   A   is a new list   B,   where   Bn = An+1 - An.\\nList   B   should have one fewer element as a result.\\nThe second-order forward difference of   A   will be:\\nThe same as the first-order forward difference of   B.\\nThat new list will have two fewer elements than   A   and one less than   B.\\nThe goal of this task is to repeat this process up to the desired order.\\nFor a more formal description, see the related   Mathworld article.\\n\\n\\n",">>> dif = lambda s: [x-s[i] for i,x in enumerate(s[1:])]\\n>>> # or, dif = lambda s: [x-y for x,y in zip(s[1:],s)]\\n>>> difn = lambda s, n: difn(dif(s), n-1) if n else s\\n\\n>>> s = [90, 47, 58, 29, 22, 32, 55, 5, 55, 73]\\n>>> difn(s, 0)\\n[90, 47, 58, 29, 22, 32, 55, 5, 55, 73]\\n>>> difn(s, 1)\\n[-43, 11, -29, -7, 10, 23, -50, 50, 18]\\n>>> difn(s, 2)\\n[54, -40, 22, 17, 13, -73, 100, -32]\\n\\n>>> from pprint import pprint\\n>>> pprint( [difn(s, i) for i in xrange(10)] )\\n[[90, 47, 58, 29, 22, 32, 55, 5, 55, 73],\\n [-43, 11, -29, -7, 10, 23, -50, 50, 18],\\n [54, -40, 22, 17, 13, -73, 100, -32],\\n [-94, 62, -5, -4, -86, 173, -132],\\n [156, -67, 1, -82, 259, -305],\\n [-223, 68, -83, 341, -564],\\n [291, -151, 424, -905],\\n [-442, 575, -1329],\\n [1017, -1904],\\n [-2921]]"
"Python","Four_bit_adder","\""Simulate\"" a four-bit adder.\\nThis design can be realized using four 1-bit full adders.\\nEach of these 1-bit full adders can be built with two half adders and an or gate. Finally a half adder can be made using a xor gate and an and gate.\\nThe xor gate can be made using two nots, two ands and one or.\\nNot, or and and, the only allowed \""gates\"" for the task, can be \""imitated\"" by using the bitwise operators of your language.\\nIf there is not a bit type in your language, to be sure that the not does not \""invert\"" all the other bits of the basic type (e.g. a byte) we are not interested in, you can use an extra nand (and then not) with the constant 1 on one input.\\nInstead of optimizing and reducing the number of gates used for the final 4-bit adder, build it in the most straightforward way, connecting the other \""constructive blocks\"", in turn made of \""simpler\"" and \""smaller\"" ones.\\nSolutions should try to be as descriptive as possible, making it as easy as possible to identify \""connections\"" between higher-order \""blocks\"".\\nIt is not mandatory to replicate the syntax of higher-order blocks in the atomic \""gate\"" blocks, i.e. basic \""gate\"" operations can be performed as usual bitwise operations, or they can be \""wrapped\"" in a block in order to expose the same syntax of higher-order blocks, at implementers' choice.\\nTo test the implementation, show the sum of two four-bit numbers (in binary).\\n\\nA test program with the above definitions\\n","def xor(a, b): return (a and not b) or (b and not a)\\n\\ndef ha(a, b): return xor(a, b), a and b     # sum, carry\\n\\ndef fa(a, b, ci):\\n    s0, c0 = ha(ci, a)\\n    s1, c1 = ha(s0, b)\\n    return s1, c0 or c1     # sum, carry\\n\\ndef fa4(a, b):\\n    width = 4\\n    ci = [None] * width\\n    co = [None] * width\\n    s  = [None] * width\\n    for i in range(width):\\n        s[i], co[i] = fa(a[i], b[i], co[i-1] if i else 0)\\n    return s, co[-1]\\n\\ndef int2bus(n, width=4):\\n    return [int(c) for c in \""{0:0{1}b}\"".format(n, width)[::-1]]\\n\\ndef bus2int(b):\\n    return sum(1 << i for i, bit in enumerate(b) if bit)\\n\\ndef test_fa4():\\n    width = 4\\n    tot = [None] * (width + 1)\\n    for a in range(2**width):\\n        for b in range(2**width):\\n            tot[:width], tot[width] = fa4(int2bus(a), int2bus(b))\\n            assert a + b == bus2int(tot), \""totals don't match: %i + %i != %s\"" % (a, b, tot)\\n\\n\\nif __name__ == '__main__':\\n   test_fa4()"
"Python","Four_is_magic","Write a subroutine, function, whatever it may be called in your language, that takes an integer number and returns an English text sequence starting with the English cardinal representation of that integer, the word 'is' and then the English cardinal representation of the count of characters that made up the first word, followed by a comma.\\nContinue the sequence by using the previous count word as the first word of the next phrase, append 'is' and the cardinal count of the letters in that word.\\nContinue until you reach four. Since four has four characters, finish by adding the words 'four is magic' and a period. All integers will eventually wind up at four.\\nFor instance, suppose your are given the integer 3. Convert 3 to Three, add  is , then the cardinal character count of three, or five, with a comma to separate if from the next phrase. Continue the sequence five is four, (five has four letters), and finally, four is magic.\\nFor reference, here are outputs for 0 through 9.\\n\\n\\nYou can choose to use a library, (module, external routine, whatever) to do the cardinal conversions as long as the code is easily and freely available to the public.\\nIf you roll your own, make the routine accept at minimum any integer from 0 up to 999999. If you use a pre-made library, support at least up to unsigned 64 bit integers. (or the largest integer supported in your language if it is less.)\\nFour is magic is a popular code-golf task. This is not code golf. Write legible, idiomatic and well formatted code.\\n\\n\\n","import random\\nfrom collections import OrderedDict\\n\\nnumbers = {  # taken from https://en.wikipedia.org/wiki/Names_of_large_numbers#cite_ref-a_14-3\\n    1: 'one',\\n    2: 'two',\\n    3: 'three',\\n    4: 'four',\\n    5: 'five',\\n    6: 'six',\\n    7: 'seven',\\n    8: 'eight',\\n    9: 'nine',\\n    10: 'ten',\\n    11: 'eleven',\\n    12: 'twelve',\\n    13: 'thirteen',\\n    14: 'fourteen',\\n    15: 'fifteen',\\n    16: 'sixteen',\\n    17: 'seventeen',\\n    18: 'eighteen',\\n    19: 'nineteen',\\n    20: 'twenty',\\n    30: 'thirty',\\n    40: 'forty',\\n    50: 'fifty',\\n    60: 'sixty',\\n    70: 'seventy',\\n    80: 'eighty',\\n    90: 'ninety',\\n    100: 'hundred',\\n    1000: 'thousand',\\n    10 ** 6: 'million',\\n    10 ** 9: 'billion',\\n    10 ** 12: 'trillion',\\n    10 ** 15: 'quadrillion',\\n    10 ** 18: 'quintillion',\\n    10 ** 21: 'sextillion',\\n    10 ** 24: 'septillion',\\n    10 ** 27: 'octillion',\\n    10 ** 30: 'nonillion',\\n    10 ** 33: 'decillion',\\n    10 ** 36: 'undecillion',\\n    10 ** 39: 'duodecillion',\\n    10 ** 42: 'tredecillion',\\n    10 ** 45: 'quattuordecillion',\\n    10 ** 48: 'quinquadecillion',\\n    10 ** 51: 'sedecillion',\\n    10 ** 54: 'septendecillion',\\n    10 ** 57: 'octodecillion',\\n    10 ** 60: 'novendecillion',\\n    10 ** 63: 'vigintillion',\\n    10 ** 66: 'unvigintillion',\\n    10 ** 69: 'duovigintillion',\\n    10 ** 72: 'tresvigintillion',\\n    10 ** 75: 'quattuorvigintillion',\\n    10 ** 78: 'quinquavigintillion',\\n    10 ** 81: 'sesvigintillion',\\n    10 ** 84: 'septemvigintillion',\\n    10 ** 87: 'octovigintillion',\\n    10 ** 90: 'novemvigintillion',\\n    10 ** 93: 'trigintillion',\\n    10 ** 96: 'untrigintillion',\\n    10 ** 99: 'duotrigintillion',\\n    10 ** 102: 'trestrigintillion',\\n    10 ** 105: 'quattuortrigintillion',\\n    10 ** 108: 'quinquatrigintillion',\\n    10 ** 111: 'sestrigintillion',\\n    10 ** 114: 'septentrigintillion',\\n    10 ** 117: 'octotrigintillion',\\n    10 ** 120: 'noventrigintillion',\\n    10 ** 123: 'quadragintillion',\\n    10 ** 153: 'quinquagintillion',\\n    10 ** 183: 'sexagintillion',\\n    10 ** 213: 'septuagintillion',\\n    10 ** 243: 'octogintillion',\\n    10 ** 273: 'nonagintillion',\\n    10 ** 303: 'centillion',\\n    10 ** 306: 'uncentillion',\\n    10 ** 309: 'duocentillion',\\n    10 ** 312: 'trescentillion',\\n    10 ** 333: 'decicentillion',\\n    10 ** 336: 'undecicentillion',\\n    10 ** 363: 'viginticentillion',\\n    10 ** 366: 'unviginticentillion',\\n    10 ** 393: 'trigintacentillion',\\n    10 ** 423: 'quadragintacentillion',\\n    10 ** 453: 'quinquagintacentillion',\\n    10 ** 483: 'sexagintacentillion',\\n    10 ** 513: 'septuagintacentillion',\\n    10 ** 543: 'octogintacentillion',\\n    10 ** 573: 'nonagintacentillion',\\n    10 ** 603: 'ducentillion',\\n    10 ** 903: 'trecentillion',\\n    10 ** 1203: 'quadringentillion',\\n    10 ** 1503: 'quingentillion',\\n    10 ** 1803: 'sescentillion',\\n    10 ** 2103: 'septingentillion',\\n    10 ** 2403: 'octingentillion',\\n    10 ** 2703: 'nongentillion',\\n    10 ** 3003: 'millinillion'\\n}\\nnumbers = OrderedDict(sorted(numbers.items(), key=lambda t: t[0], reverse=True))\\n\\n\\ndef string_representation(i: int) -> str:\\n    \""\""\""\\n    Return the english string representation of an integer\\n    \""\""\""\\n    if i == 0:\\n        return 'zero'\\n\\n    words = ['negative'] if i < 0 else []\\n    working_copy = abs(i)\\n\\n    for key, value in numbers.items():\\n        if key <= working_copy:\\n            times = int(working_copy / key)\\n\\n            if key >= 100:\\n                words.append(string_representation(times))\\n\\n            words.append(value)\\n            working_copy -= times * key\\n\\n        if working_copy == 0:\\n            break\\n\\n    return ' '.join(words)\\n\\n\\ndef next_phrase(i: int):\\n    \""\""\""\\n    Generate all the phrases\\n    \""\""\""\\n    while not i == 4:  # Generate phrases until four is reached\\n        str_i = string_representation(i)\\n        len_i = len(str_i)\\n\\n        yield str_i, 'is', string_representation(len_i)\\n\\n        i = len_i\\n\\n    # the last phrase\\n    yield string_representation(i), 'is', 'magic'\\n\\n\\ndef magic(i: int) -> str:\\n    phrases = []\\n\\n    for phrase in next_phrase(i):\\n        phrases.append(' '.join(phrase))\\n\\n    return f'{\"", \"".join(phrases)}.'.capitalize()\\n\\n\\nif __name__ == '__main__':\\n\\n    for j in (random.randint(0, 10 ** 3) for i in range(5)):\\n        print(j, ':\\n', magic(j), '\\n')\\n\\n    for j in (random.randint(-10 ** 24, 10 ** 24) for i in range(2)):\\n        print(j, ':\\n', magic(j), '\\n')"
"Python","Free_polyominoes_enumeration","A Polyomino is a plane geometric figure formed by joining one or more equal squares edge to edge. Free polyominoes are distinct when none is a translation, rotation, reflection or glide reflection of another polyomino.\\nTask: generate all the free polyominoes with n cells.\\nYou can visualize them just as a sequence of the coordinate pairs of their cells (rank 5):\\nBut a better basic visualization is using ASCII art (rank 5):\\nOr perhaps with corner characters (rank 5):\\nFor a slow but clear solution see this Haskell Wiki page:\\nhttp://www.haskell.org/haskellwiki/The_Monad.Reader/Issue5/Generating_Polyominoes\\nBonus Task: you can create an alternative program (or specialize your first program) to generate very quickly just the number of distinct free polyominoes, and to show a sequence like:\\n1, 1, 1, 2, 5, 12, 35, 108, 369, 1285, 4655, 17073, 63600, 238591, 901971, 3426576, ...\\nNumber of free polyominoes (or square animals) with n cells:\\nhttp://oeis.org/A000105\\n\\nPentomino tiling\\nTurns out the source for the counting only version of the D code example could be tweaked to show solutions as well. The max rank can be changed by supplying a command line parameter. The free polyominos of any rank can be displayed by changing the variable named target to a reasonable number. This program will also indicate the estimated times for larger ranks.\\n","from itertools import imap, imap, groupby, chain, imap\\nfrom operator import itemgetter\\nfrom sys import argv\\nfrom array import array\\n\\ndef concat_map(func, it):\\n    return list(chain.from_iterable(imap(func, it)))\\n\\ndef minima(poly):\\n    \""\""\""Finds the min x and y coordiate of a Polyomino.\""\""\""\\n    return (min(pt[0] for pt in poly), min(pt[1] for pt in poly))\\n\\ndef translate_to_origin(poly):\\n    (minx, miny) = minima(poly)\\n    return [(x - minx, y - miny) for (x, y) in poly]\\n\\nrotate90   = lambda (x, y): ( y, -x)\\nrotate180  = lambda (x, y): (-x, -y)\\nrotate270  = lambda (x, y): (-y,  x)\\nreflect    = lambda (x, y): (-x,  y)\\n\\ndef rotations_and_reflections(poly):\\n    \""\""\""All the plane symmetries of a rectangular region.\""\""\""\\n    return (poly,\\n            map(rotate90, poly),\\n            map(rotate180, poly),\\n            map(rotate270, poly),\\n            map(reflect, poly),\\n            [reflect(rotate90(pt)) for pt in poly],\\n            [reflect(rotate180(pt)) for pt in poly],\\n            [reflect(rotate270(pt)) for pt in poly])\\n\\ndef canonical(poly):\\n    return min(sorted(translate_to_origin(pl)) for pl in rotations_and_reflections(poly))\\n\\ndef unique(lst):\\n    lst.sort()\\n    return map(next, imap(itemgetter(1), groupby(lst)))\\n\\n# All four points in Von Neumann neighborhood.\\ncontiguous = lambda (x, y): [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]\\n\\ndef new_points(poly):\\n    \""\""\""Finds all distinct points that can be added to a Polyomino.\""\""\""\\n    return unique([pt for pt in concat_map(contiguous, poly) if pt not in poly])\\n\\ndef new_polys(poly):\\n    return unique([canonical(poly + [pt]) for pt in new_points(poly)])\\n\\nmonomino = [(0, 0)]\\nmonominoes = [monomino]\\n\\ndef rank(n):\\n    \""\""\""Generates polyominoes of rank n recursively.\""\""\""\\n    assert n >= 0\\n    if n == 0: return []\\n    if n == 1: return monominoes\\n    return unique(concat_map(new_polys, rank(n - 1)))\\n\\ndef text_representation(poly):\\n    \""\""\""Generates a textual representation of a Polyomino.\""\""\""\\n    min_pt = minima(poly)\\n    max_pt = (max(p[0] for p in poly), max(p[1] for p in poly))\\n    table = [array('c', ' ') * (max_pt[1] - min_pt[1] + 1)\\n             for _ in xrange(max_pt[0] - min_pt[0] + 1)]\\n    for pt in poly:\\n        table[pt[0] - min_pt[0]][pt[1] - min_pt[1]] = '#'\\n    return \""\\n\"".join(row.tostring() for row in table)\\n\\ndef main():\\n    print [len(rank(n)) for n in xrange(1, 11)]\\n\\n    n = int(argv[1]) if (len(argv) == 2) else 5\\n    print \""\\nAll free polyominoes of rank %d:\"" % n\\n\\n    for poly in rank(n):\\n        print text_representation(poly), \""\\n\""\\n\\nmain()"
"Python","FTP","Connect to a server, change directory, list its contents and download a file as binary using the FTP protocol. Use passive mode if available.\\n\\nThis uses the native FTP.EXE in Windows. I am not sure, but I think FTP.EXE client does not support passive mode.\\n","\\nfrom ftplib import FTP\\nftp = FTP('kernel.org')\\nftp.login()\\nftp.cwd('/pub/linux/kernel')\\nftp.set_pasv(True) # Default since Python 2.1\\nprint ftp.retrlines('LIST')\\nprint ftp.retrbinary('RETR README', open('README', 'wb').write)\\nftp.quit()\\n"
"Python","Function_composition","Create a function, compose,   whose two arguments   f   and   g,   are both functions with one argument.\\n\\nThe result of compose is to be a function of one argument, (lets call the argument   x),   which works like applying function    f    to the result of applying function    g    to    x.\\n\\n\\nReference: Function composition\\nHint: In some languages, implementing compose correctly requires creating a closure.\\n\\nActionScript supports closures, making function composition very straightforward.\\nThe interface of a generic functions package. The package can be instantiated with any type that has value semantics. Functions are composed using the operation '*'. The same operation applied to an argument evaluates it there: f * x. Functions can be composed with pointers to Ada functions. (In Ada functions are not first-class):\\nHere is an implementation;\\nThe following is an example of use:\\n","compose = lambda f, g: lambda x: f( g(x) )"
"Python","Function_composition","Create a function, compose,   whose two arguments   f   and   g,   are both functions with one argument.\\n\\nThe result of compose is to be a function of one argument, (lets call the argument   x),   which works like applying function    f    to the result of applying function    g    to    x.\\n\\n\\nReference: Function composition\\nHint: In some languages, implementing compose correctly requires creating a closure.\\n\\nActionScript supports closures, making function composition very straightforward.\\nThe interface of a generic functions package. The package can be instantiated with any type that has value semantics. Functions are composed using the operation '*'. The same operation applied to an argument evaluates it there: f * x. Functions can be composed with pointers to Ada functions. (In Ada functions are not first-class):\\nHere is an implementation;\\nThe following is an example of use:\\n",">>> compose = lambda f, g: lambda x: f( g(x) )\\n>>> from math import sin, asin\\n>>> sin_asin = compose(sin, asin)\\n>>> sin_asin(0.5)\\n0.5\\n>>>"
"Python","Function_composition","Create a function, compose,   whose two arguments   f   and   g,   are both functions with one argument.\\n\\nThe result of compose is to be a function of one argument, (lets call the argument   x),   which works like applying function    f    to the result of applying function    g    to    x.\\n\\n\\nReference: Function composition\\nHint: In some languages, implementing compose correctly requires creating a closure.\\n\\nActionScript supports closures, making function composition very straightforward.\\nThe interface of a generic functions package. The package can be instantiated with any type that has value semantics. Functions are composed using the operation '*'. The same operation applied to an argument evaluates it there: f * x. Functions can be composed with pointers to Ada functions. (In Ada functions are not first-class):\\nHere is an implementation;\\nThe following is an example of use:\\n","from math import (acos, cos, asin, sin)\\n\\n\\n# main :: IO ()\\ndef main():\\n    return map(\\n        lambda f: f(0.5),\\n        zipWith(compose)\\n        ([sin, cos, lambda x: x ** 3.0])\\n        ([asin, acos, lambda x: x ** (1 / 3.0)])\\n    )\\n\\n\\n# GENERIC FUNCTIONS ------------------------------\\n\\n\\n# compose (>>>) :: (a -> b) -> (b -> c) -> a -> c\\ndef compose(f):\\n    return lambda (g): lambda x: f(g(x))\\n\\n\\n# zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\\ndef zipWith(f):\\n    return (\\n        lambda xs: lambda ys:\\n            [f(a)(b) for (a, b) in zip(xs, ys)]\\n    )\\n\\n\\nprint main()"
"Python","Function_definition","A function is a body of code that returns a value.\\nThe value returned may depend on arguments provided to the function.\\n\\nWrite a definition of a function called \""multiply\"" that takes two arguments and returns their product.\\n(Argument types should be chosen so as not to distract from showing how functions are created and values returned).\\n\\n\\nLinkage conventions are: register 1 : the parameter list, register 0 : the return value,\\nand register 14 : the return address.\\nAs with other low-level languages, 6502 assembler has subroutines rather than functions in the strict sense. This implementation of MULTIPLY behaves rather like a function, however: it expects two 'parameters' to be passed in the index registers X and Y and it returns the answer in the accumulator. Note that the 6502 has no MUL instruction, so multiplication is carried out by repeated addition.\\nLike other assembly languages, 8051 doesn't have functions but instead has symbolic references to code. Function arguments are passed via registers decided on beforehand.\\nand an implementation of:\\n\\nThe Ada 2012 standard provides an even simpler way to define and implement functions:\\n\\nAda supports generic functions which can take generic formal parameters like the numeric type to use:\\nimplemented as:\\nTo use this, you need to instantiate the function for each type e.g.\\nThis implementation takes two integers and returns an integer. Note that a function is distinguished from a procedure, which does not return a value.\\nExplicit definition has the syntax:\\nInside functions, the variable args contains the sequence of arguments.\\nx, y and z contain the first, second and third argument.\\nWorks on arrays of any rank (any number of dimensions): atoms, lists, tables, etc.\\nApplesoft BASIC functions are unary meaning they only take one argument. As the task asks for a multiply function which takes two arguments this poses a problem. To get around this, the multiply function MU takes one argument as the offset into an array of parameters.\\nFunction names in Applesoft BASIC can be longer than two characters but only the first two characters are significant. Function names cannot contain any keywords.\\nwith a macro and a variable number of parameters:\\n\\nIn Commodore BASIC function definition can consist of any mathematical operation other functions or commands which result in a numeric expression. The definition is limited to single statement, and it accepts only a single argument. When using the function, keyword fn must precede the function name, which itself must be uniquely distinguishable by its first two characters.\\nWindows batch files only have procedures, not functions. Instead, environmental variables can be used as a global shared state.\\nBBC BASIC supports both single-line and multi-line function definitions. Note that the function name must begin with FN.\\nSingle-line function:\\nMultiline function:\\nMacros can be defined at the top of a program and the compiler will replace the function calls with the function itself before compiling the program (the source file will not change).\\nParentheses should be added around parameters in the function definition to avoid order of operations errors when someone uses the macro as such:\\nA program with that call would be compiled as if this were coded instead:\\nAnother advantage of macros is that they work with all types alike. For example, the above macro can be used both to multiply double values (like the function above), and to multiply int values (giving an int, which the function doesn't).\\nAnonymous function:\\nC++ functions basically are the same as in C. Also macros exist, however they are discouraged in C++ in favour of inline functions and function templates.\\nAn inline function differs from the normal function by the keyword inline and the fact that it has to be included in every translation unit which uses it (i.e. it normally is written directly in the header). It allows the compiler to eliminate the function without having the disadvantages of macros (like unintended double evaluation and not respecting scope), because the substitution doesn't happen at source level, but during compilation. An inline version of the above function is:\\nIf not only doubles, but numbers of arbitrary types are to be multiplied, a function template can be used:\\nOf course, both inline and template may be combined (the inline then has to follow the template<...>), but since templates have to be in the header anyway (while the standard allows them to be compiled separately using the keyword export, almost no compiler implements that), the compiler usually can inline the template even without the keyword.\\n\\nOr with multiple arities (in the manner of the actual * function):\\nIn COBOL, multiply is a reserved word, so the requirements must be relaxed to allow a different function name. The following uses a program:\\nThis example uses user-defined functions, which were added in COBOL 2002.\\nAs CoffeeScript. In addition, Coco provides some syntactic sugar for accessing the arguments array reminiscent of Perl's @_:\\nFurthermore, when no parameter list is defined, the first argument is available as it:\\nCommon Lisp has ordinary functions and generic functions.\\nOrdinary functions operate on the values of argument expressions. Lisp functions terminate by returning one or more values, or by executing a non-local dynamic control transfer, in which case values are not returned.\\nIn Lisp we can express optimizations of calls to a function using compiler macros. For instance, suppose we know that the multiply function, which may be in another module, simply multiplies numbers together. We can replace a call to multiply by a constant, if the arguments are constant expressions. Like the usual kind of Lisp macro, the compiler macro takes the argument forms as arguments, not the argument values. The special keyword &whole gives the macro access to the entire expression, which is convenient for the unhandled cases, whereby no transformation takes place:\\nLisp implementations do not have to honor compiler macros. Usually compilers make use of them, but evaluators do not.\\nHere is test of the macro using a CLISP interactive session. Note that the multiply function is not actually defined, yet it compiles and executes anyway, which shows that the macro provided the translation something.\\nLisp's generic functions are part of the object system. Generic functions are compiled to ordinary functions, and so are called in the ordinary way. Internally, however, they have the special behavior of dispatching one or more methods based on specializable parameters.\\nMethods can be defined right inside the DEFGENERIC construct, but usually are written with separate DEFMETHODS.\\nAlso, the DEFGENERIC is optional, since the first DEFMETHOD will define the generic function, but good practice.\\nBoth the compile-time and run-time output:\\nFor dc, the functions (called macros) are limited to names from 'a' to 'z'\\nCreate a function called 'm'\\nUse it (lm loads the function in 'm',x executes it, f shows the the stack.)\\n(This does not necessarily return a product, but whatever the \""multiply\"" method of a returns. The parameters could be guarded to only accept standard numbers.)\\nIt is also possible to write short anonymous function definitions which do not need explicit returns:\\nThis definition is identical to the previous except that the function object will not know its own name.\\nAnonymous function:\\nAnonymous function / closure:\\nRoot closure:\\n","def multiply(a, b):\\n    return a * b"
"Python","Function_definition","A function is a body of code that returns a value.\\nThe value returned may depend on arguments provided to the function.\\n\\nWrite a definition of a function called \""multiply\"" that takes two arguments and returns their product.\\n(Argument types should be chosen so as not to distract from showing how functions are created and values returned).\\n\\n\\nLinkage conventions are: register 1 : the parameter list, register 0 : the return value,\\nand register 14 : the return address.\\nAs with other low-level languages, 6502 assembler has subroutines rather than functions in the strict sense. This implementation of MULTIPLY behaves rather like a function, however: it expects two 'parameters' to be passed in the index registers X and Y and it returns the answer in the accumulator. Note that the 6502 has no MUL instruction, so multiplication is carried out by repeated addition.\\nLike other assembly languages, 8051 doesn't have functions but instead has symbolic references to code. Function arguments are passed via registers decided on beforehand.\\nand an implementation of:\\n\\nThe Ada 2012 standard provides an even simpler way to define and implement functions:\\n\\nAda supports generic functions which can take generic formal parameters like the numeric type to use:\\nimplemented as:\\nTo use this, you need to instantiate the function for each type e.g.\\nThis implementation takes two integers and returns an integer. Note that a function is distinguished from a procedure, which does not return a value.\\nExplicit definition has the syntax:\\nInside functions, the variable args contains the sequence of arguments.\\nx, y and z contain the first, second and third argument.\\nWorks on arrays of any rank (any number of dimensions): atoms, lists, tables, etc.\\nApplesoft BASIC functions are unary meaning they only take one argument. As the task asks for a multiply function which takes two arguments this poses a problem. To get around this, the multiply function MU takes one argument as the offset into an array of parameters.\\nFunction names in Applesoft BASIC can be longer than two characters but only the first two characters are significant. Function names cannot contain any keywords.\\nwith a macro and a variable number of parameters:\\n\\nIn Commodore BASIC function definition can consist of any mathematical operation other functions or commands which result in a numeric expression. The definition is limited to single statement, and it accepts only a single argument. When using the function, keyword fn must precede the function name, which itself must be uniquely distinguishable by its first two characters.\\nWindows batch files only have procedures, not functions. Instead, environmental variables can be used as a global shared state.\\nBBC BASIC supports both single-line and multi-line function definitions. Note that the function name must begin with FN.\\nSingle-line function:\\nMultiline function:\\nMacros can be defined at the top of a program and the compiler will replace the function calls with the function itself before compiling the program (the source file will not change).\\nParentheses should be added around parameters in the function definition to avoid order of operations errors when someone uses the macro as such:\\nA program with that call would be compiled as if this were coded instead:\\nAnother advantage of macros is that they work with all types alike. For example, the above macro can be used both to multiply double values (like the function above), and to multiply int values (giving an int, which the function doesn't).\\nAnonymous function:\\nC++ functions basically are the same as in C. Also macros exist, however they are discouraged in C++ in favour of inline functions and function templates.\\nAn inline function differs from the normal function by the keyword inline and the fact that it has to be included in every translation unit which uses it (i.e. it normally is written directly in the header). It allows the compiler to eliminate the function without having the disadvantages of macros (like unintended double evaluation and not respecting scope), because the substitution doesn't happen at source level, but during compilation. An inline version of the above function is:\\nIf not only doubles, but numbers of arbitrary types are to be multiplied, a function template can be used:\\nOf course, both inline and template may be combined (the inline then has to follow the template<...>), but since templates have to be in the header anyway (while the standard allows them to be compiled separately using the keyword export, almost no compiler implements that), the compiler usually can inline the template even without the keyword.\\n\\nOr with multiple arities (in the manner of the actual * function):\\nIn COBOL, multiply is a reserved word, so the requirements must be relaxed to allow a different function name. The following uses a program:\\nThis example uses user-defined functions, which were added in COBOL 2002.\\nAs CoffeeScript. In addition, Coco provides some syntactic sugar for accessing the arguments array reminiscent of Perl's @_:\\nFurthermore, when no parameter list is defined, the first argument is available as it:\\nCommon Lisp has ordinary functions and generic functions.\\nOrdinary functions operate on the values of argument expressions. Lisp functions terminate by returning one or more values, or by executing a non-local dynamic control transfer, in which case values are not returned.\\nIn Lisp we can express optimizations of calls to a function using compiler macros. For instance, suppose we know that the multiply function, which may be in another module, simply multiplies numbers together. We can replace a call to multiply by a constant, if the arguments are constant expressions. Like the usual kind of Lisp macro, the compiler macro takes the argument forms as arguments, not the argument values. The special keyword &whole gives the macro access to the entire expression, which is convenient for the unhandled cases, whereby no transformation takes place:\\nLisp implementations do not have to honor compiler macros. Usually compilers make use of them, but evaluators do not.\\nHere is test of the macro using a CLISP interactive session. Note that the multiply function is not actually defined, yet it compiles and executes anyway, which shows that the macro provided the translation something.\\nLisp's generic functions are part of the object system. Generic functions are compiled to ordinary functions, and so are called in the ordinary way. Internally, however, they have the special behavior of dispatching one or more methods based on specializable parameters.\\nMethods can be defined right inside the DEFGENERIC construct, but usually are written with separate DEFMETHODS.\\nAlso, the DEFGENERIC is optional, since the first DEFMETHOD will define the generic function, but good practice.\\nBoth the compile-time and run-time output:\\nFor dc, the functions (called macros) are limited to names from 'a' to 'z'\\nCreate a function called 'm'\\nUse it (lm loads the function in 'm',x executes it, f shows the the stack.)\\n(This does not necessarily return a product, but whatever the \""multiply\"" method of a returns. The parameters could be guarded to only accept standard numbers.)\\nIt is also possible to write short anonymous function definitions which do not need explicit returns:\\nThis definition is identical to the previous except that the function object will not know its own name.\\nAnonymous function:\\nAnonymous function / closure:\\nRoot closure:\\n","multiply = lambda a, b: a * b"
"Python","Function_definition","A function is a body of code that returns a value.\\nThe value returned may depend on arguments provided to the function.\\n\\nWrite a definition of a function called \""multiply\"" that takes two arguments and returns their product.\\n(Argument types should be chosen so as not to distract from showing how functions are created and values returned).\\n\\n\\nLinkage conventions are: register 1 : the parameter list, register 0 : the return value,\\nand register 14 : the return address.\\nAs with other low-level languages, 6502 assembler has subroutines rather than functions in the strict sense. This implementation of MULTIPLY behaves rather like a function, however: it expects two 'parameters' to be passed in the index registers X and Y and it returns the answer in the accumulator. Note that the 6502 has no MUL instruction, so multiplication is carried out by repeated addition.\\nLike other assembly languages, 8051 doesn't have functions but instead has symbolic references to code. Function arguments are passed via registers decided on beforehand.\\nand an implementation of:\\n\\nThe Ada 2012 standard provides an even simpler way to define and implement functions:\\n\\nAda supports generic functions which can take generic formal parameters like the numeric type to use:\\nimplemented as:\\nTo use this, you need to instantiate the function for each type e.g.\\nThis implementation takes two integers and returns an integer. Note that a function is distinguished from a procedure, which does not return a value.\\nExplicit definition has the syntax:\\nInside functions, the variable args contains the sequence of arguments.\\nx, y and z contain the first, second and third argument.\\nWorks on arrays of any rank (any number of dimensions): atoms, lists, tables, etc.\\nApplesoft BASIC functions are unary meaning they only take one argument. As the task asks for a multiply function which takes two arguments this poses a problem. To get around this, the multiply function MU takes one argument as the offset into an array of parameters.\\nFunction names in Applesoft BASIC can be longer than two characters but only the first two characters are significant. Function names cannot contain any keywords.\\nwith a macro and a variable number of parameters:\\n\\nIn Commodore BASIC function definition can consist of any mathematical operation other functions or commands which result in a numeric expression. The definition is limited to single statement, and it accepts only a single argument. When using the function, keyword fn must precede the function name, which itself must be uniquely distinguishable by its first two characters.\\nWindows batch files only have procedures, not functions. Instead, environmental variables can be used as a global shared state.\\nBBC BASIC supports both single-line and multi-line function definitions. Note that the function name must begin with FN.\\nSingle-line function:\\nMultiline function:\\nMacros can be defined at the top of a program and the compiler will replace the function calls with the function itself before compiling the program (the source file will not change).\\nParentheses should be added around parameters in the function definition to avoid order of operations errors when someone uses the macro as such:\\nA program with that call would be compiled as if this were coded instead:\\nAnother advantage of macros is that they work with all types alike. For example, the above macro can be used both to multiply double values (like the function above), and to multiply int values (giving an int, which the function doesn't).\\nAnonymous function:\\nC++ functions basically are the same as in C. Also macros exist, however they are discouraged in C++ in favour of inline functions and function templates.\\nAn inline function differs from the normal function by the keyword inline and the fact that it has to be included in every translation unit which uses it (i.e. it normally is written directly in the header). It allows the compiler to eliminate the function without having the disadvantages of macros (like unintended double evaluation and not respecting scope), because the substitution doesn't happen at source level, but during compilation. An inline version of the above function is:\\nIf not only doubles, but numbers of arbitrary types are to be multiplied, a function template can be used:\\nOf course, both inline and template may be combined (the inline then has to follow the template<...>), but since templates have to be in the header anyway (while the standard allows them to be compiled separately using the keyword export, almost no compiler implements that), the compiler usually can inline the template even without the keyword.\\n\\nOr with multiple arities (in the manner of the actual * function):\\nIn COBOL, multiply is a reserved word, so the requirements must be relaxed to allow a different function name. The following uses a program:\\nThis example uses user-defined functions, which were added in COBOL 2002.\\nAs CoffeeScript. In addition, Coco provides some syntactic sugar for accessing the arguments array reminiscent of Perl's @_:\\nFurthermore, when no parameter list is defined, the first argument is available as it:\\nCommon Lisp has ordinary functions and generic functions.\\nOrdinary functions operate on the values of argument expressions. Lisp functions terminate by returning one or more values, or by executing a non-local dynamic control transfer, in which case values are not returned.\\nIn Lisp we can express optimizations of calls to a function using compiler macros. For instance, suppose we know that the multiply function, which may be in another module, simply multiplies numbers together. We can replace a call to multiply by a constant, if the arguments are constant expressions. Like the usual kind of Lisp macro, the compiler macro takes the argument forms as arguments, not the argument values. The special keyword &whole gives the macro access to the entire expression, which is convenient for the unhandled cases, whereby no transformation takes place:\\nLisp implementations do not have to honor compiler macros. Usually compilers make use of them, but evaluators do not.\\nHere is test of the macro using a CLISP interactive session. Note that the multiply function is not actually defined, yet it compiles and executes anyway, which shows that the macro provided the translation something.\\nLisp's generic functions are part of the object system. Generic functions are compiled to ordinary functions, and so are called in the ordinary way. Internally, however, they have the special behavior of dispatching one or more methods based on specializable parameters.\\nMethods can be defined right inside the DEFGENERIC construct, but usually are written with separate DEFMETHODS.\\nAlso, the DEFGENERIC is optional, since the first DEFMETHOD will define the generic function, but good practice.\\nBoth the compile-time and run-time output:\\nFor dc, the functions (called macros) are limited to names from 'a' to 'z'\\nCreate a function called 'm'\\nUse it (lm loads the function in 'm',x executes it, f shows the the stack.)\\n(This does not necessarily return a product, but whatever the \""multiply\"" method of a returns. The parameters could be guarded to only accept standard numbers.)\\nIt is also possible to write short anonymous function definitions which do not need explicit returns:\\nThis definition is identical to the previous except that the function object will not know its own name.\\nAnonymous function:\\nAnonymous function / closure:\\nRoot closure:\\n","class Multiply:\\n    def __init__(self):\\n        pass\\n    def __call__(self, a, b):\\n        return a * b\\n\\nmultiply = Multiply()\\nprint multiply(2, 4)    # prints 8"
"Python","Function_frequency","Display - for a program or runtime environment (whatever suits the style of your language) - the top ten most frequently occurring functions (or also identifiers or tokens, if preferred).\\nThis is a static analysis: The question is not how often each function is\\nactually executed at runtime, but how often it is used by the programmer.\\nBesides its practical usefulness, the intent of this task is to show how to do self-inspection within the language.\\nThis will, unfortunately, also catch variable names after an open paren, such as in (let ...) expressions.\\nOutput (for itself):\\nOutput of running FUNCTION_FREQUENCY.AWK on itself:Sample input:Sample output:Output (for file LBB.BBC):\\nThis program treats doesn't differentiate between macros and functions. It works by looking for function calls which are not inside strings or comments. If a function call has a C style comment between the opening brace and the name of the function, this program will not recognize it as a function call.\\nLoading the file itself before scanning it is the quickest way to determine what function bindings would be created.\\n","import ast\\n\\nclass CallCountingVisitor(ast.NodeVisitor):\\n\\n    def __init__(self):\\n        self.calls = {}\\n\\n    def visit_Call(self, node):\\n        if isinstance(node.func, ast.Name):\\n            fun_name = node.func.id\\n            call_count = self.calls.get(fun_name, 0)\\n            self.calls[fun_name] = call_count + 1\\n        self.generic_visit(node)\\n\\nfilename = input('Enter a filename to parse: ')\\nwith open(filename, encoding='utf-8') as f:\\n    contents = f.read()\\nroot = ast.parse(contents, filename=filename) #NOTE: this will throw a SyntaxError if the file isn't valid Python code\\nvisitor = CallCountingVisitor()\\nvisitor.visit(root)\\ntop10 = sorted(visitor.calls.items(), key=lambda x: x[1], reverse=True)[:10]\\nfor name, count in top10:\\n    print(name,'called',count,'times')\\n"
"Python","Functional_coverage_tree","Functional coverage is a measure of how much a particular function of a system\\nhas been verified as correct. It is used heavily in tracking the completeness\\nof the verification of complex System on Chip (SoC) integrated circuits, where\\nit can also be used to track how well the functional requirements of the\\nsystem have been verified.\\nThis task uses a sub-set of the calculations sometimes used in tracking\\nfunctional coverage but uses a more familiar(?) scenario.\\nThe head of the clean-up crews for \""The Men in a very dark shade of grey when\\nviewed at night\"" has been tasked with managing the cleansing of two properties\\nafter an incident involving aliens.\\nShe arranges the task hierarchically with a manager for the crews working on\\neach house who return with a breakdown of how they will report on progress in\\neach house.\\nThe overall hierarchy of (sub)tasks is as follows,\\nThe head of cleanup knows that her managers will report fractional completion of leaf tasks (tasks with no child tasks of their own), and she knows that she will want to modify the weight of values of completion as she sees fit.\\nSome time into the cleaning, and some coverage reports have come in and she thinks see needs to weight the big house2 60-40 with respect to coverage from house1 She prefers a tabular view of her data where missing weights are assumed to be 1.0 and missing coverage 0.0.\\nThe coverage of a node in the tree is calculated as the weighted average of the coverage of its children evaluated bottom-upwards in the tree.\\nThe task is to calculate the overall coverage of the cleaning task and display the coverage at all levels of the hierarchy on this page, in a manner that visually shows the hierarchy, weights and coverage of all nodes.\\nAfter calculating the coverage for all nodes, one can also calculate the additional/delta top level coverage that would occur if any (sub)task where to be fully covered from its current fractional coverage. This is done by multiplying the extra coverage that could be gained \\n\\n\\n\\n1\\n−\\nc\\no\\nv\\ne\\nr\\na\\ng\\ne\\n\\n\\n{\\displaystyle 1-coverage}\\n\\n for any node, by the product of the `powers` of its parent nodes from the top down to the node.\\nThe power of a direct child of any parent is given by the power of the parent multiplied by the weight of the child divided by the sum of the weights of all the direct children.\\nThe pseudo code would be:\\nFollowed by a call to:\\n\\nNote: to aid in getting the data into your program you might want to use an alternative, more functional description of the starting data given on the discussion page.\\n","from itertools import zip_longest\\n\\n\\nfc2 = '''\\\\ncleaning,,\\n    house1,40,\\n        bedrooms,,.25\\n        bathrooms,,\\n            bathroom1,,.5\\n            bathroom2,,\\n            outside_lavatory,,1\\n        attic,,.75\\n        kitchen,,.1\\n        living_rooms,,\\n            lounge,,\\n            dining_room,,\\n            conservatory,,\\n            playroom,,1\\n        basement,,\\n        garage,,\\n        garden,,.8\\n    house2,60,\\n        upstairs,,\\n            bedrooms,,\\n                suite_1,,\\n                suite_2,,\\n                bedroom_3,,\\n                bedroom_4,,\\n            bathroom,,\\n            toilet,,\\n            attics,,.6\\n        groundfloor,,\\n            kitchen,,\\n            living_rooms,,\\n                lounge,,\\n                dining_room,,\\n                conservatory,,\\n                playroom,,\\n            wet_room_&_toilet,,\\n            garage,,\\n            garden,,.9\\n            hot_tub_suite,,1\\n        basement,,\\n            cellars,,1\\n            wine_cellar,,1\\n            cinema,,.75\\n\\n'''\\n\\nNAME, WT, COV = 0, 1, 2\\n\\ndef right_type(txt):\\n    try:\\n        return float(txt)\\n    except ValueError:\\n        return txt\\n\\ndef commas_to_list(the_list, lines, start_indent=0):\\n    '''\\n    Output format is a nest of lists and tuples\\n    lists are for coverage leaves without children items in the list are name, weight, coverage\\n    tuples are 2-tuples for nodes with children. The first element is a list representing the\\n    name, weight, coverage of the node (some to be calculated); the second element is a list of\\n    child elements which may be 2-tuples or lists as above.\\n    \\n    the_list is modified in-place\\n    lines must be a generator of successive lines of input like fc2\\n    '''\\n    for n, line in lines:\\n        indent = 0\\n        while line.startswith(' ' * (4 * indent)):\\n            indent += 1\\n        indent -= 1\\n        fields = [right_type(f) for f in line.strip().split(',')]\\n        if indent == start_indent:\\n            the_list.append(fields)\\n        elif indent > start_indent:\\n            lst = [fields]\\n            sub = commas_to_list(lst, lines, indent)\\n            the_list[-1] = (the_list[-1], lst)\\n            if sub not in (None, ['']) :\\n                the_list.append(sub)\\n        else:\\n            return fields if fields else None\\n    return None\\n\\n\\ndef pptreefields(lst, indent=0, widths=['%-32s', '%-8g', '%-10g']):\\n    '''\\n    Pretty prints the format described from function commas_to_list as a table with \\n    names in the first column suitably indented and all columns having a fixed \\n    minimum column width.\\n    '''\\n    lhs = ' ' * (4 * indent)\\n    for item in lst:\\n        if type(item) != tuple:\\n            name, *rest = item\\n            print(widths[0] % (lhs + name), end='|')\\n            for width, item in zip_longest(widths[1:len(rest)], rest, fillvalue=widths[-1]):\\n                if type(item) == str:\\n                    width = width[:-1] + 's'\\n                print(width % item, end='|')\\n            print()\\n        else:\\n            item, children = item\\n            name, *rest = item\\n            print(widths[0] % (lhs + name), end='|')\\n            for width, item in zip_longest(widths[1:len(rest)], rest, fillvalue=widths[-1]):\\n                if type(item) == str:\\n                    width = width[:-1] + 's'\\n                print(width % item, end='|')\\n            print()\\n            pptreefields(children, indent+1)\\n\\n\\ndef default_field(node_list):\\n    node_list[WT] = node_list[WT] if node_list[WT] else 1.0\\n    node_list[COV] = node_list[COV] if node_list[COV] else 0.0\\n\\ndef depth_first(tree, visitor=default_field):\\n    for item in tree:\\n        if type(item) == tuple:\\n            item, children = item\\n            depth_first(children, visitor)\\n        visitor(item)\\n            \\n\\ndef covercalc(tree):\\n    '''\\n    Depth first weighted average of coverage\\n    '''\\n    sum_covwt, sum_wt = 0, 0\\n    for item in tree:\\n        if type(item) == tuple:\\n            item, children = item\\n            item[COV] = covercalc(children)\\n        sum_wt  += item[WT]\\n        sum_covwt += item[COV] * item[WT]\\n    cov = sum_covwt / sum_wt\\n    return cov\\n\\nif __name__ == '__main__':        \\n    lstc = []\\n    commas_to_list(lstc, ((n, ln) for n, ln in enumerate(fc2.split('\\n'))))\\n    #pp(lstc, width=1, indent=4, compact=1)\\n    \\n    #print('\\n\\nEXPANDED DEFAULTS\\n')\\n    depth_first(lstc)\\n    #pptreefields(['NAME_HIERARCHY WEIGHT COVERAGE'.split()] + lstc)\\n    \\n    print('\\n\\nTOP COVERAGE = %f\\n' % covercalc(lstc))\\n    depth_first(lstc)\\n    pptreefields(['NAME_HIERARCHY WEIGHT COVERAGE'.split()] + lstc)"
"Python","Functional_coverage_tree","Functional coverage is a measure of how much a particular function of a system\\nhas been verified as correct. It is used heavily in tracking the completeness\\nof the verification of complex System on Chip (SoC) integrated circuits, where\\nit can also be used to track how well the functional requirements of the\\nsystem have been verified.\\nThis task uses a sub-set of the calculations sometimes used in tracking\\nfunctional coverage but uses a more familiar(?) scenario.\\nThe head of the clean-up crews for \""The Men in a very dark shade of grey when\\nviewed at night\"" has been tasked with managing the cleansing of two properties\\nafter an incident involving aliens.\\nShe arranges the task hierarchically with a manager for the crews working on\\neach house who return with a breakdown of how they will report on progress in\\neach house.\\nThe overall hierarchy of (sub)tasks is as follows,\\nThe head of cleanup knows that her managers will report fractional completion of leaf tasks (tasks with no child tasks of their own), and she knows that she will want to modify the weight of values of completion as she sees fit.\\nSome time into the cleaning, and some coverage reports have come in and she thinks see needs to weight the big house2 60-40 with respect to coverage from house1 She prefers a tabular view of her data where missing weights are assumed to be 1.0 and missing coverage 0.0.\\nThe coverage of a node in the tree is calculated as the weighted average of the coverage of its children evaluated bottom-upwards in the tree.\\nThe task is to calculate the overall coverage of the cleaning task and display the coverage at all levels of the hierarchy on this page, in a manner that visually shows the hierarchy, weights and coverage of all nodes.\\nAfter calculating the coverage for all nodes, one can also calculate the additional/delta top level coverage that would occur if any (sub)task where to be fully covered from its current fractional coverage. This is done by multiplying the extra coverage that could be gained \\n\\n\\n\\n1\\n−\\nc\\no\\nv\\ne\\nr\\na\\ng\\ne\\n\\n\\n{\\displaystyle 1-coverage}\\n\\n for any node, by the product of the `powers` of its parent nodes from the top down to the node.\\nThe power of a direct child of any parent is given by the power of the parent multiplied by the weight of the child divided by the sum of the weights of all the direct children.\\nThe pseudo code would be:\\nFollowed by a call to:\\n\\nNote: to aid in getting the data into your program you might want to use an alternative, more functional description of the starting data given on the discussion page.\\n","# -*- coding: utf-8 -*-\\n\\nSPACES = 4\\nclass Node:\\n    path2node = {}\\n    \\n    def add_node(self, pathname, wt, cov):\\n        path2node = self.path2node\\n        path, name = pathname.strip().rsplit('/', 1)\\n        node = Node(name, wt, cov)\\n        path2node[pathname] = node\\n        path2node[path].child.append(node) # Link the tree\\n\\n    def __init__(self, name=\""\"", wt=1, cov=0.0, child=None):\\n        if child is None:\\n            child = []\\n        self.name, self.wt, self.cov, self.child = name, wt, cov, child\\n        self.delta = None\\n        self.sum_wt = wt\\n        if name == \""\"": \\n            # designate the top of the tree\\n            self.path2node[name] = self\\n    \\n    \\n    def __repr__(self, indent=0):\\n        name, wt, cov, delta, child = (self.name, self.wt, self.cov, \\n                                       self.delta, self.child)\\n        lhs = ' ' * (SPACES * indent) + \""Node(%r,\"" % name\\n        txt = '%-40s wt=%2g, cov=%-8.5g, delta=%-10s, child=[' \\\\n              % (lhs, wt, cov, ('n/a' if delta is None else '%-10.7f' % delta))\\n        if not child:\\n            txt += (']),\\n')\\n        else:\\n            txt += ('\\n')\\n            for c in child:\\n                txt += c.__repr__(indent + 1)\\n            txt += (' ' * (SPACES * indent) + \""]),\\n\"")\\n        return txt\\n\\n    def covercalc(self):\\n        '''\\n        Depth first weighted average of coverage\\n        '''\\n        child = self.child\\n        if not child:\\n            return self.cov\\n        sum_covwt, sum_wt = 0, 0\\n        for node in child:\\n            nwt = node.wt\\n            ncov = node.covercalc()\\n            sum_wt += nwt\\n            sum_covwt += ncov * nwt\\n        cov = sum_covwt / sum_wt\\n        self.sum_wt = sum_wt\\n        self.cov = cov\\n        return cov\\n\\n    def deltacalc(self, power=1.0):\\n        '''\\n        Top down distribution of weighted residuals\\n        '''\\n        sum_wt = self.sum_wt\\n        self.delta = delta = (1 - self.cov) * power\\n        for node in self.child:\\n            node.deltacalc(power * node.wt / sum_wt)\\n        return delta\\n\\n\\ndef isclose(a, b, rel_tol=1e-9, abs_tol=1e-9):\\n    return abs(a-b) <= max( rel_tol * max(abs(a), abs(b)), abs_tol )\\n    \\n    \\nif __name__ == '__main__': \\n    top = Node()    # Add placeholder for top of tree\\n    add_node = top.add_node\\n    \\n    add_node('/cleaning', 1, 0)\\n    add_node('/cleaning/house1', 40, 0)\\n    add_node('/cleaning/house1/bedrooms', 1, 0.25)\\n    add_node('/cleaning/house1/bathrooms', 1, 0)\\n    add_node('/cleaning/house1/bathrooms/bathroom1', 1, 0.5)\\n    add_node('/cleaning/house1/bathrooms/bathroom2', 1, 0)\\n    add_node('/cleaning/house1/bathrooms/outside_lavatory', 1, 1)\\n    add_node('/cleaning/house1/attic', 1, 0.75)\\n    add_node('/cleaning/house1/kitchen', 1, 0.1)\\n    add_node('/cleaning/house1/living_rooms', 1, 0)\\n    add_node('/cleaning/house1/living_rooms/lounge', 1, 0)\\n    add_node('/cleaning/house1/living_rooms/dining_room', 1, 0)\\n    add_node('/cleaning/house1/living_rooms/conservatory', 1, 0)\\n    add_node('/cleaning/house1/living_rooms/playroom', 1, 1)\\n    add_node('/cleaning/house1/basement', 1, 0)\\n    add_node('/cleaning/house1/garage', 1, 0)\\n    add_node('/cleaning/house1/garden', 1, 0.8)\\n    add_node('/cleaning/house2', 60, 0)\\n    add_node('/cleaning/house2/upstairs', 1, 0)\\n    add_node('/cleaning/house2/upstairs/bedrooms', 1, 0)\\n    add_node('/cleaning/house2/upstairs/bedrooms/suite_1', 1, 0)\\n    add_node('/cleaning/house2/upstairs/bedrooms/suite_2', 1, 0)\\n    add_node('/cleaning/house2/upstairs/bedrooms/bedroom_3', 1, 0)\\n    add_node('/cleaning/house2/upstairs/bedrooms/bedroom_4', 1, 0)\\n    add_node('/cleaning/house2/upstairs/bathroom', 1, 0)\\n    add_node('/cleaning/house2/upstairs/toilet', 1, 0)\\n    add_node('/cleaning/house2/upstairs/attics', 1, 0.6)\\n    add_node('/cleaning/house2/groundfloor', 1, 0)\\n    add_node('/cleaning/house2/groundfloor/kitchen', 1, 0)\\n    add_node('/cleaning/house2/groundfloor/living_rooms', 1, 0)\\n    add_node('/cleaning/house2/groundfloor/living_rooms/lounge', 1, 0)\\n    add_node('/cleaning/house2/groundfloor/living_rooms/dining_room', 1, 0)\\n    add_node('/cleaning/house2/groundfloor/living_rooms/conservatory', 1, 0)\\n    add_node('/cleaning/house2/groundfloor/living_rooms/playroom', 1, 0)\\n    add_node('/cleaning/house2/groundfloor/wet_room_&_toilet', 1, 0)\\n    add_node('/cleaning/house2/groundfloor/garage', 1, 0)\\n    add_node('/cleaning/house2/groundfloor/garden', 1, 0.9)\\n    add_node('/cleaning/house2/groundfloor/hot_tub_suite', 1, 1)\\n    add_node('/cleaning/house2/basement', 1, 0)\\n    add_node('/cleaning/house2/basement/cellars', 1, 1)\\n    add_node('/cleaning/house2/basement/wine_cellar', 1, 1)\\n    add_node('/cleaning/house2/basement/cinema', 1, 0.75)\\n\\n    top = top.child[0]  # Remove artificial top\\n    cover = top.covercalc()\\n    delta = top.deltacalc()\\n    print('TOP COVERAGE = %g\\n' % cover)\\n    print(top)\\n    assert isclose((delta + cover), 1.0), \""Top level delta + coverage should \"" \\\\n                                          \""equal 1 instead of (%f + %f)\"" % (delta, cover)\\n"
"Python","Fusc_sequence","\\nThe   fusc   integer sequence is defined as:\\n\\nNote that MathWorld's definition starts with unity, not zero.   this task will be using the OEIS' version   (above).\\n\\nwhere   A   is some non-negative integer expressed in binary,   and\\nwhere   B   is the binary value of   A   reversed.\\n\\nFusc numbers are also known as:\\n\\n\\n\\n\\n","# fusc :: Int -> Int\\ndef fusc(i):\\n    def go(n):\\n        if 0 == n:\\n            return (1, 0)\\n        else:\\n            x, y = go(n // 2)\\n            return (x + y, y) if 0 == n % 2 else (\\n                x, x + y\\n            )\\n    return 0 if 1 > i else (\\n        go(i - 1)[0]\\n    )\\n\\n\\n# main :: IO()\\ndef main():\\n    print ('First 61 terms:')\\n    print (\\n        list(map(fusc, range(0, 61)))\\n    )\\n    print ('\\n(Index, Value):')\\n\\n    # Up to five digits\\n    for tpl in firstWidths(5):\\n        print (tpl)\\n\\n\\n# firstWidths :: Int -> [(Int, Int)]\\ndef firstWidths(n):\\n    # nxtFusc :: (Int, Int) -> (Int, Int)\\n    def nxtFusc(tpl):\\n        i = 1 + tpl[1]\\n        return (fusc(i), i)\\n\\n    # nxtWidth :: [(Int, Int, Int)] -> [(Int, Int, Int)]\\n    def nxtWidth(xs):\\n        '''(width, index, value)'''\\n        w, i, v = xs[0]\\n        x, j = until(lambda tpl: w <= len(str(tpl[0])))(\\n            nxtFusc\\n        )((fusc(i), i))\\n        return [(1 + w, j, x)] + xs\\n\\n    # go :: Int -> [(Int, Int, Int)]\\n    def go(n):\\n        return until(lambda xs: n <= len(xs))(\\n            nxtWidth\\n        )([(2, 1, 1)])\\n    return list(map(lambda tpl: tpl[1:], reversed(go(n))))\\n\\n\\n# GENERIC -------------------------------------------------\\n\\n\\n# until :: (a -> Bool) -> (a -> a) -> a -> a\\ndef until(p):\\n    def go(f, x):\\n        v = x\\n        while not p(v):\\n            v = f(v)\\n        return v\\n    return lambda f: lambda x: go(f, x)\\n\\n\\n# TEST ----------------------------------------------------\\nif __name__ == '__main__':\\n    main()"
"Python","Galton_box_animation","Generate an animated simulation of Sir Francis Galton's device.\\nIn a Galton box, there are a set of pins arranged in a triangular pattern.\\nA number of balls are dropped so that they fall in line with the top pin, deflecting to the left or the right of the pin. The ball continues to fall to the left or right of subsequent pins before arriving at one of the collection points between and to the sides of the bottom row of pins.\\nFor the purpose of this task the box should have at least 5 pins on the bottom row.\\nYour solution can use graphics or ASCII animation.\\nProvide a sample of the output/display such as a screenshot.\\nYour solution can have either one or more balls in flight at the same time.\\nIf multiple balls are in flight, ensure they don't interfere with each other.\\nYour solution should allow users to specify the number of balls or it should run until full or a preset limit. Optionally, display the number of balls.\\nUses an edit box for the (text based) animation\\nWindows GDI version.\\nTo keep the code simpler some corner cases are ignored.\\n","#!/usr/bin/python\\n\\nimport sys, os\\nimport random\\nimport time\\n\\ndef print_there(x, y, text):\\n     sys.stdout.write(\""\\x1b7\\x1b[%d;%df%s\\x1b8\"" % (x, y, text))\\n     sys.stdout.flush()\\n\\n\\nclass Ball():\\n    def __init__(self):\\n        self.x = 0\\n        self.y = 0\\n        \\n    def update(self):\\n        self.x += random.randint(0,1)\\n        self.y += 1\\n\\n    def fall(self):\\n        self.y +=1\\n\\n\\nclass Board():\\n    def __init__(self, width, well_depth, N):\\n        self.balls = []\\n        self.fallen = [0] * (width + 1)\\n        self.width = width\\n        self.well_depth = well_depth\\n        self.N = N\\n        self.shift = 4\\n        \\n    def update(self):\\n        for ball in self.balls:\\n            if ball.y < self.width:\\n                ball.update()\\n            elif ball.y < self.width + self.well_depth - self.fallen[ball.x]:\\n                ball.fall()\\n            elif ball.y == self.width + self.well_depth - self.fallen[ball.x]:\\n                self.fallen[ball.x] += 1\\n            else:\\n                pass\\n                \\n    def balls_on_board(self):\\n        return len(self.balls) - sum(self.fallen)\\n                \\n    def add_ball(self):\\n        if(len(self.balls) <= self.N):\\n            self.balls.append(Ball())\\n\\n    def print_board(self):\\n        for y in range(self.width + 1):\\n            for x in range(y):\\n                print_there( y + 1 ,self.width - y + 2*x + self.shift + 1, \""#\"")\\n    def print_ball(self, ball):\\n        if ball.y <= self.width:\\n            x = self.width - ball.y + 2*ball.x + self.shift\\n        else:\\n            x = 2*ball.x + self.shift\\n        y = ball.y + 1\\n        print_there(y, x, \""*\"")\\n         \\n    def print_all(self):\\n        print(chr(27) + \""[2J\"")\\n        self.print_board();\\n        for ball in self.balls:\\n            self.print_ball(ball)\\n\\n\\ndef main():\\n    board = Board(width = 15, well_depth = 5, N = 10)\\n    board.add_ball() #initialization\\n    while(board.balls_on_board() > 0):\\n         board.print_all()\\n         time.sleep(0.25)\\n         board.update()\\n         board.print_all()\\n         time.sleep(0.25)\\n         board.update()\\n         board.add_ball()\\n\\n\\nif __name__==\""__main__\"":\\n    main()"
"Python","Gamma_function","Implement one algorithm (or more) to compute the Gamma (\\n\\n\\n\\nΓ\\n\\n\\n{\\displaystyle \\Gamma }\\n\\n) function (in the real field only).\\nIf your language has the function as built-in or you know a library which has it, compare your implementation's results with the results of the built-in/library function.\\nThe Gamma function can be defined as:\\nThis suggests a straightforward (but inefficient) way of computing the \\n\\n\\n\\nΓ\\n\\n\\n{\\displaystyle \\Gamma }\\n\\n through numerical integration.\\n\\nBetter suggested methods:\\n\\nFor maximum compatibility, this program uses only the basic instruction set.\\n","_a =    ( 1.00000000000000000000, 0.57721566490153286061, -0.65587807152025388108,\\n         -0.04200263503409523553, 0.16653861138229148950, -0.04219773455554433675,\\n         -0.00962197152787697356, 0.00721894324666309954, -0.00116516759185906511,\\n         -0.00021524167411495097, 0.00012805028238811619, -0.00002013485478078824,\\n         -0.00000125049348214267, 0.00000113302723198170, -0.00000020563384169776,\\n          0.00000000611609510448, 0.00000000500200764447, -0.00000000118127457049,\\n          0.00000000010434267117, 0.00000000000778226344, -0.00000000000369680562,\\n          0.00000000000051003703, -0.00000000000002058326, -0.00000000000000534812,\\n          0.00000000000000122678, -0.00000000000000011813, 0.00000000000000000119,\\n          0.00000000000000000141, -0.00000000000000000023, 0.00000000000000000002\\n       )\\ndef gamma (x): \\n   y  = float(x) - 1.0;\\n   sm = _a[-1];\\n   for an in _a[-2::-1]:\\n      sm = sm * y + an;\\n   return 1.0 / sm;\\n \\n\\nif __name__ == '__main__':\\n    for i in range(1,11):\\n        print \""  %20.14e\"" % gamma(i/3.0)\\n"
"Python","Gaussian_elimination","Solve   Ax=b   using Gaussian elimination then backwards substitution.\\nA   being an   n by n   matrix.\\nAlso,   x and b   are   n by 1   vectors.\\nTo improve accuracy, please use partial pivoting and scaling.\\n\\n\\n","# The 'gauss' function takes two matrices, 'a' and 'b', with 'a' square, and it return the determinant of 'a' and a matrix 'x' such that a*x = b.\\n# If 'b' is the identity, then 'x' is the inverse of 'a'.\\n\\nimport copy\\nfrom fractions import Fraction\\n\\ndef gauss(a, b):\\n    a = copy.deepcopy(a)\\n    b = copy.deepcopy(b)\\n    n = len(a)\\n    p = len(b[0])\\n    det = 1\\n    for i in range(n - 1):\\n        k = i\\n        for j in range(i + 1, n):\\n            if abs(a[j][i]) > abs(a[k][i]):\\n                k = j\\n        if k != i:\\n            a[i], a[k] = a[k], a[i]\\n            b[i], b[k] = b[k], b[i]\\n            det = -det\\n            \\n        for j in range(i + 1, n):\\n            t = a[j][i]/a[i][i]\\n            for k in range(i + 1, n):\\n                a[j][k] -= t*a[i][k]\\n            for k in range(p):\\n                b[j][k] -= t*b[i][k]\\n                \\n    for i in range(n - 1, -1, -1):\\n        for j in range(i + 1, n):\\n            t = a[i][j]\\n            for k in range(p):\\n                b[i][k] -= t*b[j][k]\\n        t = 1/a[i][i]\\n        det *= a[i][i]\\n        for j in range(p):\\n            b[i][j] *= t\\n    return det, b\\n\\ndef zeromat(p, q):\\n    return [[0]*q for i in range(p)]\\n\\ndef matmul(a, b):\\n    n, p = len(a), len(a[0])\\n    p1, q = len(b), len(b[0])\\n    if p != p1:\\n        raise ValueError(\""Incompatible dimensions\"")\\n    c = zeromat(n, q)\\n    for i in range(n):\\n        for j in range(q):\\n                c[i][j] = sum(a[i][k]*b[k][j] for k in range(p))\\n    return c\\n\\n\\ndef mapmat(f, a):\\n    return [list(map(f, v)) for v in a]\\n\\ndef ratmat(a):\\n    return mapmat(Fraction, a)\\n\\n# As an example, compute the determinant and inverse of 3x3 magic square\\n\\na = [[2, 9, 4], [7, 5, 3], [6, 1, 8]]\\nb = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\\ndet, c = gauss(a, b)\\n\\ndet\\n-360.0\\n\\nc\\n[[-0.10277777777777776, 0.18888888888888888, -0.019444444444444438],\\n[0.10555555555555554, 0.02222222222222223, -0.061111111111111116],\\n[0.0638888888888889, -0.14444444444444446, 0.14722222222222223]]\\n\\n# Check product\\nmatmul(a, c)\\n[[1.0, 0.0, 0.0], [5.551115123125783e-17, 1.0, 0.0],\\n[1.1102230246251565e-16, -2.220446049250313e-16, 1.0]]\\n\\n# Same with fractions, so the result is exact\\n\\ndet, c = gauss(ratmat(a), ratmat(b))\\n\\ndet\\nFraction(-360, 1)\\n\\nc\\n[[Fraction(-37, 360), Fraction(17, 90), Fraction(-7, 360)],\\n[Fraction(19, 180), Fraction(1, 45), Fraction(-11, 180)],\\n[Fraction(23, 360), Fraction(-13, 90), Fraction(53, 360)]]\\n\\nmatmul(a, c)\\n[[Fraction(1, 1), Fraction(0, 1), Fraction(0, 1)],\\n[Fraction(0, 1), Fraction(1, 1), Fraction(0, 1)],\\n[Fraction(0, 1), Fraction(0, 1), Fraction(1, 1)]]"
"Python","Gaussian_elimination","Solve   Ax=b   using Gaussian elimination then backwards substitution.\\nA   being an   n by n   matrix.\\nAlso,   x and b   are   n by 1   vectors.\\nTo improve accuracy, please use partial pivoting and scaling.\\n\\n\\n","\\n$ python3\\nPython 3.6.0 |Anaconda custom (64-bit)| (default, Dec 23 2016, 12:22:00) \\n[GCC 4.4.7 20120313 (Red Hat 4.4.7-1)] on linux\\nType \""help\"", \""copyright\"", \""credits\"" or \""license\"" for more information.\\n>>> # https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.solve.html\\n>>> import numpy.linalg\\n>>> a = [[2, 9, 4], [7, 5, 3], [6, 1, 8]]\\n>>> b = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\\n>>> numpy.linalg.solve(a,b)\\narray([[-0.10277778,  0.18888889, -0.01944444],\\n       [ 0.10555556,  0.02222222, -0.06111111],\\n       [ 0.06388889, -0.14444444,  0.14722222]])\\n>>>\\n"
"Python","General_FizzBuzz","Write a generalized version of FizzBuzz that works for any list of factors, along with their words.\\nThis is basically a \""fizzbuzz\"" implementation where the user supplies the parameters.\\nThe user will enter the max number, then they will enter the factors to be calculated along with the corresponding word to be printed.\\nFor simplicity's sake, assume the user will input an integer as the max number and 3 factors, each with a word associated with them.\\n\\nFor example, given:\\nIn other words: For this example, print the numbers 1 through 20, replacing every multiple of 3 with \""Fizz\"", every multiple of 5 with \""Buzz\"", and every multiple of 7 with \""Baxx\"".\\nIn the case where a number is a multiple of at least two factors, print each of the words associated with those factors in the order of least to greatest factor.\\nFor instance, the number 15 is a multiple of both 3 and 5; print \""FizzBuzz\"".\\nIf the max number was 105 instead of 20, you would print \""FizzBuzzBaxx\"" because it's a multiple of 3, 5, and 7.\\n","def genfizzbuzz(factorwords, numbers):\\n    factorwords.sort(key=lambda p: p[0])\\n    lines = []\\n    for num in numbers:\\n        words = ''.join(wrd for fact, wrd in factorwords if (num % fact) == 0)\\n        lines.append(words if words else str(num))\\n    return '\\n'.join(lines)\\n\\nif __name__ == '__main__':\\n    print(genfizzbuzz([(5, 'Buzz'), (3, 'Fizz'), (7, 'Baxx')], range(1, 21)))"
"Python","General_FizzBuzz","Write a generalized version of FizzBuzz that works for any list of factors, along with their words.\\nThis is basically a \""fizzbuzz\"" implementation where the user supplies the parameters.\\nThe user will enter the max number, then they will enter the factors to be calculated along with the corresponding word to be printed.\\nFor simplicity's sake, assume the user will input an integer as the max number and 3 factors, each with a word associated with them.\\n\\nFor example, given:\\nIn other words: For this example, print the numbers 1 through 20, replacing every multiple of 3 with \""Fizz\"", every multiple of 5 with \""Buzz\"", and every multiple of 7 with \""Baxx\"".\\nIn the case where a number is a multiple of at least two factors, print each of the words associated with those factors in the order of least to greatest factor.\\nFor instance, the number 15 is a multiple of both 3 and 5; print \""FizzBuzz\"".\\nIf the max number was 105 instead of 20, you would print \""FizzBuzzBaxx\"" because it's a multiple of 3, 5, and 7.\\n","from collections import defaultdict\\n\\nn = 100\\nmods = {\\n    3: \""Fizz\"",\\n    5: \""Buzz\"",\\n}\\n\\ndef fizzbuzz(n=n, mods=mods):\\n    factors = defaultdict(list)\\n    for mod in mods:\\n        factors[mod].append(mod)\\n\\n    for i in range(1,n+1):\\n        res = ''\\n        for mod in sorted(factors[i]):\\n            factors[i+mod].append(mod)\\n            res += mods[mod]\\n        del factors[i]\\n        yield res or str(i)\\n\\nif __name__ == '__main__':\\n    n = int(input())\\n    mods = { int(k): v for k,v in (input().split(maxsplit=1) for _ in range(3)) }\\n    for line in fizzbuzz(n, mods):\\n        print(line)\\n"
"Python","General_FizzBuzz","Write a generalized version of FizzBuzz that works for any list of factors, along with their words.\\nThis is basically a \""fizzbuzz\"" implementation where the user supplies the parameters.\\nThe user will enter the max number, then they will enter the factors to be calculated along with the corresponding word to be printed.\\nFor simplicity's sake, assume the user will input an integer as the max number and 3 factors, each with a word associated with them.\\n\\nFor example, given:\\nIn other words: For this example, print the numbers 1 through 20, replacing every multiple of 3 with \""Fizz\"", every multiple of 5 with \""Buzz\"", and every multiple of 7 with \""Baxx\"".\\nIn the case where a number is a multiple of at least two factors, print each of the words associated with those factors in the order of least to greatest factor.\\nFor instance, the number 15 is a multiple of both 3 and 5; print \""FizzBuzz\"".\\nIf the max number was 105 instead of 20, you would print \""FizzBuzzBaxx\"" because it's a multiple of 3, 5, and 7.\\n","from collections import defaultdict\\n\\nn = 100\\nmods = [\\n    (3, 'Fizz'),\\n    (5, 'Buzz'),\\n]\\n\\ndef fizzbuzz(n=n, mods=mods):\\n    res = defaultdict(str)\\n\\n    for num, name in mods:\\n        for i in range(num, n+1, num):\\n            res[i] += name\\n\\n    return '\\n'.join(res[i] or str(i) for i in range(1, n+1))\\n\\n\\nif __name__ == '__main__':\\n    n = int(input())\\n\\n    mods = []\\n    while len(mods) != 3:   # for reading until EOF change 3 to -1\\n        try:\\n            line = input()\\n        except EOFError:\\n            break\\n        idx = line.find(' ')                        # preserves whitespace\\n        num, name = int(line[:idx]), line[idx+1:]   #   after the first space\\n        mods.append((num, name))    # preserves order and duplicate moduli\\n\\n    print(fizzbuzz(n, mods))\\n"
"Python","General_FizzBuzz","Write a generalized version of FizzBuzz that works for any list of factors, along with their words.\\nThis is basically a \""fizzbuzz\"" implementation where the user supplies the parameters.\\nThe user will enter the max number, then they will enter the factors to be calculated along with the corresponding word to be printed.\\nFor simplicity's sake, assume the user will input an integer as the max number and 3 factors, each with a word associated with them.\\n\\nFor example, given:\\nIn other words: For this example, print the numbers 1 through 20, replacing every multiple of 3 with \""Fizz\"", every multiple of 5 with \""Buzz\"", and every multiple of 7 with \""Baxx\"".\\nIn the case where a number is a multiple of at least two factors, print each of the words associated with those factors in the order of least to greatest factor.\\nFor instance, the number 15 is a multiple of both 3 and 5; print \""FizzBuzz\"".\\nIf the max number was 105 instead of 20, you would print \""FizzBuzzBaxx\"" because it's a multiple of 3, 5, and 7.\\n","def genfizzbuzz(numberlist, wordlist, *args):\\n    nml = [[numberlist[i], wordlist[i]] for i in range(len(numberlist))]\\n    for z in range(*args):\\n        res = \""\""\\n        for j in nml:\\n            if z % j[0] == 0:\\n                res += j[1]\\n        print(res or z)\\n\\n\\ngenfizzbuzz([3, 5, 7], ['Fizz', 'Buzz', 'Baxx'], 1, 21)\\n"
"Python","General_FizzBuzz","Write a generalized version of FizzBuzz that works for any list of factors, along with their words.\\nThis is basically a \""fizzbuzz\"" implementation where the user supplies the parameters.\\nThe user will enter the max number, then they will enter the factors to be calculated along with the corresponding word to be printed.\\nFor simplicity's sake, assume the user will input an integer as the max number and 3 factors, each with a word associated with them.\\n\\nFor example, given:\\nIn other words: For this example, print the numbers 1 through 20, replacing every multiple of 3 with \""Fizz\"", every multiple of 5 with \""Buzz\"", and every multiple of 7 with \""Baxx\"".\\nIn the case where a number is a multiple of at least two factors, print each of the words associated with those factors in the order of least to greatest factor.\\nFor instance, the number 15 is a multiple of both 3 and 5; print \""FizzBuzz\"".\\nIf the max number was 105 instead of 20, you would print \""FizzBuzzBaxx\"" because it's a multiple of 3, 5, and 7.\\n","n = 20\\nmappings = {3: \""Fizz\"", 5: \""Buzz\"", 7: \""Baxx\""}\\nfor i in range(1, n+1): print(''.join(word*(i%key==0) for  key, word in mappings.items()) or i) "
"Python","Generate_Chess960_starting_position","Chess960 is a variant of chess created by world champion Bobby Fischer. Unlike other variants of the game, Chess960 does not require a different material, but instead relies on a random initial position, with a few constraints:\\n\\nWith those constraints there are 960 possible starting positions, thus the name of the variant.\\n\\nThe purpose of this task is to write a program that can randomly generate any one of the 960 Chess960 initial positions. You will show the result as the first rank displayed with Chess symbols in Unicode: ♔♕♖♗♘ or with the letters King Queen Rook Bishop kNight.\\n\\n",">>> from itertools import permutations\\n>>> pieces = 'KQRrBbNN'\\n>>> starts = {''.join(p).upper() for p in permutations(pieces)\\n                     if p.index('B') % 2 != p.index('b') % 2 		# Bishop constraint\\n                     and ( p.index('r') < p.index('K') < p.index('R')	# King constraint	\\n                           or p.index('R') < p.index('K') < p.index('r') ) }\\n>>> len(starts)\\n960\\n>>> starts.pop()\\n'QNBRNKRB'\\n>>>"
"Python","Generate_Chess960_starting_position","Chess960 is a variant of chess created by world champion Bobby Fischer. Unlike other variants of the game, Chess960 does not require a different material, but instead relies on a random initial position, with a few constraints:\\n\\nWith those constraints there are 960 possible starting positions, thus the name of the variant.\\n\\nThe purpose of this task is to write a program that can randomly generate any one of the 960 Chess960 initial positions. You will show the result as the first rank displayed with Chess symbols in Unicode: ♔♕♖♗♘ or with the letters King Queen Rook Bishop kNight.\\n\\n",">>> import re\\n>>> pieces = 'KQRRBBNN'\\n>>> bish = re.compile(r'B(|..|....|......)B').search\\n>>> king = re.compile(r'R.*K.*R').search\\n>>> starts3 = {p for p in (''.join(q) for q in permutations(pieces))\\n            if bish(p) and king(p)}\\n>>> len(starts3)\\n960\\n>>> starts3.pop()\\n'QRNKBNRB'\\n>>>"
"Python","Generate_Chess960_starting_position","Chess960 is a variant of chess created by world champion Bobby Fischer. Unlike other variants of the game, Chess960 does not require a different material, but instead relies on a random initial position, with a few constraints:\\n\\nWith those constraints there are 960 possible starting positions, thus the name of the variant.\\n\\nThe purpose of this task is to write a program that can randomly generate any one of the 960 Chess960 initial positions. You will show the result as the first rank displayed with Chess symbols in Unicode: ♔♕♖♗♘ or with the letters King Queen Rook Bishop kNight.\\n\\n","from random import choice\\n\\ndef random960():\\n    start = ['R', 'K', 'R']         # Subsequent order unchanged by insertions.\\n    #\\n    for piece in ['Q', 'N', 'N']:\\n        start.insert(choice(range(len(start)+1)), piece)\\n    #\\n    bishpos = choice(range(len(start)+1))\\n    start.insert(bishpos, 'B')\\n    start.insert(choice(range(bishpos + 1, len(start) + 1, 2)), 'B')\\n    return start\\n    return ''.join(start).upper()\\n\\nprint(random960())"
"Python","Generate_Chess960_starting_position","Chess960 is a variant of chess created by world champion Bobby Fischer. Unlike other variants of the game, Chess960 does not require a different material, but instead relies on a random initial position, with a few constraints:\\n\\nWith those constraints there are 960 possible starting positions, thus the name of the variant.\\n\\nThe purpose of this task is to write a program that can randomly generate any one of the 960 Chess960 initial positions. You will show the result as the first rank displayed with Chess symbols in Unicode: ♔♕♖♗♘ or with the letters King Queen Rook Bishop kNight.\\n\\n","from random import choice\\n\\ndef generate960():\\n    start = ('R', 'K', 'R')         # Subsequent order unchanged by insertions.\\n\\n    # Insert QNN in all combinations of places\\n    starts = {start}\\n    for piece in ['Q', 'N', 'N']:\\n        starts2 = set()\\n        for s in starts:\\n            for pos in range(len(s)+1):\\n                s2 = list(s)\\n                s2.insert(pos, piece)\\n                starts2.add(tuple(s2))\\n        starts = starts2\\n    \\n    # For each of the previous starting positions insert the bishops in their 16 positions\\n    starts2 = set()\\n    for s in starts:\\n        for bishpos in range(len(s)+1):\\n            s2 = list(s)\\n            s2.insert(bishpos, 'B')\\n            for bishpos2 in range(bishpos+1, len(s)+2, 2):\\n                s3 = s2[::]\\n                s3.insert(bishpos2, 'B')\\n                starts2.add(tuple(s3))\\n                \\n    return  list(starts2)\\n\\ngen = generate960()\\nprint(''.join(choice(gen)))"
"Python","Generate_lower_case_ASCII_alphabet","Generate an array, list, lazy sequence, or even an indexable string of all the lower case ASCII characters, from  a  to  z. If the standard library contains such a sequence, show how to access it, but don't fail to show how to generate a similar sequence.\\nFor this basic task use a reliable style of coding, a style fit for a very large program, and use strong typing if available. It's bug prone to enumerate all the lowercase characters manually in the code. During code review it's not immediate obvious to spot the bug in a Tcl line like this contained in a page of code:\\n\\nThis creates the list in the queue\\nIn EBCDIC coding there are more than 24 characters between a and z.\\nSo we have to get rid of characters between i and j and also between r and s.\\n","# From the standard library:\\nfrom string import ascii_lowercase\\n\\n# Generation:\\nlower = [chr(i) for i in range(ord('a'), ord('z') + 1)]"
"Python","Generate_random_chess_position","The purpose of this task is to generate a random chess position in FEN format. The position does not have to be realistic or even balanced, but it must comply to the following rules:\\n\\nNo requirement is made regarding the probability distribution of your method, but your program should be able to span a reasonably representative sample of all possible positions. For instance, programs that would always generate positions with say five pieces on the board, or with kings on a corner, would not be considered truly random.\\n\\n","\\nimport random\\n\\nboard = [[\"" \"" for x in range(8)] for y in range(8)]\\npiece_list = [\""R\"", \""N\"", \""B\"", \""Q\"", \""P\""]\\n\\n\\ndef place_kings(brd):\\n	while True:\\n		rank_white, file_white, rank_black, file_black = random.randint(0,7), random.randint(0,7), random.randint(0,7), random.randint(0,7)\\n		diff_list = [abs(rank_white - rank_black),  abs(file_white - file_black)]\\n		if sum(diff_list) > 2 or set(diff_list) == set([0, 2]):\\n			brd[rank_white][file_white], brd[rank_black][file_black] = \""K\"", \""k\""\\n			break\\n\\ndef populate_board(brd, wp, bp):\\n	for x in range(2):\\n		if x == 0:\\n			piece_amount = wp\\n			pieces = piece_list\\n		else:\\n			piece_amount = bp\\n			pieces = [s.lower() for s in piece_list]\\n		while piece_amount != 0:\\n			piece_rank, piece_file = random.randint(0, 7), random.randint(0, 7)\\n			piece = random.choice(pieces)\\n			if brd[piece_rank][piece_file] == \"" \"" and pawn_on_promotion_square(piece, piece_rank) == False:\\n				brd[piece_rank][piece_file] = piece\\n				piece_amount -= 1\\n\\ndef fen_from_board(brd):\\n	fen = \""\""\\n	for x in brd:\\n		n = 0\\n		for y in x:\\n			if y == \"" \"":\\n				n += 1\\n			else:\\n				if n != 0:\\n					fen += str(n)\\n				fen += y\\n				n = 0\\n		if n != 0:\\n			fen += str(n)\\n		fen += \""/\"" if fen.count(\""/\"") < 7 else \""\""\\n	fen += \"" w - - 0 1\\n\""\\n	return fen\\n\\ndef pawn_on_promotion_square(pc, pr):\\n	if pc == \""P\"" and pr == 0:\\n		return True\\n	elif pc == \""p\"" and pr == 7:\\n		return True\\n	return False\\n\\n\\ndef start():\\n	piece_amount_white, piece_amount_black = random.randint(0, 15), random.randint(0, 15)\\n	place_kings(board)\\n	populate_board(board, piece_amount_white, piece_amount_black)\\n	print(fen_from_board(board))\\n	for x in board:\\n		print(x)\\n\\n#entry point\\nstart()\\n"
